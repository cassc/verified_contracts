{"SourceCode": "// Sources flattened with hardhat v2.22.6 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol@v1.1.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// solhint-disable-next-line interface-starts-with-i\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\n\r\n// File openzeppelin-contracts-release-v4.9/contracts/utils/Context.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n// File openzeppelin-contracts-release-v4.9/contracts/access/Ownable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File openzeppelin-contracts-release-v4.9/contracts/security/ReentrancyGuard.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/PresaleContract.sol\r\n\r\n/**\r\n * @dev The `PresaleContract` is a comprehensive smart contract designed to manage the presale of SyntraCoin, a custom ERC20 token.\r\n * The contract facilitates multiple rounds of token sales, distributes tokens to participants, manages advisor commissions,\r\n * and handles the deployment of a Uniswap V3 liquidity pool upon the presale's conclusion. It also includes robust mechanisms\r\n * for emergency handling, participant refunds, and owner-controlled operations.\r\n *\r\n * **Key Features:**\r\n * \r\n * 1. **Token Sale Management:**\r\n *    - The presale is divided into four rounds, each with increasing token prices and specific token limits.\r\n *    - Participants can purchase tokens using ETH, and the contract automatically handles ETH-to-USD conversions using Chainlink price feeds.\r\n *    - The contract tracks token purchases and ETH contributions per participant, ensuring correct token distribution once the presale ends.\r\n *    - The presale process is time-bound with a global timer, and it automatically progresses through the rounds as tokens are sold.\r\n * \r\n * 2. **Discount Management:**\r\n *    - The contract includes a refund mechanism where participants can receive a 10% refund of their ETH contribution if they are referred by a valid advisor.\r\n *    - This discount is applied automatically during the purchase process, reducing the total ETH collected by the contract.\r\n * \r\n * 3. **Investor Rights:**\r\n *    - Participants are entitled to receive the tokens they purchased once the presale concludes.\r\n *    - If the presale fails or is canceled, participants have the right to claim a refund of 80% of their ETH contributions.\r\n *    - Investors can monitor their spending and token allocation via the contract's public functions.\r\n * \r\n * 4. **Advisor Rights:**\r\n *    - Advisors can refer participants to the presale and earn a 10% commission on the ETH contributions made by their referred participants.\r\n *    - Advisors must be added by the contract owner to be eligible for commissions.\r\n *    - The contract automatically distributes the advisor\u2019s commission during the purchase process.\r\n * \r\n * 5. **Team Rights:**\r\n *    - The team (represented by the contract owner) receives 20% of the ETH collected from token sales and computer purchases as compensation.\r\n *    - The contract ensures that the team's share is transferred immediately during each purchase transaction.\r\n *    - The team has the right to withdraw remaining funds after the presale concludes, provided the withdrawal conditions are met.\r\n * \r\n * 6. **Ownership and Control (OnlyOwner Functions):**\r\n *    - The contract is owned by a single entity (the owner), who has the authority to perform critical actions:\r\n *      - Add or remove advisors.\r\n *      - Initiate emergency withdrawals if the presale encounters issues.\r\n *      - Deploy the SyntraCoin token and create the Uniswap V3 liquidity pool.\r\n *      - Manage the transition from the presale to the post-sale phase, including token minting and fund management.\r\n *    - The `onlyOwner` modifier restricts sensitive functions to the contract owner, ensuring that only authorized personnel can execute these functions.\r\n * \r\n * 7. **Emergency Handling and Refunds:**\r\n *    - The contract includes mechanisms to handle emergencies and ensure the safety of participant funds.\r\n *    - If the contract fails to safely deploy the SyntraCoin token and liquidity pool, it enters an emergency withdrawal mode.\r\n *    - In emergency mode, the owner can withdraw the remaining funds to prevent loss.\r\n *    - Participants can request a full refund of their ETH contributions if the presale fails, ensuring investor protection.\r\n *\r\n * The `PresaleContract` is a versatile and secure solution for managing the complexities of a token presale, offering various roles and rights \r\n * to participants, advisors, and the project team while ensuring that funds are handled securely and transparently.\r\n */\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.15;\r\n\r\n\r\n\r\n/// @custom:security-contact admin@syntralink.net\r\n\r\ninterface IUniswapAndCoinManager {\r\n    function deployCoinAndPool(uint256 ethForPool) external payable;\r\n    function mintTokens(address participant, uint256 amount) external;\r\n    function coinAddress() external view returns (address);\r\n}\r\n\r\ncontract PresaleContract is Ownable, ReentrancyGuard {\r\n    IUniswapAndCoinManager public _uniswapAndCoinManager; // Interface for the Uniswap and Coin Manager contract\r\n    AggregatorV3Interface internal _priceFeed; // Interface for the Chainlink price feed contract\r\n    uint256 public constant DECIMALS = 1e18; // The number of decimal places for the tokens\r\n    uint256 public constant TOTAL_TOKENS = 40e6 * DECIMALS; // Total supply of tokens for the presale\r\n    uint256 public constant BASE_TRITON_PRICE = 5.7e5; // Base price for the Triton computer in USD cents\r\n    uint256 public constant BASE_HYPERION_PRICE = 7.7e5; // Base price for the Hyperion computer in USD cents\r\n    uint256 public constant BASE_NYX_PRICE = 4.2e5; // Base price for the Nyx computer in USD cents\r\n    uint256 public constant BASE_HECATE_PRICE = 2.2e5; // Base price for the Hecate computer in USD cents\r\n    uint256 public constant GLOBAL_TIMER = 604800 * 26; // Total duration of the presale, calculated as 26 weeks\r\n    uint256 public constant MAX_ROUND = 3; // Maximum number of rounds in the presale\r\n    uint256 public constant ADVISOR_PERCENTAGE = 10; // Percentage of ETH that advisors receive from their referrals\r\n    uint256 public constant REFUND_PERCENTAGE = 10; // Percentage of ETH that discount received\r\n    uint256 public constant TEAM_PERCENTAGE = 20; // Percentage of ETH for the team\r\n    uint256 public constant PERCENTAGE_BASE = 100; // Base value used for percentage calculations\r\n    uint256[4] public _roundPrices = [10, 15, 20, 25]; // Prices per token for each presale round in USD cents\r\n    uint256[4] public _roundTokenLimits = [\r\n        4e6 * DECIMALS, // Token limit for round 1\r\n        8e6 * DECIMALS, // Token limit for round 2\r\n        12e6 * DECIMALS, // Token limit for round 3\r\n        16e6 * DECIMALS // Token limit for round 4\r\n    ];\r\n    uint256 public _currentRound = 0; // Tracks the current presale round\r\n    uint256 public _totalTokensSold = 0; // Total number of tokens sold during the presale\r\n    uint256 public _totalEthSpentInComputers = 0; // Total ETH spent on purchasing computers\r\n    uint256 public _presaleStartedAt = 0; // Timestamp marking the start of the presale      \r\n    mapping(address => uint256) public nonces; //nonces for protection against replay attacks                 \r\n    mapping(address => uint256) public _computerTritonPurchases;\r\n    mapping(address => uint256) public _computerHyperionPurchases;\r\n    mapping(address => uint256) public _computerNyxPurchases;\r\n    mapping(address => uint256) public _computerHecatePurchases;\r\n    mapping(address => uint256) public _tokenPurchases; // Tracks total tokens purchased by each participant\r\n    mapping(uint256 => uint256) public _tokensSoldPerRound; // Tracks total tokens sold per round\r\n    mapping(address => uint256) public _totalEthSpentByAddress; // Tracks total ETH spent by each participant\r\n    mapping(uint256 => mapping(address => uint256))\r\n    public _tokensSoldPerRoundByAddress; // Tracks tokens sold per round by each participant\r\n    mapping(address => address[]) public _investorsByAdvisorAddress; // Maps advisors to their referred investors\r\n    mapping(address => uint256) public _ethAmountByAdvisorAddress; // Tracks ETH owed to each advisor\r\n    mapping(address => uint256) public totalSpent;\r\n    address[] public _participants; // List of all participants in the presale\r\n    address[] public _advisors; // List of all advisors in the presale\r\n    mapping(address => bool) private _validAdvisors;\r\n    event AdvisorAdded(address indexed advisor);\r\n    event AdvisorRemoved(address indexed advisor);\r\n    event TransferCompleted(address indexed advisor, uint256 indexed amount);\r\n    event ComputerPurchased(\r\n        address indexed buyer,\r\n        uint256 indexed amount,\r\n        uint256 indexed ethSpent,\r\n        string computerType\r\n    );\r\n    event TokenPurchased(\r\n        address indexed buyer,\r\n        uint256 indexed amount,\r\n        uint256 indexed ethSpent\r\n    );\r\n    event RoundAdvanced(uint256 indexed newRound);\r\n    event AddressRefunded(address indexed purchaser, uint256 indexed amount);\r\n    event AdvisorAddressesAdded(\r\n        address indexed advisor,\r\n        address[] indexed investorsAddresses\r\n    );\r\n    bool public _isInEmergencyWithdraw = false; // Indicates if the contract is in emergency withdrawal mode\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n\r\n    /**\r\n     * @notice Function to add an advisor, only callable by the contract owner\r\n     * @param advisor - The address of the advisor to be added\r\n     */\r\n     function addAdvisor(address advisor) external onlyOwner {\r\n        require(advisor != address(0), \"Invalid address\"); // @dev Ensures the advisor address is not the zero address\r\n        require(!_validAdvisors[advisor], \"Advisor already added\"); // @dev Checks that the advisor is not already added\r\n        _validAdvisors[advisor] = true; // @dev Marks the advisor as valid\r\n        _advisors.push(advisor); // @dev Adds the advisor to the list of advisors\r\n        emit AdvisorAdded(advisor); // @dev Emits an event signaling the advisor has been added\r\n    }\r\n\r\n    /**\r\n     * @notice Function to remove an advisor, only callable by the contract owner\r\n     * @param advisor - The address of the advisor to be removed\r\n     */\r\n    function removeAdvisor(address advisor) external onlyOwner {\r\n        require(advisor != address(0), \"Invalid address\"); // @dev Ensures the advisor address is not the zero address\r\n        require(_validAdvisors[advisor], \"Advisor not found\"); // @dev Checks that the advisor exists in the list\r\n        _validAdvisors[advisor] = false; // @dev Marks the advisor as invalid\r\n        emit AdvisorRemoved(advisor); // @dev Emits an event signaling the advisor has been removed\r\n    }\r\n\r\n    /*\r\n     * @notice Constructor for initializing the PresaleContract\r\n     * @param uniswapAndCoinManager_ - Address of the Uniswap and Coin Manager contract\r\n     */\r\n    constructor(address uniswapAndCoinManager_) Ownable() {\r\n        require(uniswapAndCoinManager_ != address(0), \"Invalid address\");\r\n        _uniswapAndCoinManager = IUniswapAndCoinManager(uniswapAndCoinManager_);\r\n        _priceFeed = AggregatorV3Interface(\r\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\r\n        );\r\n        _presaleStartedAt = block.timestamp; // Record the start time of the presale\r\n    }\r\n\r\n    /*\r\n     * @dev Internal function to handle the purchase of computers\r\n     * @param amount - The number of computers being purchased\r\n     * @param totalPrice - The total ETH value for the purchase\r\n     * @param purchases - The mapping that tracks purchases by address\r\n     * @param computerType - The type of computer being purchased\r\n     * @param advisor - The address of the advisor\r\n     */\r\n     function _purchaseComputer(\r\n        uint256 amount,\r\n        uint256 totalPrice,\r\n        mapping(address => uint256) storage purchases,\r\n        string memory computerType,\r\n        address advisor\r\n    ) internal {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(msg.value == totalPrice, \"Incorrect ETH sent\");\r\n        nonces[msg.sender]++;\r\n        uint256 teamShare = totalPrice;  // Start by assuming the team gets the full amount\r\n        uint256 advisorShare = 0;\r\n        uint256 refundToSender = 0;\r\n        if (advisor != address(0) && _validAdvisors[advisor]) {\r\n            refundToSender = (totalPrice * REFUND_PERCENTAGE) / PERCENTAGE_BASE; // Calculate a 10% refund to the sender\r\n            advisorShare = (totalPrice * ADVISOR_PERCENTAGE) / PERCENTAGE_BASE; // Calculate 10% for the advisor\r\n            teamShare = totalPrice - refundToSender - advisorShare; // Calculate the remaining share for the team\r\n        } else if (advisor != address(0) && !_validAdvisors[advisor]) {\r\n            revert(\"Invalid advisor address\");\r\n        }\r\n        purchases[msg.sender] += amount; // Update the purchase record for the sender\r\n        _totalEthSpentByAddress[msg.sender] += msg.value; // Update the total ETH spent by the sender\r\n        _totalEthSpentInComputers += msg.value; // Update the total ETH spent on computers\r\n        totalSpent[msg.sender] += msg.value;  // Update the total spent by the participant\r\n        _participants.push(msg.sender); // Update the leaderboard with the sender's address\r\n        (bool successTeam, ) = payable(owner()).call{value: teamShare}(\"\");\r\n        require(successTeam, \"Transfer to team failed\");\r\n        if (advisorShare > 0) {\r\n            (bool successAdvisor, ) = payable(advisor).call{value: advisorShare}(\"\");\r\n            require(successAdvisor, \"Transfer to advisor failed\");\r\n        }\r\n        if (refundToSender > 0) {\r\n            (bool successRefund, ) = payable(msg.sender).call{value: refundToSender}(\"\");\r\n            require(successRefund, \"Refund to sender failed\");\r\n        }\r\n        emit ComputerPurchased(msg.sender, amount, msg.value, computerType); // Emit an event for the purchase\r\n    }\r\n\r\n    /*\r\n     * @notice Function to purchase Triton computers during the presale\r\n     * @param amount - The number of Triton computers to purchase\r\n     */\r\n    function purchaseTriton(uint256 amount, address advisor) external payable nonReentrant {\r\n        _purchaseComputer(\r\n            amount,\r\n            purchaseTriton_price(amount),\r\n            _computerTritonPurchases,\r\n            \"Triton\",\r\n            advisor\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @notice Function to purchase Hyperion computers during the presale\r\n     * @param amount - The number of Hyperion computers to purchase\r\n     */\r\n    function purchaseHyperion(uint256 amount, address advisor) external payable nonReentrant {\r\n        _purchaseComputer(\r\n            amount,\r\n            purchaseHyperion_price(amount),\r\n            _computerHyperionPurchases,\r\n            \"Hyperion\",\r\n            advisor\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @notice Function to purchase Nyx computers during the presale\r\n     * @param amount - The number of Nyx computers to purchase\r\n     */\r\n    function purchaseNyx(uint256 amount, address advisor) external payable nonReentrant {\r\n        _purchaseComputer(\r\n            amount,\r\n            purchaseNyx_price(amount),\r\n            _computerNyxPurchases,\r\n            \"Nyx\",\r\n            advisor\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @notice Function to purchase Hecate computers during the presale\r\n     * @param amount - The number of Hecate computers to purchase\r\n     */\r\n    function purchaseHecate(uint256 amount, address advisor) external payable nonReentrant {\r\n        _purchaseComputer(\r\n            amount,\r\n            purchaseHecate_price(amount),\r\n            _computerHecatePurchases,\r\n            \"Hecate\",\r\n            advisor\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @dev View function to calculate the ETH price for purchasing Triton computers\r\n     * @param amount - The number of Triton computers to purchase\r\n     * @return The total ETH required to purchase the specified number of Triton computers\r\n     */\r\n    function purchaseTriton_price(uint256 amount) public view returns (uint256) {\r\n        return _convertUSDtoETH(BASE_TRITON_PRICE) * amount;\r\n    }\r\n\r\n    /*\r\n     * @dev View function to calculate the ETH price for purchasing Hyperion computers\r\n     * @param amount - The number of Hyperion computers to purchase\r\n     * @return The total ETH required to purchase the specified number of Hyperion computers\r\n     */\r\n    function purchaseHyperion_price(uint256 amount) public view returns (uint256) {\r\n        return _convertUSDtoETH(BASE_HYPERION_PRICE) * amount;\r\n    }\r\n\r\n    /*\r\n     * @dev View function to calculate the ETH price for purchasing Nyx computers\r\n     * @param amount - The number of Nyx computers to purchase\r\n     * @return The total ETH required to purchase the specified number of Nyx computers\r\n     */\r\n    function purchaseNyx_price(uint256 amount) public view returns (uint256) {\r\n        return _convertUSDtoETH(BASE_NYX_PRICE) * amount;\r\n    }\r\n\r\n    /*\r\n     * @dev View function to calculate the ETH price for purchasing Hecate computers\r\n     * @param amount - The number of Hecate computers to purchase\r\n     * @return The total ETH required to purchase the specified number of Hecate computers\r\n     */\r\n    function purchaseHecate_price(uint256 amount) public view returns (uint256) {\r\n        return _convertUSDtoETH(BASE_HECATE_PRICE) * amount;\r\n    }\r\n\r\n    /*\r\n     * @dev View function to get the latest ETH/USD price from the Chainlink price feed\r\n     * @return The latest ETH/USD price in USD\r\n     */\r\n    function _getLatestETHUSDPrice() public view returns (int) {\r\n        (, int answer, , , ) = _priceFeed.latestRoundData();\r\n        return answer / 1e8;\r\n    }\r\n\r\n    /*\r\n     * @dev View function to convert a USD amount to ETH based on the latest price feed data\r\n     * @param amountInUSDCents - The amount in USD cents to convert\r\n     * @return The equivalent amount in ETH\r\n     */\r\n    function _convertUSDtoETH(uint256 amountInUSDCents) public view returns (uint256) {\r\n        uint256 currentETHPrice = uint256(_getLatestETHUSDPrice());\r\n        uint256 result = ((amountInUSDCents * 1e16) / currentETHPrice);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * @notice Function to purchase tokens during the presale\r\n     * @param amount - The number of tokens to purchase\r\n     */\r\n     function purchaseToken(uint256 amount, address advisor) external payable nonReentrant {\r\n        uint256 price = purchaseToken_price(amount);\r\n        uint256 teamShare = (price * TEAM_PERCENTAGE) / PERCENTAGE_BASE;\r\n        uint256 advisorShare = 0;\r\n        uint256 refundToSender = 0;\r\n        uint256 amountToContract = price - teamShare;\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(_totalTokensSold + amount <= TOTAL_TOKENS, \"Exceeds total token supply\");\r\n        require(msg.value == price, \"Incorrect ETH sent\");\r\n        nonces[msg.sender]++;\r\n        if (advisor != address(0) && _validAdvisors[advisor] ) {\r\n            refundToSender = (amountToContract * REFUND_PERCENTAGE) / PERCENTAGE_BASE; // Calculate 10% refund to the sender\r\n            advisorShare = (amountToContract * ADVISOR_PERCENTAGE) / PERCENTAGE_BASE; // Calculate 10% for the advisor\r\n            amountToContract = amountToContract - refundToSender - advisorShare; // Reduce the contract amount by the refund\r\n        } \r\n        _tokenPurchases[msg.sender] += amount;\r\n        _tokensSoldPerRound[_currentRound] += amount;\r\n        _tokensSoldPerRoundByAddress[_currentRound][msg.sender] += amount;\r\n        _totalEthSpentByAddress[msg.sender] += msg.value;\r\n        totalSpent[msg.sender] += msg.value;\r\n        _updateRoundProgress(amount);\r\n        _participants.push(msg.sender);\r\n        (bool successTeam, ) = payable(owner()).call{value: teamShare}(\"\");\r\n        require(successTeam, \"Transfer to team failed\");\r\n        (bool successContract, ) = address(this).call{value: amountToContract}(\"\");\r\n        require(successContract, \"Transfer to contract failed\");\r\n        if (refundToSender > 0) {\r\n            (bool successRefund, ) = payable(msg.sender).call{value: refundToSender}(\"\");\r\n            require(successRefund, \"Refund to sender failed\");\r\n            (bool successAdvisor, ) = payable(address(advisor)).call{value: advisorShare}(\"\");\r\n            require(successAdvisor, \"Refund to Advisor failed\");\r\n        }\r\n        \r\n        emit TokenPurchased(msg.sender, amount, msg.value);\r\n    }\r\n    \r\n    /*\r\n     * @dev View function to calculate the ETH price for purchasing tokens\r\n     * @param amount - The number of tokens to purchase\r\n     * @return The total ETH required to purchase the specified number of tokens\r\n     */\r\n    function purchaseToken_price(uint256 amount) public view returns (uint256) {\r\n        return _getCurrentRoundPrice() * (amount / DECIMALS);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the top `topN` participants based on their total spending.\r\n     * Iterates through the list of participants and selects the top spenders.\r\n     * @param topN The number of top participants to return.\r\n     * @return An array of addresses representing the top `topN` participants by spending.\r\n     */\r\n     function getTopParticipants(uint256 topN) public view returns (address[] memory) {\r\n        require(topN > 0 && topN <= _participants.length, \"Invalid topN value\");\r\n        address[] memory topParticipants = new address[](topN);\r\n        uint256[] memory topAmounts = new uint256[](topN);\r\n        for (uint256 i = 0; i < topN; i++) {\r\n            topParticipants[i] = _participants[i];\r\n            topAmounts[i] = totalSpent[_participants[i]];\r\n        }\r\n        for (uint256 i = topN / 2; i > 0; i--) {\r\n            heapifyDown(topAmounts, topParticipants, i - 1, topN);\r\n        }\r\n        for (uint256 i = topN; i < _participants.length; i++) {\r\n            uint256 spent = totalSpent[_participants[i]];\r\n            if (spent > topAmounts[0]) {\r\n                topAmounts[0] = spent;\r\n                topParticipants[0] = _participants[i];\r\n                heapifyDown(topAmounts, topParticipants, 0, topN);\r\n            }\r\n        }\r\n        for (uint256 i = topN - 1; i > 0; i--) {\r\n            (topAmounts[0], topAmounts[i]) = (topAmounts[i], topAmounts[0]);\r\n            (topParticipants[0], topParticipants[i]) = (topParticipants[i], topParticipants[0]);\r\n            heapifyDown(topAmounts, topParticipants, 0, i);\r\n        }\r\n        return topParticipants;\r\n    }\r\n\r\n    /**\r\n     * @dev Heapifies down the element at index `start` in the min-heap.\r\n     * @param topAmounts Array of the top spending amounts.\r\n     * @param topParticipants Array of the top participant addresses.\r\n     * @param start The starting index to heapify down.\r\n     * @param size The size of the heap.\r\n     */\r\n    function heapifyDown(\r\n        uint256[] memory topAmounts,\r\n        address[] memory topParticipants,\r\n        uint256 start,\r\n        uint256 size\r\n    ) internal pure {\r\n        uint256 left = 2 * start + 1;\r\n        uint256 right = 2 * start + 2;\r\n        uint256 smallest = start;\r\n        if (left < size && topAmounts[left] < topAmounts[smallest]) {\r\n            smallest = left;\r\n        }\r\n        if (right < size && topAmounts[right] < topAmounts[smallest]) {\r\n            smallest = right;\r\n        }\r\n        if (smallest != start) {\r\n            (topAmounts[start], topAmounts[smallest]) = (topAmounts[smallest], topAmounts[start]);\r\n            (topParticipants[start], topParticipants[smallest]) = (topParticipants[smallest], topParticipants[start]);\r\n            heapifyDown(topAmounts, topParticipants, smallest, size);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the ranking of the caller based on their total spending.\r\n     * @return The 1-based ranking of the caller among all participants. Returns 0 if the caller is not in the list.\r\n     */\r\n    function getRanking() external view returns (uint256) {\r\n        address[] memory sortedParticipants = getTopParticipants(_participants.length);\r\n        for (uint256 i = 0; i < sortedParticipants.length; i++) {\r\n            if (sortedParticipants[i] == msg.sender) {\r\n                return i + 1;\r\n            }\r\n        }\r\n        return 0; // Return 0 if the caller is not in the participants list.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the top spender.\r\n     * @return The address of the participant who has spent the most. Returns address(0) if there are no participants.\r\n     */\r\n    function getTopSpender() public view returns (address) {\r\n        if (_participants.length == 0) return address(0); // Return address(0) if no participants exist.\r\n        return getTopParticipants(1)[0]; // Return the address of the top spender.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the second top spender.\r\n     * @return The address of the participant who has spent the second most. Returns address(0) if there are less than 2 participants.\r\n     */\r\n    function getSecondTopSpender() public view returns (address) {\r\n        if (_participants.length < 2) return address(0); // Return address(0) if there are less than 2 participants.\r\n        return getTopParticipants(2)[1]; // Return the address of the second top spender.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the third top spender.\r\n     * @return The address of the participant who has spent the third most. Returns address(0) if there are less than 3 participants.\r\n     */\r\n    function getThirdTopSpender() public view returns (address) {\r\n        if (_participants.length < 3) return address(0); // Return address(0) if there are less than 3 participants.\r\n        return getTopParticipants(3)[2]; // Return the address of the third top spender.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount spent by the top spender.\r\n     * @return The total amount spent by the top spender. Returns 0 if there are no participants.\r\n     */\r\n    function getTopSpenderAmount() external view returns (uint256) {\r\n        address topSpender = getTopSpender(); // Get the address of the top spender.\r\n        if (topSpender == address(0)) return 0; // Return 0 if there is no top spender.\r\n        return totalSpent[topSpender]; // Return the total amount spent by the top spender.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount spent by the second top spender.\r\n     * @return The total amount spent by the second top spender. Returns 0 if there are less than 2 participants.\r\n     */\r\n    function getSecondTopSpenderAmount() external view returns (uint256) {\r\n        address secondTopSpender = getSecondTopSpender(); // Get the address of the second top spender.\r\n        if (secondTopSpender == address(0)) return 0; // Return 0 if there is no second top spender.\r\n        return totalSpent[secondTopSpender]; // Return the total amount spent by the second top spender.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount spent by the third top spender.\r\n     * @return The total amount spent by the third top spender. Returns 0 if there are less than 3 participants.\r\n     */\r\n    function getThirdTopSpenderAmount() external view returns (uint256) {\r\n        address thirdTopSpender = getThirdTopSpender(); // Get the address of the third top spender.\r\n        if (thirdTopSpender == address(0)) return 0; // Return 0 if there is no third top spender.\r\n        return totalSpent[thirdTopSpender]; // Return the total amount spent by the third top spender.\r\n    }\r\n\r\n\r\n    /*\r\n     * @dev View function to get the price of tokens for the current round\r\n     * @return The price of tokens in ETH for the current round\r\n     */\r\n    function _getCurrentRoundPrice() public view returns (uint256) {\r\n        return _convertUSDtoETH(_roundPrices[_currentRound]);\r\n    }\r\n\r\n    /*\r\n     * @dev View function to get the remaining tokens available for purchase in the current round\r\n     * @return The number of tokens still available for purchase in the current round\r\n     */\r\n    function _getCurrentRoundTokensRemaining() public view returns (uint256) {\r\n        return\r\n            _roundTokenLimits[_currentRound] -\r\n            _tokensSoldPerRound[_currentRound];\r\n    }\r\n\r\n    /*\r\n     * @dev Internal function to update the progress of the current round and handle token distribution across rounds\r\n     * @param amount - The number of tokens purchased in the current transaction\r\n     */\r\n    function _updateRoundProgress(uint256 amount) internal {\r\n        uint256 remainingTokensCurrentRound = _getCurrentRoundTokensRemaining();\r\n        if (remainingTokensCurrentRound >= amount) {\r\n            _totalTokensSold += amount;\r\n        } else {\r\n            uint256 excessTokens = amount - remainingTokensCurrentRound;\r\n            _totalTokensSold += remainingTokensCurrentRound;\r\n            if (_currentRound < MAX_ROUND) {\r\n                _currentRound++;\r\n                emit RoundAdvanced(_currentRound);\r\n                _updateRoundProgress(excessTokens);\r\n            } else {\r\n                _totalTokensSold += excessTokens;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice Function to withdraw funds from the contract upon presale completion\r\n     */\r\n    function deploy_SyntraCoin() external {\r\n        require(msg.sender == address(this), \"Only contract can call this function\");\r\n        require(_currentRound == MAX_ROUND, \"Presale not finished\");\r\n        uint256 ethForPool = address(this).balance;\r\n        _uniswapAndCoinManager.deployCoinAndPool{value: ethForPool}(ethForPool - 6789788);\r\n    }\r\n\r\n    /*\r\n     * @notice Function for participants to mint the tokens they bought in the presale\r\n     */\r\n     function mintMyTokens() external nonReentrant {\r\n        require(_uniswapAndCoinManager.coinAddress() != address(0), \"Coin not deployed yet\");\r\n        uint256 amountToMint = _tokenPurchases[msg.sender];\r\n        require(amountToMint > 0, \"No tokens to mint\"); \r\n        nonces[msg.sender]++;\r\n        _tokenPurchases[msg.sender] = 0;\r\n        _uniswapAndCoinManager.mintTokens(msg.sender, amountToMint);\r\n    }\r\n\r\n    /*\r\n     * @notice Function to attempt to withdraw funds safely; enters emergency mode if it fails\r\n     */\r\n    function safe_deploy_SyntraCoin() external nonReentrant onlyOwner {\r\n        try this.deploy_SyntraCoin() {} catch {\r\n            _isInEmergencyWithdraw = true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice Function to perform an emergency withdrawal if safe withdrawal fails\r\n     */\r\n    function emergencyWithdraw() external nonReentrant onlyOwner  {\r\n        require(_isInEmergencyWithdraw, \"Emergency withdraw is not active\");\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No ETH available to withdraw\");\r\n        nonces[owner()]++;\r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"ETH transfer failed\");\r\n    }\r\n\r\n    /*\r\n     * @notice Function to allow participants to request a full refund if the presale fails\r\n     */\r\n     function failedPresaleFullRefundMe() external nonReentrant {\r\n        require(block.timestamp > _presaleStartedAt + GLOBAL_TIMER, \"Global timer is not ended yet\");\r\n        address payable purchaser = payable(msg.sender);\r\n        uint256 totalEth = _totalEthSpentByAddress[purchaser];\r\n        uint256 refundEth = (totalEth * (PERCENTAGE_BASE - TEAM_PERCENTAGE)) / PERCENTAGE_BASE; // Refund only 80%\r\n        require(totalEth > 0, \"You have no ETH available to withdraw\");\r\n        nonces[msg.sender]++;\r\n        _tokensSoldPerRoundByAddress[_currentRound][purchaser] = 0;\r\n        _tokenPurchases[purchaser] = 0;\r\n        _totalEthSpentByAddress[purchaser] = 0;\r\n        (bool success, ) = purchaser.call{value: refundEth}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        emit AddressRefunded(purchaser, refundEth);\r\n    }\r\n\r\n    /*\r\n     * @notice Function to allow participants to request a refund if certain conditions are met\r\n     */\r\n     function refundMe() external nonReentrant {\r\n        address payable purchaser = payable(msg.sender);\r\n        uint256 tokensAmount = _tokensSoldPerRoundByAddress[_currentRound][purchaser];\r\n        uint256 totalAmountInEth = _totalEthSpentByAddress[purchaser]; // Using the exact amount spent by the purchaser in this round\r\n        uint256 refundAmountInEth = (totalAmountInEth * (PERCENTAGE_BASE - TEAM_PERCENTAGE)) / PERCENTAGE_BASE; // Refund only 80%\r\n        require(tokensAmount > 0, \"You have not deposited ETH in this round\");\r\n        nonces[msg.sender]++;\r\n        _totalTokensSold -= tokensAmount;\r\n        _tokensSoldPerRound[_currentRound] -= tokensAmount;\r\n        _tokensSoldPerRoundByAddress[_currentRound][purchaser] -= tokensAmount;\r\n        _tokenPurchases[purchaser] -= tokensAmount;\r\n        _totalEthSpentByAddress[purchaser] = 0;\r\n        (bool success, ) = purchaser.call{value: refundAmountInEth}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        emit AddressRefunded(purchaser, refundAmountInEth);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapAndCoinManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddressRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"AdvisorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"investorsAddresses\",\"type\":\"address[]\"}],\"name\":\"AdvisorAddressesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"AdvisorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"computerType\",\"type\":\"string\"}],\"name\":\"ComputerPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newRound\",\"type\":\"uint256\"}],\"name\":\"RoundAdvanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethSpent\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCompleted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ADVISOR_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_HECATE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_HYPERION_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_NYX_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TRITON_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GLOBAL_TIMER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROUND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTAGE_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFUND_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_advisors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_computerHecatePurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_computerHyperionPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_computerNyxPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_computerTritonPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInUSDCents\",\"type\":\"uint256\"}],\"name\":\"_convertUSDtoETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_ethAmountByAdvisorAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getCurrentRoundPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getCurrentRoundTokensRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getLatestETHUSDPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_investorsByAdvisorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isInEmergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_participants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_presaleStartedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_roundPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_roundTokenLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokenPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_tokensSoldPerRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokensSoldPerRoundByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_totalEthSpentByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalEthSpentInComputers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapAndCoinManager\",\"outputs\":[{\"internalType\":\"contract IUniswapAndCoinManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"addAdvisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploy_SyntraCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failedPresaleFullRefundMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondTopSpender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondTopSpenderAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThirdTopSpender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThirdTopSpenderAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"topN\",\"type\":\"uint256\"}],\"name\":\"getTopParticipants\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTopSpender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTopSpenderAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"purchaseHecate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseHecate_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"purchaseHyperion\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseHyperion_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"purchaseNyx\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseNyx_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"purchaseToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseToken_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"purchaseTriton\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseTriton_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"advisor\",\"type\":\"address\"}],\"name\":\"removeAdvisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe_deploy_SyntraCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PresaleContract", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009b027d11717f68b55424a9bf4461933062e07ddb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://06f61a674c1507dbfcdc42b9521dbc1bac5aa8008baee97d5bbcb38c26cc4f41"}