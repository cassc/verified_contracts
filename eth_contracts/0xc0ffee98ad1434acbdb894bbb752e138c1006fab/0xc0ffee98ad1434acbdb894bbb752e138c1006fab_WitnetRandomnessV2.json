{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/apps/WitnetRandomnessV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../WitnetRandomness.sol\\\";\\r\\nimport \\\"../apps/UsingWitnet.sol\\\";\\r\\nimport \\\"../interfaces/IWitnetRandomnessAdmin.sol\\\";\\r\\nimport \\\"../patterns/Ownable2Step.sol\\\";\\r\\n\\r\\n/// @title WitnetRandomnessV2: Unmalleable and provably-fair randomness generation based on the Witnet Oracle v2.*.\\r\\n/// @author The Witnet Foundation.\\r\\ncontract WitnetRandomnessV2\\r\\n    is\\r\\n        Ownable2Step,\\r\\n        UsingWitnet,\\r\\n        WitnetRandomness,\\r\\n        IWitnetRandomnessAdmin\\r\\n{\\r\\n    using Witnet for bytes;\\r\\n    using Witnet for Witnet.Result;\\r\\n    using WitnetV2 for WitnetV2.RadonSLA;\\r\\n\\r\\n    struct Randomize {\\r\\n        uint256 witnetQueryId;\\r\\n        uint256 prevBlock;\\r\\n        uint256 nextBlock;\\r\\n    }\\r\\n\\r\\n    struct Storage {\\r\\n        uint256 lastRandomizeBlock;\\r\\n        mapping (uint256 => Randomize) randomize_;\\r\\n    }\\r\\n\\r\\n    /// @notice Unique identifier of the RNG data request used on the Witnet Oracle blockchain for solving randomness.\\r\\n    /// @dev Can be used to track all randomness requests solved so far on the Witnet Oracle blockchain.\\r\\n    bytes32 immutable public override witnetRadHash;\\r\\n\\r\\n    constructor(\\r\\n            WitnetOracle _witnet,\\r\\n            address _operator\\r\\n        )\\r\\n        Ownable(_operator)\\r\\n        UsingWitnet(_witnet)\\r\\n    {\\r\\n        _require(\\r\\n            address(_witnet) == address(0)\\r\\n                || _witnet.specs() == type(IWitnetOracle).interfaceId,\\r\\n            \\\"uncompliant WitnetOracle\\\"\\r\\n        );\\r\\n        WitnetRequestBytecodes _registry = witnet().registry();\\r\\n        {\\r\\n            // Build own Witnet Randomness Request:\\r\\n            bytes32[] memory _retrievals = new bytes32[](1);\\r\\n            _retrievals[0] = _registry.verifyRadonRetrieval(\\r\\n                Witnet.RadonDataRequestMethods.RNG,\\r\\n                \\\"\\\", // no request url\\r\\n                \\\"\\\", // no request body\\r\\n                new string[2][](0), // no request headers\\r\\n                hex\\\"80\\\" // no request Radon script\\r\\n            );\\r\\n            Witnet.RadonFilter[] memory _filters;\\r\\n            bytes32 _aggregator = _registry.verifyRadonReducer(Witnet.RadonReducer({\\r\\n                opcode: Witnet.RadonReducerOpcodes.Mode,\\r\\n                filters: _filters // no filters\\r\\n            }));\\r\\n            bytes32 _tally = _registry.verifyRadonReducer(Witnet.RadonReducer({\\r\\n                opcode: Witnet.RadonReducerOpcodes.ConcatenateAndHash,\\r\\n                filters: _filters // no filters\\r\\n            }));\\r\\n            witnetRadHash = _registry.verifyRadonRequest(\\r\\n                _retrievals,\\r\\n                _aggregator,\\r\\n                _tally,\\r\\n                32, // 256 bits of pure entropy ;-)\\r\\n                new string[][](_retrievals.length)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() virtual external payable {\\r\\n        _revert(\\\"no transfers accepted\\\");\\r\\n    }\\r\\n\\r\\n    fallback() virtual external payable { \\r\\n        _revert(string(abi.encodePacked(\\r\\n            \\\"not implemented: 0x\\\",\\r\\n            Witnet.toHexString(uint8(bytes1(msg.sig))),\\r\\n            Witnet.toHexString(uint8(bytes1(msg.sig << 8))),\\r\\n            Witnet.toHexString(uint8(bytes1(msg.sig << 16))),\\r\\n            Witnet.toHexString(uint8(bytes1(msg.sig << 24)))\\r\\n        )));\\r\\n    }\\r\\n\\r\\n    function class() virtual override public pure returns (string memory) {\\r\\n        return type(WitnetRandomnessV2).name;\\r\\n    }\\r\\n\\r\\n    function specs() virtual override external pure returns (bytes4) {\\r\\n        return type(WitnetRandomness).interfaceId;\\r\\n    }\\r\\n\\r\\n    function witnet() override (IWitnetRandomness, UsingWitnet)\\r\\n        public view returns (WitnetOracle)\\r\\n    {\\r\\n        return UsingWitnet.witnet();\\r\\n    }\\r\\n\\r\\n    \\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'IWitnetRandomness' implementation ------------------------------------------------------------------------\\r\\n\\r\\n    /// Returns amount of wei required to be paid as a fee when requesting randomization with a \\r\\n    /// transaction gas price as the one given.\\r\\n    function estimateRandomizeFee(uint256 _evmGasPrice)\\r\\n        public view\\r\\n        virtual override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (\\r\\n            (100 + __witnetBaseFeeOverheadPercentage)\\r\\n                * __witnet.estimateBaseFee(\\r\\n                    _evmGasPrice, \\r\\n                    uint16(34)\\r\\n                ) \\r\\n        ) / 100;\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieves the result of keccak256-hashing the given block number with the randomness value \\r\\n    /// @notice generated by the Witnet Oracle blockchain in response to the first non-errored randomize request solved \\r\\n    /// @notice after such block number.\\r\\n    /// @dev Reverts if:\\r\\n    /// @dev   i.   no `randomize()` was requested on neither the given block, nor afterwards.\\r\\n    /// @dev   ii.  the first non-errored `randomize()` request found on or after the given block is not solved yet.\\r\\n    /// @dev   iii. all `randomize()` requests that took place on or after the given block were solved with errors.\\r\\n    /// @param _blockNumber Block number from which the search will start\\r\\n    function fetchRandomnessAfter(uint256 _blockNumber)\\r\\n        public view\\r\\n        virtual override\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return keccak256(\\r\\n            abi.encode(\\r\\n                _blockNumber,\\r\\n                _fetchRandomnessAfter(_blockNumber)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function _fetchRandomnessAfter(uint256 _blockNumber)\\r\\n        virtual internal view \\r\\n        returns (bytes32)\\r\\n    {\\r\\n        if (__storage().randomize_[_blockNumber].witnetQueryId == 0) {\\r\\n            _blockNumber = getRandomizeNextBlock(_blockNumber);\\r\\n        }\\r\\n\\r\\n        Randomize storage __randomize = __storage().randomize_[_blockNumber];\\r\\n        uint256 _witnetQueryId = __randomize.witnetQueryId;\\r\\n        _require(\\r\\n            _witnetQueryId != 0, \\r\\n            \\\"not randomized\\\"\\r\\n        );\\r\\n        \\r\\n        WitnetV2.ResponseStatus _status = __witnet.getQueryResponseStatus(_witnetQueryId);\\r\\n        if (_status == WitnetV2.ResponseStatus.Ready) {\\r\\n            return (\\r\\n                __witnet.getQueryResultCborBytes(_witnetQueryId)\\r\\n                    .toWitnetResult()\\r\\n                    .asBytes32()\\r\\n            );\\r\\n        } else if (_status == WitnetV2.ResponseStatus.Error) {\\r\\n            uint256 _nextRandomizeBlock = __randomize.nextBlock;\\r\\n            _require(\\r\\n                _nextRandomizeBlock != 0, \\r\\n                \\\"faulty randomize\\\"\\r\\n            );\\r\\n            return _fetchRandomnessAfter(_nextRandomizeBlock);\\r\\n        \\r\\n        } else {\\r\\n            _revert(\\\"pending randomize\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieves the actual random value, unique hash and timestamp of the witnessing commit/reveal act that took\\r\\n    /// @notice place in the Witnet Oracle blockchain in response to the first non-errored randomize request\\r\\n    /// @notice solved after the given block number.\\r\\n    /// @dev Reverts if:\\r\\n    /// @dev   i.   no `randomize()` was requested on neither the given block, nor afterwards.\\r\\n    /// @dev   ii.  the first non-errored `randomize()` request found on or after the given block is not solved yet.\\r\\n    /// @dev   iii. all `randomize()` requests that took place on or after the given block were solved with errors.\\r\\n    /// @param _blockNumber Block number from which the search will start.\\r\\n    /// @return _witnetResultRandomness Random value provided by the Witnet blockchain and used for solving randomness after given block.\\r\\n    /// @return _witnetResultTimestamp Timestamp at which the randomness value was generated by the Witnet blockchain.\\r\\n    /// @return _witnetResultTallyHash Hash of the witnessing commit/reveal act that took place on the Witnet blockchain.\\r\\n    /// @return _witnetResultFinalityBlock EVM block number from which the provided randomness can be considered to be final.\\r\\n    function fetchRandomnessAfterProof(uint256 _blockNumber) \\r\\n        virtual override\\r\\n        public view \\r\\n        returns (\\r\\n            bytes32 _witnetResultRandomness,\\r\\n            uint64  _witnetResultTimestamp,\\r\\n            bytes32 _witnetResultTallyHash,\\r\\n            uint256 _witnetResultFinalityBlock\\r\\n        )\\r\\n    {\\r\\n        if (__storage().randomize_[_blockNumber].witnetQueryId == 0) {\\r\\n            _blockNumber = getRandomizeNextBlock(_blockNumber);\\r\\n        }\\r\\n\\r\\n        Randomize storage __randomize = __storage().randomize_[_blockNumber];\\r\\n        uint256 _witnetQueryId = __randomize.witnetQueryId;\\r\\n        _require(\\r\\n            _witnetQueryId != 0, \\r\\n            \\\"not randomized\\\"\\r\\n        );\\r\\n        \\r\\n        WitnetV2.ResponseStatus _status = __witnet.getQueryResponseStatus(_witnetQueryId);\\r\\n        if (_status == WitnetV2.ResponseStatus.Ready) {\\r\\n            WitnetV2.Response memory _witnetQueryResponse = __witnet.getQueryResponse(_witnetQueryId);\\r\\n            _witnetResultTimestamp = _witnetQueryResponse.resultTimestamp;\\r\\n            _witnetResultTallyHash = _witnetQueryResponse.resultTallyHash;\\r\\n            _witnetResultFinalityBlock = _witnetQueryResponse.finality;\\r\\n            _witnetResultRandomness = _witnetQueryResponse.resultCborBytes.toWitnetResult().asBytes32();\\r\\n\\r\\n        } else if (_status == WitnetV2.ResponseStatus.Error) {\\r\\n            uint256 _nextRandomizeBlock = __randomize.nextBlock;\\r\\n            _require(\\r\\n                _nextRandomizeBlock != 0, \\r\\n                \\\"faulty randomize\\\"\\r\\n            );\\r\\n            return fetchRandomnessAfterProof(_nextRandomizeBlock);\\r\\n        \\r\\n        } else {\\r\\n            _revert(\\\"pending randomize\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns last block number on which a randomize was requested.\\r\\n    function getLastRandomizeBlock()\\r\\n        virtual override\\r\\n        external view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return __storage().lastRandomizeBlock;\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieves metadata related to the randomize request that got posted to the \\r\\n    /// @notice Witnet Oracle contract on the given block number.\\r\\n    /// @dev Returns zero values if no randomize request was actually posted on the given block.\\r\\n    /// @return _witnetQueryId Identifier of the underlying Witnet query created on the given block number. \\r\\n    /// @return _prevRandomizeBlock Block number in which a randomize request got posted just before this one. 0 if none.\\r\\n    /// @return _nextRandomizeBlock Block number in which a randomize request got posted just after this one, 0 if none.\\r\\n    function getRandomizeData(uint256 _blockNumber)\\r\\n        external view\\r\\n        virtual override\\r\\n        returns (\\r\\n            uint256 _witnetQueryId,\\r\\n            uint256 _prevRandomizeBlock,\\r\\n            uint256 _nextRandomizeBlock\\r\\n        )\\r\\n    {\\r\\n        Randomize storage __randomize = __storage().randomize_[_blockNumber];\\r\\n        _witnetQueryId = __randomize.witnetQueryId;\\r\\n        _prevRandomizeBlock = __randomize.prevBlock;\\r\\n        _nextRandomizeBlock = __randomize.nextBlock;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the number of the next block in which a randomize request was posted after the given one. \\r\\n    /// @param _blockNumber Block number from which the search will start.\\r\\n    /// @return Number of the first block found after the given one, or `0` otherwise.\\r\\n    function getRandomizeNextBlock(uint256 _blockNumber)\\r\\n        public view\\r\\n        virtual override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return ((__storage().randomize_[_blockNumber].witnetQueryId != 0)\\r\\n            ? __storage().randomize_[_blockNumber].nextBlock\\r\\n            // start search from the latest block\\r\\n            : _searchNextBlock(_blockNumber, __storage().lastRandomizeBlock)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the number of the previous block in which a randomize request was posted before the given one.\\r\\n    /// @param _blockNumber Block number from which the search will start. Cannot be zero.\\r\\n    /// @return First block found before the given one, or `0` otherwise.\\r\\n    function getRandomizePrevBlock(uint256 _blockNumber)\\r\\n        public view\\r\\n        virtual override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        assert(_blockNumber > 0);\\r\\n        uint256 _latest = __storage().lastRandomizeBlock;\\r\\n        return ((_blockNumber > _latest)\\r\\n            ? _latest\\r\\n            // start search from the latest block\\r\\n            : _searchPrevBlock(_blockNumber, __storage().randomize_[_latest].prevBlock)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns status of the first non-errored randomize request posted on or after the given block number.\\r\\n    /// @dev Possible values:\\r\\n    /// @dev - 0 -> Void: no randomize request was actually posted on or after the given block number.\\r\\n    /// @dev - 1 -> Awaiting: a randomize request was found but it's not yet solved by the Witnet blockchain.\\r\\n    /// @dev - 2 -> Ready: a successfull randomize value was reported and ready to be read.\\r\\n    /// @dev - 3 -> Error: all randomize requests after the given block were solved with errors.\\r\\n    /// @dev - 4 -> Finalizing: a randomize resolution has been reported from the Witnet blockchain, but it's not yet final.  \\r\\n    function getRandomizeStatus(uint256 _blockNumber)\\r\\n        virtual override\\r\\n        public view \\r\\n        returns (WitnetV2.ResponseStatus)\\r\\n    {\\r\\n        if (__storage().randomize_[_blockNumber].witnetQueryId == 0) {\\r\\n            _blockNumber = getRandomizeNextBlock(_blockNumber);\\r\\n        }\\r\\n        uint256 _witnetQueryId = __storage().randomize_[_blockNumber].witnetQueryId;\\r\\n        if (_witnetQueryId == 0) {\\r\\n            return WitnetV2.ResponseStatus.Void;\\r\\n        \\r\\n        } else {\\r\\n            WitnetV2.ResponseStatus _status = __witnet.getQueryResponseStatus(_witnetQueryId);\\r\\n            if (_status == WitnetV2.ResponseStatus.Error) {\\r\\n                uint256 _nextRandomizeBlock = __storage().randomize_[_blockNumber].nextBlock;\\r\\n                if (_nextRandomizeBlock != 0) {\\r\\n                    return getRandomizeStatus(_nextRandomizeBlock);\\r\\n                } else {\\r\\n                    return WitnetV2.ResponseStatus.Error;\\r\\n                }\\r\\n            } else {\\r\\n                return _status;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns `true` only if a successfull resolution from the Witnet blockchain is found for the first \\r\\n    /// @notice non-errored randomize request posted on or after the given block number.\\r\\n    function isRandomized(uint256 _blockNumber)\\r\\n        public view\\r\\n        virtual override\\r\\n        returns (bool)\\r\\n    {\\r\\n        return (\\r\\n            getRandomizeStatus(_blockNumber) == WitnetV2.ResponseStatus.Ready\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _range), by using \\r\\n    /// @notice the given `nonce` and the randomness returned by `getRandomnessAfter(blockNumber)`. \\r\\n    /// @dev Fails under same conditions as `getRandomnessAfter(uint256)` does.\\r\\n    /// @param _range Range within which the uniformly-distributed random number will be generated.\\r\\n    /// @param _nonce Nonce value enabling multiple random numbers from the same randomness value.\\r\\n    /// @param _blockNumber Block number from which the search for the first randomize request solved aftewards will start.\\r\\n    function random(uint32 _range, uint256 _nonce, uint256 _blockNumber)\\r\\n        external view \\r\\n        virtual override\\r\\n        returns (uint32)\\r\\n    {\\r\\n        return WitnetV2.randomUniformUint32(\\r\\n            _range,\\r\\n            _nonce,\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    msg.sender,\\r\\n                    fetchRandomnessAfter(_blockNumber)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Requests the Witnet oracle to generate an EVM-agnostic and trustless source of randomness. \\r\\n    /// @dev Only one randomness request per block will be actually posted to the Witnet Oracle. \\r\\n    /// @return _evmRandomizeFee Funds actually paid as randomize fee.\\r\\n    function randomize()\\r\\n        external payable\\r\\n        virtual override\\r\\n        returns (uint256 _evmRandomizeFee)\\r\\n    {\\r\\n        if (__storage().lastRandomizeBlock < block.number) {\\r\\n            _evmRandomizeFee = msg.value;\\r\\n            // Post the Witnet Randomness request:\\r\\n            uint _witnetQueryId = __witnet.postRequest{\\r\\n                value: _evmRandomizeFee\\r\\n            }(\\r\\n                witnetRadHash,\\r\\n                __witnetDefaultSLA  \\r\\n            );\\r\\n            // Keep Randomize data in storage:\\r\\n            Randomize storage __randomize = __storage().randomize_[block.number];\\r\\n            __randomize.witnetQueryId = _witnetQueryId;\\r\\n            // Update block links:\\r\\n            uint256 _prevBlock = __storage().lastRandomizeBlock;\\r\\n            __randomize.prevBlock = _prevBlock;\\r\\n            __storage().randomize_[_prevBlock].nextBlock = block.number;\\r\\n            __storage().lastRandomizeBlock = block.number;\\r\\n            // Throw event:\\r\\n            emit Randomizing(\\r\\n                block.number,\\r\\n                tx.gasprice,\\r\\n                _evmRandomizeFee,\\r\\n                _witnetQueryId,\\r\\n                __witnetDefaultSLA\\r\\n            );\\r\\n        }\\r\\n        // Transfer back unused funds:\\r\\n        if (_evmRandomizeFee < msg.value) {\\r\\n            payable(msg.sender).transfer(msg.value - _evmRandomizeFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the SLA parameters required for the Witnet Oracle blockchain to fulfill \\r\\n    /// @notice when solving randomness requests:\\r\\n    /// @notice - number of witnessing nodes contributing to randomness generation\\r\\n    /// @notice - reward in $nanoWIT received by every contributing node in the Witnet blockchain\\r\\n    function witnetQuerySLA() \\r\\n        virtual override\\r\\n        external view\\r\\n        returns (WitnetV2.RadonSLA memory)\\r\\n    {\\r\\n        return __witnetDefaultSLA;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'IWitnetRandomnessAdmin' implementation -------------------------------------------------------------------\\r\\n\\r\\n    function acceptOwnership()\\r\\n        virtual override (IWitnetRandomnessAdmin, Ownable2Step)\\r\\n        public\\r\\n    {\\r\\n        Ownable2Step.acceptOwnership();\\r\\n    }\\r\\n\\r\\n    function baseFeeOverheadPercentage()\\r\\n        virtual override\\r\\n        external view \\r\\n        returns (uint16)\\r\\n    {\\r\\n        return __witnetBaseFeeOverheadPercentage;\\r\\n    }\\r\\n\\r\\n    function owner()\\r\\n        virtual override (IWitnetRandomnessAdmin, Ownable)\\r\\n        public view \\r\\n        returns (address)\\r\\n    {\\r\\n        return Ownable.owner();\\r\\n    }\\r\\n\\r\\n    function pendingOwner() \\r\\n        virtual override (IWitnetRandomnessAdmin, Ownable2Step)\\r\\n        public view\\r\\n        returns (address)\\r\\n    {\\r\\n        return Ownable2Step.pendingOwner();\\r\\n    }\\r\\n    \\r\\n    function transferOwnership(address _newOwner)\\r\\n        virtual override (IWitnetRandomnessAdmin, Ownable2Step)\\r\\n        public \\r\\n        onlyOwner\\r\\n    {\\r\\n        Ownable.transferOwnership(_newOwner);\\r\\n    }\\r\\n\\r\\n    function settleBaseFeeOverheadPercentage(uint16 _baseFeeOverheadPercentage)\\r\\n        virtual override\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        __witnetBaseFeeOverheadPercentage = _baseFeeOverheadPercentage;\\r\\n    }\\r\\n\\r\\n    function settleWitnetQuerySLA(WitnetV2.RadonSLA calldata _witnetQuerySLA)\\r\\n        virtual override\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        _require(\\r\\n            _witnetQuerySLA.isValid(),\\r\\n            \\\"invalid SLA\\\"\\r\\n        );\\r\\n        __witnetDefaultSLA = _witnetQuerySLA;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ================================================================================================================\\r\\n    // --- Internal methods -------------------------------------------------------------------------------------------\\r\\n\\r\\n    function _require(\\r\\n            bool _condition, \\r\\n            string memory _message\\r\\n        )\\r\\n        internal pure\\r\\n    {\\r\\n        if (!_condition) {\\r\\n            _revert(_message);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(string memory _message)\\r\\n        internal pure\\r\\n    {\\r\\n        revert(\\r\\n            string(abi.encodePacked(\\r\\n                class(),\\r\\n                \\\": \\\",\\r\\n                _message\\r\\n            ))\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Recursively searches for the number of the first block after the given one in which a Witnet \\r\\n    /// @dev randomness request was posted. Returns 0 if none found.\\r\\n    function _searchNextBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {\\r\\n        return ((_target >= _latest) \\r\\n            ? __storage().randomize_[_latest].nextBlock\\r\\n            : _searchNextBlock(_target, __storage().randomize_[_latest].prevBlock)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Recursively searches for the number of the first block before the given one in which a Witnet \\r\\n    /// @dev randomness request was posted. Returns 0 if none found.\\r\\n    function _searchPrevBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {\\r\\n        return ((_target > _latest)\\r\\n            ? _latest\\r\\n            : _searchPrevBlock(_target, __storage().randomize_[_latest].prevBlock)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    bytes32 private constant _STORAGE_SLOT = \\r\\n        // keccak256(\\\"io.witnet.apps.randomness.v20\\\")\\r\\n        0x643778935c57df947f6944f6a5242a3e91445f6337f4b2ec670c8642153b614f;\\r\\n\\r\\n    function __storage() internal pure returns (Storage storage _ptr) {\\r\\n        assembly {\\r\\n            _ptr.slot := _STORAGE_SLOT\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/patterns/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\r\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available all functions\\r\\n * from parent (Ownable).\\r\\n */\\r\\nabstract contract Ownable2Step is Ownable {\\r\\n    address private _pendingOwner;\\r\\n\\r\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the pending owner.\\r\\n     */\\r\\n    function pendingOwner() public view virtual returns (address) {\\r\\n        return _pendingOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\r\\n        _pendingOwner = newOwner;\\r\\n        emit OwnershipTransferStarted(owner(), newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual override {\\r\\n        delete _pendingOwner;\\r\\n        super._transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The new owner accepts the ownership transfer.\\r\\n     */\\r\\n    function acceptOwnership() public virtual {\\r\\n        address sender = _msgSender();\\r\\n        if (pendingOwner() != sender) {\\r\\n            revert(\\\"Ownable2Step: caller is not the new owner\\\");\\r\\n        }\\r\\n        _transferOwnership(sender);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/patterns/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\"\r\n    },\r\n    \"/contracts/libs/WitnetV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Witnet.sol\\\";\\r\\n\\r\\nlibrary WitnetV2 {\\r\\n\\r\\n    /// Struct containing both request and response data related to every query posted to the Witnet Request Board\\r\\n    struct Query {\\r\\n        Request request;\\r\\n        Response response;\\r\\n    }\\r\\n\\r\\n    /// Possible status of a Witnet query.\\r\\n    enum QueryStatus {\\r\\n        Unknown,\\r\\n        Posted,\\r\\n        Reported,\\r\\n        Finalized\\r\\n    }\\r\\n\\r\\n    /// Data kept in EVM-storage for every Request posted to the Witnet Request Board.\\r\\n    struct Request {\\r\\n        address requester;              // EVM address from which the request was posted.\\r\\n        uint24  gasCallback;            // Max callback gas limit upon response, if a callback is required.\\r\\n        uint72  evmReward;              // EVM amount in wei eventually to be paid to the legit result reporter.\\r\\n        bytes   witnetBytecode;         // Optional: Witnet Data Request bytecode to be solved by the Witnet blockchain.\\r\\n        bytes32 witnetRAD;              // Optional: Previously verified hash of the Witnet Data Request to be solved.\\r\\n        WitnetV2.RadonSLA witnetSLA;    // Minimum Service-Level parameters to be committed by the Witnet blockchain. \\r\\n    }\\r\\n\\r\\n    /// Response metadata and result as resolved by the Witnet blockchain.\\r\\n    struct Response {\\r\\n        address reporter;               // EVM address from which the Data Request result was reported.\\r\\n        uint64  finality;               // EVM block number at which the reported data will be considered to be finalized.\\r\\n        uint32  resultTimestamp;        // Unix timestamp (seconds) at which the data request was resolved in the Witnet blockchain.\\r\\n        bytes32 resultTallyHash;        // Unique hash of the commit/reveal act in the Witnet blockchain that resolved the data request.\\r\\n        bytes   resultCborBytes;        // CBOR-encode result to the request, as resolved in the Witnet blockchain.\\r\\n    }\\r\\n\\r\\n    /// Response status from a requester's point of view.\\r\\n    enum ResponseStatus {\\r\\n        Void,\\r\\n        Awaiting,\\r\\n        Ready,\\r\\n        Error,\\r\\n        Finalizing,\\r\\n        Delivered\\r\\n    }\\r\\n\\r\\n    struct RadonSLA {\\r\\n        /// @notice Number of nodes in the Witnet blockchain that will take part in solving the data request. \\r\\n        uint8   committeeSize;\\r\\n        \\r\\n        /// @notice Fee in $nanoWIT paid to every node in the Witnet blockchain involved in solving the data request.\\r\\n        /// @dev Witnet nodes participating as witnesses will have to stake as collateral 100x this amount.\\r\\n        uint64  witnessingFeeNanoWit;\\r\\n    }\\r\\n\\r\\n    \\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'WitnetV2.RadonSLA' helper methods ------------------------------------------------------------------------\\r\\n\\r\\n    function equalOrGreaterThan(RadonSLA memory a, RadonSLA memory b) \\r\\n        internal pure returns (bool)\\r\\n    {\\r\\n        return (a.committeeSize >= b.committeeSize);\\r\\n    }\\r\\n     \\r\\n    function isValid(RadonSLA calldata sla) internal pure returns (bool) {\\r\\n        return (\\r\\n            sla.witnessingFeeNanoWit > 0 \\r\\n                && sla.committeeSize > 0 && sla.committeeSize <= 127\\r\\n                // v1.7.x requires witnessing collateral to be greater or equal to 20 WIT:\\r\\n                && sla.witnessingFeeNanoWit * 100 >= 20 * 10 ** 9 \\r\\n        );\\r\\n    }\\r\\n\\r\\n    function toV1(RadonSLA memory self) internal pure returns (Witnet.RadonSLA memory) {\\r\\n        return Witnet.RadonSLA({\\r\\n            numWitnesses: self.committeeSize,\\r\\n            minConsensusPercentage: 51,\\r\\n            witnessReward: self.witnessingFeeNanoWit,\\r\\n            witnessCollateral: self.witnessingFeeNanoWit * 100,\\r\\n            minerCommitRevealFee: self.witnessingFeeNanoWit / self.committeeSize\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function nanoWitTotalFee(RadonSLA storage self) internal view returns (uint64) {\\r\\n        return self.witnessingFeeNanoWit * (self.committeeSize + 3);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- P-RNG generators ------------------------------------------------------------------------------------------\\r\\n\\r\\n    /// Generates a pseudo-random uint32 number uniformly distributed within the range `[0 .. range)`, based on\\r\\n    /// the given `nonce` and `seed` values. \\r\\n    function randomUniformUint32(uint32 range, uint256 nonce, bytes32 seed)\\r\\n        internal pure \\r\\n        returns (uint32) \\r\\n    {\\r\\n        uint256 _number = uint256(\\r\\n            keccak256(\\r\\n                abi.encode(seed, nonce)\\r\\n            )\\r\\n        ) & uint256(2 ** 224 - 1);\\r\\n        return uint32((_number * range) >> 224);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/libs/WitnetCBOR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./WitnetBuffer.sol\\\";\\r\\n\\r\\n/// @title A minimalistic implementation of \u201cRFC 7049 Concise Binary Object Representation\u201d\\r\\n/// @notice This library leverages a buffer-like structure for step-by-step decoding of bytes so as to minimize\\r\\n/// the gas cost of decoding them into a useful native type.\\r\\n/// @dev Most of the logic has been borrowed from Patrick Gansterer\u2019s cbor.js library: https://github.com/paroga/cbor-js\\r\\n/// @author The Witnet Foundation.\\r\\n\\r\\nlibrary WitnetCBOR {\\r\\n\\r\\n  using WitnetBuffer for WitnetBuffer.Buffer;\\r\\n  using WitnetCBOR for WitnetCBOR.CBOR;\\r\\n\\r\\n  /// Data struct following the RFC-7049 standard: Concise Binary Object Representation.\\r\\n  struct CBOR {\\r\\n      WitnetBuffer.Buffer buffer;\\r\\n      uint8 initialByte;\\r\\n      uint8 majorType;\\r\\n      uint8 additionalInformation;\\r\\n      uint64 len;\\r\\n      uint64 tag;\\r\\n  }\\r\\n\\r\\n  uint8 internal constant MAJOR_TYPE_INT = 0;\\r\\n  uint8 internal constant MAJOR_TYPE_NEGATIVE_INT = 1;\\r\\n  uint8 internal constant MAJOR_TYPE_BYTES = 2;\\r\\n  uint8 internal constant MAJOR_TYPE_STRING = 3;\\r\\n  uint8 internal constant MAJOR_TYPE_ARRAY = 4;\\r\\n  uint8 internal constant MAJOR_TYPE_MAP = 5;\\r\\n  uint8 internal constant MAJOR_TYPE_TAG = 6;\\r\\n  uint8 internal constant MAJOR_TYPE_CONTENT_FREE = 7;\\r\\n\\r\\n  uint32 internal constant UINT32_MAX = type(uint32).max;\\r\\n  uint64 internal constant UINT64_MAX = type(uint64).max;\\r\\n  \\r\\n  error EmptyArray();\\r\\n  error InvalidLengthEncoding(uint length);\\r\\n  error UnexpectedMajorType(uint read, uint expected);\\r\\n  error UnsupportedPrimitive(uint primitive);\\r\\n  error UnsupportedMajorType(uint unexpected);  \\r\\n\\r\\n  modifier isMajorType(\\r\\n      WitnetCBOR.CBOR memory cbor,\\r\\n      uint8 expected\\r\\n  ) {\\r\\n    if (cbor.majorType != expected) {\\r\\n      revert UnexpectedMajorType(cbor.majorType, expected);\\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier notEmpty(WitnetBuffer.Buffer memory buffer) {\\r\\n    if (buffer.data.length == 0) {\\r\\n      revert WitnetBuffer.EmptyBuffer();\\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function eof(CBOR memory cbor)\\r\\n    internal pure\\r\\n    returns (bool)\\r\\n  {\\r\\n    return cbor.buffer.cursor >= cbor.buffer.data.length;\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a CBOR structure from raw bytes.\\r\\n  /// @dev This is the main factory for CBOR instances, which can be later decoded into native EVM types.\\r\\n  /// @param bytecode Raw bytes representing a CBOR-encoded value.\\r\\n  /// @return A `CBOR` instance containing a partially decoded value.\\r\\n  function fromBytes(bytes memory bytecode)\\r\\n    internal pure\\r\\n    returns (CBOR memory)\\r\\n  {\\r\\n    WitnetBuffer.Buffer memory buffer = WitnetBuffer.Buffer(bytecode, 0);\\r\\n    return fromBuffer(buffer);\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a CBOR structure from raw bytes.\\r\\n  /// @dev This is an alternate factory for CBOR instances, which can be later decoded into native EVM types.\\r\\n  /// @param buffer A Buffer structure representing a CBOR-encoded value.\\r\\n  /// @return A `CBOR` instance containing a partially decoded value.\\r\\n  function fromBuffer(WitnetBuffer.Buffer memory buffer)\\r\\n    internal pure\\r\\n    notEmpty(buffer)\\r\\n    returns (CBOR memory)\\r\\n  {\\r\\n    uint8 initialByte;\\r\\n    uint8 majorType = 255;\\r\\n    uint8 additionalInformation;\\r\\n    uint64 tag = UINT64_MAX;\\r\\n    uint256 len;\\r\\n    bool isTagged = true;\\r\\n    while (isTagged) {\\r\\n      // Extract basic CBOR properties from input bytes\\r\\n      initialByte = buffer.readUint8();\\r\\n      len ++;\\r\\n      majorType = initialByte >> 5;\\r\\n      additionalInformation = initialByte & 0x1f;\\r\\n      // Early CBOR tag parsing.\\r\\n      if (majorType == MAJOR_TYPE_TAG) {\\r\\n        uint _cursor = buffer.cursor;\\r\\n        tag = readLength(buffer, additionalInformation);\\r\\n        len += buffer.cursor - _cursor;\\r\\n      } else {\\r\\n        isTagged = false;\\r\\n      }\\r\\n    }\\r\\n    if (majorType > MAJOR_TYPE_CONTENT_FREE) {\\r\\n      revert UnsupportedMajorType(majorType);\\r\\n    }\\r\\n    return CBOR(\\r\\n      buffer,\\r\\n      initialByte,\\r\\n      majorType,\\r\\n      additionalInformation,\\r\\n      uint64(len),\\r\\n      tag\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function fork(WitnetCBOR.CBOR memory self)\\r\\n    internal pure\\r\\n    returns (WitnetCBOR.CBOR memory)\\r\\n  {\\r\\n    return CBOR({\\r\\n      buffer: self.buffer.fork(),\\r\\n      initialByte: self.initialByte,\\r\\n      majorType: self.majorType,\\r\\n      additionalInformation: self.additionalInformation,\\r\\n      len: self.len,\\r\\n      tag: self.tag\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function settle(CBOR memory self)\\r\\n      internal pure\\r\\n      returns (WitnetCBOR.CBOR memory)\\r\\n  {\\r\\n    if (!self.eof()) {\\r\\n      return fromBuffer(self.buffer);\\r\\n    } else {\\r\\n      return self;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function skip(CBOR memory self)\\r\\n      internal pure\\r\\n      returns (WitnetCBOR.CBOR memory)\\r\\n  {\\r\\n    if (\\r\\n      self.majorType == MAJOR_TYPE_INT\\r\\n        || self.majorType == MAJOR_TYPE_NEGATIVE_INT\\r\\n        || (\\r\\n          self.majorType == MAJOR_TYPE_CONTENT_FREE \\r\\n            && self.additionalInformation >= 25\\r\\n            && self.additionalInformation <= 27\\r\\n        )\\r\\n    ) {\\r\\n      self.buffer.cursor += self.peekLength();\\r\\n    } else if (\\r\\n        self.majorType == MAJOR_TYPE_STRING\\r\\n          || self.majorType == MAJOR_TYPE_BYTES\\r\\n    ) {\\r\\n      uint64 len = readLength(self.buffer, self.additionalInformation);\\r\\n      self.buffer.cursor += len;\\r\\n    } else if (\\r\\n      self.majorType == MAJOR_TYPE_ARRAY\\r\\n        || self.majorType == MAJOR_TYPE_MAP\\r\\n    ) { \\r\\n      self.len = readLength(self.buffer, self.additionalInformation);      \\r\\n    } else if (\\r\\n       self.majorType != MAJOR_TYPE_CONTENT_FREE\\r\\n        || (\\r\\n          self.additionalInformation != 20\\r\\n            && self.additionalInformation != 21\\r\\n        )\\r\\n    ) {\\r\\n      revert(\\\"WitnetCBOR.skip: unsupported major type\\\");\\r\\n    }\\r\\n    return self;\\r\\n  }\\r\\n\\r\\n  function peekLength(CBOR memory self)\\r\\n    internal pure\\r\\n    returns (uint64)\\r\\n  {\\r\\n    if (self.additionalInformation < 24) {\\r\\n      return 0;\\r\\n    } else if (self.additionalInformation < 28) {\\r\\n      return uint64(1 << (self.additionalInformation - 24));\\r\\n    } else {\\r\\n      revert InvalidLengthEncoding(self.additionalInformation);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function readArray(CBOR memory self)\\r\\n    internal pure\\r\\n    isMajorType(self, MAJOR_TYPE_ARRAY)\\r\\n    returns (CBOR[] memory items)\\r\\n  {\\r\\n    // read array's length and move self cursor forward to the first array element:\\r\\n    uint64 len = readLength(self.buffer, self.additionalInformation);\\r\\n    items = new CBOR[](len + 1);\\r\\n    for (uint ix = 0; ix < len; ix ++) {\\r\\n      // settle next element in the array:\\r\\n      self = self.settle();\\r\\n      // fork it and added to the list of items to be returned:\\r\\n      items[ix] = self.fork();\\r\\n      if (self.majorType == MAJOR_TYPE_ARRAY) {\\r\\n        CBOR[] memory _subitems = self.readArray();\\r\\n        // move forward to the first element after inner array:\\r\\n        self = _subitems[_subitems.length - 1];\\r\\n      } else if (self.majorType == MAJOR_TYPE_MAP) {\\r\\n        CBOR[] memory _subitems = self.readMap();\\r\\n        // move forward to the first element after inner map:\\r\\n        self = _subitems[_subitems.length - 1];\\r\\n      } else {\\r\\n        // move forward to the next element:\\r\\n        self.skip();\\r\\n      }\\r\\n    }\\r\\n    // return self cursor as extra item at the end of the list,\\r\\n    // as to optimize recursion when jumping over nested arrays:\\r\\n    items[len] = self;\\r\\n  }\\r\\n\\r\\n  function readMap(CBOR memory self)\\r\\n    internal pure\\r\\n    isMajorType(self, MAJOR_TYPE_MAP)\\r\\n    returns (CBOR[] memory items)\\r\\n  {\\r\\n    // read number of items within the map and move self cursor forward to the first inner element:\\r\\n    uint64 len = readLength(self.buffer, self.additionalInformation) * 2;\\r\\n    items = new CBOR[](len + 1);\\r\\n    for (uint ix = 0; ix < len; ix ++) {\\r\\n      // settle next element in the array:\\r\\n      self = self.settle();\\r\\n      // fork it and added to the list of items to be returned:\\r\\n      items[ix] = self.fork();\\r\\n      if (ix % 2 == 0 && self.majorType != MAJOR_TYPE_STRING) {\\r\\n        revert UnexpectedMajorType(self.majorType, MAJOR_TYPE_STRING);\\r\\n      } else if (self.majorType == MAJOR_TYPE_ARRAY || self.majorType == MAJOR_TYPE_MAP) {\\r\\n        CBOR[] memory _subitems = (self.majorType == MAJOR_TYPE_ARRAY\\r\\n            ? self.readArray()\\r\\n            : self.readMap()\\r\\n        );\\r\\n        // move forward to the first element after inner array or map:\\r\\n        self = _subitems[_subitems.length - 1];\\r\\n      } else {\\r\\n        // move forward to the next element:\\r\\n        self.skip();\\r\\n      }\\r\\n    }\\r\\n    // return self cursor as extra item at the end of the list,\\r\\n    // as to optimize recursion when jumping over nested arrays:\\r\\n    items[len] = self;\\r\\n  }\\r\\n\\r\\n  /// Reads the length of the settle CBOR item from a buffer, consuming a different number of bytes depending on the\\r\\n  /// value of the `additionalInformation` argument.\\r\\n  function readLength(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint8 additionalInformation\\r\\n    ) \\r\\n    internal pure\\r\\n    returns (uint64)\\r\\n  {\\r\\n    if (additionalInformation < 24) {\\r\\n      return additionalInformation;\\r\\n    }\\r\\n    if (additionalInformation == 24) {\\r\\n      return buffer.readUint8();\\r\\n    }\\r\\n    if (additionalInformation == 25) {\\r\\n      return buffer.readUint16();\\r\\n    }\\r\\n    if (additionalInformation == 26) {\\r\\n      return buffer.readUint32();\\r\\n    }\\r\\n    if (additionalInformation == 27) {\\r\\n      return buffer.readUint64();\\r\\n    }\\r\\n    if (additionalInformation == 31) {\\r\\n      return UINT64_MAX;\\r\\n    }\\r\\n    revert InvalidLengthEncoding(additionalInformation);\\r\\n  }\\r\\n\\r\\n  /// @notice Read a `CBOR` structure into a native `bool` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as a `bool` value.\\r\\n  function readBool(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_CONTENT_FREE)\\r\\n    returns (bool)\\r\\n  {\\r\\n    if (cbor.additionalInformation == 20) {\\r\\n      return false;\\r\\n    } else if (cbor.additionalInformation == 21) {\\r\\n      return true;\\r\\n    } else {\\r\\n      revert UnsupportedPrimitive(cbor.additionalInformation);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `bytes` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return output The value represented by the input, as a `bytes` value.   \\r\\n  function readBytes(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_BYTES)\\r\\n    returns (bytes memory output)\\r\\n  {\\r\\n    cbor.len = readLength(\\r\\n      cbor.buffer,\\r\\n      cbor.additionalInformation\\r\\n    );\\r\\n    if (cbor.len == UINT32_MAX) {\\r\\n      // These checks look repetitive but the equivalent loop would be more expensive.\\r\\n      uint32 length = uint32(_readIndefiniteStringLength(\\r\\n        cbor.buffer,\\r\\n        cbor.majorType\\r\\n      ));\\r\\n      if (length < UINT32_MAX) {\\r\\n        output = abi.encodePacked(cbor.buffer.read(length));\\r\\n        length = uint32(_readIndefiniteStringLength(\\r\\n          cbor.buffer,\\r\\n          cbor.majorType\\r\\n        ));\\r\\n        if (length < UINT32_MAX) {\\r\\n          output = abi.encodePacked(\\r\\n            output,\\r\\n            cbor.buffer.read(length)\\r\\n          );\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      return cbor.buffer.read(uint32(cbor.len));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a `fixed16` value.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 5 decimal orders so as to get a fixed precision of 5 decimal positions, which should be OK for most `fixed16`\\r\\n  /// use cases. In other words, the output of this method is 10,000 times the actual value, encoded into an `int32`.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as an `int128` value.\\r\\n  function readFloat16(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_CONTENT_FREE)\\r\\n    returns (int32)\\r\\n  {\\r\\n    if (cbor.additionalInformation == 25) {\\r\\n      return cbor.buffer.readFloat16();\\r\\n    } else {\\r\\n      revert UnsupportedPrimitive(cbor.additionalInformation);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a `fixed32` value.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 9 decimal orders so as to get a fixed precision of 9 decimal positions, which should be OK for most `fixed64`\\r\\n  /// use cases. In other words, the output of this method is 10^9 times the actual value, encoded into an `int`.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as an `int` value.\\r\\n  function readFloat32(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_CONTENT_FREE)\\r\\n    returns (int)\\r\\n  {\\r\\n    if (cbor.additionalInformation == 26) {\\r\\n      return cbor.buffer.readFloat32();\\r\\n    } else {\\r\\n      revert UnsupportedPrimitive(cbor.additionalInformation);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a `fixed64` value.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 15 decimal orders so as to get a fixed precision of 15 decimal positions, which should be OK for most `fixed64`\\r\\n  /// use cases. In other words, the output of this method is 10^15 times the actual value, encoded into an `int`.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as an `int` value.\\r\\n  function readFloat64(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_CONTENT_FREE)\\r\\n    returns (int)\\r\\n  {\\r\\n    if (cbor.additionalInformation == 27) {\\r\\n      return cbor.buffer.readFloat64();\\r\\n    } else {\\r\\n      revert UnsupportedPrimitive(cbor.additionalInformation);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `int128[]` value whose inner values follow the same convention \\r\\n  /// @notice as explained in `decodeFixed16`.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  function readFloat16Array(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_ARRAY)\\r\\n    returns (int32[] memory values)\\r\\n  {\\r\\n    uint64 length = readLength(cbor.buffer, cbor.additionalInformation);\\r\\n    if (length < UINT64_MAX) {\\r\\n      values = new int32[](length);\\r\\n      for (uint64 i = 0; i < length; ) {\\r\\n        CBOR memory item = fromBuffer(cbor.buffer);\\r\\n        values[i] = readFloat16(item);\\r\\n        unchecked {\\r\\n          i ++;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      revert InvalidLengthEncoding(length);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `int128` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as an `int128` value.\\r\\n  function readInt(CBOR memory cbor)\\r\\n    internal pure\\r\\n    returns (int)\\r\\n  {\\r\\n    if (cbor.majorType == 1) {\\r\\n      uint64 _value = readLength(\\r\\n        cbor.buffer,\\r\\n        cbor.additionalInformation\\r\\n      );\\r\\n      return int(-1) - int(uint(_value));\\r\\n    } else if (cbor.majorType == 0) {\\r\\n      // Any `uint64` can be safely casted to `int128`, so this method supports majorType 1 as well so as to have offer\\r\\n      // a uniform API for positive and negative numbers\\r\\n      return int(readUint(cbor));\\r\\n    }\\r\\n    else {\\r\\n      revert UnexpectedMajorType(cbor.majorType, 1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `int[]` value.\\r\\n  /// @param cbor instance of `CBOR`.\\r\\n  /// @return array The value represented by the input, as an `int[]` value.\\r\\n  function readIntArray(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_ARRAY)\\r\\n    returns (int[] memory array)\\r\\n  {\\r\\n    uint64 length = readLength(cbor.buffer, cbor.additionalInformation);\\r\\n    if (length < UINT64_MAX) {\\r\\n      array = new int[](length);\\r\\n      for (uint i = 0; i < length; ) {\\r\\n        CBOR memory item = fromBuffer(cbor.buffer);\\r\\n        array[i] = readInt(item);\\r\\n        unchecked {\\r\\n          i ++;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      revert InvalidLengthEncoding(length);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `string` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return text The value represented by the input, as a `string` value.\\r\\n  function readString(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_STRING)\\r\\n    returns (string memory text)\\r\\n  {\\r\\n    cbor.len = readLength(cbor.buffer, cbor.additionalInformation);\\r\\n    if (cbor.len == UINT64_MAX) {\\r\\n      bool _done;\\r\\n      while (!_done) {\\r\\n        uint64 length = _readIndefiniteStringLength(\\r\\n          cbor.buffer,\\r\\n          cbor.majorType\\r\\n        );\\r\\n        if (length < UINT64_MAX) {\\r\\n          text = string(abi.encodePacked(\\r\\n            text,\\r\\n            cbor.buffer.readText(length / 4)\\r\\n          ));\\r\\n        } else {\\r\\n          _done = true;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      return string(cbor.buffer.readText(cbor.len));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `string[]` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return strings The value represented by the input, as an `string[]` value.\\r\\n  function readStringArray(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_ARRAY)\\r\\n    returns (string[] memory strings)\\r\\n  {\\r\\n    uint length = readLength(cbor.buffer, cbor.additionalInformation);\\r\\n    if (length < UINT64_MAX) {\\r\\n      strings = new string[](length);\\r\\n      for (uint i = 0; i < length; ) {\\r\\n        CBOR memory item = fromBuffer(cbor.buffer);\\r\\n        strings[i] = readString(item);\\r\\n        unchecked {\\r\\n          i ++;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      revert InvalidLengthEncoding(length);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `uint64` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return The value represented by the input, as an `uint64` value.\\r\\n  function readUint(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_INT)\\r\\n    returns (uint)\\r\\n  {\\r\\n    return readLength(\\r\\n      cbor.buffer,\\r\\n      cbor.additionalInformation\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Decode a `CBOR` structure into a native `uint64[]` value.\\r\\n  /// @param cbor An instance of `CBOR`.\\r\\n  /// @return values The value represented by the input, as an `uint64[]` value.\\r\\n  function readUintArray(CBOR memory cbor)\\r\\n    internal pure\\r\\n    isMajorType(cbor, MAJOR_TYPE_ARRAY)\\r\\n    returns (uint[] memory values)\\r\\n  {\\r\\n    uint64 length = readLength(cbor.buffer, cbor.additionalInformation);\\r\\n    if (length < UINT64_MAX) {\\r\\n      values = new uint[](length);\\r\\n      for (uint ix = 0; ix < length; ) {\\r\\n        CBOR memory item = fromBuffer(cbor.buffer);\\r\\n        values[ix] = readUint(item);\\r\\n        unchecked {\\r\\n          ix ++;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      revert InvalidLengthEncoding(length);\\r\\n    }\\r\\n  }  \\r\\n\\r\\n  /// Read the length of a CBOR indifinite-length item (arrays, maps, byte strings and text) from a buffer, consuming\\r\\n  /// as many bytes as specified by the first byte.\\r\\n  function _readIndefiniteStringLength(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint8 majorType\\r\\n    )\\r\\n    private pure\\r\\n    returns (uint64 len)\\r\\n  {\\r\\n    uint8 initialByte = buffer.readUint8();\\r\\n    if (initialByte == 0xff) {\\r\\n      return UINT64_MAX;\\r\\n    }\\r\\n    len = readLength(\\r\\n      buffer,\\r\\n      initialByte & 0x1f\\r\\n    );\\r\\n    if (len >= UINT64_MAX) {\\r\\n      revert InvalidLengthEncoding(len);\\r\\n    } else if (majorType != (initialByte >> 5)) {\\r\\n      revert UnexpectedMajorType((initialByte >> 5), majorType);\\r\\n    }\\r\\n  }\\r\\n \\r\\n}\"\r\n    },\r\n    \"/contracts/libs/WitnetBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\n/// @title A convenient wrapper around the `bytes memory` type that exposes a buffer-like interface\\r\\n/// @notice The buffer has an inner cursor that tracks the final offset of every read, i.e. any subsequent read will\\r\\n/// start with the byte that goes right after the last one in the previous read.\\r\\n/// @dev `uint32` is used here for `cursor` because `uint16` would only enable seeking up to 8KB, which could in some\\r\\n/// theoretical use cases be exceeded. Conversely, `uint32` supports up to 512MB, which cannot credibly be exceeded.\\r\\n/// @author The Witnet Foundation.\\r\\nlibrary WitnetBuffer {\\r\\n\\r\\n  error EmptyBuffer();\\r\\n  error IndexOutOfBounds(uint index, uint range);\\r\\n  error MissingArgs(uint expected, uint given);\\r\\n\\r\\n  /// Iterable bytes buffer.\\r\\n  struct Buffer {\\r\\n      bytes data;\\r\\n      uint cursor;\\r\\n  }\\r\\n\\r\\n  // Ensures we access an existing index in an array\\r\\n  modifier withinRange(uint index, uint _range) {\\r\\n    if (index > _range) {\\r\\n      revert IndexOutOfBounds(index, _range);\\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @notice Concatenate undefinite number of bytes chunks.\\r\\n  /// @dev Faster than looping on `abi.encodePacked(output, _buffs[ix])`.\\r\\n  function concat(bytes[] memory _buffs)\\r\\n    internal pure\\r\\n    returns (bytes memory output)\\r\\n  {\\r\\n    unchecked {\\r\\n      uint destinationPointer;\\r\\n      uint destinationLength;\\r\\n      assembly {\\r\\n        // get safe scratch location\\r\\n        output := mload(0x40)\\r\\n        // set starting destination pointer\\r\\n        destinationPointer := add(output, 32)\\r\\n      }      \\r\\n      for (uint ix = 1; ix <= _buffs.length; ix ++) {  \\r\\n        uint source;\\r\\n        uint sourceLength;\\r\\n        uint sourcePointer;        \\r\\n        assembly {\\r\\n          // load source length pointer\\r\\n          source := mload(add(_buffs, mul(ix, 32)))\\r\\n          // load source length\\r\\n          sourceLength := mload(source)\\r\\n          // sets source memory pointer\\r\\n          sourcePointer := add(source, 32)\\r\\n        }\\r\\n        memcpy(\\r\\n          destinationPointer,\\r\\n          sourcePointer,\\r\\n          sourceLength\\r\\n        );\\r\\n        assembly {          \\r\\n          // increase total destination length\\r\\n          destinationLength := add(destinationLength, sourceLength)\\r\\n          // sets destination memory pointer\\r\\n          destinationPointer := add(destinationPointer, sourceLength)\\r\\n        }\\r\\n      }\\r\\n      assembly {\\r\\n        // protect output bytes\\r\\n        mstore(output, destinationLength)\\r\\n        // set final output length\\r\\n        mstore(0x40, add(mload(0x40), add(destinationLength, 32)))\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function fork(WitnetBuffer.Buffer memory buffer)\\r\\n    internal pure\\r\\n    returns (WitnetBuffer.Buffer memory)\\r\\n  {\\r\\n    return Buffer(\\r\\n      buffer.data,\\r\\n      buffer.cursor\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function mutate(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint length,\\r\\n      bytes memory pokes\\r\\n    )\\r\\n    internal pure\\r\\n    withinRange(length, buffer.data.length - buffer.cursor + 1)\\r\\n  {\\r\\n    bytes[] memory parts = new bytes[](3);\\r\\n    parts[0] = peek(\\r\\n      buffer,\\r\\n      0,\\r\\n      buffer.cursor\\r\\n    );\\r\\n    parts[1] = pokes;\\r\\n    parts[2] = peek(\\r\\n      buffer,\\r\\n      buffer.cursor + length,\\r\\n      buffer.data.length - buffer.cursor - length\\r\\n    );\\r\\n    buffer.data = concat(parts);\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next byte from the buffer.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return The next byte in the buffer counting from the cursor position.\\r\\n  function next(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor, buffer.data.length)\\r\\n    returns (bytes1)\\r\\n  {\\r\\n    // Return the byte at the position marked by the cursor and advance the cursor all at once\\r\\n    return buffer.data[buffer.cursor ++];\\r\\n  }\\r\\n\\r\\n  function peek(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint offset,\\r\\n      uint length\\r\\n    )\\r\\n    internal pure\\r\\n    withinRange(offset + length, buffer.data.length)\\r\\n    returns (bytes memory)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    bytes memory peeks = new bytes(length);\\r\\n    uint destinationPointer;\\r\\n    uint sourcePointer;\\r\\n    assembly {\\r\\n      destinationPointer := add(peeks, 32)\\r\\n      sourcePointer := add(add(data, 32), offset)\\r\\n    }\\r\\n    memcpy(\\r\\n      destinationPointer,\\r\\n      sourcePointer,\\r\\n      length\\r\\n    );\\r\\n    return peeks;\\r\\n  }\\r\\n\\r\\n  // @notice Extract bytes array from buffer starting from current cursor.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @param length How many bytes to peek from the Buffer.\\r\\n  // solium-disable-next-line security/no-assign-params\\r\\n  function peek(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint length\\r\\n    )\\r\\n    internal pure\\r\\n    withinRange(length, buffer.data.length - buffer.cursor)\\r\\n    returns (bytes memory)\\r\\n  {\\r\\n    return peek(\\r\\n      buffer,\\r\\n      buffer.cursor,\\r\\n      length\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume a certain amount of bytes from the buffer.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @param length How many bytes to read and consume from the buffer.\\r\\n  /// @return output A `bytes memory` containing the first `length` bytes from the buffer, counting from the cursor position.\\r\\n  function read(Buffer memory buffer, uint length)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + length, buffer.data.length)\\r\\n    returns (bytes memory output)\\r\\n  {\\r\\n    // Create a new `bytes memory destination` value\\r\\n    output = new bytes(length);\\r\\n    // Early return in case that bytes length is 0\\r\\n    if (length > 0) {\\r\\n      bytes memory input = buffer.data;\\r\\n      uint offset = buffer.cursor;\\r\\n      // Get raw pointers for source and destination\\r\\n      uint sourcePointer;\\r\\n      uint destinationPointer;\\r\\n      assembly {\\r\\n        sourcePointer := add(add(input, 32), offset)\\r\\n        destinationPointer := add(output, 32)\\r\\n      }\\r\\n      // Copy `length` bytes from source to destination\\r\\n      memcpy(\\r\\n        destinationPointer,\\r\\n        sourcePointer,\\r\\n        length\\r\\n      );\\r\\n      // Move the cursor forward by `length` bytes\\r\\n      seek(\\r\\n        buffer,\\r\\n        length,\\r\\n        true\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  /// @notice Read and consume the next 2 bytes from the buffer as an IEEE 754-2008 floating point number enclosed in an\\r\\n  /// `int32`.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 5 decimal orders so as to get a fixed precision of 5 decimal positions, which should be OK for most `float16`\\r\\n  /// use cases. In other words, the integer output of this method is 10,000 times the actual value. The input bytes are\\r\\n  /// expected to follow the 16-bit base-2 format (a.k.a. `binary16`) in the IEEE 754-2008 standard.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return result The `int32` value of the next 4 bytes in the buffer counting from the cursor position.\\r\\n  function readFloat16(Buffer memory buffer)\\r\\n    internal pure\\r\\n    returns (int32 result)\\r\\n  {\\r\\n    uint32 value = readUint16(buffer);\\r\\n    // Get bit at position 0\\r\\n    uint32 sign = value & 0x8000;\\r\\n    // Get bits 1 to 5, then normalize to the [-15, 16] range so as to counterweight the IEEE 754 exponent bias\\r\\n    int32 exponent = (int32(value & 0x7c00) >> 10) - 15;\\r\\n    // Get bits 6 to 15\\r\\n    int32 fraction = int32(value & 0x03ff);\\r\\n    // Add 2^10 to the fraction if exponent is not -15\\r\\n    if (exponent != -15) {\\r\\n      fraction |= 0x400;\\r\\n    } else if (exponent == 16) {\\r\\n      revert(\\r\\n        string(abi.encodePacked(\\r\\n          \\\"WitnetBuffer.readFloat16: \\\",\\r\\n          sign != 0 ? \\\"negative\\\" : hex\\\"\\\",\\r\\n          \\\" infinity\\\"\\r\\n        ))\\r\\n      );\\r\\n    }\\r\\n    // Compute `2 ^ exponent \u00b7 (1 + fraction / 1024)`\\r\\n    if (exponent >= 0) {\\r\\n      result = int32(int(\\r\\n        int(1 << uint256(int256(exponent)))\\r\\n          * 10000\\r\\n          * fraction\\r\\n      ) >> 10);\\r\\n    } else {\\r\\n      result = int32(int(\\r\\n        int(fraction)\\r\\n          * 10000\\r\\n          / int(1 << uint(int(- exponent)))\\r\\n      ) >> 10);\\r\\n    }\\r\\n    // Make the result negative if the sign bit is not 0\\r\\n    if (sign != 0) {\\r\\n      result *= -1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Consume the next 4 bytes from the buffer as an IEEE 754-2008 floating point number enclosed into an `int`.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 9 decimal orders so as to get a fixed precision of 9 decimal positions, which should be OK for most `float32`\\r\\n  /// use cases. In other words, the integer output of this method is 10^9 times the actual value. The input bytes are\\r\\n  /// expected to follow the 64-bit base-2 format (a.k.a. `binary32`) in the IEEE 754-2008 standard.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return result The `int` value of the next 8 bytes in the buffer counting from the cursor position.\\r\\n  function readFloat32(Buffer memory buffer)\\r\\n    internal pure\\r\\n    returns (int result)\\r\\n  {\\r\\n    uint value = readUint32(buffer);\\r\\n    // Get bit at position 0\\r\\n    uint sign = value & 0x80000000;\\r\\n    // Get bits 1 to 8, then normalize to the [-127, 128] range so as to counterweight the IEEE 754 exponent bias\\r\\n    int exponent = (int(value & 0x7f800000) >> 23) - 127;\\r\\n    // Get bits 9 to 31\\r\\n    int fraction = int(value & 0x007fffff);\\r\\n    // Add 2^23 to the fraction if exponent is not -127\\r\\n    if (exponent != -127) {\\r\\n      fraction |= 0x800000;\\r\\n    } else if (exponent == 128) {\\r\\n      revert(\\r\\n        string(abi.encodePacked(\\r\\n          \\\"WitnetBuffer.readFloat32: \\\",\\r\\n          sign != 0 ? \\\"negative\\\" : hex\\\"\\\",\\r\\n          \\\" infinity\\\"\\r\\n        ))\\r\\n      );\\r\\n    }\\r\\n    // Compute `2 ^ exponent \u00b7 (1 + fraction / 2^23)`\\r\\n    if (exponent >= 0) {\\r\\n      result = (\\r\\n        int(1 << uint(exponent))\\r\\n          * (10 ** 9)\\r\\n          * fraction\\r\\n      ) >> 23;\\r\\n    } else {\\r\\n      result = (\\r\\n        fraction \\r\\n          * (10 ** 9)\\r\\n          / int(1 << uint(-exponent)) \\r\\n      ) >> 23;\\r\\n    }\\r\\n    // Make the result negative if the sign bit is not 0\\r\\n    if (sign != 0) {\\r\\n      result *= -1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Consume the next 8 bytes from the buffer as an IEEE 754-2008 floating point number enclosed into an `int`.\\r\\n  /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values\\r\\n  /// by 15 decimal orders so as to get a fixed precision of 15 decimal positions, which should be OK for most `float64`\\r\\n  /// use cases. In other words, the integer output of this method is 10^15 times the actual value. The input bytes are\\r\\n  /// expected to follow the 64-bit base-2 format (a.k.a. `binary64`) in the IEEE 754-2008 standard.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return result The `int` value of the next 8 bytes in the buffer counting from the cursor position.\\r\\n  function readFloat64(Buffer memory buffer)\\r\\n    internal pure\\r\\n    returns (int result)\\r\\n  {\\r\\n    uint value = readUint64(buffer);\\r\\n    // Get bit at position 0\\r\\n    uint sign = value & 0x8000000000000000;\\r\\n    // Get bits 1 to 12, then normalize to the [-1023, 1024] range so as to counterweight the IEEE 754 exponent bias\\r\\n    int exponent = (int(value & 0x7ff0000000000000) >> 52) - 1023;\\r\\n    // Get bits 6 to 15\\r\\n    int fraction = int(value & 0x000fffffffffffff);\\r\\n    // Add 2^52 to the fraction if exponent is not -1023\\r\\n    if (exponent != -1023) {\\r\\n      fraction |= 0x10000000000000;\\r\\n    } else if (exponent == 1024) {\\r\\n      revert(\\r\\n        string(abi.encodePacked(\\r\\n          \\\"WitnetBuffer.readFloat64: \\\",\\r\\n          sign != 0 ? \\\"negative\\\" : hex\\\"\\\",\\r\\n          \\\" infinity\\\"\\r\\n        ))\\r\\n      );\\r\\n    }\\r\\n    // Compute `2 ^ exponent \u00b7 (1 + fraction / 1024)`\\r\\n    if (exponent >= 0) {\\r\\n      result = (\\r\\n        int(1 << uint(exponent))\\r\\n          * (10 ** 15)\\r\\n          * fraction\\r\\n      ) >> 52;\\r\\n    } else {\\r\\n      result = (\\r\\n        fraction \\r\\n          * (10 ** 15)\\r\\n          / int(1 << uint(-exponent)) \\r\\n      ) >> 52;\\r\\n    }\\r\\n    // Make the result negative if the sign bit is not 0\\r\\n    if (sign != 0) {\\r\\n      result *= -1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Read a text string of a given length from a buffer. Returns a `bytes memory` value for the sake of genericness,\\r\\n  /// but it can be easily casted into a string with `string(result)`.\\r\\n  // solium-disable-next-line security/no-assign-params\\r\\n  function readText(\\r\\n      WitnetBuffer.Buffer memory buffer,\\r\\n      uint64 length\\r\\n    )\\r\\n    internal pure\\r\\n    returns (bytes memory text)\\r\\n  {\\r\\n    text = new bytes(length);\\r\\n    unchecked {\\r\\n      for (uint64 index = 0; index < length; index ++) {\\r\\n        uint8 char = readUint8(buffer);\\r\\n        if (char & 0x80 != 0) {\\r\\n          if (char < 0xe0) {\\r\\n            char = (char & 0x1f) << 6\\r\\n              | (readUint8(buffer) & 0x3f);\\r\\n            length -= 1;\\r\\n          } else if (char < 0xf0) {\\r\\n            char  = (char & 0x0f) << 12\\r\\n              | (readUint8(buffer) & 0x3f) << 6\\r\\n              | (readUint8(buffer) & 0x3f);\\r\\n            length -= 2;\\r\\n          } else {\\r\\n            char = (char & 0x0f) << 18\\r\\n              | (readUint8(buffer) & 0x3f) << 12\\r\\n              | (readUint8(buffer) & 0x3f) << 6  \\r\\n              | (readUint8(buffer) & 0x3f);\\r\\n            length -= 3;\\r\\n          }\\r\\n        }\\r\\n        text[index] = bytes1(char);\\r\\n      }\\r\\n      // Adjust text to actual length:\\r\\n      assembly {\\r\\n        mstore(text, length)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next byte from the buffer as an `uint8`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint8` value of the next byte in the buffer counting from the cursor position.\\r\\n  function readUint8(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor, buffer.data.length)\\r\\n    returns (uint8 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 1), offset))\\r\\n    }\\r\\n    buffer.cursor ++;\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next 2 bytes from the buffer as an `uint16`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint16` value of the next 2 bytes in the buffer counting from the cursor position.\\r\\n  function readUint16(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + 2, buffer.data.length)\\r\\n    returns (uint16 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 2), offset))\\r\\n    }\\r\\n    buffer.cursor += 2;\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next 4 bytes from the buffer as an `uint32`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint32` value of the next 4 bytes in the buffer counting from the cursor position.\\r\\n  function readUint32(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + 4, buffer.data.length)\\r\\n    returns (uint32 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 4), offset))\\r\\n    }\\r\\n    buffer.cursor += 4;\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next 8 bytes from the buffer as an `uint64`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint64` value of the next 8 bytes in the buffer counting from the cursor position.\\r\\n  function readUint64(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + 8, buffer.data.length)\\r\\n    returns (uint64 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 8), offset))\\r\\n    }\\r\\n    buffer.cursor += 8;\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next 16 bytes from the buffer as an `uint128`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint128` value of the next 16 bytes in the buffer counting from the cursor position.\\r\\n  function readUint128(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + 16, buffer.data.length)\\r\\n    returns (uint128 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 16), offset))\\r\\n    }\\r\\n    buffer.cursor += 16;\\r\\n  }\\r\\n\\r\\n  /// @notice Read and consume the next 32 bytes from the buffer as an `uint256`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @return value The `uint256` value of the next 32 bytes in the buffer counting from the cursor position.\\r\\n  function readUint256(Buffer memory buffer)\\r\\n    internal pure\\r\\n    withinRange(buffer.cursor + 32, buffer.data.length)\\r\\n    returns (uint256 value)\\r\\n  {\\r\\n    bytes memory data = buffer.data;\\r\\n    uint offset = buffer.cursor;\\r\\n    assembly {\\r\\n      value := mload(add(add(data, 32), offset))\\r\\n    }\\r\\n    buffer.cursor += 32;\\r\\n  }\\r\\n\\r\\n  /// @notice Count number of required parameters for given bytes arrays\\r\\n  /// @dev Wildcard format: \\\"\\\\#\\\\\\\", with # in [\\\"0\\\"..\\\"9\\\"].\\r\\n  /// @param input Bytes array containing strings.\\r\\n  /// @param count Highest wildcard index found, plus 1.\\r\\n  function argsCountOf(bytes memory input)\\r\\n    internal pure\\r\\n    returns (uint8 count)\\r\\n  {\\r\\n    if (input.length < 3) {\\r\\n      return 0;\\r\\n    }\\r\\n    unchecked {\\r\\n      uint ix = 0; \\r\\n      uint length = input.length - 2;\\r\\n      for (; ix < length; ) {\\r\\n        if (\\r\\n          input[ix] == bytes1(\\\"\\\\\\\\\\\")\\r\\n            && input[ix + 2] == bytes1(\\\"\\\\\\\\\\\")\\r\\n            && input[ix + 1] >= bytes1(\\\"0\\\")\\r\\n            && input[ix + 1] <= bytes1(\\\"9\\\")\\r\\n        ) {\\r\\n          uint8 ax = uint8(uint8(input[ix + 1]) - uint8(bytes1(\\\"0\\\")) + 1);\\r\\n          if (ax > count) {\\r\\n            count = ax;\\r\\n          }\\r\\n          ix += 3;\\r\\n        } else {\\r\\n          ix ++;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Replace bytecode indexed wildcards by correspondent substrings.\\r\\n  /// @dev Wildcard format: \\\"\\\\#\\\\\\\", with # in [\\\"0\\\"..\\\"9\\\"].\\r\\n  /// @param input Bytes array containing strings.\\r\\n  /// @param args Array of substring values for replacing indexed wildcards.\\r\\n  /// @return output Resulting bytes array after replacing all wildcards.\\r\\n  /// @return hits Total number of replaced wildcards.\\r\\n  function replace(bytes memory input, string[] memory args)\\r\\n    internal pure\\r\\n    returns (bytes memory output, uint hits)\\r\\n  {\\r\\n    uint ix = 0; uint lix = 0;\\r\\n    uint inputLength;\\r\\n    uint inputPointer;\\r\\n    uint outputLength;\\r\\n    uint outputPointer;    \\r\\n    uint source;\\r\\n    uint sourceLength;\\r\\n    uint sourcePointer;\\r\\n\\r\\n    if (input.length < 3) {\\r\\n      return (input, 0);\\r\\n    }\\r\\n    \\r\\n    assembly {\\r\\n      // set starting input pointer\\r\\n      inputPointer := add(input, 32)\\r\\n      // get safe output location\\r\\n      output := mload(0x40)\\r\\n      // set starting output pointer\\r\\n      outputPointer := add(output, 32)\\r\\n    }         \\r\\n\\r\\n    unchecked {\\r\\n      uint length = input.length - 2;\\r\\n      for (; ix < length; ) {\\r\\n        if (\\r\\n          input[ix] == bytes1(\\\"\\\\\\\\\\\")\\r\\n            && input[ix + 2] == bytes1(\\\"\\\\\\\\\\\")\\r\\n            && input[ix + 1] >= bytes1(\\\"0\\\")\\r\\n            && input[ix + 1] <= bytes1(\\\"9\\\")\\r\\n        ) {\\r\\n          inputLength = (ix - lix);\\r\\n          if (ix > lix) {\\r\\n            memcpy(\\r\\n              outputPointer,\\r\\n              inputPointer,\\r\\n              inputLength\\r\\n            );\\r\\n            inputPointer += inputLength + 3;\\r\\n            outputPointer += inputLength;\\r\\n          } else {\\r\\n            inputPointer += 3;\\r\\n          }\\r\\n          uint ax = uint(uint8(input[ix + 1]) - uint8(bytes1(\\\"0\\\")));\\r\\n          if (ax >= args.length) {\\r\\n            revert MissingArgs(ax + 1, args.length);\\r\\n          }\\r\\n          assembly {\\r\\n            source := mload(add(args, mul(32, add(ax, 1))))\\r\\n            sourceLength := mload(source)\\r\\n            sourcePointer := add(source, 32)      \\r\\n          }        \\r\\n          memcpy(\\r\\n            outputPointer,\\r\\n            sourcePointer,\\r\\n            sourceLength\\r\\n          );\\r\\n          outputLength += inputLength + sourceLength;\\r\\n          outputPointer += sourceLength;\\r\\n          ix += 3;\\r\\n          lix = ix;\\r\\n          hits ++;\\r\\n        } else {\\r\\n          ix ++;\\r\\n        }\\r\\n      }\\r\\n      ix = input.length;    \\r\\n    }\\r\\n    if (outputLength > 0) {\\r\\n      if (ix > lix ) {\\r\\n        memcpy(\\r\\n          outputPointer,\\r\\n          inputPointer,\\r\\n          ix - lix\\r\\n        );\\r\\n        outputLength += (ix - lix);\\r\\n      }\\r\\n      assembly {\\r\\n        // set final output length\\r\\n        mstore(output, outputLength)\\r\\n        // protect output bytes\\r\\n        mstore(0x40, add(mload(0x40), add(outputLength, 32)))\\r\\n      }\\r\\n    }\\r\\n    else {\\r\\n      return (input, 0);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Replace string indexed wildcards by correspondent substrings.\\r\\n  /// @dev Wildcard format: \\\"\\\\#\\\\\\\", with # in [\\\"0\\\"..\\\"9\\\"].\\r\\n  /// @param input String potentially containing wildcards.\\r\\n  /// @param args Array of substring values for replacing indexed wildcards.\\r\\n  /// @return output Resulting string after replacing all wildcards.\\r\\n  function replace(string memory input, string[] memory args)\\r\\n    internal pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    (bytes memory _outputBytes, ) = replace(bytes(input), args);\\r\\n    return string(_outputBytes);\\r\\n  }\\r\\n\\r\\n  /// @notice Move the inner cursor of the buffer to a relative or absolute position.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @param offset How many bytes to move the cursor forward.\\r\\n  /// @param relative Whether to count `offset` from the last position of the cursor (`true`) or the beginning of the\\r\\n  /// buffer (`true`).\\r\\n  /// @return The final position of the cursor (will equal `offset` if `relative` is `false`).\\r\\n  // solium-disable-next-line security/no-assign-params\\r\\n  function seek(\\r\\n      Buffer memory buffer,\\r\\n      uint offset,\\r\\n      bool relative\\r\\n    )\\r\\n    internal pure\\r\\n    withinRange(offset, buffer.data.length)\\r\\n    returns (uint)\\r\\n  {\\r\\n    // Deal with relative offsets\\r\\n    if (relative) {\\r\\n      offset += buffer.cursor;\\r\\n    }\\r\\n    buffer.cursor = offset;\\r\\n    return offset;\\r\\n  }\\r\\n\\r\\n  /// @notice Move the inner cursor a number of bytes forward.\\r\\n  /// @dev This is a simple wrapper around the relative offset case of `seek()`.\\r\\n  /// @param buffer An instance of `Buffer`.\\r\\n  /// @param relativeOffset How many bytes to move the cursor forward.\\r\\n  /// @return The final position of the cursor.\\r\\n  function seek(\\r\\n      Buffer memory buffer,\\r\\n      uint relativeOffset\\r\\n    )\\r\\n    internal pure\\r\\n    returns (uint)\\r\\n  {\\r\\n    return seek(\\r\\n      buffer,\\r\\n      relativeOffset,\\r\\n      true\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Copy bytes from one memory address into another.\\r\\n  /// @dev This function was borrowed from Nick Johnson's `solidity-stringutils` lib, and reproduced here under the terms\\r\\n  /// of [Apache License 2.0](https://github.com/Arachnid/solidity-stringutils/blob/master/LICENSE).\\r\\n  /// @param dest Address of the destination memory.\\r\\n  /// @param src Address to the source memory.\\r\\n  /// @param len How many bytes to copy.\\r\\n  // solium-disable-next-line security/no-assign-params\\r\\n  function memcpy(\\r\\n      uint dest,\\r\\n      uint src,\\r\\n      uint len\\r\\n    )\\r\\n    private pure\\r\\n  {\\r\\n    unchecked {\\r\\n      // Copy word-length chunks while possible\\r\\n      for (; len >= 32; len -= 32) {\\r\\n        assembly {\\r\\n          mstore(dest, mload(src))\\r\\n        }\\r\\n        dest += 32;\\r\\n        src += 32;\\r\\n      }\\r\\n      if (len > 0) {\\r\\n        // Copy remaining bytes\\r\\n        uint _mask = 256 ** (32 - len) - 1;\\r\\n        assembly {\\r\\n          let srcpart := and(mload(src), not(_mask))\\r\\n          let destpart := and(mload(dest), _mask)\\r\\n          mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/contracts/libs/Witnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./WitnetCBOR.sol\\\";\\r\\n\\r\\nlibrary Witnet {\\r\\n\\r\\n    using WitnetBuffer for WitnetBuffer.Buffer;\\r\\n    using WitnetCBOR for WitnetCBOR.CBOR;\\r\\n    using WitnetCBOR for WitnetCBOR.CBOR[];\\r\\n\\r\\n    /// Struct containing both request and response data related to every query posted to the Witnet Request Board\\r\\n    struct Query {\\r\\n        Request request;\\r\\n        Response response;\\r\\n        address from;      // Address from which the request was posted.\\r\\n    }\\r\\n\\r\\n    /// Possible status of a Witnet query.\\r\\n    enum QueryStatus {\\r\\n        Unknown,\\r\\n        Posted,\\r\\n        Reported,\\r\\n        Deleted\\r\\n    }\\r\\n\\r\\n    /// Data kept in EVM-storage for every Request posted to the Witnet Request Board.\\r\\n    struct Request {\\r\\n        address addr;       // Address of the (deprecated) IWitnetRequest contract containing Witnet data request raw bytecode.\\r\\n        bytes32 slaHash;    // Radon SLA hash of the Witnet data request.\\r\\n        bytes32 radHash;    // Radon radHash of the Witnet data request.\\r\\n        uint256 gasprice;   // Minimum gas price the DR resolver should pay on the solving tx.\\r\\n        uint256 reward;     // Escrowed reward to be paid to the DR resolver.\\r\\n    }\\r\\n\\r\\n    /// Data kept in EVM-storage containing the Witnet-provided response metadata and CBOR-encoded result.\\r\\n    struct Response {\\r\\n        address reporter;       // Address from which the result was reported.\\r\\n        uint256 timestamp;      // Timestamp of the Witnet-provided result.\\r\\n        bytes32 drTxHash;       // Hash of the Witnet transaction that solved the queried Data Request.\\r\\n        bytes   cborBytes;      // Witnet-provided result CBOR-bytes to the queried Data Request.\\r\\n    }\\r\\n\\r\\n    /// Data struct containing the Witnet-provided result to a Data Request.\\r\\n    struct Result {\\r\\n        bool success;           // Flag stating whether the request could get solved successfully, or not.\\r\\n        WitnetCBOR.CBOR value;  // Resulting value, in CBOR-serialized bytes.\\r\\n    }\\r\\n\\r\\n    /// Final query's result status from a requester's point of view.\\r\\n    enum ResultStatus {\\r\\n        Void,\\r\\n        Awaiting,\\r\\n        Ready,\\r\\n        Error\\r\\n    }\\r\\n\\r\\n    /// Data struct describing an error when trying to fetch a Witnet-provided result to a Data Request.\\r\\n    struct ResultError {\\r\\n        ResultErrorCodes code;\\r\\n        string reason;\\r\\n    }\\r\\n\\r\\n    enum ResultErrorCodes {\\r\\n        /// 0x00: Unknown error. Something went really bad!\\r\\n        Unknown, \\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Source-specific format error sub-codes ============================================================================\\r\\n        /// 0x01: At least one of the source scripts is not a valid CBOR-encoded value.\\r\\n        SourceScriptNotCBOR, \\r\\n        /// 0x02: The CBOR value decoded from a source script is not an Array.\\r\\n        SourceScriptNotArray,\\r\\n        /// 0x03: The Array value decoded form a source script is not a valid Data Request.\\r\\n        SourceScriptNotRADON,\\r\\n        /// 0x04: The request body of at least one data source was not properly formated.\\r\\n        SourceRequestBody,\\r\\n        /// 0x05: The request headers of at least one data source was not properly formated.\\r\\n        SourceRequestHeaders,\\r\\n        /// 0x06: The request URL of at least one data source was not properly formated.\\r\\n        SourceRequestURL,\\r\\n        /// Unallocated\\r\\n        SourceFormat0x07, SourceFormat0x08, SourceFormat0x09, SourceFormat0x0A, SourceFormat0x0B, SourceFormat0x0C,\\r\\n        SourceFormat0x0D, SourceFormat0x0E, SourceFormat0x0F, \\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Complexity error sub-codes ========================================================================================\\r\\n        /// 0x10: The request contains too many sources.\\r\\n        RequestTooManySources,\\r\\n        /// 0x11: The script contains too many calls.\\r\\n        ScriptTooManyCalls,\\r\\n        /// Unallocated\\r\\n        Complexity0x12, Complexity0x13, Complexity0x14, Complexity0x15, Complexity0x16, Complexity0x17, Complexity0x18,\\r\\n        Complexity0x19, Complexity0x1A, Complexity0x1B, Complexity0x1C, Complexity0x1D, Complexity0x1E, Complexity0x1F,\\r\\n\\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Lack of support error sub-codes ===================================================================================\\r\\n        /// 0x20: Some Radon operator code was found that is not supported (1+ args).\\r\\n        UnsupportedOperator,\\r\\n        /// 0x21: Some Radon filter opcode is not currently supported (1+ args).\\r\\n        UnsupportedFilter,\\r\\n        /// 0x22: Some Radon request type is not currently supported (1+ args).\\r\\n        UnsupportedHashFunction,\\r\\n        /// 0x23: Some Radon reducer opcode is not currently supported (1+ args)\\r\\n        UnsupportedReducer,\\r\\n        /// 0x24: Some Radon hash function is not currently supported (1+ args).\\r\\n        UnsupportedRequestType, \\r\\n        /// 0x25: Some Radon encoding function is not currently supported (1+ args).\\r\\n        UnsupportedEncodingFunction,\\r\\n        /// Unallocated\\r\\n        Operator0x26, Operator0x27, \\r\\n        /// 0x28: Wrong number (or type) of arguments were passed to some Radon operator.\\r\\n        WrongArguments,\\r\\n        /// Unallocated\\r\\n        Operator0x29, Operator0x2A, Operator0x2B, Operator0x2C, Operator0x2D, Operator0x2E, Operator0x2F,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Retrieve-specific circumstantial error sub-codes ================================================================================\\r\\n        /// 0x30: A majority of data sources returned an HTTP status code other than 200 (1+ args):\\r\\n        HttpErrors,\\r\\n        /// 0x31: A majority of data sources timed out:\\r\\n        RetrievalsTimeout,\\r\\n        /// Unallocated\\r\\n        RetrieveCircumstance0x32, RetrieveCircumstance0x33, RetrieveCircumstance0x34, RetrieveCircumstance0x35,\\r\\n        RetrieveCircumstance0x36, RetrieveCircumstance0x37, RetrieveCircumstance0x38, RetrieveCircumstance0x39,\\r\\n        RetrieveCircumstance0x3A, RetrieveCircumstance0x3B, RetrieveCircumstance0x3C, RetrieveCircumstance0x3D,\\r\\n        RetrieveCircumstance0x3E, RetrieveCircumstance0x3F,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Scripting-specific runtime error sub-code =========================================================================\\r\\n        /// 0x40: Math operator caused an underflow.\\r\\n        MathUnderflow,\\r\\n        /// 0x41: Math operator caused an overflow.\\r\\n        MathOverflow,\\r\\n        /// 0x42: Math operator tried to divide by zero.\\r\\n        MathDivisionByZero,            \\r\\n        /// 0x43:Wrong input to subscript call.\\r\\n        WrongSubscriptInput,\\r\\n        /// 0x44: Value cannot be extracted from input binary buffer.\\r\\n        BufferIsNotValue,\\r\\n        /// 0x45: Value cannot be decoded from expected type.\\r\\n        Decode,\\r\\n        /// 0x46: Unexpected empty array.\\r\\n        EmptyArray,\\r\\n        /// 0x47: Value cannot be encoded to expected type.\\r\\n        Encode,\\r\\n        /// 0x48: Failed to filter input values (1+ args).\\r\\n        Filter,\\r\\n        /// 0x49: Failed to hash input value.\\r\\n        Hash,\\r\\n        /// 0x4A: Mismatching array ranks.\\r\\n        MismatchingArrays,\\r\\n        /// 0x4B: Failed to process non-homogenous array.\\r\\n        NonHomegeneousArray,\\r\\n        /// 0x4C: Failed to parse syntax of some input value, or argument.\\r\\n        Parse,\\r\\n        /// 0x4E: Parsing logic limits were exceeded.\\r\\n        ParseOverflow,\\r\\n        /// 0x4F: Unallocated\\r\\n        ScriptError0x4F,\\r\\n    \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Actual first-order result error codes =============================================================================\\r\\n        /// 0x50: Not enough reveals were received in due time:\\r\\n        InsufficientReveals,\\r\\n        /// 0x51: No actual reveal majority was reached on tally stage:\\r\\n        InsufficientMajority,\\r\\n        /// 0x52: Not enough commits were received before tally stage:\\r\\n        InsufficientCommits,\\r\\n        /// 0x53: Generic error during tally execution (to be deprecated after WIP #0028)\\r\\n        TallyExecution,\\r\\n        /// 0x54: A majority of data sources could either be temporarily unresponsive or failing to report the requested data:\\r\\n        CircumstantialFailure,\\r\\n        /// 0x55: At least one data source is inconsistent when queried through multiple transports at once:\\r\\n        InconsistentSources,\\r\\n        /// 0x56: Any one of the (multiple) Retrieve, Aggregate or Tally scripts were badly formated:\\r\\n        MalformedDataRequest,\\r\\n        /// 0x57: Values returned from a majority of data sources don't match the expected schema:\\r\\n        MalformedResponses,\\r\\n        /// Unallocated:    \\r\\n        OtherError0x58, OtherError0x59, OtherError0x5A, OtherError0x5B, OtherError0x5C, OtherError0x5D, OtherError0x5E, \\r\\n        /// 0x5F: Size of serialized tally result exceeds allowance:\\r\\n        OversizedTallyResult,\\r\\n\\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Inter-stage runtime error sub-codes ===============================================================================\\r\\n        /// 0x60: Data aggregation reveals could not get decoded on the tally stage:\\r\\n        MalformedReveals,\\r\\n        /// 0x61: The result to data aggregation could not get encoded:\\r\\n        EncodeReveals,  \\r\\n        /// 0x62: A mode tie ocurred when calculating some mode value on the aggregation or the tally stage:\\r\\n        ModeTie, \\r\\n        /// Unallocated:\\r\\n        OtherError0x63, OtherError0x64, OtherError0x65, OtherError0x66, OtherError0x67, OtherError0x68, OtherError0x69, \\r\\n        OtherError0x6A, OtherError0x6B, OtherError0x6C, OtherError0x6D, OtherError0x6E, OtherError0x6F,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Runtime access error sub-codes ====================================================================================\\r\\n        /// 0x70: Tried to access a value from an array using an index that is out of bounds (1+ args):\\r\\n        ArrayIndexOutOfBounds,\\r\\n        /// 0x71: Tried to access a value from a map using a key that does not exist (1+ args):\\r\\n        MapKeyNotFound,\\r\\n        /// 0X72: Tried to extract value from a map using a JSON Path that returns no values (+1 args):\\r\\n        JsonPathNotFound,\\r\\n        /// Unallocated:\\r\\n        OtherError0x73, OtherError0x74, OtherError0x75, OtherError0x76, OtherError0x77, OtherError0x78, \\r\\n        OtherError0x79, OtherError0x7A, OtherError0x7B, OtherError0x7C, OtherError0x7D, OtherError0x7E, OtherError0x7F, \\r\\n        OtherError0x80, OtherError0x81, OtherError0x82, OtherError0x83, OtherError0x84, OtherError0x85, OtherError0x86, \\r\\n        OtherError0x87, OtherError0x88, OtherError0x89, OtherError0x8A, OtherError0x8B, OtherError0x8C, OtherError0x8D, \\r\\n        OtherError0x8E, OtherError0x8F, OtherError0x90, OtherError0x91, OtherError0x92, OtherError0x93, OtherError0x94, \\r\\n        OtherError0x95, OtherError0x96, OtherError0x97, OtherError0x98, OtherError0x99, OtherError0x9A, OtherError0x9B,\\r\\n        OtherError0x9C, OtherError0x9D, OtherError0x9E, OtherError0x9F, OtherError0xA0, OtherError0xA1, OtherError0xA2, \\r\\n        OtherError0xA3, OtherError0xA4, OtherError0xA5, OtherError0xA6, OtherError0xA7, OtherError0xA8, OtherError0xA9, \\r\\n        OtherError0xAA, OtherError0xAB, OtherError0xAC, OtherError0xAD, OtherError0xAE, OtherError0xAF, OtherError0xB0,\\r\\n        OtherError0xB1, OtherError0xB2, OtherError0xB3, OtherError0xB4, OtherError0xB5, OtherError0xB6, OtherError0xB7,\\r\\n        OtherError0xB8, OtherError0xB9, OtherError0xBA, OtherError0xBB, OtherError0xBC, OtherError0xBD, OtherError0xBE,\\r\\n        OtherError0xBF, OtherError0xC0, OtherError0xC1, OtherError0xC2, OtherError0xC3, OtherError0xC4, OtherError0xC5,\\r\\n        OtherError0xC6, OtherError0xC7, OtherError0xC8, OtherError0xC9, OtherError0xCA, OtherError0xCB, OtherError0xCC,\\r\\n        OtherError0xCD, OtherError0xCE, OtherError0xCF, OtherError0xD0, OtherError0xD1, OtherError0xD2, OtherError0xD3,\\r\\n        OtherError0xD4, OtherError0xD5, OtherError0xD6, OtherError0xD7, OtherError0xD8, OtherError0xD9, OtherError0xDA,\\r\\n        OtherError0xDB, OtherError0xDC, OtherError0xDD, OtherError0xDE, OtherError0xDF,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Inter-client generic error codes ==================================================================================\\r\\n        /// Data requests that cannot be relayed into the Witnet blockchain should be reported\\r\\n        /// with one of these errors. \\r\\n        /// 0xE0: Requests that cannot be parsed must always get this error as their result.\\r\\n        BridgeMalformedDataRequest,\\r\\n        /// 0xE1: Witnesses exceeds 100\\r\\n        BridgePoorIncentives,\\r\\n        /// 0xE2: The request is rejected on the grounds that it may cause the submitter to spend or stake an\\r\\n        /// amount of value that is unjustifiably high when compared with the reward they will be getting\\r\\n        BridgeOversizedTallyResult,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// Unallocated =======================================================================================================\\r\\n        OtherError0xE3, OtherError0xE4, OtherError0xE5, OtherError0xE6, OtherError0xE7, OtherError0xE8, OtherError0xE9,\\r\\n        OtherError0xEA, OtherError0xEB, OtherError0xEC, OtherError0xED, OtherError0xEE, OtherError0xEF, OtherError0xF0,\\r\\n        OtherError0xF1, OtherError0xF2, OtherError0xF3, OtherError0xF4, OtherError0xF5, OtherError0xF6, OtherError0xF7,\\r\\n        OtherError0xF8, OtherError0xF9, OtherError0xFA, OtherError0xFB, OtherError0xFC, OtherError0xFD, OtherError0xFE,\\r\\n        \\r\\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n        /// 0xFF: Some tally error is not intercepted but it should (0+ args)\\r\\n        UnhandledIntercept\\r\\n    }\\r\\n\\r\\n    function isCircumstantial(ResultErrorCodes self) internal pure returns (bool) {\\r\\n        return (self == ResultErrorCodes.CircumstantialFailure);\\r\\n    }\\r\\n\\r\\n    function lackOfConsensus(ResultErrorCodes self) internal pure returns (bool) {\\r\\n        return (\\r\\n            self == ResultErrorCodes.InsufficientCommits\\r\\n                || self == ResultErrorCodes.InsufficientMajority\\r\\n                || self == ResultErrorCodes.InsufficientReveals\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isRetriable(ResultErrorCodes self) internal pure returns (bool) {\\r\\n        return (\\r\\n            lackOfConsensus(self)\\r\\n                || isCircumstantial(self)\\r\\n                || poorIncentives(self)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function poorIncentives(ResultErrorCodes self) internal pure returns (bool) {\\r\\n        return (\\r\\n            self == ResultErrorCodes.OversizedTallyResult\\r\\n                || self == ResultErrorCodes.InsufficientCommits\\r\\n                || self == ResultErrorCodes.BridgePoorIncentives\\r\\n                || self == ResultErrorCodes.BridgeOversizedTallyResult\\r\\n        );\\r\\n    }\\r\\n    \\r\\n\\r\\n    /// Possible Radon data request methods that can be used within a Radon Retrieval. \\r\\n    enum RadonDataRequestMethods {\\r\\n        /* 0 */ Unknown,\\r\\n        /* 1 */ HttpGet,\\r\\n        /* 2 */ RNG,\\r\\n        /* 3 */ HttpPost,\\r\\n        /* 4 */ HttpHead\\r\\n    }\\r\\n\\r\\n    /// Possible types either processed by Witnet Radon Scripts or included within results to Witnet Data Requests.\\r\\n    enum RadonDataTypes {\\r\\n        /* 0x00 */ Any, \\r\\n        /* 0x01 */ Array,\\r\\n        /* 0x02 */ Bool,\\r\\n        /* 0x03 */ Bytes,\\r\\n        /* 0x04 */ Integer,\\r\\n        /* 0x05 */ Float,\\r\\n        /* 0x06 */ Map,\\r\\n        /* 0x07 */ String,\\r\\n        Unused0x08, Unused0x09, Unused0x0A, Unused0x0B,\\r\\n        Unused0x0C, Unused0x0D, Unused0x0E, Unused0x0F,\\r\\n        /* 0x10 */ Same,\\r\\n        /* 0x11 */ Inner,\\r\\n        /* 0x12 */ Match,\\r\\n        /* 0x13 */ Subscript\\r\\n    }\\r\\n\\r\\n    /// Structure defining some data filtering that can be applied at the Aggregation or the Tally stages\\r\\n    /// within a Witnet Data Request resolution workflow.\\r\\n    struct RadonFilter {\\r\\n        RadonFilterOpcodes opcode;\\r\\n        bytes args;\\r\\n    }\\r\\n\\r\\n    /// Filtering methods currently supported on the Witnet blockchain. \\r\\n    enum RadonFilterOpcodes {\\r\\n        /* 0x00 */ Reserved0x00, //GreaterThan,\\r\\n        /* 0x01 */ Reserved0x01, //LessThan,\\r\\n        /* 0x02 */ Reserved0x02, //Equals,\\r\\n        /* 0x03 */ Reserved0x03, //AbsoluteDeviation,\\r\\n        /* 0x04 */ Reserved0x04, //RelativeDeviation\\r\\n        /* 0x05 */ StandardDeviation,\\r\\n        /* 0x06 */ Reserved0x06, //Top,\\r\\n        /* 0x07 */ Reserved0x07, //Bottom,\\r\\n        /* 0x08 */ Mode,\\r\\n        /* 0x09 */ Reserved0x09  //LessOrEqualThan\\r\\n    }\\r\\n\\r\\n    /// Structure defining the array of filters and reducting function to be applied at either the Aggregation\\r\\n    /// or the Tally stages within a Witnet Data Request resolution workflow.\\r\\n    struct RadonReducer {\\r\\n        RadonReducerOpcodes opcode;\\r\\n        RadonFilter[] filters;\\r\\n    }\\r\\n\\r\\n    /// Reducting functions currently supported on the Witnet blockchain.\\r\\n    enum RadonReducerOpcodes {\\r\\n        /* 0x00 */ Reserved0x00, //Minimum,\\r\\n        /* 0x01 */ Reserved0x01, //Maximum,\\r\\n        /* 0x02 */ Mode,\\r\\n        /* 0x03 */ AverageMean,\\r\\n        /* 0x04 */ Reserved0x04, //AverageMeanWeighted,\\r\\n        /* 0x05 */ AverageMedian,\\r\\n        /* 0x06 */ Reserved0x06, //AverageMedianWeighted,\\r\\n        /* 0x07 */ StandardDeviation,\\r\\n        /* 0x08 */ Reserved0x08, //AverageDeviation,\\r\\n        /* 0x09 */ Reserved0x09, //MedianDeviation,\\r\\n        /* 0x0A */ Reserved0x10, //MaximumDeviation,\\r\\n        /* 0x0B */ ConcatenateAndHash\\r\\n    }\\r\\n\\r\\n    /// Structure containing all the parameters that fully describe a Witnet Radon Retrieval within a Witnet Data Request.\\r\\n    struct RadonRetrieval {\\r\\n        uint8 argsCount;\\r\\n        RadonDataRequestMethods method;\\r\\n        RadonDataTypes resultDataType;\\r\\n        string url;\\r\\n        string body;\\r\\n        string[2][] headers;\\r\\n        bytes script;\\r\\n    }\\r\\n\\r\\n    /// Structure containing the Retrieve-Attestation-Delivery parts of a Witnet Data Request.\\r\\n    struct RadonRAD {\\r\\n        RadonRetrieval[] retrieve;\\r\\n        RadonReducer aggregate;\\r\\n        RadonReducer tally;\\r\\n    }\\r\\n\\r\\n    /// Structure containing the Service Level Aggreement parameters of a Witnet Data Request.\\r\\n    struct RadonSLA {\\r\\n        uint8 numWitnesses;\\r\\n        uint8 minConsensusPercentage;\\r\\n        uint64 witnessReward;\\r\\n        uint64 witnessCollateral;\\r\\n        uint64 minerCommitRevealFee;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'uint*' helper methods ------------------------------------------------------------------------------------\\r\\n\\r\\n    /// @notice Convert a `uint8` into a 2 characters long `string` representing its two less significant hexadecimal values.\\r\\n    function toHexString(uint8 _u)\\r\\n        internal pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory b2 = new bytes(2);\\r\\n        uint8 d0 = uint8(_u / 16) + 48;\\r\\n        uint8 d1 = uint8(_u % 16) + 48;\\r\\n        if (d0 > 57)\\r\\n            d0 += 7;\\r\\n        if (d1 > 57)\\r\\n            d1 += 7;\\r\\n        b2[0] = bytes1(d0);\\r\\n        b2[1] = bytes1(d1);\\r\\n        return string(b2);\\r\\n    }\\r\\n\\r\\n    /// @notice Convert a `uint8` into a 1, 2 or 3 characters long `string` representing its.\\r\\n    /// three less significant decimal values.\\r\\n    function toString(uint8 _u)\\r\\n        internal pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        if (_u < 10) {\\r\\n            bytes memory b1 = new bytes(1);\\r\\n            b1[0] = bytes1(uint8(_u) + 48);\\r\\n            return string(b1);\\r\\n        } else if (_u < 100) {\\r\\n            bytes memory b2 = new bytes(2);\\r\\n            b2[0] = bytes1(uint8(_u / 10) + 48);\\r\\n            b2[1] = bytes1(uint8(_u % 10) + 48);\\r\\n            return string(b2);\\r\\n        } else {\\r\\n            bytes memory b3 = new bytes(3);\\r\\n            b3[0] = bytes1(uint8(_u / 100) + 48);\\r\\n            b3[1] = bytes1(uint8(_u % 100 / 10) + 48);\\r\\n            b3[2] = bytes1(uint8(_u % 10) + 48);\\r\\n            return string(b3);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Convert a `uint` into a string` representing its value.\\r\\n    function toString(uint v)\\r\\n        internal pure \\r\\n        returns (string memory)\\r\\n    {\\r\\n        uint maxlength = 100;\\r\\n        bytes memory reversed = new bytes(maxlength);\\r\\n        uint i = 0;\\r\\n        do {\\r\\n            uint8 remainder = uint8(v % 10);\\r\\n            v = v / 10;\\r\\n            reversed[i ++] = bytes1(48 + remainder);\\r\\n        } while (v != 0);\\r\\n        bytes memory buf = new bytes(i);\\r\\n        for (uint j = 1; j <= i; j ++) {\\r\\n            buf[j - 1] = reversed[i - j];\\r\\n        }\\r\\n        return string(buf);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'bytes' helper methods ------------------------------------------------------------------------------------\\r\\n\\r\\n    /// @dev Transform given bytes into a Witnet.Result instance.\\r\\n    /// @param cborBytes Raw bytes representing a CBOR-encoded value.\\r\\n    /// @return A `Witnet.Result` instance.\\r\\n    function toWitnetResult(bytes memory cborBytes)\\r\\n        internal pure\\r\\n        returns (Witnet.Result memory)\\r\\n    {\\r\\n        WitnetCBOR.CBOR memory cborValue = WitnetCBOR.fromBytes(cborBytes);\\r\\n        return _resultFromCborValue(cborValue);\\r\\n    }\\r\\n\\r\\n    function toAddress(bytes memory _value) internal pure returns (address) {\\r\\n        return address(toBytes20(_value));\\r\\n    }\\r\\n\\r\\n    function toBytes4(bytes memory _value) internal pure returns (bytes4) {\\r\\n        return bytes4(toFixedBytes(_value, 4));\\r\\n    }\\r\\n    \\r\\n    function toBytes20(bytes memory _value) internal pure returns (bytes20) {\\r\\n        return bytes20(toFixedBytes(_value, 20));\\r\\n    }\\r\\n    \\r\\n    function toBytes32(bytes memory _value) internal pure returns (bytes32) {\\r\\n        return toFixedBytes(_value, 32);\\r\\n    }\\r\\n\\r\\n    function toFixedBytes(bytes memory _value, uint8 _numBytes)\\r\\n        internal pure\\r\\n        returns (bytes32 _bytes32)\\r\\n    {\\r\\n        assert(_numBytes <= 32);\\r\\n        unchecked {\\r\\n            uint _len = _value.length > _numBytes ? _numBytes : _value.length;\\r\\n            for (uint _i = 0; _i < _len; _i ++) {\\r\\n                _bytes32 |= bytes32(_value[_i] & 0xff) >> (_i * 8);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'string' helper methods -----------------------------------------------------------------------------------\\r\\n\\r\\n    function toLowerCase(string memory str)\\r\\n        internal pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory lowered = new bytes(bytes(str).length);\\r\\n        unchecked {\\r\\n            for (uint i = 0; i < lowered.length; i ++) {\\r\\n                uint8 char = uint8(bytes(str)[i]);\\r\\n                if (char >= 65 && char <= 90) {\\r\\n                    lowered[i] = bytes1(char + 32);\\r\\n                } else {\\r\\n                    lowered[i] = bytes1(char);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return string(lowered);\\r\\n    }\\r\\n\\r\\n    /// @notice Converts bytes32 into string.\\r\\n    function toString(bytes32 _bytes32)\\r\\n        internal pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory _bytes = new bytes(_toStringLength(_bytes32));\\r\\n        for (uint _i = 0; _i < _bytes.length;) {\\r\\n            _bytes[_i] = _bytes32[_i];\\r\\n            unchecked {\\r\\n                _i ++;\\r\\n            }\\r\\n        }\\r\\n        return string(_bytes);\\r\\n    }\\r\\n\\r\\n    function tryUint(string memory str)\\r\\n        internal pure\\r\\n        returns (uint res, bool)\\r\\n    {\\r\\n        unchecked {\\r\\n            for (uint256 i = 0; i < bytes(str).length; i++) {\\r\\n                if (\\r\\n                    (uint8(bytes(str)[i]) - 48) < 0\\r\\n                        || (uint8(bytes(str)[i]) - 48) > 9\\r\\n                ) {\\r\\n                    return (0, false);\\r\\n                }\\r\\n                res += (uint8(bytes(str)[i]) - 48) * 10 ** (bytes(str).length - i - 1);\\r\\n            }\\r\\n            return (res, true);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- 'Witnet.Result' helper methods ----------------------------------------------------------------------------\\r\\n\\r\\n    modifier _isReady(Result memory result) {\\r\\n        require(result.success, \\\"Witnet: tried to decode value from errored result.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an address from the Witnet.Result's CBOR value.\\r\\n    function asAddress(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (address)\\r\\n    {\\r\\n        if (result.value.majorType == uint8(WitnetCBOR.MAJOR_TYPE_BYTES)) {\\r\\n            return toAddress(result.value.readBytes());\\r\\n        } else {\\r\\n            // TODO\\r\\n            revert(\\\"WitnetLib: reading address from string not yet supported.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `bool` value from the Witnet.Result's CBOR value.\\r\\n    function asBool(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (bool)\\r\\n    {\\r\\n        return result.value.readBool();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `bytes` value from the Witnet.Result's CBOR value.\\r\\n    function asBytes(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns(bytes memory)\\r\\n    {\\r\\n        return result.value.readBytes();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `bytes4` value from the Witnet.Result's CBOR value.\\r\\n    function asBytes4(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (bytes4)\\r\\n    {\\r\\n        return toBytes4(asBytes(result));\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `bytes32` value from the Witnet.Result's CBOR value.\\r\\n    function asBytes32(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return toBytes32(asBytes(result));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the Witnet.Result's unread CBOR value.\\r\\n    function asCborValue(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (WitnetCBOR.CBOR memory)\\r\\n    {\\r\\n        return result.value;\\r\\n    }\\r\\n\\r\\n    /// @notice Decode array of CBOR values from the Witnet.Result's CBOR value. \\r\\n    function asCborArray(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (WitnetCBOR.CBOR[] memory)\\r\\n    {\\r\\n        return result.value.readArray();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a fixed16 (half-precision) numeric value from the Witnet.Result's CBOR value.\\r\\n    /// @dev Due to the lack of support for floating or fixed point arithmetic in the EVM, this method offsets all values.\\r\\n    /// by 5 decimal orders so as to get a fixed precision of 5 decimal positions, which should be OK for most `fixed16`.\\r\\n    /// use cases. In other words, the output of this method is 10,000 times the actual value, encoded into an `int32`.\\r\\n    function asFixed16(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (int32)\\r\\n    {\\r\\n        return result.value.readFloat16();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an array of fixed16 values from the Witnet.Result's CBOR value.\\r\\n    function asFixed16Array(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (int32[] memory)\\r\\n    {\\r\\n        return result.value.readFloat16Array();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an `int64` value from the Witnet.Result's CBOR value.\\r\\n    function asInt(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (int)\\r\\n    {\\r\\n        return result.value.readInt();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an array of integer numeric values from a Witnet.Result as an `int[]` array.\\r\\n    /// @param result An instance of Witnet.Result.\\r\\n    /// @return The `int[]` decoded from the Witnet.Result.\\r\\n    function asIntArray(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (int[] memory)\\r\\n    {\\r\\n        return result.value.readIntArray();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `string` value from the Witnet.Result's CBOR value.\\r\\n    /// @param result An instance of Witnet.Result.\\r\\n    /// @return The `string` decoded from the Witnet.Result.\\r\\n    function asText(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns(string memory)\\r\\n    {\\r\\n        return result.value.readString();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an array of strings from the Witnet.Result's CBOR value.\\r\\n    /// @param result An instance of Witnet.Result.\\r\\n    /// @return The `string[]` decoded from the Witnet.Result.\\r\\n    function asTextArray(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (string[] memory)\\r\\n    {\\r\\n        return result.value.readStringArray();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode a `uint64` value from the Witnet.Result's CBOR value.\\r\\n    /// @param result An instance of Witnet.Result.\\r\\n    /// @return The `uint` decoded from the Witnet.Result.\\r\\n    function asUint(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        _isReady(result)\\r\\n        returns (uint)\\r\\n    {\\r\\n        return result.value.readUint();\\r\\n    }\\r\\n\\r\\n    /// @dev Decode an array of `uint64` values from the Witnet.Result's CBOR value.\\r\\n    /// @param result An instance of Witnet.Result.\\r\\n    /// @return The `uint[]` decoded from the Witnet.Result.\\r\\n    function asUintArray(Witnet.Result memory result)\\r\\n        internal pure\\r\\n        returns (uint[] memory)\\r\\n    {\\r\\n        return result.value.readUintArray();\\r\\n    }\\r\\n\\r\\n\\r\\n    /// ===============================================================================================================\\r\\n    /// --- Witnet library private methods ----------------------------------------------------------------------------\\r\\n\\r\\n    /// @dev Decode a CBOR value into a Witnet.Result instance.\\r\\n    function _resultFromCborValue(WitnetCBOR.CBOR memory cbor)\\r\\n        private pure\\r\\n        returns (Witnet.Result memory)    \\r\\n    {\\r\\n        // Witnet uses CBOR tag 39 to represent RADON error code identifiers.\\r\\n        // [CBOR tag 39] Identifiers for CBOR: https://github.com/lucas-clemente/cbor-specs/blob/master/id.md\\r\\n        bool success = cbor.tag != 39;\\r\\n        return Witnet.Result(success, cbor);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculate length of string-equivalent to given bytes32.\\r\\n    function _toStringLength(bytes32 _bytes32)\\r\\n        private pure\\r\\n        returns (uint _length)\\r\\n    {\\r\\n        for (; _length < 32; ) {\\r\\n            if (_bytes32[_length] == 0) {\\r\\n                break;\\r\\n            }\\r\\n            unchecked {\\r\\n                _length ++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetRequestFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\ninterface IWitnetRequestFactory {\\r\\n    \\r\\n    event WitnetRequestTemplateBuilt(address template, bool parameterized);\\r\\n    \\r\\n    function buildRequestTemplate(\\r\\n            bytes32[] memory sourcesIds,\\r\\n            bytes32 aggregatorId,\\r\\n            bytes32 tallyId,\\r\\n            uint16  resultDataMaxSize\\r\\n        ) external returns (address template);\\r\\n\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetRequestBytecodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/WitnetV2.sol\\\";\\r\\n\\r\\ninterface IWitnetRequestBytecodes {\\r\\n\\r\\n    error UnknownRadonRetrieval(bytes32 hash);\\r\\n    error UnknownRadonReducer(bytes32 hash);\\r\\n    error UnknownRadonRequest(bytes32 hash);\\r\\n\\r\\n    event NewDataProvider(uint256 index);\\r\\n    event NewRadonRetrievalHash(bytes32 hash);\\r\\n    event NewRadonReducerHash(bytes32 hash);\\r\\n    event NewRadHash(bytes32 hash);\\r\\n\\r\\n    function bytecodeOf(bytes32 radHash) external view returns (bytes memory);\\r\\n    function bytecodeOf(bytes32 radHash, WitnetV2.RadonSLA calldata sla) external view returns (bytes memory);\\r\\n    function bytecodeOf(bytes calldata radBytecode, WitnetV2.RadonSLA calldata sla) external view returns (bytes memory);\\r\\n    \\r\\n    function hashOf(bytes calldata) external view returns (bytes32);\\r\\n\\r\\n    function lookupDataProvider(uint256 index) external view returns (string memory, uint);\\r\\n    function lookupDataProviderIndex(string calldata authority) external view returns (uint);\\r\\n    function lookupDataProviderSources(uint256 index, uint256 offset, uint256 length) external view returns (bytes32[] memory);\\r\\n\\r\\n    function lookupRadonReducer(bytes32 hash) external view returns (Witnet.RadonReducer memory);\\r\\n    \\r\\n    function lookupRadonRetrieval(bytes32 hash) external view returns (Witnet.RadonRetrieval memory);\\r\\n    function lookupRadonRetrievalArgsCount(bytes32 hash) external view returns (uint8);\\r\\n    function lookupRadonRetrievalResultDataType(bytes32 hash) external view returns (Witnet.RadonDataTypes);\\r\\n    \\r\\n    function lookupRadonRequestAggregator(bytes32 radHash) external view returns (Witnet.RadonReducer memory);\\r\\n    function lookupRadonRequestResultMaxSize(bytes32 radHash) external view returns (uint16);\\r\\n    function lookupRadonRequestResultDataType(bytes32 radHash) external view returns (Witnet.RadonDataTypes);\\r\\n    function lookupRadonRequestSources(bytes32 radHash) external view returns (bytes32[] memory);\\r\\n    function lookupRadonRequestSourcesCount(bytes32 radHash) external view returns (uint);\\r\\n    function lookupRadonRequestTally(bytes32 radHash) external view returns (Witnet.RadonReducer memory);\\r\\n        \\r\\n    function verifyRadonRetrieval(\\r\\n            Witnet.RadonDataRequestMethods requestMethod,\\r\\n            string calldata requestURL,\\r\\n            string calldata requestBody,\\r\\n            string[2][] calldata requestHeaders,\\r\\n            bytes calldata requestRadonScript\\r\\n        ) external returns (bytes32 hash);\\r\\n    \\r\\n    function verifyRadonReducer(Witnet.RadonReducer calldata reducer)\\r\\n        external returns (bytes32 hash);\\r\\n    \\r\\n    function verifyRadonRequest(\\r\\n            bytes32[] calldata sources,\\r\\n            bytes32 aggregator,\\r\\n            bytes32 tally,\\r\\n            uint16 resultMaxSize,\\r\\n            string[][] calldata args\\r\\n        ) external returns (bytes32 radHash);\\r\\n\\r\\n    function totalDataProviders() external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetRandomnessEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../libs/WitnetV2.sol\\\";\\r\\n\\r\\n/// @title The Witnet Randomness generator interface.\\r\\n/// @author Witnet Foundation.\\r\\ninterface IWitnetRandomnessEvents {\\r\\n    event Randomizing(\\r\\n            uint256 blockNumber, \\r\\n            uint256 evmTxGasPrice,\\r\\n            uint256 evmRandomizeFee,\\r\\n            uint256 witnetQueryId, \\r\\n            WitnetV2.RadonSLA witnetQuerySLA\\r\\n        );\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetRandomnessAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/WitnetV2.sol\\\";\\r\\n\\r\\ninterface IWitnetRandomnessAdmin {\\r\\n    function acceptOwnership() external;\\r\\n    function baseFeeOverheadPercentage() external view returns (uint16);\\r\\n    function owner() external view returns (address);\\r\\n    function pendingOwner() external returns (address);\\r\\n    function transferOwnership(address) external;\\r\\n    function settleBaseFeeOverheadPercentage(uint16) external;\\r\\n    function settleWitnetQuerySLA(WitnetV2.RadonSLA calldata) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetRandomness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../WitnetOracle.sol\\\";\\r\\n\\r\\n/// @title The Witnet Randomness generator interface.\\r\\n/// @author Witnet Foundation.\\r\\ninterface IWitnetRandomness {\\r\\n    \\r\\n    /// @notice Returns amount of wei required to be paid as a fee when requesting randomization with a \\r\\n    /// transaction gas price as the one given.\\r\\n    function estimateRandomizeFee(uint256 evmGasPrice) external view returns (uint256);\\r\\n\\r\\n    /// @notice Retrieves the result of keccak256-hashing the given block number with the randomness value \\r\\n    /// @notice generated by the Witnet Oracle blockchain in response to the first non-errored randomize request solved \\r\\n    /// @notice after such block number.\\r\\n    /// @dev Reverts if:\\r\\n    /// @dev   i.   no `randomize()` was requested on neither the given block, nor afterwards.\\r\\n    /// @dev   ii.  the first non-errored `randomize()` request found on or after the given block is not solved yet.\\r\\n    /// @dev   iii. all `randomize()` requests that took place on or after the given block were solved with errors.\\r\\n    /// @param blockNumber Block number from which the search will start.\\r\\n    function fetchRandomnessAfter(uint256 blockNumber) external view returns (bytes32);\\r\\n\\r\\n    /// @notice Retrieves the actual random value, unique hash and timestamp of the witnessing commit/reveal act that took\\r\\n    /// @notice place in the Witnet Oracle blockchain in response to the first non-errored randomize request\\r\\n    /// @notice solved after the given block number.\\r\\n    /// @dev Reverts if:\\r\\n    /// @dev   i.   no `randomize()` was requested on neither the given block, nor afterwards.\\r\\n    /// @dev   ii.  the first non-errored `randomize()` request found on or after the given block is not solved yet.\\r\\n    /// @dev   iii. all `randomize()` requests that took place on or after the given block were solved with errors.\\r\\n    /// @param blockNumber Block number from which the search will start.\\r\\n    /// @return witnetResultRandomness Random value provided by the Witnet blockchain and used for solving randomness after given block.\\r\\n    /// @return witnetResultTimestamp Timestamp at which the randomness value was generated by the Witnet blockchain.\\r\\n    /// @return witnetResultTallyHash Hash of the witnessing commit/reveal act that took place on the Witnet blockchain.\\r\\n    /// @return witnetResultFinalityBlock EVM block number from which the provided randomness can be considered to be final.\\r\\n    function fetchRandomnessAfterProof(uint256 blockNumber) external view returns (\\r\\n            bytes32 witnetResultRandomness,\\r\\n            uint64  witnetResultTimestamp, \\r\\n            bytes32 witnetResultTallyHash,\\r\\n            uint256 witnetResultFinalityBlock\\r\\n        ); \\r\\n\\r\\n    /// @notice Returns last block number on which a randomize was requested.\\r\\n    function getLastRandomizeBlock() external view returns (uint256);\\r\\n\\r\\n    /// @notice Retrieves metadata related to the randomize request that got posted to the \\r\\n    /// @notice Witnet Oracle contract on the given block number.\\r\\n    /// @dev Returns zero values if no randomize request was actually posted on the given block.\\r\\n    /// @return witnetQueryId Identifier of the underlying Witnet query created on the given block number. \\r\\n    /// @return prevRandomizeBlock Block number in which a randomize request got posted just before this one. 0 if none.\\r\\n    /// @return nextRandomizeBlock Block number in which a randomize request got posted just after this one, 0 if none.\\r\\n    function getRandomizeData(uint256 blockNumber) external view returns (\\r\\n            uint256 witnetQueryId,\\r\\n            uint256 prevRandomizeBlock, \\r\\n            uint256 nextRandomizeBlock\\r\\n        );\\r\\n    \\r\\n    /// @notice Returns the number of the next block in which a randomize request was posted after the given one. \\r\\n    /// @param blockNumber Block number from which the search will start.\\r\\n    /// @return Number of the first block found after the given one, or `0` otherwise.\\r\\n    function getRandomizeNextBlock(uint256 blockNumber) external view returns (uint256); \\r\\n\\r\\n    /// @notice Returns the number of the previous block in which a randomize request was posted before the given one.\\r\\n    /// @param blockNumber Block number from which the search will start.\\r\\n    /// @return First block found before the given one, or `0` otherwise.\\r\\n    function getRandomizePrevBlock(uint256 blockNumber) external view returns (uint256);\\r\\n\\r\\n    /// @notice Gets current status of the first non-errored randomize request posted on or after the given block number.\\r\\n    /// @dev Possible values:\\r\\n    /// @dev - 0 -> Void: no randomize request was actually posted on or after the given block number.\\r\\n    /// @dev - 1 -> Awaiting: a randomize request was found but it's not yet solved by the Witnet blockchain.\\r\\n    /// @dev - 2 -> Ready: a successfull randomize value was reported and ready to be read.\\r\\n    /// @dev - 3 -> Error: all randomize resolutions after the given block were solved with errors.\\r\\n    /// @dev - 4 -> Finalizing: a randomize resolution has been reported from the Witnet blockchain, but it's not yet final.  \\r\\n    function getRandomizeStatus(uint256 blockNumber) external view returns (WitnetV2.ResponseStatus);\\r\\n\\r\\n    /// @notice Returns `true` only if a successfull resolution from the Witnet blockchain is found for the first \\r\\n    /// @notice non-errored randomize request posted on or after the given block number.\\r\\n    function isRandomized(uint256 blockNumber) external view returns (bool);\\r\\n\\r\\n    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _range), by using \\r\\n    /// @notice the given `nonce` and the randomness returned by `getRandomnessAfter(blockNumber)`. \\r\\n    /// @dev Fails under same conditions as `getRandomnessAfter(uint256)` does.\\r\\n    /// @param range Range within which the uniformly-distributed random number will be generated.\\r\\n    /// @param nonce Nonce value enabling multiple random numbers from the same randomness value.\\r\\n    /// @param blockNumber Block number from which the search for the first randomize request solved aftewards will start.\\r\\n    function random(uint32 range, uint256 nonce, uint256 blockNumber) external view returns (uint32);\\r\\n\\r\\n    /// @notice Requests the Witnet oracle to generate an EVM-agnostic and trustless source of randomness. \\r\\n    /// @dev Only one randomness request per block will be actually posted to the Witnet Oracle. \\r\\n    /// @dev Unused funds will be transfered back to the `msg.sender`. \\r\\n    /// @return Funds actually paid as randomize fee. \\r\\n    function randomize() external payable returns (uint256);\\r\\n\\r\\n    /// @notice Returns address of the Witnet Oracle bridging contract being used for solving randomness requests.\\r\\n    function witnet() external view returns (WitnetOracle);\\r\\n\\r\\n    /// @notice Returns the SLA parameters required for the Witnet Oracle blockchain to fulfill \\r\\n    /// @notice when solving randomness requests:\\r\\n    /// @notice - number of witnessing nodes contributing to randomness generation\\r\\n    /// @notice - reward in $nanoWIT received per witnessing node in the Witnet blockchain\\r\\n    function witnetQuerySLA() external view returns (WitnetV2.RadonSLA memory);\\r\\n\\r\\n    /// @notice Returns the unique identifier of the Witnet-compliant data request being used for solving randomness.\\r\\n    function witnetRadHash() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetOracleEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/WitnetV2.sol\\\";\\r\\n\\r\\ninterface IWitnetOracleEvents {\\r\\n    \\r\\n    /// Emitted every time a new query containing some verified data request is posted to the WRB.\\r\\n    event WitnetQuery(\\r\\n        uint256 id, \\r\\n        uint256 evmReward,\\r\\n        WitnetV2.RadonSLA witnetSLA\\r\\n    );\\r\\n\\r\\n    /// Emitted when a query with no callback gets reported into the WRB.\\r\\n    event WitnetQueryResponse(\\r\\n        uint256 id, \\r\\n        uint256 evmGasPrice\\r\\n    );\\r\\n\\r\\n    /// Emitted when a query with a callback gets successfully reported into the WRB.\\r\\n    event WitnetQueryResponseDelivered(\\r\\n        uint256 id, \\r\\n        uint256 evmGasPrice, \\r\\n        uint256 evmCallbackGas\\r\\n    );\\r\\n\\r\\n    /// Emitted when a query with a callback cannot get reported into the WRB.\\r\\n    event WitnetQueryResponseDeliveryFailed(\\r\\n        uint256 id, \\r\\n        bytes   resultCborBytes,\\r\\n        uint256 evmGasPrice, \\r\\n        uint256 evmCallbackActualGas, \\r\\n        string  evmCallbackRevertReason\\r\\n    );\\r\\n\\r\\n    /// Emitted when the reward of some not-yet reported query is upgraded.\\r\\n    event WitnetQueryRewardUpgraded(\\r\\n        uint256 id, \\r\\n        uint256 evmReward\\r\\n    );\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IWitnetOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/WitnetV2.sol\\\";\\r\\n\\r\\ninterface IWitnetOracle {\\r\\n\\r\\n    /// @notice Estimate the minimum reward required for posting a data request.\\r\\n    /// @dev Underestimates if the size of returned data is greater than `resultMaxSize`. \\r\\n    /// @param gasPrice Expected gas price to pay upon posting the data request.\\r\\n    /// @param resultMaxSize Maximum expected size of returned data (in bytes).  \\r\\n    function estimateBaseFee(uint256 gasPrice, uint16 resultMaxSize) external view returns (uint256);\\r\\n\\r\\n    /// @notice Estimate the minimum reward required for posting a data request.\\r\\n    /// @dev Fails if the RAD hash was not previously verified on the WitnetRequestBytecodes registry.\\r\\n    /// @param gasPrice Expected gas price to pay upon posting the data request.\\r\\n    /// @param radHash The RAD hash of the data request to be solved by Witnet.\\r\\n    function estimateBaseFee(uint256 gasPrice, bytes32 radHash) external view returns (uint256);\\r\\n    \\r\\n    /// @notice Estimate the minimum reward required for posting a data request with a callback.\\r\\n    /// @param gasPrice Expected gas price to pay upon posting the data request.\\r\\n    /// @param callbackGasLimit Maximum gas to be spent when reporting the data request result.\\r\\n    function estimateBaseFeeWithCallback(uint256 gasPrice, uint24 callbackGasLimit) external view returns (uint256);\\r\\n       \\r\\n    /// @notice Retrieves a copy of all Witnet-provable data related to a previously posted request, \\r\\n    /// removing the whole query from the WRB storage.\\r\\n    /// @dev Fails if the query was not in 'Reported' status, or called from an address different to\\r\\n    /// @dev the one that actually posted the given request.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function fetchQueryResponse(uint256 queryId) external returns (WitnetV2.Response memory);\\r\\n   \\r\\n    /// @notice Gets the whole Query data contents, if any, no matter its current status.\\r\\n    function getQuery(uint256 queryId) external view returns (WitnetV2.Query memory);\\r\\n\\r\\n    /// @notice Gets the current EVM reward the report can claim, if not done yet.\\r\\n    function getQueryEvmReward(uint256 queryId) external view returns (uint256);\\r\\n\\r\\n    /// @notice Retrieves the RAD hash and SLA parameters of the given query.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function getQueryRequest(uint256 queryId) external view returns (WitnetV2.Request memory);\\r\\n\\r\\n    /// @notice Retrieves the whole `Witnet.Response` record referred to a previously posted Witnet Data Request.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function getQueryResponse(uint256 queryId) external view returns (WitnetV2.Response memory);\\r\\n\\r\\n    /// @notice Returns query's result current status from a requester's point of view:\\r\\n    /// @notice   - 0 => Void: the query is either non-existent or deleted;\\r\\n    /// @notice   - 1 => Awaiting: the query has not yet been reported;\\r\\n    /// @notice   - 2 => Ready: the query response was finalized, and contains a result with no erros.\\r\\n    /// @notice   - 3 => Error: the query response was finalized, and contains a result with errors.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function getQueryResponseStatus(uint256 queryId) external view returns (WitnetV2.ResponseStatus);\\r\\n\\r\\n    /// @notice Retrieves the CBOR-encoded buffer containing the Witnet-provided result to the given query.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function getQueryResultCborBytes(uint256 queryId) external view returns (bytes memory);\\r\\n\\r\\n    /// @notice Gets error code identifying some possible failure on the resolution of the given query.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function getQueryResultError(uint256 queryId) external view returns (Witnet.ResultError memory);\\r\\n\\r\\n    /// @notice Gets current status of given query.\\r\\n    function getQueryStatus(uint256 queryId) external view returns (WitnetV2.QueryStatus);\\r\\n    \\r\\n    /// @notice Get current status of all given query ids.\\r\\n    function getQueryStatusBatch(uint256[] calldata queryIds) external view returns (WitnetV2.QueryStatus[] memory);\\r\\n\\r\\n    /// @notice Returns next query id to be generated by the Witnet Request Board.\\r\\n    function getNextQueryId() external view returns (uint256);\\r\\n\\r\\n    /// @notice Requests the execution of the given Witnet Data Request, in expectation that it will be relayed and \\r\\n    /// @notice solved by the Witnet blockchain. A reward amount is escrowed by the Witnet Request Board that will be \\r\\n    /// @notice transferred to the reporter who relays back the Witnet-provable result to this request.\\r\\n    /// @dev Reasons to fail:\\r\\n    /// @dev - the RAD hash was not previously verified by the WitnetRequestBytecodes registry;\\r\\n    /// @dev - invalid SLA parameters were provided;\\r\\n    /// @dev - insufficient value is paid as reward.\\r\\n    /// @param queryRAD The RAD hash of the data request to be solved by Witnet.\\r\\n    /// @param querySLA The data query SLA to be fulfilled on the Witnet blockchain.\\r\\n    /// @return queryId Unique query identifier.\\r\\n    function postRequest(\\r\\n            bytes32 queryRAD, \\r\\n            WitnetV2.RadonSLA calldata querySLA\\r\\n        ) external payable returns (uint256 queryId);\\r\\n\\r\\n    /// @notice Requests the execution of the given Witnet Data Request, in expectation that it will be relayed and solved by \\r\\n    /// @notice the Witnet blockchain. A reward amount is escrowed by the Witnet Request Board that will be transferred to the \\r\\n    /// @notice reporter who relays back the Witnet-provable result to this request. The Witnet-provable result will be reported\\r\\n    /// @notice directly to the requesting contract. If the report callback fails for any reason, an `WitnetQueryResponseDeliveryFailed`\\r\\n    /// @notice will be triggered, and the Witnet audit trail will be saved in storage, but not so the actual CBOR-encoded result.\\r\\n    /// @dev Reasons to fail:\\r\\n    /// @dev - the caller is not a contract implementing the IWitnetConsumer interface;\\r\\n    /// @dev - the RAD hash was not previously verified by the WitnetRequestBytecodes registry;\\r\\n    /// @dev - invalid SLA parameters were provided;\\r\\n    /// @dev - insufficient value is paid as reward.\\r\\n    /// @param queryRAD The RAD hash of the data request to be solved by Witnet.\\r\\n    /// @param querySLA The data query SLA to be fulfilled on the Witnet blockchain.\\r\\n    /// @param queryCallbackGasLimit Maximum gas to be spent when reporting the data request result.\\r\\n    /// @return queryId Unique query identifier.\\r\\n    function postRequestWithCallback(\\r\\n            bytes32 queryRAD, \\r\\n            WitnetV2.RadonSLA calldata querySLA, \\r\\n            uint24 queryCallbackGasLimit\\r\\n        ) external payable returns (uint256 queryId);\\r\\n\\r\\n    /// @notice Requests the execution of the given Witnet Data Request, in expectation that it will be relayed and solved by \\r\\n    /// @notice the Witnet blockchain. A reward amount is escrowed by the Witnet Request Board that will be transferred to the \\r\\n    /// @notice reporter who relays back the Witnet-provable result to this request. The Witnet-provable result will be reported\\r\\n    /// @notice directly to the requesting contract. If the report callback fails for any reason, a `WitnetQueryResponseDeliveryFailed`\\r\\n    /// @notice event will be triggered, and the Witnet audit trail will be saved in storage, but not so the CBOR-encoded result.\\r\\n    /// @dev Reasons to fail:\\r\\n    /// @dev - the caller is not a contract implementing the IWitnetConsumer interface;\\r\\n    /// @dev - the provided bytecode is empty;\\r\\n    /// @dev - invalid SLA parameters were provided;\\r\\n    /// @dev - insufficient value is paid as reward.\\r\\n    /// @param queryUnverifiedBytecode The (unverified) bytecode containing the actual data request to be solved by the Witnet blockchain.\\r\\n    /// @param querySLA The data query SLA to be fulfilled on the Witnet blockchain.\\r\\n    /// @param queryCallbackGasLimit Maximum gas to be spent when reporting the data request result.\\r\\n    /// @return queryId Unique query identifier.\\r\\n    function postRequestWithCallback(\\r\\n            bytes calldata queryUnverifiedBytecode,\\r\\n            WitnetV2.RadonSLA calldata querySLA, \\r\\n            uint24 queryCallbackGasLimit\\r\\n        ) external payable returns (uint256 queryId);\\r\\n\\r\\n    /// @notice Increments the reward of a previously posted request by adding the transaction value to it.\\r\\n    /// @param queryId The unique query identifier.\\r\\n    function upgradeQueryEvmReward(uint256 queryId) external payable;\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/apps/UsingWitnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../WitnetOracle.sol\\\";\\r\\n\\r\\n/// @title The UsingWitnet contract\\r\\n/// @dev Witnet-aware contracts can inherit from this contract in order to interact with Witnet.\\r\\n/// @author The Witnet Foundation.\\r\\nabstract contract UsingWitnet\\r\\n    is\\r\\n        IWitnetOracleEvents\\r\\n{\\r\\n    /// @dev Immutable reference to the Witnet Request Board contract.\\r\\n    WitnetOracle internal immutable __witnet;\\r\\n    \\r\\n    /// @dev Default Security-Level Agreement parameters to be fulfilled by the Witnet blockchain\\r\\n    /// @dev when solving a data request.\\r\\n    WitnetV2.RadonSLA internal __witnetDefaultSLA;\\r\\n\\r\\n    /// @dev Percentage over base fee to pay on every data request, \\r\\n    /// @dev as to deal with volatility of evmGasPrice and evmWitPrice during the live time of \\r\\n    /// @dev a data request (since being posted until a result gets reported back), at both the EVM and \\r\\n    /// @dev the Witnet blockchain levels, respectivelly. \\r\\n    uint16 internal __witnetBaseFeeOverheadPercentage;\\r\\n\\r\\n    /// @param _wrb Address of the WitnetOracle contract.\\r\\n    constructor(WitnetOracle _wrb) {\\r\\n        require(\\r\\n            _wrb.specs() == type(IWitnetOracle).interfaceId,\\r\\n            \\\"UsingWitnet: uncompliant WitnetOracle\\\"\\r\\n        );\\r\\n        __witnet = _wrb;\\r\\n        __witnetDefaultSLA = WitnetV2.RadonSLA({\\r\\n            // Number of nodes in the Witnet blockchain that will take part in solving the data request:\\r\\n            committeeSize: 10,\\r\\n            // Fee in $nanoWIT paid to every node in the Witnet blockchain involved in solving the data request:\\r\\n            witnessingFeeNanoWit: 2 * 10 ** 8  // defaults to 0.2 $WIT\\r\\n        });\\r\\n        \\r\\n        __witnetBaseFeeOverheadPercentage = 33; // defaults to 33%\\r\\n    }\\r\\n\\r\\n    /// @dev Provides a convenient way for client contracts extending this to block the execution of the main logic of the\\r\\n    /// @dev contract until a particular request has been successfully solved and reported by Witnet,\\r\\n    /// @dev either with an error or successfully.\\r\\n    modifier witnetQuerySolved(uint256 _witnetQueryId) {\\r\\n        require(_witnetCheckQueryResultAvailability(_witnetQueryId), \\\"UsingWitnet: unsolved query\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function witnet() virtual public view returns (WitnetOracle) {\\r\\n        return __witnet;\\r\\n    }\\r\\n\\r\\n    /// @notice Check if given query was already reported back from the Witnet oracle.\\r\\n    /// @param _id The unique identifier of a previously posted data request.\\r\\n    function _witnetCheckQueryResultAvailability(uint256 _id)\\r\\n        internal view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return __witnet.getQueryStatus(_id) == WitnetV2.QueryStatus.Reported;\\r\\n    }\\r\\n\\r\\n    /// @notice Estimate the minimum reward required for posting a data request, using `tx.gasprice` as a reference.\\r\\n    /// @dev Underestimates if the size of returned data is greater than `_resultMaxSize`. \\r\\n    /// @param _resultMaxSize Maximum expected size of returned data (in bytes).\\r\\n    function _witnetEstimateEvmReward(uint16 _resultMaxSize)\\r\\n        virtual internal view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (\\r\\n            (100 + __witnetBaseFeeOverheadPercentage)\\r\\n                * __witnet.estimateBaseFee(tx.gasprice, _resultMaxSize) \\r\\n        ) / 100;\\r\\n    }\\r\\n\\r\\n    function _witnetCheckQueryResponseStatus(uint256 _witnetQueryId)\\r\\n        internal view\\r\\n        returns (WitnetV2.ResponseStatus)\\r\\n    {\\r\\n        return __witnet.getQueryResponseStatus(_witnetQueryId);\\r\\n    }\\r\\n\\r\\n    function _witnetCheckQueryResultError(uint256 _witnetQueryId)\\r\\n        internal view\\r\\n        returns (Witnet.ResultError memory)\\r\\n    {\\r\\n        return __witnet.getQueryResultError(_witnetQueryId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/WitnetRequestFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./WitnetRequestBytecodes.sol\\\";\\r\\nimport \\\"./WitnetOracle.sol\\\";\\r\\nimport \\\"./interfaces/IWitnetRequestFactory.sol\\\";\\r\\n\\r\\nabstract contract WitnetRequestFactory\\r\\n    is\\r\\n        IWitnetRequestFactory\\r\\n{\\r\\n    function class() virtual external view returns (string memory);\\r\\n    function registry() virtual external view returns (WitnetRequestBytecodes);\\r\\n    function specs() virtual external view returns (bytes4);\\r\\n    function witnet() virtual external view returns (WitnetOracle);\\r\\n}\"\r\n    },\r\n    \"/contracts/WitnetRequestBytecodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./interfaces/IWitnetRequestBytecodes.sol\\\";\\r\\n\\r\\nabstract contract WitnetRequestBytecodes\\r\\n    is\\r\\n        IWitnetRequestBytecodes\\r\\n{\\r\\n    function class() virtual external view returns (string memory) {\\r\\n        return type(WitnetRequestBytecodes).name;\\r\\n    }   \\r\\n    function specs() virtual external view returns (bytes4);\\r\\n}\"\r\n    },\r\n    \"/contracts/WitnetRandomness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IWitnetOracleEvents.sol\\\";\\r\\nimport \\\"./interfaces/IWitnetRandomness.sol\\\";\\r\\nimport \\\"./interfaces/IWitnetRandomnessEvents.sol\\\";\\r\\n\\r\\nabstract contract WitnetRandomness\\r\\n    is\\r\\n        IWitnetOracleEvents,\\r\\n        IWitnetRandomness,\\r\\n        IWitnetRandomnessEvents\\r\\n{\\r\\n    function class() virtual external view returns (string memory);\\r\\n    function specs() virtual external view returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/WitnetOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./WitnetRequestBytecodes.sol\\\";\\r\\nimport \\\"./WitnetRequestFactory.sol\\\";\\r\\nimport \\\"./interfaces/IWitnetOracle.sol\\\";\\r\\nimport \\\"./interfaces/IWitnetOracleEvents.sol\\\";\\r\\n\\r\\n/// @title Witnet Request Board functionality base contract.\\r\\n/// @author The Witnet Foundation.\\r\\nabstract contract WitnetOracle\\r\\n    is\\r\\n        IWitnetOracle,\\r\\n        IWitnetOracleEvents\\r\\n{\\r\\n    function class() virtual external view returns (string memory) {\\r\\n        return type(WitnetOracle).name;\\r\\n    }\\r\\n    function channel() virtual external view returns (bytes4);\\r\\n    function factory() virtual external view returns (WitnetRequestFactory);\\r\\n    function registry() virtual external view returns (WitnetRequestBytecodes);\\r\\n    function specs() virtual external view returns (bytes4);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract WitnetOracle\",\"name\":\"_witnet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmptyBuffer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"range\",\"type\":\"uint256\"}],\"name\":\"IndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"InvalidLengthEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"read\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"UnexpectedMajorType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unexpected\",\"type\":\"uint256\"}],\"name\":\"UnsupportedMajorType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmTxGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmRandomizeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"witnetQueryId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"committeeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"witnessingFeeNanoWit\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct WitnetV2.RadonSLA\",\"name\":\"witnetQuerySLA\",\"type\":\"tuple\"}],\"name\":\"Randomizing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmReward\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"committeeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"witnessingFeeNanoWit\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct WitnetV2.RadonSLA\",\"name\":\"witnetSLA\",\"type\":\"tuple\"}],\"name\":\"WitnetQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmGasPrice\",\"type\":\"uint256\"}],\"name\":\"WitnetQueryResponse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmCallbackGas\",\"type\":\"uint256\"}],\"name\":\"WitnetQueryResponseDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resultCborBytes\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmCallbackActualGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"evmCallbackRevertReason\",\"type\":\"string\"}],\"name\":\"WitnetQueryResponseDeliveryFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"evmReward\",\"type\":\"uint256\"}],\"name\":\"WitnetQueryRewardUpgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFeeOverheadPercentage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"class\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_evmGasPrice\",\"type\":\"uint256\"}],\"name\":\"estimateRandomizeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"fetchRandomnessAfter\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"fetchRandomnessAfterProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_witnetResultRandomness\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_witnetResultTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_witnetResultTallyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_witnetResultFinalityBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRandomizeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRandomizeData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_witnetQueryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prevRandomizeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextRandomizeBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRandomizeNextBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRandomizePrevBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRandomizeStatus\",\"outputs\":[{\"internalType\":\"enum WitnetV2.ResponseStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"isRandomized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_range\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_evmRandomizeFee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_baseFeeOverheadPercentage\",\"type\":\"uint16\"}],\"name\":\"settleBaseFeeOverheadPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"committeeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"witnessingFeeNanoWit\",\"type\":\"uint64\"}],\"internalType\":\"struct WitnetV2.RadonSLA\",\"name\":\"_witnetQuerySLA\",\"type\":\"tuple\"}],\"name\":\"settleWitnetQuerySLA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specs\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"witnet\",\"outputs\":[{\"internalType\":\"contract WitnetOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"witnetQuerySLA\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"committeeSize\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"witnessingFeeNanoWit\",\"type\":\"uint64\"}],\"internalType\":\"struct WitnetV2.RadonSLA\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"witnetRadHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WitnetRandomnessV2", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000077703ae126b971c9946d562f41dd47071da00777000000000000000000000000f121b71715e71dded592f1125a06d4ed06f0694d", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}