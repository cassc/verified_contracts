{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\n// File: CRYPTOZEE/CZEEICO.sol\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n//import \"./CZEEToken.sol\";\r\n\r\n/**\r\n * @title CZEEICO Contract\r\n * @dev A smart contract that implements the CZEE initial coin offering (ICO),\r\n * allowing investors to purchase CZEE tokens in exchange for Matic or Tether.\r\n */\r\ncontract CZEEICO is Ownable, ReentrancyGuard {  \r\n\r\n    using SafeMath for uint256;           \r\n    \r\n    // maximum number of tokens that can be purchased in a single transaction.\r\n    uint256 private _maxTokensPerTx = 100_000e18;\r\n\r\n    // minimum number of tokens that can be purchased in a single transaction.\r\n    uint256 private _minTokensPerTx = 10e18;\r\n\r\n    // maximum number of tokens that a buyer can hold.\r\n    uint256 private _maxTokensPerBuyer = 1_000_000e18;\r\n\r\n    IERC20 public _token;\r\n\r\n    //---------------------------------------------------------------\r\n    // Tether (USDT) address \r\n    //---------------------------------------------------------------\r\n    // Polygon  : 0xc2132D05D31c914a87C6611C10748AEb04B58e8F\r\n    //------------------\r\n    // Ethereum : 0xc2132D05D31c914a87C6611C10748AEb04B58e8F \r\n    //---------------------------------------------------------------\r\n   // IERC20 private _usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n  \r\n   IERC20 private _usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    //---------------------------------------------------------------\r\n    // Chainlink price feed\r\n    // ETH/USD \r\n    // https://docs.chain.link/data-feeds/price-feeds/addresses\r\n    //---------------------------------------------------------------\r\n    // Polygon\r\n    //------------------\r\n    // Mainnet : 0xAB594600376Ec9fD91F8e885dADF0CE036862dE0      \r\n    // Testnet : 0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada \r\n    //------------------\r\n    // Ehereum\r\n    //------------------\r\n    // Mainnet : 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\r\n    // Testnet : 0x694AA1769357215DE4FAC081bf1f309aDC325306\r\n    //---------------------------------------------------------------\r\n    AggregatorV3Interface private toUsdPriceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    // Price of token in USD (1 CZEE = 0.0000018 $)\r\n    uint256 private _tokenPriceInUSD = 0.0000018 * 1e18;\r\n    \r\n    // The total amount of funds raised in the ICO.\r\n    uint256 private _fundsRaised;     \r\n\r\n    // The total amount of tokens available for sale in the ICO.\r\n    uint256 private _icoTokenAmount;    \r\n\r\n    // Unix timestamp for the start of the ICO.\r\n    uint256 private _icoOpeningTime;\r\n\r\n    // Unix timestamp for the end of the ICO.\r\n    uint256 private _icoClosingTime; \r\n\r\n    // duration of the ICO in seconds.\r\n    uint256 private _icoDurationInSeconds;     \r\n\r\n    // Maps the address of each buyer to their token balance.    \r\n    mapping(address => uint256) private tokenAmountInWallet;\r\n\r\n\r\n    //---------------------------------------------------------------\r\n    // Private Sale Scheduling\r\n    //---------------------------------------------------------------\r\n    // Release info\r\n    uint256 private releaseStep = 60 days;  // seconds, minutes, hours, days, weeks, years\r\n    \r\n    // Release Schedules Array\r\n    uint256[3] private releaseSchedule;\r\n\r\n    // Beneficiary info\r\n    address[] beneficiaryAdrs;\r\n\r\n    struct Beneficiary {\r\n        uint256 scheduleStartTime;\r\n        uint256 tokenAmountInWallet;\r\n        uint256 withdrawn;          // How many tokens, this Beneficiary has took out of account, until now.\r\n    }\r\n\r\n    // BeneficiaryAddress => Beneficiary Struct\r\n    mapping(address => Beneficiary) beneficiaries;\r\n\r\n    modifier onlyBeneficiaries() {\r\n        require(beneficiaries[msg.sender].scheduleStartTime != 0, \"You are not a beneficiary.\");\r\n        _;\r\n    }\r\n\r\n    event TokensDeposited(address indexed _owner, uint256 amount);\r\n    event TokensPurchased(address indexed beneficiary, uint256 value, uint256 amount);\r\n    event FundsWithdrawn(address indexed _owner, uint256 _amount);\r\n    event usdtWithdrawn(address indexed _owner, uint256 _amount);\r\n    event TokensWithdrawn(address indexed _owner, uint256 _amount);\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        releaseSchedule = [33, 33, 34];\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to restrict certain functions to the time when the ICO is closed.\r\n    * @notice This modifier should be used in conjunction with isOpen() function.\r\n    */\r\n    modifier onlyWhileClosed {\r\n         require(!isOpen(), \"ICO Should be closed\");\r\n        _;\r\n    }    \r\n\r\n    /**\r\n    * @dev Modifier to restrict certain functions to the time when the ICO is open.\r\n    * @notice This modifier should be used in conjunction with isOpen() function.\r\n    */\r\n    modifier onlyWhileOpen {\r\n        require(isOpen(), \"ICO: has been already closed\");\r\n        _;\r\n    } \r\n\r\n    //------------------\r\n    // Admin Functions\r\n    //------------------\r\n    \r\n    /**\r\n    * @dev Deposits tokens into the ICO contract.\r\n    * @notice Only the contract owner can deposit tokens.\r\n    * @param _amount The amount of tokens to be deposited.\r\n    */\r\n    function depositTokens(address token, uint _amount) external onlyOwner returns (bool) {\r\n        _token = IERC20(token);\r\n\r\n        require(_amount > 0, \"ICO: Invalid token amount\");\r\n\r\n        _icoTokenAmount += _amount;      \r\n        _token.transferFrom(owner(), address(this), _amount);\r\n\r\n        emit TokensDeposited(owner(), _amount);\r\n        return true;      \r\n    }\r\n\r\n    /**\r\n    * @dev Opens the ICO for buying tokens.\r\n    * @param _icoDurationInDays The duration of the ICO in days.\r\n    * @notice Only the contract owner can open the ICO.\r\n    */\r\n    function openIco(uint256 _icoDurationInDays) external onlyOwner {\r\n        require(_icoDurationInDays > 0, \"ICO: Invalid ico Duration\");\r\n        require(!isOpen(), \"ICO: has been already opened\");\r\n        require(_icoTokenAmount > 0, \"ICO: No tokens to buy\");\r\n                \r\n        _icoOpeningTime = block.timestamp;\r\n        _icoDurationInSeconds = _icoDurationInDays * 1 days;\r\n        _icoClosingTime = _icoOpeningTime + _icoDurationInSeconds;                                 \r\n    }\r\n\r\n    /**\r\n    * @dev Extends the ICO closing time.\r\n    * @notice Only the contract owner can extend the ICO.\r\n    * @notice This function can only be called while the ICO is open.\r\n    * @param _addedDurationInDays The added ICO duration in days.\r\n    */\r\n    function extendIcoTime(uint256 _addedDurationInDays) external onlyOwner onlyWhileOpen {\r\n        require(_addedDurationInDays > 0, \"ICO: Invalid Duration\");\r\n\r\n        _icoDurationInSeconds += _addedDurationInDays * 1 days;      \r\n        _icoClosingTime = _icoOpeningTime + _icoDurationInSeconds;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the price feed address of the native coin to USD from the Chainlink oracle.\r\n    * @param _toUsdPricefeed The address of native coin to USD price feed.\r\n    */    \r\n    function changePriceFeed(address _toUsdPricefeed) external onlyOwner onlyWhileClosed {\r\n        require(_toUsdPricefeed != address(0), \"ICO: Price feed address cannot be zero\" );\r\n        toUsdPriceFeed = AggregatorV3Interface(_toUsdPricefeed);        \r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the USD stable coin.\r\n    * @param _stableCoin The address of native USD stable coin.\r\n    */    \r\n    function changeStableCoin(address _stableCoin) external onlyOwner onlyWhileClosed {\r\n        require(_stableCoin != address(0), \"ICO: Price feed address cannot be zero\" );\r\n        _usdt = IERC20(_stableCoin);        \r\n    }\r\n\r\n    // update maximum number of tokens that can be purchased in a single transaction.\r\n    function change_maxTokensPerTx(uint256 _newMaxTokensPerTx) external onlyOwner onlyWhileClosed {\r\n        require(_newMaxTokensPerTx != 0, \"ICO: _maxTokensPerTx cannot be zero\" );\r\n        _maxTokensPerTx = _newMaxTokensPerTx;        \r\n    }\r\n\r\n    // update minimum number of tokens that can be purchased in a single transaction.\r\n    function change_minTokensPerTx(uint256 _newMinTokensPerTx) external onlyOwner onlyWhileClosed {\r\n        require(_newMinTokensPerTx != 0, \"ICO: _minTokensPerTx cannot be zero\" );\r\n        _minTokensPerTx = _newMinTokensPerTx;        \r\n    }\r\n\r\n    // update maximum number of tokens that a buyer can hold.\r\n    function change_maxTokensPerBuyer(uint256 _newMaxTokensPerBuyer) external onlyOwner onlyWhileClosed {\r\n        require(_newMaxTokensPerBuyer != 0, \"ICO: _maxTokensPerBuyer cannot be zero\" );\r\n        _maxTokensPerBuyer = _newMaxTokensPerBuyer;        \r\n    }\r\n\r\n    /**\r\n    * @dev Closes the ICO for buying tokens.\r\n    * @notice Only the contract owner can close the ICO.\r\n    * @notice This function can only be called while the ICO is open.\r\n    */\r\n    function closeIco() external onlyOwner onlyWhileOpen {        \r\n        _icoOpeningTime = 0;\r\n        _icoClosingTime = 0;\r\n        _icoDurationInSeconds = 0;                 \r\n    }  \r\n    \r\n    /**\r\n    * @dev Withdraws all funds from the ICO contract.\r\n    * @notice Only the contract owner can withdraw funds.\r\n    * @notice This function can only be called while the ICO is closed.\r\n    * @return _success boolean indicating whether the withdrawal was successful.\r\n    */\r\n    function withdrawFunds(uint _value) external onlyOwner onlyWhileClosed returns (bool _success) {        \r\n        require(_value > 0, \"ICO: Invalid Amount to withdraw Funds\");\r\n        require(_fundsRaised >= _value, \"ICO: No Enough Funds to Withdraw\");\r\n        \r\n        _fundsRaised -= _value;\r\n        (_success,) = owner().call{value: _value}(\"\");\r\n\r\n        emit FundsWithdrawn(owner(), _value);\r\n        return _success;        \r\n    }\r\n\r\n    /**\r\n    * @dev Withdraws Stable Coins from the ICO contract.\r\n    * @notice Only the contract owner can withdraw tokens.    \r\n    * @param _amount The amount of tokens to be withdrawn.\r\n    */\r\n    function withdrawUSDT(uint _amount) external onlyOwner onlyWhileClosed returns (bool) {        \r\n        require(_amount > 0, \"ICO: Invalid Amount to withdraw USDT\");      \r\n        require(_usdt.balanceOf(address(this)) >= _amount, \"ICO: No Enough USDT to Withdraw\");       \r\n\r\n        _usdt.transfer(owner(), _amount);\r\n        \r\n        emit usdtWithdrawn(owner(), _amount);\r\n        return true; \r\n    }\r\n\r\n    /**\r\n    * @dev withdraw the remained tokens (if any) in ICO.\r\n    * @notice This function can only be called while the ICO is closed.\r\n    */\r\n    function withdrawRemainedTokens() external onlyOwner onlyWhileClosed returns (bool) {\r\n        require(_icoTokenAmount != 0, \"ICO: No Tokens to withdraw\");\r\n\r\n        uint256 remainedAmount = _icoTokenAmount;\r\n        _icoTokenAmount = 0;\r\n        _token.transfer(msg.sender, remainedAmount);\r\n\r\n        emit TokensWithdrawn(msg.sender, remainedAmount);\r\n        return true;        \r\n    }\r\n\r\n\r\n    //------------------\r\n    // User Functions\r\n    //------------------\r\n\r\n    /**\r\n    * @dev Allows users to buy tokens during the ICO.\r\n    * @notice This function can only be called while the ICO is open.    \r\n    * @return A boolean indicating whether the token purchase was successful.\r\n    */\r\n    function publicSale_by_NativeCoin() external onlyWhileOpen nonReentrant payable returns(bool) {\r\n        address beneficiary = msg.sender;\r\n        uint256 paymentInWei = msg.value;                \r\n\r\n        _preValidatePurchase(beneficiary, paymentInWei);\r\n        uint256 tokenAmount = _getTokenAmount(false, paymentInWei);       \r\n        _processPurchase(beneficiary, tokenAmount);\r\n\r\n        _fundsRaised += paymentInWei;\r\n        tokenAmountInWallet[beneficiary] += tokenAmount;        \r\n        _icoTokenAmount -= tokenAmount;\r\n        _token.transfer(beneficiary, tokenAmount);\r\n\r\n        emit TokensPurchased(beneficiary, paymentInWei, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to buy tokens with a Stable coin during the ICO.\r\n    * @notice This function can only be called while the ICO is open.    \r\n    * @param _usdtAmount The amount of USDT in wei.    \r\n    * @return A boolean indicating whether the token purchase was successful.\r\n    */\r\n    function publicSale_buy_USDT(uint256 _usdtAmount) external onlyWhileOpen nonReentrant returns(bool) {\r\n        address beneficiary = msg.sender;                                     \r\n\r\n        _preValidatePurchase(beneficiary, _usdtAmount);\r\n        uint256 tokenAmount = _getTokenAmount(true, _usdtAmount);      \r\n        _processPurchase(beneficiary, tokenAmount);\r\n\r\n        tokenAmountInWallet[beneficiary] += tokenAmount;        \r\n        _icoTokenAmount -= tokenAmount;\r\n        _usdt.transferFrom(beneficiary, address(this), _usdtAmount);\r\n        _token.transfer(beneficiary, tokenAmount);\r\n\r\n        emit TokensPurchased(beneficiary, _usdtAmount, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n\r\n    //------------------\r\n    // Internal functions\r\n    //------------------\r\n\r\n    /**\r\n    * @dev Validates that a token purchase is valid.\r\n    * @notice This function is called by the `buyWithMatic()` function to validate the transaction.\r\n    * @param _beneficiary The address of the beneficiary of the token purchase.\r\n    * @param _amount The amount of Ether/USDT sent in the transaction.\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _amount) internal view {\r\n        require(_beneficiary != address(0), \"ICO: Beneficiary address cannot be zero\");\r\n        require(_amount > 0, \"ICO: Payment is zero\"); \r\n        require(_amount <= _icoTokenAmount, \"ICO: not enough tokens to buy\");\r\n    }\r\n\r\n    /**\r\n    * @dev Processes a token purchase for a given beneficiary.\r\n    * @notice This function is called by the `buyWithMatic()` function to process a token purchase.\r\n    * @param _beneficiary The address of the beneficiary of the token purchase.\r\n    * @param _tokenAmount The amount of tokens to be purchased.\r\n    */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal view {        \r\n        require(_tokenAmount >= _minTokensPerTx, \"ICO: cannot buy less than the max amount\" );\r\n        require(_tokenAmount <= _maxTokensPerTx, \"ICO: cannot buy more than the max amount\" );\r\n        require(tokenAmountInWallet[_beneficiary] + _tokenAmount <= _maxTokensPerBuyer, \"ICO: Cannot hold more tokens than max allowed\");      \r\n    }\r\n    \r\n    /**\r\n    * @dev Calculates the amount of tokens that can be purchased with the specified amount of ether, based on the current token rate in USD.\r\n    * @param paymentInWei The amount of ether sent to purchase tokens.\r\n    * @return The number of tokens that can be purchased with the specified amount of ether.\r\n    */\r\n    function _getTokenAmount(bool isUSDT, uint256 paymentInWei) internal view returns (uint256) {   \r\n        uint priceInwei;\r\n\r\n        if (isUSDT)\r\n            priceInwei = 1e18;\r\n        else          \r\n            priceInwei = _priceInWei();        \r\n        \r\n        return ((paymentInWei * priceInwei) / _tokenPriceInUSD);\r\n    }   \r\n\r\n    /**\r\n    * @dev Gets the latest MATIC/USD from the Chainlink oracle.\r\n    * @return The price of 1 MATIC in USD.\r\n    */\r\n    function _priceInWei() internal view returns (uint256) {\r\n        (,int price,,,) = toUsdPriceFeed.latestRoundData();\r\n        uint8 priceFeedDecimals = toUsdPriceFeed.decimals();\r\n        price = _toWei(price, priceFeedDecimals, 18);\r\n        return uint256(price);\r\n    } \r\n    \r\n    /**\r\n    * @dev Converts the price from the Chainlink Oracle to the appropriate data type,\r\n        before performing arithmetic operations.\r\n    * @param _amount The price returned from the Chainlink Oracle.\r\n    * @param _amountDecimals The number of decimals in the price returned from the Chainlink Oracle.\r\n    * @param _chainDecimals The number of decimals used by the Ethereum blockchain (18 for ether).\r\n    * @return The price converted to the appropriate data type.\r\n    */\r\n    function _toWei(int256 _amount, uint8 _amountDecimals, uint8 _chainDecimals) internal pure returns (int256) {        \r\n        if (_chainDecimals > _amountDecimals)\r\n            return _amount * int256(10 **(_chainDecimals - _amountDecimals));\r\n        else\r\n            return _amount * int256(10 **(_amountDecimals - _chainDecimals));\r\n    }\r\n\r\n\r\n    //------------------\r\n    // get functions\r\n    //------------------\r\n\r\n    /**\r\n    * @dev Checks if the ICO is currently open.\r\n    * @return A boolean indicating whether the ICO is currently open or not.\r\n    */\r\n    function isOpen() public view returns (bool) {        \r\n        return block.timestamp >= _icoOpeningTime && block.timestamp <= _icoClosingTime;\r\n    }    \r\n\r\n    /**\r\n    * @dev Returns the total amount of funds raised in the ICO.\r\n    * @return The total amount of funds raised in the ICO.\r\n    */\r\n    function getIcoFundsBalance() external view returns(uint256) {\r\n        return _fundsRaised;\r\n    } \r\n\r\n    /**\r\n    * @dev Returns the total amount of ICO tokens remaining.\r\n    * @return The total amount of ICO tokens remaining.\r\n    */\r\n    function getIcoCZEETokensBalance() external view returns(uint256) {\r\n        return _icoTokenAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the total amount of USDT raised in the ICO.\r\n    * @return The total amount of USDT raised in the ICO.\r\n    */\r\n    function getIcoUsdtBalance() external view returns(uint256) {\r\n        return _usdt.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of tokens held by the specified beneficiary.\r\n    * @param _beneficiary The address of the beneficiary.\r\n    * @return The number of tokens held by the specified beneficiary.\r\n    */\r\n    function getTokenBuyerBalance(address _beneficiary) external view returns(uint256) {\r\n        return tokenAmountInWallet[_beneficiary];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the maximum number of tokens that can be purchased in a single transaction.\r\n    */\r\n    function getMaxTokensPerTx() external view returns(uint256) {\r\n        return _maxTokensPerTx;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the minimum number of tokens that can be purchased in a single transaction.\r\n    */\r\n    function getMinTokensPerTx() external view returns(uint256) {\r\n        return _minTokensPerTx;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the maximum number of tokens that a buyer can hold.\r\n    */\r\n    function getMaxTokensPerBuyer() external view returns(uint256) {\r\n        return _maxTokensPerBuyer;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the duration of the ICO in seconds.\r\n    */    \r\n    function getIcoDurationInSeconds() external view returns(uint256) {\r\n        return _icoDurationInSeconds;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the Unix timestamp for the start of the ICO.\r\n    */    \r\n    function getIcoOpeningTime() external view returns(uint256) {\r\n        return _icoOpeningTime;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the Unix timestamp for the end of the ICO.\r\n    */    \r\n    function getIcoClosingTime() external view returns(uint256) {\r\n        return _icoClosingTime;\r\n    }\r\n\r\n    /**  \r\n    * @dev Returns the price of token in USD.\r\n    */    \r\n    function getTokenPriceInUSD() external view returns(uint256) {\r\n        return _tokenPriceInUSD;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the price feed address and the price of the native coin to USD from the Chainlink oracle.    \r\n    */  \r\n    function getPriceFeedData() external view returns(address, uint256) {\r\n        return (address(toUsdPriceFeed), _priceInWei());\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of USDT according to the chain.    \r\n    */\r\n    function getUSDTaddress() external view returns(address) {\r\n        return address(_usdt);\r\n    }\r\n\r\n    function getCZEETokenAddress() external view returns(address) {\r\n        return address(_token);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////\r\n    //          Private Sale\r\n    /////////////////////////////////////////////\r\n\r\n\r\n    /**\r\n    * @dev Allows users to buy tokens during the ICO.\r\n    * @notice This function can only be called while the ICO is open.    \r\n    * @return A boolean indicating whether the token purchase was successful.\r\n    */\r\n    function privateSale_by_NativeCoin() external onlyWhileOpen nonReentrant payable returns(bool) {\r\n        address beneficiary = msg.sender;\r\n        uint256 paymentInWei = msg.value;                \r\n        _preValidatePurchase(beneficiary, paymentInWei);\r\n\r\n        uint256 tokenAmount = _getTokenAmount(false, paymentInWei); \r\n        tokenAmountInWallet[beneficiary] += tokenAmount;   \r\n        _fundsRaised += paymentInWei;\r\n        _icoTokenAmount -= tokenAmount;\r\n\r\n        // keeping tokens for the claim by the buyer instead of a transfer\r\n        // _token.transfer(beneficiary, tokenAmount);\r\n        addBeneficiary(beneficiary, tokenAmount);\r\n\r\n        emit TokensPurchased(beneficiary, paymentInWei, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to buy tokens with a Stable coin during the ICO.\r\n    * @notice This function can only be called while the ICO is open.    \r\n    * @param _usdtAmount The amount of USDT in wei.    \r\n    * @return A boolean indicating whether the token purchase was successful.\r\n    */\r\n    function privateSale_buy_USDT(uint256 _usdtAmount) external onlyWhileOpen nonReentrant returns(bool) {\r\n        address beneficiary = msg.sender;                                     \r\n        _preValidatePurchase(beneficiary, _usdtAmount);\r\n\r\n        uint256 tokenAmount = _getTokenAmount(true, _usdtAmount);  \r\n        tokenAmountInWallet[beneficiary] += tokenAmount;        \r\n        _icoTokenAmount -= tokenAmount;\r\n\r\n        _usdt.transferFrom(beneficiary, address(this), _usdtAmount);\r\n\r\n        // keeping tokens for the claim by the buyer instead of a transfer\r\n        // _token.transfer(beneficiary, tokenAmount);\r\n        addBeneficiary(beneficiary, tokenAmount);\r\n\r\n        emit TokensPurchased(beneficiary, _usdtAmount, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    function addBeneficiary(address _beneficiary, uint256 purchaseAmount) internal {\r\n        require(_beneficiary != address(0), \"The Beneficiary address cannot be zero\");\r\n        require(beneficiaries[_beneficiary].scheduleStartTime == 0, \"The beneficiary has added already\");\r\n\r\n        beneficiaryAdrs.push(_beneficiary);\r\n\r\n        beneficiaries[_beneficiary] = Beneficiary({\r\n            scheduleStartTime: block.timestamp, \r\n            tokenAmountInWallet: purchaseAmount,\r\n            withdrawn: 0\r\n            });\r\n    }\r\n\r\n    // Beneficiary call this function to withdraw released tokens.\r\n    function withdrawTokens(uint256 _amount) external onlyBeneficiaries nonReentrant returns (bool)  {\r\n        require(_amount > 0, \"amount has to be grater than zero\");\r\n        address beneficiaryAdr = msg.sender;\r\n\r\n        // get amount of tokens that can be withdraw\r\n        (,,,uint256 canwithdraw) = getAvailableTokens(beneficiaryAdr);\r\n        require(canwithdraw >= _amount, \"You have not enough released tokens\");\r\n\r\n        // Update the beneficiary information\r\n        uint256 preWithdrawn = beneficiaries[beneficiaryAdr].withdrawn;\r\n        uint256 curWithdrawn = preWithdrawn.add(_amount);\r\n        beneficiaries[beneficiaryAdr].withdrawn = curWithdrawn;\r\n\r\n        // Transfer released tokens to the beneficiary\r\n        _token.transfer(beneficiaryAdr, _amount);\r\n\r\n        emit TokensWithdrawn(beneficiaryAdr, _amount);\r\n        return true;\r\n    }\r\n\r\n    function getBeneficiaryAdr(uint _idx) public view returns(address) {\r\n        return beneficiaryAdrs[_idx];\r\n    }\r\n\r\n    function getBeneficiary(address _beneficiaryAdr) public view returns(uint256, uint256, uint256) {\r\n        Beneficiary storage ben = beneficiaries[_beneficiaryAdr];\r\n        return (ben.scheduleStartTime, ben.tokenAmountInWallet , ben.withdrawn);\r\n    }\r\n\r\n    function getReleaseStep() public view returns (uint256) {\r\n        return releaseStep;\r\n    }\r\n\r\n    function getReleaseSchedule() public view returns(uint256[3] memory) {\r\n        return releaseSchedule;\r\n    }\r\n\r\n    function getCurrentSlot(address _beneficiaryAdr) public view returns (uint256) {\r\n        Beneficiary storage ben = beneficiaries[_beneficiaryAdr];\r\n        require(ben.scheduleStartTime != 0, \"You are not a beneficiary.\");\r\n        return (block.timestamp.sub(ben.scheduleStartTime)).div(releaseStep);\r\n    }\r\n\r\n    // Get the amount of tokens that beneficiary can withdraw now, base on release schedule.\r\n    function getAvailableTokens(address _beneficiary) public view returns ( \r\n        uint256 beneficiaryTotalTokens,\r\n        uint256 beneficiaryReleasedTokens,\r\n        uint256 withdrawn,\r\n        uint256 canwithdraw\r\n    ) {\r\n        require(_beneficiary != address(0), \"The Beneficiary address cannot be zero\");\r\n        Beneficiary storage ben = beneficiaries[_beneficiary];\r\n        require(ben.scheduleStartTime != 0, \"Invalid beneficiary.\");\r\n\r\n        beneficiaryTotalTokens = beneficiaries[_beneficiary].tokenAmountInWallet;\r\n        // get the current slot\r\n        uint256 curSlot  = getCurrentSlot(_beneficiary) > 3 ? 3 : getCurrentSlot(_beneficiary);\r\n\r\n        if(curSlot == 3) {\r\n            beneficiaryReleasedTokens = beneficiaryTotalTokens;\r\n        }\r\n        else {\r\n            for(uint i; i < curSlot; i++) {\r\n                uint256 slotReleasedTokens = (releaseSchedule[i].mul(beneficiaryTotalTokens)).div(100);\r\n                // Released tokens\r\n                beneficiaryReleasedTokens = beneficiaryReleasedTokens.add(slotReleasedTokens);\r\n            }\r\n        }\r\n\r\n        // How many tokens, this Beneficiary has took out of account, until now.\r\n        withdrawn = ben.withdrawn;\r\n        canwithdraw = beneficiaryReleasedTokens.sub(withdrawn);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"usdtWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toUsdPricefeed\",\"type\":\"address\"}],\"name\":\"changePriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stableCoin\",\"type\":\"address\"}],\"name\":\"changeStableCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxTokensPerBuyer\",\"type\":\"uint256\"}],\"name\":\"change_maxTokensPerBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxTokensPerTx\",\"type\":\"uint256\"}],\"name\":\"change_maxTokensPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinTokensPerTx\",\"type\":\"uint256\"}],\"name\":\"change_minTokensPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeIco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addedDurationInDays\",\"type\":\"uint256\"}],\"name\":\"extendIcoTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getAvailableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"beneficiaryTotalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beneficiaryReleasedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canwithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiaryAdr\",\"type\":\"address\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getBeneficiaryAdr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCZEETokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiaryAdr\",\"type\":\"address\"}],\"name\":\"getCurrentSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoCZEETokensBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoClosingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoDurationInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoFundsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoOpeningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIcoUsdtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTokensPerBuyer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTokensPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinTokensPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceFeedData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReleaseSchedule\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReleaseStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getTokenBuyerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDTaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_icoDurationInDays\",\"type\":\"uint256\"}],\"name\":\"openIco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"privateSale_buy_USDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privateSale_by_NativeCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"publicSale_buy_USDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSale_by_NativeCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRemainedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CZEEICO", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://087d021548427fa7d3bfb3019cbb52a1e55167a949220b4ff0a13cf55af239ef"}