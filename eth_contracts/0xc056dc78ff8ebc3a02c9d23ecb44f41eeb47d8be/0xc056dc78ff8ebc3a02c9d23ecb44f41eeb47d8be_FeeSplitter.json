{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n/**\r\n * @title FeeSplitter\r\n */\r\ncontract FeeSplitter {\r\n    address payable private recipient1;\r\n    address payable private recipient2;\r\n    address payable private recipient3;\r\n    bool private initialized;\r\n\r\n    constructor() {\r\n        // Contructor not used. Deploy script will call this.initialize()\r\n        initialized = false;\r\n    }\r\n\r\n    function initialize(\r\n        address payable _recipient1,\r\n        address payable _recipient2,\r\n        address payable _recipient3\r\n    )\r\n        public\r\n    {\r\n        require(initialized == false, \"Already initialized\");\r\n\r\n        recipient1 = _recipient1;\r\n        recipient2 = _recipient2;\r\n        recipient3 = _recipient3;\r\n\r\n        initialized = true;\r\n    }\r\n\r\n    receive() external payable {\r\n        _splitNative(msg.value);\r\n    }\r\n\r\n    error SplitNativeFailed(\r\n        bool recipient1,\r\n        bool recipient2,\r\n        bool recipient3\r\n    );\r\n\r\n    function _splitNative(uint256 value)\r\n        private\r\n    {\r\n        require(initialized == true, \"Uninitialized\");\r\n\r\n        uint256 prevBalance = address(this).balance - value;\r\n\r\n        // @dev any remainder will be included in next split\r\n        uint256 splitAmount = 0;\r\n        unchecked { splitAmount = (value + prevBalance) / 3; }\r\n\r\n        if (splitAmount > 0) {\r\n            (bool sent1,/* data */) = recipient1.call{value: splitAmount}(\"\");\r\n            (bool sent2,/* data */) = recipient2.call{value: splitAmount}(\"\");\r\n            (bool sent3,/* data */) = recipient3.call{value: splitAmount}(\"\");\r\n            if (!(sent1 && sent2 && sent3)) revert SplitNativeFailed(sent1, sent2, sent3);\r\n        }\r\n    }\r\n\r\n    function splitERC20(address tokenAddress) public returns (bool) {\r\n        require(initialized == true, \"Uninitialized\");\r\n        require(tokenAddress.code.length > 0, \"not a token\");\r\n        \r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        uint256 splitAmount;\r\n\r\n        // @dev any remainder will be included in next split\r\n        unchecked { splitAmount = balance / 3; } // underflow/remainder acceptable\r\n\r\n        token.transfer(recipient1, splitAmount);\r\n        token.transfer(recipient2, splitAmount);\r\n        token.transfer(recipient3, splitAmount);\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"recipient1\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"recipient2\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"recipient3\",\"type\":\"bool\"}],\"name\":\"SplitNativeFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient1\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_recipient2\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_recipient3\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"splitERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FeeSplitter", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://77866b076329b2b498833e83502d78b86cd80de1fb726fb1051d1912dbca07bf"}