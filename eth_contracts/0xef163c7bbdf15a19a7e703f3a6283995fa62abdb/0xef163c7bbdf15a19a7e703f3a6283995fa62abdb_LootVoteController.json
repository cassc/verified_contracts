{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHolyPalPower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.20;\\n\\ninterface IHolyPalPower {\\n    \\n    // Structs \\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope;\\n        uint256 endTimestamp;\\n        uint256 blockNumber;\\n    }\\n\\n    // Functions\\n    \\n\\tfunction balanceOf(address user) external view returns(uint256);\\n\\n    function balanceOfAt(address user, uint256 timestamp) external view returns(uint256);\\n\\n    function getUserPoint(address user) external view returns(Point memory);\\n\\n    function getUserPointAt(address user, uint256 timestamp) external view returns(Point memory);\\n\\n    // to match with veToken interface\\n    // solhint-disable-next-line\\n    function locked__end(address user) external view returns(uint256);\\n\\n    function totalSupply() external view returns(uint256);\\n\\n    function totalLocked() external view returns(uint256);\\n\\n    function totalLockedAt(uint256 blockNumber) external view returns(uint256);\\n\\n    function findTotalLockedAt(uint256 timestamp) external view returns(uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILootVoteController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.20;\\n\\ninterface ILootVoteController {\\n\\n\\tfunction isListedGauge(address gauge) external view returns(bool);\\n\\n    function getBoardForGauge(address gauge) external view returns(address);\\n    function getDistributorForGauge(address gauge) external view returns(address);\\n\\n\\tfunction getGaugeWeight(address gauge) external view returns(uint256);\\n    function getGaugeWeightAt(address gauge, uint256 ts) external view returns(uint256);\\n\\n    function getTotalWeight() external view returns(uint256);\\n\\n    function getGaugeRelativeWeight(address gauge) external view returns(uint256);\\n    function getGaugeRelativeWeight(address gauge, uint256 ts) external view returns(uint256);\\n\\n\\tfunction getGaugeRelativeWeightWrite(address gauge) external returns(uint256);\\n    function getGaugeRelativeWeightWrite(address gauge, uint256 ts) external returns(uint256);\\n\\n\\tfunction getGaugeCap(address gauge) external view returns(uint256);\\n\\n    function getUserProxyVoters(address user) external view returns(address[] memory);\\n\\n    function voteForGaugeWeights(address gauge, uint256 userPower) external;\\n    function voteForManyGaugeWeights(address[] memory gauge, uint256[] memory userPower) external;\\n\\n    function voteForGaugeWeightsFor(address user, address gauge, uint256 userPower) external;\\n    function voteForManyGaugeWeightsFor(address user, address[] memory gauge, uint256[] memory userPower) external;\\n\\n\\tfunction updateGaugeWeight(address gauge) external;\\n    function updateTotalWeight() external;\\n\\n    function approveProxyManager(address manager, uint256 maxDuration) external;\\n    function removeProxyManager(address manager) external;\\n    function setVoterProxy(address user, address proxy, uint256 maxPower, uint256 endTimestamp) external;\\n    function clearUserExpiredProxies(address user) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nlibrary Errors {\\n    \\n    // Commons\\n    error AddressZero();\\n    error NullAmount();\\n    error InvalidParameter();\\n    error SameAddress();\\n    error ArraySizeMismatch();\\n    error AlreadyInitialized();\\n\\n    // Access Control\\n    error CannotBeOwner();\\n    error CallerNotPendingOwner();\\n    error CallerNotAllowed();\\n\\n    // Merkle Distributor\\n    error EmptyParameters();\\n    error InvalidProof();\\n    error AlreadyClaimed();\\n    error MerkleRootNotUpdated();\\n    error EmptyMerkleRoot();\\n    error IncorrectQuestID();\\n    error QuestAlreadyListed();\\n    error QuestNotListed();\\n    error PeriodAlreadyUpdated();\\n    error PeriodNotClosed();\\n    error IncorrectPeriod();\\n    error PeriodNotListed();\\n    error TokenNotWhitelisted();\\n    error IncorrectRewardAmount();\\n    error CannotRecoverToken();\\n\\n    // HolyPalPower\\n    error InvalidTimestamp();\\n\\n    // Vote Controller\\n    error AlreadyListed();\\n    error LockExpired();\\n    error VotingPowerInvalid();\\n    error VotingPowerExceeded();\\n    error VotingPowerProxyExceeded();\\n    error VotingCooldown();\\n    error KilledGauge();\\n    error NotKilledGauge();\\n    error NotAllowedManager();\\n    error NotAllowedProxyVoter();\\n    error ExpiredProxy();\\n    error ProxyAlreadyActive();\\n    error ProxyPowerExceeded();\\n    error ProxyDurationExceeded();\\n    error NotAllowedVoteChange();\\n    error MaxVoteListExceeded();\\n    error MaxProxyListExceeded();\\n    error InvalidGaugeCap();\\n\\n    // Loot\\n    error CreatorAlreadySet();\\n    error InvalidId(uint256 id);\\n    error VestingNotStarted(uint256 id);\\n\\n    // Loot Creator\\n    error NotListed();\\n\\n    // Loot Buget\\n    error LootBudgetExceedLimit();\\n\\n    //Maths\\n    error ConversionOverflow();\\n}\"\r\n    },\r\n    \"contracts/LootVoteController.sol\": {\r\n      \"content\": \"//\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\\n//\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\n//\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\\n//\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\\n//\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\\n//\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\\n \\n\\n//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ILootVoteController} from \\\"./interfaces/ILootVoteController.sol\\\";\\nimport {IHolyPalPower} from \\\"./interfaces/IHolyPalPower.sol\\\";\\nimport \\\"./libraries/Errors.sol\\\";\\nimport \\\"./utils/Owner.sol\\\";\\n\\n/** @title Loot Vote Controller contract */\\n/// @author Paladin\\n/*\\n    Contract handling the vote logic for repartition of the global Loot budget\\n    between all the listed gauges for the Quest system\\n*/\\ncontract LootVoteController is Owner, ILootVoteController {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants\\n\\n    /** @notice Seconds in a Week */\\n    uint256 private constant WEEK = 604800;\\n\\n    /** @notice Unit scale for wei calculations */\\n    uint256 private constant UNIT = 1e18;\\n\\n    /** @notice Max BPS value */\\n    uint256 private constant MAX_BPS = 10000;\\n\\n    /** @notice Cooldown between 2 votes */\\n    uint256 private constant VOTE_COOLDOWN = 864000; // 10 days\\n\\n    /** @notice Max number of votes an user can vote at once */\\n    uint256 private constant MAX_VOTE_LENGTH = 10;\\n\\n    /** @notice Max number of proxies an user can have at once */\\n    uint256 private constant MAX_PROXY_LENGTH = 50;\\n\\n    uint256 private constant MIN_GAUGE_CAP = 0.001 * 1e18; // 0.1%\\n    uint256 private constant MAX_GAUGE_CAP = 1 * 1e18; // 100%\\n\\n\\n    // Structs\\n\\n    /** @notice Quest Board & distributor struct */\\n    struct QuestBoard {\\n        address board;\\n        address distributor;\\n    }\\n\\n    /** @notice Point struct */\\n    struct Point {\\n        uint256 bias;\\n        uint256 slope;\\n    }\\n\\n    /** @notice Voted Slope struct */\\n    struct VotedSlope {\\n        uint256 slope;\\n        uint256 power;\\n        uint256 end;\\n        address caller;\\n    }\\n\\n    /** @notice Struct used for the vote method */\\n    struct VoteVars {\\n        uint256 currentPeriod;\\n        uint256 nextPeriod;\\n        int128 userSlope;\\n        uint256 userLockEnd;\\n        uint256 oldBias;\\n        uint256 newBias;\\n        uint256 totalPowerUsed;\\n        uint256 oldUsedPower;\\n        uint256 oldWeightBias;\\n        uint256 oldWeightSlope;\\n        uint256 oldTotalBias;\\n        uint256 oldTotalSlope;\\n    }\\n\\n    /** @notice Proxy Voter struct */\\n    struct ProxyVoter {\\n        uint256 maxPower;\\n        uint256 usedPower;\\n        uint256 endTimestamp;\\n    }\\n\\n\\n    // Storage\\n\\n    /** @notice Address of the hPalPower contract */\\n    address public immutable hPalPower;\\n\\n    /** @notice Next ID to list Boards */\\n    uint256 public nextBoardId; // ID 0 == no ID/not set\\n\\n    /** @notice Listed Quest Boards */\\n    mapping(uint256 => QuestBoard) public questBoards;\\n    /** @notice Match Board address to ID */\\n    mapping(address => uint256) public boardToId;\\n    /** @notice Match Distributor address to ID */\\n    mapping(address => uint256) public distributorToId;\\n\\n    /** @notice Match a Gauge to a Board ID */\\n    mapping(address => uint256) public gaugeToBoardId;\\n    \\n    /** @notice Default weight cap for gauges */\\n    uint256 public defaultCap = 0.1 * 1e18; // 10%\\n    /** @notice Custom caps for gauges */\\n    mapping(address => uint256) public gaugeCaps;\\n    /** @notice Flag for killed gauges */\\n    mapping(address => bool) public isGaugeKilled;\\n\\n    /** @notice User VotedSlopes for each gauge */\\n    // user -> gauge -> VotedSlope\\n    mapping(address => mapping(address => VotedSlope)) public voteUserSlopes;\\n    /** @notice Total vote power used by user */\\n    mapping(address => uint256) public voteUserPower;\\n    /** @notice Last user vote's timestamp for each gauge address */\\n    mapping(address => mapping(address => uint256)) public lastUserVote;\\n\\n    /** @notice Point weight for each gauge */\\n    // gauge -> time -> Point\\n    mapping(address => mapping(uint256 => Point)) public pointsWeight;\\n    /** @notice Slope changes for each gauge */\\n    // gauge -> time -> slope\\n    mapping(address => mapping(uint256 => uint256)) public changesWeight;\\n    /** @notice Last scheduled time for gauge weight update */\\n    // gauge -> last scheduled time (next week)\\n    mapping(address => uint256) public timeWeight;\\n\\n    /** @notice Total Point weights */\\n    // time -> Point\\n    mapping(uint256 => Point) public pointsWeightTotal;\\n    /** @notice Total weight slope changes */\\n    // time -> slope\\n    mapping(uint256 => uint256) public changesWeightTotal;\\n    /** @notice Last scheduled time for weight update */\\n    uint256 public timeTotal;\\n\\n    /** @notice Proxy Managers set for each user */\\n    // user -> proxy manager -> bool\\n    mapping(address => mapping(address => bool)) public isProxyManager;\\n\\n    /** @notice Max Proxy duration allowed for Manager */\\n    // user -> proxy manager -> uint256\\n    mapping(address => mapping(address => uint256)) public maxProxyDuration;\\n\\n    /** @notice State of Proxy Managers for each user */\\n    // user -> proxy voter -> state\\n    mapping(address => mapping(address => ProxyVoter)) public proxyVoterState;\\n\\n    /** @notice List of current proxy for each user */\\n    mapping(address => address[]) public currentUserProxyVoters;\\n\\n    /** @notice Blocked (for Proxies) voting power for each user */\\n    mapping(address => uint256) public blockedProxyPower;\\n    /** @notice Used free voting power for each user */\\n    mapping(address => uint256) public usedFreePower;\\n\\n\\n\\n    // Events\\n\\n    /** @notice Event emitted when a vote is casted for a gauge */\\n    event VoteForGauge(\\n        uint256 time,\\n        address user,\\n        address gauge_addr,\\n        uint256 weight\\n    );\\n\\n    /** @notice Event emitted when a new Board is listed */\\n    event NewBoardListed(uint256 id, address indexed board, address indexed distributor);\\n    /** @notice Event emitted when a Board is udpated */\\n    event BoardUpdated(uint256 id, address indexed newDistributor);\\n\\n    /** @notice Event emitted when a new Gauge is listed */\\n    event NewGaugeAdded(address indexed gauge, uint256 indexed boardId, uint256 cap);\\n    /** @notice Event emitted when a Gauge is updated */\\n    event GaugeCapUpdated(address indexed gauge, uint256 indexed boardId, uint256 newCap);\\n    /** @notice Event emitted when a Gauge is updated */\\n    event GaugeBoardUpdated(address indexed gauge, uint256 indexed newBoardId);\\n    /** @notice Event emitted when a Gauge is killed */\\n    event GaugeKilled(address indexed gauge, uint256 indexed boardId);\\n    /** @notice Event emitted when a Gauge is unkilled */\\n    event GaugeUnkilled(address indexed gauge, uint256 indexed boardId);\\n\\n    /** @notice Event emitted when a Proxy Manager is set */\\n    event SetProxyManager(address indexed user, address indexed manager);\\n    /** @notice Event emitted when a Proxy Manager is removed */\\n    event RemoveProxyManager(address indexed user, address indexed manager);\\n    /** @notice Event emitted when a Proxy Voter is set */\\n    event SetNewProxyVoter(address indexed user, address indexed proxyVoter, uint256 maxPower, uint256 endTimestamp);\\n    \\n    /** @notice Event emitted when the default gauge cap is updated */\\n    event DefaultCapUpdated(uint256 newCap);\\n\\n\\n    // Constructor\\n\\n    constructor(address _hPalPower) {\\n        if(_hPalPower == address(0)) revert Errors.AddressZero();\\n\\n        hPalPower = _hPalPower;\\n\\n        nextBoardId = 1;\\n\\n        timeTotal = (block.timestamp) / WEEK * WEEK;\\n    }\\n\\n\\n    // View functions\\n\\n    /**\\n    * @notice Is the gauge listed\\n    * @param gauge Address of the gauge\\n    * @return bool : Is the gauge listed\\n    */\\n    function isListedGauge(address gauge) external view returns(bool) {\\n        return _isGaugeListed(gauge);\\n    }\\n\\n    /**\\n    * @notice Returns the Quest Board assocatied to a gauge\\n    * @param gauge Address of the gauge\\n    * @return address : Address of the Quest Board\\n    */\\n    function getBoardForGauge(address gauge) external view returns(address) {\\n        return questBoards[gaugeToBoardId[gauge]].board;\\n    }\\n\\n    /**\\n    * @notice Returns the Distributor assocatied to a gauge\\n    * @param gauge Address of the gauge\\n    * @return address : Address of the Distributor\\n    */\\n    function getDistributorForGauge(address gauge) external view returns(address) {\\n        return questBoards[gaugeToBoardId[gauge]].distributor;\\n    }\\n\\n    /**\\n    * @notice Returns the current gauge weight\\n    * @param gauge Address of the gauge\\n    * @return uint256 : Current gauge weight\\n    */\\n    function getGaugeWeight(address gauge) external view returns(uint256) {\\n        return pointsWeight[gauge][timeWeight[gauge]].bias;\\n    }\\n\\n    /**\\n    * @notice Returns the gauge weight at a specific timestamp\\n    * @param gauge Address of the gauge\\n    * @param ts Timestamp\\n    * @return uint256 : Gauge weight at the timestamp\\n    */\\n    function getGaugeWeightAt(address gauge, uint256 ts) external view returns(uint256) {\\n        ts = ts / WEEK * WEEK;\\n        return pointsWeight[gauge][ts].bias;\\n    }\\n\\n    /**\\n    * @notice Returns the current total weight\\n    * @return uint256 : Total weight\\n    */\\n    function getTotalWeight() external view returns(uint256) {\\n        return pointsWeightTotal[timeTotal].bias;\\n    }\\n\\n    /**\\n    * @notice Returns a gauge relative weight\\n    * @param gauge Address of the gauge\\n    * @return uint256 : Gauge relative weight\\n    */\\n    function getGaugeRelativeWeight(address gauge) external view returns(uint256) {\\n        return _getGaugeRelativeWeight(gauge, block.timestamp);\\n    }\\n\\n    /**\\n    * @notice Returns a gauge relative weight at a specific timestamp\\n    * @param gauge Address of the gauge\\n    * @param ts Timestamp\\n    * @return uint256 : Gauge relative weight at the timestamp\\n    */\\n    function getGaugeRelativeWeight(address gauge, uint256 ts) external view returns(uint256) {\\n        return _getGaugeRelativeWeight(gauge, ts);\\n    }\\n\\n    /**\\n    * @notice Returns the cap relative weight for a gauge\\n    * @param gauge Address of the gauge\\n    * @return uint256 : Gauge cap\\n    */\\n    function getGaugeCap(address gauge) external view returns(uint256) {\\n        return gaugeCaps[gauge] != 0 ? gaugeCaps[gauge] : defaultCap;\\n    }\\n\\n    /**\\n    * @notice Returns the list of current proxies for a user\\n    * @param user Address of the user\\n    * @return address[] : List of proxy addresses\\n    */\\n    function getUserProxyVoters(address user) external view returns(address[] memory) {\\n        return currentUserProxyVoters[user];\\n    }\\n\\n\\n    // State-changing functions\\n\\n    /**\\n    * @notice Votes for a gauge weight\\n    * @dev Votes for a gauge weight based on the given user power\\n    * @param gauge Address of the gauge\\n    * @param userPower Power used for this gauge\\n    */\\n    function voteForGaugeWeights(address gauge, uint256 userPower) external {\\n        // Clear any expired past Proxy\\n        _clearExpiredProxies(msg.sender);\\n\\n        _voteForGauge(msg.sender, gauge, userPower, msg.sender);\\n    }\\n\\n    /**\\n    * @notice Votes for multiple gauge weights\\n    * @dev Votes for multiple gauge weights based on the given user powers\\n    * @param gauge Address of the gauges\\n    * @param userPower Power used for each gauge\\n    */\\n    function voteForManyGaugeWeights(address[] calldata gauge, uint256[] calldata userPower) external {\\n        // Clear any expired past Proxy\\n        _clearExpiredProxies(msg.sender);\\n\\n        uint256 length = gauge.length;\\n        if(length > MAX_VOTE_LENGTH) revert Errors.MaxVoteListExceeded();\\n        if(length != userPower.length) revert Errors.ArraySizeMismatch();\\n        for(uint256 i; i < length; i++) {\\n            _voteForGauge(msg.sender, gauge[i], userPower[i], msg.sender);\\n        }\\n    }\\n\\n    /**\\n    * @notice Votes for a gauge weight as another user\\n    * @dev Votes for a gauge weight based on the given user power as another user (need to have a proxy set)\\n    * @param user Address of the user\\n    * @param gauge Address of the gauge\\n    * @param userPower Power used for this gauge\\n    */\\n    function voteForGaugeWeightsFor(address user, address gauge, uint256 userPower) external {\\n        // Clear any expired past Proxy\\n        _clearExpiredProxies(user);\\n\\n        ProxyVoter memory proxyState = proxyVoterState[user][msg.sender];\\n        if(proxyState.maxPower == 0) revert Errors.NotAllowedProxyVoter();\\n        if(proxyState.endTimestamp < block.timestamp) revert Errors.ExpiredProxy();\\n        if(userPower > proxyState.maxPower) revert Errors.VotingPowerProxyExceeded();\\n\\n        _voteForGauge(user, gauge, userPower, msg.sender);\\n    }\\n\\n    /**\\n    * @notice Votes for multiple gauge weights as another user\\n    * @dev Votes for multiple gauge weights based on the given user powers as another user (need to have a proxy set)\\n    * @param user Address of the user\\n    * @param gauge Address of the gauges\\n    * @param userPower Power used for each gauge\\n    */\\n    function voteForManyGaugeWeightsFor(address user, address[] calldata gauge, uint256[] calldata userPower) external {\\n        // Clear any expired past Proxy\\n        _clearExpiredProxies(user);\\n\\n        ProxyVoter memory proxyState = proxyVoterState[user][msg.sender];\\n        if(proxyState.maxPower == 0) revert Errors.NotAllowedProxyVoter();\\n        if(proxyState.endTimestamp < block.timestamp) revert Errors.ExpiredProxy();\\n        uint256 totalPower;\\n\\n        uint256 length = gauge.length;\\n        if(length > MAX_VOTE_LENGTH) revert Errors.MaxVoteListExceeded();\\n        if(length != userPower.length) revert Errors.ArraySizeMismatch();\\n        for(uint256 i; i < length;) {\\n            totalPower += userPower[i];\\n            _voteForGauge(user, gauge[i], userPower[i], msg.sender);\\n            unchecked { i++; }\\n        }\\n        if(totalPower > proxyState.maxPower) revert Errors.VotingPowerProxyExceeded();\\n    }\\n\\n    /**\\n    * @notice Returns the updated gauge relative weight\\n    * @dev Updates the gauge weight & returns the new relative weight\\n    * @param gauge Address of the gauge\\n    * @return uint256 : Updated gauge relative weight\\n    */\\n    function getGaugeRelativeWeightWrite(address gauge) external returns(uint256) {\\n        _updateGaugeWeight(gauge);\\n        _updateTotalWeight();\\n        return _getGaugeRelativeWeight(gauge, block.timestamp);\\n    }\\n\\n    /**\\n    * @notice Returns the updated gauge relative weight at a given timestamp\\n    * @dev Updates the gauge weight & returns the relative weight at a given timestamp\\n    * @param gauge Address of the gauge\\n    * @param ts Timestamp\\n    * @return uint256 : Updated gauge relative weight at the timestamp\\n    */\\n    function getGaugeRelativeWeightWrite(address gauge, uint256 ts) external returns(uint256) {\\n        _updateGaugeWeight(gauge);\\n        _updateTotalWeight();\\n        return _getGaugeRelativeWeight(gauge, ts);\\n    }\\n\\n    /**\\n    * @notice Updates the gauge weight\\n    * @dev Updates a gauge current weight for all past non-updated periods\\n    * @param gauge Address of the gauge\\n    */\\n    function updateGaugeWeight(address gauge) external {\\n        _updateGaugeWeight(gauge);\\n    }\\n\\n    /**\\n    * @notice Updates the total weight\\n    * @dev Updates the total wieght for all past non-updated periods\\n    */\\n    function updateTotalWeight() external {\\n        _updateTotalWeight();\\n    }\\n\\n    /**\\n    * @notice Approves a Proxy Manager for the caller\\n    * @dev Approves a Proxy Manager for the caller allowed to create Proxy on his voting power\\n    * @param manager Address of the Proxy Manager\\n    * @param maxDuration Maximum Proxy duration allowed to be created by the Manager (can be set to 0 for no limit)\\n    */\\n    function approveProxyManager(address manager, uint256 maxDuration) external {\\n        if(manager == address(0)) revert Errors.AddressZero();\\n\\n        isProxyManager[msg.sender][manager] = true;\\n        maxProxyDuration[msg.sender][manager] = maxDuration;\\n\\n        emit SetProxyManager(msg.sender, manager);\\n    }\\n\\n    /**\\n    * @notice Updates the max duration allowed for a Proxy Manager\\n    * @dev  Updates the max duration allowed for a Proxy Manager\\n    * @param manager Address of the Proxy Manager\\n    * @param newMaxDuration Maximum Proxy duration allowed to be created by the Manager (can be set to 0 for no limit)\\n    */\\n    function updateProxyManagerDuration(address manager, uint256 newMaxDuration) external {\\n        if(manager == address(0)) revert Errors.AddressZero();\\n        if(!isProxyManager[msg.sender][manager]) revert Errors.NotAllowedManager();\\n\\n        maxProxyDuration[msg.sender][manager] = newMaxDuration;\\n    }\\n\\n    /**\\n    * @notice Approves a Proxy Manager for the caller\\n    * @dev Approves a Proxy Manager for the caller allowed to create Proxy on his voting power\\n    * @param manager Address of the Proxy Manager\\n    */\\n    function removeProxyManager(address manager) external {\\n        if(manager == address(0)) revert Errors.AddressZero();\\n\\n        isProxyManager[msg.sender][manager] = false;\\n\\n        emit RemoveProxyManager(msg.sender, manager);\\n    }\\n\\n    /**\\n    * @notice Sets a Proxy Voter for the user\\n    * @dev Sets a Proxy Voter for the user allowed to vote on his behalf\\n    * @param user Address of the user\\n    * @param proxy Address of the Proxy Voter\\n    * @param maxPower Max voting power allowed for the Proxy\\n    * @param endTimestamp Timestamp of the Proxy expiry\\n    */\\n    function setVoterProxy(address user, address proxy, uint256 maxPower, uint256 endTimestamp) external {\\n        if(!isProxyManager[user][msg.sender] && msg.sender != user) revert Errors.NotAllowedManager();\\n        if(maxPower == 0 || maxPower > MAX_BPS) revert Errors.VotingPowerInvalid();\\n        if(currentUserProxyVoters[user].length + 1 > MAX_PROXY_LENGTH) revert Errors.MaxProxyListExceeded();\\n\\n        // Round down the end timestamp to weeks & check the user Lock is not expired then\\n        endTimestamp = endTimestamp / WEEK * WEEK;\\n        uint256 userLockEnd = IHolyPalPower(hPalPower).locked__end(user);\\n        if(endTimestamp < block.timestamp || endTimestamp > userLockEnd) revert Errors.InvalidTimestamp();\\n\\n        uint256 maxDuration = maxProxyDuration[user][msg.sender];\\n        if(maxDuration > 0 && endTimestamp > block.timestamp + maxDuration) revert Errors.ProxyDurationExceeded();\\n\\n        // Clear any expired past Proxy\\n        _clearExpiredProxies(user);\\n\\n        // Revert if the user already has a Proxy with the same address\\n        ProxyVoter memory prevProxyState = proxyVoterState[user][proxy];\\n        if(prevProxyState.maxPower != 0) revert Errors.ProxyAlreadyActive();\\n\\n        // Block the user's power for the Proxy & revert if the user execeed's its voting power\\n        uint256 userBlockedPower = blockedProxyPower[user];\\n        if(userBlockedPower + maxPower > MAX_BPS) revert Errors.ProxyPowerExceeded();\\n        blockedProxyPower[user] = userBlockedPower + maxPower;\\n\\n        // Set up the Proxy\\n        proxyVoterState[user][proxy] = ProxyVoter({\\n            maxPower: maxPower,\\n            usedPower: 0,\\n            endTimestamp: endTimestamp\\n        });\\n\\n        // Add the Proxy to the user's list\\n        currentUserProxyVoters[user].push(proxy);\\n\\n        emit SetNewProxyVoter(user, proxy, maxPower, endTimestamp);\\n    }\\n\\n    /**\\n    * @notice Clears expired Proxies for a user\\n    * @dev Clears all expired Proxies for a user & frees the blocked voting power\\n    * @param user Address of the user\\n    */\\n    function clearUserExpiredProxies(address user) external {\\n        _clearExpiredProxies(user);\\n    }\\n\\n\\n    // Internal functions\\n\\n    /**\\n    * @dev Checks if a gauge is listed\\n    * @param gauge Address of the gauge\\n    * @return bool : Is the gauge listed\\n    */\\n    function _isGaugeListed(address gauge) internal view returns(bool) {\\n        return gaugeToBoardId[gauge] != 0;\\n    }\\n\\n    /**\\n    * @dev Clears expired Proxies for a user & frees the blocked voting power\\n    * @param user Address of the user\\n    */\\n    function _clearExpiredProxies(address user) internal {\\n        uint256 length = currentUserProxyVoters[user].length;\\n        if(length == 0) return;\\n        for(uint256 i; i < length;) {\\n            address proxyVoter = currentUserProxyVoters[user][i];\\n            if(proxyVoterState[user][proxyVoter].endTimestamp < block.timestamp) {\\n                // Free the user blocked voting power\\n                blockedProxyPower[user] -= proxyVoterState[user][proxyVoter].maxPower;\\n                // Delete the Proxy\\n                delete proxyVoterState[user][proxyVoter];\\n                \\n                // Remove the Proxy from the user's list\\n                uint256 lastIndex = length - 1;\\n                if(i != lastIndex) {\\n                    currentUserProxyVoters[user][i] = currentUserProxyVoters[user][length-1];\\n                }\\n                currentUserProxyVoters[user].pop();\\n                length--;\\n            } else {\\n                unchecked{ i++; }\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Vote for a gauge weight based on the given user power\\n    * @param user Address of the user\\n    * @param gauge Address of the gauge\\n    * @param userPower Power used for this gauge\\n    * @param caller Address of the caller\\n    */\\n    function _voteForGauge(address user, address gauge, uint256 userPower, address caller) internal {\\n        VoteVars memory vars;\\n        \\n        // Get the periods timestamps & user lock state\\n        vars.currentPeriod = (block.timestamp) / WEEK * WEEK;\\n        vars.nextPeriod = vars.currentPeriod + WEEK;\\n        vars.userSlope = IHolyPalPower(hPalPower).getUserPoint(user).slope;\\n        vars.userLockEnd = IHolyPalPower(hPalPower).locked__end(user);\\n\\n        // Check the gauge is listed & the user lock is not expired\\n        if(!_isGaugeListed(gauge)) revert Errors.NotListed();\\n        if(vars.userLockEnd <= vars.nextPeriod) revert Errors.LockExpired();\\n        // Check the user has enough voting power & the cooldown is respected\\n        if(userPower > MAX_BPS) revert Errors.VotingPowerInvalid();\\n        if(block.timestamp < lastUserVote[user][gauge] + VOTE_COOLDOWN) revert Errors.VotingCooldown();\\n\\n        // Load the user past vote state\\n        VotedSlope memory oldSlope = voteUserSlopes[user][gauge];\\n        if(oldSlope.end > vars.nextPeriod) {\\n            vars.oldBias = oldSlope.slope * (oldSlope.end - vars.nextPeriod);\\n        }\\n\\n        // No vote to cast & no previous vote to remove == useless action\\n        if(userPower == 0 && oldSlope.power == 0) return;\\n\\n        // Calculate the new vote state\\n        VotedSlope memory newSlope = VotedSlope({\\n            slope: (convertInt128ToUint128(vars.userSlope) * userPower) / MAX_BPS,\\n            power: userPower,\\n            end: vars.userLockEnd,\\n            caller: caller\\n        });\\n        vars.newBias = newSlope.slope * (vars.userLockEnd - vars.nextPeriod);\\n\\n        // Check if the caller is allowed to change this vote\\n        if(\\n            oldSlope.caller != caller && proxyVoterState[user][oldSlope.caller].endTimestamp > block.timestamp\\n        ) revert Errors.NotAllowedVoteChange();\\n\\n        // Update the voter used voting power & the proxy one if needed\\n        vars.totalPowerUsed = voteUserPower[user];\\n        vars.totalPowerUsed = vars.totalPowerUsed + newSlope.power - oldSlope.power;\\n        if(user == caller) {\\n            uint256 usedPower = usedFreePower[user];\\n            vars.oldUsedPower = oldSlope.caller != user ? 0 : oldSlope.power;\\n            usedPower = usedPower + newSlope.power - vars.oldUsedPower;\\n            if(usedPower > (MAX_BPS - blockedProxyPower[user])) revert Errors.VotingPowerExceeded();\\n            usedFreePower[user] = usedPower;\\n        } else {\\n            uint256 proxyPower = proxyVoterState[user][caller].usedPower;\\n            vars.oldUsedPower = oldSlope.caller == caller ? oldSlope.power : 0;\\n            proxyPower = proxyPower + newSlope.power - vars.oldUsedPower;\\n            if(oldSlope.caller == user) {\\n                usedFreePower[user] -= oldSlope.power;\\n            }\\n            if(proxyPower > proxyVoterState[user][caller].maxPower) revert Errors.VotingPowerProxyExceeded();\\n\\n            proxyVoterState[user][caller].usedPower = proxyPower;\\n        }\\n        if(vars.totalPowerUsed > MAX_BPS) revert Errors.VotingPowerExceeded();\\n        voteUserPower[user] = vars.totalPowerUsed;\\n\\n        // Update the gauge weight\\n        vars.oldWeightBias = _updateGaugeWeight(gauge);\\n        vars.oldWeightSlope = pointsWeight[gauge][vars.nextPeriod].slope;\\n\\n        // Update the total weight\\n        vars.oldTotalBias = _updateTotalWeight();\\n        vars.oldTotalSlope = pointsWeightTotal[vars.nextPeriod].slope;\\n\\n        // Update the new gauge bias & total bias\\n        pointsWeight[gauge][vars.nextPeriod].bias = max(vars.oldWeightBias + vars.newBias, vars.oldBias) - vars.oldBias;\\n        pointsWeightTotal[vars.nextPeriod].bias = max(vars.oldTotalBias + vars.newBias, vars.oldBias) - vars.oldBias;\\n\\n        // Update the new gauge slope & total slope\\n        if(oldSlope.end > vars.nextPeriod) {\\n            pointsWeight[gauge][vars.nextPeriod].slope = max(vars.oldWeightSlope + newSlope.slope, oldSlope.slope) - oldSlope.slope;\\n            pointsWeightTotal[vars.nextPeriod].slope = max(vars.oldTotalSlope + newSlope.slope, oldSlope.slope) - oldSlope.slope;\\n        } else {\\n            pointsWeight[gauge][vars.nextPeriod].slope += newSlope.slope;\\n            pointsWeightTotal[vars.nextPeriod].slope += newSlope.slope;\\n        }\\n\\n        // Update the gauge slope changes & total slope changes\\n        if(oldSlope.end > block.timestamp) {\\n            changesWeight[gauge][oldSlope.end] -= oldSlope.slope;\\n            changesWeightTotal[oldSlope.end] -= oldSlope.slope;\\n        }\\n        changesWeight[gauge][newSlope.end] += newSlope.slope;\\n        changesWeightTotal[newSlope.end] += newSlope.slope;\\n\\n        // Store the user vote state\\n        voteUserSlopes[user][gauge] = newSlope;\\n        lastUserVote[user][gauge] = block.timestamp;\\n\\n        emit VoteForGauge(block.timestamp, user, gauge, userPower);\\n    }\\n\\n    /**\\n    * @dev Returns a gauge relative weight based on its weight and the total weight at a given period\\n    * @param gauge Address of the gauge\\n    * @param ts Timestamp\\n    * @return uint256 : Gauge relative weight\\n    */\\n    function _getGaugeRelativeWeight(address gauge, uint256 ts) internal view returns(uint256) {\\n        if(isGaugeKilled[gauge]) return 0;\\n\\n        ts = ts / WEEK * WEEK;\\n\\n        uint256 _totalWeight = pointsWeightTotal[ts].bias;\\n        if(_totalWeight == 0) return 0;\\n\\n        return (pointsWeight[gauge][ts].bias * UNIT) / _totalWeight;\\n    }\\n\\n    /**\\n    * @dev Updates the gauge weight for all past non-updated periods & returns the current gauge weight\\n    * @param gauge Address of the gauge\\n    * @return uint256 : Current gauge weight\\n    */\\n    function _updateGaugeWeight(address gauge) internal returns(uint256) {\\n        uint256 ts = timeWeight[gauge];\\n\\n        if(ts == 0) return 0;\\n\\n        Point memory _point = pointsWeight[gauge][ts];\\n        for(uint256 i; i < 500; i++) {\\n            if(ts > block.timestamp) break;\\n            ts += WEEK;\\n\\n            uint256 decreaseBias = _point.slope * WEEK;\\n            if(decreaseBias >= _point.bias) {\\n                _point.bias = 0;\\n                _point.slope = 0;\\n            } else {\\n                _point.bias -= decreaseBias;\\n                uint256 decreaseSlope = changesWeight[gauge][ts];\\n                _point.slope -= decreaseSlope;\\n            }\\n\\n            pointsWeight[gauge][ts] = _point;\\n\\n            if(ts > block.timestamp) {\\n                timeWeight[gauge] = ts;\\n            }\\n        }\\n\\n        return _point.bias;\\n    }\\n\\n    /**\\n    * @dev Updates the total weight for all past non-updated periods & returns the current total weight\\n    * @return uint256 : Current total weight\\n    */\\n    function _updateTotalWeight() internal returns(uint256) {\\n        uint256 ts = timeTotal;\\n\\n        if(ts == 0) return 0;\\n\\n        Point memory _point = pointsWeightTotal[ts];\\n        for(uint256 i; i < 500; i++) {\\n            if(ts > block.timestamp) break;\\n            ts += WEEK;\\n\\n            uint256 decreaseBias = _point.slope * WEEK;\\n            if(decreaseBias >= _point.bias) {\\n                _point.bias = 0;\\n                _point.slope = 0;\\n            } else {\\n                _point.bias -= decreaseBias;\\n                uint256 decreaseSlope = changesWeightTotal[ts];\\n                _point.slope -= decreaseSlope;\\n            }\\n\\n            pointsWeightTotal[ts] = _point;\\n\\n            if(ts > block.timestamp) {\\n                timeTotal = ts;\\n            }\\n        }\\n\\n        return _point.bias;\\n    }\\n\\n\\n    // Admin functions\\n\\n    /**\\n    * @notice Adds a new Quest Board & its Distributor\\n    * @dev Adds a new Quest Board & its Distributor\\n    * @param board Address of the Quest Board\\n    * @param distributor Address of the Distributor\\n    */\\n    function addNewBoard(address board, address distributor) external onlyOwner {\\n        if(board == address(0) || distributor == address(0)) revert Errors.AddressZero();\\n        if(boardToId[board] != 0 || distributorToId[distributor] != 0) revert Errors.AlreadyListed();\\n        \\n        uint256 boardId = nextBoardId;\\n        nextBoardId++;\\n\\n        questBoards[boardId] = QuestBoard(board, distributor);\\n        boardToId[board] = boardId;\\n        distributorToId[distributor] = boardId;\\n\\n        emit NewBoardListed(boardId, board, distributor);\\n    }\\n\\n    /**\\n    * @notice Updates the Distributor for a Quest Board\\n    * @dev Updates the Distributor for a Quest Board\\n    * @param board Address of the Quest Board\\n    * @param newDistributor Address of the new Distributor\\n    */\\n    function updateDistributor(address board, address newDistributor) external onlyOwner {\\n        if(board == address(0) || newDistributor == address(0)) revert Errors.AddressZero();\\n        if(distributorToId[newDistributor] != 0) revert Errors.AlreadyListed();\\n        \\n        uint256 boardId = boardToId[board];\\n        if(boardId == 0) revert Errors.InvalidParameter();\\n\\n        questBoards[boardId].distributor = newDistributor;\\n        distributorToId[newDistributor] = boardId;\\n\\n        emit BoardUpdated(boardId, newDistributor);\\n    }\\n\\n    /**\\n    * @notice Adds a new Gauge (with a cap)\\n    * @dev Adds a new Gauge linked to a listed Quest Board & sets a weight cap\\n    * @param gauge Address of the gauge\\n    * @param boardId ID of the Quest Board\\n    * @param cap Weight cap for the gauge\\n    */\\n    function addNewGauge(address gauge, uint256 boardId, uint256 cap) external onlyOwner {\\n        if(gauge == address(0)) revert Errors.AddressZero();\\n        if(boardId == 0) revert Errors.InvalidParameter();\\n        if(_isGaugeListed(gauge)) revert Errors.AlreadyListed();\\n        if((cap < MIN_GAUGE_CAP && cap != 0) || cap > MAX_GAUGE_CAP) revert Errors.InvalidGaugeCap();\\n\\n        gaugeToBoardId[gauge] = boardId;\\n        gaugeCaps[gauge] = cap;\\n\\n        timeWeight[gauge] = (block.timestamp + WEEK) / WEEK * WEEK;\\n\\n        emit NewGaugeAdded(gauge, boardId, cap);\\n    }\\n\\n    /**\\n    * @notice Updates the Board ID for a gauge\\n    * @dev Updates the Board ID for a gauge\\n    * @param gauge Address of the gauge\\n    * @param newBoardId New Board ID for the gauge\\n    */\\n    function updateGaugeBoard(address gauge, uint256 newBoardId) external onlyOwner {\\n        if(gauge == address(0)) revert Errors.AddressZero();\\n        if(gaugeToBoardId[gauge] == 0) revert Errors.InvalidParameter();\\n        if(isGaugeKilled[gauge]) revert Errors.KilledGauge();\\n\\n        gaugeToBoardId[gauge] = newBoardId;\\n\\n        emit GaugeBoardUpdated(gauge, newBoardId);\\n    }\\n\\n    /**\\n    * @notice Updates the weight cap for a gauge\\n    * @dev Updates the weight cap for a gauge\\n    * @param gauge Address of the gauge\\n    * @param newCap New weight cap for the gauge\\n    */\\n    function updateGaugeCap(address gauge, uint256 newCap) external onlyOwner {\\n        if(gauge == address(0)) revert Errors.AddressZero();\\n        if(gaugeToBoardId[gauge] == 0) revert Errors.InvalidParameter();\\n        if(isGaugeKilled[gauge]) revert Errors.KilledGauge();\\n        if((newCap < MIN_GAUGE_CAP && newCap != 0) || newCap > MAX_GAUGE_CAP) revert Errors.InvalidGaugeCap();\\n\\n        gaugeCaps[gauge] = newCap;\\n\\n        emit GaugeCapUpdated(gauge, gaugeToBoardId[gauge], newCap);\\n    }\\n\\n    /**\\n    * @notice Updates the default weight cap\\n    * @dev Updates the default weight cap\\n    * @param newCap New default weight cap\\n    */\\n    function updateDefaultGaugeCap(uint256 newCap) external onlyOwner {\\n        if(newCap < MIN_GAUGE_CAP || newCap > MAX_GAUGE_CAP) revert Errors.InvalidGaugeCap();\\n        defaultCap = newCap;\\n\\n        emit DefaultCapUpdated(newCap);\\n    }\\n\\n\\n    /**\\n    * @notice Kills a gauge\\n    * @dev Kills a gauge, blocking the votes & weight updates\\n    * @param gauge Address of the gauge\\n    */\\n    function killGauge(address gauge) external onlyOwner {\\n        if(gauge == address(0)) revert Errors.AddressZero();\\n        if(!_isGaugeListed(gauge)) revert Errors.NotListed();\\n        if(isGaugeKilled[gauge]) revert Errors.KilledGauge();\\n\\n        isGaugeKilled[gauge] = true;\\n\\n        emit GaugeKilled(gauge, gaugeToBoardId[gauge]);\\n    }\\n\\n    /**\\n    * @notice Unkills a gauge\\n    * @dev Unkills a gauge, unblocking the votes & weight updates\\n    * @param gauge Address of the gauge\\n    */\\n    function unkillGauge(address gauge) external onlyOwner {\\n        if(gauge == address(0)) revert Errors.AddressZero();\\n        if(!isGaugeKilled[gauge]) revert Errors.NotKilledGauge();\\n\\n        isGaugeKilled[gauge] = false;\\n\\n        emit GaugeUnkilled(gauge, gaugeToBoardId[gauge]);\\n    }\\n\\n    // Maths\\n\\n    function convertInt128ToUint128(int128 value) internal pure returns(uint128) {\\n        if (value < 0) revert Errors.ConversionOverflow();\\n        return uint128(value);\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/utils/Owner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\n/** @title 2-step Ownership  */\\n/// @author Paladin\\n/*\\n    Extends OZ Ownable contract to add 2-step ownership transfer\\n*/\\n\\ncontract Owner is Ownable {\\n\\n    address public pendingOwner;\\n\\n    event NewPendingOwner(address indexed previousPendingOwner, address indexed newPendingOwner);\\n\\n    constructor() Ownable(msg.sender) {}\\n\\n    function transferOwnership(address newOwner) public override virtual onlyOwner {\\n        if(newOwner == address(0)) revert Errors.AddressZero();\\n        if(newOwner == owner()) revert Errors.CannotBeOwner();\\n        address oldPendingOwner = pendingOwner;\\n\\n        pendingOwner = newOwner;\\n\\n        emit NewPendingOwner(oldPendingOwner, newOwner);\\n    }\\n\\n    function acceptOwnership() public virtual {\\n        if(msg.sender != pendingOwner) revert Errors.CallerNotPendingOwner();\\n        address newOwner = pendingOwner;\\n        _transferOwnership(pendingOwner);\\n        pendingOwner = address(0);\\n\\n        emit NewPendingOwner(newOwner, address(0));\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hPalPower\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArraySizeMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotBeOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConversionOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidGaugeCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KilledGauge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxProxyListExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxVoteListExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedProxyVoter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedVoteChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotKilledGauge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyAlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyDurationExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyPowerExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingCooldown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingPowerExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingPowerInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingPowerProxyExceeded\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"BoardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"DefaultCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBoardId\",\"type\":\"uint256\"}],\"name\":\"GaugeBoardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"GaugeCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"}],\"name\":\"GaugeKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"}],\"name\":\"GaugeUnkilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"board\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"NewBoardListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"NewGaugeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPendingOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"NewPendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"RemoveProxyManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxyVoter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"SetNewProxyVoter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetProxyManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"VoteForGauge\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"board\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"addNewBoard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"addNewGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"}],\"name\":\"approveProxyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockedProxyPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boardToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"changesWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"changesWeightTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"clearUserExpiredProxies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentUserProxyVoters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributorToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gaugeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gaugeToBoardId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getBoardForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getDistributorForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getGaugeCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getGaugeRelativeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"getGaugeRelativeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"getGaugeRelativeWeightWrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getGaugeRelativeWeightWrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"getGaugeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"getGaugeWeightAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserProxyVoters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hPalPower\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGaugeKilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"isListedGauge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isProxyManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"killGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUserVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxProxyDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextBoardId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pointsWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pointsWeightTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyVoterState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"questBoards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"board\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeProxyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"setVoterProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"unkillGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"updateDefaultGaugeCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"board\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"updateDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newBoardId\",\"type\":\"uint256\"}],\"name\":\"updateGaugeBoard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"updateGaugeCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"updateGaugeWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDuration\",\"type\":\"uint256\"}],\"name\":\"updateProxyManagerDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTotalWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usedFreePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userPower\",\"type\":\"uint256\"}],\"name\":\"voteForGaugeWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userPower\",\"type\":\"uint256\"}],\"name\":\"voteForGaugeWeightsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"gauge\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userPower\",\"type\":\"uint256[]\"}],\"name\":\"voteForManyGaugeWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"gauge\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userPower\",\"type\":\"uint256[]\"}],\"name\":\"voteForManyGaugeWeightsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteUserPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteUserSlopes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LootVoteController", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000a241a6670231ea66ac3bfe95f29c67f2bb28113b", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}