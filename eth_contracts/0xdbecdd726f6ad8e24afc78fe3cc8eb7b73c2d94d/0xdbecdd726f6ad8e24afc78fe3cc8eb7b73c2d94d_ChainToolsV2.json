{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\n/*                              \r\n                    CHAINTOOLS 2023. DEFI REIMAGINED\r\n\r\n                                                               2023\r\n\r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800            2021           \u28f0\u28fe\u28ff\u28f6\u2844\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28002019\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800     \u2839\u28ffV4\u2844\u2877\u2800\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28e4\u28fe\u28ff\u28f7\u28e6\u2840\u2800\u2800\u2800\u2800   \u28ff\u28ff\u284f\u2801\u2800\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800 \u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u2804\u2800\u2800\u2800  \u28f0\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u281f\u281b\u280b\u2800\u2800\u2800 \u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2809\u2809\u2809\u2801\u2880\u28f4\u28ff\u28ffV3\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800  \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800 \u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2840\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800        2017\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ffV2\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800 \u28b9\u28ff \u28ff\u28ff\u28ff\u28ff\u2819\u28bf\u28c6\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e4\u28f4\u28e6\u28e4\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2808\u28bb\u28ff\u28ff\u28ff\u28ff\u281b\u283f\u283f\u2836\u2836\u28f6\u2800  \u28ff \u28b8\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u2807\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28ff\u28ff\u28ff\u28ff\u28f7\u2846\u2800\u2800\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u2809\u281b\u28bf\u28f7\u2844\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800  \u2839\u2807\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2800\u2800\u28e0\u28f4\u28ff\u28ffV1\u28ff\u28ff\u28ff\u284f\u281b\u2803\u2800\u2800\u2800\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2818\u280b\u2801\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800  \u2800\u28ff\u28ff\u285f\u28bf\u28ff\u28ff\u2800\u2800\u2800\u2800   \r\n\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2809\u2819\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800 \u2888\u28ff\u28ff\u285f\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u287f\u2808\u28ff\u28ff\u285f\u2800\u2800\u2800\u2800\u2800  \u28b8\u28ff\u28ff\u2800\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800   \r\n\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u283b\u28ff\u28ff\u28ff\u28ff\u28f6\u28c4\u2800\u2800\u2800\u28b0\u28ff\u28ff\u285f\u2801\u28fe\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28f6\u28ff\u281f\u280b\u2800\u28bc\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u2801\u2800\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800   \r\n\u2800\u2880\u28f4\u28ff\u287f\u280b\u28b9\u28ff\u2847\u2800\u2800\u2808\u2819\u28ff\u28c7\u2819\u28ff\u28f7\u2800\u2800\u28b8\u28ff\u285f\u2800\u2800\u28bb\u28ff\u284f\u2800\u2800\u2800\u2800\u2800\u2880\u28fc\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800   \u28a8\u28ff\u2847\u2800\u2800\u2800\u28ff\u28ff\u2800\u2800\u2800\u2800   \r\n\u28f4\u28ff\u285f\u2809\u2800\u2800\u28fe\u28ff\u2847\u2800\u2800\u2800\u2800\u2888\u28ff\u2844\u2800\u2809\u2800\u2800\u28fc\u28ff\u2846\u2800\u2800\u28b8\u28ff\u28f7\u2800\u2800\u2800\u2800\u28b4\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ef\u2840\u2800\u2800\u2800\u2800    \u28b8\u28ff\u28c7\u2800\u2800\u2800\u28ba\u28ff\u2844\u2800\u2800\u2800   \r\n\u2808\u283b\u2837\u2804\u2800\u2800\u28ff\u28ff\u28f7\u28e4\u28e0\u2800\u2800\u2808\u283d\u2837\u2800\u2800\u2800\u2838\u281f\u281b\u281b\u2812\u2836\u2838\u28ff\u28ff\u28f7\u28e6\u28e4\u28c4\u2808\u283b\u2837\u2804\u2800\u2800\u2800\u283e\u283f\u283f\u28ff\u28f6\u28e4\u2800    \u2818\u281b\u281b\u281b\u2812\u2800\u2838\u283f\u283f\u2826 \r\n\r\n\r\nTelegram: https://t.me/ChaintoolsOfficial\r\nWebsite: https://www.chaintools.ai/\r\nWhitepaper: https://chaintools-whitepaper.gitbook.io/\r\nTwitter: https://twitter.com/ChaintoolsTech\r\ndApp: https://www.chaintools.wtf/\r\n*/\r\n\r\npragma solidity ^0.8.19;\r\n\r\n// import \"forge-std/console.sol\";\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\ninterface IV2Pair {\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n}\r\n\r\ninterface IV3Pool {\r\n    function liquidity() external view returns (uint128 Liq);\r\n\r\n    struct Info {\r\n        uint128 liquidity;\r\n        uint256 feeGrowthInside0LastX128;\r\n        uint256 feeGrowthInside1LastX128;\r\n        uint128 tokensOwed0;\r\n        uint128 tokensOwed1;\r\n    }\r\n\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    function positions(bytes32 key)\r\n        external\r\n        view\r\n        returns (IV3Pool.Info memory liqInfo);\r\n\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes memory data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\r\n    function burn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160,\r\n            int24,\r\n            uint16,\r\n            uint16,\r\n            uint16,\r\n            uint8,\r\n            bool\r\n        );\r\n\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function uniswapV3FlashCallback(\r\n        uint256 fee0,\r\n        uint256 fee1,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function mint(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n}\r\n\r\ninterface IWETH {\r\n    function withdraw(uint256 wad) external;\r\n\r\n    function approve(address who, uint256 wad) external returns (bool);\r\n\r\n    function deposit() external payable;\r\n\r\n    function transfer(address dst, uint256 wad) external returns (bool);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\ninterface IQuoterV2 {\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\ninterface IV3Factory {\r\n    function getPool(\r\n        address token0,\r\n        address token1,\r\n        uint24 poolFee\r\n    ) external view returns (address);\r\n\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address);\r\n}\r\n\r\ninterface INonfungiblePositionManager {\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function increaseLiquidity(\r\n        INonfungiblePositionManager.IncreaseLiquidityParams calldata params\r\n    )\r\n        external\r\n        returns (\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256 tokenId);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function factory() external view returns (address);\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function mint(MintParams calldata mp)\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 tokenId,\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    function collect(CollectParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function decreaseLiquidity(DecreaseLiquidityParams calldata dl)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function positions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n}\r\n\r\ninterface IRouterV3 {\r\n    function factory() external view returns (address);\r\n\r\n    function WETH9() external view returns (address);\r\n\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\r\n        external\r\n        returns (uint256 amountIn);\r\n\r\n    function exactInputSingle(ExactInputSingleParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n}\r\n\r\ninterface YieldVault {\r\n    function getDeviation(uint256 amountIn, uint256 startTickDeviation)\r\n        external\r\n        view\r\n        returns (uint256 adjusted);\r\n\r\n    function getCurrentTick() external view returns (int24 cTick);\r\n\r\n    function getStartTickDeviation(int24 currentTick)\r\n        external\r\n        view\r\n        returns (uint256 perc);\r\n\r\n    function findPoolFee(address token0, address token1)\r\n        external\r\n        view\r\n        returns (uint24 poolFee);\r\n\r\n    function getPosition(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint128 liquidity\r\n        );\r\n\r\n    function getTickDistance(uint256 flag)\r\n        external\r\n        view\r\n        returns (int24 tickDistance);\r\n\r\n    function findApprovalToken(address pool)\r\n        external\r\n        view\r\n        returns (address token);\r\n\r\n    function findApprovalToken(address token0, address token1)\r\n        external\r\n        view\r\n        returns (address token);\r\n\r\n    function buyback(\r\n        uint256 flag,\r\n        uint128 internalWETHAmt,\r\n        uint128 internalCTLSAmt,\r\n        address to,\r\n        uint256 id\r\n    ) external returns (uint256 t0, uint256 t1);\r\n\r\n    function keeper() external view returns (address);\r\n}\r\n\r\ninterface YieldBooster {\r\n    function preventFragmentations(address pool) external;\r\n}\r\n\r\ninterface TickMaths {\r\n    function getSqrtRatioAtTick(int24 tick)\r\n        external\r\n        pure\r\n        returns (uint160 sqrtPriceX96);\r\n}\r\n\r\ncontract ChainToolsV2 is Context, IERC20, IERC20Metadata {\r\n    IUniswapV2Router02 internal immutable router;\r\n    INonfungiblePositionManager internal immutable positionManager;\r\n    YieldBooster internal YIELD_BOOSTER;\r\n    YieldVault internal YIELD_VAULT;\r\n    TickMaths internal immutable TickMath;\r\n    address internal immutable uniswapV3Pool;\r\n    address internal immutable multiSig;\r\n    address internal immutable WETH;\r\n    address internal immutable v3Router;\r\n    address internal immutable apest;\r\n\r\n    uint256 internal immutable _MAX_SUPPLY;\r\n    uint256 internal immutable _totalSupply;\r\n    uint256 internal immutable _cap;\r\n\r\n    uint8 internal tokenomicsOn;\r\n    uint32 internal startStamp;\r\n    uint32 internal lastRewardStamp;\r\n    uint80 internal issuanceRate;\r\n\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\n    mapping(address => bool) internal isTaxExcluded;\r\n    mapping(address => bool) internal badPool;\r\n\r\n    mapping(address => address) internal upperRef;\r\n    mapping(address => uint256) internal sandwichLock;\r\n\r\n    event zapIn(\r\n        address indexed from,\r\n        uint256 tokenId,\r\n        uint256 flag,\r\n        uint256 amtETHIn,\r\n        uint256 amtTokensIn\r\n    );\r\n\r\n    event referralPaid(address indexed from, address indexed to, uint256 amt);\r\n\r\n    error MinMax();\r\n    error ZeroAddress();\r\n    error Auth();\r\n    error Sando();\r\n\r\n    constructor(address _apest, address _tickMaths) {\r\n        TickMath = TickMaths(_tickMaths);\r\n        multiSig = 0xb0Df68E0bf4F54D06A4a448735D2a3d7D97A2222;\r\n        apest = _apest;\r\n        tokenomicsOn = 1;\r\n        issuanceRate = 10e18;\r\n        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        WETH = IRouterV3(v3Router).WETH9();\r\n\r\n        positionManager = INonfungiblePositionManager(\r\n            0xC36442b4a4522E871399CD717aBDD847Ab11FE88\r\n        );\r\n\r\n        uniswapV3Pool = IV3Factory(positionManager.factory()).createPool(\r\n            WETH,\r\n            address(this),\r\n            10000\r\n        );\r\n\r\n        require(IV3Pool(uniswapV3Pool).token0() == WETH, \"token0pool0\");\r\n\r\n        //Initial supply\r\n        uint256 forLiquidityBootstrap = 1_000_000e18;\r\n        _balances[\r\n            0x0000000000000000000000000000000000C0FFEE\r\n        ] = forLiquidityBootstrap;\r\n        emit Transfer(\r\n            address(0),\r\n            address(0x0000000000000000000000000000000000C0FFEE),\r\n            forLiquidityBootstrap\r\n        );\r\n\r\n        uint256 forMigration = 8_200_000e18;\r\n        _balances[apest] += forMigration;\r\n        emit Transfer(address(0), address(apest), forMigration);\r\n\r\n        uint256 forLp = 600_000e18;\r\n        _balances[address(this)] += forLp;\r\n        emit Transfer(address(0), address(this), forLp);\r\n\r\n        uint256 forMarketing = 1_000_000e18;\r\n        _balances[0xb0Df68E0bf4F54D06A4a448735D2a3d7D97A2222] += forMarketing;\r\n        emit Transfer(\r\n            address(0),\r\n            0xb0Df68E0bf4F54D06A4a448735D2a3d7D97A2222,\r\n            forMarketing\r\n        );\r\n\r\n        uint256 forYieldBoosting = 200_000e18;\r\n        _balances[address(this)] += forYieldBoosting;\r\n        emit Transfer(address(0), address(this), forMarketing);\r\n\r\n        int24 startTick = 98140;\r\n        IV3Pool(uniswapV3Pool).initialize(\r\n            TickMath.getSqrtRatioAtTick(startTick)\r\n        );\r\n        IERC20(WETH).approve(address(positionManager), type(uint256).max);\r\n        IERC20(WETH).approve(v3Router, type(uint256).max);\r\n\r\n        _allowances[address(this)][v3Router] = type(uint256).max;\r\n        _allowances[address(this)][address(positionManager)] = type(uint256)\r\n            .max;\r\n\r\n        isTaxExcluded[v3Router] = true;\r\n        isTaxExcluded[multiSig] = true;\r\n        isTaxExcluded[address(this)] = true;\r\n\r\n        _totalSupply = forLiquidityBootstrap + forMigration + forLp + forMarketing + forYieldBoosting;\r\n        _MAX_SUPPLY = _totalSupply;\r\n        _cap = _MAX_SUPPLY;\r\n    }\r\n\r\n    function prepareFomo(address yieldVault, address yieldBooster) external {\r\n        if (msg.sender != apest) revert Auth();\r\n        if (startStamp != 0) revert MinMax();\r\n\r\n        //Compounder\r\n        YIELD_VAULT = YieldVault(yieldVault);\r\n        isTaxExcluded[address(YIELD_VAULT)] = true;\r\n        _allowances[address(YIELD_VAULT)][address(positionManager)] = type(\r\n            uint256\r\n        ).max;\r\n        _allowances[address(YIELD_VAULT)][address(v3Router)] = type(uint256)\r\n            .max;\r\n\r\n        //Yield Booster\r\n        YIELD_BOOSTER = YieldBooster(payable(yieldBooster));\r\n\r\n        _allowances[address(YIELD_BOOSTER)][address(positionManager)] = type(\r\n            uint256\r\n        ).max;\r\n\r\n        isTaxExcluded[address(YIELD_BOOSTER)] = true;\r\n        _basicTransfer(address(this), address(YIELD_BOOSTER), 200_000e18);\r\n\r\n        YIELD_BOOSTER.preventFragmentations(address(0));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function preparePool() external payable {\r\n        if (msg.sender != apest) revert Auth();\r\n        startStamp = uint32(block.timestamp);\r\n\r\n        int24 tick = 98140;\r\n        uint256 forLp = 600_000e18;\r\n        tick = (tick / 200) * 200;\r\n        uint256 a0;\r\n        uint256 a1;\r\n        IWETH(WETH).deposit{value: msg.value}();\r\n        (, , a0, a1) = positionManager.mint(\r\n            INonfungiblePositionManager.MintParams({\r\n                token0: WETH,\r\n                token1: address(this),\r\n                fee: 10000,\r\n                tickLower: tick - 420000,\r\n                tickUpper: tick + 420000,\r\n                amount0Desired: msg.value - 1e7,\r\n                amount1Desired: forLp,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                recipient: address(this),\r\n                deadline: block.timestamp\r\n            })\r\n        );\r\n\r\n        positionManager.setApprovalForAll(address(YIELD_VAULT), true);\r\n\r\n        uint256 leftOver2 = forLp - a1;\r\n\r\n        (, , , a1) = positionManager.mint(\r\n            INonfungiblePositionManager.MintParams({\r\n                token0: WETH,\r\n                token1: address(this),\r\n                fee: 10000,\r\n                tickLower: tick - 420000,\r\n                tickUpper: tick - 200,\r\n                amount0Desired: 0,\r\n                amount1Desired: leftOver2,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                recipient: address(this),\r\n                deadline: block.timestamp\r\n            })\r\n        );\r\n\r\n        IRouterV3(v3Router).exactInputSingle(\r\n            IRouterV3.ExactInputSingleParams({\r\n                tokenIn: WETH,\r\n                tokenOut: address(this),\r\n                fee: 10000,\r\n                recipient: multiSig,\r\n                deadline: block.timestamp,\r\n                amountIn: 1e7 - 1,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n\r\n        uint256 leftOver = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (leftOver != 0) {\r\n            IERC20(WETH).transfer(multiSig, leftOver - 1);\r\n        }\r\n        startStamp = 0;\r\n    }\r\n\r\n    function openTrading() external {\r\n        startStamp = uint32(block.timestamp);\r\n        lastRewardStamp = uint32(block.timestamp);\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return \"ChainTools\";\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return \"CTLS\";\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _approve(from, spender, _allowances[from][spender] - amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        unchecked {\r\n            _balances[recipient] += amount;\r\n        }\r\n        if (\r\n            sender != address(YIELD_BOOSTER) &&\r\n            recipient != address(YIELD_BOOSTER) &&\r\n            recipient != address(positionManager)\r\n        ) emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (owner == address(0)) revert ZeroAddress();\r\n        if (spender == address(0)) revert ZeroAddress();\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function multiTransfer(address[] calldata to, uint256[] calldata amounts)\r\n        external\r\n    {\r\n        uint256 size = to.length;\r\n        require(size == amounts.length, \"Length\");\r\n        if (msg.sender != apest) {\r\n            require(startStamp != 0, \"notOpenYet\");\r\n            require(sandwichLock[msg.sender] != block.number, \"altSando\");\r\n        }\r\n        for (uint256 i; i < size; ) {\r\n            unchecked {\r\n                _basicTransfer(msg.sender, to[i], amounts[i]);\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        //determine trader\r\n        address trader = sender == uniswapV3Pool ? recipient : sender;\r\n        if (sender != uniswapV3Pool && recipient != uniswapV3Pool)\r\n            trader = sender;\r\n\r\n        if (startStamp == 0) {\r\n            revert MinMax();\r\n        }\r\n\r\n        if (\r\n            recipient == uniswapV3Pool ||\r\n            recipient == address(positionManager) ||\r\n            isTaxExcluded[sender] ||\r\n            isTaxExcluded[recipient]\r\n        ) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        if (\r\n            trader != address(this) &&\r\n            trader != address(YIELD_BOOSTER) &&\r\n            trader != address(positionManager) &&\r\n            trader != address(YIELD_VAULT)\r\n        ) {\r\n            //One Block Delay [Sandwich Protection]\r\n            if (sandwichLock[trader] < block.number) {\r\n                sandwichLock[trader] = block.number + 1;\r\n            } else {\r\n                revert Sando();\r\n            }\r\n        }\r\n\r\n        if (tokenomicsOn != 0) {\r\n            if (amount < 1e8 || amount > 2_000_000e18) revert MinMax();\r\n        } else {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        //Normal Transfer\r\n        if (\r\n            sender != uniswapV3Pool &&\r\n            sender != address(positionManager) &&\r\n            recipient != uniswapV3Pool\r\n        ) {\r\n            if (badPool[recipient]) revert Auth();\r\n            try this.swapBack() {} catch {}\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        unchecked {\r\n            if (sender != uniswapV3Pool) {\r\n                try this.swapBack() {} catch {}\r\n            }\r\n        }\r\n\r\n        _balances[sender] -= amount;\r\n\r\n        //Tax & Final transfer amounts\r\n        unchecked {\r\n            uint256 tFee = amount / 20;\r\n\r\n            if (\r\n                //Only first 10 minutes\r\n                block.timestamp < startStamp + 10 minutes\r\n            ) {\r\n                //Sniper bots funding lp rewards\r\n                tFee *= 2;\r\n            }\r\n\r\n            amount -= tFee;\r\n            //if sender is not position manager tax go to contract\r\n            if (sender != address(positionManager)) {\r\n                _balances[address(this)] += tFee;\r\n            } else if (sender == address(positionManager)) {\r\n                address ref = upperRef[recipient] != address(0)\r\n                    ? upperRef[recipient]\r\n                    : multiSig;\r\n                uint256 rFee0 = tFee / 5;\r\n                _balances[ref] += rFee0;\r\n                tFee -= rFee0;\r\n\r\n                _balances[address(YIELD_BOOSTER)] += tFee;\r\n\r\n                emit Transfer(recipient, ref, tFee);\r\n                emit referralPaid(recipient, ref, rFee0);\r\n            }\r\n\r\n            _balances[recipient] += amount;\r\n        }\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapBack() public {\r\n        unchecked {\r\n            uint256 fullAmount = _balances[address(this)];\r\n            if (fullAmount < _totalSupply / 2000) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                msg.sender != address(this) &&\r\n                msg.sender != address(YIELD_VAULT) &&\r\n                msg.sender != address(YIELD_BOOSTER)\r\n            ) revert Auth();\r\n            //0.20% max per swap\r\n            uint256 maxSwap = _totalSupply / 500;\r\n\r\n            if (fullAmount > maxSwap) {\r\n                fullAmount = maxSwap;\r\n            }\r\n\r\n            IRouterV3(v3Router).exactInputSingle(\r\n                IRouterV3.ExactInputSingleParams({\r\n                    tokenIn: address(this),\r\n                    tokenOut: WETH,\r\n                    fee: 10000,\r\n                    recipient: address(this),\r\n                    deadline: block.timestamp,\r\n                    amountIn: fullAmount,\r\n                    amountOutMinimum: 0,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            );\r\n        }\r\n    }\r\n\r\n    function sendLPRewards() internal {\r\n        unchecked {\r\n            address sendToken = WETH;\r\n            assembly {\r\n                let bal := balance(address())\r\n                if gt(bal, 1000000000000) {\r\n                    let inputMem := mload(0x40)\r\n                    mstore(inputMem, 0xd0e30db)\r\n                    pop(call(gas(), sendToken, bal, inputMem, 0x4, 0, 0))\r\n                }\r\n            }\r\n            uint256 fin = IERC20(WETH).balanceOf(address(this)) - 1;\r\n            address toMsig = multiSig;\r\n            address toPool = uniswapV3Pool;\r\n            assembly {\r\n                if gt(fin, 1000000000000) {\r\n                    let inputMem := mload(0x40)\r\n                    mstore(\r\n                        inputMem,\r\n                        0xa9059cbb00000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(inputMem, 0x04), toMsig)\r\n                    mstore(add(inputMem, 0x24), div(mul(fin, 65), 100))\r\n                    pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\r\n                    mstore(\r\n                        inputMem,\r\n                        0xa9059cbb00000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(inputMem, 0x04), toPool)\r\n                    mstore(add(inputMem, 0x24), div(mul(fin, 35), 100))\r\n                    pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function flashReward() external {\r\n        if (\r\n            msg.sender != address(this) &&\r\n            msg.sender != address(YIELD_VAULT) &&\r\n            msg.sender != address(multiSig) &&\r\n            msg.sender != address(YIELD_BOOSTER)\r\n        ) revert Auth();\r\n        if (IV3Pool(uniswapV3Pool).liquidity() != 0) {\r\n            IV3Pool(uniswapV3Pool).flash(address(this), 0, 0, \"\");\r\n        }\r\n    }\r\n\r\n    function uniswapV3FlashCallback(\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external {\r\n        if (msg.sender != uniswapV3Pool) revert Auth();\r\n        uint256 secondsPassed = block.timestamp - lastRewardStamp;\r\n        if (secondsPassed > 30 minutes) {\r\n            sendLPRewards();\r\n            lastRewardStamp = uint32(block.timestamp);\r\n\r\n            if (issuanceRate == 0) return;\r\n\r\n            uint256 pending = (secondsPassed / 60) * issuanceRate;\r\n            if (\r\n                _balances[0x0000000000000000000000000000000000C0FFEE] >= pending\r\n            ) {\r\n                unchecked {\r\n                    _balances[\r\n                        0x0000000000000000000000000000000000C0FFEE\r\n                    ] -= pending;\r\n                    _balances[uniswapV3Pool] += pending;\r\n                    emit Transfer(\r\n                        0x0000000000000000000000000000000000C0FFEE,\r\n                        uniswapV3Pool,\r\n                        pending\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _collectLPRewards(uint256 tokenId)\r\n        internal\r\n        returns (uint256 c0, uint256 c1)\r\n    {\r\n        (c0, c1) = positionManager.collect(\r\n            INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: address(this),\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            })\r\n        );\r\n    }\r\n\r\n    function _decreasePosition(uint256 tokenId, uint128 liquidity)\r\n        internal\r\n        returns (uint256 a0, uint256 a1)\r\n    {\r\n        positionManager.decreaseLiquidity(\r\n            INonfungiblePositionManager.DecreaseLiquidityParams({\r\n                tokenId: tokenId,\r\n                liquidity: liquidity,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                deadline: block.timestamp\r\n            })\r\n        );\r\n        (a0, a1) = _collectLPRewards(tokenId);\r\n    }\r\n\r\n    function _swapV3(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 poolFee,\r\n        uint256 amountIn,\r\n        uint256 minOut\r\n    ) internal returns (uint256 out) {\r\n        if (tokenIn != WETH && tokenIn != address(this)) {\r\n            tokenIn.call(\r\n                abi.encodeWithSelector(\r\n                    IERC20.approve.selector,\r\n                    address(v3Router),\r\n                    amountIn\r\n                )\r\n            );\r\n        }\r\n        require(tokenIn == WETH || tokenOut == WETH, \"unsupported_pair\");\r\n        out = IRouterV3(v3Router).exactInputSingle(\r\n            IRouterV3.ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: poolFee,\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: amountIn,\r\n                amountOutMinimum: minOut,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    function zapFromV3LPToken(\r\n        uint256 tokenId,\r\n        uint256 minOut,\r\n        uint256 minOut2,\r\n        uint256 flag,\r\n        address ref\r\n    ) external payable returns (uint256 tokenIdNew) {\r\n        if (positionManager.ownerOf(tokenId) != msg.sender) revert Auth();\r\n        (address token0, address token1, uint128 liquidity) = YIELD_VAULT\r\n            .getPosition(tokenId);\r\n        (uint256 c0, uint256 c1) = _decreasePosition(\r\n            tokenId,\r\n            (liquidity * uint128(msg.value)) / 100\r\n        );\r\n\r\n        uint256 gotOut = _swapV3(\r\n            token0 == WETH ? token1 : token0,\r\n            WETH,\r\n            YIELD_VAULT.findPoolFee(token0, token1),\r\n            token0 == WETH ? c1 : c0,\r\n            minOut\r\n        );\r\n\r\n        uint256 totalWETH = token0 == WETH ? c0 + gotOut : c1 + gotOut;\r\n        address _weth = WETH;\r\n        assembly {\r\n            let inputMem := mload(0x40)\r\n            mstore(\r\n                inputMem,\r\n                0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(inputMem, 0x04), totalWETH)\r\n            pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\r\n        }\r\n\r\n        return\r\n            this.zapFromETH{value: totalWETH}(minOut2, msg.sender, flag, ref);\r\n    }\r\n\r\n    function _mintPosition(\r\n        uint256 amt0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 flag,\r\n        address to\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 tokenId,\r\n            uint256 amt0Consumed,\r\n            uint256 amt1Consumed\r\n        )\r\n    {\r\n        int24 tick = YIELD_VAULT.getCurrentTick();\r\n        int24 tickDist = YieldVault(YIELD_VAULT).getTickDistance(flag);\r\n        (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(\r\n            INonfungiblePositionManager.MintParams({\r\n                token0: WETH,\r\n                token1: address(this),\r\n                fee: 10000,\r\n                tickLower: tick - tickDist < int24(-887000)\r\n                    ? int24(-887000)\r\n                    : tick - tickDist,\r\n                tickUpper: tick + tickDist > int24(887000)\r\n                    ? int24(887000)\r\n                    : tick + tickDist,\r\n                amount0Desired: amt0Desired,\r\n                amount1Desired: amount1Desired,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                recipient: to,\r\n                deadline: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function _zapFromWETH(\r\n        uint256 minOut,\r\n        uint256 finalAmt,\r\n        uint256 flag,\r\n        address to\r\n    ) internal returns (uint256 tokenId) {\r\n        unchecked {\r\n            uint256 startTickDeviation = YIELD_VAULT.getStartTickDeviation(\r\n                YIELD_VAULT.getCurrentTick()\r\n            );\r\n\r\n            uint256 gotTokens;\r\n\r\n            uint256 deviationAmt = YIELD_VAULT.getDeviation(\r\n                finalAmt,\r\n                startTickDeviation\r\n            );\r\n            gotTokens = IRouterV3(v3Router).exactInputSingle(\r\n                IRouterV3.ExactInputSingleParams({\r\n                    tokenIn: WETH,\r\n                    tokenOut: address(this),\r\n                    fee: 10000,\r\n                    recipient: address(this),\r\n                    deadline: block.timestamp,\r\n                    amountIn: deviationAmt,\r\n                    amountOutMinimum: minOut,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            );\r\n            finalAmt -= deviationAmt;\r\n            uint256 a1Out;\r\n            (tokenId, deviationAmt, a1Out) = _mintPosition(\r\n                finalAmt,\r\n                gotTokens,\r\n                flag,\r\n                to\r\n            );\r\n\r\n            if (a1Out > gotTokens) revert MinMax();\r\n            if (deviationAmt > finalAmt) revert MinMax();\r\n\r\n            address sendToken = WETH;\r\n            assembly {\r\n                let refundAmtWETH := sub(finalAmt, deviationAmt)\r\n                if gt(refundAmtWETH, 100000000000000) {\r\n                    let inputMem := mload(0x40)\r\n                    mstore(\r\n                        inputMem,\r\n                        0xa9059cbb00000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(inputMem, 0x04), to)\r\n                    mstore(add(inputMem, 0x24), refundAmtWETH)\r\n                    pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\r\n                }\r\n            }\r\n\r\n            if (gotTokens - a1Out >= 1e18)\r\n                _basicTransfer(address(this), to, gotTokens - a1Out);\r\n\r\n            emit zapIn(to, tokenId, flag, deviationAmt, gotTokens);\r\n        }\r\n    }\r\n\r\n    function zapFromETH(\r\n        uint256 minOut,\r\n        address to,\r\n        uint256 flag,\r\n        address upper\r\n    ) external payable returns (uint256 tokenId) {\r\n        address _d = address(YIELD_BOOSTER);\r\n        address cUpper = upperRef[tx.origin];\r\n        //handle referrals\r\n        {\r\n            if (\r\n                upper != tx.origin &&\r\n                cUpper == address(0) &&\r\n                upper != address(0)\r\n            ) {\r\n                upperRef[tx.origin] = upper;\r\n            }\r\n            if (upperRef[tx.origin] == address(0)) {\r\n                cUpper = _d;\r\n            } else {\r\n                cUpper = upperRef[tx.origin];\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            uint256 finalAmt = msg.value;\r\n            uint256 forReferral = finalAmt / 100; //1%\r\n            finalAmt -= (forReferral * 3); //3% taxx\r\n            address sendToken = WETH;\r\n            assembly {\r\n                if eq(_d, cUpper) {\r\n                    pop(call(10000, _d, mul(forReferral, 3), \"\", 0, 0, 0))\r\n                }\r\n\r\n                if not(eq(_d, cUpper)) {\r\n                    pop(call(10000, _d, mul(forReferral, 2), \"\", 0, 0, 0))\r\n                    pop(call(10000, cUpper, forReferral, \"\", 0, 0, 0))\r\n                }\r\n\r\n                let inputMem := mload(0x40)\r\n                //wrap eth\r\n                mstore(inputMem, 0xd0e30db)\r\n                pop(call(gas(), sendToken, finalAmt, inputMem, 0x4, 0, 0))\r\n            }\r\n\r\n            emit referralPaid(to, cUpper, forReferral);\r\n            return _zapFromWETH(minOut, finalAmt, flag, to);\r\n        }\r\n    }\r\n\r\n    //Protocol FUNCTIONS\r\n    function adjustFomo(\r\n        uint16 flag,\r\n        uint256 amount,\r\n        address who\r\n    ) external {\r\n        if (flag == 5) {\r\n            //prevent liquidity fragmentation\r\n            if (msg.sender != address(YIELD_BOOSTER)) revert Auth();\r\n            require(IV3Pool(who).token0() != address(0)); //will revert if non-pair contract\r\n            require(who != uniswapV3Pool);\r\n            badPool[who] = !badPool[who];\r\n        } else {\r\n            if (msg.sender != multiSig) revert Auth();\r\n\r\n            if (flag == 0) {\r\n                //Shutdown tokenomics [emergency only!]\r\n                require(amount == 0 || amount == 1);\r\n                tokenomicsOn = uint8(amount);\r\n            } else if (flag == 1) {\r\n                //Change issuance rate\r\n                require(amount <= 100e18);\r\n                issuanceRate = uint80(amount);\r\n            } else if (flag == 2) {\r\n                //Exclude from tax\r\n                require(who != address(this) && who != uniswapV3Pool);\r\n                isTaxExcluded[who] = !isTaxExcluded[who];\r\n            } else if (flag == 3) {\r\n                //New YIELD_VAULT implementation\r\n                positionManager.setApprovalForAll(address(YIELD_VAULT), false);\r\n                YIELD_VAULT = YieldVault(who);\r\n                positionManager.setApprovalForAll(address(who), true);\r\n                isTaxExcluded[who] = true;\r\n                _allowances[who][address(positionManager)] = type(uint256).max;\r\n            } else if (flag == 4) {\r\n                //Unlock LP\r\n                require(block.timestamp >= startStamp + (1 days * 30 * 4));\r\n                positionManager.transferFrom(address(this), multiSig, amount);\r\n            } else if (flag == 5) {\r\n                //new Yield Booster implementation\r\n                YIELD_BOOSTER = YieldBooster(who);\r\n                isTaxExcluded[who] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //GETTERS\r\n    function getIsTaxExcluded(address who) external view returns (bool) {\r\n        return isTaxExcluded[who];\r\n    }\r\n\r\n    function getUpperRef(address who) external view returns (address) {\r\n        return upperRef[who];\r\n    }\r\n\r\n    function getYieldBooster() external view returns (address yb) {\r\n        return address(YIELD_BOOSTER);\r\n    }\r\n\r\n    function MAX_SUPPLY() external view returns (uint256) {\r\n        return _MAX_SUPPLY;\r\n    }\r\n\r\n    function cap() external view returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    function getV3Pool() external view returns (address pool) {\r\n        pool = uniswapV3Pool;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_apest\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tickMaths\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Auth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Sando\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"referralPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtETHIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtTokensIn\",\"type\":\"uint256\"}],\"name\":\"zapIn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"flag\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"adjustFomo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getIsTaxExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getUpperRef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getV3Pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYieldBooster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"yb\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"yieldVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yieldBooster\",\"type\":\"address\"}],\"name\":\"prepareFomo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preparePool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upper\",\"type\":\"address\"}],\"name\":\"zapFromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"zapFromV3LPToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdNew\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChainToolsV2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "42000", "ConstructorArguments": "000000000000000000000000633347e08e48901b3c2f4200884a1feddac5195600000000000000000000000002d30a0c5790e03016165f851994093656a57aef", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fb8badff437aa9a7dd33288b7e2a376e3b0985736d5275e9fb693176c26504db"}