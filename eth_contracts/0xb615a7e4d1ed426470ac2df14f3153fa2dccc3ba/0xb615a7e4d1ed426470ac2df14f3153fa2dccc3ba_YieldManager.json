{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/yield/YieldManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\n/// Core /////\\nimport {YieldTokenFactory} from \\\"./YieldTokenFactory.sol\\\";\\nimport {YieldToken} from \\\"./YieldToken.sol\\\";\\nimport {sTRSY} from \\\"./sTRSY.sol\\\";\\nimport {UserRequest} from \\\"src/core/Structs.sol\\\";\\n\\n/// Utils /////\\nimport {Ownable} from \\\"src/utils/Ownable.sol\\\";\\n\\n/// Interfaces /////\\nimport {IRelayerV2} from \\\"src/interfaces/IRelayerV2.sol\\\";\\nimport {IOracle} from \\\"src/interfaces/IOracle.sol\\\";\\nimport {ITaxModule} from \\\"src/interfaces/ITaxModule.sol\\\";\\nimport {IERC20} from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IDSRManager} from \\\"./IDSRManager.sol\\\";\\n\\nimport {StructGen} from \\\"./StructGen.sol\\\";\\n\\nimport {ERC1967Proxy} from \\\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\ncontract YieldManager is YieldTokenFactory, Ownable, StructGen, ERC1967Proxy {\\n  mapping(address token => address yieldToken) public tokenToYieldToken;\\n  IRelayerV2 public relayer;\\n  IOracle public oracle;\\n  ITaxModule public taxModule;\\n  sTRSY public sTrsy;\\n  IERC20 public trsy;\\n\\n  error NoYieldTokenExists();\\n\\n  constructor(\\n    address _fyde,\\n    address _relayer,\\n    address _oracle,\\n    address _taxModule,\\n    address _sTrsy,\\n    address _stratgies\\n  ) YieldTokenFactory(_fyde, _relayer) Ownable(msg.sender) ERC1967Proxy(_stratgies, \\\"\\\") {\\n    relayer = IRelayerV2(_relayer);\\n    oracle = IOracle(_oracle);\\n    taxModule = ITaxModule(_taxModule);\\n    trsy = IERC20(_fyde);\\n    sTrsy = sTRSY(_sTrsy);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             PROXY SECTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function getStrategiesContract() public view returns (address) {\\n    return _implementation();\\n  }\\n\\n  fallback() external payable override onlyOwner {\\n    _fallback();\\n  }\\n\\n  // override receive fallback to remove entry point\\n  receive() external payable override {}\\n\\n  function upgradeStrategiesContract(address _newImplementation) external onlyOwner {\\n    _upgradeTo(_newImplementation);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             ADMIN SECTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Set the relayer address\\n  ///@param _relayer The new relayer address\\n  function setRelayer(address _relayer) external onlyOwner {\\n    relayer = IRelayerV2(_relayer);\\n  }\\n\\n  ///@notice Set the oracle address\\n  ///@param _oracle The new oracle address\\n  function setOracle(address _oracle) external onlyOwner {\\n    oracle = IOracle(_oracle);\\n  }\\n\\n  ///@notice Set the tax module address\\n  ///@param _taxModule The new tax module address\\n  function setTaxModule(address _taxModule) external onlyOwner {\\n    taxModule = ITaxModule(_taxModule);\\n  }\\n\\n  ///@notice Creates a new yield token for a given asset\\n  ///@param _asset The address of the asset for which to create a yield token\\n  function createYieldToken(address _asset) external onlyOwner {\\n    string memory name = string.concat(\\\"yield-\\\", IERC20Metadata(_asset).symbol());\\n    address yToken = _createYieldToken(name, name, IERC20Metadata(_asset).decimals());\\n    tokenToYieldToken[_asset] = yToken;\\n    oracle.registerYieldToken(_asset, yToken);\\n    taxModule.registerYieldToken(_asset, yToken);\\n  }\\n\\n  function moveAssetToYieldManager(address _asset, uint256 _amount) external onlyOwner {\\n    if (tokenToYieldToken[_asset] == address(0x0)) revert NoYieldTokenExists();\\n    YieldToken yToken = YieldToken(tokenToYieldToken[_asset]);\\n    yToken.mint(_amount);\\n    yToken.approve(address(relayer), _amount);\\n    relayer.swap(address(yToken), _amount, _asset, 0);\\n  }\\n\\n  function moveAssetToLiquidVault(address _asset, uint256 _amount) external onlyOwner {\\n    // this assume always 1:1 exchange rate for now\\n    address yToken = tokenToYieldToken[_asset];\\n    IERC20(_asset).approve(address(relayer), _amount);\\n    uint256 balBefore = IERC20(yToken).balanceOf(address(this));\\n    relayer.swap(_asset, _amount, yToken, 0);\\n    uint256 balAfter = IERC20(yToken).balanceOf(address(this));\\n    YieldToken(yToken).burn(balAfter - balBefore);\\n  }\\n\\n  function depositYieldIntoLiquidVault(address _asset, uint256 _amount) external onlyOwner {\\n    IERC20(_asset).approve(address(relayer), _amount);\\n    UserRequest[] memory req = new UserRequest[](1);\\n    req[0].asset = _asset;\\n    req[0].amount = _amount;\\n    require(taxModule.taxFactorDeposit() == 0, \\\"Deposit Tax Factor not zero\\\");\\n    relayer.deposit(req, false, 0);\\n  }\\n\\n  function distributeYieldToStrsy(uint256 _amount) external onlyOwner {\\n    trsy.transfer(address(sTrsy), _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/yield/YieldTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\n/// Core /////\\nimport {YieldToken} from \\\"./YieldToken.sol\\\";\\n\\n/// Utils /////\\nimport {Clones} from \\\"openzeppelin-contracts/proxy/Clones.sol\\\";\\n\\n///@title  YieldTokenFactory\\n///@notice Factory to deploy yieldtoken\\nabstract contract YieldTokenFactory {\\n  address public immutable TOKEN_IMPLEMENTATION;\\n\\n  constructor(address _fyde, address _relayer) {\\n    TOKEN_IMPLEMENTATION = address(new YieldToken(address(this), _fyde, _relayer, msg.sender));\\n  }\\n\\n  function _createYieldToken(string memory _name, string memory _symbol, uint8 decimals)\\n    internal\\n    returns (address)\\n  {\\n    address clone = Clones.clone(TOKEN_IMPLEMENTATION);\\n    YieldToken(clone).initialize(_name, _symbol, decimals);\\n    return clone;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/yield/YieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\n/// Utils /////\\nimport {ERC20Upgradeable} from\\n  \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport {Ownable} from \\\"src/utils/Ownable.sol\\\";\\n\\ncontract YieldToken is ERC20Upgradeable, Ownable {\\n  /*//////////////////////////////////////////////////////////////\\n                              STORAGE\\n  //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Yield Manager can mint and burn\\n  address public yieldManager;\\n\\n  ///@notice Fyde contract\\n  address private immutable FYDE;\\n\\n  ///@notice Relayer contract\\n  address public relayer;\\n\\n  ///@notice Address of the yield token\\n  IYieldToken public immutable BASEYIELDTOKEN;\\n\\n  uint8 private _decimals;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                              STORAGE\\n  //////////////////////////////////////////////////////////////*/\\n\\n  error NonWithdrawableYieldToken();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                           INITIALIZATION\\n  //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Constructor of the yieldToken template\\n  ///@param _yieldManager Yield Manager\\n  constructor(address _yieldManager, address _fyde, address _relayer, address _owner)\\n    Ownable(_owner)\\n  {\\n    yieldManager = _yieldManager;\\n    FYDE = _fyde;\\n    relayer = _relayer;\\n    BASEYIELDTOKEN = IYieldToken(address(this));\\n  }\\n\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  ///@notice Initializer for state variables that are different for each clone\\n  ///@param  _name Name of the yield token\\n  ///@param  _symbol Symbol of the yield token\\n  function initialize(string memory _name, string memory _symbol, uint8 _dec) public initializer {\\n    __ERC20_init(_name, _symbol);\\n    _decimals = _dec;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                         AUTHORIZED EXTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Getter for yieldManager address\\n  function getYieldManager() public view returns (address) {\\n    return BASEYIELDTOKEN.yieldManager();\\n  }\\n\\n  ///@notice Setter for yieldManager address\\n  function setYieldManager(address _yieldManager) public onlyOwner {\\n    yieldManager = _yieldManager;\\n  }\\n\\n  ///@notice Getter for fyde address\\n  function getFyde() public view returns (address) {\\n    return FYDE;\\n  }\\n\\n  ///@notice Getter for relayer address\\n  function getRelayer() public view returns (address) {\\n    return BASEYIELDTOKEN.relayer();\\n  }\\n\\n  ///@notice Setter for relayer address\\n  function setRelayer(address _relayer) public onlyOwner {\\n    relayer = _relayer;\\n  }\\n\\n  ///@notice Mint yield token to yield manager\\n  ///@param _amount Amount to be minted\\n  function mint(uint256 _amount) external onlyYieldManager {\\n    _mint(getYieldManager(), _amount);\\n  }\\n\\n  ///@notice Burn yield token from yield manager\\n  ///@param _amount Amount to be burned\\n  function burn(uint256 _amount) external onlyYieldManager {\\n    _burn(getYieldManager(), _amount);\\n  }\\n\\n  function _beforeTokenTransfer(address _from, address _to, uint256) internal view override {\\n    if (\\n      _from != address(0x0) && _to != address(0x0) && _to != getRelayer() && _to != getFyde()\\n        && _to != getYieldManager()\\n    ) revert NonWithdrawableYieldToken();\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                              MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  modifier onlyYieldManager() {\\n    if (msg.sender != getYieldManager()) revert Unauthorized();\\n    _;\\n  }\\n}\\n\\ninterface IYieldToken {\\n  ///@notice Getter for relayer address\\n  function relayer() external view returns (address);\\n\\n  ///@notice Getter for yieldManager address\\n  function yieldManager() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/yield/sTRSY.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/// Utils /////\\nimport {RevenueDistributionToken} from \\\"./revenueDistributionToken/RevenueDistributionToken.sol\\\";\\nimport {IRewardsDistributor} from \\\"./IRewardsDistributor.sol\\\";\\n\\ncontract sTRSY is RevenueDistributionToken {\\n  IRewardsDistributor public distributor;\\n\\n  constructor(address _asset)\\n    RevenueDistributionToken(\\\"staked TRSY\\\", \\\"sTRSY\\\", msg.sender, _asset, 1e27)\\n  {}\\n\\n  function setRewardsDistributor(address _distributor) external {\\n    require(msg.sender == owner, \\\"RDT:SPO:NOT_OWNER\\\");\\n    distributor = IRewardsDistributor(_distributor);\\n  }\\n\\n  function _afterTokenTransfer(address from, address to, uint256) internal override {\\n    distributor.updateAccounting(from, to);\\n  }\\n\\n  function _getRewardsDistributor() internal view override returns (IRewardsDistributor) {\\n    return distributor;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/core/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nstruct AssetInfo {\\n  uint72 targetConcentration;\\n  address uniswapPool;\\n  int72 incentiveFactor;\\n  uint8 assetDecimals;\\n  uint8 quoteTokenDecimals;\\n  address uniswapQuoteToken;\\n  bool isSupported;\\n}\\n\\nstruct ProtocolData {\\n  ///@notice Protocol AUM in USD\\n  uint256 aum;\\n  ///@notice multiplicator for the tax equation, 100% = 100e18\\n  uint72 taxFactor;\\n  ///@notice Max deviation allowed between AUM from keeper and registry\\n  uint16 maxAumDeviationAllowed; // Default val 200 == 2 %\\n  ///@notice block number where AUM was last updated\\n  uint48 lastAUMUpdateBlock;\\n  ///@notice annual fee on AUM, in % per year 100% = 100e18\\n  uint72 managementFee;\\n  ///@notice last block.timestamp when fee was collected\\n  uint48 lastFeeCollectionTime;\\n}\\n\\nstruct UserRequest {\\n  address asset;\\n  uint256 amount;\\n}\\n\\nstruct RequestData {\\n  uint32 id;\\n  address requestor;\\n  address[] assetIn;\\n  uint256[] amountIn;\\n  address[] assetOut;\\n  uint256[] amountOut;\\n  bool keepGovRights;\\n  uint256 slippageChecker;\\n}\\n\\nstruct RequestQ {\\n  uint64 start;\\n  uint64 end;\\n  mapping(uint64 => RequestData) requestData;\\n}\\n\\nstruct ProcessParam {\\n  uint256 targetConc;\\n  uint256 currentConc;\\n  uint256 usdValue;\\n  uint256 taxableAmount;\\n  uint256 taxInUSD;\\n  uint256 sharesBeforeTax;\\n  uint256 sharesAfterTax;\\n}\\n\\nstruct RebalanceParam {\\n  address asset;\\n  uint256 assetTotalAmount;\\n  uint256 assetProxyAmount;\\n  uint256 assetPrice;\\n  uint256 sTrsyTotalSupply;\\n  uint256 trsyPrice;\\n}\\n\"\r\n    },\r\n    \"src/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\n///@title Ownable contract\\n/// @notice Simple 2step owner authorization combining solmate and OZ implementation\\nabstract contract Ownable {\\n  /*//////////////////////////////////////////////////////////////\\n                             STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Address of the owner\\n  address public owner;\\n\\n  ///@notice Address of the pending owner\\n  address public pendingOwner;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event OwnershipTransferred(address indexed user, address indexed newOner);\\n  event OwnershipTransferStarted(address indexed user, address indexed newOwner);\\n  event OwnershipTransferCanceled(address indexed pendingOwner);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 ERROR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  error Unauthorized();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  constructor(address _owner) {\\n    owner = _owner;\\n\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Transfer ownership to a new address\\n  ///@param newOwner address of the new owner\\n  ///@dev newOwner have to acceptOwnership\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(msg.sender, pendingOwner);\\n  }\\n\\n  ///@notice NewOwner accept the ownership, it transfer the ownership to newOwner\\n  function acceptOwnership() external {\\n    if (msg.sender != pendingOwner) revert Unauthorized();\\n    address oldOwner = owner;\\n    owner = pendingOwner;\\n    delete pendingOwner;\\n    emit OwnershipTransferred(oldOwner, owner);\\n  }\\n\\n  ///@notice Cancel the ownership transfer\\n  function cancelTransferOwnership() external onlyOwner {\\n    emit OwnershipTransferCanceled(pendingOwner);\\n    delete pendingOwner;\\n  }\\n\\n  modifier onlyOwner() {\\n    if (msg.sender != owner) revert Unauthorized();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRelayerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {UserRequest} from \\\"../core/Structs.sol\\\";\\n\\ninterface IRelayerV2 {\\n  function governanceWithdraw(UserRequest memory _userRequest, address _user, uint256 _maxTRSYToPay)\\n    external\\n    payable;\\n\\n  function withdraw(UserRequest[] memory _userRequest, uint256 _maxTRSYToPay) external payable;\\n\\n  function deposit(UserRequest[] memory _userRequest, bool _keepGovRights, uint256 _minTRSYExpected)\\n    external\\n    payable;\\n\\n  function swap(address _assetIn, uint256 _amountIn, address _assetOut, uint256 _minAmountOut)\\n    external\\n    payable;\\n\\n  function isQuarantined(address _asset) external view returns (bool);\\n\\n  function isIncentiveManager(address _incentiveManager) external view returns (bool);\\n\\n  function isUser(address _asset) external view returns (bool);\\n\\n  function isAnyQuarantined(address[] memory _assets) external view returns (address);\\n\\n  function deviationThreshold() external view returns (uint16);\\n\\n  function pauseProtocol() external;\\n\\n  function updateProtocolAUM(uint256 nAum) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {AssetInfo} from \\\"../core/Structs.sol\\\";\\n\\ninterface IOracle {\\n  function getPriceInUSD(address, AssetInfo calldata) external view returns (uint256);\\n\\n  function getGweiPrice() external view returns (uint256);\\n\\n  function registerYieldToken(address _baseToken, address _yieldToken) external;\\n\\n  function useCache(address[] calldata addr, AssetInfo[] calldata assetInfo) external;\\n\\n  function disableCache() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITaxModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {RequestData, ProcessParam} from \\\"src/core/Structs.sol\\\";\\n\\ninterface ITaxModule {\\n  function getProcessParamDeposit(RequestData memory _req, uint256 _protocolAUM)\\n    external\\n    view\\n    returns (\\n      ProcessParam[] memory processParam,\\n      uint256 sharesToMint,\\n      uint256 taxInTRSY,\\n      uint256 totalUsdDeposit\\n    );\\n\\n  function getProcessParamWithdraw(RequestData calldata _req, uint256 _protocolAUM)\\n    external\\n    view\\n    returns (\\n      ProcessParam[] memory processParam,\\n      uint256 totalSharesToBurn,\\n      uint256 sharesToBurnBeforeTax,\\n      uint256 taxInTRSY,\\n      uint256 totalUsdWithdraw\\n    );\\n\\n  function getSwapAmountOut(\\n    address _assetIn,\\n    uint256 _amountIn,\\n    address _assetOut,\\n    uint256 _protocolAUM\\n  ) external view returns (uint256, int256);\\n\\n  function setYieldManager(address _yieldManager) external;\\n\\n  function registerYieldToken(address _baseToken, address _yieldToken) external;\\n\\n  function taxFactorDeposit() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/yield/IDSRManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\ninterface IDSRManager {\\n  function join(address dst, uint256 amount) external;\\n\\n  function exit(address dst, uint256 wad) external;\\n\\n  function exitAll(address dst) external;\\n\\n  function daiBalance(address usr) external returns (uint256 wad);\\n}\\n\"\r\n    },\r\n    \"src/yield/StructGen.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nimport \\\"lib/pendle-core-v2-public/contracts/interfaces/IPAllActionV3.sol\\\";\\nimport \\\"lib/pendle-core-v2-public/contracts/interfaces/IPMarket.sol\\\";\\n\\nabstract contract StructGen {\\n  function _defaultApprox() internal pure returns (ApproxParams memory) {\\n    return ApproxParams(0, type(uint256).max, 0, 256, 1e14);\\n  }\\n\\n  function _emptyLimit() internal pure returns (LimitOrderData memory) {\\n    LimitOrderData memory limitOrderData;\\n    return limitOrderData;\\n  }\\n\\n  function _emptySwap() internal pure returns (SwapData memory) {\\n    SwapData memory swapData;\\n    return swapData;\\n  }\\n\\n  /// @notice create a simple TokenInput struct without using any aggregators. For more info please\\n  /// refer to\\n  /// IPAllActionTypeV3.sol\\n  function _createTokenInputStruct(address tokenIn, uint256 netTokenIn)\\n    internal\\n    pure\\n    returns (TokenInput memory)\\n  {\\n    return TokenInput({\\n      tokenIn: tokenIn,\\n      netTokenIn: netTokenIn,\\n      tokenMintSy: tokenIn,\\n      pendleSwap: address(0),\\n      swapData: _emptySwap()\\n    });\\n  }\\n\\n  /// @notice create a simple TokenOutput struct without using any aggregators. For more info please\\n  /// refer to\\n  /// IPAllActionTypeV3.sol\\n  function _createTokenOutputStruct(address tokenOut, uint256 minTokenOut)\\n    internal\\n    pure\\n    returns (TokenOutput memory)\\n  {\\n    return TokenOutput({\\n      tokenOut: tokenOut,\\n      minTokenOut: minTokenOut,\\n      tokenRedeemSy: tokenOut,\\n      pendleSwap: address(0),\\n      swapData: _emptySwap()\\n    });\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/RevenueDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\nimport {ERC20Helper} from \\\"./ERC20Helper.sol\\\";\\n\\nimport {IRevenueDistributionToken} from \\\"./IRevenueDistributionToken.sol\\\";\\nimport {IRewardsDistributor} from \\\"../IRewardsDistributor.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551\\n    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d\\n*/\\n\\nabstract contract RevenueDistributionToken is IRevenueDistributionToken, ERC20 {\\n  uint256 public immutable override PRECISION; // Precision of rates, equals max deposit amounts\\n    // before rounding errors occur\\n\\n  address public override asset; // Underlying ERC-20 asset used by ERC-4626 functionality.\\n\\n  address public override owner; // Current owner of the contract, able to update the vesting\\n    // schedule.\\n  address public override pendingOwner; // Pending owner of the contract, able to accept ownership.\\n\\n  uint256 public override freeAssets; // Amount of assets unlocked regardless of time passed.\\n  uint256 public override issuanceRate; // asset/second rate dependent on aggregate vesting\\n    // schedule.\\n  uint256 public override lastUpdated; // Timestamp of when issuance equation was last updated.\\n  uint256 public override vestingPeriodFinish; // Timestamp when current vesting schedule ends.\\n\\n  uint256 private locked = 1; // Used in reentrancy check.\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Modifiers **\\n   */\\n  /**\\n   *\\n   */\\n  modifier nonReentrant() {\\n    require(locked == 1, \\\"RDT:LOCKED\\\");\\n\\n    locked = 2;\\n\\n    _;\\n\\n    locked = 1;\\n  }\\n\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    address owner_,\\n    address asset_,\\n    uint256 precision_\\n  ) ERC20(name_, symbol_, ERC20(asset_).decimals()) {\\n    require((owner = owner_) != address(0), \\\"RDT:C:OWNER_ZERO_ADDRESS\\\");\\n\\n    asset = asset_; // Don't need to check zero address as ERC20(asset_).decimals() will fail in\\n      // ERC20 constructor.\\n    PRECISION = precision_;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Administrative Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function acceptOwnership() external virtual override {\\n    require(msg.sender == pendingOwner, \\\"RDT:AO:NOT_PO\\\");\\n\\n    emit OwnershipAccepted(owner, msg.sender);\\n\\n    owner = msg.sender;\\n    pendingOwner = address(0);\\n  }\\n\\n  function setPendingOwner(address pendingOwner_) external virtual override {\\n    require(msg.sender == owner, \\\"RDT:SPO:NOT_OWNER\\\");\\n\\n    pendingOwner = pendingOwner_;\\n\\n    emit PendingOwnerSet(msg.sender, pendingOwner_);\\n  }\\n\\n  function updateVestingSchedule(uint256 vestingPeriod_)\\n    external\\n    virtual\\n    override\\n    returns (uint256 issuanceRate_, uint256 freeAssets_)\\n  {\\n    require(msg.sender == owner, \\\"RDT:UVS:NOT_OWNER\\\");\\n    require(totalSupply != 0, \\\"RDT:UVS:ZERO_SUPPLY\\\");\\n\\n    // Update \\\"y-intercept\\\" to reflect current available asset.\\n    freeAssets_ = freeAssets = totalAssets();\\n\\n    // Calculate slope.\\n    issuanceRate_ = issuanceRate =\\n      ((ERC20(asset).balanceOf(address(this)) - freeAssets_) * PRECISION) / vestingPeriod_;\\n\\n    // Update timestamp and period finish.\\n    vestingPeriodFinish = (lastUpdated = block.timestamp) + vestingPeriod_;\\n\\n    emit IssuanceParamsUpdated(freeAssets_, issuanceRate_);\\n    emit VestingScheduleUpdated(msg.sender, vestingPeriodFinish);\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Staker Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function deposit(uint256 assets_, address receiver_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 shares_)\\n  {\\n    _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\\n  }\\n\\n  function depositWithPermit(\\n    uint256 assets_,\\n    address receiver_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external virtual override nonReentrant returns (uint256 shares_) {\\n    ERC20(asset).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\\n    _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\\n  }\\n\\n  function mint(uint256 shares_, address receiver_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 assets_)\\n  {\\n    _mint(shares_, assets_ = previewMint(shares_), receiver_, msg.sender);\\n  }\\n\\n  function mintWithPermit(\\n    uint256 shares_,\\n    address receiver_,\\n    uint256 maxAssets_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external virtual override nonReentrant returns (uint256 assets_) {\\n    require((assets_ = previewMint(shares_)) <= maxAssets_, \\\"RDT:MWP:INSUFFICIENT_PERMIT\\\");\\n\\n    ERC20(asset).permit(msg.sender, address(this), maxAssets_, deadline_, v_, r_, s_);\\n    _mint(shares_, assets_, receiver_, msg.sender);\\n  }\\n\\n  function redeem(uint256 shares_, address receiver_, address owner_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 assets_)\\n  {\\n    _burn(shares_, assets_ = previewRedeem(shares_), receiver_, owner_, msg.sender);\\n  }\\n\\n  function withdraw(uint256 assets_, address receiver_, address owner_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 shares_)\\n  {\\n    _burn(shares_ = previewWithdraw(assets_), assets_, receiver_, owner_, msg.sender);\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _mint(uint256 shares_, uint256 assets_, address receiver_, address caller_) internal {\\n    require(receiver_ != address(0), \\\"RDT:M:ZERO_RECEIVER\\\");\\n    require(shares_ != uint256(0), \\\"RDT:M:ZERO_SHARES\\\");\\n    require(assets_ != uint256(0), \\\"RDT:M:ZERO_ASSETS\\\");\\n\\n    _mint(receiver_, shares_);\\n\\n    uint256 freeAssetsCache = freeAssets = totalAssets() + assets_;\\n\\n    uint256 issuanceRate_ = _updateIssuanceParams();\\n\\n    emit Deposit(caller_, receiver_, assets_, shares_);\\n    emit IssuanceParamsUpdated(freeAssetsCache, issuanceRate_);\\n\\n    require(ERC20Helper.transferFrom(asset, caller_, address(this), assets_), \\\"RDT:M:TRANSFER_FROM\\\");\\n    _activateFydeEmissions(receiver_);\\n  }\\n\\n  function _burn(\\n    uint256 shares_,\\n    uint256 assets_,\\n    address receiver_,\\n    address owner_,\\n    address caller_\\n  ) internal {\\n    require(receiver_ != address(0), \\\"RDT:B:ZERO_RECEIVER\\\");\\n    require(shares_ != uint256(0), \\\"RDT:B:ZERO_SHARES\\\");\\n    require(assets_ != uint256(0), \\\"RDT:B:ZERO_ASSETS\\\");\\n\\n    if (caller_ != owner_) _decreaseAllowance(owner_, caller_, shares_);\\n\\n    _burn(owner_, shares_);\\n\\n    uint256 freeAssetsCache = freeAssets = totalAssets() - assets_;\\n\\n    uint256 issuanceRate_ = _updateIssuanceParams();\\n\\n    emit Withdraw(caller_, receiver_, owner_, assets_, shares_);\\n    emit IssuanceParamsUpdated(freeAssetsCache, issuanceRate_);\\n\\n    require(ERC20Helper.transfer(asset, receiver_, assets_), \\\"RDT:B:TRANSFER\\\");\\n  }\\n\\n  function _updateIssuanceParams() internal returns (uint256 issuanceRate_) {\\n    return issuanceRate = (lastUpdated = block.timestamp) > vestingPeriodFinish ? 0 : issuanceRate;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function balanceOfAssets(address account_)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256 balanceOfAssets_)\\n  {\\n    return convertToAssets(balanceOf[account_]);\\n  }\\n\\n  function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply;\\n  }\\n\\n  function convertToShares(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    shares_ = supply == 0 ? assets_ : (assets_ * supply) / totalAssets();\\n  }\\n\\n  function maxDeposit(address receiver_)\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (uint256 maxAssets_)\\n  {\\n    receiver_; // Silence warning\\n    maxAssets_ = type(uint256).max;\\n  }\\n\\n  function maxMint(address receiver_) external pure virtual override returns (uint256 maxShares_) {\\n    receiver_; // Silence warning\\n    maxShares_ = type(uint256).max;\\n  }\\n\\n  function maxRedeem(address owner_) external view virtual override returns (uint256 maxShares_) {\\n    maxShares_ = balanceOf[owner_];\\n  }\\n\\n  function maxWithdraw(address owner_) external view virtual override returns (uint256 maxAssets_) {\\n    maxAssets_ = balanceOfAssets(owner_);\\n  }\\n\\n  function previewDeposit(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round DOWN if it\u2019s calculating the amount of shares to issue to a user, given an\\n    // amount of assets provided.\\n    shares_ = convertToShares(assets_);\\n  }\\n\\n  function previewMint(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round UP if it\u2019s calculating the amount of assets a user must provide, to be\\n    // issued a given amount of shares.\\n    assets_ = supply == 0 ? shares_ : _divRoundUp(shares_ * totalAssets(), supply);\\n  }\\n\\n  function previewRedeem(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round DOWN if it\u2019s calculating the amount of assets to send to a user, given\\n    // amount of shares returned.\\n    assets_ = convertToAssets(shares_);\\n  }\\n\\n  function previewWithdraw(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round UP if it\u2019s calculating the amount of shares a user must return, to be sent\\n    // a given amount of assets.\\n    shares_ = supply == 0 ? assets_ : _divRoundUp(assets_ * supply, totalAssets());\\n  }\\n\\n  function totalAssets() public view virtual override returns (uint256 totalManagedAssets_) {\\n    uint256 issuanceRate_ = issuanceRate;\\n\\n    if (issuanceRate_ == 0) return freeAssets;\\n\\n    uint256 vestingPeriodFinish_ = vestingPeriodFinish;\\n    uint256 lastUpdated_ = lastUpdated;\\n\\n    uint256 vestingTimePassed = block.timestamp > vestingPeriodFinish_\\n      ? vestingPeriodFinish_ - lastUpdated_\\n      : block.timestamp - lastUpdated_;\\n\\n    return ((issuanceRate_ * vestingTimePassed) / PRECISION) + freeAssets;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _divRoundUp(uint256 numerator_, uint256 divisor_)\\n    internal\\n    pure\\n    returns (uint256 result_)\\n  {\\n    return (numerator_ / divisor_) + (numerator_ % divisor_ > 0 ? 1 : 0);\\n  }\\n\\n  function _activateFydeEmissions(address _user) internal {\\n    _getRewardsDistributor().activateFydeEmissions(_user);\\n  }\\n\\n  function _getRewardsDistributor() internal view virtual returns (IRewardsDistributor);\\n}\\n\"\r\n    },\r\n    \"src/yield/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\ninterface IRewardsDistributor {\\n  function updateAccounting(address _user1, address _user2) external;\\n  function activateFydeEmissions(address _user) external;\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPAllActionV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPActionAddRemoveLiqV3.sol\\\";\\nimport \\\"./IPActionSwapPTV3.sol\\\";\\nimport \\\"./IPActionSwapYTV3.sol\\\";\\nimport \\\"./IPActionMiscV3.sol\\\";\\nimport \\\"./IPActionCallbackV3.sol\\\";\\nimport \\\"./IPActionStorageV4.sol\\\";\\n\\ninterface IPAllActionV3 is\\n    IPActionAddRemoveLiqV3,\\n    IPActionSwapPTV3,\\n    IPActionSwapYTV3,\\n    IPActionMiscV3,\\n    IPActionCallbackV3,\\n    IPActionStorageV4\\n{}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./IPPrincipalToken.sol\\\";\\nimport \\\"./IPYieldToken.sol\\\";\\nimport \\\"./IStandardizedYield.sol\\\";\\nimport \\\"./IPGauge.sol\\\";\\nimport \\\"../core/Market/MarketMathCore.sol\\\";\\n\\ninterface IPMarket is IERC20Metadata, IPGauge {\\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\\n\\n    event Burn(\\n        address indexed receiverSy,\\n        address indexed receiverPt,\\n        uint256 netLpBurned,\\n        uint256 netSyOut,\\n        uint256 netPtOut\\n    );\\n\\n    event Swap(\\n        address indexed caller,\\n        address indexed receiver,\\n        int256 netPtOut,\\n        int256 netSyOut,\\n        uint256 netSyFee,\\n        uint256 netSyToReserve\\n    );\\n\\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\\n\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    function mint(\\n        address receiver,\\n        uint256 netSyDesired,\\n        uint256 netPtDesired\\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\\n\\n    function burn(\\n        address receiverSy,\\n        address receiverPt,\\n        uint256 netLpToBurn\\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\\n\\n    function swapExactPtForSy(\\n        address receiver,\\n        uint256 exactPtIn,\\n        bytes calldata data\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n\\n    function swapSyForExactPt(\\n        address receiver,\\n        uint256 exactPtOut,\\n        bytes calldata data\\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\\n\\n    function redeemRewards(address user) external returns (uint256[] memory);\\n\\n    function readState(address router) external view returns (MarketState memory market);\\n\\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\\n\\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\\n\\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\\n\\n    function getRewardTokens() external view returns (address[] memory);\\n\\n    function isExpired() external view returns (bool);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function observations(\\n        uint256 index\\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\\n\\n    function _storage()\\n        external\\n        view\\n        returns (\\n            int128 totalPt,\\n            int128 totalSy,\\n            uint96 lastLnImpliedRate,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551          \u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551         \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\\n*/\\n\\n/**\\n *  @title Modern ERC-20 implementation.\\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\\n */\\ncontract ERC20 is IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * ERC-20 **\\n   */\\n  /**\\n   *\\n   */\\n  string public override name;\\n  string public override symbol;\\n\\n  uint8 public override decimals;\\n\\n  uint256 public override totalSupply;\\n\\n  mapping(address => uint256) public override balanceOf;\\n\\n  mapping(address => mapping(address => uint256)) public override allowance;\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * ERC-2612 **\\n   */\\n  /**\\n   *\\n   */\\n\\n  // PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256\\n  // nonce,uint256 deadline)\\\");\\n  bytes32 public constant override PERMIT_TYPEHASH =\\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  mapping(address => uint256) public override nonces;\\n\\n  /**\\n   *  @param name_     The name of the token.\\n   *  @param symbol_   The symbol of the token.\\n   *  @param decimals_ The decimal precision used by the token.\\n   */\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n    decimals = decimals_;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * External Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function approve(address spender_, uint256 amount_) external override returns (bool success_) {\\n    _approve(msg.sender, spender_, amount_);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender_, uint256 subtractedAmount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _decreaseAllowance(msg.sender, spender_, subtractedAmount_);\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender_, uint256 addedAmount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\\n    return true;\\n  }\\n\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 amount_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external override {\\n    require(deadline_ >= block.timestamp, \\\"ERC20:P:EXPIRED\\\");\\n\\n    // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf),\\n    // defines\\n    // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.\\n    require(\\n      uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0)\\n        && (v_ == 27 || v_ == 28),\\n      \\\"ERC20:P:MALLEABLE\\\"\\n    );\\n\\n    // Nonce realistically cannot overflow.\\n    unchecked {\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR(),\\n          keccak256(\\n            abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_)\\n          )\\n        )\\n      );\\n\\n      address recoveredAddress = ecrecover(digest, v_, r_, s_);\\n\\n      require(recoveredAddress == owner_ && owner_ != address(0), \\\"ERC20:P:INVALID_SIGNATURE\\\");\\n    }\\n\\n    _approve(owner_, spender_, amount_);\\n  }\\n\\n  function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\\n    _transfer(msg.sender, recipient_, amount_);\\n    return true;\\n  }\\n\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _decreaseAllowance(owner_, msg.sender, amount_);\\n    _transfer(owner_, recipient_, amount_);\\n    return true;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function DOMAIN_SEPARATOR() public view override returns (bytes32 domainSeparator_) {\\n    return keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(name)),\\n        keccak256(bytes(\\\"1\\\")),\\n        block.chainid,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _approve(address owner_, address spender_, uint256 amount_) internal {\\n    emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\\n  }\\n\\n  function _burn(address owner_, uint256 amount_) internal {\\n    balanceOf[owner_] -= amount_;\\n\\n    // Cannot underflow because a user's balance will never be larger than the total supply.\\n    unchecked {\\n      totalSupply -= amount_;\\n    }\\n\\n    emit Transfer(owner_, address(0), amount_);\\n\\n    _afterTokenTransfer(owner_, address(0x0), amount_);\\n  }\\n\\n  function _decreaseAllowance(address owner_, address spender_, uint256 subtractedAmount_) internal {\\n    uint256 spenderAllowance = allowance[owner_][spender_]; // Cache to memory.\\n\\n    if (spenderAllowance != type(uint256).max) {\\n      _approve(owner_, spender_, spenderAllowance - subtractedAmount_);\\n    }\\n  }\\n\\n  function _mint(address recipient_, uint256 amount_) internal {\\n    totalSupply += amount_;\\n\\n    // Cannot overflow because totalSupply would first overflow in the statement above.\\n    unchecked {\\n      balanceOf[recipient_] += amount_;\\n    }\\n\\n    emit Transfer(address(0), recipient_, amount_);\\n\\n    _afterTokenTransfer(address(0x0), recipient_, amount_);\\n  }\\n\\n  function _transfer(address owner_, address recipient_, uint256 amount_) internal {\\n    balanceOf[owner_] -= amount_;\\n\\n    // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances ==\\n    // totalSupply.\\n    unchecked {\\n      balanceOf[recipient_] += amount_;\\n    }\\n\\n    emit Transfer(owner_, recipient_, amount_);\\n\\n    _afterTokenTransfer(owner_, recipient_, amount_);\\n  }\\n\\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/ERC20Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\nimport {IERC20Like} from \\\"./IERC20Like.sol\\\";\\n\\n/**\\n * @title Small Library to standardize erc20 token interactions.\\n */\\nlibrary ERC20Helper {\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\\n    return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\\n  }\\n\\n  function transferFrom(address token_, address from_, address to_, uint256 amount_)\\n    internal\\n    returns (bool success_)\\n  {\\n    return\\n      _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\\n  }\\n\\n  function approve(address token_, address spender_, uint256 amount_)\\n    internal\\n    returns (bool success_)\\n  {\\n    // If setting approval to zero fails, return false.\\n    if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) {\\n      return false;\\n    }\\n\\n    // If `amount_` is zero, return true as the previous step already did this.\\n    if (amount_ == uint256(0)) return true;\\n\\n    // Return the result of setting the approval to `amount_`.\\n    return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\\n  }\\n\\n  function _call(address token_, bytes memory data_) private returns (bool success_) {\\n    if (token_.code.length == uint256(0)) return false;\\n\\n    bytes memory returnData;\\n    (success_, returnData) = token_.call(data_);\\n\\n    return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IRevenueDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\nimport {IERC4626} from \\\"./IERC4626.sol\\\";\\n\\n/// @title A token that represents ownership of future revenues distributed linearly over time.\\ninterface IRevenueDistributionToken is IERC20, IERC4626 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   Issuance parameters have been updated after a `_mint` or `_burn`.\\n   *  @param freeAssets_   Resulting `freeAssets` (y-intercept) value after accounting update.\\n   *  @param issuanceRate_ The new issuance rate of `asset` until `vestingPeriodFinish_`.\\n   */\\n  event IssuanceParamsUpdated(uint256 freeAssets_, uint256 issuanceRate_);\\n\\n  /**\\n   *  @dev   `newOwner_` has accepted the transferral of RDT ownership from `previousOwner_`.\\n   *  @param previousOwner_ The previous RDT owner.\\n   *  @param newOwner_      The new RDT owner.\\n   */\\n  event OwnershipAccepted(address indexed previousOwner_, address indexed newOwner_);\\n\\n  /**\\n   *  @dev   `owner_` has set the new pending owner of RDT to `pendingOwner_`.\\n   *  @param owner_        The current RDT owner.\\n   *  @param pendingOwner_ The new pending RDT owner.\\n   */\\n  event PendingOwnerSet(address indexed owner_, address indexed pendingOwner_);\\n\\n  /**\\n   *  @dev   `owner_` has updated the RDT vesting schedule to end at `vestingPeriodFinish_`.\\n   *  @param owner_               The current RDT owner.\\n   *  @param vestingPeriodFinish_ When the unvested balance will finish vesting.\\n   */\\n  event VestingScheduleUpdated(address indexed owner_, uint256 vestingPeriodFinish_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Variables **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev The total amount of the underlying asset that is currently unlocked and is not\\n   * time-dependent.\\n   *       Analogous to the y-intercept in a linear function.\\n   */\\n  function freeAssets() external view returns (uint256 freeAssets_);\\n\\n  /**\\n   *  @dev The rate of issuance of the vesting schedule that is currently active.\\n   *       Denominated as the amount of underlying assets vesting per second.\\n   */\\n  function issuanceRate() external view returns (uint256 issuanceRate_);\\n\\n  /**\\n   *  @dev The timestamp of when the linear function was last recalculated.\\n   *       Analogous to t0 in a linear function.\\n   */\\n  function lastUpdated() external view returns (uint256 lastUpdated_);\\n\\n  /**\\n   *  @dev The address of the account that is allowed to update the vesting schedule.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   *  @dev The next owner, nominated by the current owner.\\n   */\\n  function pendingOwner() external view returns (address pendingOwner_);\\n\\n  /**\\n   *  @dev The precision at which the issuance rate is measured.\\n   */\\n  function PRECISION() external view returns (uint256 precision_);\\n\\n  /**\\n   *  @dev The end of the current vesting schedule.\\n   */\\n  function vestingPeriodFinish() external view returns (uint256 vestingPeriodFinish_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Administrative Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev Sets the pending owner as the new owner.\\n   *       Can be called only by the pending owner, and only after their nomination by the current\\n   * owner.\\n   */\\n  function acceptOwnership() external;\\n\\n  /**\\n   *  @dev   Sets a new address as the pending owner.\\n   *  @param pendingOwner_ The address of the next potential owner.\\n   */\\n  function setPendingOwner(address pendingOwner_) external;\\n\\n  /**\\n   *  @dev    Updates the current vesting formula based on the amount of total unvested funds in the\\n   * contract and the new `vestingPeriod_`.\\n   *  @param  vestingPeriod_ The amount of time over which all currently unaccounted underlying\\n   * assets will be vested over.\\n   *  @return issuanceRate_  The new issuance rate.\\n   *  @return freeAssets_    The new amount of underlying assets that are unlocked.\\n   */\\n  function updateVestingSchedule(uint256 vestingPeriod_)\\n    external\\n    returns (uint256 issuanceRate_, uint256 freeAssets_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Staker Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Does a ERC4626 `deposit` with a ERC-2612 `permit`.\\n   *  @param  assets_   The amount of `asset` to deposit.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @param  deadline_ The timestamp after which the `permit` signature is no longer valid.\\n   *  @param  v_        ECDSA signature v component.\\n   *  @param  r_        ECDSA signature r component.\\n   *  @param  s_        ECDSA signature s component.\\n   *  @return shares_   The amount of shares minted.\\n   */\\n  function depositWithPermit(\\n    uint256 assets_,\\n    address receiver_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Does a ERC4626 `mint` with a ERC-2612 `permit`.\\n   *  @param  shares_    The amount of `shares` to mint.\\n   *  @param  receiver_  The receiver of the shares.\\n   *  @param  maxAssets_ The maximum amount of assets that can be taken, as per the permit.\\n   *  @param  deadline_  The timestamp after which the `permit` signature is no longer valid.\\n   *  @param  v_         ECDSA signature v component.\\n   *  @param  r_         ECDSA signature r component.\\n   *  @param  s_         ECDSA signature s component.\\n   *  @return assets_    The amount of shares deposited.\\n   */\\n  function mintWithPermit(\\n    uint256 shares_,\\n    address receiver_,\\n    uint256 maxAssets_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external returns (uint256 assets_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Returns the amount of underlying assets owned by the specified account.\\n   *  @param  account_ Address of the account.\\n   *  @return assets_  Amount of assets owned.\\n   */\\n  function balanceOfAssets(address account_) external view returns (uint256 assets_);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionAddRemoveLiqV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"./IPAllActionTypeV3.sol\\\";\\n\\n/*\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n * NOTICE *\\n * Refer to https://docs.pendle.finance/Developers/Contracts/PendleRouter for more information on\\n * TokenInput, TokenOutput, ApproxParams, LimitOrderData\\n * It's recommended to use Pendle's Hosted SDK to generate the params\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n */\\n\\ninterface IPActionAddRemoveLiqV3 {\\n    event AddLiquidityDualSyAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyUsed,\\n        uint256 netPtUsed,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquidityDualTokenAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed tokenIn,\\n        address receiver,\\n        uint256 netTokenUsed,\\n        uint256 netPtUsed,\\n        uint256 netLpOut,\\n        uint256 netSyInterm\\n    );\\n\\n    event AddLiquiditySinglePt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netPtIn,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySingleSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyIn,\\n        uint256 netLpOut\\n    );\\n\\n    event AddLiquiditySingleToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netLpOut,\\n        uint256 netSyInterm\\n    );\\n\\n    event AddLiquiditySingleSyKeepYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netSyIn,\\n        uint256 netSyMintPy,\\n        uint256 netLpOut,\\n        uint256 netYtOut\\n    );\\n\\n    event AddLiquiditySingleTokenKeepYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netLpOut,\\n        uint256 netYtOut,\\n        uint256 netSyMintPy,\\n        uint256 netSyInterm\\n    );\\n\\n    event RemoveLiquidityDualSyAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut,\\n        uint256 netSyOut\\n    );\\n\\n    event RemoveLiquidityDualTokenAndPt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed tokenOut,\\n        address receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut,\\n        uint256 netTokenOut,\\n        uint256 netSyInterm\\n    );\\n\\n    event RemoveLiquiditySinglePt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netPtOut\\n    );\\n\\n    event RemoveLiquiditySingleSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        uint256 netLpToRemove,\\n        uint256 netSyOut\\n    );\\n\\n    event RemoveLiquiditySingleToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        uint256 netLpToRemove,\\n        uint256 netTokenOut,\\n        uint256 netSyInterm\\n    );\\n\\n    function addLiquidityDualTokenAndPt(\\n        address receiver,\\n        address market,\\n        TokenInput calldata input,\\n        uint256 netPtDesired,\\n        uint256 minLpOut\\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\\n\\n    function addLiquidityDualSyAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netSyDesired,\\n        uint256 netPtDesired,\\n        uint256 minLpOut\\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\\n\\n    function addLiquiditySinglePt(\\n        address receiver,\\n        address market,\\n        uint256 netPtIn,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtSwapToSy,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\\n\\n    function addLiquiditySingleToken(\\n        address receiver,\\n        address market,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtReceivedFromSy,\\n        TokenInput calldata input,\\n        LimitOrderData calldata limit\\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function addLiquiditySingleSy(\\n        address receiver,\\n        address market,\\n        uint256 netSyIn,\\n        uint256 minLpOut,\\n        ApproxParams calldata guessPtReceivedFromSy,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\\n\\n    function addLiquiditySingleTokenKeepYt(\\n        address receiver,\\n        address market,\\n        uint256 minLpOut,\\n        uint256 minYtOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\\n\\n    function addLiquiditySingleSyKeepYt(\\n        address receiver,\\n        address market,\\n        uint256 netSyIn,\\n        uint256 minLpOut,\\n        uint256 minYtOut\\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\\n\\n    function removeLiquidityDualTokenAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        TokenOutput calldata output,\\n        uint256 minPtOut\\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\\n\\n    function removeLiquidityDualSyAndPt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minSyOut,\\n        uint256 minPtOut\\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\\n\\n    function removeLiquiditySinglePt(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtReceivedFromSy,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n\\n    function removeLiquiditySingleToken(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        TokenOutput calldata output,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function removeLiquiditySingleSy(\\n        address receiver,\\n        address market,\\n        uint256 netLpToRemove,\\n        uint256 minSyOut,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionSwapPTV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"./IPAllActionTypeV3.sol\\\";\\n\\n/*\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n * NOTICE *\\n * Refer to https://docs.pendle.finance/Developers/Contracts/PendleRouter for more information on\\n * TokenInput, TokenOutput, ApproxParams, LimitOrderData\\n * It's recommended to use Pendle's Hosted SDK to generate the params\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n */\\n\\ninterface IPActionSwapPTV3 {\\n    event SwapPtAndSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netPtToAccount,\\n        int256 netSyToAccount\\n    );\\n\\n    event SwapPtAndToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        int256 netPtToAccount,\\n        int256 netTokenToAccount,\\n        uint256 netSyInterm\\n    );\\n\\n    function swapExactTokenForPt(\\n        address receiver,\\n        address market,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtOut,\\n        TokenInput calldata input,\\n        LimitOrderData calldata limit\\n    ) external payable returns (uint256 netPtOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function swapExactSyForPt(\\n        address receiver,\\n        address market,\\n        uint256 exactSyIn,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessPtOut,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n\\n    function swapExactPtForToken(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        TokenOutput calldata output,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function swapExactPtForSy(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        uint256 minSyOut,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionSwapYTV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"./IPAllActionTypeV3.sol\\\";\\n\\n/*\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n * NOTICE *\\n * Refer to https://docs.pendle.finance/Developers/Contracts/PendleRouter for more information on\\n * TokenInput, TokenOutput, ApproxParams, LimitOrderData\\n * It's recommended to use Pendle's Hosted SDK to generate the params\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n */\\n\\ninterface IPActionSwapYTV3 {\\n    event SwapYtAndSy(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netYtToAccount,\\n        int256 netSyToAccount\\n    );\\n\\n    event SwapYtAndToken(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed token,\\n        address receiver,\\n        int256 netYtToAccount,\\n        int256 netTokenToAccount,\\n        uint256 netSyInterm\\n    );\\n\\n    event SwapPtAndYt(\\n        address indexed caller,\\n        address indexed market,\\n        address indexed receiver,\\n        int256 netPtToAccount,\\n        int256 netYtToAccount\\n    );\\n\\n    function swapExactTokenForYt(\\n        address receiver,\\n        address market,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessYtOut,\\n        TokenInput calldata input,\\n        LimitOrderData calldata limit\\n    ) external payable returns (uint256 netYtOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function swapExactSyForYt(\\n        address receiver,\\n        address market,\\n        uint256 exactSyIn,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessYtOut,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\\n\\n    function swapExactYtForToken(\\n        address receiver,\\n        address market,\\n        uint256 exactYtIn,\\n        TokenOutput calldata output,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\\n\\n    function swapExactYtForSy(\\n        address receiver,\\n        address market,\\n        uint256 exactYtIn,\\n        uint256 minSyOut,\\n        LimitOrderData calldata limit\\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\\n\\n    function swapExactPtForYt(\\n        address receiver,\\n        address market,\\n        uint256 exactPtIn,\\n        uint256 minYtOut,\\n        ApproxParams calldata guessTotalPtToSwap\\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\\n\\n    function swapExactYtForPt(\\n        address receiver,\\n        address market,\\n        uint256 exactYtIn,\\n        uint256 minPtOut,\\n        ApproxParams calldata guessTotalPtFromSwap\\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionMiscV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../router/base/MarketApproxLib.sol\\\";\\nimport \\\"./IPAllActionTypeV3.sol\\\";\\n\\n/*\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n * NOTICE *\\n * Refer to https://docs.pendle.finance/Developers/Contracts/PendleRouter for more information on\\n * TokenInput, TokenOutput, ApproxParams, LimitOrderData\\n * It's recommended to use Pendle's Hosted SDK to generate the params\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n */\\n\\ninterface IPActionMiscV3 {\\n    struct Call3 {\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    event MintSyFromToken(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed SY,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netSyOut\\n    );\\n\\n    event RedeemSyToToken(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        address indexed SY,\\n        address receiver,\\n        uint256 netSyIn,\\n        uint256 netTokenOut\\n    );\\n\\n    event MintPyFromSy(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed YT,\\n        uint256 netSyIn,\\n        uint256 netPyOut\\n    );\\n\\n    event RedeemPyToSy(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed YT,\\n        uint256 netPyIn,\\n        uint256 netSyOut\\n    );\\n\\n    event MintPyFromToken(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed YT,\\n        address receiver,\\n        uint256 netTokenIn,\\n        uint256 netPyOut,\\n        uint256 netSyInterm\\n    );\\n\\n    event RedeemPyToToken(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        address indexed YT,\\n        address receiver,\\n        uint256 netPyIn,\\n        uint256 netTokenOut,\\n        uint256 netSyInterm\\n    );\\n\\n    function mintSyFromToken(\\n        address receiver,\\n        address SY,\\n        uint256 minSyOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netSyOut);\\n\\n    function redeemSyToToken(\\n        address receiver,\\n        address SY,\\n        uint256 netSyIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut);\\n\\n    function mintPyFromToken(\\n        address receiver,\\n        address YT,\\n        uint256 minPyOut,\\n        TokenInput calldata input\\n    ) external payable returns (uint256 netPyOut, uint256 netSyInterm);\\n\\n    function redeemPyToToken(\\n        address receiver,\\n        address YT,\\n        uint256 netPyIn,\\n        TokenOutput calldata output\\n    ) external returns (uint256 netTokenOut, uint256 netSyInterm);\\n\\n    function mintPyFromSy(\\n        address receiver,\\n        address YT,\\n        uint256 netSyIn,\\n        uint256 minPyOut\\n    ) external returns (uint256 netPyOut);\\n\\n    function redeemPyToSy(\\n        address receiver,\\n        address YT,\\n        uint256 netPyIn,\\n        uint256 minSyOut\\n    ) external returns (uint256 netSyOut);\\n\\n    function redeemDueInterestAndRewards(\\n        address user,\\n        address[] calldata sys,\\n        address[] calldata yts,\\n        address[] calldata markets\\n    ) external;\\n\\n    function swapTokenToToken(\\n        address receiver,\\n        uint256 minTokenOut,\\n        TokenInput calldata inp\\n    ) external payable returns (uint256 netTokenOut);\\n\\n    function swapTokenToTokenViaSy(\\n        address receiver,\\n        address SY,\\n        TokenInput calldata input,\\n        address tokenRedeemSy,\\n        uint256 minTokenOut\\n    ) external payable returns (uint256 netTokenOut, uint256 netSyInterm);\\n\\n    function boostMarkets(address[] memory markets) external;\\n\\n    function multicall(Call3[] calldata calls) external payable returns (Result[] memory res);\\n\\n    function simulate(address target, bytes calldata data) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionCallbackV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPMarketSwapCallback.sol\\\";\\nimport \\\"./IPLimitRouter.sol\\\";\\n\\ninterface IPActionCallbackV3 is IPMarketSwapCallback, IPLimitRouterCallback {}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPActionStorageV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPActionStorageV4 {\\n    struct SelectorsToFacet {\\n        address facet;\\n        bytes4[] selectors;\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    event SelectorToFacetSet(bytes4 indexed selector, address indexed facet);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\\n\\n    function claimOwnership() external;\\n\\n    function setSelectorToFacets(SelectorsToFacet[] calldata arr) external;\\n\\n    function selectorToFacet(bytes4 selector) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPPrincipalToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IPPrincipalToken is IERC20Metadata {\\n    function burnByYT(address user, uint256 amount) external;\\n\\n    function mintByYT(address user, uint256 amount) external;\\n\\n    function initialize(address _YT) external;\\n\\n    function SY() external view returns (address);\\n\\n    function YT() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function isExpired() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./IRewardManager.sol\\\";\\nimport \\\"./IPInterestManagerYT.sol\\\";\\n\\ninterface IPYieldToken is IERC20Metadata, IRewardManager, IPInterestManagerYT {\\n    event NewInterestIndex(uint256 indexed newIndex);\\n\\n    event Mint(\\n        address indexed caller,\\n        address indexed receiverPT,\\n        address indexed receiverYT,\\n        uint256 amountSyToMint,\\n        uint256 amountPYOut\\n    );\\n\\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\\n\\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\\n\\n    event RedeemInterest(address indexed user, uint256 interestOut);\\n\\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\\n\\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\\n\\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\\n\\n    function redeemPYMulti(\\n        address[] calldata receivers,\\n        uint256[] calldata amountPYToRedeems\\n    ) external returns (uint256[] memory amountSyOuts);\\n\\n    function redeemDueInterestAndRewards(\\n        address user,\\n        bool redeemInterest,\\n        bool redeemRewards\\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\\n\\n    function rewardIndexesCurrent() external returns (uint256[] memory);\\n\\n    function pyIndexCurrent() external returns (uint256);\\n\\n    function pyIndexStored() external view returns (uint256);\\n\\n    function getRewardTokens() external view returns (address[] memory);\\n\\n    function SY() external view returns (address);\\n\\n    function PT() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function isExpired() external view returns (bool);\\n\\n    function doCacheIndexSameBlock() external view returns (bool);\\n\\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IStandardizedYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n/*\\n * MIT License\\n * ===========\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n */\\n\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IStandardizedYield is IERC20Metadata {\\n    /// @dev Emitted when any base tokens is deposited to mint shares\\n    event Deposit(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed tokenIn,\\n        uint256 amountDeposited,\\n        uint256 amountSyOut\\n    );\\n\\n    /// @dev Emitted when any shares are redeemed for base tokens\\n    event Redeem(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed tokenOut,\\n        uint256 amountSyToRedeem,\\n        uint256 amountTokenOut\\n    );\\n\\n    /// @dev check `assetInfo()` for more information\\n    enum AssetType {\\n        TOKEN,\\n        LIQUIDITY\\n    }\\n\\n    /// @dev Emitted when (`user`) claims their rewards\\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\\n\\n    /**\\n     * @notice mints an amount of shares by depositing a base token.\\n     * @param receiver shares recipient address\\n     * @param tokenIn address of the base tokens to mint shares\\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\\n     * @param minSharesOut reverts if amount of shares minted is lower than this\\n     * @return amountSharesOut amount of shares minted\\n     * @dev Emits a {Deposit} event\\n     *\\n     * Requirements:\\n     * - (`tokenIn`) must be a valid base token.\\n     */\\n    function deposit(\\n        address receiver,\\n        address tokenIn,\\n        uint256 amountTokenToDeposit,\\n        uint256 minSharesOut\\n    ) external payable returns (uint256 amountSharesOut);\\n\\n    /**\\n     * @notice redeems an amount of base tokens by burning some shares\\n     * @param receiver recipient address\\n     * @param amountSharesToRedeem amount of shares to be burned\\n     * @param tokenOut address of the base token to be redeemed\\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\\n     * @return amountTokenOut amount of base tokens redeemed\\n     * @dev Emits a {Redeem} event\\n     *\\n     * Requirements:\\n     * - (`tokenOut`) must be a valid base token.\\n     */\\n    function redeem(\\n        address receiver,\\n        uint256 amountSharesToRedeem,\\n        address tokenOut,\\n        uint256 minTokenOut,\\n        bool burnFromInternalBalance\\n    ) external returns (uint256 amountTokenOut);\\n\\n    /**\\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\\n     he can mint must be X * exchangeRate / 1e18\\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\\n     & division\\n     */\\n    function exchangeRate() external view returns (uint256 res);\\n\\n    /**\\n     * @notice claims reward for (`user`)\\n     * @param user the user receiving their rewards\\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\\n     * @dev\\n     * Emits a `ClaimRewards` event\\n     * See {getRewardTokens} for list of reward tokens\\n     */\\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\\n\\n    /**\\n     * @notice get the amount of unclaimed rewards for (`user`)\\n     * @param user the user to check for\\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\\n     */\\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\\n\\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\\n\\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\\n\\n    /**\\n     * @notice returns the list of reward token addresses\\n     */\\n    function getRewardTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice returns the address of the underlying yield token\\n     */\\n    function yieldToken() external view returns (address);\\n\\n    /**\\n     * @notice returns all tokens that can mint this SY\\n     */\\n    function getTokensIn() external view returns (address[] memory res);\\n\\n    /**\\n     * @notice returns all tokens that can be redeemed by this SY\\n     */\\n    function getTokensOut() external view returns (address[] memory res);\\n\\n    function isValidTokenIn(address token) external view returns (bool);\\n\\n    function isValidTokenOut(address token) external view returns (bool);\\n\\n    function previewDeposit(\\n        address tokenIn,\\n        uint256 amountTokenToDeposit\\n    ) external view returns (uint256 amountSharesOut);\\n\\n    function previewRedeem(\\n        address tokenOut,\\n        uint256 amountSharesToRedeem\\n    ) external view returns (uint256 amountTokenOut);\\n\\n    /**\\n     * @notice This function contains information to interpret what the asset is\\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\\n     * @return assetAddress the address of the asset\\n     * @return assetDecimals the decimals of the asset\\n     */\\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPGauge {\\n    function totalActiveSupply() external view returns (uint256);\\n\\n    function activeBalance(address user) external view returns (uint256);\\n\\n    // only available for newer factories. please check the verified contracts\\n    event RedeemRewards(address indexed user, uint256[] rewardsOut);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/Market/MarketMathCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/math/PMath.sol\\\";\\nimport \\\"../libraries/math/LogExpMath.sol\\\";\\n\\nimport \\\"../StandardizedYield/PYIndex.sol\\\";\\nimport \\\"../libraries/MiniHelpers.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nstruct MarketState {\\n    int256 totalPt;\\n    int256 totalSy;\\n    int256 totalLp;\\n    address treasury;\\n    /// immutable variables ///\\n    int256 scalarRoot;\\n    uint256 expiry;\\n    /// fee data ///\\n    uint256 lnFeeRateRoot;\\n    uint256 reserveFeePercent; // base 100\\n    /// last trade data ///\\n    uint256 lastLnImpliedRate;\\n}\\n\\n// params that are expensive to compute, therefore we pre-compute them\\nstruct MarketPreCompute {\\n    int256 rateScalar;\\n    int256 totalAsset;\\n    int256 rateAnchor;\\n    int256 feeRate;\\n}\\n\\n// solhint-disable ordering\\nlibrary MarketMathCore {\\n    using PMath for uint256;\\n    using PMath for int256;\\n    using LogExpMath for int256;\\n    using PYIndexLib for PYIndex;\\n\\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    uint256 internal constant DAY = 86400;\\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\\n\\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\\n\\n    using PMath for uint256;\\n    using PMath for int256;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function addLiquidity(\\n        MarketState memory market,\\n        uint256 syDesired,\\n        uint256 ptDesired,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\\n            market,\\n            syDesired.Int(),\\n            ptDesired.Int(),\\n            blockTime\\n        );\\n\\n        lpToReserve = _lpToReserve.Uint();\\n        lpToAccount = _lpToAccount.Uint();\\n        syUsed = _syUsed.Uint();\\n        ptUsed = _ptUsed.Uint();\\n    }\\n\\n    function removeLiquidity(\\n        MarketState memory market,\\n        uint256 lpToRemove\\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\\n\\n        netSyToAccount = _syToAccount.Uint();\\n        netPtToAccount = _ptToAccount.Uint();\\n    }\\n\\n    function swapExactPtForSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtToMarket,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\\n            market,\\n            index,\\n            exactPtToMarket.neg(),\\n            blockTime\\n        );\\n\\n        netSyToAccount = _netSyToAccount.Uint();\\n        netSyFee = _netSyFee.Uint();\\n        netSyToReserve = _netSyToReserve.Uint();\\n    }\\n\\n    function swapSyForExactPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtToAccount,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\\n            market,\\n            index,\\n            exactPtToAccount.Int(),\\n            blockTime\\n        );\\n\\n        netSyToMarket = _netSyToAccount.neg().Uint();\\n        netSyFee = _netSyFee.Uint();\\n        netSyToReserve = _netSyToReserve.Uint();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    CORE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function addLiquidityCore(\\n        MarketState memory market,\\n        int256 syDesired,\\n        int256 ptDesired,\\n        uint256 blockTime\\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        if (market.totalLp == 0) {\\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\\n            lpToReserve = MINIMUM_LIQUIDITY;\\n            syUsed = syDesired;\\n            ptUsed = ptDesired;\\n        } else {\\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\\n            if (netLpByPt < netLpBySy) {\\n                lpToAccount = netLpByPt;\\n                ptUsed = ptDesired;\\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\\n            } else {\\n                lpToAccount = netLpBySy;\\n                syUsed = syDesired;\\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\\n            }\\n        }\\n\\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.totalSy += syUsed;\\n        market.totalPt += ptUsed;\\n        market.totalLp += lpToAccount + lpToReserve;\\n    }\\n\\n    function removeLiquidityCore(\\n        MarketState memory market,\\n        int256 lpToRemove\\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\\n\\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\\n    }\\n\\n    function executeTradeCore(\\n        MarketState memory market,\\n        PYIndex index,\\n        int256 netPtToAccount,\\n        uint256 blockTime\\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n        if (market.totalPt <= netPtToAccount)\\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\\n\\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\\n    }\\n\\n    function getMarketPreCompute(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 blockTime\\n    ) internal pure returns (MarketPreCompute memory res) {\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n\\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\\n        res.totalAsset = index.syToAsset(market.totalSy);\\n\\n        if (market.totalPt == 0 || res.totalAsset == 0)\\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\\n\\n        res.rateAnchor = _getRateAnchor(\\n            market.totalPt,\\n            market.lastLnImpliedRate,\\n            res.totalAsset,\\n            res.rateScalar,\\n            timeToExpiry\\n        );\\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\\n    }\\n\\n    function calcTrade(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        int256 netPtToAccount\\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\\n        int256 preFeeExchangeRate = _getExchangeRate(\\n            market.totalPt,\\n            comp.totalAsset,\\n            comp.rateScalar,\\n            comp.rateAnchor,\\n            netPtToAccount\\n        );\\n\\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\\n        int256 fee = comp.feeRate;\\n\\n        if (netPtToAccount > 0) {\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\\n\\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\\n        } else {\\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\\n        }\\n\\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\\n\\n        netSyToAccount = netAssetToAccount < 0\\n            ? index.assetToSyUp(netAssetToAccount)\\n            : index.assetToSy(netAssetToAccount);\\n        netSyFee = index.assetToSy(fee);\\n        netSyToReserve = index.assetToSy(netAssetToReserve);\\n    }\\n\\n    function _setNewMarketStateTrade(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        int256 netPtToAccount,\\n        int256 netSyToAccount,\\n        int256 netSyToReserve,\\n        uint256 blockTime\\n    ) internal pure {\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n\\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\\n\\n        market.lastLnImpliedRate = _getLnImpliedRate(\\n            market.totalPt,\\n            index.syToAsset(market.totalSy),\\n            comp.rateScalar,\\n            comp.rateAnchor,\\n            timeToExpiry\\n        );\\n\\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\\n    }\\n\\n    function _getRateAnchor(\\n        int256 totalPt,\\n        uint256 lastLnImpliedRate,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        uint256 timeToExpiry\\n    ) internal pure returns (int256 rateAnchor) {\\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\\n\\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\\n\\n        {\\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\\n\\n            int256 lnProportion = _logProportion(proportion);\\n\\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\\n        }\\n    }\\n\\n    /// @notice Calculates the current market implied rate.\\n    /// @return lnImpliedRate the implied rate\\n    function _getLnImpliedRate(\\n        int256 totalPt,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        uint256 timeToExpiry\\n    ) internal pure returns (uint256 lnImpliedRate) {\\n        // This will check for exchange rates < PMath.IONE\\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\\n\\n        // exchangeRate >= 1 so its ln >= 0\\n        uint256 lnRate = exchangeRate.ln().Uint();\\n\\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\\n    }\\n\\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\\n    /// formula is E = e^rt\\n    function _getExchangeRateFromImpliedRate(\\n        uint256 lnImpliedRate,\\n        uint256 timeToExpiry\\n    ) internal pure returns (int256 exchangeRate) {\\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\\n\\n        exchangeRate = LogExpMath.exp(rt.Int());\\n    }\\n\\n    function _getExchangeRate(\\n        int256 totalPt,\\n        int256 totalAsset,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 netPtToAccount\\n    ) internal pure returns (int256 exchangeRate) {\\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\\n\\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\\n\\n        if (proportion > MAX_MARKET_PROPORTION)\\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\\n\\n        int256 lnProportion = _logProportion(proportion);\\n\\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\\n\\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\\n    }\\n\\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\\n\\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\\n\\n        res = logitP.ln();\\n    }\\n\\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\\n    }\\n\\n    function setInitialLnImpliedRate(\\n        MarketState memory market,\\n        PYIndex index,\\n        int256 initialAnchor,\\n        uint256 blockTime\\n    ) internal pure {\\n        /// ------------------------------------------------------------\\n        /// CHECKS\\n        /// ------------------------------------------------------------\\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\\n\\n        /// ------------------------------------------------------------\\n        /// MATH\\n        /// ------------------------------------------------------------\\n        int256 totalAsset = index.syToAsset(market.totalSy);\\n        uint256 timeToExpiry = market.expiry - blockTime;\\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\\n\\n        /// ------------------------------------------------------------\\n        /// WRITE\\n        /// ------------------------------------------------------------\\n        market.lastLnImpliedRate = _getLnImpliedRate(\\n            market.totalPt,\\n            totalAsset,\\n            rateScalar,\\n            initialAnchor,\\n            timeToExpiry\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @title Interface of the ERC20 standard as defined in the EIP, including EIP-2612 permit\\n/// functionality.\\ninterface IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   Emitted when one account has set the allowance of another account over their tokens.\\n   *  @param owner_   Account that tokens are approved from.\\n   *  @param spender_ Account that tokens are approved for.\\n   *  @param amount_  Amount of tokens that have been approved.\\n   */\\n  event Approval(address indexed owner_, address indexed spender_, uint256 amount_);\\n\\n  /**\\n   *  @dev   Emitted when tokens have moved from one account to another.\\n   *  @param owner_     Account that tokens have moved from.\\n   *  @param recipient_ Account that tokens have moved to.\\n   *  @param amount_    Amount of tokens that have been transferred.\\n   */\\n  event Transfer(address indexed owner_, address indexed recipient_, uint256 amount_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * External Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Function that allows one account to set the allowance of another account over their\\n   * tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_ Account that tokens are approved for.\\n   *  @param  amount_  Amount of tokens that have been approved.\\n   *  @return success_ Boolean indicating whether the operation succeeded.\\n   */\\n  function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n  /**\\n   *  @dev    Function that allows one account to decrease the allowance of another account over\\n   * their tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_          Account that tokens are approved for.\\n   *  @param  subtractedAmount_ Amount to decrease approval by.\\n   *  @return success_          Boolean indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address spender_, uint256 subtractedAmount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *  @dev    Function that allows one account to increase the allowance of another account over\\n   * their tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_     Account that tokens are approved for.\\n   *  @param  addedAmount_ Amount to increase approval by.\\n   *  @return success_     Boolean indicating whether the operation succeeded.\\n   */\\n  function increaseAllowance(address spender_, uint256 addedAmount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *  @dev   Approve by signature.\\n   *  @param owner_    Owner address that signed the permit.\\n   *  @param spender_  Spender of the permit.\\n   *  @param amount_   Permit approval spend limit.\\n   *  @param deadline_ Deadline after which the permit is invalid.\\n   *  @param v_        ECDSA signature v component.\\n   *  @param r_        ECDSA signature r component.\\n   *  @param s_        ECDSA signature s component.\\n   */\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 amount_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n\\n  /**\\n   *  @dev    Moves an amount of tokens from `msg.sender` to a specified account.\\n   *          Emits a {Transfer} event.\\n   *  @param  recipient_ Account that receives tokens.\\n   *  @param  amount_    Amount of tokens that are transferred.\\n   *  @return success_   Boolean indicating whether the operation succeeded.\\n   */\\n  function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n  /**\\n   *  @dev    Moves a pre-approved amount of tokens from a sender to a specified account.\\n   *          Emits a {Transfer} event.\\n   *          Emits an {Approval} event.\\n   *  @param  owner_     Account that tokens are moving from.\\n   *  @param  recipient_ Account that receives tokens.\\n   *  @param  amount_    Amount of tokens that are transferred.\\n   *  @return success_   Boolean indicating whether the operation succeeded.\\n   */\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Returns the allowance that one account has given another over their tokens.\\n   *  @param  owner_     Account that tokens are approved from.\\n   *  @param  spender_   Account that tokens are approved for.\\n   *  @return allowance_ Allowance that one account has given another over their tokens.\\n   */\\n  function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\\n\\n  /**\\n   *  @dev    Returns the amount of tokens owned by a given account.\\n   *  @param  account_ Account that owns the tokens.\\n   *  @return balance_ Amount of tokens owned by a given account.\\n   */\\n  function balanceOf(address account_) external view returns (uint256 balance_);\\n\\n  /**\\n   *  @dev    Returns the decimal precision used by the token.\\n   *  @return decimals_ The decimal precision used by the token.\\n   */\\n  function decimals() external view returns (uint8 decimals_);\\n\\n  /**\\n   *  @dev    Returns the signature domain separator.\\n   *  @return domainSeparator_ The signature domain separator.\\n   */\\n  function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator_);\\n\\n  /**\\n   *  @dev    Returns the name of the token.\\n   *  @return name_ The name of the token.\\n   */\\n  function name() external view returns (string memory name_);\\n\\n  /**\\n   *  @dev    Returns the nonce for the given owner.\\n   *  @param  owner_  The address of the owner account.\\n   *  @return nonce_ The nonce for the given owner.\\n   */\\n  function nonces(address owner_) external view returns (uint256 nonce_);\\n\\n  /**\\n   *  @dev    Returns the permit type hash.\\n   *  @return permitTypehash_ The permit type hash.\\n   */\\n  function PERMIT_TYPEHASH() external view returns (bytes32 permitTypehash_);\\n\\n  /**\\n   *  @dev    Returns the symbol of the token.\\n   *  @return symbol_ The symbol of the token.\\n   */\\n  function symbol() external view returns (string memory symbol_);\\n\\n  /**\\n   *  @dev    Returns the total amount of tokens in existence.\\n   *  @return totalSupply_ The total amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256 totalSupply_);\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC20Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\n/// @title Interface of the ERC20 standard as needed by ERC20Helper.\\ninterface IERC20Like {\\n  function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n  function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    returns (bool success_);\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/// @title A standard for tokenized Vaults with a single underlying ERC-20 token.\\ninterface IERC4626 is IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   `caller_` has exchanged `assets_` for `shares_` and transferred them to `owner_`.\\n   *         MUST be emitted when assets are deposited via the `deposit` or `mint` methods.\\n   *  @param caller_ The caller of the function that emitted the `Deposit` event.\\n   *  @param owner_  The owner of the shares.\\n   *  @param assets_ The amount of assets deposited.\\n   *  @param shares_ The amount of shares minted.\\n   */\\n  event Deposit(address indexed caller_, address indexed owner_, uint256 assets_, uint256 shares_);\\n\\n  /**\\n   *  @dev   `caller_`\u00a0has exchanged\u00a0`shares_`, owned by\u00a0`owner_`, for\u00a0`assets_`, and\\n   * transferred them\u00a0to\u00a0`receiver_`.\\n   *         MUST be emitted when assets are withdrawn via the\u00a0`withdraw`\u00a0or\u00a0`redeem`\u00a0methods.\\n   *  @param caller_   The caller of the function that emitted the `Withdraw` event.\\n   *  @param receiver_ The receiver of the assets.\\n   *  @param owner_    The owner of the shares.\\n   *  @param assets_   The amount of assets withdrawn.\\n   *  @param shares_   The amount of shares burned.\\n   */\\n  event Withdraw(\\n    address indexed caller_,\\n    address indexed receiver_,\\n    address indexed owner_,\\n    uint256 assets_,\\n    uint256 shares_\\n  );\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Variables **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    The address of the underlying asset used by the Vault.\\n   *          MUST be a contract that implements the ERC-20 standard.\\n   *          MUST NOT revert.\\n   *  @return asset_ The address of the underlying asset.\\n   */\\n  function asset() external view returns (address asset_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Changing Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\n   *          MUST emit the {Deposit} event.\\n   *          MUST revert if all of the assets cannot be deposited (due to insufficient approval,\\n   * deposit limits, slippage, etc).\\n   *  @param  assets_   The amount of assets to deposit.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return shares_   The amount of shares minted.\\n   */\\n  function deposit(uint256 assets_, address receiver_) external returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\n   *          MUST emit the {Deposit} event.\\n   *          MUST revert if all of shares cannot be minted (due to insufficient approval, deposit\\n   * limits, slippage, etc).\\n   *  @param  shares_   The amount of shares to mint.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return assets_   The amount of assets deposited.\\n   */\\n  function mint(uint256 shares_, address receiver_) external returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends\u00a0`assets_` to\u00a0`receiver_`.\\n   *          MUST emit the\u00a0{Withdraw}\u00a0event.\\n   *          MUST revert if all of\u00a0the shares\u00a0cannot be redeemed (due to insufficient shares,\\n   * withdrawal limits, slippage, etc).\\n   *  @param  shares_   The amount of shares to redeem.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @param  owner_    The owner of the shares.\\n   *  @return assets_   The amount of assets sent to the receiver.\\n   */\\n  function redeem(uint256 shares_, address receiver_, address owner_)\\n    external\\n    returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends `assets_`\u00a0to `receiver_`.\\n   *          MUST emit the\u00a0{Withdraw}\u00a0event.\\n   *          MUST revert if all of\u00a0the assets\u00a0cannot be withdrawn (due to insufficient assets,\\n   * withdrawal limits, slippage, etc).\\n   *  @param  assets_   The amount of assets to withdraw.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @param  owner_    The owner of the assets.\\n   *  @return shares_   The amount of shares burned from the owner.\\n   */\\n  function withdraw(uint256 assets_, address receiver_, address owner_)\\n    external\\n    returns (uint256 shares_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    The amount of `assets_` the `shares_` are currently equivalent to.\\n   *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   *          MUST NOT reflect slippage or other on-chain conditions when performing the actual\\n   * exchange.\\n   *          MUST NOT show any variations depending on the caller.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to convert.\\n   *  @return assets_ The amount of equivalent assets.\\n   */\\n  function convertToAssets(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    The amount of `shares_` the `assets_` are currently equivalent to.\\n   *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   *          MUST NOT reflect slippage or other on-chain conditions when performing the actual\\n   * exchange.\\n   *          MUST NOT show any variations depending on the caller.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to convert.\\n   *  @return shares_ The amount of equivalent shares.\\n   */\\n  function convertToShares(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `assets_` that can be deposited on behalf of the `receiver_` through\\n   * a `deposit` call.\\n   *          MUST return a limited value if the receiver is subject to any limits, or the maximum\\n   * value otherwise.\\n   *          MUST NOT revert.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @return assets_   The maximum amount of assets that can be deposited.\\n   */\\n  function maxDeposit(address receiver_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Maximum amount of `shares_` that can be minted on behalf of the `receiver_` through a\\n   * `mint` call.\\n   *          MUST return a limited value if the receiver is subject to any limits, or the maximum\\n   * value otherwise.\\n   *          MUST NOT revert.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return shares_   The maximum amount of shares that can be minted.\\n   */\\n  function maxMint(address receiver_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `shares_` that can be redeemed from the\u00a0`owner_` through\\n   * a\u00a0`redeem`\u00a0call.\\n   *          MUST return a limited value if\u00a0the owner\u00a0is subject to any limits, or the total\\n   * amount of owned shares otherwise.\\n   *          MUST\u00a0NOT\u00a0revert.\\n   *  @param  owner_  The owner of the shares.\\n   *  @return shares_ The maximum amount of shares that can be redeemed.\\n   */\\n  function maxRedeem(address owner_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `assets_` that can be withdrawn from the `owner_` through a\\n   * `withdraw` call.\\n   *          MUST return a limited value if the owner is subject to any limits, or the total amount\\n   * of owned assets otherwise.\\n   *          MUST NOT revert.\\n   *  @param  owner_  The owner of the assets.\\n   *  @return assets_ The maximum amount of assets that can be withdrawn.\\n   */\\n  function maxWithdraw(address owner_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their deposit at the\\n   * current block, given current on-chain conditions.\\n   *          MUST return as close to and no more than the exact amount of shares that would be\\n   * minted in a `deposit` call in the same transaction.\\n   *          MUST NOT account for deposit limits like those returned from `maxDeposit` and should\\n   * always act as though the deposit would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to deposit.\\n   *  @return shares_ The amount of shares that would be minted.\\n   */\\n  function previewDeposit(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their mint at the\\n   * current block, given current on-chain conditions.\\n   *          MUST return as close to and no fewer than the exact amount of assets that would be\\n   * deposited in a `mint` call in the same transaction.\\n   *          MUST NOT account for mint limits like those returned from `maxMint` and should always\\n   * act as though the minting would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to mint.\\n   *  @return assets_ The amount of assets that would be deposited.\\n   */\\n  function previewMint(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their redemption at\\n   * the current block, given current on-chain conditions.\\n   *          MUST return as close to and no more than the exact amount of assets that would be\\n   * withdrawn in a\u00a0`redeem`\u00a0call in the same transaction.\\n   *          MUST NOT account for redemption limits like those returned from `maxRedeem` and should\\n   * always act as though the redemption would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to redeem.\\n   *  @return assets_ The amount of assets that would be withdrawn.\\n   */\\n  function previewRedeem(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their withdrawal at\\n   * the current block, given current on-chain conditions.\\n   *          MUST return as close to and no fewer than the exact amount of shares that would be\\n   * burned in a\u00a0`withdraw`\u00a0call in the same transaction.\\n   *          MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and\\n   * should always act as though the withdrawal would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to withdraw.\\n   *  @return shares_ The amount of shares that would be redeemed.\\n   */\\n  function previewWithdraw(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Total amount of the underlying asset that is managed by the Vault.\\n   *          SHOULD include compounding that occurs from any yields.\\n   *          MUST NOT revert.\\n   *  @return totalAssets_ The total amount of assets the Vault manages.\\n   */\\n  function totalAssets() external view returns (uint256 totalAssets_);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/router/base/MarketApproxLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../core/libraries/math/PMath.sol\\\";\\nimport \\\"../../core/Market/MarketMathCore.sol\\\";\\n\\nstruct ApproxParams {\\n    uint256 guessMin;\\n    uint256 guessMax;\\n    uint256 guessOffchain; // pass 0 in to skip this variable\\n    uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\\n    uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\\n    // to 1e15 (1e18/1000 = 0.1%)\\n}\\n\\n/// Further explanation of the eps. Take swapExactSyForPt for example. To calc the corresponding amount of Pt to swap out,\\n/// it's necessary to run an approximation algorithm, because by default there only exists the Pt to Sy formula\\n/// To approx, the 5 values above will have to be provided, and the approx process will run as follows:\\n/// mid = (guessMin + guessMax) / 2 // mid here is the current guess of the amount of Pt out\\n/// netSyNeed = calcSwapSyForExactPt(mid)\\n/// if (netSyNeed > exactSyIn) guessMax = mid - 1 // since the maximum Sy in can't exceed the exactSyIn\\n/// else guessMin = mid (1)\\n/// For the (1), since netSyNeed <= exactSyIn, the result might be usable. If the netSyNeed is within eps of\\n/// exactSyIn (ex eps=0.1% => we have used 99.9% the amount of Sy specified), mid will be chosen as the final guess result\\n\\n/// for guessOffchain, this is to provide a shortcut to guessing. The offchain SDK can precalculate the exact result\\n/// before the tx is sent. When the tx reaches the contract, the guessOffchain will be checked first, and if it satisfies the\\n/// approximation, it will be used (and save all the guessing). It's expected that this shortcut will be used in most cases\\n/// except in cases that there is a trade in the same market right before the tx\\n\\nlibrary MarketApproxPtInLib {\\n    using MarketMathCore for MarketState;\\n    using PYIndexLib for PYIndex;\\n    using PMath for uint256;\\n    using PMath for int256;\\n    using LogExpMath for int256;\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swap in\\n     *     - Try swapping & get netSyOut\\n     *     - Stop when netSyOut greater & approx minSyOut\\n     *     - guess & approx is for netPtIn\\n     */\\n    function approxSwapPtForExactSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 minSyOut,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            if (netSyOut >= minSyOut) {\\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\\n                    return (guess, netSyOut, netSyFee);\\n                }\\n                approx.guessMax = guess;\\n            } else {\\n                approx.guessMin = guess;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swap in\\n     *     - Flashswap the corresponding amount of SY out\\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\\n     *     - PT to repay the flashswap, YT transferred to user\\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\\n     *     - guess & approx is for netYtOut (also netPtIn)\\n     */\\n    function approxSwapExactSyForYt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactSyIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\\n\\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\\n\\n            if (netSyToPull <= exactSyIn) {\\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\\n                    return (guess, netSyFee);\\n                }\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    struct Args5 {\\n        MarketState market;\\n        PYIndex index;\\n        uint256 totalPtIn;\\n        uint256 netSyHolding;\\n        uint256 blockTime;\\n        ApproxParams approx;\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swap to SY\\n     *     - Swap PT to SY\\n     *     - Pair the remaining PT with the SY to add liquidity\\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\\n     *     - guess & approx is for netPtSwap\\n     */\\n    function approxSwapPtToAddLiquidity(\\n        MarketState memory _market,\\n        PYIndex _index,\\n        uint256 _totalPtIn,\\n        uint256 _netSyHolding,\\n        uint256 _blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\\n            validateApprox(approx);\\n            require(a.market.totalLp != 0, \\\"no existing lp\\\");\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\\n                a.market,\\n                a.index,\\n                a.totalPtIn,\\n                a.netSyHolding,\\n                comp,\\n                guess\\n            );\\n\\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\\n                return (guess, netSyOut, netSyFee);\\n            }\\n\\n            if (syNumerator <= ptNumerator) {\\n                // needs more SY --> swap more PT\\n                approx.guessMin = guess + 1;\\n            } else {\\n                // needs less SY --> swap less PT\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    function calcNumerators(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 totalPtIn,\\n        uint256 netSyHolding,\\n        MarketPreCompute memory comp,\\n        uint256 guess\\n    )\\n        internal\\n        pure\\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\\n    {\\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\\n\\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\\n\\n        // it is desired that\\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\\n        // which is equivalent to\\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\\n\\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swap to SY\\n     *     - Flashswap the corresponding amount of SY out\\n     *     - Tokenize all the SY into PT + YT\\n     *     - PT to repay the flashswap, YT transferred to user\\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\\n     *     - guess & approx is for totalPtToSwap\\n     */\\n    function approxSwapExactPtForYt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactPtIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\\n\\n            uint256 netAssetOut = index.syToAsset(netSyOut);\\n\\n            // guess >= netAssetOut since we are swapping PT to SY\\n            uint256 netPtToPull = guess - netAssetOut;\\n\\n            if (netPtToPull <= exactPtIn) {\\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\\n                    return (netAssetOut, guess, netSyFee);\\n                }\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    function calcSyOut(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        uint256 netPtIn\\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\\n        netSyOut = uint256(_netSyOut);\\n        netSyFee = uint256(_netSyFee);\\n        netSyToReserve = uint256(_netSyToReserve);\\n    }\\n\\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\\n        revert(\\\"Slippage: guessMin > guessMax\\\");\\n    }\\n\\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\\n\\n    function validateApprox(ApproxParams memory approx) internal pure {\\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert(\\\"Internal: INVALID_APPROX_PARAMS\\\");\\n    }\\n\\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 hi = uint256(comp.totalAsset) - 1;\\n\\n        while (low != hi) {\\n            uint256 mid = (low + hi + 1) / 2;\\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\\n            else low = mid;\\n        }\\n\\n        low = PMath.min(\\n            low,\\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\\n        );\\n\\n        return low;\\n    }\\n\\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\\n        int256 sumPt = ptToMarket + totalPt;\\n\\n        require(diffAssetPtToMarket > 0 && sumPt > 0, \\\"invalid ptToMarket\\\");\\n\\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\\n\\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\\n\\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\\n    }\\n}\\n\\nlibrary MarketApproxPtOutLib {\\n    using MarketMathCore for MarketState;\\n    using PYIndexLib for PYIndex;\\n    using PMath for uint256;\\n    using PMath for int256;\\n    using LogExpMath for int256;\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swapExactOut\\n     *     - Calculate the amount of SY needed\\n     *     - Stop when the netSyIn is smaller approx exactSyIn\\n     *     - guess & approx is for netSyIn\\n     */\\n    function approxSwapExactSyForPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactSyIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            if (netSyIn <= exactSyIn) {\\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\\n                    return (guess, netSyFee);\\n                }\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swapExactOut\\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\\n     *     - Stop when the netSyOut is greater approx the minSyOut\\n     *     - guess & approx is for netSyOut\\n     */\\n    function approxSwapYtForExactSy(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 minSyOut,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            // no limit on min\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\\n\\n            if (netSyOut >= minSyOut) {\\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\\n                    return (guess, netSyOut, netSyFee);\\n                }\\n                approx.guessMax = guess;\\n            } else {\\n                approx.guessMin = guess + 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    struct Args6 {\\n        MarketState market;\\n        PYIndex index;\\n        uint256 totalSyIn;\\n        uint256 netPtHolding;\\n        uint256 blockTime;\\n        ApproxParams approx;\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swapExactOut\\n     *     - Swap that amount of PT out\\n     *     - Pair the remaining PT with the SY to add liquidity\\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\\n     *     - guess & approx is for netPtFromSwap\\n     */\\n    function approxSwapSyToAddLiquidity(\\n        MarketState memory _market,\\n        PYIndex _index,\\n        uint256 _totalSyIn,\\n        uint256 _netPtHolding,\\n        uint256 _blockTime,\\n        ApproxParams memory _approx\\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\\n\\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\\n        if (a.approx.guessOffchain == 0) {\\n            // no limit on min\\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\\n            validateApprox(a.approx);\\n            require(a.market.totalLp != 0, \\\"no existing lp\\\");\\n        }\\n\\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(a.approx, iter);\\n\\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\\n\\n            if (netSyIn > a.totalSyIn) {\\n                a.approx.guessMax = guess - 1;\\n                continue;\\n            }\\n\\n            uint256 syNumerator;\\n            uint256 ptNumerator;\\n\\n            {\\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\\n\\n                // it is desired that\\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\\n                // which is equivalent to\\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\\n\\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\\n            }\\n\\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\\n                return (guess, netSyIn, netSyFee);\\n            }\\n\\n            if (ptNumerator <= syNumerator) {\\n                // needs more PT\\n                a.approx.guessMin = guess + 1;\\n            } else {\\n                // needs less PT\\n                a.approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    /**\\n     * @dev algorithm:\\n     *     - Bin search the amount of PT to swapExactOut\\n     *     - Flashswap that amount of PT out\\n     *     - Pair all the PT with the YT to redeem SY\\n     *     - Use the SY to repay the flashswap debt\\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\\n     *     - guess & approx is for netPtFromSwap\\n     */\\n    function approxSwapExactYtForPt(\\n        MarketState memory market,\\n        PYIndex index,\\n        uint256 exactYtIn,\\n        uint256 blockTime,\\n        ApproxParams memory approx\\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\\n        if (approx.guessOffchain == 0) {\\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\\n            validateApprox(approx);\\n        }\\n\\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\\n            uint256 guess = nextGuess(approx, iter);\\n\\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\\n\\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\\n\\n            if (netYtToPull <= exactYtIn) {\\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\\n                    return (guess - netYtToPull, guess, netSyFee);\\n                }\\n                approx.guessMin = guess;\\n            } else {\\n                approx.guessMax = guess - 1;\\n            }\\n        }\\n        revert(\\\"Slippage: APPROX_EXHAUSTED\\\");\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    function calcSyIn(\\n        MarketState memory market,\\n        MarketPreCompute memory comp,\\n        PYIndex index,\\n        uint256 netPtOut\\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\\n\\n        // all safe since totalPt and totalSy is int128\\n        netSyIn = uint256(-_netSyIn);\\n        netSyFee = uint256(_netSyFee);\\n        netSyToReserve = uint256(_netSyToReserve);\\n    }\\n\\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\\n        int256 maxPtOut = totalPt - numerator;\\n        // only get 99.9% of the theoretical max to accommodate some precision issues\\n        return (uint256(maxPtOut) * 999) / 1000;\\n    }\\n\\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\\n        revert(\\\"Slippage: guessMin > guessMax\\\");\\n    }\\n\\n    function validateApprox(ApproxParams memory approx) internal pure {\\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert(\\\"Internal: INVALID_APPROX_PARAMS\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPAllActionTypeV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../router/swap-aggregator/IPSwapAggregator.sol\\\";\\nimport \\\"./IPLimitRouter.sol\\\";\\n\\n/*\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n * NOTICE *\\n * Refer to https://docs.pendle.finance/Developers/Contracts/PendleRouter for more information on\\n * TokenInput, TokenOutput, ApproxParams, LimitOrderData\\n * It's recommended to use Pendle's Hosted SDK to generate the params\\n *******************************************************************************************************************\\n *******************************************************************************************************************\\n */\\n\\nstruct TokenInput {\\n    // TOKEN DATA\\n    address tokenIn;\\n    uint256 netTokenIn;\\n    address tokenMintSy;\\n    // AGGREGATOR DATA\\n    address pendleSwap;\\n    SwapData swapData;\\n}\\n\\nstruct TokenOutput {\\n    // TOKEN DATA\\n    address tokenOut;\\n    uint256 minTokenOut;\\n    address tokenRedeemSy;\\n    // AGGREGATOR DATA\\n    address pendleSwap;\\n    SwapData swapData;\\n}\\n\\nstruct LimitOrderData {\\n    address limitRouter;\\n    uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\\n    FillOrderParams[] normalFills;\\n    FillOrderParams[] flashFills;\\n    bytes optData;\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPMarketSwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPMarketSwapCallback {\\n    function swapCallback(int256 ptToAccount, int256 syToAccount, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPLimitRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../core/StandardizedYield/PYIndex.sol\\\";\\n\\ninterface IPLimitOrderType {\\n    enum OrderType {\\n        SY_FOR_PT,\\n        PT_FOR_SY,\\n        SY_FOR_YT,\\n        YT_FOR_SY\\n    }\\n\\n    // Fixed-size order part with core information\\n    struct StaticOrder {\\n        uint256 salt;\\n        uint256 expiry;\\n        uint256 nonce;\\n        OrderType orderType;\\n        address token;\\n        address YT;\\n        address maker;\\n        address receiver;\\n        uint256 makingAmount;\\n        uint256 lnImpliedRate;\\n        uint256 failSafeRate;\\n    }\\n\\n    struct FillResults {\\n        uint256 totalMaking;\\n        uint256 totalTaking;\\n        uint256 totalFee;\\n        uint256 totalNotionalVolume;\\n        uint256[] netMakings;\\n        uint256[] netTakings;\\n        uint256[] netFees;\\n        uint256[] notionalVolumes;\\n    }\\n}\\n\\nstruct Order {\\n    uint256 salt;\\n    uint256 expiry;\\n    uint256 nonce;\\n    IPLimitOrderType.OrderType orderType;\\n    address token;\\n    address YT;\\n    address maker;\\n    address receiver;\\n    uint256 makingAmount;\\n    uint256 lnImpliedRate;\\n    uint256 failSafeRate;\\n    bytes permit;\\n}\\n\\nstruct FillOrderParams {\\n    Order order;\\n    bytes signature;\\n    uint256 makingAmount;\\n}\\n\\ninterface IPLimitRouterCallback is IPLimitOrderType {\\n    function limitRouterCallback(\\n        uint256 actualMaking,\\n        uint256 actualTaking,\\n        uint256 totalFee,\\n        bytes memory data\\n    ) external returns (bytes memory);\\n}\\n\\ninterface IPLimitRouter is IPLimitOrderType {\\n    struct OrderStatus {\\n        uint128 filledAmount;\\n        uint128 remaining;\\n    }\\n\\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\\n\\n    event OrderFilledV2(\\n        bytes32 indexed orderHash,\\n        OrderType indexed orderType,\\n        address indexed YT,\\n        address token,\\n        uint256 netInputFromMaker,\\n        uint256 netOutputToMaker,\\n        uint256 feeAmount,\\n        uint256 notionalVolume,\\n        address maker,\\n        address taker\\n    );\\n\\n    // @dev actualMaking, actualTaking are in the SY form\\n    function fill(\\n        FillOrderParams[] memory params,\\n        address receiver,\\n        uint256 maxTaking,\\n        bytes calldata optData,\\n        bytes calldata callback\\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\\n\\n    function feeRecipient() external view returns (address);\\n\\n    function hashOrder(Order memory order) external view returns (bytes32);\\n\\n    function cancelSingle(Order calldata order) external;\\n\\n    function cancelBatch(Order[] calldata orders) external;\\n\\n    function orderStatusesRaw(\\n        bytes32[] memory orderHashes\\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\\n\\n    function orderStatuses(\\n        bytes32[] memory orderHashes\\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function simulate(address target, bytes calldata data) external payable;\\n\\n    /* --- Deprecated events --- */\\n\\n    // deprecate on 7/1/2024, prior to official launch\\n    event OrderFilled(\\n        bytes32 indexed orderHash,\\n        OrderType indexed orderType,\\n        address indexed YT,\\n        address token,\\n        uint256 netInputFromMaker,\\n        uint256 netOutputToMaker,\\n        uint256 feeAmount,\\n        uint256 notionalVolume\\n    );\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IRewardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IRewardManager {\\n    function userReward(address token, address user) external view returns (uint128 index, uint128 accrued);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/interfaces/IPInterestManagerYT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPInterestManagerYT {\\n    event CollectInterestFee(uint256 amountInterestFee);\\n\\n    function userInterest(address user) external view returns (uint128 lastPYIndex, uint128 accruedInterest);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/libraries/math/PMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/* solhint-disable private-vars-leading-underscore, reason-string */\\n\\nlibrary PMath {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    int256 internal constant IONE = 1e18; // 18 decimal places\\n\\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return (a >= b ? a - b : 0);\\n        }\\n    }\\n\\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\\n        require(a >= b, \\\"negative\\\");\\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        unchecked {\\n            return product / ONE;\\n        }\\n    }\\n\\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\\n        int256 product = a * b;\\n        unchecked {\\n            return product / IONE;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 aInflated = a * ONE;\\n        unchecked {\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\\n        int256 aInflated = a * IONE;\\n        unchecked {\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a + b - 1) / b;\\n    }\\n\\n    // @author Uniswap\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function square(uint256 x) internal pure returns (uint256) {\\n        return x * x;\\n    }\\n\\n    function squareDown(uint256 x) internal pure returns (uint256) {\\n        return mulDown(x, x);\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x > 0 ? x : -x);\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256) {\\n        return x * (-1);\\n    }\\n\\n    function neg(uint256 x) internal pure returns (int256) {\\n        return Int(x) * (-1);\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (x > y ? x : y);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return (x > y ? x : y);\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (x < y ? x : y);\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return (x < y ? x : y);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               SIGNED CASTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function Int(uint256 x) internal pure returns (int256) {\\n        require(x <= uint256(type(int256).max));\\n        return int256(x);\\n    }\\n\\n    function Int128(int256 x) internal pure returns (int128) {\\n        require(type(int128).min <= x && x <= type(int128).max);\\n        return int128(x);\\n    }\\n\\n    function Int128(uint256 x) internal pure returns (int128) {\\n        return Int128(Int(x));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               UNSIGNED CASTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function Uint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function Uint32(uint256 x) internal pure returns (uint32) {\\n        require(x <= type(uint32).max);\\n        return uint32(x);\\n    }\\n\\n    function Uint64(uint256 x) internal pure returns (uint64) {\\n        require(x <= type(uint64).max);\\n        return uint64(x);\\n    }\\n\\n    function Uint112(uint256 x) internal pure returns (uint112) {\\n        require(x <= type(uint112).max);\\n        return uint112(x);\\n    }\\n\\n    function Uint96(uint256 x) internal pure returns (uint96) {\\n        require(x <= type(uint96).max);\\n        return uint96(x);\\n    }\\n\\n    function Uint128(uint256 x) internal pure returns (uint128) {\\n        require(x <= type(uint128).max);\\n        return uint128(x);\\n    }\\n\\n    function Uint192(uint256 x) internal pure returns (uint192) {\\n        require(x <= type(uint192).max);\\n        return uint192(x);\\n    }\\n\\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\\n    }\\n\\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\\n        return a >= b && a <= mulDown(b, ONE + eps);\\n    }\\n\\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\\n        return a <= b && a >= mulDown(b, ONE - eps);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/libraries/math/LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.0;\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        unchecked {\\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \\\"Invalid exponent\\\");\\n\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, \\\"out of bounds\\\");\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x < 2 ** 255, \\\"x out of bounds\\\");\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, \\\"y out of bounds\\\");\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n                \\\"product out of bounds\\\"\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/StandardizedYield/PYIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"../../interfaces/IPYieldToken.sol\\\";\\nimport \\\"../../interfaces/IPPrincipalToken.sol\\\";\\n\\nimport \\\"./SYUtils.sol\\\";\\nimport \\\"../libraries/math/PMath.sol\\\";\\n\\ntype PYIndex is uint256;\\n\\nlibrary PYIndexLib {\\n    using PMath for uint256;\\n    using PMath for int256;\\n\\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\\n        return PYIndex.wrap(YT.pyIndexCurrent());\\n    }\\n\\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\\n    }\\n\\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\\n    }\\n\\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\\n    }\\n\\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\\n        uint256 _index = PYIndex.unwrap(index);\\n        return SYUtils.syToAssetUp(_index, syAmount);\\n    }\\n\\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\\n    }\\n\\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\\n    }\\n\\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/libraries/MiniHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary MiniHelpers {\\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\\n        return (expiry <= block.timestamp);\\n    }\\n\\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\\n        return (expiry <= blockTime);\\n    }\\n\\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    // BulkSeller\\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error BulkNotMaintainer();\\n    error BulkNotAdmin();\\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\\n    error BulkSellerInvalidToken(address token, address SY);\\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\\n\\n    // APPROX\\n    error ApproxFail();\\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\\n    error ApproxBinarySearchInputInvalid(\\n        uint256 approxGuessMin,\\n        uint256 approxGuessMax,\\n        uint256 minGuessMin,\\n        uint256 maxGuessMax\\n    );\\n\\n    // MARKET + MARKET MATH CORE\\n    error MarketExpired();\\n    error MarketZeroAmountsInput();\\n    error MarketZeroAmountsOutput();\\n    error MarketZeroLnImpliedRate();\\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\\n    error MarketProportionMustNotEqualOne();\\n    error MarketRateScalarBelowZero(int256 rateScalar);\\n    error MarketScalarRootBelowZero(int256 scalarRoot);\\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\\n\\n    error OracleUninitialized();\\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\\n    error OracleZeroCardinality();\\n\\n    error MarketFactoryExpiredPt();\\n    error MarketFactoryInvalidPt();\\n    error MarketFactoryMarketExists();\\n\\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\\n    error MarketFactoryOverriddenFeeTooHigh(uint80 overriddenFee, uint256 marketLnFeeRateRoot);\\n    error MarketFactoryReserveFeePercentTooHigh(uint8 reserveFeePercent, uint8 maxReserveFeePercent);\\n    error MarketFactoryZeroTreasury();\\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\\n    error MFNotPendleMarket(address addr);\\n\\n    // ROUTER\\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\\n\\n    error RouterTimeRangeZero();\\n    error RouterCallbackNotPendleMarket(address caller);\\n    error RouterInvalidAction(bytes4 selector);\\n    error RouterInvalidFacet(address facet);\\n\\n    error RouterKyberSwapDataZero();\\n\\n    error SimulationResults(bool success, bytes res);\\n\\n    // YIELD CONTRACT\\n    error YCExpired();\\n    error YCNotExpired();\\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\\n    error YCNothingToRedeem();\\n    error YCPostExpiryDataNotSet();\\n    error YCNoFloatingSy();\\n\\n    // YieldFactory\\n    error YCFactoryInvalidExpiry();\\n    error YCFactoryYieldContractExisted();\\n    error YCFactoryZeroExpiryDivisor();\\n    error YCFactoryZeroTreasury();\\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\\n\\n    // SY\\n    error SYInvalidTokenIn(address token);\\n    error SYInvalidTokenOut(address token);\\n    error SYZeroDeposit();\\n    error SYZeroRedeem();\\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\\n\\n    // SY-specific\\n    error SYQiTokenMintFailed(uint256 errCode);\\n    error SYQiTokenRedeemFailed(uint256 errCode);\\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\\n\\n    error SYCurveInvalidPid();\\n    error SYCurve3crvPoolNotFound();\\n\\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\\n    error SYBalancerInvalidPid();\\n    error SYInvalidRewardToken(address token);\\n\\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\\n\\n    error SYBalancerReentrancy();\\n\\n    error NotFromTrustedRemote(uint16 srcChainId, bytes path);\\n\\n    error ApxETHNotEnoughBuffer();\\n\\n    // Liquidity Mining\\n    error VCInactivePool(address pool);\\n    error VCPoolAlreadyActive(address pool);\\n    error VCZeroVePendle(address user);\\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\\n    error VCEpochNotFinalized(uint256 wTime);\\n    error VCPoolAlreadyAddAndRemoved(address pool);\\n\\n    error VEInvalidNewExpiry(uint256 newExpiry);\\n    error VEExceededMaxLockTime();\\n    error VEInsufficientLockTime();\\n    error VENotAllowedReduceExpiry();\\n    error VEZeroAmountLocked();\\n    error VEPositionNotExpired();\\n    error VEZeroPosition();\\n    error VEZeroSlope(uint128 bias, uint128 slope);\\n    error VEReceiveOldSupply(uint256 msgTime);\\n\\n    error GCNotPendleMarket(address caller);\\n    error GCNotVotingController(address caller);\\n\\n    error InvalidWTime(uint256 wTime);\\n    error ExpiryInThePast(uint256 expiry);\\n    error ChainNotSupported(uint256 chainId);\\n\\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\\n    error FDEpochLengthMismatch();\\n    error FDInvalidPool(address pool);\\n    error FDPoolAlreadyExists(address pool);\\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\\n    error FDInvalidStartEpoch(uint256 startEpoch);\\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\\n\\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\\n\\n    // Cross-Chain\\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\\n    error MsgNotFromReceiveEndpoint(address sender);\\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\\n    error ApproxDstExecutionGasNotSet();\\n    error InvalidRetryData();\\n\\n    // GENERIC MSG\\n    error ArrayLengthMismatch();\\n    error ArrayEmpty();\\n    error ArrayOutOfBounds();\\n    error ZeroAddress();\\n    error FailedToSendEther();\\n    error InvalidMerkleProof();\\n\\n    error OnlyLayerZeroEndpoint();\\n    error OnlyYT();\\n    error OnlyYCFactory();\\n    error OnlyWhitelisted();\\n\\n    // Swap Aggregator\\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/router/swap-aggregator/IPSwapAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nstruct SwapData {\\n    SwapType swapType;\\n    address extRouter;\\n    bytes extCalldata;\\n    bool needScale;\\n}\\n\\nenum SwapType {\\n    NONE,\\n    KYBERSWAP,\\n    ONE_INCH,\\n    // ETH_WETH not used in Aggregator\\n    ETH_WETH\\n}\\n\\ninterface IPSwapAggregator {\\n    function swap(address tokenIn, uint256 amountIn, SwapData calldata swapData) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/pendle-core-v2-public/contracts/core/StandardizedYield/SYUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary SYUtils {\\n    uint256 internal constant ONE = 1e18;\\n\\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\\n        return (syAmount * exchangeRate) / ONE;\\n    }\\n\\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\\n    }\\n\\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\\n        return (assetAmount * ONE) / exchangeRate;\\n    }\\n\\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pendle-core-v2-public/=lib/pendle-core-v2-public/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"synthetix-v3/=lib/synthetix-v3/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fyde\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_taxModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sTrsy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stratgies\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NoYieldTokenExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"TOKEN_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"createYieldToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositYieldIntoLiquidVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeYieldToStrsy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategiesContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveAssetToLiquidVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveAssetToYieldManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"contract IRelayerV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sTrsy\",\"outputs\":[{\"internalType\":\"contract sTRSY\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_taxModule\",\"type\":\"address\"}],\"name\":\"setTaxModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxModule\",\"outputs\":[{\"internalType\":\"contract ITaxModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenToYieldToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trsy\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeStrategiesContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "YieldManager", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000087cc45fff5c0933bb6af6bae7fc013b7ec7df2ee0000000000000000000000006830c61df103946b63c786e63222c59677f3207800000000000000000000000005198327206123e89c24abd9a482316449bd2aee000000000000000000000000f6bcf96f5bace0241303ee0819e2e009a7f1eb40000000000000000000000000e11df8c0e9b5697bd31515d0fc5f4c9bd71566b9000000000000000000000000a11d02c5ac034786deb0a7ad1dfcfacc0e6de055", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xa11d02c5ac034786deb0a7ad1dfcfacc0e6de055", "SwarmSource": ""}