{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Safe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SegMint Code License 1.1\\npragma solidity 0.8.19;\\n\\nimport { Initializable } from \\\"@openzeppelin/proxy/utils/Initializable.sol\\\";\\nimport { ECDSA } from \\\"solady/src/utils/ECDSA.sol\\\";\\nimport { ISafe } from \\\"./interfaces/ISafe.sol\\\";\\n\\nimport { OwnerManager } from \\\"./managers/OwnerManager.sol\\\";\\nimport { Approvals } from \\\"./handlers/Approvals.sol\\\";\\nimport { MultiCall } from \\\"./handlers/MultiCall.sol\\\";\\n\\nimport { SelfAuthorized } from \\\"./utils/SelfAuthorized.sol\\\";\\nimport { NativeTokenReceiver } from \\\"./utils/NativeTokenReceiver.sol\\\";\\nimport { StandardTokenReceiver } from \\\"./utils/StandardTokenReceiver.sol\\\";\\nimport { TransactionExecutor } from \\\"./utils/TransactionExecutor.sol\\\";\\nimport { TransactionEncoder } from \\\"./utils/TransactionEncoder.sol\\\";\\n\\nimport { Transaction } from \\\"./types/DataTypes.sol\\\";\\n\\n/**\\n * @title Safe\\n * @notice Implements the logic associated with a SegMint Safe.\\n */\\ncontract Safe is\\n    ISafe,\\n    SelfAuthorized,\\n    Initializable,\\n    OwnerManager,\\n    Approvals,\\n    MultiCall,\\n    NativeTokenReceiver,\\n    StandardTokenReceiver,\\n    TransactionExecutor,\\n    TransactionEncoder\\n{\\n    using ECDSA for bytes32;\\n\\n    /// Transaction nonce.\\n    uint256 public nonce;\\n\\n    constructor() {\\n        /// Prevent implementation contract from being initialized.\\n        _disableInitializers();\\n    }\\n\\n    modifier onlyOwners() {\\n        _onlyOwners();\\n        _;\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe\\n     */\\n    function initialize(address[] calldata owners, uint256 quorum) external initializer {\\n        _initOwners(owners, quorum);\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe\\n     * @dev `signatures` must be provided in ascending order from the 'lowest' signer address to the 'highest'.\\n     */\\n    function executeTransaction(Transaction calldata transaction, bytes[] calldata signatures) external onlyOwners {\\n        /// Checks: Ensure a valid number of signatures have been provided.\\n        if (signatures.length < _quorum) revert QuorumNotReached();\\n\\n        /// Checks: Ensure a valid nonce has been provided and update the current nonce.\\n        if (transaction.nonce != nonce++) revert NonceMismatch();\\n\\n        /// Checks: Ensure the transaction is still valid.\\n        if (block.timestamp > transaction.deadline) revert TransactionDeadlinePassed();\\n\\n        /// Get the EIP712 digest of the transaction.\\n        bytes32 txnHash = _encodeTransaction(transaction);\\n\\n        /// Validate the provided signatures and approvals.\\n        _validateSignatures(txnHash, signatures);\\n\\n        /// Execute the transaction.\\n        bool success = _executeTransaction(transaction);\\n        if (success) {\\n            emit TransactionSuccess(txnHash);\\n        } else {\\n            emit TransactionFailed(txnHash);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe\\n     */\\n    function approveTxnHash(bytes32 txnHash) external onlyOwners {\\n        _approveTxnHash(txnHash);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       INTERNAL LOGIC                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to validate the provided signatures and check that each of the recovered\\n     * signers has approved the given transaction hash. By successful execution of this\\n     * function, it should be guaranteed that the quorum value has been met and that all of\\n     * the recovered signers are unique.\\n     */\\n    function _validateSignatures(bytes32 txnHash, bytes[] calldata signatures) internal view {\\n        address lastSigner;\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            /// Cache the signature.\\n            bytes calldata signature = signatures[i];\\n\\n            /// Recover the signer.\\n            /// @dev It should be noted that Solady's {ECDSA.recover} does not allow for failed recovery resulting\\n            /// in the zero address. Short form signatures (EIP-2098) signatures are also not deemed as valid.\\n            address recoveredSigner = txnHash.toEthSignedMessageHash().recover(signature);\\n\\n            /// Checks: Ensure the recovered signer is an owner.\\n            if (!_isOwner(recoveredSigner)) revert SignerNotOwner();\\n\\n            /// Checks: Ensure the recovered signer is greater than the last.\\n            if (recoveredSigner <= lastSigner) revert InvalidSignatureOrder();\\n\\n            /// Checks: Ensure the signer has approved the txn.\\n            if (!_approvedTxns[recoveredSigner][txnHash]) revert SignerHasNotApproved();\\n\\n            /// Update the `lastSigner` and continue iterating.\\n            lastSigner = recoveredSigner;\\n        }\\n    }\\n\\n    /**\\n     * Function used to ensure that the caller is a known owner.\\n     */\\n    function _onlyOwners() internal view {\\n        /// Checks: Ensure `msg.sender` is a known owner.\\n        if (!_isOwner(msg.sender)) revert CallerNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers.\\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note: as of Solady version 0.0.68, these functions will\\n    // revert upon recovery failure for more safety by default.\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signatureLength, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signature.length, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signatureLength, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signature.length, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { Transaction } from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title ISafe\\n * @notice Interface for {Safe}.\\n */\\ninterface ISafe {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERRORS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Thrown when the caller is not a known owner.\\n     */\\n    error CallerNotOwner();\\n\\n    /**\\n     * Thrown when the amount of signatures provided subceeds the quorum value.\\n     */\\n    error QuorumNotReached();\\n\\n    /**\\n     * Thrown when the recovered signer of a signature does not exceed the previously recovered signer.\\n     */\\n    error InvalidSignatureOrder();\\n\\n    /**\\n     * Thrown when the recovered signer of a signature is not a known owner.\\n     */\\n    error SignerNotOwner();\\n\\n    /**\\n     * Thrown when the recovered signer has not approved the txn.\\n     */\\n    error SignerHasNotApproved();\\n\\n    /**\\n     * Thrown when the transaction nonce doesn't match the transaction nonce.\\n     */\\n    error NonceMismatch();\\n\\n    /**\\n     * Thrown when the transaction deadline has passed.\\n     */\\n    error TransactionDeadlinePassed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Emitted when a transaction has successfully executed.\\n     * @param txnHash EIP712 digest of the transaction.\\n     */\\n    event TransactionSuccess(bytes32 txnHash);\\n\\n    /**\\n     * Emitted when a transaction has failed to execute.\\n     * @param txnHash EIP712 digest of the transaction.\\n     */\\n    event TransactionFailed(bytes32 txnHash);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         FUNCTIONS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to initialize a newly created Safe.\\n     * @param owners Array of desired owners.\\n     * @param quorum Number of approvals required to reach quorum.\\n     */\\n    function initialize(address[] calldata owners, uint256 quorum) external;\\n\\n    /**\\n     * Function used to execute a Safe transaction.\\n     * @param transaction Struct containing the transaction parameters.\\n     * @param signatures Signed message digests of the owner approvals.\\n     */\\n    function executeTransaction(Transaction calldata transaction, bytes[] calldata signatures) external;\\n\\n    /**\\n     * Function used to approve a Safe transaction.\\n     * @param txnHash EIP712 digest of the transaction.\\n     */\\n    function approveTxnHash(bytes32 txnHash) external;\\n}\\n\"\r\n    },\r\n    \"src/managers/OwnerManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\nimport { IOwnerManager } from \\\"../interfaces/IOwnerManager.sol\\\";\\nimport { SelfAuthorized } from \\\"../utils/SelfAuthorized.sol\\\";\\n\\n/**\\n * @title OwnerManager\\n * @custom:note Modification of Gnosis Safe's `OwnerManager` to use custom errors.\\n * @custom:reference https://github.com/safe-global/safe-contracts/blob/main/contracts/base/OwnerManager.sol\\n */\\n\\nabstract contract OwnerManager is IOwnerManager, SelfAuthorized {\\n    address internal constant _SENTINEL_VALUE = address(0x01);\\n\\n    /// @dev Linked list of approved owners, `ptrOwner` references the address that points to `owner` in the list.\\n    mapping(address ptrOwner => address owner) internal _owners;\\n\\n    /// Number of owners associated with the Safe.\\n    uint256 internal _ownerCount;\\n\\n    /// Proposal quorum value.\\n    uint256 internal _quorum;\\n\\n    /**\\n     * Function used to initialize the owners associated with a safe.\\n     * @param owners List of intended owners to initialize the safe with.\\n     * @param quorum Number of approvals required to reach quorum.\\n     */\\n    function _initOwners(address[] calldata owners, uint256 quorum) internal {\\n        /// Checks: Ensure owners is non-zero in length.\\n        if (owners.length == 0) revert NoOwnersProvided();\\n\\n        /// Checks: Ensure a valid quorum value has been provided.\\n        if (quorum == 0 || quorum > owners.length) revert InvalidQuorum();\\n\\n        address currentOwner = _SENTINEL_VALUE;\\n\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            address owner = owners[i];\\n\\n            /// forgefmt: disable-next-item\\n            /// Checks: Ensure `owner` is a valid address.\\n            if (\\n                owner == address(0) ||         // not zero address.\\n                owner == _SENTINEL_VALUE ||    // not sentinel value.\\n                owner == address(this) ||      // not self.\\n                currentOwner == owner         // not concurrent index duplicate.\\n            ) revert InvalidOwner();\\n\\n            /// Checks: Ensure `owner` is not already an authorized owner.\\n            if (_owners[owner] != address(0)) revert DuplicateOwner();\\n\\n            _owners[currentOwner] = owner;\\n            currentOwner = owner;\\n        }\\n\\n        _owners[currentOwner] = _SENTINEL_VALUE;\\n        _ownerCount = owners.length;\\n        _quorum = quorum;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function addOwner(address newOwner, uint256 newQuorum) public selfAuthorized {\\n        /// Checks: Ensure `owner` is a valid address.\\n        if (newOwner == address(0) || newOwner == _SENTINEL_VALUE || newOwner == address(this)) revert InvalidOwner();\\n\\n        /// Checks: Ensure `owner` is not already an authorized owner.\\n        if (_owners[newOwner] != address(0)) revert DuplicateOwner();\\n\\n        _owners[newOwner] = _owners[_SENTINEL_VALUE];\\n        _owners[_SENTINEL_VALUE] = newOwner;\\n        _ownerCount++;\\n\\n        /// Emit event after owner address has been set in storage and count has been updated.\\n        emit OwnerAdded({ account: newOwner });\\n\\n        if (_quorum != newQuorum) {\\n            changeQuorum(newQuorum);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function removeOwner(address pointerOwner, address oldOwner, uint256 newQuorum) public selfAuthorized {\\n        if (newQuorum > _ownerCount - 1) revert RemovalBreaksQuorum();\\n        if (oldOwner == address(0) || oldOwner == _SENTINEL_VALUE) revert InvalidOwner();\\n        if (_owners[pointerOwner] != oldOwner) revert InvalidPointer();\\n\\n        _owners[pointerOwner] = _owners[oldOwner];\\n        _owners[oldOwner] = address(0);\\n        _ownerCount--;\\n\\n        /// Emit event after owner address has been cleared in storage and count has been updated.\\n        emit OwnerRemoved({ account: oldOwner });\\n\\n        if (_quorum != newQuorum) {\\n            changeQuorum(newQuorum);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function swapOwner(address pointerOwner, address oldOwner, address newOwner) public selfAuthorized {\\n        // Owner address cannot be null, the sentinel or the Safe itself.\\n        if (newOwner == address(0) || newOwner == _SENTINEL_VALUE || newOwner == address(this)) revert InvalidOwner();\\n\\n        // No duplicate owners allowed.\\n        if (_owners[newOwner] != address(0)) revert DuplicateOwner();\\n\\n        // Validate oldOwner address and check that it corresponds to owner index.\\n        if (oldOwner == address(0) || oldOwner == _SENTINEL_VALUE) revert InvalidOwner();\\n        if (_owners[pointerOwner] != oldOwner) revert PointerMismatch();\\n\\n        _owners[newOwner] = _owners[oldOwner];\\n        _owners[pointerOwner] = newOwner;\\n        _owners[oldOwner] = address(0);\\n\\n        emit OwnerSwapped(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function changeQuorum(uint256 newQuorum) public selfAuthorized {\\n        /// Checks: Ensure the new quorum value is neither 0 or greater than the owner count.\\n        if (newQuorum == 0 || newQuorum > _ownerCount) revert InvalidQuorum();\\n\\n        uint256 oldQuorum = _quorum;\\n        _quorum = newQuorum;\\n\\n        emit QuorumChanged(oldQuorum, newQuorum);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       VIEW FUNCTIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function getOwners() public view returns (address[] memory) {\\n        address[] memory safeOwners = new address[](_ownerCount);\\n\\n        uint256 idx = 0;\\n        address currentOwner = _owners[_SENTINEL_VALUE];\\n\\n        while (currentOwner != _SENTINEL_VALUE) {\\n            safeOwners[idx] = currentOwner;\\n            currentOwner = _owners[currentOwner];\\n            idx++;\\n        }\\n\\n        return safeOwners;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return _isOwner(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function ownerCount() public view returns (uint256) {\\n        return _ownerCount;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwnerManager\\n     */\\n    function getQuorum() public view returns (uint256) {\\n        return _quorum;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       INTERNAL LOGIC                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function _isOwner(address account) internal view returns (bool) {\\n        return account != _SENTINEL_VALUE && _owners[account] != address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/handlers/Approvals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SegMint Code License 1.1\\npragma solidity 0.8.19;\\n\\nimport { IApprovals } from \\\"../interfaces/IApprovals.sol\\\";\\n\\n/**\\n * @title Approvals\\n * @notice Handles transaction approvals.\\n */\\nabstract contract Approvals is IApprovals {\\n    /// Mapping that keeps track of which accounts have approved which transactions.\\n    mapping(address account => mapping(bytes32 txnHash => bool approved)) internal _approvedTxns;\\n\\n    /**\\n     * @inheritdoc IApprovals\\n     */\\n    function hasApprovedTxn(address account, bytes32 txnHash) external view returns (bool) {\\n        return _approvedTxns[account][txnHash];\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       INTERNAL LOGIC                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to approve a transaction hash.\\n     */\\n    function _approveTxnHash(bytes32 txnHash) internal {\\n        _approvedTxns[msg.sender][txnHash] = true;\\n        emit TxnApproved({ account: msg.sender, txnHash: txnHash });\\n    }\\n}\\n\"\r\n    },\r\n    \"src/handlers/MultiCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { SelfAuthorized } from \\\"../utils/SelfAuthorized.sol\\\";\\n\\n/**\\n * @title MultiCall\\n * @notice Used to batch multiple nonpayable calls in a single transaction.\\n */\\nabstract contract MultiCall is SelfAuthorized {\\n    /**\\n     * Thrown when the `targets` and `payloads` array are not equal in length.\\n     */\\n    error ArrayLengthMismatch();\\n\\n    /**\\n     * Thrown when a call fails.\\n     */\\n    error CallFailed();\\n\\n    /**\\n     * Emitted when a call is successfully made to a target.\\n     */\\n    event CallSuccess(address indexed target, bytes payload);\\n\\n    /**\\n     * Function used to execute an array of payloads to an array of targets.\\n     * @param targets Array of addresses to call.\\n     * @param payloads Array of calldata to forward to each target address.\\n     */\\n    function multicall(address[] calldata targets, bytes[] calldata payloads) public selfAuthorized {\\n        if (targets.length != payloads.length) revert ArrayLengthMismatch();\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            address target = targets[i];\\n            bytes calldata payload = payloads[i];\\n\\n            (bool success,) = target.call(payload);\\n            if (!success) revert CallFailed();\\n\\n            emit CallSuccess(target, payload);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/SelfAuthorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n/**\\n * @title SelfAuthorized\\n * @notice From Gnosis Safe's `SelfAuthorized`.\\n * https://github.com/safe-global/safe-contracts/blob/main/contracts/common/SelfAuthorized.sol\\n */\\nabstract contract SelfAuthorized {\\n    /**\\n     * Thrown when the caller is not the address itself.\\n     */\\n    error CallerNotSelf();\\n\\n    function _sanityCheck() private view {\\n        /// Checks: Ensure the caller is the address itself.\\n        if (msg.sender != address(this)) revert CallerNotSelf();\\n    }\\n\\n    modifier selfAuthorized() {\\n        _sanityCheck();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/NativeTokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n/**\\n * @title NativeTokenReceiver\\n * @notice Enables the inheriting contract to receive the chain native token.\\n */\\nabstract contract NativeTokenReceiver {\\n    /**\\n     * Emitted when native token is received.\\n     * @param sender Sender of the native token.\\n     * @param amount Amount of native token received.\\n     */\\n    event NativeTokenReceived(address sender, uint256 amount);\\n\\n    receive() external payable {\\n        emit NativeTokenReceived(msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/StandardTokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n/**\\n * @title StandardTokenReceiver\\n * @notice Allows the receival of ERC721 and ERC1155 tokens that are sent using\\n * either `safeTransferFrom` or `safeBatchTransferFrom`.\\n */\\nabstract contract StandardTokenReceiver {\\n    /**\\n     * Handles {ERC721.safeTransferFrom} callback.\\n     */\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * Handles {ERC155.safeTransferFrom} callback.\\n     */\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    /**\\n     * Handles {ERC155.safeBatchTransferFrom} callback.\\n     */\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\\n        external\\n        pure\\n        returns (bytes4)\\n    {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/TransactionExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SegMint Code License 1.1\\npragma solidity 0.8.19;\\n\\nimport { Operation, Transaction } from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title TransactionExecutor\\n * @notice Used to execute transactions.\\n */\\nabstract contract TransactionExecutor {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       INTERNAL LOGIC                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to execute a Safe transaction.\\n     */\\n    function _executeTransaction(Transaction memory transaction) internal returns (bool success) {\\n        if (transaction.operation == Operation.CALL) {\\n            (success,) = transaction.to.call{ value: transaction.value }(transaction.data);\\n        } else {\\n            (success,) = transaction.to.delegatecall(transaction.data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/TransactionEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SegMint Code License 1.1\\npragma solidity 0.8.19;\\n\\nimport { EIP712 } from \\\"solady/src/utils/EIP712.sol\\\";\\nimport { ITransactionEncoder } from \\\"../interfaces/ITransactionEncoder.sol\\\";\\nimport { Transaction } from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title TransactionEncoder\\n * @notice Encodes a `Transaction` struct in accordance with EIP712.\\n */\\nabstract contract TransactionEncoder is ITransactionEncoder, EIP712 {\\n    /// @dev keccak256(\\\"Transaction(uint8 operation,address to,uint256 value,bytes data,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _TRANSACTION_TYPEHASH = 0x33b543d6d88a9ae409adf21994caa4f1fb2caa001d13be022d6bf4a3a5afc01d;\\n\\n    /**\\n     * @inheritdoc ITransactionEncoder\\n     */\\n    function encodeTransaction(Transaction memory transaction) public view returns (bytes32) {\\n        return _encodeTransaction(transaction);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       INTERNAL LOGIC                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to return the EIP712 digest of a `Transaction` struct.\\n     */\\n    function _encodeTransaction(Transaction memory transaction) internal view returns (bytes32) {\\n        return _hashTypedData(\\n            keccak256(\\n                abi.encodePacked(\\n                    _TRANSACTION_TYPEHASH,\\n                    transaction.operation,\\n                    transaction.to,\\n                    transaction.value,\\n                    keccak256(transaction.data),\\n                    transaction.nonce,\\n                    transaction.deadline\\n                )\\n            )\\n        );\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EIP712                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Overriden as required in Solady EIP712 documentation.\\n     */\\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\\n        name = \\\"SegMint Safe\\\";\\n        version = \\\"1.0\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\n/**\\n * Enum encapsulating the types of calls that can be made with a safe.\\n */\\nenum Operation {\\n    CALL,\\n    DELEGATECALL\\n}\\n\\n/**\\n * Struct encapsulating the types associated with a transaction call.\\n * @param operation {Operation} Enum value.\\n * @param to Address that the call will be made too.\\n * @param value Amount of native token to provide with the call.\\n * @param data Calldata to associate with the call.\\n * @param nonce Safe nonce to associate with the call.\\n * @param deadline Timestamp by which the transaction is valid until.\\n */\\nstruct Transaction {\\n    Operation operation;\\n    address to;\\n    uint256 value;\\n    bytes data;\\n    uint256 nonce;\\n    uint256 deadline;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOwnerManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IOwnerManager\\n * @notice Interface for {OwnerManager}.\\n */\\ninterface IOwnerManager {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERRORS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Thrown when trying to add a owner that is deemed as invalid.\\n     */\\n    error InvalidOwner();\\n\\n    /**\\n     * Thrown when attempting to add a owner that already exists.\\n     */\\n    error DuplicateOwner();\\n\\n    /**\\n     * Thrown when the newly proposed quorum value exceeds the number of owners.\\n     */\\n    error RemovalBreaksQuorum();\\n\\n    /**\\n     * Thrown when the pointer owner does point to the expected owner.\\n     */\\n    error InvalidPointer();\\n\\n    /**\\n     * Thrown when the pointer owner does not match the expected owner.\\n     */\\n    error PointerMismatch();\\n\\n    /**\\n     * Thrown when an invalid quorum value is provided.\\n     */\\n    error InvalidQuorumValue();\\n\\n    /**\\n     * Thrown when no owners have been provided during initialization.\\n     */\\n    error NoOwnersProvided();\\n\\n    /**\\n     * Thrown when an invalid quorum value is proposed.\\n     */\\n    error InvalidQuorum();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Emitted when a new owner is added.\\n     * @param account Address of the newly added owner.\\n     */\\n    event OwnerAdded(address account);\\n\\n    /**\\n     * Emitted when an owner is removed.\\n     * @param account Address of the removed owner.\\n     */\\n    event OwnerRemoved(address account);\\n\\n    /**\\n     * Emitted when an owner is swapped.\\n     * @param oldOwner Address of the owner being swapped out.\\n     * @param newOwner Address of the owner being swapped in.\\n     */\\n    event OwnerSwapped(address oldOwner, address newOwner);\\n\\n    /**\\n     * Emitted when the quorum value is modified.\\n     * @param oldQuorum Old quorum value.\\n     * @param newQuorum New quorum value.\\n     */\\n    event QuorumChanged(uint256 oldQuorum, uint256 newQuorum);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         FUNCTIONS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to add a owner and update the quorum value.\\n     * @param newOwner Address of the new owner to be added.\\n     * @param quorumValue Number of owner approvals to reach quorum on a proposal.\\n     */\\n    function addOwner(address newOwner, uint256 quorumValue) external;\\n\\n    /**\\n     * Function used to remove a owner and update the quorum value.\\n     * @param pointerOwner Signer address that points to `owner` in the linked list.\\n     * @param owner Address of the owner to be removed.\\n     * @param quorumValue Number of owner approvals to reach quorum on a proposal.\\n     */\\n    function removeOwner(address pointerOwner, address owner, uint256 quorumValue) external;\\n\\n    /**\\n     * Function used to swap `oldOwner` with `newOwner` and update the quorum value.\\n     * @param pointerOwner Signer address that points to `owner` in the linked list.\\n     * @param oldOwner Address of the old owner to be removed.\\n     * @param newOwner Address of the new owner to be added.\\n     */\\n    function swapOwner(address pointerOwner, address oldOwner, address newOwner) external;\\n\\n    /**\\n     * Function used to update the quorum value.\\n     * @param quorumValue New number of approvals required to reach quorum on a proposal.\\n     */\\n    function changeQuorum(uint256 quorumValue) external;\\n\\n    /**\\n     * Function used to view all the approved owners of a Safe.\\n     */\\n    function getOwners() external view returns (address[] memory);\\n\\n    /**\\n     * Function used to view if `account` is an approved owner.\\n     */\\n    function isOwner(address account) external view returns (bool);\\n\\n    /**\\n     * Function used to view the current number of owners.\\n     */\\n    function ownerCount() external view returns (uint256);\\n\\n    /**\\n     * Function used to view the current quorum value.\\n     */\\n    function getQuorum() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IApprovals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IApprovals\\n * @notice Interface for {Approvals}.\\n */\\ninterface IApprovals {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Emitted when a transaction is approved.\\n     * @param account Address which made the approval.\\n     * @param txnHash EIP712 digest of the transaction.\\n     */\\n    event TxnApproved(address indexed account, bytes32 txnHash);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         FUNCTIONS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to check if account has approved a transaction hash.\\n     * @param account Address to check transaction approval of.\\n     * @param txnHash EIP712 digest of the transaction.\\n     */\\n    function hasApprovedTxn(address account, bytes32 txnHash) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n/// Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    address private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = address(this);\\n        _cachedChainId = block.chainid;\\n\\n        (string memory name, string memory version) = _domainNameAndVersion();\\n        bytes32 nameHash = keccak256(bytes(name));\\n        bytes32 versionHash = keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    function _domainNameAndVersion()\\n        internal\\n        pure\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        separator = _cachedDomainSeparator;\\n        if (_cachedDomainSeparatorInvalidated()) {\\n            separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        bytes32 separator = _cachedDomainSeparator;\\n        if (_cachedDomainSeparatorInvalidated()) {\\n            separator = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, separator) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        bytes32 nameHash = _cachedNameHash;\\n        bytes32 versionHash = _cachedVersionHash;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        address cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITransactionEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { Transaction } from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title ITransactionEncoder\\n * @notice Interface for {TransactionEncoder}.\\n */\\ninterface ITransactionEncoder {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         FUNCTIONS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /**\\n     * Function used to encode a `Transaction` struct and return the EIP712 digest.\\n     * @param transaction `Transaction` struct.\\n     */\\n    function encodeTransaction(Transaction memory transaction) external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DuplicateOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPointer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuorum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuorumValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOwnersProvided\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PointerMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuorumNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RemovalBreaksQuorum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerHasNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionDeadlinePassed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"CallSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeTokenReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"QuorumChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"TxnApproved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"approveTxnHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"changeQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Transaction\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"encodeTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Transaction\",\"name\":\"transaction\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"hasApprovedTxn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointerOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointerOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"swapOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Safe", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}