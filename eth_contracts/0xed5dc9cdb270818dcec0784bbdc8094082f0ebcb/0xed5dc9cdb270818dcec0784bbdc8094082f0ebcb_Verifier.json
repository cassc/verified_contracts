{"SourceCode": "// SPDX-License-Identifier: AML\r\n//\r\n// Copyright 2017 Christian Reitwiessner\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n// IN THE SOFTWARE.\r\n\r\n// 2019 OKIMS\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Pairing {\r\n\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct G1Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n\r\n    // Encoding of field elements is: X[0] * z + X[1]\r\n    struct G2Point {\r\n        uint256[2] X;\r\n        uint256[2] Y;\r\n    }\r\n\r\n    /*\r\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\r\n     */\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n\r\n        // The prime q in the base field F_q for G1\r\n        if (p.X == 0 && p.Y == 0) {\r\n            return G1Point(0, 0);\r\n        } else {\r\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @return The sum of two points of G1\r\n     */\r\n    function plus(\r\n        G1Point memory p1,\r\n        G1Point memory p2\r\n    ) internal view returns (G1Point memory r) {\r\n\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-add-failed\");\r\n    }\r\n\r\n\r\n    /*\r\n     * Same as plus but accepts raw input instead of struct\r\n     * @return The sum of two points of G1, one is represented as array\r\n     */\r\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 {invalid()}\r\n        }\r\n\r\n        require(success, \"pairing-add-failed\");\r\n    }\r\n\r\n    /*\r\n     * @return The product of a point on G1 and a scalar, i.e.\r\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\r\n     *         points p.\r\n     */\r\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\r\n\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require (success,\"pairing-mul-failed\");\r\n    }\r\n\r\n\r\n    /*\r\n     * Same as scalar_mul but accepts raw input instead of struct,\r\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\r\n     */\r\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 {invalid()}\r\n        }\r\n        require(success, \"pairing-mul-failed\");\r\n    }\r\n\r\n    /* @return The result of computing the pairing check\r\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n     *         For example,\r\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\r\n     */\r\n    function pairing(\r\n        G1Point memory a1,\r\n        G2Point memory a2,\r\n        G1Point memory b1,\r\n        G2Point memory b2,\r\n        G1Point memory c1,\r\n        G2Point memory c2,\r\n        G1Point memory d1,\r\n        G2Point memory d2\r\n    ) internal view returns (bool) {\r\n\r\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\r\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\r\n        uint256 inputSize = 24;\r\n        uint256[] memory input = new uint256[](inputSize);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 j = i * 6;\r\n            input[j + 0] = p1[i].X;\r\n            input[j + 1] = p1[i].Y;\r\n            input[j + 2] = p2[i].X[0];\r\n            input[j + 3] = p2[i].X[1];\r\n            input[j + 4] = p2[i].Y[0];\r\n            input[j + 5] = p2[i].Y[1];\r\n        }\r\n\r\n        uint256[1] memory out;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-opcode-failed\");\r\n\r\n        return out[0] != 0;\r\n    }\r\n}\r\n\r\ncontract Verifier {\r\n\r\n    using Pairing for *;\r\n\r\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct VerifyingKey {\r\n        Pairing.G1Point alfa1;\r\n        Pairing.G2Point beta2;\r\n        Pairing.G2Point gamma2;\r\n        Pairing.G2Point delta2;\r\n        // []G1Point IC (K in gnark) appears directly in verifyProof\r\n    }\r\n\r\n    struct Proof {\r\n        Pairing.G1Point A;\r\n        Pairing.G2Point B;\r\n        Pairing.G1Point C;\r\n    }\r\n\r\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\r\n        vk.alfa1 = Pairing.G1Point(uint256(20491192805390485299153009773594534940189261866228447918068658471970481763042), uint256(9383485363053290200918347156157836566562967994039712273449902621266178545958));\r\n        vk.beta2 = Pairing.G2Point([uint256(4252822878758300859123897981450591353533073413197771768651442665752259397132), uint256(6375614351688725206403948262868962793625744043794305715222011528459656738731)], [uint256(21847035105528745403288232691147584728191162732299865338377159692350059136679), uint256(10505242626370262277552901082094356697409835680220590971873171140371331206856)]);\r\n        vk.gamma2 = Pairing.G2Point([uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634), uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781)], [uint256(4082367875863433681332203403145435568316851327593401208105741076214120093531), uint256(8495653923123431417604973247489272438418190587263600148770280649306958101930)]);\r\n        vk.delta2 = Pairing.G2Point([uint256(15957309824529629063789387503022281134914545869068808343398269313872376747902), uint256(21088846403694384787456339107878932194943621194992970909891089464885485970071)], [uint256(7573109104231341089207612173444896635507348069577028937579046603911609986008), uint256(6054035969289747855363354935222431463449323486093846586557007948807905262216)]);\r\n    }\r\n\r\n\r\n    // accumulate scalarMul(mul_input) into q\r\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\r\n    function accumulate(\r\n        uint256[3] memory mul_input,\r\n        Pairing.G1Point memory p,\r\n        uint256[4] memory buffer,\r\n        Pairing.G1Point memory q\r\n    ) internal view {\r\n        // computes p = mul_input[0:2] * mul_input[3]\r\n        Pairing.scalar_mul_raw(mul_input, p);\r\n\r\n        // point addition inputs\r\n        buffer[0] = q.X;\r\n        buffer[1] = q.Y;\r\n        buffer[2] = p.X;\r\n        buffer[3] = p.Y;\r\n\r\n        // q = p + q\r\n        Pairing.plus_raw(buffer, q);\r\n    }\r\n\r\n    /*\r\n     * @returns Whether the proof is valid given the hardcoded verifying key\r\n     *          above and the public inputs\r\n     */\r\n    function verifyProof(\r\n        uint256[2] memory a,\r\n        uint256[2][2] memory b,\r\n        uint256[2] memory c,\r\n        uint256[1] calldata input\r\n    ) public view returns (bool r) {\r\n\r\n        Proof memory proof;\r\n        proof.A = Pairing.G1Point(a[0], a[1]);\r\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\r\n        proof.C = Pairing.G1Point(c[0], c[1]);\r\n\r\n        // Make sure that proof.A, B, and C are each less than the prime q\r\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\r\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\r\n\r\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\r\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\r\n\r\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\r\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\r\n\r\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\r\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\r\n\r\n        // Make sure that every input is less than the snark scalar field\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\r\n        }\r\n\r\n        VerifyingKey memory vk = verifyingKey();\r\n\r\n        // Compute the linear combination vk_x\r\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\r\n\r\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\r\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\r\n        uint256[4] memory add_input;\r\n\r\n        // Buffer reused for multiplication p1 * s\r\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\r\n        uint256[3] memory mul_input;\r\n\r\n        // temporary point to avoid extra allocations in accumulate\r\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\r\n\r\n        vk_x.X = uint256(12669601960876154050979008760459271652274048136473627319884033059609265504932); // vk.K[0].X\r\n        vk_x.Y = uint256(5077825442666188450678039778731633842068475207260287428845938171984029124889); // vk.K[0].Y\r\n        mul_input[0] = uint256(11698127579692750089626539987688368781746070835963853370400614920920295929258); // vk.K[1].X\r\n        mul_input[1] = uint256(14804988182516733323196578006261973296323149932829466089226370705585880147003); // vk.K[1].Y\r\n        mul_input[2] = input[0];\r\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\r\n\r\n        return Pairing.pairing(\r\n            Pairing.negate(proof.A),\r\n            proof.B,\r\n            vk.alfa1,\r\n            vk.beta2,\r\n            vk_x,\r\n            vk.gamma2,\r\n            proof.C,\r\n            vk.delta2\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[1]\",\"name\":\"input\",\"type\":\"uint256[1]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Verifier", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d5611aa93da8137aad55c461b5ec8d176af89fdb5eb51ad44bd3322bcb64baa9"}