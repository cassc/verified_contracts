{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/openzeppelin/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/FeeProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./dependencies/openzeppelin/proxy/utils/Initializable.sol\\\";\\nimport \\\"./storage/FeeProviderStorage.sol\\\";\\nimport \\\"./lib/WadRayMath.sol\\\";\\n\\nerror SenderIsNotGovernor();\\nerror PoolRegistryIsNull();\\nerror EscrowMETIsNull();\\nerror NewValueIsSameAsCurrent();\\nerror FeeIsGreaterThanTheMax();\\nerror TierDiscountTooHigh();\\nerror TiersNotOrderedByMin();\\n\\n/**\\n * @title FeeProvider contract\\n */\\ncontract FeeProvider is Initializable, FeeProviderStorageV1 {\\n    using WadRayMath for uint256;\\n\\n    string public constant VERSION = \\\"1.1.0\\\";\\n\\n    uint256 internal constant MAX_FEE_VALUE = 0.25e18; // 25%\\n    uint256 internal constant MAX_FEE_DISCOUNT = 1e18; // 100%\\n\\n    /// @notice Emitted when deposit fee is updated\\n    event DepositFeeUpdated(uint256 oldDepositFee, uint256 newDepositFee);\\n\\n    /// @notice Emitted when issue fee is updated\\n    event IssueFeeUpdated(uint256 oldIssueFee, uint256 newIssueFee);\\n\\n    /// @notice Emitted when liquidator incentive is updated\\n    event LiquidatorIncentiveUpdated(uint256 oldLiquidatorIncentive, uint256 newLiquidatorIncentive);\\n\\n    /// @notice Emitted when protocol liquidation fee is updated\\n    event ProtocolLiquidationFeeUpdated(uint256 oldProtocolLiquidationFee, uint256 newProtocolLiquidationFee);\\n\\n    /// @notice Emitted when repay fee is updated\\n    event RepayFeeUpdated(uint256 oldRepayFee, uint256 newRepayFee);\\n\\n    /// @notice Emitted when swap fee is updated\\n    event SwapDefaultFeeUpdated(uint256 oldSwapFee, uint256 newSwapFee);\\n\\n    /// @notice Emitted when tiers are updated\\n    event TiersUpdated(Tier[] oldTiers, Tier[] newTiers);\\n\\n    /// @notice Emitted when withdraw fee is updated\\n    event WithdrawFeeUpdated(uint256 oldWithdrawFee, uint256 newWithdrawFee);\\n\\n    /**\\n     * @notice Throws if caller isn't the governor\\n     */\\n    modifier onlyGovernor() {\\n        if (msg.sender != poolRegistry.governor()) revert SenderIsNotGovernor();\\n        _;\\n    }\\n\\n    function initialize(IPoolRegistry poolRegistry_, IESMET esMET_) public initializer {\\n        if (address(poolRegistry_) == address(0)) revert PoolRegistryIsNull();\\n        if (address(esMET_) == address(0)) revert EscrowMETIsNull();\\n\\n        poolRegistry = poolRegistry_;\\n        esMET = esMET_;\\n\\n        liquidationFees = LiquidationFees({\\n            liquidatorIncentive: 1e17, // 10%\\n            protocolFee: 8e16 // 8%\\n        });\\n        defaultSwapFee = 25e14; // 0.25%\\n    }\\n\\n    /**\\n     * @notice Get fee discount tiers\\n     */\\n    function getTiers() external view returns (Tier[] memory _tiers) {\\n        return tiers;\\n    }\\n\\n    /**\\n     * @notice Get the swap fee for a given account\\n     * Fee discount are applied on top of the default swap fee depending on user's esMET balance\\n     * @param account_ The account address\\n     * @return _swapFee The account's swap fee\\n     */\\n    function swapFeeFor(address account_) external view override returns (uint256 _swapFee) {\\n        uint256 _len = tiers.length;\\n\\n        if (_len == 0) {\\n            return defaultSwapFee;\\n        }\\n\\n        uint256 _balance = esMET.balanceOf(account_);\\n\\n        if (_balance < tiers[0].min) {\\n            return defaultSwapFee;\\n        }\\n\\n        uint256 i = 1;\\n        while (i < _len) {\\n            if (_balance < tiers[i].min) {\\n                unchecked {\\n                    // Note: `discount` is always <= `1e18`\\n                    return defaultSwapFee.wadMul(1e18 - tiers[i - 1].discount);\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        unchecked {\\n            // Note: `discount` is always <= `1e18`\\n            return defaultSwapFee.wadMul(1e18 - tiers[_len - 1].discount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update deposit fee\\n     */\\n    function updateDepositFee(uint256 newDepositFee_) external onlyGovernor {\\n        if (newDepositFee_ > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        uint256 _currentDepositFee = depositFee;\\n        if (newDepositFee_ == _currentDepositFee) revert NewValueIsSameAsCurrent();\\n        emit DepositFeeUpdated(_currentDepositFee, newDepositFee_);\\n        depositFee = newDepositFee_;\\n    }\\n\\n    /**\\n     * @notice Update issue fee\\n     */\\n    function updateIssueFee(uint256 newIssueFee_) external onlyGovernor {\\n        if (newIssueFee_ > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        uint256 _currentIssueFee = issueFee;\\n        if (newIssueFee_ == _currentIssueFee) revert NewValueIsSameAsCurrent();\\n        emit IssueFeeUpdated(_currentIssueFee, newIssueFee_);\\n        issueFee = newIssueFee_;\\n    }\\n\\n    /**\\n     * @notice Update liquidator incentive\\n     * @dev liquidatorIncentive + protocolFee can't surpass max\\n     */\\n    function updateLiquidatorIncentive(uint128 newLiquidatorIncentive_) external onlyGovernor {\\n        LiquidationFees memory _current = liquidationFees;\\n        if (newLiquidatorIncentive_ + _current.protocolFee > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        if (newLiquidatorIncentive_ == _current.liquidatorIncentive) revert NewValueIsSameAsCurrent();\\n        emit LiquidatorIncentiveUpdated(_current.liquidatorIncentive, newLiquidatorIncentive_);\\n        liquidationFees.liquidatorIncentive = newLiquidatorIncentive_;\\n    }\\n\\n    /**\\n     * @notice Update protocol liquidation fee\\n     * @dev liquidatorIncentive + protocolFee can't surpass max\\n     */\\n    function updateProtocolLiquidationFee(uint128 newProtocolLiquidationFee_) external onlyGovernor {\\n        LiquidationFees memory _current = liquidationFees;\\n        if (newProtocolLiquidationFee_ + _current.liquidatorIncentive > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        if (newProtocolLiquidationFee_ == _current.protocolFee) revert NewValueIsSameAsCurrent();\\n        emit ProtocolLiquidationFeeUpdated(_current.protocolFee, newProtocolLiquidationFee_);\\n        liquidationFees.protocolFee = newProtocolLiquidationFee_;\\n    }\\n\\n    /**\\n     * @notice Update repay fee\\n     */\\n    function updateRepayFee(uint256 newRepayFee_) external onlyGovernor {\\n        if (newRepayFee_ > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        uint256 _currentRepayFee = repayFee;\\n        if (newRepayFee_ == _currentRepayFee) revert NewValueIsSameAsCurrent();\\n        emit RepayFeeUpdated(_currentRepayFee, newRepayFee_);\\n        repayFee = newRepayFee_;\\n    }\\n\\n    /**\\n     * @notice Update swap fee\\n     */\\n    function updateDefaultSwapFee(uint256 newDefaultSwapFee_) external onlyGovernor {\\n        if (newDefaultSwapFee_ > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        uint256 _current = defaultSwapFee;\\n        if (newDefaultSwapFee_ == _current) revert NewValueIsSameAsCurrent();\\n        emit SwapDefaultFeeUpdated(_current, newDefaultSwapFee_);\\n        defaultSwapFee = newDefaultSwapFee_;\\n    }\\n\\n    /**\\n     * @notice Update fee discount tiers\\n     */\\n    function updateTiers(Tier[] memory tiers_) external onlyGovernor {\\n        emit TiersUpdated(tiers, tiers_);\\n        delete tiers;\\n\\n        uint256 _len = tiers_.length;\\n        for (uint256 i; i < _len; ++i) {\\n            Tier memory _tier = tiers_[i];\\n            if (_tier.discount > MAX_FEE_DISCOUNT) revert TierDiscountTooHigh();\\n            if (i > 0 && tiers_[i - 1].min > _tier.min) revert TiersNotOrderedByMin();\\n            tiers.push(_tier);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update withdraw fee\\n     */\\n    function updateWithdrawFee(uint256 newWithdrawFee_) external onlyGovernor {\\n        if (newWithdrawFee_ > MAX_FEE_VALUE) revert FeeIsGreaterThanTheMax();\\n        uint256 _currentWithdrawFee = withdrawFee;\\n        if (newWithdrawFee_ == _currentWithdrawFee) revert NewValueIsSameAsCurrent();\\n        emit WithdrawFeeUpdated(_currentWithdrawFee, newWithdrawFee_);\\n        withdrawFee = newWithdrawFee_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IESMET.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\ninterface IESMET {\\n    function balanceOf(address account_) external view returns (uint256);\\n\\n    function lock(uint256 amount_, uint256 lockPeriod_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IMasterOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\ninterface IMasterOracle {\\n    function quoteTokenToUsd(address _asset, uint256 _amount) external view returns (uint256 _amountInUsd);\\n\\n    function quoteUsdToToken(address _asset, uint256 _amountInUsd) external view returns (uint256 _amount);\\n\\n    function quote(address _assetIn, address _assetOut, uint256 _amountIn) external view returns (uint256 _amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./ISyntheticToken.sol\\\";\\n\\ninterface IDebtToken is IERC20Metadata {\\n    function lastTimestampAccrued() external view returns (uint256);\\n\\n    function isActive() external view returns (bool);\\n\\n    function syntheticToken() external view returns (ISyntheticToken);\\n\\n    function accrueInterest() external;\\n\\n    function debtIndex() external returns (uint256 debtIndex_);\\n\\n    function burn(address from_, uint256 amount_) external;\\n\\n    function issue(uint256 amount_, address to_) external returns (uint256 _issued, uint256 _fee);\\n\\n    function flashIssue(address borrower_, uint256 amount_) external returns (uint256 _issued, uint256 _fee);\\n\\n    function repay(address onBehalfOf_, uint256 amount_) external returns (uint256 _repaid, uint256 _fee);\\n\\n    function repayAll(address onBehalfOf_) external returns (uint256 _repaid, uint256 _fee);\\n\\n    function quoteIssueIn(uint256 amountToIssue_) external view returns (uint256 _amount, uint256 _fee);\\n\\n    function quoteIssueOut(uint256 amount_) external view returns (uint256 _amountToIssue, uint256 _fee);\\n\\n    function quoteRepayIn(uint256 amountToRepay_) external view returns (uint256 _amount, uint256 _fee);\\n\\n    function quoteRepayOut(uint256 amount_) external view returns (uint256 _amountToRepay, uint256 _fee);\\n\\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external;\\n\\n    function updateInterestRate(uint256 newInterestRate_) external;\\n\\n    function maxTotalSupply() external view returns (uint256);\\n\\n    function interestRate() external view returns (uint256);\\n\\n    function interestRatePerSecond() external view returns (uint256);\\n\\n    function toggleIsActive() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @notice FeeProvider interface\\n */\\ninterface IFeeProvider {\\n    struct LiquidationFees {\\n        uint128 liquidatorIncentive;\\n        uint128 protocolFee;\\n    }\\n\\n    function defaultSwapFee() external view returns (uint256);\\n\\n    function depositFee() external view returns (uint256);\\n\\n    function issueFee() external view returns (uint256);\\n\\n    function liquidationFees() external view returns (uint128 liquidatorIncentive, uint128 protocolFee);\\n\\n    function repayFee() external view returns (uint256);\\n\\n    function swapFeeFor(address account_) external view returns (uint256);\\n\\n    function withdrawFee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @notice Governable interface\\n */\\ninterface IGovernable {\\n    function governor() external view returns (address _governor);\\n\\n    function transferGovernorship(address _proposedGovernor) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPauseable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\ninterface IPauseable {\\n    function paused() external view returns (bool);\\n\\n    function everythingStopped() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./external/IMasterOracle.sol\\\";\\nimport \\\"./IPauseable.sol\\\";\\nimport \\\"./IGovernable.sol\\\";\\nimport \\\"./ISyntheticToken.sol\\\";\\n\\ninterface IPoolRegistry is IPauseable, IGovernable {\\n    function isPoolRegistered(address pool_) external view returns (bool);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function nativeTokenGateway() external view returns (address);\\n\\n    function getPools() external view returns (address[] memory);\\n\\n    function registerPool(address pool_) external;\\n\\n    function unregisterPool(address pool_) external;\\n\\n    function masterOracle() external view returns (IMasterOracle);\\n\\n    function updateMasterOracle(IMasterOracle newOracle_) external;\\n\\n    function updateFeeCollector(address newFeeCollector_) external;\\n\\n    function updateNativeTokenGateway(address newGateway_) external;\\n\\n    function idOfPool(address pool_) external view returns (uint256);\\n\\n    function nextPoolId() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISyntheticToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../dependencies/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./IDebtToken.sol\\\";\\nimport \\\"./IPoolRegistry.sol\\\";\\n\\ninterface ISyntheticToken is IERC20Metadata {\\n    function isActive() external view returns (bool);\\n\\n    function mint(address to_, uint256 amount_) external;\\n\\n    function burn(address from_, uint256 amount) external;\\n\\n    function poolRegistry() external returns (IPoolRegistry);\\n\\n    function toggleIsActive() external;\\n\\n    function seize(address from_, address to_, uint256 amount_) external;\\n\\n    function updateMaxTotalSupply(uint256 newMaxTotalSupply_) external;\\n\\n    function maxTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @title Math library\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n * @dev Based on https://github.com/dapphub/ds-math/blob/master/src/math.sol\\n */\\nlibrary WadRayMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a*b, in wad\\n     */\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n\\n        return (a * b + HALF_WAD) / WAD;\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a/b, in wad\\n     */\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * WAD + b / 2) / b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/storage/FeeProviderStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/IFeeProvider.sol\\\";\\nimport \\\"../interfaces/IPoolRegistry.sol\\\";\\nimport \\\"../interfaces/external/IESMET.sol\\\";\\n\\nabstract contract FeeProviderStorageV1 is IFeeProvider {\\n    struct Tier {\\n        uint128 min; // esMET min balance needed to be eligible for `discount`\\n        uint128 discount; // discount in percentage to apply. Use 18 decimals (e.g. 1e16 = 1%)\\n    }\\n\\n    /**\\n     * @notice The fee discount tiers\\n     */\\n    Tier[] public tiers;\\n\\n    /**\\n     * @notice The default fee charged when swapping synthetic tokens\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    uint256 public override defaultSwapFee;\\n\\n    /**\\n     * @notice The fee charged when depositing collateral\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    uint256 public override depositFee;\\n\\n    /**\\n     * @notice The fee charged when minting a synthetic token\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    uint256 public override issueFee;\\n\\n    /**\\n     * @notice The fee charged when withdrawing collateral\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    uint256 public override withdrawFee;\\n\\n    /**\\n     * @notice The fee charged when repaying debt\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    uint256 public override repayFee;\\n\\n    /**\\n     * @notice The fees charged when liquidating a position\\n     * @dev Use 18 decimals (e.g. 1e16 = 1%)\\n     */\\n    LiquidationFees public override liquidationFees;\\n\\n    /**\\n     * @dev The Pool Registry\\n     */\\n    IPoolRegistry public poolRegistry;\\n\\n    /**\\n     * @notice The esMET contract\\n     */\\n    IESMET public esMET;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"EscrowMETIsNull\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeIsGreaterThanTheMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewValueIsSameAsCurrent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolRegistryIsNull\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderIsNotGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TierDiscountTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TiersNotOrderedByMin\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDepositFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDepositFee\",\"type\":\"uint256\"}],\"name\":\"DepositFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIssueFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIssueFee\",\"type\":\"uint256\"}],\"name\":\"IssueFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLiquidatorIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidatorIncentive\",\"type\":\"uint256\"}],\"name\":\"LiquidatorIncentiveUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolLiquidationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolLiquidationFee\",\"type\":\"uint256\"}],\"name\":\"ProtocolLiquidationFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRepayFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRepayFee\",\"type\":\"uint256\"}],\"name\":\"RepayFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSwapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapFee\",\"type\":\"uint256\"}],\"name\":\"SwapDefaultFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"discount\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct FeeProviderStorageV1.Tier[]\",\"name\":\"oldTiers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"discount\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct FeeProviderStorageV1.Tier[]\",\"name\":\"newTiers\",\"type\":\"tuple[]\"}],\"name\":\"TiersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWithdrawFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWithdrawFee\",\"type\":\"uint256\"}],\"name\":\"WithdrawFeeUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"esMET\",\"outputs\":[{\"internalType\":\"contract IESMET\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTiers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"discount\",\"type\":\"uint128\"}],\"internalType\":\"struct FeeProviderStorageV1.Tier[]\",\"name\":\"_tiers\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPoolRegistry\",\"name\":\"poolRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract IESMET\",\"name\":\"esMET_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issueFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationFees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidatorIncentive\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"protocolFee\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRegistry\",\"outputs\":[{\"internalType\":\"contract IPoolRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repayFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"swapFeeFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiers\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"discount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultSwapFee_\",\"type\":\"uint256\"}],\"name\":\"updateDefaultSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDepositFee_\",\"type\":\"uint256\"}],\"name\":\"updateDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newIssueFee_\",\"type\":\"uint256\"}],\"name\":\"updateIssueFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newLiquidatorIncentive_\",\"type\":\"uint128\"}],\"name\":\"updateLiquidatorIncentive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newProtocolLiquidationFee_\",\"type\":\"uint128\"}],\"name\":\"updateProtocolLiquidationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRepayFee_\",\"type\":\"uint256\"}],\"name\":\"updateRepayFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"discount\",\"type\":\"uint128\"}],\"internalType\":\"struct FeeProviderStorageV1.Tier[]\",\"name\":\"tiers_\",\"type\":\"tuple[]\"}],\"name\":\"updateTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWithdrawFee_\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeeProvider", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}