{"SourceCode": "{\"AFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IAFi.sol\\\";\\nimport \\\"./IUniswapV3.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\nimport {ReentrancyGuard} from \\\"./ReentrancyGuard.sol\\\";\\nimport {OwnableDelayModule} from \\\"./OwnableDelayModule.sol\\\";\\nimport \\\"./ArrayUtils.sol\\\";\\nimport {AggregatorV3Interface} from \\\"./AggregatorV3Interface.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\nimport \\\"./IAFiFactory.sol\\\";\\n\\ninterface Compound {\\n  function exchangeRateStored() external view returns (uint);\\n}\\n\\n/**\\n * @title AFiStorage.\\n * @notice Storage conntract for storing investors and teamwallets details and performig the storage changes.\\n * @dev Error codes: AFS01: Cannot be address zero. AFS02: Unauthorized caller.\\n */\\ncontract AFiStorage is OwnableDelayModule, IAFiStorage, ReentrancyGuard {\\n  using SafeCast for uint256;\\n  using ArrayUtils for uint[];\\n  using ArrayUtils for address[];\\n\\n  address private aFiManager;\\n  // List of TeamWallets, helpful when fetching team wallets report\\n  mapping(address =\\u003e address[]) internal teamWalletsOfAFi;\\n  // aFiContract =\\u003e investor =\\u003e Investor Struct\\n  mapping(address =\\u003e mapping(address =\\u003e Investor)) internal investorInAFi;\\n  // aFiContract =\\u003e teamWallet =\\u003e TeamWallet Struct\\n  mapping(address =\\u003e mapping(address =\\u003e TeamWallet)) internal teamWalletInAFi;\\n  mapping(address =\\u003e uint) internal totalActiveTeamWallets;\\n  mapping(address =\\u003e bool) internal onlyOnce;\\n  mapping(address =\\u003e bool) public isAFiActive;\\n  mapping(address =\\u003e RebalanceDetails[]) internal _rebalanceDetails;\\n  mapping(address =\\u003e mapping(uint256 =\\u003e mapping(address =\\u003e uint256)))\\n    public preDepositedInputTokens;\\n  uint256 internal preDep;\\n\\n  mapping(address =\\u003e uint256) public stablesWithdrawalLimit; // Amount in USD that can be withdrawn in between cumulative swaps\\n  mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public stablesWithdrawn; // Amount in USD that has been withdrawn in between cumulative swaps\\n  uint256 public maxSwapFee; // We set this parameter in % to calculate max fee that can be deducted in a swap\\n\\n  uint256 internal redFromContract;\\n  mapping(address =\\u003e uint256) internal lastSwapTime;\\n  address internal rebal;\\n  address internal _afiTemp;\\n\\n  //synData\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public aaveTokenCopy; // aaveToken address for various u tokens\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public compoundCometCopy;\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public compoundCopy;\\n  mapping(address =\\u003e mapping(address =\\u003e uint)) public provider; // Protocol where each u token is invested\\n  mapping(address =\\u003e mapping(address =\\u003e bool)) internal _isStaked;\\n\\n  // State variables\\n  mapping(address =\\u003e mapping(uint =\\u003e bool)) public swapMethodPaused; // Mapping to keep track of paused swap methods\\n\\n  address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  address private constant USDC_ORACLE = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\\n  address public immutable uniswapOracleV3;\\n  address public immutable aFiFactory;\\n\\n  /*\\n    Is underlying token staked\\n    isUTokenStaked: AFi =\\u003e UToken `isUTokenStaked[AFi][UToken]`\\n    isRebalanced: AFi `isRebalanced[AFi]`\\n  */\\n  mapping(address =\\u003e bool) internal isActiveRebalanced;\\n\\n  event SetActiveRebalancedStatus(address indexed aFiContract, bool status);\\n  event SetAFiActive(address indexed aFiContract, bool status);\\n  event ReActivateTeamWallet(address aFiContract, address wallet);\\n  event DeactivateTeamWallet(address aFiContract, address wallet);\\n  event SetAFiManager(address indexed afiContract, address manager);\\n  event ProfitShareDistributed(\\n    address indexed aFiContract,\\n    address indexed teamWallet,\\n    uint256 amount\\n  );\\n\\n  constructor(\\n    address _aFiManager,\\n    address oracleV3,\\n    address _passiveRebal,\\n    address _aFiFactory\\n  ) {\\n    validateAddress(_aFiManager, address(0));\\n    validateAddress(_aFiFactory, address(0));\\n    validateAddress(oracleV3, address(0));\\n    aFiManager = _aFiManager;\\n    uniswapOracleV3 = oracleV3;\\n    rebal = _passiveRebal;\\n    aFiFactory = _aFiFactory;\\n  }\\n\\n  function validateAddress(address addA, address addB) internal pure {\\n    require(addA != addB, \\\"AFS01\\\");\\n  }\\n\\n  function aFiVaultCaller(address aFiContract, address _owner1) internal view {\\n    require(\\n      IAFiFactory(aFiFactory).getAFiTokenStatus(aFiContract) || msg.sender == _owner1,\\n      \\\"AFS09\\\"\\n    );\\n  }\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external override nonReentrant {\\n    validateFlag(isAFiActive[aFiContract]);\\n    validateCaller(msg.sender, aFiManager);\\n    validateAddress(wallet, address(0));\\n    require(totalActiveTeamWallets[aFiContract] \\u003e 0, \\\"AFS05\\\");\\n    if (!teamWalletInAFi[aFiContract][wallet].isPresent \\u0026\\u0026 isPresent) {\\n      teamWalletsOfAFi[aFiContract].push(wallet);\\n      teamWalletInAFi[aFiContract][wallet].isPresent = isPresent;\\n\\n      // Write to contract storage\\n      if (!teamWalletInAFi[aFiContract][wallet].isActive \\u0026\\u0026 isActive) {\\n        teamWalletInAFi[aFiContract][wallet].isActive = isActive;\\n        totalActiveTeamWallets[aFiContract]++;\\n      }\\n      teamWalletInAFi[aFiContract][wallet].walletAddress = wallet;\\n    }\\n    emit TeamWalletAdd(wallet, true);\\n  }\\n\\n  /**\\n   * @notice To deactivate a team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param wallet Wallet address that has to be deactivated.\\n   */\\n  function deactivateTeamWallet(\\n    address aFiContract,\\n    address wallet\\n  ) external onlyOwner nonReentrant {\\n    // solhint-disable-next-line reason-string\\n\\n    validateFlag(isAFiActive[aFiContract]);\\n    validateFlag(teamWalletInAFi[aFiContract][wallet].isActive);\\n    totalActiveTeamWallets[aFiContract]--;\\n\\n    // Write to contract storage\\n    teamWalletInAFi[aFiContract][wallet].isActive = false;\\n    emit DeactivateTeamWallet(aFiContract, wallet);\\n  }\\n\\n  /**\\n   * @notice To reactivated a team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param wallet address that has to be reactivated.\\n   */\\n  function reActivateTeamWallet(\\n    address aFiContract,\\n    address wallet\\n  ) external onlyOwner nonReentrant {\\n    // solhint-disable-next-line reason-string\\n\\n    validateFlag(isAFiActive[aFiContract]);\\n    validateFlag(teamWalletInAFi[aFiContract][wallet].isPresent);\\n    validateFlag(!teamWalletInAFi[aFiContract][wallet].isActive);\\n    totalActiveTeamWallets[aFiContract]++;\\n\\n    // Write to contract storage\\n    teamWalletInAFi[aFiContract][wallet].isActive = true;\\n    emit ReActivateTeamWallet(aFiContract, wallet);\\n  }\\n\\n  function getTotalActiveWallets(\\n    address aFiContract\\n  ) public view override returns (uint) {\\n    return totalActiveTeamWallets[aFiContract];\\n  }\\n\\n  /**\\n   * @notice To add given wallet address to the contract storage.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets An array of wallet addresses.\\n   */\\n  function setTeamWallets(\\n    address aFiContract,\\n    address[] memory _teamWallets\\n  ) external override nonReentrant {\\n    validateFlag(!onlyOnce[aFiContract]);\\n    validateCaller(msg.sender, aFiContract);\\n    uint tWalletLength = _teamWallets.length;\\n\\n    // Check if the team wallets have already been set\\n    require(totalActiveTeamWallets[aFiContract] == 0, \\\"AFS12\\\");\\n\\n    totalActiveTeamWallets[aFiContract] = tWalletLength;\\n\\n    for (uint i = 0; i \\u003c tWalletLength; i++) {\\n      address wallet = _teamWallets[i];\\n\\n      TeamWallet memory tWallet = teamWalletInAFi[aFiContract][wallet];\\n\\n      if (!tWallet.isPresent) {\\n        teamWalletsOfAFi[aFiContract].push(wallet);\\n        tWallet.isPresent = true;\\n        tWallet.isActive = true;\\n        tWallet.walletAddress = wallet;\\n\\n        // Write to contract storage\\n        teamWalletInAFi[aFiContract][wallet] = tWallet;\\n\\n        emit TeamWalletActive(wallet, true);\\n      } else {\\n        // only for duplicacy\\n        totalActiveTeamWallets[aFiContract]--;\\n      }\\n    }\\n    onlyOnce[aFiContract] = true;\\n  }\\n\\n  function setActiveRebalancedStatus(\\n    address aFiContract,\\n    bool status\\n  ) external override {\\n    aFiVaultCaller(aFiContract, aFiManager);\\n    isActiveRebalanced[aFiContract] = status;\\n    emit SetActiveRebalancedStatus(aFiContract, status);\\n  }\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Team wallet address.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) public view override returns (bool isActive, bool isPresent) {\\n    return (\\n      teamWalletInAFi[aFiContract][_wallet].isActive,\\n      teamWalletInAFi[aFiContract][_wallet].isPresent\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the array of team wallet addresses.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) public view override returns (address[] memory _teamWallets) {\\n    _teamWallets = teamWalletsOfAFi[aFiContract];\\n  }\\n\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view override returns (bool _isActiveRebalanced) {\\n    _isActiveRebalanced = isActiveRebalanced[aFiContract];\\n  }\\n\\n  /**\\n   * @notice To set the AFi contract status.\\n   * @dev Requirements: It can be invoked only by the contract owner.\\n   * @param aFiContract Address of the AFiContract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external override {\\n    require(msg.sender == aFiContract || msg.sender == owner(), \\\"AFS04\\\");\\n    // Check if the contract is already active and trying to activate it again\\n    require(active != isAFiActive[aFiContract], \\\"AFS14\\\");\\n    isAFiActive[aFiContract] = active;\\n    emit SetAFiActive(aFiContract, isAFiActive[aFiContract]);\\n  }\\n\\n  /**\\n   * @notice syncs the pool data of a token to the pool data of aficontract.\\n   * @param afiContract address of the afi contract.\\n   * @param tok address of the token to sync the pool data.\\n   * @param aaveTok address of the aave pool.\\n   * @param compComet compound v3 comet address of tok.\\n   * @param compTok address of the compound pool.\\n   */\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    address compComet,\\n    address compTok\\n  ) external override {\\n    validateCaller(msg.sender, afiContract);\\n    aaveTokenCopy[afiContract][tok] = aaveTok;\\n    compoundCometCopy[afiContract][tok] = compComet;\\n    compoundCopy[afiContract][tok] = compTok;\\n  }\\n\\n  function balanceCompound(\\n    address tok,\\n    address afiContract\\n  ) public view returns (uint) {\\n    return IERC20(compoundCopy[afiContract][tok]).balanceOf(afiContract);\\n  }\\n\\n  function balanceCompoundInToken(\\n    address tok,\\n    address afiContract\\n  ) public view returns (uint) {\\n    // Mantisa 1e18 to decimals\\n    uint b = balanceCompound(tok, afiContract);\\n    if (b \\u003e= 1) {\\n      b =\\n        (b * (Compound(compoundCopy[afiContract][tok]).exchangeRateStored())) /\\n        (1e18);\\n    }\\n    return b;\\n  }\\n\\n  /**\\n   * @notice Returns the balance of Aave tokens in the AFi contract for a specific token.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return The Aave token balance.\\n   */\\n  function balanceAave(address tok, address afiContract) public view returns (uint) {\\n    return IERC20(aaveTokenCopy[afiContract][tok]).balanceOf(afiContract);\\n  }\\n\\n  /**\\n   * @notice Returns the balance of a specific token in the AFi contract.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return The token balance.\\n   */\\n  function balance(address tok, address afiContract) internal view returns (uint) {\\n    return IERC20(tok).balanceOf(afiContract);\\n  }\\n\\n  /**\\n   * @notice Returns the balance of compound v3 wrapper tokens in the AFi contract for a specific token.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return bal cUSDCv3 token balance.\\n   */\\n  function balanceCompV3(\\n    address tok,\\n    address afiContract\\n  ) public view returns (uint256 bal) {\\n    if (compoundCometCopy[afiContract][tok] != address(0)) {\\n      bal = IERC20(compoundCometCopy[afiContract][tok]).balanceOf(afiContract);\\n    }\\n  }\\n\\n  /**\\n   * @notice To set the AFiManager contract address.\\n   * @dev Requirements: It can be invoked only by the platform wallet.\\n   * @param _aFiManager Address of the AFiManager contract.\\n   */\\n  function setAFiManager(address _aFiManager) external onlyOwner {\\n    validateAddress(_aFiManager, address(0));\\n    aFiManager = _aFiManager;\\n    emit SetAFiManager(address(this), _aFiManager);\\n  }\\n\\n  /**\\n   * @notice Calculates the total value of a token locked by the AFi contract in USD.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return The total value of the token in USD.\\n   */\\n  function calcPoolValue(\\n    address tok,\\n    address afiContract\\n  ) public view override returns (uint) {\\n    (uint256 price, uint256 multiplier) = getPriceInUSDC(tok);\\n    (uint256 bal, uint256 uTokensDecimal) = tvlRead(tok, afiContract);\\n    if (price != 0) {\\n      bal = (bal) * (uint(price));\\n      bal = ((bal * (10 ** uTokensDecimal)) / (multiplier));\\n    }\\n    return bal;\\n  }\\n\\n  function tvlRead(\\n    address tok,\\n    address afiContract\\n  ) public view override returns (uint, uint256) {\\n    uint uTokensDecimal = IERC20(tok).decimals();\\n    validateGreaterEqual(18, uTokensDecimal);\\n    uTokensDecimal = 18 - uTokensDecimal;\\n    uint bal = balanceOfUnderlyingInPoolsAndContract(tok, afiContract);\\n    return (bal, uTokensDecimal);\\n  }\\n\\n  /**\\n   * @notice Calculates the balance of underlying tokens in the AFi contract for a specific token.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return The balance of underlying tokens.\\n   */\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) external view override returns (uint) {\\n    return balanceOfUnderlyingInPoolsAndContract(tok, afiContract);\\n  }\\n\\n  /**\\n   * @notice Calculates the balance of underlying tokens in the AFi contract for a specific token.\\n   * @param tok The address of the token.\\n   * @param afiContract The address of the AFi contract.\\n   * @return bal balance of underlying tokens.\\n   */\\n  function balanceOfUnderlyingInPoolsAndContract(\\n    address tok,\\n    address afiContract\\n  ) internal view returns (uint256 bal) {\\n    if (\\n      compoundCopy[afiContract][tok] != address(0) \\u0026\\u0026 provider[afiContract][tok] == 1\\n    ) {\\n      bal += balanceCompoundInToken(tok, afiContract);\\n    }\\n    if (\\n      aaveTokenCopy[afiContract][tok] != address(0) \\u0026\\u0026 provider[afiContract][tok] == 2\\n    ) {\\n      bal += balanceAave(tok, afiContract);\\n    }\\n    if (\\n      compoundCometCopy[afiContract][tok] != address(0) \\u0026\\u0026\\n      provider[afiContract][tok] == 3\\n    ) {\\n      bal += balanceCompV3(tok, afiContract);\\n    }\\n    bal = (bal + balance(tok, afiContract));\\n  }\\n\\n  // returns the TVL by the external protocols\\n  function calcPoolValueSomeRead(\\n    address tok,\\n    address afiContract,\\n    uint256 price,\\n    uint256 multiplier\\n  ) internal view returns (uint) {\\n    (uint bal, uint256 uTokensDecimal) = tvlRead(tok, afiContract);\\n    if (price != 0) {\\n      bal = (bal - (balance(tok, afiContract))) * (uint(price));\\n      bal = ((bal * (10 ** uTokensDecimal)) / (multiplier));\\n    }\\n    return bal;\\n  }\\n\\n  /**\\n   * @notice Calculates the total value of all tokens locked by the AFi contract in USD.\\n   * @param afiContract The address of the AFi contract.\\n   * @return The total value of all tokens in USD.\\n   */\\n  function calculatePoolInUsd(\\n    address afiContract\\n  ) external view override returns (uint) {\\n    uint bal = 0;\\n    address[] memory uToken = new address[](IAFi(afiContract).getUTokens().length);\\n    uToken = IAFi(afiContract).getUTokens();\\n    (, address[] memory iToken) = IAFi(afiContract).getInputToken();\\n    uint uLen = uToken.length \\u003e iToken.length ? uToken.length : iToken.length;\\n    uint256 cSwapCounter = IAFi(afiContract).getcSwapCounter();\\n    uint256 preDepositStableBalance;\\n    for (uint i = 0; i \\u003c uLen; i++) {\\n      if (uLen == iToken.length) {\\n        if (i \\u003c uToken.length) {\\n          bal = bal + (calcPoolValue(uToken[i], afiContract));\\n        }\\n        preDepositStableBalance = convertInUSDAndTok(\\n          iToken[i],\\n          preDepositedInputTokens[afiContract][cSwapCounter][iToken[i]],\\n          false\\n        );\\n        bal = bal + (preDepositStableBalance);\\n      } else {\\n        if (i \\u003c iToken.length) {\\n          preDepositStableBalance = convertInUSDAndTok(\\n            iToken[i],\\n            preDepositedInputTokens[afiContract][cSwapCounter][iToken[i]],\\n            false\\n          );\\n          bal = bal + (preDepositStableBalance);\\n        }\\n        bal = bal + (calcPoolValue(uToken[i], afiContract));\\n      }\\n    }\\n    return bal;\\n  }\\n\\n  /**\\n   * @notice Validates and returns the number of decimals for a given token.\\n   * @param tok The address of the token.\\n   * @return The number of decimals.\\n   */\\n  function validateAndGetDecimals(address tok) public view override returns (uint256) {\\n    uint uTokensDecimal = IERC20(tok).decimals();\\n    validateGreaterEqual(18, uTokensDecimal);\\n    return (18 - uTokensDecimal);\\n  }\\n\\n  /**\\n   * @notice Validates that two addresses are equal.\\n   * @param add1 The first address.\\n   * @param add2 The second address.\\n   */\\n  function validateCaller(address add1, address add2) internal pure {\\n    require(add1 == add2, \\\"AFS27\\\");\\n  }\\n\\n  /**\\n   * @notice Validates a boolean flag.\\n   * @param flag The boolean flag to validate.\\n   */\\n  function validateFlag(bool flag) internal pure {\\n    require(flag, \\\"AFS28\\\");\\n  }\\n\\n  /**\\n   * @notice Validates that one value is greater than or equal to another.\\n   * @param val1 The first value.\\n   * @param val2 The second value.\\n   */\\n  function validateGreaterEqual(uint256 val1, uint256 val2) internal pure {\\n    require(val1 \\u003e= val2, \\\"AFS19\\\");\\n  }\\n\\n  /**\\n   * @notice Rearranges the staking of uTokens, withdrawing from existing pools and staking in recommended pools.\\n   * @param aFiContract The address of the AFi contract.\\n   */\\n  //90% uTokens will be staked on pool and 10% remain on contract\\n  function rearrange(\\n    address aFiContract,\\n    address[] memory underlyingTokens,\\n    uint256[] memory newProviders\\n  ) external override {\\n    (, , uint256 productType) = IAFi(aFiContract).getTVLandRebalContractandType();\\n    if (productType == 2) {\\n      validateCaller(msg.sender, uniswapOracleV3);\\n      require(underlyingTokens.length == newProviders.length, \\\"AFS03\\\");\\n      for (uint i = 0; i \\u003c underlyingTokens.length; i++) {\\n        address uToken = underlyingTokens[i];\\n        uint256 newProvider = newProviders[i];\\n\\n        // Assuming provider is now a mapping to uint\\n        if (newProvider != provider[aFiContract][uToken]) {\\n          _isStaked[aFiContract][uToken] = false;\\n          _withdrawAll(aFiContract, uToken);\\n        }\\n\\n        if (balance(uToken, aFiContract) \\u003e 0) {\\n          // 1 for COMPOUND II, 2 for AAVE, 3 for COMPOUND III\\n\\n          if (newProvider == 2) {\\n            // AAVE\\n            if (aaveTokenCopy[aFiContract][uToken] != address(0)) {\\n              _isStaked[aFiContract][uToken] = true;\\n              IAFi(aFiContract)._supplyAave(\\n                uToken,\\n                (balance(uToken, aFiContract) * (90)) / (100)\\n              );\\n            }\\n          } else if (newProvider == 3) {\\n            // Compound III\\n            if (compoundCometCopy[aFiContract][uToken] != address(0)) {\\n              _isStaked[aFiContract][uToken] = true;\\n\\n              IAFi(aFiContract)._supplyCompV3(\\n                uToken,\\n                (balance(uToken, aFiContract) * (90)) / (100)\\n              );\\n            }\\n          } else if (newProvider == 1) {\\n            // COMPOUND II\\n            if (compoundCopy[aFiContract][uToken] != address(0)) {\\n              _isStaked[aFiContract][uToken] = true;\\n              IAFi(aFiContract)._supplyCompound(\\n                uToken,\\n                ((balance(uToken, aFiContract) * (90)) / (100))\\n              );\\n            }\\n          }\\n        }\\n\\n        provider[aFiContract][uToken] = newProvider;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks the staked status of a uToken.\\n   * @param aFiContract The address of the AFi contract.\\n   * @param uToken The address of the uToken.\\n   * @return Whether the uToken is staked or not.\\n   */\\n  function getStakedStatus(\\n    address aFiContract,\\n    address uToken\\n  ) public view override returns (bool) {\\n    return _isStaked[aFiContract][uToken];\\n  }\\n\\n  function calculateShares(\\n    address afiContract,\\n    uint256 amount,\\n    uint256 prevPool,\\n    uint256 _totalSupply,\\n    address iToken,\\n    uint256 currentDepositNAV,\\n    uint256 prevBalance\\n  ) external view override returns (uint256 shares, uint256 newDepositNAV) {\\n    validateAddress(afiContract, address(0));\\n    validateCaller(msg.sender, afiContract);\\n    (uint256 price, uint256 dec) = getPriceInUSDC(iToken);\\n    uint8 decimals = 18 - IERC20(iToken).decimals();\\n    uint256 amountCheck = (amount * price * (10 ** decimals)) / dec;\\n\\n    if (_totalSupply == 0) {\\n      shares = amountCheck / 100;\\n    } else {\\n      require(prevPool \\u003e 0, \\\"AFB00007\\\");\\n      shares = (amountCheck * _totalSupply) / prevPool;\\n    }\\n\\n    if (currentDepositNAV == 0) {\\n      if (_totalSupply == 0) {\\n        newDepositNAV = 1000000;\\n      } else {\\n        newDepositNAV = (prevPool * 10000) / _totalSupply;\\n      }\\n    } else {\\n      uint256 newNav = (prevPool * 10000) / _totalSupply;\\n      newDepositNAV =\\n        ((currentDepositNAV * prevBalance) + (shares * newNav)) /\\n        (prevBalance + shares);\\n    }\\n  }\\n\\n  function handleRedemption(\\n    RedemptionParams memory params,\\n    uint _shares,\\n    uint swapMethod\\n  ) external override returns (uint256 redemptionFromContract) {\\n    validateAddress(params.baseContract, address(0));\\n    aFiVaultCaller(msg.sender, params.baseContract);\\n    if (swapMethod == 1) {\\n      redemptionFromContract = checkUnderlyingToken(\\n        params.baseContract,\\n        params.r,\\n        params.oToken,\\n        params.cSwapCounter,\\n        params.uTokens,\\n        params.deadline,\\n        params.minimumReturnAmount\\n      );\\n    } else if (swapMethod == 2) {\\n      redemptionFromContract = checkiToken(\\n        params.r,\\n        params.oToken,\\n        params.cSwapCounter,\\n        params.iTokens,\\n        params.deadline,\\n        params.minimumReturnAmount\\n      );\\n    } else {\\n      redemptionFromContract = swapForOtherProduct(\\n        params.baseContract,\\n        params.r,\\n        params.oToken,\\n        params.deadline,\\n        params.minimumReturnAmount,\\n        params.uTokens\\n      );\\n    }\\n\\n    uint256 redemptionNAV = (params._pool * 10000) / params.tSupply;\\n    if (redemptionNAV \\u003e params.depositNAV) {\\n      redemptionFromContract -= _distributeProfitShare(\\n        params.baseContract,\\n        _shares,\\n        params.oToken,\\n        params.depositNAV,\\n        redemptionNAV\\n      );\\n    }\\n\\n    return redemptionFromContract;\\n  }\\n\\n  /**\\n   * @notice Swaps tokens in the AFi contract for another product.\\n   * @param afiContract The address of the AFi contract.\\n   * @param r A parameter for the swap.\\n   * @param oToken The address of the output token.\\n   * @param deadline The deadline for the swap.\\n   * @return The total amount swapped from the contract.\\n   */\\n  function swapForOtherProduct(\\n    address afiContract,\\n    uint r,\\n    address oToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount,\\n    address[] memory uToken\\n  ) public override returns (uint256) {\\n    validateAddress(afiContract, address(0));\\n    aFiVaultCaller(afiContract, uniswapOracleV3);\\n    (, rebal, ) = IAFi(afiContract).getTVLandRebalContractandType();\\n    redFromContract = 0;\\n    _afiTemp = afiContract;\\n\\n    preDep = IAFiManager(aFiManager).inputTokenUSD(\\n      IAFi(afiContract),\\n      IAFi(afiContract).getcSwapCounter(),\\n      IAFiStorage(address(this))\\n    );\\n    checkIfTokenPresent(uToken, r, oToken, deadline, afiContract, minimumReturnAmount);\\n    swapInternal(uToken, r, oToken, deadline, minimumReturnAmount);\\n\\n    return redFromContract;\\n  }\\n\\n  function calculateRedemptionFromContract(\\n    address afiContract,\\n    address tok,\\n    uint256 r\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      uint256 price,\\n      bool stakedStatus,\\n      uint256 redemptionValueFromContract,\\n      uint256 multiplier,\\n      uint256 tvl\\n    )\\n  {\\n    validateAddress(afiContract, address(0));\\n    (price, multiplier) = getPriceInUSDC(tok);\\n    (tvl, , ) = IAFi(afiContract).getTVLandRebalContractandType();\\n    uint256 tokPreDep = preDepositedInputTokens[afiContract][\\n      IAFi(afiContract).getcSwapCounter()\\n    ][tok];\\n    if (price != 0) {\\n      uint256 uTokensDecimal = validateAndGetDecimals(tok);\\n      uint256 tokPredepInUSD = (tokPreDep) * (uint(price));\\n      tokPredepInUSD = ((tokPredepInUSD * (10 ** uTokensDecimal)) / (multiplier));\\n      redemptionValueFromContract = (((r) *\\n        (calcPoolValue(tok, afiContract) - tokPredepInUSD)) * (multiplier));\\n      redemptionValueFromContract =\\n        (redemptionValueFromContract) /\\n        (((tvl - preDep) * (uint(price)) * (10 ** (validateAndGetDecimals(tok)))));\\n      tvl -= preDep;\\n      return (\\n        price,\\n        getStakedStatus(afiContract, tok),\\n        redemptionValueFromContract,\\n        multiplier,\\n        tvl\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Withdraws funds from pools and performs an internal swap.\\n   * @param tok The address of the token.\\n   * @param r A parameter for the withdrawal.\\n   * @param oToken The address of the output token.\\n   * @param redemptionFromContract The redemption amount from the contract.\\n   * @param deadline The deadline for the withdrawal.\\n   */\\n  function withdrawFromPools(\\n    address tok,\\n    uint r,\\n    address oToken,\\n    uint redemptionFromContract,\\n    uint deadline,\\n    uint256 price,\\n    uint256 multiplier,\\n    uint256 minimumReturnAmount,\\n    uint256 tvl\\n  ) internal {\\n    address midTok = IUniswapOracleV3(uniswapOracleV3).getMidToken(tok);\\n    {\\n      uint256 redemptionFromPool = calcPoolValueSomeRead(\\n        tok,\\n        _afiTemp,\\n        price,\\n        multiplier\\n      );\\n      redemptionFromPool = redemptionFromPool * (r) * (multiplier);\\n      redemptionFromPool =\\n        (redemptionFromPool) /\\n        ((tvl) * (uint(price)) * (10 ** validateAndGetDecimals(tok)));\\n\\n      _withdrawSome(_afiTemp, tok, redemptionFromPool);\\n    }\\n    internalSwap(\\n      _afiTemp,\\n      tok,\\n      oToken,\\n      midTok,\\n      deadline,\\n      redemptionFromContract,\\n      minimumReturnAmount\\n    );\\n  }\\n\\n  function internalSwap(\\n    address afiContract,\\n    address tok,\\n    address oToken,\\n    address midTok,\\n    uint deadline,\\n    uint redeem,\\n    uint minimumReturnAmount\\n  ) internal {\\n    if (tok != oToken) {\\n      if (IERC20(tok).balanceOf(afiContract) \\u003e 0) {\\n        redFromContract += IAFi(afiContract).swapViaStorageOrManager(\\n          tok,\\n          oToken,\\n          redeem,\\n          deadline,\\n          midTok,\\n          minimumReturnAmount\\n        );\\n      }\\n    } else {\\n      redFromContract = redFromContract + redeem;\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns pool to invest in, amount to invest and\\n   * deducted amount if there is a fluctuation or insufficient balance(rare case).\\n   */\\n  function _withdrawSome(\\n    address afiContract,\\n    address tok,\\n    uint _amount\\n  ) internal returns (bool withdrawal) {\\n    if (\\n      aaveTokenCopy[afiContract][tok] != address(0) \\u0026\\u0026 provider[afiContract][tok] == 2\\n    ) {\\n      if (balanceAave(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e balanceAave(tok, afiContract)) {\\n          revert(\\\"Insufficient redemption balance!\\\");\\n        } else {\\n          IAFi(afiContract)._withdrawAave(tok, _amount);\\n        }\\n      }\\n      return true;\\n    }\\n\\n    if (\\n      compoundCopy[afiContract][tok] != address(0) \\u0026\\u0026 provider[afiContract][tok] == 1\\n    ) {\\n      if (balanceCompound(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e balanceCompoundInToken(tok, afiContract)) {\\n          revert(\\\"Insufficient redemption balance!\\\");\\n        } else {\\n          IAFi(afiContract)._withdrawCompound(tok, _amount);\\n        }\\n      }\\n      return true;\\n    }\\n\\n    if (\\n      compoundCometCopy[afiContract][tok] != address(0) \\u0026\\u0026\\n      provider[afiContract][tok] == 3\\n    ) {\\n      if (balanceCompV3(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e balanceCompV3(tok, afiContract)) {\\n          revert(\\\"Insufficient redemption balance!\\\");\\n        } else {\\n          IAFi(afiContract)._withdrawCompoundV3(tok, _amount);\\n        }\\n      }\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks if a token is of type USDC and retrieves its price and multiplier.\\n   * @param tok The address of the token.\\n   * @return The token\\u0027s price and multiplier.\\n   */\\n  function getPriceInUSDC(address tok) public view override returns (uint256, uint256) {\\n    return (IUniswapOracleV3(uniswapOracleV3).getPriceInUSDC(tok));\\n  }\\n\\n  /**\\n   * @notice Checks if a specific token is present, calculates redemption, and withdraws from pools.\\n   * @param uToken An array of token addresses.\\n   * @param r A parameter for calculation.\\n   * @param oToken The address of the output token.\\n   * @param deadline The deadline for the swap.\\n   * @param afiContract The address of the AFi contract.\\n   */\\n  function checkIfTokenPresent(\\n    address[] memory uToken,\\n    uint r,\\n    address oToken,\\n    uint deadline,\\n    address afiContract,\\n    uint[] memory minimumReturnAmount\\n  ) internal {\\n    uint256 redemptionFromContract;\\n    bool stakedStatus;\\n    uint256 price;\\n    uint256 multiplier;\\n    uint256 tvl;\\n    {\\n      (uint index, bool present) = ArrayUtils.indexOf(uToken, oToken);\\n      if (present) {\\n        (\\n          price,\\n          stakedStatus,\\n          redemptionFromContract,\\n          multiplier,\\n          tvl\\n        ) = calculateRedemptionFromContract(afiContract, uToken[index], r);\\n        if (!stakedStatus) {\\n          redFromContract += redemptionFromContract;\\n        }\\n        if (stakedStatus) {\\n          if (price != 0) {\\n            withdrawFromPools(\\n              uToken[index],\\n              r,\\n              oToken,\\n              redemptionFromContract,\\n              deadline,\\n              price,\\n              multiplier,\\n              minimumReturnAmount[index],\\n              tvl\\n            );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function swapInternal(\\n    address[] memory uToken,\\n    uint r,\\n    address oToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount\\n  ) internal {\\n    address midTok;\\n    uint256 price;\\n    bool stakedStatus;\\n    uint256 redemptionFromContract;\\n    uint256 multiplier;\\n    uint256 tvl;\\n    unchecked {\\n      for (uint n = 0; n \\u003c uToken.length; n++) {\\n        (\\n          price,\\n          stakedStatus,\\n          redemptionFromContract,\\n          multiplier,\\n          tvl\\n        ) = calculateRedemptionFromContract(_afiTemp, uToken[n], r);\\n\\n        if (!stakedStatus \\u0026\\u0026 uToken[n] != oToken) {\\n          if (IERC20(uToken[n]).balanceOf(_afiTemp) \\u003e 0) {\\n            midTok = IUniswapOracleV3(uniswapOracleV3).getMidToken(uToken[n]);\\n\\n            if (redemptionFromContract \\u003c= IERC20(uToken[n]).balanceOf(_afiTemp)) {\\n              redFromContract += IAFi(_afiTemp).swapViaStorageOrManager(\\n                uToken[n],\\n                oToken,\\n                redemptionFromContract,\\n                deadline,\\n                midTok,\\n                minimumReturnAmount[n]\\n              );\\n            } else {\\n              redFromContract += IAFi(_afiTemp).swapViaStorageOrManager(\\n                uToken[n],\\n                oToken,\\n                IERC20(uToken[n]).balanceOf(_afiTemp),\\n                deadline,\\n                midTok,\\n                minimumReturnAmount[n]\\n              );\\n            }\\n          }\\n          continue;\\n        }\\n        if (stakedStatus \\u0026\\u0026 uToken[n] != oToken) {\\n          if (price != 0) {\\n            withdrawFromPools(\\n              uToken[n],\\n              r,\\n              oToken,\\n              redemptionFromContract,\\n              deadline,\\n              price,\\n              multiplier,\\n              minimumReturnAmount[n],\\n              tvl\\n            );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice _withdrawAll Function withdraws whole diposited balance from the pools(protocols).\\n   * @dev It should only be called by the AFiManager, AFiStorage contracts.\\n   * @param tok address of the token to withdraw from protocols.\\n   */\\n  function _withdrawAll(\\n    address afiContract,\\n    address tok\\n  ) public override returns (bool) {\\n    require(msg.sender == uniswapOracleV3 || msg.sender == aFiManager, \\\"AFS02\\\");\\n    uint poolBal;\\n    if (\\n      provider[afiContract][tok] == 1 \\u0026\\u0026 compoundCopy[afiContract][tok] != address(0)\\n    ) {\\n      if (balanceCompound(tok, afiContract) \\u003e= 1) {\\n        IAFi(afiContract)._withdrawCompound(\\n          tok,\\n          balanceCompoundInToken(tok, afiContract) - (1)\\n        );\\n      }\\n    }\\n    if (\\n      provider[afiContract][tok] == 2 \\u0026\\u0026 aaveTokenCopy[afiContract][tok] != address(0)\\n    ) {\\n      poolBal = balanceAave(tok, afiContract);\\n      if (poolBal \\u003e= 1) {\\n        IAFi(afiContract)._withdrawAave(tok, poolBal);\\n      }\\n    }\\n    if (\\n      provider[afiContract][tok] == 3 \\u0026\\u0026\\n      compoundCometCopy[afiContract][tok] != address(0)\\n    ) {\\n      poolBal = balanceCompV3(tok, afiContract);\\n      if (poolBal \\u003e= 1) {\\n        IAFi(afiContract)._withdrawCompoundV3(tok, poolBal);\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function getAFiOracle() external view override returns (address) {\\n    return uniswapOracleV3;\\n  }\\n\\n  function checkUnderlyingToken(\\n    address afiContract,\\n    uint r,\\n    address oToken,\\n    uint256 _cSwapCounter,\\n    address[] memory uTokens,\\n    uint256 deadline,\\n    uint256[] memory minimumAmountOut\\n  ) internal returns (uint256 available) {\\n    uint256 redemptionFromContract;\\n    uint256 balToConsider;\\n    preDep = IAFiManager(aFiManager).inputTokenUSD(\\n      IAFi(afiContract),\\n      IAFi(afiContract).getcSwapCounter(),\\n      IAFiStorage(address(this))\\n    );\\n\\n    for (uint i; i \\u003c uTokens.length; i++) {\\n      (, , redemptionFromContract, , ) = calculateRedemptionFromContract(\\n        afiContract,\\n        uTokens[i],\\n        r\\n      );\\n\\n      balToConsider =\\n        IERC20(uTokens[i]).balanceOf(afiContract) -\\n        preDepositedInputTokens[afiContract][_cSwapCounter][uTokens[i]];\\n      if (balToConsider \\u003e= redemptionFromContract \\u0026\\u0026 uTokens[i] != oToken) {\\n        available += IAFi(afiContract).swapViaStorageOrManager(\\n          uTokens[i],\\n          oToken,\\n          redemptionFromContract,\\n          deadline,\\n          WETH,\\n          minimumAmountOut[i]\\n        );\\n      } else if (balToConsider \\u003e= redemptionFromContract \\u0026\\u0026 uTokens[i] == oToken) {\\n        available += redemptionFromContract;\\n      } else {\\n        revert(\\\"Insufficient balance!\\\");\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Distributes the profit share amongst team wallets.\\n   * @dev Only a specific address can call this function.\\n   * @param aFiContract Address of the aFi contract.\\n   * @param share The profit amount that is distributed amongst team wallets.\\n   * @param oToken Output token.\\n   * @param depositNAV NAV (Net Asset Value) at the time of deposit.\\n   * @param redemptionNAV NAV at the time of redemption.\\n   * @return totalProfitShare Returns the total profit share that was distributed amongst the team wallets.\\n   */\\n  function _distributeProfitShare(\\n    address aFiContract,\\n    uint share,\\n    address oToken,\\n    uint256 depositNAV,\\n    uint256 redemptionNAV\\n  ) internal returns (uint totalProfitShare) {\\n    uint256 profitShare;\\n    (uint256 price, uint256 multiplier) = getPriceInUSDC(oToken);\\n\\n    if (price != 0) {\\n      profitShare =\\n        ((redemptionNAV - (depositNAV)) * (share) * (multiplier)) /\\n        (((uint(price)) * (10 ** (validateAndGetDecimals(oToken)))) * (10000));\\n      totalProfitShare = profitDistribution(aFiContract, profitShare, oToken);\\n    }\\n  }\\n\\n  function profitDistribution(\\n    address aFiContract,\\n    uint256 profitShare,\\n    address oToken\\n  ) internal returns (uint totalProfitShare) {\\n    // Investor has made a profit, let us distribute the profit share amongst team wallet\\n    address[] memory _teamWallets = getTeamWalletsOfAFi(aFiContract);\\n    uint256 teamProfitShare;\\n    uint256 totalProfit = IUniswapOracleV3(uniswapOracleV3).getTotalProfit();\\n    uint256 daoProfit = IUniswapOracleV3(uniswapOracleV3).getDaoProfit();\\n    // Alpha Creator gets 4% of gain\\n\\n    uint totalActive = getTotalActiveWallets(aFiContract);\\n    if (totalActive \\u003e 1) {\\n      teamProfitShare =\\n        (profitShare * (totalProfit - daoProfit)) /\\n        ((totalActive - 1) * (100));\\n    }\\n\\n    for (uint i = 0; i \\u003c _teamWallets.length; i++) {\\n      (bool isActive, ) = getTeamWalletDetails(aFiContract, _teamWallets[i]);\\n\\n      if (isActive) {\\n        if (i == 0) {\\n          // /**\\n          //   Always at i==0 address must be of Aarna Dao\\n          //   Aarna DAO gets 6% of gain\\n          // */\\n          uint256 daoProfitShare = (profitShare * (daoProfit)) / (100);\\n          profitShare = daoProfitShare;\\n        } else {\\n          profitShare = teamProfitShare;\\n        }\\n\\n        totalProfitShare = totalProfitShare + profitShare;\\n\\n        IAFi(aFiContract).sendProfitOrFeeToManager(\\n          _teamWallets[i],\\n          profitShare,\\n          oToken\\n        );\\n\\n        emit ProfitShareDistributed(aFiContract, _teamWallets[i], profitShare);\\n      }\\n    }\\n  }\\n\\n  function setStablesWithdrawalLimit(\\n    address afiContract,\\n    uint256 limit\\n  ) external onlyOwner {\\n    require(limit \\u003e 0, \\\"AFS07\\\");\\n\\n    stablesWithdrawalLimit[afiContract] = limit;\\n  }\\n\\n  function setMaxSwapFee(uint256 fee) external onlyOwner {\\n    require(fee \\u003e 0 \\u0026\\u0026 fee \\u003c 10000, \\\"AFS08\\\");\\n    maxSwapFee = fee; // 100 = 1%\\n  }\\n\\n  /**\\n   * @notice Checks the iToken and performs necessary deductions.\\n   * @dev This external function checks the iToken and performs deductions based on specified conditions.\\n   * @param r The redemption amount to be deducted.\\n   * @param oToken The address of the output token.\\n   * @param deadline The deadline for the transaction.\\n   * @return redemptionBalance The amount to be deducted.\\n   */\\n  function checkiToken(\\n    uint r,\\n    address oToken,\\n    uint256 _cSwapCounter,\\n    address[] memory token,\\n    uint256 deadline,\\n    uint256[] memory minimumReturnAmount\\n  ) internal returns (uint256 redemptionBalance) {\\n    redemptionBalance = preDepositedInputTokens[msg.sender][_cSwapCounter][oToken];\\n    uint temp = convertInUSDAndTok(oToken, redemptionBalance, false);\\n\\n    if (temp \\u003e= r) {\\n      redemptionBalance = convertInUSDAndTok(oToken, r, true);\\n      preDepositedInputTokens[msg.sender][_cSwapCounter][oToken] -= redemptionBalance;\\n    } else {\\n      delete preDepositedInputTokens[msg.sender][_cSwapCounter][oToken];\\n      temp = r - temp;\\n      uint temp1;\\n      for (uint i; i \\u003c token.length; i++) {\\n        if (\\n          preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]] \\u003e 0 \\u0026\\u0026\\n          token[i] != oToken\\n        ) {\\n          temp1 = convertInUSDAndTok(token[i], temp, true);\\n          if (temp1 \\u003e preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]]) {\\n            redemptionBalance += IAFi(msg.sender).swapViaStorageOrManager(\\n              token[i],\\n              oToken,\\n              preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]],\\n              deadline,\\n              WETH,\\n              minimumReturnAmount[i]\\n            );\\n            temp -= convertInUSDAndTok(\\n              token[i],\\n              preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]],\\n              false\\n            );\\n            delete preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]];\\n          } else {\\n            redemptionBalance += IAFi(msg.sender).swapViaStorageOrManager(\\n              token[i],\\n              oToken,\\n              temp1,\\n              deadline,\\n              WETH,\\n              minimumReturnAmount[i]\\n            );\\n            preDepositedInputTokens[msg.sender][_cSwapCounter][token[i]] -= temp1;\\n            delete temp;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    temp = (convertInUSDAndTok(oToken, r, true) * (10000 - maxSwapFee)) / 10000;\\n    uint256 tempInUSD = convertInUSDAndTok(oToken, temp, false);\\n    if (\\n      redemptionBalance \\u003c temp ||\\n      (stablesWithdrawn[msg.sender][_cSwapCounter] + tempInUSD) \\u003e\\n      stablesWithdrawalLimit[msg.sender]\\n    ) {\\n      revert(\\\"Insufficient balance!\\\");\\n    } else {\\n      stablesWithdrawn[msg.sender][_cSwapCounter] += tempInUSD;\\n    }\\n  }\\n\\n  function convertInUSDAndTok(\\n    address tok,\\n    uint256 amt,\\n    bool usd\\n  ) public view override returns (uint256) {\\n    (uint256 price, uint256 decimal) = getPriceInUSDC(tok);\\n    uint iTokenDecimal = 18 - IERC20(tok).decimals();\\n    if (!usd) {\\n      return ((((amt) * (price)) * (10 ** iTokenDecimal)) / (decimal));\\n    } else {\\n      return (amt * (decimal)) / ((price) * (10 ** iTokenDecimal));\\n    }\\n  }\\n\\n  function setPreDepositedInputToken(\\n    uint256 _cSwapCounter,\\n    uint256 _amount,\\n    address _oToken\\n  ) external override {\\n    preDepositedInputTokens[msg.sender][_cSwapCounter][_oToken] += _amount;\\n  }\\n\\n  /**\\n   * @notice sets the pre-swap deposits of a specific stable token and request should come from afimanager.\\n   * @param aficontract Address of the afi vault.\\n   * @param _cSwapCounter value of the current cswap counter of the aficontract.\\n   * @param _amount of oToken.\\n   * @param _oToken address of oToken.\\n   */\\n  function setPreDepositedInputTokenInRebalance(\\n    address aficontract,\\n    uint256 _cSwapCounter,\\n    uint256 _amount,\\n    address _oToken\\n  ) external override {\\n    validateCaller(msg.sender, aFiManager);\\n    preDepositedInputTokens[aficontract][_cSwapCounter][_oToken] += _amount;\\n  }\\n\\n  function deletePreDepositedInputToken(\\n    address aFiContract,\\n    address oToken,\\n    uint256 currentCounter\\n  ) external override {\\n    validateCaller(msg.sender, aFiManager);\\n    delete preDepositedInputTokens[aFiContract][currentCounter][oToken];\\n  }\\n\\n  /**\\n   * @notice Returns the pre-swap deposits of a specific stable token.\\n   * @param stableToken Address of the stable token.\\n   * @return The amount of pre-swap deposits for the specified stable token.\\n   */\\n  function getPreSwapDepositsTokens(\\n    address aFiContract,\\n    uint256 _cSwapCounter,\\n    address stableToken\\n  ) external view override returns (uint256) {\\n    return preDepositedInputTokens[aFiContract][_cSwapCounter][stableToken];\\n  }\\n\\n  function doSwapForThewhiteListRemoval(\\n    address tok,\\n    uint256 _cSwapCounter,\\n    address swapToken,\\n    uint256 deadline,\\n    uint256 minAmountOut\\n  ) external override {\\n    uint256 redemptionBalance = preDepositedInputTokens[msg.sender][_cSwapCounter][tok];\\n    uint256 balToConsider = IERC20(swapToken).balanceOf(msg.sender);\\n    IAFi(msg.sender).swapViaStorageOrManager(\\n      tok,\\n      swapToken,\\n      redemptionBalance,\\n      deadline,\\n      WETH,\\n      minAmountOut\\n    );\\n    balToConsider = IERC20(swapToken).balanceOf(msg.sender) - balToConsider;\\n    delete preDepositedInputTokens[msg.sender][_cSwapCounter][tok];\\n    preDepositedInputTokens[msg.sender][_cSwapCounter][swapToken] += balToConsider;\\n  }\\n\\n  /**\\n   * @notice Pauses / unpauses specific swap methods in the contract.\\n   * @dev Requirements: Can only be invoked by the Delay Module.\\n   * @param methods An array of swap method IDs to be paused or unpaused.\\n   * @param statuses The status to set (true to pause, false to unpause).\\n   */\\n  function pauseSwapMethods(\\n    address afiContract,\\n    uint[] memory methods,\\n    bool[] memory statuses\\n  ) external {\\n    require(msg.sender == delayModule, \\\"Caller is not the Delay Module\\\"); // Ensures only the Delay Module can call this function\\n    for (uint i = 0; i \\u003c methods.length; i++) {\\n      swapMethodPaused[afiContract][methods[i]] = statuses[i];\\n    }\\n  }\\n\\n  /**\\n   * @notice Check if a swap method is paused.\\n   * @dev This function can be used in the `withdraw` function to validate if a swap method is paused.\\n   * @param swapMethod The ID of the swap method to check.\\n   */\\n  function isSwapMethodPaused(\\n    address afiContract,\\n    uint swapMethod\\n  ) public view override returns (bool) {\\n    return swapMethodPaused[afiContract][swapMethod];\\n  }\\n}\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface\\n{\\n}\\n\\n\\ninterface AggregatorV3Interface {\\n\\n  struct Phase {\\n    uint16 id;\\n    AggregatorV2V3Interface aggregator;\\n  }\\n\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  \\n  /**\\n   * @notice returns the current phase\\u0027s aggregator address.\\n   */\\n  function aggregator()\\n    external\\n    view\\n    returns (address);\\n\\n  function minAnswer() external view returns(uint);\\n\\n  function maxAnswer() external view returns(uint);\\n\\n}\"},\"ArrayUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\n// Reference: https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\\nlibrary ArrayUtils {\\n  /**\\n   * Deletes address at index and fills the spot with the last address.\\n   * Order is preserved.\\n   */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopAddress(address[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopUint256(uint[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sumOfMArrays(\\n    uint[] memory A,\\n    uint[] memory B\\n  ) internal pure returns (uint[] memory sum) {\\n    sum = new uint[](A.length);\\n    for (uint i = 0; i \\u003c A.length; i++) {\\n      sum[i] = A[i] + B[i];\\n    }\\n    return sum;\\n  }\\n\\n  /**\\n   * Finds the index of the first occurrence of the given element.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns (index and isIn) for the first occurrence starting from index 0\\n   */\\n  function indexOf(address[] memory A, address a) internal pure returns (uint, bool) {\\n    uint length = A.length;\\n    for (uint i = 0; i \\u003c length; i++) {\\n      if (A[i] == a) {\\n        return (i, true);\\n      }\\n    }\\n    return (type(uint).max, false);\\n  }\\n\\n  /**\\n   * Returns true if the value is present in the list. Uses indexOf internally.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns isIn for the first occurrence starting from index 0\\n   */\\n  function contains(address[] memory A, address a) internal pure returns (bool) {\\n    (, bool isIn) = indexOf(A, a);\\n    return isIn;\\n  }\\n\\n  /**\\n   * Returns true if there are 2 elements that are the same in an array\\n   * @param A The input array to search\\n   * @return Returns boolean for the first occurrence of a duplicate\\n   */\\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n    require(A.length \\u003e 0, \\\"A is empty\\\");\\n\\n    for (uint i = 0; i \\u003c A.length - 1; i++) {\\n      address current = A[i];\\n      for (uint j = i + 1; j \\u003c A.length; j++) {\\n        if (current == A[j]) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   * @return Returns the array with the object removed.\\n   */\\n  function remove(\\n    address[] memory A,\\n    address a\\n  ) internal pure returns (address[] memory) {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      (address[] memory _A, ) = pop(A, index);\\n      return _A;\\n    }\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   */\\n  function removeStorage(address[] storage A, address a) internal {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      uint lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\\n      if (index != lastIndex) {\\n        A[index] = A[lastIndex];\\n      }\\n      A.pop();\\n    }\\n  }\\n\\n  /**\\n   * Removes specified index from array\\n   * @param A The input array to search\\n   * @param index The index to remove\\n   * @return Returns the new array and the removed entry\\n   */\\n  function pop(\\n    address[] memory A,\\n    uint index\\n  ) internal pure returns (address[] memory, address) {\\n    uint length = A.length;\\n    require(index \\u003c A.length, \\\"Index must be \\u003c A length\\\");\\n    address[] memory newAddresses = new address[](length - 1);\\n    for (uint i = 0; i \\u003c index; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = index + 1; j \\u003c length; j++) {\\n      newAddresses[j - 1] = A[j];\\n    }\\n    return (newAddresses, A[index]);\\n  }\\n\\n  /**\\n   * Returns the combination of the two arrays\\n   * @param A The first array\\n   * @param B The second array\\n   * @return Returns A extended by B\\n   */\\n  function extend(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure returns (address[] memory) {\\n    uint aLength = A.length;\\n    uint bLength = B.length;\\n    address[] memory newAddresses = new address[](aLength + bLength);\\n    for (uint i = 0; i \\u003c aLength; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = 0; j \\u003c bLength; j++) {\\n      newAddresses[aLength + j] = B[j];\\n    }\\n    return newAddresses;\\n  }\\n\\n  /**\\n   * Validate that address and uint array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of uint\\n   */\\n  function validatePairsWithArray(address[] memory A, uint[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bool array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bool\\n   */\\n  function validatePairsWithArray(address[] memory A, bool[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and string array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of strings\\n   */\\n  function validatePairsWithArray(address[] memory A, string[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address array lengths match, and calling address array are not empty\\n   * and contain no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of addresses\\n   */\\n  function validatePairsWithArray(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bytes array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bytes\\n   */\\n  function validatePairsWithArray(address[] memory A, bytes[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate address array is not empty and contains no duplicate elements.\\n   *\\n   * @param A          Array of addresses\\n   */\\n  function _validateLengthAndUniqueness(address[] memory A) internal pure {\\n    require(A.length \\u003e 0, \\\"Array length must be \\u003e 0\\\");\\n    require(!hasDuplicate(A), \\\"Cannot duplicate addresses\\\");\\n  }\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\"},\"IAFi.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Extended as IERC20} from \\\"./IERC20Extended.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\n\\n/**\\n * @title PassiveRebal.\\n * @notice Interface of the Passive Rebalance contract.\\n */\\ninterface PassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    address[] memory _tokens,\\n    uint256 strategy\\n  ) external returns (uint[] memory proportions, uint256);\\n\\n  function getPauseStatus() external returns (bool);\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n}\\n\\ninterface IAFiOracle {\\n  function uniswapV3Oracle(\\n    address afiContract,\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint _amountIn,\\n    uint _maxTime,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (bytes memory swapParams);\\n}\\n\\ninterface IAFiManager {\\n  function updateUTokenProportion(\\n    address aFiContract,\\n    address aFiStorage\\n  ) external returns (uint256[] memory);\\n\\n  function inputTokenUSD(\\n    IAFi aFiContract,\\n    uint256 cSwapCounter,\\n    IAFiStorage _aFiStorage\\n  ) external view returns (uint256 totalPreDepositInUSD);\\n\\n  function rebalanceController() external view returns(address);\\n  function pauseQueueWithdrawUnstaking(address afiContract,bool status) external;\\n  function isQueueWithdrawUnstakingPaused(address afiContract) external view returns(bool);\\n}\\n\\n/**\\n * @title IAFi.\\n * @notice Interface of the AToken.\\n */\\ninterface IAFi {\\n\\n  struct UnderlyingData {\\n    address[] _underlyingTokens; //uTokens\\n    address[] _underlyingUniPoolToken; //uToken - MiddleToken\\n  }\\n\\n  struct PoolsData {\\n    address[] _depositStableCoin;\\n    address[] _depositCoinOracle;\\n    bytes underlyingData;\\n    address[] _compound;\\n    address[] _aaveToken;\\n    address[] _priceOracles;\\n    uint[] _underlyingTokensProportion;\\n    address[] compoundV3Comet;\\n    uint _typeOfProduct;\\n  }\\n\\n  struct SwapParameters {\\n    address afiContract;\\n    address oToken;\\n    uint256 cSwapFee;\\n    uint256 cSwapCounter;\\n    address[] depositTokens;\\n    uint256[] minimumReturnAmount;\\n    uint256[] iMinimumReturnAmount; // minimum amount out expcted after swaps For deposit tokens\\n    address[] underlyingTokens;\\n    uint256[] newProviders;\\n    uint _deadline;\\n    address[] cometToClaim;\\n    address[] cometRewardTokens;\\n    uint256[] rewardTokenMinReturnAmounts;\\n  }\\n\\n  /**\\n   * @notice Function to initialize the data, owner and afi token related data.\\n   * @dev the function should be called once only by factory\\n   * @param newOwner indicates the owner of the created afi product.\\n   * @param _name indicates the name of the afi Token\\n   * @param _symbol indicates symbol of the the afi Token.\\n   * @param data indicates the encoded data that follows the PoolsData struct format.\\n   * @param _isActiveRebalanced indicates the active rebalance status of the afi contract.\\n   * @param _aFiStorage indicates the afi storage contract address.\\n   */\\n  function initialize(\\n    address newOwner,\\n    string memory _name,\\n    string memory _symbol,\\n    bytes memory data,\\n    bool _isActiveRebalanced,\\n    IAFiStorage _aFiStorage,\\n    address[] memory _commonInputTokens\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize accepted tokens in deposit and withdraw functions.\\n   * @dev  the function should be called once only by factory\\n   * @param iToken indicates the array of the accepted token addressess.\\n   */\\n  function initializeToken(\\n    address[] memory iToken,\\n    address[] memory _teamWallets,\\n    IPassiveRebal _rebalContract,\\n    address _aFiManager\\n  ) external;\\n\\n  function getcSwapCounter() external view returns(uint256);\\n\\n  /**\\n   * @notice Returns the array of underlying tokens.\\n   * @return uTokensArray Array of underlying tokens.\\n   */\\n  function getUTokens() external view returns (address[] memory uTokensArray);\\n\\n  function swapViaStorageOrManager(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint deadline,\\n    address midTok,\\n    uint minimumReturnAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Returns the paused status of the contract.\\n   */\\n  function isPaused() external view returns (bool, bool);\\n\\n  function getProportions()\\n    external\\n    view\\n    returns (uint[] memory, uint[] memory);\\n\\n  /**\\n   * @notice Updates the pool data during Active Rebalance.\\n   * @param data that follows PoolsData format indicates the data of the token being rebalanced in Active Rebalance.\\n   */\\n  function updatePoolData(bytes memory data) external;\\n\\n  function sendProfitOrFeeToManager(\\n    address wallet,\\n    uint profitShare,\\n    address oToken\\n  ) external;\\n\\n  function _supplyCompV3(address tok, uint amount) external;\\n\\n  function _supplyAave(address tok, uint amount) external;\\n\\n  function _supplyCompound(address tok, uint amount) external;\\n\\n  function _withdrawAave(address tok, uint amount) external;\\n\\n  function _withdrawCompoundV3(address tok, uint amount) external;\\n\\n  function _withdrawCompound(address tok, uint amount) external;\\n\\n  function getTVLandRebalContractandType()\\n    external\\n    view\\n  returns (uint256, address, uint256);\\n\\n  function getInputToken() external view returns (address[] memory, address[] memory);\\n\\n  function swap(\\n    address inputToken,\\n    address uTok,\\n    uint256 amountAsPerProportion,\\n    uint _deadline,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (uint256);\\n\\n  function updateDp(\\n    uint256[] memory _defaultProportion,\\n    uint256[] memory _uTokensProportion\\n  ) external;\\n\\n  function updateuTokAndProp(\\n    address[] memory _uTokens\\n  ) external;\\n\\n  function underlyingTokensStaking(address[] memory _depositTokens) external returns(uint256 _totalProp);\\n\\n  function depositUserNav(address user) external view returns (uint256);\\n\\n  function setUnstakeData(uint256 totalQueuedShares) external returns (address[] memory, address[] memory, uint256, uint256);\\n\\n  function isOTokenWhitelisted(address oToken) external view returns (bool);\\n\\n  function validateWithdraw(address user, address oToken, uint256 _shares) external;\\n\\n function updateLockedTokens(\\n    address user,\\n    uint256 amount,\\n    bool lock,\\n    bool queue,\\n    bool unqueue,\\n    uint256 newNAV\\n  ) external;\\n\\n  function checkTVL(bool _updateTVL) external;\\n\\n  function updateInputTokens(address[] memory _inputTokens) external;\\n  \\n  function reinitializeHappened(bool status) external;\\n\\n  function getPreSwapDepositLimit() external view returns(uint256);\\n\\n  function pauseUnpauseDeposit(bool status) external;\\n}\"},\"IAFiFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\n\\ninterface IAFiFactory {\\n    event TokenCreated(address indexed token, string name, string symbol);\\n    event AddUnderlyingTokens(address indexed afiContract, address utoken);\\n\\n    function allUnderlyingTokensLength() external view returns (uint256);\\n\\n    function afiProductsCount() external view returns (uint256);\\n    \\n    function getPricePerFullShare(address afiContract, address afiStorage) external view returns (uint256);\\n\\n    function afiContractInitUpdate(address aFiContract, uint256 order) external;\\n\\n    function getAFiInitStatus(address aFiContract) external view returns (bool, bool);\\n\\n    function getAFiTokenStatus(address _aFiContract) external view returns (bool);\\n}\\n\"},\"IAFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAFiStorage.\\n * @notice Interface of the AFiStorage.\\n */\\n\\ninterface IIEarnManager {\\n  function recommend(\\n    address _token,\\n    address afiBase,\\n    address afiStorage\\n  ) external view returns (string memory choice, uint capr, uint aapr, uint dapr);\\n}\\n\\ninterface IAFiStorage {\\n  /**\\n   * @notice Struct representing investor details.\\n   * @param isPresent Boolean indicating whether an investor exists.\\n   * @param uTokenBalance Investor underlying token balance.\\n   * @param investedAmount Amount of StableCoin invested in the underlying token\\n   */\\n  struct Investor {\\n    bool isPresent;\\n    uint depositNAV;\\n    uint redemptionNAV;\\n  }\\n\\n  struct RedemptionParams {\\n        address baseContract;\\n        uint r;\\n        address oToken;\\n        uint256 cSwapCounter;\\n        address[] uTokens;\\n        address[] iTokens;\\n        uint256 deadline;\\n        uint256[] minimumReturnAmount;\\n        uint256 _pool;\\n        uint256 tSupply;\\n        uint256 depositNAV;\\n    }\\n\\n  /**\\n   * @notice Struct representing TeamWallet details.\\n   * @param isPresent Boolean indicating whether a wallet exists.\\n   * @param isActive Boolean indicating whether a wallet is active.\\n   * @param walletAddress Wallet address.\\n   */\\n  struct TeamWallet {\\n    bool isPresent;\\n    bool isActive;\\n    address walletAddress;\\n  }\\n\\n  /**\\n   * @notice Struct representing Rebalance details.\\n   * @param scenario Scenario can be either of 0, 1 or 2.\\n   * @param rebalancedUToken Address of the underlying token that is rebalanced.\\n   * @param rebalancedToUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   */\\n  struct RebalanceDetails {\\n    uint8 scenario;\\n    address rebalancedUToken;\\n    address[] rebalancedToUTokens;\\n  }\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletActive(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletAdd(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) external view returns (bool isPresent, bool isActive);\\n\\n\\n\\n   function handleRedemption(RedemptionParams memory params, uint _shares, uint swapMethod) external  returns (uint256 redemptionFromContract);\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address _wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external;\\n\\n  /**\\n   * @notice Returns the team wallets for an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) external view returns (address[] memory _teamWallets);\\n\\n  /**\\n   * @notice Sets the address for team wallets.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets Array of addresses for the team wallets.\\n   */\\n  function setTeamWallets(address aFiContract, address[] memory _teamWallets) external;\\n\\n  /**\\n   * @notice Sets the status for the AFi in the storage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external;\\n\\n  /**\\n   * @notice Sets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param status indicating active rebalance status of the AFi contract.\\n   */\\n  function setActiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  /**\\n   * @notice gets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _isActiveRebalanced bool indicating active rebalance status of the AFi contract.\\n   */\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view returns (bool _isActiveRebalanced);\\n\\n  function getTotalActiveWallets(address aFiContract) external view returns (uint);\\n\\n  function calcPoolValue(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculatePoolInUsd(address afiContract) external view returns (uint);\\n\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    address compV3Comet,\\n    address compTok\\n  ) external;\\n\\n  function getPriceInUSDC(\\n    address tok\\n  ) external view returns (uint256, uint256);\\n\\n  function validateAndGetDecimals(address tok) external view returns (uint256);\\n\\n  function getStakedStatus(\\n    address aFiContract,\\n    address uToken\\n  ) external view returns (bool);\\n\\n  function rearrange(address aFiContract,address[] memory underlyingTokens, uint256[] memory newProviders) external;\\n\\n  function swapForOtherProduct(\\n    address afiContract,\\n    uint r,\\n    address oToken,\\n    uint deadline,\\n    uint[] memory minimumReturnAmount,\\n    address[] memory uToken\\n  ) external returns (uint256);\\n\\n  function _withdrawAll(address afiContract, address tok) external returns(bool);\\n  function getAFiOracle() external view returns(address);\\n\\n  function calculateRedemptionFromContract(\\n    address afiContract,\\n    address tok,\\n    uint256 r\\n  ) external view returns (uint256, bool, uint256, uint256, uint256);\\n\\n\\n\\n  function tvlRead(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint, uint256);\\n\\n  function getPreSwapDepositsTokens(\\n    address aFiContract,\\n    uint256 _cSwapCounter,\\n    address stableToken\\n  ) external view returns (uint256);\\n\\n  function setPreDepositedInputToken(uint256 _cSwapCounter, uint256 _amount,address _oToken) external;\\n  function setPreDepositedInputTokenInRebalance(\\n    address aficontract,\\n    uint256 _cSwapCounter,\\n    uint256 _amount,\\n    address _oToken\\n  ) external;\\n\\n  function convertInUSDAndTok(\\n    address tok,\\n    uint256 amt,\\n    bool usd\\n  ) external view returns (uint256);\\n\\n  function calculateShares(\\n    address afiContract,\\n    uint256 amount,\\n    uint256 prevPool,\\n    uint256 _totalSupply,\\n    address iToken,\\n    uint256 currentDepositNAV,\\n    uint256 prevBalance\\n  ) external view returns (uint256 shares, uint256 newDepositNAV);\\n\\n  function deletePreDepositedInputToken(\\n    address aFiContract,\\n    address oToken,\\n    uint256 currentCounter\\n  )external;\\n\\n  function doSwapForThewhiteListRemoval(\\n    address tok,\\n    uint256 _cSwapCounter,\\n    address swapToken,\\n    uint256 deadline,\\n    uint256 minAmountOut\\n  ) external;\\n\\n  function isSwapMethodPaused(address afiContract,uint swapMethod) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\"},\"IERC20Extended.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\"},\"IPassiveRebal.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.0;\\n\\ninterface IPassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    address[] memory _tokens,\\n    uint256 strategy\\n  ) external returns (uint[] memory proportions, uint256 totalProp);\\n\\n  function getPauseStatus() external returns (bool);\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function uniswapV3Oracle(\\n    address afiContract,\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint _amountIn,\\n    uint _maxTime,\\n    address middleToken,\\n    uint256 minimumReturnAmount\\n  ) external returns (bytes memory swapParams);\\n  function getPool(address tok, address midTok) external view returns (address);\\n\\n  function upDateInputTokPool(address[] memory iToken, bytes memory uniData) external;\\n\\n  function getPriceOracle(address tok) external view returns (address);\\n\\n  function updateOracleData(\\n    address _uToken,\\n    address _oracleAddress\\n  ) external;\\n\\n   function removeToken(\\n    address[] memory _nonOverlappingITokens,\\n    address token\\n  ) external pure returns (address[] memory);\\n\\n  function initUniStructure(\\n    address[] memory inputTokens,\\n    bytes memory _poolData\\n  ) external;\\n}\\n\"},\"IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./IUniswapV3Factory.sol\\\";\\nimport \\\"./IAFi.sol\\\";\\n\\ninterface IUniswapOracleV3 {\\n  function PERIOD() external returns (uint256);\\n  function factory() external returns (address);\\n  function getTotalProfit() external view returns (uint256);\\n  function getDaoProfit() external view returns (uint256);\\n  function update(address _tokenIn, address _tokenOut) external;\\n\\n  function quotePrice(IAFi aFiContract,address _tokenIn, address _depositToken, uint256 _amount) external view returns (uint256 price);\\n\\n\\n  function consult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external view returns (uint256 _amountOut);\\n\\n  function estimateAmountOut(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut\\n  ) external view returns (uint amountOut);\\n\\n  function estimateAmountOutMin(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut,\\n    address pool\\n  ) external view returns (uint amountOut);\\n\\n  function updateAndConsult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external returns (uint256 _amountOut);\\n\\n  function checkUnderlyingPool(address token) external view returns (bool hasPool);\\n  function getStalePriceDelay(address aFiContract, address uToken) external view returns(uint256);\\n  function getPriceAndDecimals(address aFiContract, address uToken, address feed) external view returns(int256 , uint8 );\\n  function getPriceInUSDC(address tok) external view returns (uint256, uint256);\\n  function getMidToken(address tok) external view returns (address);\\n  function updateMidToken(address[] memory tok, address[] memory midTok) external;\\n  function setRedeemData(address _oToken, uint256 _batchWithdrawCounter, uint256 _totalShares, uint256 _oTokenUnits) external;\\n  function getControllers(address afiContract) external view returns(address, address);\\n  function cumulativeSwap(\\n    IAFi.SwapParameters memory params\\n  ) external;\\n}\\n\"},\"IUniswapV3Factory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n  /// @notice Emitted when the owner of the factory is changed\\n  /// @param oldOwner The owner before the owner was changed\\n  /// @param newOwner The owner after the owner was changed\\n  event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n  /// @notice Emitted when a pool is created\\n  /// @param token0 The first token of the pool by address sort order\\n  /// @param token1 The second token of the pool by address sort order\\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n  /// @param tickSpacing The minimum number of ticks between initialized ticks\\n  /// @param pool The address of the created pool\\n  event PoolCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint24 indexed fee,\\n    int24 tickSpacing,\\n    address pool\\n  );\\n\\n  /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n  /// @param fee The enabled fee, denominated in hundredths of a bip\\n  /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n  event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n  /// @notice Returns the current owner of the factory\\n  /// @dev Can be changed by the current owner via setOwner\\n  /// @return The address of the factory owner\\n  function owner() external view returns (address);\\n\\n  /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n  /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n  /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n  /// @return The tick spacing\\n  function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n  /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n  /// @param tokenA The contract address of either token0 or token1\\n  /// @param tokenB The contract address of the other token\\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n  /// @return pool The pool address\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) external view returns (address pool);\\n\\n  /// @notice Creates a pool for the given two tokens and fee\\n  /// @param tokenA One of the two tokens in the desired pool\\n  /// @param tokenB The other of the two tokens in the desired pool\\n  /// @param fee The desired fee for the pool\\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n  /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n  /// are invalid.\\n  /// @return pool The address of the newly created pool\\n  function createPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) external returns (address pool);\\n\\n  /// @notice Updates the owner of the factory\\n  /// @dev Must be called by the current owner\\n  /// @param _owner The new owner of the factory\\n  function setOwner(address _owner) external;\\n\\n  /// @notice Enables a fee amount with the given tickSpacing\\n  /// @dev Fee amounts may never be removed once enabled\\n  /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n  /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\\ninterface IUniswapV3Pool {\\n  function observe(\\n    uint32[] calldata secondsAgos\\n  ) external\\n    view\\n    returns (\\n      int56[] memory tickCumulatives,\\n      uint160[] memory secondsPerLiquidityCumulativeX128s\\n    );\\n\\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n  function fee() external returns(uint24);\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address internal _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    // /**\\n    //  * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n    //  * Can only be called by the current owner.\\n    //  */\\n    // function transferOwnership(address newOwner) public virtual override onlyOwner {\\n    //     _pendingOwner = newOwner;\\n    //     emit OwnershipTransferStarted(owner(), newOwner);\\n    // }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\"},\"OwnableDelayModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\ncontract OwnableDelayModule is Ownable2Step {\\n  address internal delayModule;\\n\\n  constructor() {\\n    delayModule = msg.sender;\\n  }\\n\\n  function isDelayModule() internal view {\\n    require(msg.sender == delayModule, \\\"NA\\\");\\n  }\\n\\n  function setDelayModule(address _delayModule) external {\\n    isDelayModule();\\n    require(_delayModule != address(0), \\\"ODZ\\\");\\n    delayModule = _delayModule;\\n  }\\n\\n  function getDelayModule() external view returns (address) {\\n    return delayModule;\\n  }\\n\\n  /**\\n   * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public override {\\n    isDelayModule();\\n    _pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(owner(), newOwner);\\n  }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"},\"SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value \\u003c= type(uint248).max, \\\"SafeCast: value doesn\\u0027t fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value \\u003c= type(uint240).max, \\\"SafeCast: value doesn\\u0027t fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value \\u003c= type(uint232).max, \\\"SafeCast: value doesn\\u0027t fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value \\u003c= type(uint224).max, \\\"SafeCast: value doesn\\u0027t fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value \\u003c= type(uint216).max, \\\"SafeCast: value doesn\\u0027t fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value \\u003c= type(uint208).max, \\\"SafeCast: value doesn\\u0027t fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value \\u003c= type(uint200).max, \\\"SafeCast: value doesn\\u0027t fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value \\u003c= type(uint192).max, \\\"SafeCast: value doesn\\u0027t fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value \\u003c= type(uint184).max, \\\"SafeCast: value doesn\\u0027t fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value \\u003c= type(uint176).max, \\\"SafeCast: value doesn\\u0027t fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value \\u003c= type(uint168).max, \\\"SafeCast: value doesn\\u0027t fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value \\u003c= type(uint160).max, \\\"SafeCast: value doesn\\u0027t fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value \\u003c= type(uint152).max, \\\"SafeCast: value doesn\\u0027t fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value \\u003c= type(uint144).max, \\\"SafeCast: value doesn\\u0027t fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value \\u003c= type(uint136).max, \\\"SafeCast: value doesn\\u0027t fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value \\u003c= type(uint128).max, \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value \\u003c= type(uint120).max, \\\"SafeCast: value doesn\\u0027t fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value \\u003c= type(uint112).max, \\\"SafeCast: value doesn\\u0027t fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value \\u003c= type(uint104).max, \\\"SafeCast: value doesn\\u0027t fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value \\u003c= type(uint96).max, \\\"SafeCast: value doesn\\u0027t fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value \\u003c= type(uint88).max, \\\"SafeCast: value doesn\\u0027t fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value \\u003c= type(uint80).max, \\\"SafeCast: value doesn\\u0027t fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value \\u003c= type(uint72).max, \\\"SafeCast: value doesn\\u0027t fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value \\u003c= type(uint64).max, \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value \\u003c= type(uint56).max, \\\"SafeCast: value doesn\\u0027t fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value \\u003c= type(uint48).max, \\\"SafeCast: value doesn\\u0027t fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value \\u003c= type(uint40).max, \\\"SafeCast: value doesn\\u0027t fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value \\u003c= type(uint32).max, \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value \\u003c= type(uint24).max, \\\"SafeCast: value doesn\\u0027t fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value \\u003c= type(uint16).max, \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity\\u0027s `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value \\u003c= type(uint8).max, \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value \\u003e= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity\\u0027s `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity\\u0027s `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity\\u0027s `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity\\u0027s `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity\\u0027s `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity\\u0027s `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity\\u0027s `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity\\u0027s `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity\\u0027s `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity\\u0027s `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity\\u0027s `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity\\u0027s `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity\\u0027s `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity\\u0027s `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity\\u0027s `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity\\u0027s `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity\\u0027s `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity\\u0027s `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity\\u0027s `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity\\u0027s `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity\\u0027s `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity\\u0027s `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity\\u0027s `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity\\u0027s `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity\\u0027s `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity\\u0027s `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity\\u0027s `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity\\u0027s `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity\\u0027s `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity\\u0027s `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity\\u0027s `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value \\u003c= uint256(type(int256).max), \\\"SafeCast: value doesn\\u0027t fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aFiManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleV3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_passiveRebal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aFiFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"DeactivateTeamWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teamWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitShareDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ReActivateTeamWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetAFiActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetAFiManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetActiveRebalancedStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"TeamWalletActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"TeamWalletAdd\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"_withdrawAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aFiFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"aaveTokenCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPresent\",\"type\":\"bool\"}],\"name\":\"addTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveTok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compComet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compTok\",\"type\":\"address\"}],\"name\":\"afiSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceAave\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceCompV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceCompoundInToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"calcPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"calculateBalanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"calculatePoolInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"calculateRedemptionFromContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakedStatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"redemptionValueFromContract\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tvl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentDepositNAV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevBalance\",\"type\":\"uint256\"}],\"name\":\"calculateShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDepositNAV\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"compoundCometCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"compoundCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usd\",\"type\":\"bool\"}],\"name\":\"convertInUSDAndTok\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"deactivateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentCounter\",\"type\":\"uint256\"}],\"name\":\"deletePreDepositedInputToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"doSwapForThewhiteListRemoval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAFiOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelayModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stableToken\",\"type\":\"address\"}],\"name\":\"getPreSwapDepositsTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"getPriceInUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"getStakedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTeamWalletDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPresent\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"getTeamWalletsOfAFi\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_teamWallets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"getTotalActiveWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"baseContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"uTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"iTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositNAV\",\"type\":\"uint256\"}],\"internalType\":\"struct IAFiStorage.RedemptionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMethod\",\"type\":\"uint256\"}],\"name\":\"handleRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redemptionFromContract\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAFiActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"isAFiActiveRebalanced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isActiveRebalanced\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapMethod\",\"type\":\"uint256\"}],\"name\":\"isSwapMethodPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"methods\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"}],\"name\":\"pauseSwapMethods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"preDepositedInputTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"reActivateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"underlyingTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newProviders\",\"type\":\"uint256[]\"}],\"name\":\"rearrange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setAFiActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aFiManager\",\"type\":\"address\"}],\"name\":\"setAFiManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setActiveRebalancedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delayModule\",\"type\":\"address\"}],\"name\":\"setDelayModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setMaxSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oToken\",\"type\":\"address\"}],\"name\":\"setPreDepositedInputToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aficontract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cSwapCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oToken\",\"type\":\"address\"}],\"name\":\"setPreDepositedInputTokenInRebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setStablesWithdrawalLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_teamWallets\",\"type\":\"address[]\"}],\"name\":\"setTeamWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stablesWithdrawalLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stablesWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumReturnAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"uToken\",\"type\":\"address[]\"}],\"name\":\"swapForOtherProduct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapMethodPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"tvlRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapOracleV3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"validateAndGetDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AFiStorage", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002b8463052e2878f9b38ae9627344ecc88111617d00000000000000000000000011747c3284b5f8088e815e5cf2e5c3062da55d5b00000000000000000000000025b5720e9b20be18b4d020153ac26d957c83e341000000000000000000000000a4c0babb949569cc20f83ee891f620aaeed9a5ab", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f46b70757a5e8731363fd47aa026c146d0f38cf4e4dc2c926a96d77f1a96278f"}