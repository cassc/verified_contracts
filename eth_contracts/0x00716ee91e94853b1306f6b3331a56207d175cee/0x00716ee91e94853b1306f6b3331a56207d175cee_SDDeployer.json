{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n//optimize 100\r\n/// Standard IERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function owner() external view returns(address);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// Factory interface of uniswap and forks\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n/// First part of the router interface of uniswap and forks\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n/// Second part of the router interface of uniswap and forks\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n/// Interface for the pairs of uniswap and forks\r\ninterface IPair {\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function token0() external view returns(address);\r\n    function token1() external view returns(address);\r\n    function sync() external;\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns(uint);\r\n}\r\n\r\ninterface Dataport {\r\n    function DATA_READ() external view returns(address);\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value);\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/// Transfer Helper to ensure the correct transfer of the tokens or ETH\r\nlibrary SafeTransfer {\r\n    using Address for address;\r\n    /** Safe Transfer asset from one wallet with approval of the wallet\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param from: the wallet to take from\r\n    * @param amount: the amount to take from the wallet\r\n    **/\r\n    function _pullUnderlying(IERC20 erc20, address from, uint amount) internal\r\n    {\r\n        safeTransferFrom(erc20,from,address(this),amount);\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /** Safe Transfer asset to one wallet from within the contract\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param to: the wallet to send to\r\n    * @param amount: the amount to send from the contract\r\n    **/\r\n    function _pushUnderlying(IERC20 erc20, address to, uint amount) internal\r\n    {\r\n        safeTransfer(erc20,to,amount);\r\n    }\r\n\r\n    /** Safe Transfer ETH to one wallet from within the contract\r\n    * @param to: the wallet to send to\r\n    * @param value: the amount to send from the contract\r\n    **/\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface Logic{\r\n    function createSD(string memory n, string memory symbol, uint supply, uint[12] memory fee, bool sb, address ownerAddr, address backingTokenAddress, bool _LGE) external returns (address);\r\n    function afterConstructor() external;\r\n    function sdOwner() external view returns(address);\r\n    function backingAsset() external view returns(address);\r\n}\r\n\r\n/// Main contract that deploys smartdefi contract and can be used to verify the original code\r\ncontract SDDeployer {\r\n    mapping(address => address) public creatorOfSD; // tracker for bridge\r\n    mapping(address => address) public SDOfCreator; // enforce unique names\r\n    mapping(string => bool) public useInfo; // enforce unique info names\r\n    mapping(string => bool) public use; // enforce unique names\r\n    mapping(address => uint256[]) public tick; // balance data tracking\r\n    mapping(address => Protector) public protect; // slippage user data for front run protection\r\n    mapping(address => mapping(string => string)) public info; // project information data\r\n    mapping(address => string[]) private news; // project news feed\r\n    mapping(address => string[]) public usedInfoStrings; // used data strings for project, for ui tracking\r\n    mapping(address => mapping(address => KYC)) private kyc; // \r\n    mapping(address => uint256) public KYCopen;\r\n    mapping(address => mapping(string => bool)) public usedInfoStringsBool; // bool to confirm used info string\r\n    mapping(address => mapping(address => uint256[])) public myTickets;\r\n    mapping(address => mapping(address => bool)) public isSupport;\r\n    mapping(address => mapping(address => uint256[])) public myReplied;\r\n    mapping(address => Tickets[]) private ticket;\r\n    mapping(address => uint256) public ticketsOpened;\r\n    mapping(address => uint256) public ticketsClosed;\r\n    mapping(address => uint256) public minTicketCost;\r\n    mapping(address => uint256) public heldDonation;\r\n    mapping(address => uint256) public karma;\r\n    mapping(address => uint256) public karmaDonation;\r\n    mapping(address => mapping(address => uint256)) public lastKarma;\r\n    mapping(address => address) public donationLocation;\r\n    address[] public allSD; // A pseudo list of all SD addresses in order.\r\n    address public logic = 0x7a8B3a2c9e2d6506045fA95180be608c95cf2a30; // SD logic address\r\n    address public dataread;\r\n    uint256 public length = 0; // public read for total SD created\r\n    uint256 public minDonation = 1e15;\r\n    string internal fill = \"Awaiting\"; // Standard fill for submission of support and suggestions.\r\n    bool public on = false;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    mapping(address => bool) whitelist;\r\n    uint256 private _status;\r\n    uint256 private _status2;\r\n    event Created(string name, address pair);\r\n    event SetProtection(address user, uint256 slippage);\r\n    event Dock(string symbol, bool _bool);\r\n    event DockInfo(string symbol, bool _bool);\r\n    event ConfirmKYC(address sd, address who);\r\n    event UpdateInformation(string choice, string input);\r\n    event AddNews(address sd, string input);\r\n    event EditNews(address sd, uint256 id, string input);\r\n    event SubmitKYC(address sd, address user);\r\n    event GiveKarma(address sd, uint256 choice);\r\n    event SubmitTicket(address sd, address user, uint256 id);\r\n    event ReplyTicket(address sd, uint256 id);\r\n\r\n    constructor() {        \r\n    dataread = Dataport(0xcCeD1a96321B2B2a06E8F3F4B0B883dDD059968c).DATA_READ();\r\n    address feg = 0xF3c7CECF8cBC3066F9a87b310cEBE198d00479aC;\r\n    address own = 0x4b01518524845a2E32cA4B136e8d05Cc0Ef1Ca78;\r\n    creatorOfSD[feg] = own;\r\n    SDOfCreator[own] = feg;\r\n    allSD.push(feg);\r\n    length += 1;\r\n    isSupport[feg][own] = true;\r\n    minTicketCost[feg] = minDonation;\r\n    ticket[feg].push();\r\n    news[feg].push();\r\n    donationLocation[feg] = own;\r\n    string memory f = 'FEG';\r\n    use[f] = true;\r\n    _status = _NOT_ENTERED;\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED || whitelist[msg.sender], \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function addWhitelist(address toAdd) internal {\r\n        whitelist[toAdd] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for holders to make get support directly from project leaders in real time\r\n     */\r\n    struct Tickets {\r\n        address sd;\r\n        address user;\r\n        address lastAdmin;\r\n        string[] question;\r\n        string[] answer;\r\n        uint256 donation;\r\n        uint256 time;\r\n        bool closed;\r\n    }\r\n\r\n    struct KYC {\r\n        string document;\r\n        uint256 donation;\r\n        uint256 time;\r\n        bool confirmed;\r\n    }\r\n\r\n    function dock(string[] memory sym, bool[] memory _bool) external {\r\n        require(Reader(dataread).isAdmin(msg.sender) || Reader(dataread).isSetter(msg.sender));\r\n        for(uint256 i = 0; i < sym.length; i++) {\r\n        use[sym[i]] = _bool[i];\r\n        emit Dock(sym[i], _bool[i]);\r\n        }\r\n    }\r\n\r\n    function setOn(bool _bool) external {        \r\n        require(Reader(dataread).isAdmin(msg.sender) || Reader(dataread).superAdmin(msg.sender));\r\n        on = _bool;\r\n    }\r\n\r\n    function openTickets(address sd, uint256 start, uint256 amount) external view returns(uint256[] memory ids) {\r\n        uint256 a = amount > 0 ? amount : ticket[sd].length;\r\n        require(start + a <= ticket[sd].length, \"over\");\r\n        uint256 b = 0;\r\n        ids = new uint256[](a);\r\n        for(uint256 i = start; i < start + a; i++) {\r\n            if(!ticket[sd][i].closed) {\r\n                ids[b] = i;\r\n                b++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev you can submit your suggestions with this function simply type out your suggestion and submit the transaction\r\n     */\r\n    function submitTicket(address sd, string memory _question) external payable {\r\n        uint256 cost = minTicketCost[sd];\r\n        if(cost > 0) {\r\n        require(msg.value == cost, \"min\");\r\n        }\r\n        ticket[sd].push();\r\n        uint256 id = ticket[sd].length - 1;\r\n        ticket[sd][id].sd = sd;\r\n        ticket[sd][id].question.push(_question);\r\n        ticket[sd][id].user = msg.sender;\r\n        if(cost > 0) {\r\n        ticket[sd][id].donation = msg.value;\r\n        heldDonation[sd] += msg.value;\r\n        }\r\n        ticket[sd][id].time = block.timestamp;\r\n        myTickets[sd][msg.sender].push(ticket[sd].length - 1);\r\n        ticketsOpened[sd] += 1;\r\n        emit SubmitTicket(sd, msg.sender, id);\r\n    }\r\n\r\n    function recoverDonation(address sd, uint256 id) external nonReentrant() {\r\n        require(ticket[sd][id].user == msg.sender, \"user\");\r\n        require(block.timestamp > ticket[sd][id].time + 72 hours , \"!expired\");\r\n        uint256 d = ticket[sd][id].donation;\r\n        uint256 k = kyc[sd][msg.sender].donation;\r\n        require(d + k > 0, \"no donation\"); \r\n        if(k > 0) {\r\n        d += k;\r\n        KYCopen[sd] -= 1;\r\n        kyc[sd][msg.sender].donation = 0;\r\n        }\r\n        if(d > 0) {\r\n        ticketsOpened[sd] -= 1;\r\n        ticket[sd][id].donation = 0;\r\n        }\r\n        heldDonation[sd] = d > heldDonation[sd] ? 0 : heldDonation[sd] - d;\r\n        SafeTransfer.safeTransferETH(msg.sender, d);\r\n    }\r\n\r\n    function giveKarma(address sd, uint256 choice) external payable nonReentrant() {\r\n        require(msg.value == karmaDonation[sd], \"min\");\r\n        require(block.timestamp > lastKarma[msg.sender][sd] + 1 days, \"1 day\");\r\n        bool d;\r\n        (uint256[] memory _balances, uint256[] memory blockNumbers) = Reader(sd).allLastBalance(msg.sender);\r\n        for(uint256 i = 0; i < _balances.length; i++) {\r\n        if(blockNumbers[i] < block.number - 5 && IERC20(sd).balanceOf(msg.sender) >= _balances[i]) {\r\n            d = true;\r\n            break;\r\n        }\r\n        }\r\n        require(d, \"!5blocks\");\r\n        karma[sd] = choice == 0 ? karma[sd] + 1 : karma[sd] > 0 ? karma[sd] - 1 : 0;\r\n        if(karmaDonation[sd] > 0) {\r\n        SafeTransfer.safeTransferETH(donationLocation[sd], msg.value);\r\n        }\r\n        lastKarma[msg.sender][sd] = block.timestamp;\r\n        emit GiveKarma(sd, choice);\r\n    }\r\n\r\n    function setKarmaDonation(address sd, uint256 amt) external {\r\n        require(Logic(sd).sdOwner() == msg.sender, \"owner\");\r\n        require(amt <= 1e17, \"1e17\");\r\n        karmaDonation[sd] = amt;\r\n    }\r\n\r\n    function setDonationLocation(address sd, address location) external {\r\n        require(Logic(sd).sdOwner() == msg.sender, \"owner\");\r\n        donationLocation[sd] = location;\r\n    }\r\n\r\n    function submitKYC(address sd, string memory document) external payable{\r\n        require(!kyc[sd][msg.sender].confirmed && kyc[sd][msg.sender].time == 0, \"already\");\r\n        uint256 cost = minTicketCost[sd];\r\n        if(cost > 0) {\r\n        require(msg.value == cost, \"min\");\r\n        kyc[sd][msg.sender].donation = msg.value;\r\n        heldDonation[sd] += cost;\r\n        }\r\n        kyc[sd][msg.sender].document = document;\r\n        kyc[sd][msg.sender].time = block.timestamp;\r\n        KYCopen[sd] += 1;\r\n        emit SubmitKYC(sd, msg.sender);\r\n    }\r\n\r\n    function confirmKYC(address sd, address user) external {\r\n        require(isSupport[sd][msg.sender], \"not support\");\r\n        require(!kyc[sd][user].confirmed && kyc[sd][msg.sender].time > 0, \"already\");\r\n        KYCopen[sd] -= 1;\r\n        uint256 don = kyc[sd][user].donation;\r\n        kyc[sd][user].confirmed = true;\r\n        if(don > 0) {\r\n        kyc[sd][user].donation = 0;\r\n        SafeTransfer.safeTransferETH(msg.sender, don);        \r\n        heldDonation[sd] = don > heldDonation[sd] ? 0 : heldDonation[sd] - don;\r\n        }\r\n        emit ConfirmKYC(sd, user);\r\n    }\r\n\r\n    function viewKYC(address sd, address user) external view returns(string memory document, bool confirmed) {\r\n        if(isSupport[sd][msg.sender]) {\r\n        document = kyc[sd][user].document;\r\n        confirmed = kyc[sd][user].confirmed;\r\n        }\r\n        else {\r\n        document = kyc[sd][msg.sender].document;\r\n        confirmed = kyc[sd][msg.sender].confirmed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to view suggestion enter the user address and suggestionID(ticket#) note: only the user and isAdmin can view support tickets\r\n     */\r\n    function viewTicket(address sd, uint256 ticketID) external view returns(string[] memory question, string[] memory answer, address lastAdmin, uint256 donation, uint256 time) {\r\n        require(ticket[sd][ticketID].user == msg.sender || isSupport[sd][msg.sender], \"only\");\r\n        uint256 i;\r\n        question = new string[](ticket[sd][ticketID].question.length);\r\n        answer = new string[](ticket[sd][ticketID].answer.length);\r\n\r\n        for(i = 0; i > ticket[sd][ticketID].question.length; i++) {\r\n            question[i] = ticket[sd][ticketID].question[i];\r\n        }\r\n\r\n        for(i = 0; i > ticket[sd][ticketID].answer.length; i++) {\r\n            answer[i] = ticket[sd][ticketID].answer[i];\r\n        }\r\n\r\n        lastAdmin = ticket[sd][ticketID].lastAdmin;\r\n        donation = ticket[sd][ticketID].donation;\r\n        time = ticket[sd][ticketID].time;\r\n    }\r\n\r\n    /**\r\n     * @dev only isAdmin can use this function to reply to suggestions, enter the users address, suggestID and reply to log a reply to the suggestion.\r\n     */\r\n    function replyTicket(address sd, uint256 ticketID, string memory _answer) external nonReentrant() {\r\n        address user = ticket[sd][ticketID].user;\r\n        require(isSupport[sd][msg.sender] || user == msg.sender, \"Only\");\r\n        uint256 don = ticket[sd][ticketID].donation;\r\n        if(msg.sender != user) {\r\n        ticket[sd][ticketID].answer.push(_answer);\r\n        ticket[sd][ticketID].lastAdmin = msg.sender;\r\n        myReplied[msg.sender][sd].push(ticketID);\r\n        if(don > 0) {\r\n        SafeTransfer.safeTransferETH(msg.sender, don);\r\n        heldDonation[sd] = don > heldDonation[sd] ? 0 : heldDonation[sd] - don;\r\n        ticket[sd][ticketID].donation = 0;\r\n        }\r\n        if(!ticket[sd][ticketID].closed) {\r\n        ticketsClosed[sd] += 1;\r\n        ticket[sd][ticketID].closed = true;\r\n        }\r\n        }\r\n\r\n        if(msg.sender == user) {\r\n        myReplied[user][sd].push(ticketID);\r\n        ticket[sd][ticketID].question.push(_answer);\r\n        if(ticket[sd][ticketID].closed) {\r\n        ticketsClosed[sd] = ticketsClosed[sd] > 1 ? ticketsClosed[sd] - 1 : 0;\r\n        ticket[sd][ticketID].closed = false;\r\n        }\r\n        }\r\n        emit ReplyTicket(sd, ticketID);\r\n    }\r\n\r\n    /**\r\n     * @dev can add or remove admins with this function, true = isAdmin, false = notAdmin. Admins cannot do anything to change the contract they can only reply to support tickets and suggestions.\r\n     */\r\n    function setSupport(address sd, address _supporter, bool _bool) external {\r\n        require(msg.sender == Logic(sd).sdOwner());\r\n        isSupport[sd][_supporter] = _bool;\r\n    }\r\n\r\n    function setMinDonation(address sd, uint256 amt) external {\r\n        require(msg.sender == Logic(sd).sdOwner());\r\n        require(amt <= 1e17, \"0.1\");\r\n        minTicketCost[sd] = amt;\r\n    }\r\n\r\n    function mySupportIDs(address sd, address user) external view returns(uint256[] memory ids) {\r\n        uint256 a = myTickets[sd][user].length;\r\n        ids = new uint256[](a);\r\n        for(uint256 i = 0; i < a; i++) {\r\n            ids[i] = myTickets[sd][user][i];\r\n        }\r\n    }\r\n\r\n    function supportReplyIDs(address sd, address user) external view returns(uint256[] memory ids) {\r\n        uint256 a = myReplied[user][sd].length;\r\n        ids = new uint256[](a);\r\n        for(uint256 i = 0; i < a; i++) {\r\n            ids[i] = myReplied[user][sd][i];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Onchain information system for project data, which can provide official links, verify admin contacts etc.\r\n    * @param sd : address of SD token\r\n    * @param choice : string input example: twitter\r\n    * @param input : string input example: https://twitter.com/fegtoken\r\n    **/\r\n    function updateInformation(address sd, string[] memory choice, string[] memory input) external {\r\n        uint256 a = input.length;\r\n        uint256 b = choice.length;\r\n        require(a == b, \"same\");\r\n        require(isSD(sd), \"Not SD\");\r\n        require(msg.sender == Logic(sd).sdOwner());\r\n        for(uint256 i = 0; i < a; i++) {\r\n            require(!useInfo[input[i]], \"docked\");\r\n            info[sd][choice[i]] = input[i];\r\n            emit UpdateInformation(choice[i], input[i]);\r\n            if(!usedInfoStringsBool[sd][choice[i]]) {\r\n            usedInfoStrings[sd].push(choice[i]);\r\n            usedInfoStringsBool[sd][choice[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // function to view all news array\r\n    function viewAllNews(address sd) external view returns(string[] memory posts) {\r\n        uint256 l = news[sd].length;\r\n        posts = new string[](l);\r\n        for(uint256 i = 0; i < l; i++) {\r\n            posts[i] = news[sd][i];\r\n        }\r\n    }\r\n\r\n    // function to view single news article\r\n    function viewNews(address sd, uint256 id) external view returns(string memory post) {\r\n        return news[sd][id];\r\n    }\r\n\r\n    // function to create new news article\r\n    function newNews(address sd, string memory input) external {\r\n        require(isSD(sd), \"Not SD\");\r\n        require(isSupport[sd][msg.sender], \"staff\");\r\n        news[sd].push(input);\r\n        emit AddNews(sd,input);\r\n    }\r\n\r\n    // function to edit new article\r\n    function editNews(address sd, uint256 id, string memory input) external {\r\n        require(isSD(sd), \"Not SD\");\r\n        require(isSupport[sd][msg.sender], \"staff\");\r\n        require(id <= news[sd].length - 1, \"Invalid\");\r\n        news[sd][id] = input;\r\n        emit EditNews(sd,id,input);\r\n    }\r\n\r\n    function viewInfo(address sd, string[] memory choice) external view returns(string[] memory _info) {\r\n        uint256 a = choice.length;\r\n        _info = new string[](a);\r\n        for(uint256 i = 0; i < a; i++) {\r\n            _info[i] = info[sd][choice[i]];\r\n        }\r\n    }\r\n\r\n    function wETH() public view returns(address) {\r\n        return Reader(dataread).wETH();\r\n    }\r\n\r\n    /**\r\n    * Main function to create an SD and register it as an official SD.\r\n    * @param name: the name of the token\r\n    * @param symbol: The symbol of the token\r\n    * @param fee: the fees that should be applied (0.1% = 1 and 1000 = 0)\r\n    *   fee[0] = backingFeeBuy\r\n    *   fee[1] = burningFeeBuy\r\n    *   fee[2] = liquidityFeeBuy\r\n    *   fee[3] = growthFeeBuy\r\n    *   fee[4] = stakingFeeBuy\r\n    *   fee[5] = reflectionFeeBuy\r\n    *   fee[6] = backingFeeSell\r\n    *   fee[7] = burningFeeSell\r\n    *   fee[8] = liquidityFeeSell\r\n    *   fee[9] = growthFeeSell\r\n    *   fee[10] = stakingFeeSell\r\n    *   fee[11] = reflectionFeeSell\r\n    * @param sb: if true all Fees apply to only buy and sells. On false it alows also for transfer taxes.\r\n    * @param backingTokenAddress: The ERC20 address of the backing token. Need to be listed on uniswap/pancakeswap\r\n    **/\r\n    function createSD(address owner, string memory name, string memory symbol, uint256 supply, uint[12] calldata fee, bool sb, address _uniswapV2Router, address backingTokenAddress, bool _LGE) external returns (address SD) {\r\n        require(on, \"!on\");\r\n        require((supply <= 1e75) && !use[symbol], \"sym used\");\r\n        if(backingTokenAddress != address(0)) {\r\n        require(backingTokenAddress.code.length > 0, \"not\");\r\n        }\r\n        require(fee[0] + fee[1] + fee[2] + fee[3] + fee[4] + fee[5] < 501, \" 50% max\");\r\n        require(fee[6] + fee[7] + fee[8] + fee[9] + fee[10] + fee[11] < 501, \" 50% max\");\r\n        use[symbol] = true;\r\n        address fac = IUniswapV2Router01(_uniswapV2Router).factory();\r\n        address o = owner;\r\n        SD = Logic(logic).createSD(name, symbol, supply, fee, sb, o, backingTokenAddress, _LGE);\r\n        require(SDOfCreator[owner] == address(0), \"already created\");\r\n        creatorOfSD[SD] = owner;\r\n        SDOfCreator[owner] = SD;\r\n        backingTokenAddress = backingTokenAddress == address(0) ? SD : backingTokenAddress;\r\n        address uniswapV2Pair = IUniswapV2Factory(fac).createPair(SD, wETH());\r\n        address pair = backingTokenAddress != wETH() ? IUniswapV2Router01(fac).getPair(wETH(), backingTokenAddress) : uniswapV2Pair;\r\n        require(pair != address(0), \"!ETHPair\");\r\n        allSD.push(SD);\r\n        length += 1;\r\n        Reader(dataread).setIsSD(SD);\r\n        Reader(dataread).set_UNISWAP_V2_ROUTER(SD,_uniswapV2Router, uniswapV2Pair);\r\n        Logic(SD).afterConstructor();   \r\n        address oo = owner;\r\n        isSupport[SD][oo] = true;\r\n        minTicketCost[SD] = minDonation;\r\n        ticket[SD].push();\r\n        news[SD].push();\r\n        donationLocation[SD] = owner;\r\n        emit Created(name, SD);\r\n        return SD;\r\n    }\r\n\r\n    struct Protector {\r\n        uint256 range;\r\n        uint256 slippage;\r\n    }\r\n    \r\n    // view slippage of users front run protection system\r\n    function slippage(address user) external view returns(uint256,uint256) {\r\n        return (protect[user].range,protect[user].slippage);\r\n    }\r\n\r\n    // update the Logic can only be called by superAdmin multisig\r\n    function setLogic(address addy) external {\r\n        require(Reader(dataread).superAdmin(msg.sender), \"admin\");\r\n        logic = addy;\r\n    }\r\n\r\n    /**\r\n    * Setting your desired front run protection range\r\n    * @param _slippage : amount of pool slippage you will allow\r\n    * @param user : if user does not match msg.sender then require SmartDeFi calling contract.\r\n    **/\r\n    function setFrontRunProtection(address user, uint256 _range, uint256 _slippage) external {\r\n        if(user != msg.sender) {\r\n        require(isSD(msg.sender), \"caller\");\r\n        }\r\n        require(_slippage <= 30 , \"30\");\r\n        require(_range <= 100 , \"100\");\r\n        protect[user].slippage = _slippage;\r\n        protect[user].range = _range;\r\n        emit SetProtection(user, _slippage);\r\n    }\r\n\r\n    function dockInfo(string[] memory symbol, bool[] memory bool_) external {\r\n        require(Reader(dataread).isAdmin(msg.sender) || Reader(dataread).isSetter(msg.sender));\r\n        for(uint256 i = 0; i < bool_.length; i++) {\r\n        useInfo[symbol[i]] = bool_[i];\r\n        emit DockInfo(symbol[i], bool_[i]);\r\n        }\r\n    }\r\n\r\n    function setCreatorOFSD(address sd, address creator) external {\r\n        require(Reader(dataread).superAdmin(msg.sender), \"admin\");\r\n        creatorOfSD[sd] = creator;\r\n        SDOfCreator[creator] = sd;\r\n    }\r\n\r\n    /**\r\n    * This will track the balance of wETH in the FEG main pair as well as backing asset in the backing pair of SmartDeFi token.\r\n    * @param who : address of the SD token\r\n    **/\r\n    function setTick(address who) external {\r\n        address DR = dataread;\r\n        if(!Reader(DR).tickOn(who)) {\r\n        address ba = Logic(who).backingAsset();\r\n        address weth = wETH();\r\n        require(Reader(DR).isProtocol(who) && isSD(who), \"caller\");\r\n        address fac = IUniswapV2Router01(Reader(who).UNISWAP_V2_ROUTER()).factory();\r\n        address t = ba == weth ? Reader(DR).uniswapV2Pair(who) : IUniswapV2Router01(fac).getPair(wETH(), ba);\r\n        if(IERC20(ba).balanceOf(t) > 0) {\r\n        uint256 k1 = tick[t].length > 0 ? tick[t][tick[t].length - 1] : 0;\r\n        (uint112 reserve0, uint112 reserve1,) = IPair(t).getReserves();\r\n        uint256 reserve = ba == IPair(t).token0() ? reserve0 : reserve1;\r\n        if(reserve != k1) {\r\n        tick[t].push(reserve);\r\n        }\r\n        }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This function lets you know if there was a front run trade before your transaction within a given percentage rate.\r\n    * If you input range 5 then if the last trade moved the tracked balance of the previous 3 trades average by 5% then front run happened.\r\n    * On contracts if returned bool is true then revert trade to save losses.\r\n    * @param who : The name of to register\r\n    * @param range : amount of slippage desired\r\n    **/\r\n    function frontRun(address who, uint256 range, uint256 slip) external view returns(bool yes) {\r\n        if(!Reader(dataread).tickOn(who)) {\r\n        if(range > 0) {\r\n        uint256 a;\r\n        address fac = IUniswapV2Router01(Reader(who).UNISWAP_V2_ROUTER()).factory();\r\n        address ba = Logic(who).backingAsset();\r\n        address t = ba == wETH() ? Reader(dataread).uniswapV2Pair(who) : IUniswapV2Router01(fac).getPair(wETH(), ba);\r\n        (uint112 reserve0, uint112 reserve1,) = IPair(t).getReserves();\r\n        a = (ba == IPair(t).token0() ? reserve0 : reserve1) * range;    \r\n        if(tick[t].length > range + 3) {\r\n        uint256 l = tick[who].length - (isSD(ba) ? 1 : 2); \r\n        uint256 c;\r\n        for(uint256 i = 0; i < range; i++) {\r\n            c += tick[who][l - i];\r\n            if(l - i == 0) {\r\n            a = (i + 1) * a / range;\r\n            break;\r\n            }\r\n        }\r\n        if(a > (c + (c * slip / 100))) {\r\n            yes = true;\r\n        }\r\n        if(a < (c - (c * slip / 100))) {\r\n            yes = true;\r\n        }\r\n        }\r\n        }\r\n        }\r\n    }\r\n\r\n    function ticketLength(address sd) external view returns(uint256) {\r\n        return ticket[sd].length;\r\n    }\r\n\r\n    function isSD(address addy) public view returns(bool) {\r\n        return Reader(dataread).isSD(addy);\r\n    }\r\n}\r\n\r\ninterface Reader {\r\n    function isAdmin(address addy) external view returns (bool);\r\n    function superAdmin(address addy) external view returns (bool);\r\n    function isSetter(address addy) external view returns (bool);\r\n    function isSD(address addy) external view returns (bool);\r\n    function setIsSD(address addy) external;\r\n    function protocolAddy() external view returns (address);    \r\n    function feeConverter() external view returns (address);\r\n    function sdDepAddy() external view returns (address);\r\n    function getProtocolFee() external view returns (uint256);\r\n    function breaker() external view returns (bool); //circuit breaked in case of an exploit to handle\r\n    function isWhitelistContract(address addy) external view returns (bool);\r\n    function setWhitelistContract(address addy, bool _bool) external;\r\n    function stakeDeployerAddress() external view returns(address);\r\n    function LEAPDepAddy() external view returns(address);\r\n    function fegAddress() external view returns(address);\r\n    function UNISWAP_V2_ROUTER(address token) external view returns(address);\r\n    function UNISWAP_V2_ROUTER() external view returns(address);\r\n    function uniswapV2Pair(address token) external view returns(address);\r\n    function set_UNISWAP_V2_ROUTER(address token, address _uniswapV2Router, address _uniswapV2Pair) external;\r\n    function backingLogicDep() external view returns(address);\r\n    function BackingLogicAddress() external view returns(address);\r\n    function setTick(address who) external;\r\n    function frontRun(address who, uint256 range, uint256 slip, uint256 trades) external view returns(bool yes);\r\n    function lastBalance(address user) external view returns(uint256);\r\n    function wETH() external view returns(address);\r\n    function LGEAddress() external view returns(address);\r\n    function currentRouter() external view returns(address);\r\n    function feeConverterSD(address sd) external view returns(address);\r\n    function tickOn(address token) external view returns(bool);\r\n    function isProtocol(address addy) external view returns(bool);\r\n    function allLastBalance(address user) external view returns(uint256[] memory _balances, uint256[] memory blockNumbers);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"AddNews\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ConfirmKYC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"Dock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"DockInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"EditNews\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"choice\",\"type\":\"uint256\"}],\"name\":\"GiveKarma\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ReplyTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"SetProtection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"SubmitKYC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"SubmitTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"choice\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"UpdateInformation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"KYCopen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"SDOfCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"confirmKYC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256[12]\",\"name\":\"fee\",\"type\":\"uint256[12]\"},{\"internalType\":\"bool\",\"name\":\"sb\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_uniswapV2Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"backingTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_LGE\",\"type\":\"bool\"}],\"name\":\"createSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"SD\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"creatorOfSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataread\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"sym\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"_bool\",\"type\":\"bool[]\"}],\"name\":\"dock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"symbol\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"bool_\",\"type\":\"bool[]\"}],\"name\":\"dockInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donationLocation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"editNews\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"range\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slip\",\"type\":\"uint256\"}],\"name\":\"frontRun\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"yes\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"choice\",\"type\":\"uint256\"}],\"name\":\"giveKarma\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"heldDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"isSD\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSupport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"karma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"karmaDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastKarma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minTicketCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myReplied\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"mySupportIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"newNews\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"on\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"openTickets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"range\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"recoverDonation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_answer\",\"type\":\"string\"}],\"name\":\"replyTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"setCreatorOFSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"location\",\"type\":\"address\"}],\"name\":\"setDonationLocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_range\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"setFrontRunProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setKarmaDonation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setMinDonation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_supporter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setTick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"slippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"document\",\"type\":\"string\"}],\"name\":\"submitKYC\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_question\",\"type\":\"string\"}],\"name\":\"submitTicket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"supportReplyIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tick\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"}],\"name\":\"ticketLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsClosed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsOpened\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"choice\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"input\",\"type\":\"string[]\"}],\"name\":\"updateInformation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"use\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"useInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedInfoStrings\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"usedInfoStringsBool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"}],\"name\":\"viewAllNews\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"posts\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"choice\",\"type\":\"string[]\"}],\"name\":\"viewInfo\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"_info\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewKYC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"document\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"viewNews\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"post\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"}],\"name\":\"viewTicket\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"question\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"answer\",\"type\":\"string[]\"},{\"internalType\":\"address\",\"name\":\"lastAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"donation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SDDeployer", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cdd88381bbc28349b36a675bfc0e9a95de09d796a3dfcb6bbd1ab6ac1236405a"}