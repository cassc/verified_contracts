{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\n/*\r\n    DoubleEspresso - a bot to build your website and deploy your token in a few minutes!\r\n    (token factory at the bottom of the contract)\r\n\r\n    Why just one espresso if you can take two?\r\n    \r\n    tg: https://t.me/DespressoToken\r\n    twitter: @DEspressotoken\r\n    website: https://despresso.eth.limo/\r\n\r\n*/\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IpinkSale {\r\n    function lock(\r\n        address owner,\r\n        address token,\r\n        bool isLpToken,\r\n        uint256 amount,\r\n        uint256 unlockDate,\r\n        string memory description\r\n    ) external returns (uint256 id);\r\n\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Invalid owner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract tokenTemplate is Ownable {\r\n    IDEXRouter public constant router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IpinkSale constant locker = IpinkSale(0x71B5759d73262FBb223956913ecF4ecC51057641);\r\n    address public pair;\r\n\r\n    // ERC20 defaults\r\n    string _name;\r\n    string _ticker;\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 1 * (10**9) * (10**_decimals); // default 1 billion\r\n\r\n    // ERC20 mappings\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n\r\n    uint256 constant divisor = 1_000;\r\n\r\n    // Limits\r\n    bool public limitsEnabled = true;\r\n    mapping(address => bool) _isTxLimitExempt;\r\n    uint256 public maxTxAmount = (_totalSupply * 10) / divisor; //1 %\r\n    uint256 public maxWalletAmount = (_totalSupply * 10) / divisor; // 1%\r\n\r\n    // Fees\r\n    bool public feesEnabled;\r\n    mapping(address => bool) _isFeeExempt;\r\n    uint256 private sniperTaxTillBlock;\r\n    uint256 private tokensForMarketing;\r\n    uint256 private tokensForLp;\r\n    uint256 private tokensForDev;\r\n    address public lpWallet;\r\n    address public marketingWallet;\r\n    address public devWallet;\r\n    uint256 marketingBuyFee = 20;\r\n    uint256 liquidityBuyFee = 20;\r\n    uint256 developmentBuyFee = 20;\r\n    uint256 public totalBuyFee = marketingBuyFee + liquidityBuyFee + developmentBuyFee;\r\n    uint256 marketingSellFee = 30;\r\n    uint256 liquiditySellFee = 30;\r\n    uint256 developmentSellFee = 20;\r\n    uint256 public totalSellFee = marketingSellFee + liquiditySellFee + developmentSellFee;\r\n\r\n    // Lp locker\r\n    uint256 public lpLockId;\r\n\r\n    // Swapback\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = (_totalSupply * 10) / 100_000; // 0.01%\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiquidity\r\n    );\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    // Trade block\r\n    bool tradingAllowed;\r\n    uint256 sniperTaxTill;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    constructor(\r\n        string memory __name,\r\n        string memory __ticker,\r\n        address __owner,\r\n        bool __hasFees,\r\n        uint256 __marketingTax,\r\n        address __marketing,\r\n        uint256 __devTax,\r\n        address __dev,\r\n        uint256 __lpTax,\r\n        address __lp\r\n    ) {\r\n        _name = __name;\r\n        _ticker = __ticker;\r\n        transferOwnership(__owner);      \r\n\r\n        // Arrange fee and tx exempts\r\n        _isFeeExempt[address(this)] = true;\r\n        _isTxLimitExempt[address(this)] = true;\r\n        _isFeeExempt[__owner] = true;\r\n        _isTxLimitExempt[__owner] = true;\r\n        _isTxLimitExempt[address(router)] = true;\r\n\r\n        // Take care of the approvals for the owner and the token itself\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        \r\n        // If fees are disabled entirely we can totally skip them in the transfer\r\n        // to save tx costs.\r\n        feesEnabled = __hasFees;\r\n        swapEnabled = __hasFees; // only need to enable swap in case of fees\r\n\r\n        // Set fee wallets\r\n        lpWallet = __lp;\r\n        marketingWallet = __marketing;\r\n        devWallet = __dev;\r\n\r\n        // Set taxes\r\n        // - Buy taxes\r\n        require(__marketingTax + __lpTax + __devTax <= 150); // note divisor = 1000\r\n        marketingBuyFee = __marketingTax;\r\n        liquidityBuyFee = __lpTax;\r\n        developmentBuyFee = __devTax;\r\n        totalBuyFee  = marketingBuyFee + liquidityBuyFee + developmentBuyFee;\r\n\r\n        // - Sell taxes\r\n        marketingSellFee = __marketingTax;\r\n        liquiditySellFee = __lpTax;\r\n        developmentSellFee = __devTax;\r\n        totalSellFee  = marketingSellFee + liquiditySellFee + developmentSellFee;\r\n\r\n        // Mint the tokens to the contract\r\n        _balances[address(this)] = _totalSupply;\r\n        emit Transfer(address(0), address(this), _totalSupply);\r\n    }\r\n\r\n\r\n    // Basic ERC20 functions\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _ticker;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address holder, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // Basic transfer is a transfer without tax - for wallets excluded from fees/limits\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"Insufficient Balance\");\r\n        _balances[sender] = _balances[sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // To configure the buy fees with a limit of 15%\r\n    function setBuyFees(\r\n        uint256 _marketingFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _developFee\r\n    ) external onlyOwner {\r\n        require(_marketingFee + _liquidityFee + _developFee <= 150); // note divisor = 1000\r\n        marketingBuyFee = _marketingFee;\r\n        liquidityBuyFee = _liquidityFee;\r\n        developmentBuyFee = _developFee;\r\n        totalBuyFee = _marketingFee + _liquidityFee + _developFee;\r\n    }\r\n\r\n    // To configure the sell fees with a limit of 15%\r\n    function setSellFees(\r\n        uint256 _marketingFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _developFee\r\n    ) external onlyOwner {\r\n        require(_marketingFee + _liquidityFee + _developFee <= 150); // max 15%\r\n        marketingSellFee = _marketingFee;\r\n        liquiditySellFee = _liquidityFee;\r\n        developmentSellFee = _developFee;\r\n        totalSellFee = _marketingFee + _liquidityFee + _developFee;\r\n    }\r\n\r\n    // Update tax wallet if necessary\r\n    function updateWallets(\r\n        address _marketingWallet,\r\n        address _lpWallet,\r\n        address _devWallet\r\n    ) external onlyOwner {\r\n        marketingWallet = _marketingWallet;\r\n        lpWallet = _lpWallet;\r\n        devWallet = _devWallet;\r\n    }\r\n\r\n    // We can change the max wallet but only to be at least 1% of the supply\r\n    function setMaxWallet(uint256 percent) external onlyOwner {\r\n        require(percent >= 10); // Note divisor = 1000\r\n        maxWalletAmount = (_totalSupply * percent) / divisor;\r\n    }\r\n\r\n    // We can change the max tx limit but it should be at least 1% of the supply\r\n    function setTxLimit(uint256 percent) external onlyOwner {\r\n        require(percent >= 10); // Note divisor = 1000\r\n        maxTxAmount = (_totalSupply * percent) / divisor;\r\n    }\r\n\r\n    // Check restrictions, mainly to just after launch limit wallets taking up large portions of\r\n    // the supply\r\n    function checkLimits(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal view {\r\n        // return if sender and recipient are excluded\r\n        if (_isTxLimitExempt[sender] && _isTxLimitExempt[recipient]) {\r\n            return;\r\n        }\r\n\r\n        // Buy\r\n        if (sender == pair && !_isTxLimitExempt[recipient]) {\r\n            require(amount <= maxTxAmount, \"Max tx limit\");\r\n\r\n        // Sell\r\n        } else if (recipient == pair && !_isTxLimitExempt[sender]) {\r\n            require(amount <= maxTxAmount, \"Max tx limit\");\r\n        }\r\n\r\n        // Max wallet\r\n        if (!_isTxLimitExempt[recipient]) {\r\n            require(\r\n                amount + balanceOf(recipient) <= maxWalletAmount,\r\n                \"Max wallet\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // Permanently lift the limits, this can't be reversed\r\n    // limits can also just be loosened instead\r\n    function permanent_lift_limits() external onlyOwner {\r\n        limitsEnabled = false;\r\n    }\r\n\r\n    // Let the trading begin! \r\n    // This will automatically lock the lp for at least 1 month with \r\n    // the msg.sender (=owner) becoming the owner of the lp tokens that\r\n    // can be withdraw after at least a month or locks can just be extended\r\n    // in the pinksale GUI\r\n    function startTrading(uint256 lock_lp_months) external payable onlyOwner {\r\n        require(!tradingAllowed, \"Trading already enabled\");\r\n        require(lock_lp_months >= 1, \"Lock < 1 month\");\r\n        require(msg.value > 0, \"No ETH supplied\");\r\n\r\n        // Create the pair contract \r\n        pair = IDEXFactory(router.factory()).createPair(\r\n            router.WETH(),\r\n            address(this)\r\n        );\r\n\r\n        // Exclude the pair from tx limit and approve owner\r\n        _isTxLimitExempt[address(pair)] = true;\r\n        _allowances[owner()][address(pair)] = _totalSupply;\r\n\r\n        // Add the lp and send the lp tokens back to the token contract\r\n        inSwap = true;\r\n        addLiquidity(balanceOf(address(this)), msg.value, address(this));\r\n        tradingAllowed = true;\r\n        inSwap = false;\r\n\r\n        // Transfer LP tokens to pinksale locker\r\n        uint256 lp_tokens = IERC20(pair).balanceOf(address(this));\r\n        IERC20(pair).approve(address(locker), lp_tokens);\r\n        uint256 unlock_date = block.timestamp + lock_lp_months * 30 days;\r\n\r\n        // Lock and assign ownership of the lock to the sender i.e. dev\r\n        lpLockId = locker.lock(\r\n            msg.sender,\r\n            pair,\r\n            true,\r\n            lp_tokens,\r\n            unlock_date,\r\n            \"lp lock\"\r\n        );\r\n\r\n        // Set sniper block\r\n        sniperTaxTill = block.number + 2;\r\n    }\r\n\r\n    // To change whether tokens in the contract should be swapped for for ETH\r\n    // and at what threshold\r\n    function setTokenSwapSettings(bool _enabled, uint256 _threshold)\r\n        external\r\n        onlyOwner\r\n    {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _threshold * (10**_decimals);\r\n    }\r\n\r\n    // Check if tokens in the contract should be swapped, only on sells\r\n    function shouldTokenSwap(address recipient) internal view returns (bool) {\r\n        return\r\n            recipient == pair &&\r\n            !inSwap &&\r\n            swapEnabled &&\r\n            _balances[address(this)] >= swapThreshold;\r\n    }\r\n\r\n    function takeFee(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        // Exempt from fees so return\r\n        if (_isFeeExempt[from] || _isFeeExempt[to]) {\r\n            return amount;\r\n        }\r\n\r\n        uint256 fees;\r\n\r\n        // Sniper tax, only first two blocks after lp\r\n        if (block.number <= sniperTaxTill) {\r\n            fees = (amount * 98) / 100; // 98% tax\r\n            tokensForLp += (fees * 50) / 98;\r\n            tokensForMarketing += (fees * 48) / 98;\r\n        }\r\n        // On sell\r\n        else if (to == pair && totalSellFee > 0) {\r\n            fees = (amount * totalSellFee) / divisor;\r\n            tokensForLp += (fees * liquiditySellFee) / totalSellFee;\r\n            tokensForDev += (fees * developmentSellFee) / totalSellFee;\r\n            tokensForMarketing += (fees * marketingSellFee) / totalSellFee;\r\n        }\r\n        // On buy\r\n        else if (from == pair && totalBuyFee > 0) {\r\n            fees = (amount * totalBuyFee) / divisor;\r\n            tokensForLp += (fees * liquidityBuyFee) / totalBuyFee;\r\n            tokensForDev += (fees * developmentBuyFee) / totalBuyFee;\r\n            tokensForMarketing += (fees * marketingBuyFee) / totalBuyFee;\r\n        }\r\n\r\n        // Send collected fees\r\n        if (fees > 0) {\r\n            _basicTransfer(from, address(this), fees);\r\n            emit Transfer(from, address(this), fees);\r\n        }\r\n\r\n        // Taxed amount\r\n        return amount -= fees;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = tokensForLp +\r\n            tokensForMarketing +\r\n            tokensForDev;\r\n\r\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\r\n            return;\r\n        }\r\n\r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = (contractBalance * tokensForLp) / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance - liquidityTokens;\r\n\r\n        uint256 initialETHBalance = address(this).balance;\r\n\r\n        // Swap the tokens for ETH\r\n        swapTokensForEth(amountToSwapForETH);\r\n\r\n        uint256 ethBalance = address(this).balance - initialETHBalance;\r\n        uint256 ethForMarketing = (ethBalance * tokensForMarketing) / totalTokensToSwap;\r\n        uint256 ethForDev = (ethBalance * tokensForDev) / totalTokensToSwap;\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\r\n\r\n        // Reset token fee counts\r\n        tokensForLp = 0;\r\n        tokensForMarketing = 0;\r\n        tokensForDev = 0;\r\n\r\n        // Send Dev fees\r\n        payable(devWallet).transfer(ethForDev);\r\n\r\n        // Add liquidty\r\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\r\n            addLiquidity(liquidityTokens, ethForLiquidity, lpWallet);\r\n            emit SwapAndLiquify(\r\n                amountToSwapForETH,\r\n                ethForLiquidity,\r\n                tokensForLp\r\n            );\r\n        }\r\n\r\n        // Hand out the marketing ETH\r\n        payable(marketingWallet).transfer(address(this).balance);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        if (owner() == msg.sender) {\r\n            return _basicTransfer(msg.sender, recipient, amount);\r\n        } else {\r\n            return _transferFrom(msg.sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        if (_allowances[sender][msg.sender] != _totalSupply) {\r\n            // Get the current allowance\r\n            uint256 curAllowance = _allowances[sender][msg.sender];\r\n            require(curAllowance >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        // Excluded from limits and fees\r\n        if (sender == owner() || recipient == owner() || inSwap) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        // In any other case, check if trading is open already and whether limits/fees should be applied\r\n        require(tradingAllowed, \"Trading not open yet\");\r\n        if (limitsEnabled) {\r\n            checkLimits(sender, recipient, amount);\r\n        }\r\n        if (shouldTokenSwap(recipient)) {\r\n            swapBack();\r\n        }\r\n        if (feesEnabled) {\r\n            amount = (recipient == pair || sender == pair)\r\n                ? takeFee(sender, recipient, amount)\r\n                : amount;\r\n        }\r\n        _basicTransfer(sender, recipient, amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 tokenAmount,\r\n        uint256 ethAmount,\r\n        address sendTo\r\n    ) private {\r\n        router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            sendTo,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function clearStuckWETH(uint256 perc) external {\r\n        require(msg.sender == marketingWallet);\r\n        uint256 amountWETH = address(this).balance;\r\n        payable(marketingWallet).transfer((amountWETH * perc) / 100);\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\ncontract DoubleEspresso is tokenTemplate {\r\n    mapping(address => address) public token_owners; // token -> owner\r\n    mapping(address => address[]) public tokens_owned; // owner -> token(s)\r\n    bool factory_enabled;\r\n    uint256 public tokens_created;\r\n    uint256 burnCreationFee = 1_000;\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    event TokenCreated(address creator, address token);\r\n\r\n    constructor()\r\n        tokenTemplate(\r\n            \"DoubleEspresso\",\r\n            \"DESP\",\r\n            msg.sender, //owner\r\n            true,\r\n            20,\r\n            0x76B2c08407133B36F3Fd38fD362DfBd5ed836384, // marketing\r\n            20,\r\n            0x37F60ceA0892B7f1a39811Df4415034f723a54d7, // dev\r\n            10,\r\n            0xcEB53721d782367d9CD11F3aA443418d615C7a26  // lp\r\n        )\r\n    {\r\n        factory_enabled = true;\r\n    }\r\n\r\n    function update_burn_creation_fee(uint256 fee) external onlyOwner {\r\n        burnCreationFee = fee;\r\n    }\r\n\r\n    // Could also just use regular approve\r\n    function easy_approve_creation_fee() external {\r\n        _allowances[msg.sender][address(this)] = burnCreationFee;\r\n        emit Approval(msg.sender, address(this), burnCreationFee);\r\n    }\r\n\r\n    function createToken(\r\n        string memory _name,\r\n        string memory _ticker,\r\n        address owner,\r\n        bool enableFees,\r\n        uint256 marketingTax,\r\n        address marketing,\r\n        uint256 devTax,\r\n        address dev,\r\n        uint256 lpTax,\r\n        address lp\r\n    ) external {\r\n        require(factory_enabled, \"Factory is disabled\");\r\n\r\n        // Check if the sender has enough tokens to burn \r\n        require(_balances[msg.sender] >= burnCreationFee, \"Not enough tokens\");\r\n\r\n        // Burn tokens to create a token using safeTransfer\r\n        TransferHelper.safeTransferFrom(\r\n            address(this), \r\n            msg.sender, // Get the tokens from the msg sender\r\n            DEAD,\r\n            burnCreationFee\r\n        );\r\n\r\n        tokenTemplate token_clone = new tokenTemplate(\r\n            _name,\r\n            _ticker,\r\n            owner, // Use the \"owner\" as token owner (usually just the same as msg.sender)\r\n            enableFees,\r\n            marketingTax,\r\n            marketing,\r\n            devTax,\r\n            dev,\r\n            lpTax,\r\n            lp\r\n        );\r\n\r\n        address token_address = address(token_clone);\r\n\r\n        // Store the creator to verify adjustments later on\r\n        token_owners[token_address] = owner;\r\n        tokens_owned[owner].push(token_address);\r\n\r\n        tokens_created++;\r\n        emit TokenCreated(owner, token_address);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"}],\"name\":\"clearStuckWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enableFees\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"devTax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dev\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpTax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"createToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"easy_approve_creation_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanent_lift_limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_developFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_developFee\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setTokenSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lock_lp_months\",\"type\":\"uint256\"}],\"name\":\"startTrading\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token_owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens_created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens_owned\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"}],\"name\":\"updateWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"update_burn_creation_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DoubleEspresso", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e8c79a7e8eaa59a81adaeb97a2e54f529eb3aaa1a200975dd6b85abf898b07bd"}