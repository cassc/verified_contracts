{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"OptimismMessengers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../../interfaces/IMessenger.sol\\\";\\n\\nimport \\\"../../RestrictedCalls.sol\\\";\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/vendor/optimism/ICrossDomainMessenger.sol\\\";\\nimport \\\"optimism/Lib_PredeployAddresses.sol\\\";\\n\\nabstract contract OptimismMessengerBase is IMessenger, RestrictedCalls {\\n    uint32 private constant MESSAGE_GAS_LIMIT = 1_000_000;\\n\\n    ICrossDomainMessenger public nativeMessenger;\\n\\n    function callAllowed(\\n        address caller,\\n        address courier\\n    ) external view returns (bool) {\\n        return\\n            courier == address(nativeMessenger) &&\\n            caller == nativeMessenger.xDomainMessageSender();\\n    }\\n\\n    function sendMessage(\\n        address target,\\n        bytes calldata message\\n    ) external restricted(block.chainid) {\\n        nativeMessenger.sendMessage(target, message, MESSAGE_GAS_LIMIT);\\n    }\\n}\\n\\ncontract OptimismL1Messenger is OptimismMessengerBase {\\n    constructor(address messenger_) {\\n        nativeMessenger = ICrossDomainMessenger(messenger_);\\n    }\\n}\\n\\ncontract OptimismL2Messenger is OptimismMessengerBase {\\n    constructor() {\\n        nativeMessenger = ICrossDomainMessenger(\\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/vendor/optimism/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (vendor/optimism/ICrossDomainMessenger.sol)\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \".cache/Optimism/local/Lib_PredeployAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n        0x4200000000000000000000000000000000000007;\\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\\n        0x4200000000000000000000000000000000000012;\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n}\\n\"\r\n    },\r\n    \".cache/Interfaces/local/IMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n/// The messenger interface.\\n///\\n/// Implementations of this interface are expected to transport\\n/// messages across the L1 <-> L2 boundary. For instance,\\n/// if an implementation is deployed on L1, the :sol:func:`sendMessage`\\n/// would send a message to a L2 chain, as determined by the implementation.\\n/// In order to do this, a messenger implementation may use a native\\n/// messenger contract. In such cases, :sol:func:`nativeMessenger` must\\n/// return the address of the native messenger contract.\\ninterface IMessenger {\\n    /// Send a message across the L1 <-> L2 boundary.\\n    ///\\n    /// @param target The message recipient.\\n    /// @param message The message.\\n    function sendMessage(address target, bytes calldata message) external;\\n\\n    /// Return whether the call is allowed or not.\\n    ///\\n    /// @param caller The caller.\\n    /// @param courier The contract that is trying to deliver the message.\\n    function callAllowed(address caller, address courier)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"RestrictedCalls.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IMessenger.sol\\\";\\n\\n/// A helper contract that provides a way to restrict callers of restricted functions\\n/// to a single address. This allows for a trusted call chain,\\n/// as described in :ref:`contracts' architecture <contracts-architecture>`.\\ncontract RestrictedCalls is Ownable {\\n    /// Maps caller chain IDs to tuples [caller, messenger].\\n    ///\\n    /// For same-chain calls, the messenger address is 0x0.\\n    mapping(uint256 callerChainId => address[2]) public callers;\\n\\n    function _addCaller(\\n        uint256 callerChainId,\\n        address caller,\\n        address messenger\\n    ) internal {\\n        require(caller != address(0), \\\"RestrictedCalls: caller cannot be 0\\\");\\n        require(\\n            callers[callerChainId][0] == address(0),\\n            \\\"RestrictedCalls: caller already exists\\\"\\n        );\\n        callers[callerChainId] = [caller, messenger];\\n    }\\n\\n    /// Allow calls from an address on the same chain.\\n    ///\\n    /// @param caller The caller.\\n    function addCaller(address caller) external onlyOwner {\\n        _addCaller(block.chainid, caller, address(0));\\n    }\\n\\n    /// Allow calls from an address on another chain.\\n    ///\\n    /// @param callerChainId The caller's chain ID.\\n    /// @param caller The caller.\\n    /// @param messenger The messenger.\\n    function addCaller(\\n        uint256 callerChainId,\\n        address caller,\\n        address messenger\\n    ) external onlyOwner {\\n        _addCaller(callerChainId, caller, messenger);\\n    }\\n\\n    /// Mark the function as restricted.\\n    ///\\n    /// Calls to the restricted function can only come from an address that\\n    /// was previously added by a call to :sol:func:`addCaller`.\\n    ///\\n    /// Example usage::\\n    ///\\n    ///     restricted(block.chainid)   // expecting calls from the same chain\\n    ///     restricted(otherChainId)    // expecting calls from another chain\\n    ///\\n    modifier restricted(uint256 callerChainId) {\\n        address caller = callers[callerChainId][0];\\n\\n        if (callerChainId == block.chainid) {\\n            require(msg.sender == caller, \\\"RestrictedCalls: call disallowed\\\");\\n        } else {\\n            address messenger = callers[callerChainId][1];\\n            require(\\n                messenger != address(0),\\n                \\\"RestrictedCalls: messenger not set\\\"\\n            );\\n            require(\\n                IMessenger(messenger).callAllowed(caller, msg.sender),\\n                \\\"RestrictedCalls: call disallowed\\\"\\n            );\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [\r\n      \"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts=.cache/OpenZeppelin/v4.8.0\",\r\n      \"interfaces=.cache/Interfaces/local\",\r\n      \"optimism=.cache/Optimism/local\"\r\n    ],\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"messenger_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callerChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"messenger\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"courier\",\"type\":\"address\"}],\"name\":\"callAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callerChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"callers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeMessenger\",\"outputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OptimismL1Messenger", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000866e82a600a1414e583f7f13623f1ac5d58b0afa", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}