{"SourceCode": "// File: wns-multichain/implementations/wns_addresses_impl.sol\r\n\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface WnsAddressesInterface {\r\n    function owner() external view returns (address);\r\n    function getWnsAddress(string memory _label) external view returns(address);\r\n}\r\n\r\nabstract contract WnsImpl {\r\n    WnsAddressesInterface wnsAddresses;\r\n\r\n    constructor(address addresses_) {\r\n        wnsAddresses = WnsAddressesInterface(addresses_);\r\n    }\r\n\r\n    function setAddresses(address addresses_) public {\r\n        require(msg.sender == owner(), \"Not authorized.\");\r\n        wnsAddresses = WnsAddressesInterface(addresses_);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return wnsAddresses.owner();\r\n    }\r\n\r\n    function getWnsAddress(string memory _label) public view returns (address) {\r\n        return wnsAddresses.getWnsAddress(_label);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeam() {\r\n        require(msg.sender == getWnsAddress(\"team\"), \"Ownable: caller is not team\");\r\n        _;\r\n    }\r\n}\r\n// File: wns-multichain/wns_registrar.sol\r\n\r\n\r\n\r\npragma solidity 0.8.24;\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\ninterface WnsRegistryInterface {\r\n    function owner() external view returns (address);\r\n    function getWnsAddress(string memory _label) external view returns (address);\r\n    function setRecord(bytes32 _hash, uint256 _tokenId, string memory _name, uint8 _tier) external;\r\n    function setRecord(uint256 _tokenId, string memory _name) external;\r\n    function getRecord(bytes32 _hash) external view returns (uint256);\r\n    function upgradeTier(uint256 _tokenId, uint8 _tier) external;\r\n}\r\n\r\ninterface WnsErc721Interface {\r\n    function mintErc721(address to) external;\r\n    function getNextTokenId() external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ncontract Computation {\r\n    function computeNamehash(string memory _name) public pure returns (bytes32 namehash) {\r\n        namehash = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked('eth')))\r\n        );\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(_name)))\r\n        );\r\n    }\r\n}\r\n\r\nabstract contract Signatures {\r\n\r\n    struct Register {\r\n        string name;\r\n        string extension;\r\n        uint8 tier;\r\n        address registrant;\r\n        uint256 chainId; \r\n        uint256 cost;\r\n        uint256 expiration;\r\n        address[] splitAddresses;\r\n        uint256[] splitAmounts;\r\n    }\r\n\r\n    struct TierUpgrade {\r\n        uint256 tokenId;\r\n        uint8 tier;\r\n        uint256 cost;\r\n        uint256 expiration;\r\n    }\r\n     \r\n   function verifySignature(Register memory _register, bytes memory sig) internal pure returns(address) {\r\n        bytes32 message = keccak256(abi.encode(_register.name, _register.extension, _register.tier, _register.registrant, _register.chainId, _register.cost, _register.expiration, _register.splitAddresses, _register.splitAmounts));\r\n        return recoverSigner(message, sig);\r\n   }\r\n\r\n   function verifyTierUpgradeSignature(TierUpgrade memory _tierUpgrade, bytes memory sig) internal pure returns(address) {\r\n        bytes32 message = keccak256(abi.encode(_tierUpgrade.tokenId, _tierUpgrade.tier, _tierUpgrade.cost, _tierUpgrade.expiration));\r\n        return recoverSigner(message, sig);\r\n   }\r\n\r\n   function recoverSigner(bytes32 message, bytes memory sig)\r\n       public\r\n       pure\r\n       returns (address)\r\n     {\r\n       uint8 v;\r\n       bytes32 r;\r\n       bytes32 s;\r\n       (v, r, s) = splitSignature(sig);\r\n       return ecrecover(message, v, r, s);\r\n   }\r\n\r\n   function splitSignature(bytes memory sig)\r\n       internal\r\n       pure\r\n       returns (uint8, bytes32, bytes32)\r\n     {\r\n       require(sig.length == 65);\r\n\r\n       bytes32 r;\r\n       bytes32 s;\r\n       uint8 v;\r\n\r\n       assembly {\r\n           r := mload(add(sig, 32))\r\n           s := mload(add(sig, 64))\r\n           v := byte(0, mload(add(sig, 96)))\r\n       }\r\n \r\n       return (v, r, s);\r\n   }\r\n}\r\n\r\n\r\ncontract WnsRegistrar is Computation, Signatures, ReentrancyGuard, WnsImpl {\r\n\r\n    constructor(address addresses_) WnsImpl(addresses_) {}\r\n\r\n    bool public isActive = true;\r\n    uint256 private minLength = 3;\r\n    uint256 private maxLength = 15;\r\n    uint256 public chainId = 1;\r\n\r\n    function wnsRegister(Register[] memory register, bytes[] memory sig) public payable nonReentrant {\r\n        bool[] memory success = _registerAll(register, sig);\r\n        settlePayment(register, success);\r\n    }\r\n\r\n    function wnsRegisterWithShare(Register[] memory register, bytes[] memory sig) public payable nonReentrant {\r\n        bool[] memory success = _registerAll(register, sig);\r\n        settlePaymentWithShare(register, success);\r\n    }\r\n\r\n    function _registerAll(Register[] memory register, bytes[] memory sig) internal returns (bool[] memory) {\r\n        require(isActive, \"Registration must be active.\");\r\n        require(register.length == sig.length, \"Invalid parameters.\");\r\n        require(calculateCost(register) <= msg.value, \"Ether value is not correct.\");\r\n        \r\n        bool[] memory success = new bool[](register.length);\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            success[i] = _register(register[i], sig[i]);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function _register(Register memory register, bytes memory sig) internal returns (bool) {\r\n        WnsErc721Interface wnsErc721 = WnsErc721Interface(getWnsAddress(\"_wnsErc721\"));\r\n        require(verifySignature(register,sig) == getWnsAddress(\"_wnsSigner\"), \"Not authorized.\");\r\n        require(register.expiration >= block.timestamp, \"Expired credentials.\");\r\n        require(register.chainId == chainId, \"Invalid chainId\");\r\n        \r\n        string memory sanitizedName = sanitizeName(register.name);\r\n        require(isLengthValid(sanitizedName), \"Invalid name\");\r\n        \r\n        bytes32 _hash = computeNamehash(sanitizedName);\r\n\r\n        WnsRegistryInterface wnsRegistry = WnsRegistryInterface(getWnsAddress(\"_wnsRegistry\"));\r\n        if(wnsRegistry.getRecord(_hash) == 0) {\r\n            wnsErc721.mintErc721(register.registrant);\r\n            wnsRegistry.setRecord(_hash, wnsErc721.getNextTokenId(), string(abi.encodePacked(sanitizedName, register.extension)), register.tier);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function calculateCost(Register[] memory register) internal pure returns (uint256) {\r\n        uint256 cost;\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            cost = cost + register[i].cost;\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    function settlePayment(Register[] memory register, bool[] memory success) internal {\r\n        require(register.length == success.length, \"Length doesn't match\");\r\n\r\n        uint256 failedCost = 0;\r\n        for(uint256 i = 0; i < register.length; i++) {\r\n            if(!success[i]) {\r\n                failedCost += register[i].cost;\r\n            }\r\n        }\r\n\r\n        if (failedCost > 0) {\r\n            payable(msg.sender).transfer(failedCost);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function settlePaymentWithShare(Register[] memory registers, bool[] memory success) internal {\r\n        require(registers.length == success.length, \"Mismatched array lengths\");\r\n\r\n        address[] memory shareAddresses = new address[](registers.length);\r\n        uint256[] memory shareAmounts = new uint256[](registers.length);\r\n        uint256 addressCount = 0;\r\n        uint256 failedCost = 0;\r\n\r\n        for (uint256 i = 0; i < registers.length; i++) {\r\n            if (success[i]) {\r\n                for (uint256 j = 0; j < registers[i].splitAddresses.length; j++) {\r\n                    address payee = registers[i].splitAddresses[j];\r\n                    uint256 amount = registers[i].splitAmounts[j];\r\n\r\n                    bool addressFound = false;\r\n                    for (uint256 k = 0; k < addressCount; k++) {\r\n                        if (shareAddresses[k] == payee) {\r\n                            shareAmounts[k] += amount;\r\n                            addressFound = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!addressFound) {\r\n                        shareAddresses[addressCount] = payee;\r\n                        shareAmounts[addressCount] = amount;\r\n                        addressCount++;\r\n                    }\r\n                }\r\n            } else {\r\n                failedCost += registers[i].cost;\r\n            }\r\n        }\r\n\r\n        for (uint256 i = 0; i < addressCount; i++) {\r\n            payable(shareAddresses[i]).transfer(shareAmounts[i]);\r\n        }\r\n\r\n        if (failedCost > 0) {\r\n            payable(msg.sender).transfer(failedCost);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function upgradeTier(TierUpgrade[] memory tierUpgrade, bytes[] memory sig) public payable nonReentrant {\r\n        require(isActive, \"Upgradation must be active.\");\r\n        require(tierUpgrade.length == sig.length, \"Invalid parameters\");\r\n        require(calculateCostTierUpgrade(tierUpgrade) <= msg.value, \"Ether value is not correct.\");\r\n\r\n        for(uint256 i=0; i < tierUpgrade.length; i++) {\r\n            TierUpgrade memory currentTierUpgrade = tierUpgrade[i];\r\n            bytes memory currentSig = sig[i];\r\n\r\n            require(verifyTierUpgradeSignature(currentTierUpgrade, currentSig) == getWnsAddress(\"_wnsSigner\"), \"Not authorised\");\r\n            require(currentTierUpgrade.expiration >= block.timestamp, \"Expired credentials.\");\r\n\r\n            WnsErc721Interface wnsErc721 = WnsErc721Interface(getWnsAddress(\"_wnsErc721\"));\r\n            require(currentTierUpgrade.tokenId < wnsErc721.getNextTokenId(), \"Token does not exist\");\r\n            require(wnsErc721.ownerOf(currentTierUpgrade.tokenId) == msg.sender, \"Token not owned by caller\");\r\n\r\n            WnsRegistryInterface wnsRegistry = WnsRegistryInterface(getWnsAddress(\"_wnsRegistry\"));\r\n            wnsRegistry.upgradeTier(currentTierUpgrade.tokenId, currentTierUpgrade.tier);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function calculateCostTierUpgrade(TierUpgrade[] memory tierUpgrade) internal pure returns (uint256) {\r\n        uint256 cost;\r\n        for(uint256 i=0; i<tierUpgrade.length; i++) {\r\n            cost = cost + tierUpgrade[i].cost;\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    function sanitizeName(string memory name) public pure returns (string memory) {\r\n        bytes memory nameBytes = bytes(name);\r\n\r\n        uint dotPosition = nameBytes.length;\r\n        for (uint i = 0; i < nameBytes.length; i++) {\r\n            // Convert uppercase to lowercase\r\n            if (uint8(nameBytes[i]) >= 65 && uint8(nameBytes[i]) <= 90) {\r\n                nameBytes[i] = bytes1(uint8(nameBytes[i]) + 32);\r\n            }\r\n            // Check for the dot\r\n            if (nameBytes[i] == bytes1(\".\")) {\r\n                dotPosition = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory sanitizedBytes = new bytes(dotPosition);\r\n        for (uint i = 0; i < dotPosition; i++) {\r\n            sanitizedBytes[i] = nameBytes[i];\r\n        }\r\n\r\n        return string(sanitizedBytes);\r\n    }\r\n\r\n    function isLengthValid(string memory name) internal view returns (bool) {\r\n        bytes memory nameBytes = bytes(name);\r\n        uint length = nameBytes.length;\r\n\r\n        return (length >= minLength && length <= maxLength);\r\n    }\r\n\r\n    function changeLengths(uint256 min, uint256 max) public onlyOwner {\r\n        minLength = min;\r\n        maxLength = max;\r\n    }\r\n\r\n    function withdraw(address to, uint256 amount) public nonReentrant onlyOwner {\r\n        require(amount <= address(this).balance);\r\n        payable(to).transfer(amount);\r\n    }\r\n    \r\n    function flipActiveState() public onlyOwner {\r\n        isActive = !isActive;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addresses_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"changeLengths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"computeNamehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"namehash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipActiveState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_label\",\"type\":\"string\"}],\"name\":\"getWnsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"sanitizeName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addresses_\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct Signatures.TierUpgrade[]\",\"name\":\"tierUpgrade\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"upgradeTier\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"splitAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splitAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Signatures.Register[]\",\"name\":\"register\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"wnsRegister\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"splitAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splitAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Signatures.Register[]\",\"name\":\"register\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"wnsRegisterWithShare\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WnsRegistrar", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001498fccd345c4ba7cddb1054857a6efbc99b858e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://20d46c261fc63356fa845d8d0d4fff24120cc247d2525bd6987636536d9a5f15"}