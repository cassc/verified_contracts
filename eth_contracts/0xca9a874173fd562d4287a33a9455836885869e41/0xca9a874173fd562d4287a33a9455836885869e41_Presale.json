{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2024-06-05\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^ 0.8.26;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IToken {\r\n  function balanceOf(address _user) external view returns(uint256);\r\n  function transfer(address _user, uint256 amount) external returns (bool);  \r\n}\r\ncontract Presale is Ownable {\r\n  struct UserData {\r\n    uint256 buyTokenAmount;\r\n    uint256 payEtherAmount;\r\n    uint256 price;\r\n    uint256 limitTokens;\r\n    uint256 timeStamp;\r\n    uint256 duration;\r\n  }\r\n  IToken public token;\r\n  uint256 public PRESALE_ENTRIES = 1000 ether;\r\n  uint256 private whitelistPrice = 0.00003 ether;\r\n  uint256 public saleAmount; \r\n  uint256 public LimitTokens;\r\n  enum STAGES { PENDING, PRESALE, FINISH }\r\n  STAGES public stage = STAGES.PENDING;\r\n  mapping(address => bool) public whitelisted;\r\n  mapping(address => UserData) private userData;\r\n  uint256 public whitelistAccessCount;\r\n  mapping(uint256 => address) private AddressList;\r\n\r\n  constructor(address tokenAddress, uint256 price, uint256 presale_limit, uint256 tokens_limit) {\r\n    token = IToken(tokenAddress );\r\n    whitelistPrice = price;\r\n    PRESALE_ENTRIES = presale_limit;\r\n    LimitTokens = tokens_limit;\r\n  }\r\n\r\n  function buy(uint256 _amount) external payable {\r\n    require(stage == STAGES.PRESALE, \"Presale not started yet.\");\r\n    require(saleAmount + _amount <= PRESALE_ENTRIES, \"PRESALE LIMIT EXCEED\");\r\n    require(userData[msg.sender].buyTokenAmount + _amount  <= userData[msg.sender].limitTokens, \"Presale Limit Exceed\");    \r\n    require(whitelisted[msg.sender], \"You are not the member of Whitelist\");\r\n    require(msg.value >= userData[msg.sender].price * _amount / 1e18, \"need more money\");\r\n    token.transfer(msg.sender, _amount);\r\n    payable(owner()).transfer(msg.value);\r\n    userData[msg.sender].buyTokenAmount += _amount;\r\n    userData[msg.sender].payEtherAmount += msg.value;\r\n    saleAmount += _amount;\r\n  }\r\n\r\n  function getUserData(address _account) public view returns(UserData memory) {\r\n    return userData[_account];\r\n  }\r\n\r\n  function setPresaleEntries(uint256 preentries) external onlyOwner {\r\n    require(stage != STAGES.FINISH, \"Presale is already closed\");\r\n    PRESALE_ENTRIES = preentries;\r\n  }\r\n\r\n  function setProposal(uint256 _price, uint256 dura) external {\r\n    require(stage == STAGES.PRESALE, \"Presale is not opened.\");\r\n    require(_price >= whitelistPrice, \"Price is smaller than Limit\");\r\n    userData[msg.sender].timeStamp = block.timestamp;\r\n    userData[msg.sender].price = _price;\r\n    userData[msg.sender].duration = dura;\r\n    if(!whitelisted[msg.sender]) {\r\n      AddressList[whitelistAccessCount] = msg.sender;   \r\n      userData[msg.sender].buyTokenAmount = 0;\r\n      userData[msg.sender].payEtherAmount = 0;      \r\n      whitelisted[msg.sender] = true;\r\n      userData[msg.sender].limitTokens = LimitTokens;   \r\n      whitelistAccessCount++;\r\n    }\r\n  }\r\n\r\n  function removeWhiteListAddress(address addr) external onlyOwner {\r\n    _remoteWhiteListAddress(addr);\r\n  }\r\n\r\n  function _remoteWhiteListAddress(address addr) internal {\r\n    require(stage != STAGES.FINISH, \"Presale is already closed\"); \r\n      if(whitelisted[addr]) {  \r\n        for(uint8 i = 0; i < whitelistAccessCount; i++)\r\n          if(AddressList[i] == addr) {\r\n            for(uint j = i + 1; j < whitelistAccessCount; j++) {\r\n              AddressList[j - 1] = AddressList[j];\r\n            }\r\n            whitelistAccessCount--;\r\n            break;\r\n          }\r\n        whitelisted[addr] = false;\r\n      }    \r\n  }\r\n\r\n  function setLimitTokens(address _account, uint256 _amount) external {\r\n        require(stage != STAGES.FINISH, \"Presale is already closed\");\r\n    userData[_account].limitTokens = _amount;\r\n  }  \r\n\r\n  function setWhitelistPrice(uint256 rePrice) external onlyOwner {\r\n    require(stage != STAGES.FINISH, \"Presale is already closed\");    \r\n    whitelistPrice = rePrice;\r\n  }\r\n\r\n  function setLimit(uint256 limit) external onlyOwner {\r\n    require(stage != STAGES.FINISH, \"Presale is already closed\");    \r\n    LimitTokens = limit;    \r\n  }\r\n\r\n  function getWhitelistPrice() public view returns(uint256) {\r\n    return whitelistPrice;\r\n  }\r\n  function getLimitTokens() public view returns(uint256) {\r\n    return LimitTokens;\r\n  }  \r\n\r\n  function getAddressList() public onlyOwner view returns (address[] memory){\r\n    address[] memory result = new address[](whitelistAccessCount);\r\n    for (uint i = 0;  i < whitelistAccessCount; i++) {\r\n        result[i] = AddressList[i];\r\n    }\r\n    return result;    \r\n  }\r\n\r\n  function startSale() external onlyOwner {\r\n    require(stage == STAGES.PENDING, \"Not in pending stage.\");\r\n    for(uint i = 0; i < whitelistAccessCount; i++) {\r\n      userData[AddressList[i]].timeStamp = block.timestamp;\r\n    }\r\n    stage = STAGES.PRESALE;\r\n  }\r\n\r\n  function endSale() external onlyOwner {\r\n    require(stage == STAGES.PRESALE, \"Still in pending stage\");\r\n    stage = STAGES.FINISH;\r\n  }\r\n\r\n  function setSale(uint256 i) external onlyOwner {\r\n    if(i == 0)stage = STAGES.PENDING;\r\n    if(i == 1)stage = STAGES.PRESALE;\r\n    if(i == 2)stage = STAGES.FINISH;\r\n  }\r\n\r\n  function recoverCurrency(uint256 amount) public onlyOwner {\r\n    bool success;\r\n    (success, ) = payable(owner()).call{value: amount}(\"\");\r\n    require(success);\r\n  }\r\n\r\n  function recoverToken(uint256 tokenAmount) public onlyOwner {\r\n    token.transfer(owner(), tokenAmount * 1e18);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presale_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens_limit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LimitTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRESALE_ENTRIES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLimitTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"buyTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payEtherAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct Presale.UserData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeWhiteListAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setLimitTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"preentries\",\"type\":\"uint256\"}],\"name\":\"setPresaleEntries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dura\",\"type\":\"uint256\"}],\"name\":\"setProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"setSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rePrice\",\"type\":\"uint256\"}],\"name\":\"setWhitelistPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"enum Presale.STAGES\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistAccessCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Presale", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000023bbb1b8cc5756e4211c859bdc774f29461478c300000000000000000000000000000000000000000000000000001b48eb57e000000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000021e19e0c9bab2400000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1bc1d8137843a4374c66e5afd27375655358e1a199d819a70276a4f1dc97e25c"}