{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/nft/base/BaseEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\nimport \\\"../interfaces/IEscrow.sol\\\";\\n\\nabstract contract BaseEscrow is IEscrow {\\n    /// @dev The super admin address.\\n    address public superAdmin;\\n\\n    /// @dev The vault address that will be storing the funds\\n    address public vault;\\n\\n    /// @dev total supply\\n    uint256 public totalSupply;\\n\\n    /// @dev max nft per address\\n    uint256 public maxNftPerAddress;\\n\\n    constructor(address _superAdmin, address _vault, uint256 _totalSupply) {\\n        superAdmin = _superAdmin;\\n        vault = _vault;\\n        totalSupply = _totalSupply;\\n    }\\n\\n    ///@dev nft contract address - this will be 0 during the presale\\n    address public nftContract;\\n\\n    /// @dev if the mint is restricted to only whitelisted addresses\\n    bool public restrictedMint = true;\\n\\n    /// @dev paused state of the contract\\n    bool public paused = false;\\n\\n    /// @dev reserved supply\\n    uint256 public reservedSupply;\\n\\n    /// @dev nft price\\n    uint256 public nftPrice = 0.050 ether;\\n\\n    /// @dev escrow state\\n    EscrowState public state = EscrowState.ESCROW;\\n\\n    /// @dev Mapping of whitelisted addresses.\\n    mapping(address => bool) public whitelist;\\n\\n    /// @dev Mapping of admin addresses.\\n    mapping(address => bool) public admin;\\n\\n    /// @dev Mapping of nfts reserved.\\n    mapping(address => NftReserve) public nftReserveAmount;\\n\\n    /// @dev Checks if sender is admin.\\n    modifier onlyAdmin() {\\n        require(\\n            admin[msg.sender] || msg.sender == superAdmin,\\n            \\\"ESCROW: only admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Checks if sender is super admin.\\n    modifier onlySuperAdmin() {\\n        require(msg.sender == superAdmin, \\\"ESCROW: only super admin\\\");\\n        _;\\n    }\\n\\n    /// @dev Checks if sender is whitelisted.\\n    modifier onlyWhitelisted() {\\n        if (restrictedMint) {\\n            require(whitelist[msg.sender], \\\"ESCROW: only whitelisted\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Checks if sender is nft contract.\\n    modifier onlyNftContract() {\\n        require(msg.sender == nftContract, \\\"ESCROW: only nft contract\\\");\\n        _;\\n    }\\n\\n    /// @dev Checks if contract is not paused.\\n    modifier notPaused() {\\n        require(!paused, \\\"ESCROW: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Allows super admin to update escrow price.\\n     *\\n     * @param _nftPrice New escrow price.\\n     */\\n    function updateNftPrice(uint256 _nftPrice) external onlySuperAdmin {\\n        nftPrice = _nftPrice;\\n    }\\n\\n    /**\\n     * @dev Allows super admin to toggle an admin account\\n     *\\n     * @param _account The address to be marked as admin\\n     */\\n    function toggleAdminStatus(\\n        address _account\\n    ) external override onlySuperAdmin {\\n        admin[_account] = !admin[_account];\\n    }\\n\\n    /**\\n     * @dev Allows admin to toggle mint restriction\\n     */\\n    function toggleMintRestriction() external onlyAdmin {\\n        restrictedMint = !restrictedMint;\\n    }\\n\\n    /**\\n     * @dev Allows admin to update total supply\\n     *\\n     * @param _totalSupply total supply of escrow.\\n     */\\n    function updateTotalSupply(uint256 _totalSupply) external onlyAdmin {\\n        totalSupply = _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Allows admin to toggle whitelist\\n     *\\n     * @param _account The address to be toggled\\n     */\\n    function toggleWhitelist(address _account) external override onlyAdmin {\\n        whitelist[_account] = !whitelist[_account];\\n    }\\n\\n    /**\\n     *  @dev Allows admin to batch whitelist addresses\\n     *\\n     * @param _accounts array of addresses to be whitelisted\\n     */\\n    function batchWhitelist(address[] calldata _accounts) external onlyAdmin {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            whitelist[_accounts[i]] = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows super admin to update vault address.\\n     *\\n     * @param _vault The new vault address.\\n     */\\n    function updateVault(address _vault) external override onlySuperAdmin {\\n        vault = _vault;\\n    }\\n\\n    /**\\n     * @dev Allows super admin to update nft contract address.\\n     *\\n     * @param _nftContract The new nft contract address.\\n     */\\n    function updateNftContract(\\n        address _nftContract\\n    ) external override onlySuperAdmin {\\n        nftContract = _nftContract;\\n    }\\n\\n    /**\\n     * @dev Allows admins to toggle paused status\\n     */\\n    function togglePaused() external onlyAdmin {\\n        paused = !paused;\\n    }\\n\\n    /**\\n     * Allows admins to set a wallet limit.\\n     *\\n     * @param _limit The new limit.\\n     */\\n    function setLimitPerWallet(uint256 _limit) external onlyAdmin {\\n        maxNftPerAddress = _limit;\\n    }\\n\\n    /**\\n     * Allows super admin to renounce super admin role to another.\\n     *\\n     * @param _superAdmin The new super admin address.\\n     */\\n    function renounceSuperAdmin(address _superAdmin) external onlySuperAdmin {\\n        superAdmin = _superAdmin;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nft/ForgeEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\nimport \\\"./base/BaseEscrow.sol\\\";\\n\\ncontract ForgeEscrow is BaseEscrow {\\n    constructor(\\n        address _superAdmin,\\n        address _vault,\\n        uint256 _totalSupply\\n    ) BaseEscrow(_superAdmin, _vault, _totalSupply) {}\\n\\n    /// @dev Number of co-founder reserved mints.\\n    uint8 public coFounderMintLimit = 1;\\n\\n    /// @dev strictly for co-founder initial mint.\\n    uint256 public coFounderPrice = 0.55 ether;\\n\\n    /**\\n     * @dev Allows NFT contract to clear the reserved amount for an address\\n     *\\n     * @param _account Address to check\\n     */\\n    function claimFor(address _account) external override onlyNftContract {\\n        /// @dev this is a redundent check but it is here for safety\\n        require(nftContract != address(0), \\\"ESCROW: NFT contract not set.\\\");\\n        require(\\n            nftReserveAmount[_account].publicReserved > 0 ||\\n                nftReserveAmount[_account].coFounderReserved > 0,\\n            \\\"ESCROW: No nft reserved for account.\\\"\\n        );\\n\\n        nftReserveAmount[_account].price = 0;\\n        nftReserveAmount[_account].publicReserved = 0;\\n        nftReserveAmount[_account].coFounderReserved = 0;\\n    }\\n\\n    /**\\n     * @dev Allows NFT contract to set the escrow state to claim state.\\n     */\\n    function setClaim() external onlyNftContract {\\n        state = EscrowState.CLAIM;\\n    }\\n\\n    /**\\n     * @dev Allows NFT contract to set the escrow state to pending state.\\n     */\\n    function setPending() external onlyNftContract {\\n        state = EscrowState.ESCROW;\\n    }\\n\\n    /**\\n     * @dev Allows admin to withdraw funds into vault\\n     *\\n     */\\n    function withdrawETH() external onlyAdmin {\\n        require(\\n            address(this).balance > 0,\\n            \\\"ESCROW: No eth balance to withdraw.\\\"\\n        );\\n        require(\\n            state == EscrowState.CLAIM,\\n            \\\"ESCROW: Withdraw only allowed in claim state.\\\"\\n        );\\n\\n        payable(vault).transfer(address(this).balance);\\n    }\\n\\n    /**\\n     * @dev Allows admin to update co-founder price.\\n     *\\n     * @param _coFounderPrice New co-founder price.\\n     */\\n    function updateCoFounderPrice(uint256 _coFounderPrice) external onlyAdmin {\\n        coFounderPrice = _coFounderPrice;\\n    }\\n\\n    /**\\n     * @dev Allows super admin to update co-founder mint limit.\\n     *\\n     * @param _coFounderMintLimit Mint limit.\\n     */\\n    function updateCoFounderMintLimit(\\n        uint8 _coFounderMintLimit\\n    ) external onlyAdmin {\\n        coFounderMintLimit = _coFounderMintLimit;\\n    }\\n\\n    /**\\n     * @dev Emergency function to allow claimers to refund their reserved amount.\\n     */\\n    function setRefunded() external onlySuperAdmin {\\n        state = EscrowState.REFUND;\\n    }\\n\\n    /**\\n     * Reserve mint NFT for whitelisted addresses, differentiating between co-founder and normal NFTs\\n     *\\n     * @param _amount amount to reserve\\n     */\\n    function reserveMint(\\n        uint256 _amount\\n    ) external payable override notPaused onlyWhitelisted {\\n        uint256 expectedPrice = calculatePrice(_amount, msg.sender);\\n        uint256 mintsAllowed = calculateMintsAllowed(msg.sender);\\n\\n        require(\\n            msg.value == expectedPrice,\\n            \\\"ESCROW: Incorrect ETH value sent.\\\"\\n        );\\n        require(\\n            _amount <= mintsAllowed,\\n            \\\"ESCROW: Max nft per address reached.\\\"\\n        );\\n        require(\\n            reservedSupply + _amount <= totalSupply,\\n            \\\"ESCROW: Quantity goes above total supply.\\\"\\n        );\\n\\n        uint256 coFounderNfts = 0;\\n\\n        if (\\n            nftReserveAmount[msg.sender].coFounderReserved <\\n            coFounderMintLimit &&\\n            whitelist[msg.sender]\\n        ) {\\n            coFounderNfts =\\n                coFounderMintLimit -\\n                nftReserveAmount[msg.sender].coFounderReserved;\\n            if (coFounderNfts > _amount) {\\n                coFounderNfts = _amount;\\n            }\\n        }\\n\\n        reservedSupply += _amount;\\n\\n        nftReserveAmount[msg.sender].publicReserved += (_amount -\\n            coFounderNfts);\\n        nftReserveAmount[msg.sender].coFounderReserved += coFounderNfts;\\n        nftReserveAmount[msg.sender].price += msg.value;\\n\\n        emit NftReserved(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Emergency trustless functio to allow caller to refund their reserved amount.\\n     */\\n    function refund(address _address) external {\\n        require(\\n            state == EscrowState.REFUND,\\n            \\\"ESCROW: Refund only allowed in refund state.\\\"\\n        );\\n        require(\\n            nftReserveAmount[_address].publicReserved > 0 ||\\n                nftReserveAmount[_address].coFounderReserved > 0,\\n            \\\"ESCROW: No nft reserved for account.\\\"\\n        );\\n\\n        uint256 refundAmount = nftReserveAmount[_address].price;\\n\\n        nftReserveAmount[_address].publicReserved = 0;\\n        nftReserveAmount[_address].coFounderReserved = 0;\\n        nftReserveAmount[_address].price = 0;\\n\\n        payable(_address).transfer(refundAmount);\\n    }\\n\\n    /**\\n     * @dev Allows admins to set a reserved amount for an address\\n     *\\n     * @notice The value of the reserved amount will affect the total supply.\\n     *\\n     * @param _to Address to set reserve for\\n     * @param _newPublicAmount New reserve amount for the address\\n     * @param _newCoFounderAmount New co-founder reserve amount for the address\\n     */\\n    function adminReserveMint(\\n        address _to,\\n        uint256 _newPublicAmount,\\n        uint256 _newCoFounderAmount\\n    ) external override onlyAdmin {\\n        uint256 currentPublicAmount = nftReserveAmount[_to].publicReserved;\\n        uint256 currentCoFounderAmount = nftReserveAmount[_to]\\n            .coFounderReserved;\\n\\n        require(\\n            currentPublicAmount != _newPublicAmount ||\\n                currentCoFounderAmount != _newCoFounderAmount,\\n            \\\"ESCROW: No change in amount.\\\"\\n        );\\n\\n        uint256 totalNewAmount = _newPublicAmount + _newCoFounderAmount;\\n        uint256 totalCurrentAmount = currentPublicAmount +\\n            currentCoFounderAmount;\\n\\n        if (totalNewAmount > totalCurrentAmount) {\\n            uint256 additionalAmount = totalNewAmount - totalCurrentAmount;\\n\\n            require(\\n                totalSupply + additionalAmount <= maxNftPerAddress,\\n                \\\"ESCROW: New amount exceeds max limit.\\\"\\n            );\\n\\n            totalSupply += additionalAmount;\\n        } else if (totalCurrentAmount > totalNewAmount) {\\n            uint256 reductionAmount = totalCurrentAmount - totalNewAmount;\\n\\n            totalSupply -= reductionAmount;\\n        }\\n\\n        nftReserveAmount[_to].publicReserved = _newPublicAmount;\\n        nftReserveAmount[_to].coFounderReserved = _newCoFounderAmount;\\n\\n        emit NftReserved(_to, totalNewAmount);\\n    }\\n\\n    /**\\n     * @dev Calculates allowed mints in total.\\n     *\\n     * @notice This will not take into account the current amount minted.\\n     *\\n     * @param _account Address of the account\\n     */\\n    function calculateMintsAllowed(\\n        address _account\\n    ) public view returns (uint256) {\\n        uint256 alreadyMintedNfts = nftReserveAmount[_account].publicReserved +\\n            nftReserveAmount[_account].coFounderReserved;\\n\\n        if (whitelist[_account]) {\\n            uint256 whitelistedLimit = maxNftPerAddress + coFounderMintLimit;\\n\\n            return\\n                (whitelistedLimit > alreadyMintedNfts)\\n                    ? (whitelistedLimit - alreadyMintedNfts)\\n                    : 0;\\n        }\\n\\n        return\\n            (maxNftPerAddress > alreadyMintedNfts)\\n                ? (maxNftPerAddress - alreadyMintedNfts)\\n                : 0;\\n    }\\n\\n    /**\\n     *  This function will help determine the price of the nft based on their role and what they've already minted as a co-founder\\n     *\\n     * @param _amount quantity of nfts\\n     * @param _account  address of the account\\n     */\\n    function calculatePrice(\\n        uint256 _amount,\\n        address _account\\n    ) public view returns (uint256) {\\n        if (\\n            !whitelist[_account] ||\\n            nftReserveAmount[_account].coFounderReserved >= coFounderMintLimit\\n        ) {\\n            return _amount * nftPrice;\\n        }\\n\\n        uint256 coFounderEligibleAmount = coFounderMintLimit -\\n            nftReserveAmount[_account].coFounderReserved;\\n\\n        if (coFounderEligibleAmount > _amount) {\\n            coFounderEligibleAmount = _amount;\\n        }\\n\\n        uint256 coFounderTotalPrice = coFounderEligibleAmount * coFounderPrice;\\n\\n        uint256 standardAmount = _amount - coFounderEligibleAmount;\\n        uint256 standardTotalPrice = standardAmount * nftPrice;\\n\\n        return coFounderTotalPrice + standardTotalPrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nft/interfaces/IEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\ninterface IEscrow {\\n    ///@dev Event emiited when nft is reserved\\n    event NftReserved(address indexed to, uint256 amount);\\n\\n    /// @dev Event emitted when whitelist is toggled.\\n    event WhitelistToggled(address indexed account);\\n\\n    enum EscrowState {\\n        ESCROW,\\n        CLAIM,\\n        REFUND\\n    }\\n\\n    struct NftReserve {\\n        uint256 publicReserved;\\n        uint256 coFounderReserved;\\n        uint256 price;\\n    }\\n\\n    function claimFor(address _account) external;\\n\\n    function toggleWhitelist(address _account) external;\\n\\n    function toggleAdminStatus(address _account) external;\\n\\n    function updateNftContract(address _nftContract) external;\\n\\n    function updateVault(address _vault) external;\\n\\n    function reserveMint(uint256 _amount) external payable;\\n\\n    function adminReserveMint(\\n        address _to,\\n        uint256 _amount,\\n        uint256 coFounderAmount\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_superAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NftReserved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistToggled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newPublicAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newCoFounderAmount\",\"type\":\"uint256\"}],\"name\":\"adminReserveMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"batchWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"calculateMintsAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounderMintLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounderPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNftPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftReserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"publicReserved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coFounderReserved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_superAdmin\",\"type\":\"address\"}],\"name\":\"renounceSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"reserveMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictedMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setLimitPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRefunded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum IEscrow.EscrowState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"toggleAdminStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleMintRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"toggleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_coFounderMintLimit\",\"type\":\"uint8\"}],\"name\":\"updateCoFounderMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coFounderPrice\",\"type\":\"uint256\"}],\"name\":\"updateCoFounderPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"}],\"name\":\"updateNftContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftPrice\",\"type\":\"uint256\"}],\"name\":\"updateNftPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"updateTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"updateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ForgeEscrow", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007b9a6faa0ff6a59e7e7f06b61f99af53021d95cd000000000000000000000000386e93e9a9d8061abd0595377519598c35196645000000000000000000000000000000000000000000000000000000000000022b", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}