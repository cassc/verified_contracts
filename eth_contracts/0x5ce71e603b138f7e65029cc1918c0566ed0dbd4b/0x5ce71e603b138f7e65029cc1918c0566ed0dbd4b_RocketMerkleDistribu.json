{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interface/RocketStorageInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketStorageInterface {\\n\\n    // Deploy status\\n    function getDeployedStatus() external view returns (bool);\\n\\n    // Guardian\\n    function getGuardian() external view returns(address);\\n    function setGuardian(address _newAddress) external;\\n    function confirmGuardian() external;\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getString(bytes32 _key) external view returns (string memory);\\n    function getBytes(bytes32 _key) external view returns (bytes memory);\\n    function getBool(bytes32 _key) external view returns (bool);\\n    function getInt(bytes32 _key) external view returns (int);\\n    function getBytes32(bytes32 _key) external view returns (bytes32);\\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setString(bytes32 _key, string calldata _value) external;\\n    function setBytes(bytes32 _key, bytes calldata _value) external;\\n    function setBool(bytes32 _key, bool _value) external;\\n    function setInt(bytes32 _key, int _value) external;\\n    function setBytes32(bytes32 _key, bytes32 _value) external;\\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteString(bytes32 _key) external;\\n    function deleteBytes(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;\\n    function deleteInt(bytes32 _key) external;\\n    function deleteBytes32(bytes32 _key) external;\\n\\n    // Arithmetic\\n    function addUint(bytes32 _key, uint256 _amount) external;\\n    function subUint(bytes32 _key, uint256 _amount) external;\\n\\n    // Protected storage\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\\n    function confirmWithdrawalAddress(address _nodeAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/contract/RocketBase.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../interface/RocketStorageInterface.sol\\\";\\n\\n/// @title Base settings / modifiers for each contract in Rocket Pool\\n/// @author David Rugendyke\\n\\nabstract contract RocketBase {\\n\\n    // Calculate using this as the base\\n    uint256 constant calcBase = 1 ether;\\n\\n    // Version of the contract\\n    uint8 public version;\\n\\n    // The main storage contract where primary persistant storage is maintained\\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\\n\\n\\n    /*** Modifiers **********************************************************/\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\\n    */\\n    modifier onlyLatestNetworkContract() {\\n        require(getBool(keccak256(abi.encodePacked(\\\"contract.exists\\\", msg.sender))), \\\"Invalid or outdated network contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\\n    */\\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName))), \\\"Invalid or outdated contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a registered node\\n    */\\n    modifier onlyRegisteredNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"node.exists\\\", _nodeAddress))), \\\"Invalid node\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\\n    */\\n    modifier onlyTrustedNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"dao.trustednodes.\\\", \\\"member\\\", _nodeAddress))), \\\"Invalid trusted node\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a registered minipool\\n    */\\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"minipool.exists\\\", _minipoolAddress))), \\\"Invalid minipool\\\");\\n        _;\\n    }\\n    \\n\\n    /**\\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\\n    */\\n    modifier onlyGuardian() {\\n        require(msg.sender == rocketStorage.getGuardian(), \\\"Account is not a temporary guardian\\\");\\n        _;\\n    }\\n\\n\\n\\n\\n    /*** Methods **********************************************************/\\n\\n    /// @dev Set the main Rocket Storage address\\n    constructor(RocketStorageInterface _rocketStorageAddress) {\\n        // Update the contract address\\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\\n    }\\n\\n\\n    /// @dev Get the address of a network contract by name\\n    function getContractAddress(string memory _contractName) internal view returns (address) {\\n        // Get the current contract address\\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        // Check it\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        // Return\\n        return contractAddress;\\n    }\\n\\n\\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\\n        // Get the current contract address\\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        // Return\\n        return contractAddress;\\n    }\\n\\n\\n    /// @dev Get the name of a network contract by address\\n    function getContractName(address _contractAddress) internal view returns (string memory) {\\n        // Get the contract name\\n        string memory contractName = getString(keccak256(abi.encodePacked(\\\"contract.name\\\", _contractAddress)));\\n        // Check it\\n        require(bytes(contractName).length > 0, \\\"Contract not found\\\");\\n        // Return\\n        return contractName;\\n    }\\n\\n    /// @dev Get revert error message from a .call method\\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n        assembly {\\n            // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n\\n\\n\\n    /*** Rocket Storage Methods ****************************************/\\n\\n    // Note: Unused helpers have been removed to keep contract sizes down\\n\\n    /// @dev Storage get methods\\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\\n\\n    /// @dev Storage set methods\\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\\n\\n    /// @dev Storage delete methods\\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\\n\\n    /// @dev Storage arithmetic methods\\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/util/IERC20.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/token/RocketTokenRPLInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"../util/IERC20.sol\\\";\\n\\ninterface RocketTokenRPLInterface is IERC20 {\\n    function getInflationCalcTime() external view returns(uint256);\\n    function getInflationIntervalTime() external view returns(uint256);\\n    function getInflationIntervalRate() external view returns(uint256);\\n    function getInflationIntervalsPassed() external view returns(uint256);\\n    function getInflationIntervalStartTime() external view returns(uint256);\\n    function getInflationRewardsContractAddress() external view returns(address);\\n    function inflationCalculate() external view returns (uint256);\\n    function inflationMintTokens() external returns (uint256);\\n    function swapTokens(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/util/IERC20Burnable.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\nimport \\\"./IERC20.sol\\\";\\n\\npragma solidity >0.5.0 <0.9.0;\\n\\ninterface IERC20Burnable is IERC20 {\\n    function burn(uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/RocketVaultInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\nimport \\\"./util/IERC20Burnable.sol\\\";\\n\\ninterface RocketVaultInterface {\\n    function balanceOf(string memory _networkContractName) external view returns (uint256);\\n    function depositEther() external payable;\\n    function withdrawEther(uint256 _amount) external;\\n    function depositToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\\n    function withdrawToken(address _withdrawalAddress, IERC20 _tokenAddress, uint256 _amount) external;\\n    function balanceOfToken(string memory _networkContractName, IERC20 _tokenAddress) external view returns (uint256);\\n    function transferToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\\n    function burnToken(IERC20Burnable _tokenAddress, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/node/RocketNodeStakingInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\n\\ninterface RocketNodeStakingInterface {\\n    function getTotalRPLStake() external view returns (uint256);\\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\\n    function getRPLLockingAllowed(address _nodeAddress) external view returns (bool);\\n    function stakeRPL(uint256 _amount) external;\\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\\n    function setRPLLockingAllowed(address _nodeAddress, bool _allowed) external;\\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\\n    function setStakeRPLForAllowed(address _nodeAddress, address _caller, bool _allowed) external;\\n    function getNodeRPLLocked(address _nodeAddress) external view returns (uint256);\\n    function lockRPL(address _nodeAddress, uint256 _amount) external;\\n    function unlockRPL(address _nodeAddress, uint256 _amount) external;\\n    function transferRPL(address _from, address _to, uint256 _amount) external;\\n    function withdrawRPL(uint256 _amount) external;\\n    function withdrawRPL(address _nodeAddress, uint256 _amount) external;\\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/rewards/RocketRewardsRelayInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\npragma abicoder v2;\\n\\ninterface RocketRewardsRelayInterface {\\n    function relayRewards(uint256 _intervalIndex, bytes32 _merkleRoot, uint256 _rewardsRPL, uint256 _rewardsETH) external;\\n    function claim(address _nodeAddress, uint256[] calldata _intervalIndex, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, bytes32[][] calldata _merkleProof) external;\\n    function claimAndStake(address _nodeAddress, uint256[] calldata _intervalIndex, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, bytes32[][] calldata _merkleProof, uint256 _stakeAmount) external;\\n    function isClaimed(uint256 _intervalIndex, address _claimer) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/rewards/RocketSmoothingPoolInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\npragma abicoder v2;\\n\\ninterface RocketSmoothingPoolInterface {\\n    function withdrawEther(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/RocketVaultWithdrawerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface RocketVaultWithdrawerInterface {\\n    function receiveVaultWithdrawalETH() external payable; \\n}\\n\"\r\n    },\r\n    \"contracts/types/NodeDetails.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\npragma solidity >0.5.0 <0.9.0;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// A struct containing all the information on-chain about a specific node\\n\\nstruct NodeDetails {\\n    bool exists;\\n    uint256 registrationTime;\\n    string timezoneLocation;\\n    bool feeDistributorInitialised;\\n    address feeDistributorAddress;\\n    uint256 rewardNetwork;\\n    uint256 rplStake;\\n    uint256 effectiveRPLStake;\\n    uint256 minimumRPLStake;\\n    uint256 maximumRPLStake;\\n    uint256 ethMatched;\\n    uint256 ethMatchedLimit;\\n    uint256 minipoolCount;\\n    uint256 balanceETH;\\n    uint256 balanceRETH;\\n    uint256 balanceRPL;\\n    uint256 balanceOldRPL;\\n    uint256 depositCreditBalance;\\n    uint256 distributorBalanceUserETH;\\n    uint256 distributorBalanceNodeETH;\\n    address withdrawalAddress;\\n    address pendingWithdrawalAddress;\\n    bool smoothingPoolRegistrationState;\\n    uint256 smoothingPoolRegistrationChanged;\\n    address nodeAddress;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/node/RocketNodeManagerInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"../../types/NodeDetails.sol\\\";\\n\\ninterface RocketNodeManagerInterface {\\n\\n    // Structs\\n    struct TimezoneCount {\\n        string timezone;\\n        uint256 count;\\n    }\\n\\n    function getNodeCount() external view returns (uint256);\\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\\n    function getNodeAt(uint256 _index) external view returns (address);\\n    function getNodeExists(address _nodeAddress) external view returns (bool);\\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) external view returns (bool);\\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external;\\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external;\\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external;\\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\\n    function registerNode(string calldata _timezoneLocation) external;\\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\\n    function initialiseFeeDistributor() external;\\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\\n    function setSmoothingPoolRegistrationState(bool _state) external;\\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\\n    function getNodeDetails(address _nodeAddress) external view returns (NodeDetails memory);\\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/rewards/RocketMerkleDistributorMainnetInterface.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >0.5.0 <0.9.0;\\n\\nimport \\\"./RocketRewardsRelayInterface.sol\\\";\\n\\ninterface RocketMerkleDistributorMainnetInterface is RocketRewardsRelayInterface {\\n    function claimOutstandingEth() external;\\n    function getOutstandingEth(address _address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin4/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contract/rewards/RocketMerkleDistributorMainnet.sol\": {\r\n      \"content\": \"/**\\r\\n   *       .\\r\\n   *      / \\\\\\r\\n   *     |.'.|\\r\\n   *     |'.'|\\r\\n   *   ,'|   |'.\\r\\n   *  |,-'-|-'-.|\\r\\n   *   __|_| |         _        _      _____           _\\r\\n   *  | ___ \\\\|        | |      | |    | ___ \\\\         | |\\r\\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\\r\\n   *  |    // _ \\\\ / __| |/ / _ \\\\ __|  |  __/ _ \\\\ / _ \\\\| |\\r\\n   *  | |\\\\ \\\\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\\r\\n   *  \\\\_| \\\\_\\\\___/ \\\\___|_|\\\\_\\\\___|\\\\__|  \\\\_|  \\\\___/ \\\\___/|_|\\r\\n   * +---------------------------------------------------+\\r\\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\\r\\n   * +---------------------------------------------------+\\r\\n   *\\r\\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\\r\\n   *  be community-owned, decentralised, permissionless, & trustless.\\r\\n   *\\r\\n   *  For more information about Rocket Pool, visit https://rocketpool.net\\r\\n   *\\r\\n   *  Authored by the Rocket Pool Core Team\\r\\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\\r\\n   *  A special thanks to the Rocket Pool community for all their contributions.\\r\\n   *\\r\\n   */\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"../RocketBase.sol\\\";\\r\\nimport \\\"../../interface/token/RocketTokenRPLInterface.sol\\\";\\r\\nimport \\\"../../interface/RocketVaultInterface.sol\\\";\\r\\nimport \\\"../../interface/node/RocketNodeStakingInterface.sol\\\";\\r\\nimport \\\"../../interface/rewards/RocketRewardsRelayInterface.sol\\\";\\r\\nimport \\\"../../interface/rewards/RocketSmoothingPoolInterface.sol\\\";\\r\\nimport \\\"../../interface/RocketVaultWithdrawerInterface.sol\\\";\\r\\nimport \\\"../../interface/node/RocketNodeManagerInterface.sol\\\";\\r\\nimport \\\"../../interface/rewards/RocketMerkleDistributorMainnetInterface.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin4/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\n/// @dev On mainnet, the relay and the distributor are the same contract as there is no need for an intermediate contract to\\r\\n///      handle cross-chain messaging.\\r\\ncontract RocketMerkleDistributorMainnet is RocketBase, RocketMerkleDistributorMainnetInterface, RocketVaultWithdrawerInterface {\\r\\n\\r\\n    // Events\\r\\n    event RewardsClaimed(address indexed claimer, uint256[] rewardIndex, uint256[] amountRPL, uint256[] amountETH);\\r\\n\\r\\n    // Constants\\r\\n    uint256 constant network = 0;\\r\\n\\r\\n    // Immutables\\r\\n    bytes32 immutable rocketVaultKey;\\r\\n    bytes32 immutable rocketTokenRPLKey;\\r\\n\\r\\n    // Allow receiving ETH\\r\\n    receive() payable external {}\\r\\n\\r\\n    // Construct\\r\\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\\r\\n        // Version\\r\\n        version = 2;\\r\\n        // Precompute keys\\r\\n        rocketVaultKey = keccak256(abi.encodePacked(\\\"contract.address\\\", \\\"rocketVault\\\"));\\r\\n        rocketTokenRPLKey = keccak256(abi.encodePacked(\\\"contract.address\\\", \\\"rocketTokenRPL\\\"));\\r\\n    }\\r\\n\\r\\n    // Called by RocketRewardsPool to include a snapshot into this distributor\\r\\n    function relayRewards(uint256 _rewardIndex, bytes32 _root, uint256 _rewardsRPL, uint256 _rewardsETH) external override onlyLatestContract(\\\"rocketMerkleDistributorMainnet\\\", address(this)) onlyLatestContract(\\\"rocketRewardsPool\\\", msg.sender) {\\r\\n        bytes32 key = keccak256(abi.encodePacked('rewards.merkle.root', _rewardIndex));\\r\\n        require(getBytes32(key) == bytes32(0));\\r\\n        setBytes32(key, _root);\\r\\n        // Send the ETH and RPL to the vault\\r\\n        RocketVaultInterface rocketVault = RocketVaultInterface(getAddress(rocketVaultKey));\\r\\n        if (_rewardsETH > 0) {\\r\\n            rocketVault.depositEther{value: _rewardsETH}();\\r\\n        }\\r\\n        if (_rewardsRPL > 0) {\\r\\n            IERC20 rocketTokenRPL = IERC20(getAddress(rocketTokenRPLKey));\\r\\n            rocketTokenRPL.approve(address(rocketVault), _rewardsRPL);\\r\\n            rocketVault.depositToken(\\\"rocketMerkleDistributorMainnet\\\", rocketTokenRPL, _rewardsRPL);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Reward recipients can call this method with a merkle proof to claim rewards for one or more reward intervals\\r\\n    function claim(address _nodeAddress, uint256[] calldata _rewardIndex, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, bytes32[][] calldata _merkleProof) external override {\\r\\n        claimAndStake(_nodeAddress, _rewardIndex, _amountRPL, _amountETH, _merkleProof, 0);\\r\\n    }\\r\\n\\r\\n    function claimAndStake(address _nodeAddress, uint256[] calldata _rewardIndex, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, bytes32[][] calldata _merkleProof, uint256 _stakeAmount) public override {\\r\\n        _verifyClaim(_rewardIndex, _nodeAddress, _amountRPL, _amountETH, _merkleProof);\\r\\n        _claimAndStake(_nodeAddress, _rewardIndex, _amountRPL, _amountETH, _stakeAmount);\\r\\n    }\\r\\n\\r\\n    // Node operators can call this method to claim rewards for one or more reward intervals and specify an amount of RPL to stake at the same time\\r\\n    function _claimAndStake(address _nodeAddress, uint256[] calldata _rewardIndex, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, uint256 _stakeAmount) internal {\\r\\n        // Get contracts\\r\\n        RocketVaultInterface rocketVault = RocketVaultInterface(getAddress(rocketVaultKey));\\r\\n\\r\\n        address rplWithdrawalAddress;\\r\\n        address withdrawalAddress;\\r\\n\\r\\n        // Confirm caller is permitted\\r\\n        {\\r\\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\\\"rocketNodeManager\\\"));\\r\\n            rplWithdrawalAddress = rocketNodeManager.getNodeRPLWithdrawalAddress(_nodeAddress);\\r\\n            withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\\r\\n            if (rocketNodeManager.getNodeRPLWithdrawalAddressIsSet(_nodeAddress)) {\\r\\n                if (_stakeAmount > 0) {\\r\\n                    // If staking and RPL withdrawal address is set, must be called from RPL withdrawal address\\r\\n                    require(msg.sender == rplWithdrawalAddress, \\\"Can only claim and stake from RPL withdrawal address\\\");\\r\\n                } else {\\r\\n                    // Otherwise, must be called from RPL withdrawal address, node address or withdrawal address\\r\\n                    require(msg.sender == rplWithdrawalAddress || msg.sender == _nodeAddress || msg.sender == withdrawalAddress, \\\"Can only claim from withdrawal addresses or node address\\\");\\r\\n                }\\r\\n            } else {\\r\\n                // If RPL withdrawal address isn't set, must be called from node address or withdrawal address\\r\\n                require(msg.sender == _nodeAddress || msg.sender == withdrawalAddress, \\\"Can only claim from node address\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        address rocketTokenRPLAddress = getAddress(rocketTokenRPLKey);\\r\\n\\r\\n        // Calculate totals\\r\\n        {\\r\\n            uint256 totalAmountRPL = 0;\\r\\n            uint256 totalAmountETH = 0;\\r\\n            for (uint256 i = 0; i < _rewardIndex.length; ++i) {\\r\\n                totalAmountRPL = totalAmountRPL + _amountRPL[i];\\r\\n                totalAmountETH = totalAmountETH + _amountETH[i];\\r\\n            }\\r\\n            // Validate input\\r\\n            require(_stakeAmount <= totalAmountRPL, \\\"Invalid stake amount\\\");\\r\\n            {\\r\\n                // Distribute any remaining tokens to the node's withdrawal address\\r\\n                uint256 remaining = totalAmountRPL - _stakeAmount;\\r\\n                if (remaining > 0) {\\r\\n                    rocketVault.withdrawToken(rplWithdrawalAddress, IERC20(rocketTokenRPLAddress), remaining);\\r\\n                }\\r\\n            }\\r\\n            // Distribute ETH\\r\\n            if (totalAmountETH > 0) {\\r\\n                rocketVault.withdrawEther(totalAmountETH);\\r\\n                // Allow up to 10000 gas to send ETH to the withdrawal address\\r\\n                (bool result,) = withdrawalAddress.call{value: totalAmountETH, gas: 10000}(\\\"\\\");\\r\\n                if (!result) {\\r\\n                    // If the withdrawal address cannot accept the ETH with 10000 gas, add it to their balance to be claimed later at their own expense\\r\\n                    bytes32 balanceKey = keccak256(abi.encodePacked('rewards.eth.balance', withdrawalAddress));\\r\\n                    addUint(balanceKey, totalAmountETH);\\r\\n                    // Return the ETH to the vault\\r\\n                    rocketVault.depositEther{value: totalAmountETH}();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Restake requested amount\\r\\n        if (_stakeAmount > 0) {\\r\\n            RocketTokenRPLInterface rocketTokenRPL = RocketTokenRPLInterface(rocketTokenRPLAddress);\\r\\n            RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\\\"rocketNodeStaking\\\"));\\r\\n            rocketVault.withdrawToken(address(this), IERC20(rocketTokenRPLAddress), _stakeAmount);\\r\\n            rocketTokenRPL.approve(address(rocketNodeStaking), _stakeAmount);\\r\\n            rocketNodeStaking.stakeRPLFor(_nodeAddress, _stakeAmount);\\r\\n        }\\r\\n\\r\\n        // Emit event\\r\\n        emit RewardsClaimed(_nodeAddress, _rewardIndex, _amountRPL, _amountETH);\\r\\n    }\\r\\n\\r\\n    // If ETH was claimed but was unable to be sent to the withdrawal address, it can be claimed via this function\\r\\n    function claimOutstandingEth() external override {\\r\\n        // Get contracts\\r\\n        RocketVaultInterface rocketVault = RocketVaultInterface(getAddress(rocketVaultKey));\\r\\n        // Get the amount and zero it out\\r\\n        bytes32 balanceKey = keccak256(abi.encodePacked('rewards.eth.balance', msg.sender));\\r\\n        uint256 amount = getUint(balanceKey);\\r\\n        setUint(balanceKey, 0);\\r\\n        // Withdraw the ETH from the vault\\r\\n        rocketVault.withdrawEther(amount);\\r\\n        // Attempt to send it to the caller\\r\\n        (bool result,) = payable(msg.sender).call{value: amount}(\\\"\\\");\\r\\n        require(result, 'Transfer failed');\\r\\n    }\\r\\n\\r\\n    // Returns the amount of ETH that can be claimed by a withdrawal address\\r\\n    function getOutstandingEth(address _address) external override view returns (uint256) {\\r\\n        bytes32 balanceKey = keccak256(abi.encodePacked('rewards.eth.balance', _address));\\r\\n        return getUint(balanceKey);\\r\\n    }\\r\\n\\r\\n    // Verifies the given data exists as a leaf nodes for the specified reward interval and marks them as claimed if they are valid\\r\\n    // Note: this function is optimised for gas when _rewardIndex is ordered numerically\\r\\n    function _verifyClaim(uint256[] calldata _rewardIndex, address _nodeAddress, uint256[] calldata _amountRPL, uint256[] calldata _amountETH, bytes32[][] calldata _merkleProof) internal {\\r\\n        // Set initial parameters to the first reward index in the array\\r\\n        uint256 indexWordIndex = _rewardIndex[0] / 256;\\r\\n        bytes32 claimedWordKey = keccak256(abi.encodePacked('rewards.interval.claimed', _nodeAddress, indexWordIndex));\\r\\n        uint256 claimedWord = getUint(claimedWordKey);\\r\\n        // Loop over every entry\\r\\n        for (uint256 i = 0; i < _rewardIndex.length; ++i) {\\r\\n            // Prevent accidental claim of 0\\r\\n            require(_amountRPL[i] > 0 || _amountETH[i] > 0, \\\"Invalid amount\\\");\\r\\n            // Check if this entry has a different word index than the previous\\r\\n            if (indexWordIndex != _rewardIndex[i] / 256) {\\r\\n                // Store the previous word\\r\\n                setUint(claimedWordKey, claimedWord);\\r\\n                // Load the word for this entry\\r\\n                indexWordIndex = _rewardIndex[i] / 256;\\r\\n                claimedWordKey = keccak256(abi.encodePacked('rewards.interval.claimed', _nodeAddress, indexWordIndex));\\r\\n                claimedWord = getUint(claimedWordKey);\\r\\n            }\\r\\n            // Calculate the bit index for this entry\\r\\n            uint256 indexBitIndex = _rewardIndex[i] % 256;\\r\\n            // Ensure the bit is not yet set on this word\\r\\n            uint256 mask = (1 << indexBitIndex);\\r\\n            require(claimedWord & mask != mask, \\\"Already claimed\\\");\\r\\n            // Verify the merkle proof\\r\\n            require(_verifyProof(_rewardIndex[i], _nodeAddress, _amountRPL[i], _amountETH[i], _merkleProof[i]), \\\"Invalid proof\\\");\\r\\n            // Set the bit for the current reward index\\r\\n            claimedWord = claimedWord | (1 << indexBitIndex);\\r\\n        }\\r\\n        // Store the word\\r\\n        setUint(claimedWordKey, claimedWord);\\r\\n    }\\r\\n\\r\\n    // Verifies that the given proof is valid\\r\\n    function _verifyProof(uint256 _rewardIndex, address _nodeAddress, uint256 _amountRPL, uint256 _amountETH, bytes32[] calldata _merkleProof) internal view returns (bool) {\\r\\n        bytes32 node = keccak256(abi.encodePacked(_nodeAddress, network, _amountRPL, _amountETH));\\r\\n        bytes32 key = keccak256(abi.encodePacked('rewards.merkle.root', _rewardIndex));\\r\\n        bytes32 merkleRoot = getBytes32(key);\\r\\n        return MerkleProof.verify(_merkleProof, merkleRoot, node);\\r\\n    }\\r\\n\\r\\n    // Returns true if the given claimer has claimed for the given reward interval\\r\\n    function isClaimed(uint256 _rewardIndex, address _claimer) public override view returns (bool) {\\r\\n        uint256 indexWordIndex = _rewardIndex / 256;\\r\\n        uint256 indexBitIndex = _rewardIndex % 256;\\r\\n        uint256 claimedWord = getUint(keccak256(abi.encodePacked('rewards.interval.claimed', _claimer, indexWordIndex)));\\r\\n        uint256 mask = (1 << indexBitIndex);\\r\\n        return claimedWord & mask == mask;\\r\\n    }\\r\\n\\r\\n    // Allow receiving ETH from RocketVault, no action required\\r\\n    function receiveVaultWithdrawalETH() external override payable {}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract RocketStorageInterface\",\"name\":\"_rocketStorageAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"rewardIndex\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountRPL\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountETH\",\"type\":\"uint256[]\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_rewardIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountRPL\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountETH\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[][]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_rewardIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountRPL\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountETH\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"}],\"name\":\"claimAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOutstandingEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getOutstandingEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveVaultWithdrawalETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsRPL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsETH\",\"type\":\"uint256\"}],\"name\":\"relayRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RocketMerkleDistributorMainnet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "15000", "ConstructorArguments": "0000000000000000000000001d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}