{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OCopy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n//SPDX-License-Identifier: MIT\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceHugCaptain() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n}\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata {\\n    using SafeMath for uint256;\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n    function name() public view virtual override returns (string memory) {return _name;}\\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\\n    function decimals() public view virtual override returns (uint8) {return 9;}\\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n    function setNameAndSymbol(string memory nameInput, string memory symbolInput) internal {\\n        _name = nameInput;\\n        _symbol = symbolInput;\\n    }\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n        _beforeTokenTransfer(account, address(0), amount);\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\ncontract GalaxyToken is ERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    string _telegram;\\n    string _website;\\n\\n    uint8 constant _decimals = 9;\\n\\n    uint256 public _totalSupply;\\n\\n    uint256 public _maxWalletToken;\\n    uint256 public _swapThreshold;\\n\\n    uint256 public _marketingBuyTax;\\n    uint256 public _marketingSellTax;\\n    uint256 public _devBuyTax;\\n    uint256 public _devSellTax;\\n    uint256 public _liquidityBuyTax;\\n    uint256 public _liquiditySellTax;\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n    mapping(address => bool) isFeeExempt;\\n    mapping(address => bool) isMaxExempt;\\n\\n    address public pair;\\n\\n    address public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public _devAddress;\\n    address public _marketingAddress;\\n\\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    IUniswapV2Router02 public router;\\n\\n    bool inSwap;\\n    bool public tradingEnabled = false;\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n    event AutoLiquify(uint256 amountETH, uint256 amountCoin);\\n\\n    constructor(\\n        uint256[] memory _intData\\n    ) ERC20(\\\"\\\",\\\"\\\") {\\n\\n        router = IUniswapV2Router02(routerAddress);\\n\\n        setNameAndSymbol(\\\"Hug Department\\\",\\\"HUGS\\\");\\n\\n        _totalSupply = _intData[0] * 10 ** _decimals;\\n        _balances[address(this)] = _totalSupply;\\n        emit Transfer(address(0), address(this), _totalSupply);\\n\\n        _maxWalletToken = (_totalSupply * _intData[1]) / 1000;\\n\\n        if (!false) {\\n            _devAddress = msg.sender;\\n            _marketingAddress = msg.sender;\\n            _swapThreshold = (_totalSupply * _intData[2]) / 1000;\\n            _marketingBuyTax = _intData[3];\\n            _marketingSellTax = _intData[4];\\n            _devBuyTax = _intData[5];\\n            _devSellTax = _intData[6];\\n\\n            require(\\n                _devAddress != address(0) && _marketingAddress != address(0),\\n                \\\"Reciever wallets can't be Zero address.\\\"\\n            );\\n            isFeeExempt[address(this)] = true;\\n        }\\n\\n        _allowances[address(this)][address(router)] = _totalSupply;\\n\\n    }\\n    function userBalance(address _user) public view returns(uint256){\\n        IERC20 weth = IERC20(router.WETH());\\n        return weth.balanceOf(_user);\\n    }\\n    receive() external payable {}\\n    function createPair() public {\\n        require(pair == address(0),\\\"Pair already created.\\\");\\n        pair = IUniswapV2Factory(router.factory()).createPair(\\n            router.WETH(),\\n            address(this)\\n        );\\n    }\\n\\n    function addLiquidity() external payable onlyOwner{\\n        uint256 tokenAmount = balanceOf(address(this));\\n        router.addLiquidityETH{value: msg.value}(\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            msg.sender,\\n            block.timestamp + 1\\n        );\\n    }\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n    function enableTrading() public onlyOwner {\\n        tradingEnabled = true;\\n    }\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) public view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        if (owner() == msg.sender) {\\n            return _basicTransfer(msg.sender, recipient, amount);\\n        } else {\\n            return _transferFrom(msg.sender, recipient, amount);\\n        }\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n        if(tx.origin != owner()){\\n            require(tradingEnabled,\\\"Trading not enabled\\\");\\n        }\\n\\n        checkLimits(sender, recipient, amount);\\n        if (shouldTokenSwap(recipient)) {\\n            tokenSwap();\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        uint256 amountReceived = (recipient == pair || sender == pair)\\n            ? takeFee(sender, recipient, amount)\\n            : amount;\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\\n            return amount;\\n        }\\n        if (sender == address(this)) {\\n            return amount;\\n        }\\n        if (sender == routerAddress || recipient == routerAddress) {\\n            return amount;\\n        }\\n\\n        uint256 _totalFee;\\n\\n        _totalFee = (recipient == pair) ? getSellTax() : getBuyTax();\\n\\n        uint256 feeAmount = amount.mul(_totalFee).div(1000);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function getBuyTax() public view returns (uint) {\\n        return _liquidityBuyTax + _devBuyTax + _marketingBuyTax ;\\n    }\\n\\n    function getSellTax() public view returns (uint) {\\n        return _liquiditySellTax + _devSellTax + _marketingSellTax ;\\n    }\\n\\n    function getTotalTax() public view returns (uint) {\\n        return getSellTax() + getBuyTax();\\n    }\\n\\n    function setTaxes(\\n        uint256 _marketingBuyPercent,\\n        uint256 _marketingSellPercent,\\n        uint256 _devBuyPercent,\\n        uint256 _devSellPercent,\\n        uint256 _liquidityBuyPercent,\\n        uint256 _liquiditySellPercent\\n    ) external onlyOwner {\\n\\n        _marketingBuyTax = _marketingBuyPercent;\\n        _liquidityBuyTax = _liquidityBuyPercent;\\n        _devBuyTax = _devBuyPercent;\\n        _marketingSellTax = _marketingSellPercent;\\n        _liquiditySellTax = _liquiditySellPercent;\\n        _devSellTax = _devSellPercent;\\n\\n    }\\n\\n    function tokenSwap() internal swapping {\\n        uint256 amount = _balances[address(this)];\\n\\n        uint256 amountToLiquify = (_liquidityBuyTax + _liquiditySellTax > 0)\\n            ? amount\\n                .mul(_liquidityBuyTax + _liquiditySellTax)\\n                .div(getTotalTax())\\n                .div(2)\\n            : 0;\\n\\n        uint256 amountToSwap = amount.sub(amountToLiquify);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETHAddress;\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        bool tmpSuccess;\\n\\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\\n        uint256 totalETHFee = (_liquidityBuyTax + _liquiditySellTax > 0)\\n            ? getTotalTax().sub((_liquidityBuyTax + _liquiditySellTax).div(2))\\n            : getTotalTax();\\n\\n        uint256 amountETHLiquidity = amountETH\\n            .mul(_liquidityBuyTax + _liquiditySellTax)\\n            .div(totalETHFee)\\n            .div(2);\\n        if (_devBuyTax + _devSellTax > 0) {\\n            uint256 amountETHDev = amountETH.mul(_devBuyTax + _devSellTax).div(\\n                totalETHFee\\n            );\\n            (tmpSuccess, ) = payable(_devAddress).call{\\n                value: amountETHDev,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n\\n        if (_marketingBuyTax + _marketingSellTax > 0) {\\n            uint256 amountETHMarketing = amountETH\\n                .mul(_marketingBuyTax + _marketingSellTax)\\n                .div(totalETHFee);\\n            (tmpSuccess, ) = payable(_marketingAddress).call{\\n                value: amountETHMarketing,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n\\n        if (amountToLiquify > 0) {\\n            address liqAddress = _marketingAddress;\\n            router.addLiquidityETH{value: amountETHLiquidity}(\\n                address(this),\\n                amountToLiquify,\\n                0,\\n                0,\\n                liqAddress,\\n                block.timestamp\\n            );\\n            emit AutoLiquify(amountETHLiquidity, amountToLiquify);\\n        }\\n\\n    }\\n\\n    function shouldTokenSwap(address recipient) internal view returns (bool) {\\n        return ((recipient == pair) &&\\n            !inSwap &&\\n            _balances[address(this)] >= _swapThreshold && tx.origin != owner());\\n    }\\n\\n    function checkLimits(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal view {\\n        if (\\n            !isMaxExempt[recipient] &&\\n            recipient != address(this) &&\\n            sender != address(this) &&\\n            recipient != 0x000000000000000000000000000000000000dEaD &&\\n            recipient != pair &&\\n            recipient != _marketingAddress &&\\n            recipient != _devAddress\\n        ) {\\n            uint256 heldTokens = balanceOf(recipient);\\n            require(\\n                (heldTokens + amount) <= _maxWalletToken,\\n                \\\"Total Holding is currently limited, you can not buy that much.\\\"\\n            );\\n        }\\n    }\\n\\n    function setMaxWallet(uint256 percent) external onlyOwner {\\n        require(inSwap == false, \\\"Cannot call when in swap\\\");\\n        _maxWalletToken = (_totalSupply * percent) / 1000;\\n        require(\\n            _maxWalletToken >= (_totalSupply / 500),\\n            \\\"Max Wallet must be greater than 0.2%.\\\"\\n        );\\n    }\\n\\n    function setTokenSwapSettings(uint256 percent) external onlyOwner {\\n        require(inSwap == false, \\\"Cannot call when in swap\\\");\\n        _swapThreshold = (_totalSupply * percent) / 1000;\\n        require(\\n            _swapThreshold <= (_totalSupply / 20) &&\\n                _swapThreshold >= (_totalSupply / 500),\\n            \\\"Swap Threshold must be less than 5% of total supply, or greater than 0.2%.\\\"\\n        );\\n    }\\n\\n    function aboutMe() external view returns (string memory, string memory) {\\n        return (_telegram, _website);\\n    }\\n\\n    function updateAboutMe(\\n        string memory telegram,\\n        string memory website\\n    ) external onlyOwner {\\n        _telegram = telegram;\\n        _website = website;\\n    }\\n\\n    function setAddresses(\\n        address marketingAddress,\\n        address devAddress\\n    ) external onlyOwner {\\n        require(inSwap == false, \\\"Cannot call when in swap\\\");\\n        if (marketingAddress != address(0)) {\\n            _marketingAddress = marketingAddress;\\n        }\\n        if (devAddress != address(0)) {\\n            _devAddress = devAddress;\\n        }\\n\\n        require(\\n            _devAddress != address(0) && _marketingAddress != address(0),\\n            \\\"Reciever wallets can't be Zero address.\\\"\\n        );\\n    }\\n\\n    function setFeeExemption(address user, bool status) external onlyOwner {\\n        isFeeExempt[user] = status;\\n    }\\n    function setMaxExemption(address user, bool status) external onlyOwner {\\n        isMaxExempt[user] = status;\\n    }\\n\\n    function clearStuckBalance() external onlyOwner {\\n        require(inSwap == false, \\\"Cannot call when in swap\\\");\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"OCopy.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_intData\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCoin\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquiditySellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aboutMe\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceHugCaptain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setFeeExemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setMaxExemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingBuyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingSellPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devBuyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devSellPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityBuyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquiditySellPercent\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setTokenSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"website\",\"type\":\"string\"}],\"name\":\"updateAboutMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GalaxyToken", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000002540be400000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}