{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Gateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Escrow.sol\\\";\\nimport \\\"./Dispute.sol\\\";\\nimport \\\"./Agent.sol\\\";\\nimport \\\"./interfaces/IGateway.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Gateway is Ownable, Escrow, Dispute, Agent, IGateway {\\n    // External token address, should be able to reset this by an owner\\n    address public token;\\n\\n    mapping(uint256 => address[]) public reviewers;\\n    mapping(uint256 => address[]) public pickedAgents;\\n\\n    constructor(address _token) {\\n        require(\\n            _token != address(0),\\n            \\\"Invalid Token Address\\\"\\n        );\\n        token = _token;\\n    }\\n    \\n    function resetTokenAddress(address _newTokenAddress) external onlyOwner {\\n        require(\\n            _newTokenAddress != address(0) && _newTokenAddress != address(this),\\n            \\\"Invalid Token Address\\\"\\n        );\\n        token = _newTokenAddress;\\n    }\\n\\n    /* \\n    * @param _escrowDisputableTime (Epoch time in seconds) - After this time, a customer can make a dispute case\\n    * @param _escrowWithdrawableTime (Epoch time in seconds) - After this time, a merchant can withdraw funds from an escrow contract\\n    */\\n    function purchase(\\n        uint256 _productId,\\n        address _merchantAddress,\\n        uint256 _amount,\\n        uint256 _escrowDisputableTime,\\n        uint256 _escrowWithdrawableTime\\n    ) public {\\n        _purchase(\\n            token,\\n            _msgSender(),\\n            _productId,\\n            _merchantAddress,\\n            _amount,\\n            _escrowDisputableTime,\\n            _escrowWithdrawableTime\\n        );\\n    }\\n\\n    function withdraw(uint256 _escrowId) public {\\n        _withdraw(token, _msgSender(), _escrowId);\\n    }\\n\\n    function startDispute(uint256 _escrowId) public {\\n        require(\\n            escrows[_escrowId].status == DEFAULT,\\n            \\\"Escrow status must be on the DEFAULT status\\\"\\n        );\\n        require(\\n            _msgSender() == escrows[_escrowId].buyerAddress,\\n            \\\"Caller is not buyer\\\"\\n        );\\n        require(\\n            escrows[_escrowId].escrowDisputableTime <= block.timestamp,\\n            \\\"Please wait until the disputable time\\\"\\n        );\\n        require(\\n            escrows[_escrowId].escrowWithdrawableTime >= block.timestamp,\\n            \\\"Disputable time was passed already\\\"\\n        );\\n\\n        escrows[_escrowId].status = DISPUTE;\\n        _dispute(_msgSender(), _escrowId);\\n    }\\n\\n    // Call this function to get credits as an Agent, should call approve function of Token contract before calling this function\\n    function participate() external {\\n        Agent memory agent = agents[_msgSender()];\\n        require(\\n            agent.status == 0 || // not exists\\n                agent.status == _LOST || // Agent submitted and lost\\n                    agent.status == _INIT, // Agent submitted and won\\n            \\\"Wrong status\\\"\\n        );\\n        require(\\n            TransferHelper.balanceOf(token, _msgSender()) >=\\n                agentPaticipateAmount,\\n            \\\"Not correct amount\\\"\\n        );\\n\\n        if (agent.participationCount != 0 && agent.score < criteriaScore) {\\n            revert(\\n                \\\"Your agent score is too low, so can't participate any more\\\"\\n            );\\n        }\\n\\n        if (agent.participationCount == 0) {\\n            agents[_msgSender()] = Agent(\\n                initialAgentScore,\\n                0,\\n                agentPaticipateAmount,\\n                0,\\n                _WAITING\\n            );\\n        } else {\\n            agents[_msgSender()] = Agent(\\n                agent.score,\\n                agent.participationCount,\\n                agent.accumulatedAmount + agentPaticipateAmount,\\n                0,\\n                _WAITING\\n            );\\n        }\\n        TransferHelper.safeTransferFrom(\\n            token,\\n            _msgSender(),\\n            address(this),\\n            agentPaticipateAmount\\n        );\\n\\n        emit AgentParticipated(_msgSender());\\n    }\\n\\n    function pickDispute(uint256 _disputeId)\\n        external\\n    {\\n        require(\\n            agents[_msgSender()].status == _WAITING,\\n            \\\"Agent is not in waiting state\\\"\\n        );\\n        require(\\n            agents[_msgSender()].score >= criteriaScore,\\n            \\\"Low agent score\\\"\\n        );\\n        require(disputes[_disputeId].escrowId != 0, \\\"Invalid dispute id\\\");\\n         require(disputes[_disputeId].applied_agents_count < disputeReviewGroupCount ||\\n            (disputes[_disputeId].createdAt + maxReviewDelay) < block.timestamp, \\\"max applied agents exceed\\\");\\n        require(\\n            disputes[_disputeId].status == INIT ||\\n                disputes[_disputeId].status == WAITING ||\\n                disputes[_disputeId].status == REVIEW,\\n            \\\"Dispute is not in init nor in waiting status\\\"\\n        );\\n        pickedAgents[_disputeId].push(_msgSender());\\n        disputes[_disputeId].status = REVIEW;\\n        agents[_msgSender()].status = REVIEW;\\n        agents[_msgSender()].assignedDisputeId = _disputeId;\\n        disputes[_disputeId].applied_agents_count +=1;\\n        emit AssignAgent(_msgSender(), _disputeId);\\n    }\\n\\n    function _setAgent(\\n        Agent storage agent,\\n        uint256 status,\\n        uint256 score,\\n        uint256 assignedDisputeId\\n    ) internal {\\n        agent.status = status;\\n        if (status == _LOST) \\n            agent.score -= score;\\n        else \\n            agent.score += score;\\n        agent.assignedDisputeId = assignedDisputeId;\\n    }\\n\\n    function _setDispute(\\n        Dispute storage dispute,\\n        uint256 status\\n    ) internal {\\n        dispute.status = status;\\n        if(status == FAIL){\\n            dispute.disapprovedCount += 1;\\n        }else if(status == WIN){\\n            dispute.approvedCount += 1;\\n        }else if( status == INIT){\\n            dispute.approvedCount = 0;\\n            dispute.disapprovedCount = 0;\\n        }\\n        dispute.updatedAt = block.timestamp;\\n    }\\n\\n    // Need to have MTO transfered beforehand\\n    function submit(uint256 _disputeId, uint256 _decision) external {\\n        Dispute storage dispute = disputes[_disputeId];\\n        Agent storage agent;\\n        require(\\n            agents[_msgSender()].score >= criteriaScore,\\n            \\\"Too low score as an Agent\\\"\\n        );        \\n        require(\\n            agents[_msgSender()].status == _REVIEW,\\n            \\\"Agent status should be review\\\"\\n        );\\n        require(\\n            agents[_msgSender()].assignedDisputeId == _disputeId,\\n            \\\"disputeID is not assigned\\\"\\n        );\\n        require(\\n            disputes[agents[_msgSender()].assignedDisputeId].escrowId != 0,\\n            \\\"DisputeID is not valid\\\"\\n        );\\n        require(\\n            _decision == _APPROVED || _decision == _DISAPPROVED,\\n            \\\"Invalid decision value\\\"\\n        );\\n\\n        agents[_msgSender()].participationCount += 1;\\n        if (\\n            _decision == _APPROVED &&\\n            dispute.approvedCount + 1 >= disputeReviewConsensusCount\\n        ) {\\n            _setAgent(agents[_msgSender()], _EARNED, scoreUp, 0);\\n\\n            _setDispute(dispute, WIN);\\n            emit DisputeApproved(_disputeId);\\n\\n            escrows[dispute.escrowId].status = REFUNDED; // REFUNDABLE; In case not returing the funds back to a customer in this function\\n            // Transfer the funds to a customer for chargeback as a dipsute case got approved\\n            TransferHelper.safeTransfer(\\n                token,\\n                escrows[dispute.escrowId].buyerAddress,\\n                escrows[dispute.escrowId].amount\\n            );\\n            emit Refunded(\\n                escrows[dispute.escrowId].buyerAddress,\\n                dispute.escrowId,\\n                escrows[dispute.escrowId].amount\\n            );\\n\\n            for (uint256 i = 0; i < reviewers[_disputeId].length; i++) {\\n                agent = agents[reviewers[_disputeId][i]];\\n                if (agent.status == _APPROVED) {\\n                    _setAgent(agent, _EARNED, scoreUp, 0);\\n                } else if (agent.status == _DISAPPROVED) {\\n                    _setAgent(agent, _LOST, scoreDown, 0);\\n                }\\n            }\\n            for (uint256 i = 0; i < pickedAgents[_disputeId].length; i++) {\\n                agent = agents[pickedAgents[_disputeId][i]];\\n                _setAgent(agent, _WAITING, 0, 0);\\n            }\\n\\n        } else if (\\n            _decision == _DISAPPROVED &&\\n            dispute.disapprovedCount + 1 >= disputeReviewConsensusCount\\n        ) {\\n            _setAgent(agents[_msgSender()], _EARNED, scoreUp, 0);\\n            _setDispute(dispute, FAIL);\\n            emit DisputeDisapproved(_disputeId);\\n\\n            escrows[dispute.escrowId].status = COMPLETED; // DEFAULT; In case not returing the funds to a merchant in this function\\n\\n            for (uint256 i = 0; i < reviewers[_disputeId].length; i++) {\\n                agent = agents[reviewers[_disputeId][i]];\\n                if (agent.status == _DISAPPROVED) {\\n                    _setAgent(agent, _EARNED, scoreUp, 0);\\n                } else if (agent.status == _APPROVED) {\\n                    _setAgent(agent, _LOST, scoreDown, 0);\\n                }\\n            }\\n            for (uint256 i = 0; i < pickedAgents[_disputeId].length; i++) {\\n                agent = agents[pickedAgents[_disputeId][i]];\\n                _setAgent(agent, _WAITING, 0, 0);\\n            }\\n            // Transfer the funds to a merchant for selling the product as a dipsute case(by a customer) got disapproved\\n            TransferHelper.safeTransfer(\\n                token,\\n                escrows[dispute.escrowId].merchantAddress,\\n                escrows[dispute.escrowId].amount\\n            );\\n            emit Withdraw(\\n                escrows[dispute.escrowId].merchantAddress,\\n                dispute.escrowId,\\n                escrows[dispute.escrowId].amount\\n            );\\n        } else if (\\n            _decision == _APPROVED &&\\n            dispute.approvedCount + 1 < disputeReviewConsensusCount &&\\n            (dispute.approvedCount + dispute.disapprovedCount + 1) >=\\n            disputeReviewGroupCount\\n        ) {\\n            _setAgent(agents[_msgSender()], _LOST, scoreDown, 0);\\n            _setDispute(dispute, INIT);\\n\\n            for (uint256 i = 0; i < reviewers[_disputeId].length; i++) {\\n                _setAgent(\\n                    agents[reviewers[_disputeId][i]],\\n                    _LOST,\\n                    scoreDown,\\n                    0\\n                );\\n            }\\n            for (uint256 i = 0; i < pickedAgents[_disputeId].length; i++) {                \\n                _setAgent(agents[pickedAgents[_disputeId][i]], _WAITING, 0, 0);\\n            }\\n        } else if (\\n            _decision == _DISAPPROVED &&\\n            dispute.disapprovedCount + 1 < disputeReviewConsensusCount &&\\n            (dispute.approvedCount + dispute.disapprovedCount + 1) >=\\n            disputeReviewGroupCount\\n        ) {\\n            _setAgent(agents[_msgSender()], _LOST, scoreDown, 0);\\n            _setDispute(dispute, INIT);\\n            for (uint256 i = 0; i < reviewers[_disputeId].length; i++) {\\n                _setAgent(\\n                    agents[reviewers[_disputeId][i]],\\n                    _LOST,\\n                    scoreDown,\\n                    0\\n                );\\n            }\\n            for (uint256 i = 0; i < pickedAgents[_disputeId].length; i++) {                \\n                _setAgent(agents[pickedAgents[_disputeId][i]], _WAITING, 0, 0);\\n            }\\n        } else {            \\n            _setAgent(agents[_msgSender()], _decision, 0, 0);\\n\\n            _removeFromPickedAgents(_disputeId, _msgSender());\\n            reviewers[_disputeId].push(_msgSender());\\n\\n            dispute.status = WAITING;\\n            dispute.updatedAt = block.timestamp;\\n\\n            if (_decision == _APPROVED) dispute.approvedCount += 1;\\n            else if (_decision == _DISAPPROVED) dispute.disapprovedCount += 1;\\n        }\\n\\n        if (\\n            agents[_msgSender()].score < criteriaScore &&\\n            agents[_msgSender()].status != _BAN\\n        ) {\\n            agents[_msgSender()].status = _BAN;\\n        }\\n\\n        emit SubmittedDispute(_msgSender(), _disputeId, _decision);\\n    }\\n\\n    function agentWithdraw() external {\\n        require(\\n            agents[_msgSender()].status == _EARNED,\\n            \\\"Cannot withdraw unearned tokens\\\"\\n        );\\n\\n        agents[_msgSender()].status = _INIT;\\n        TransferHelper.safeTransfer(token, _msgSender(), disputeBonusAmount);\\n\\n        emit AgentWithdraw(_msgSender(), disputeBonusAmount);\\n    }\\n\\n    function adminWithdrawToken(uint256 _amount) external onlyOwner {\\n        require(\\n            TransferHelper.balanceOf(token, address(this)) > _amount,\\n            \\\"Not enough balance\\\"\\n        );\\n        TransferHelper.safeTransfer(token, _msgSender(), _amount);\\n    }\\n\\n    function getMerchantReputation(address _merchantAddress)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(_merchantAddress != address(0), \\\"Invalid Merchant Address\\\");\\n\\n        if (currentEscrowId == 0) {\\n            return 0;\\n        }\\n\\n        uint256 Es = 0; //total number of escrow for merchant address\\n        uint256 Ds = 0; //total win dispute againts merchant address\\n        uint256 Er = 0; //(escrow success ratio) = (Es - Ds)/Es\\n\\n        uint256 Esa = 0; //total escrowed amount\\n        uint256 Dsa = 0; //total disputed amount\\n        uint256 Ar = 0; // (Amount ratio) = (Esa - Dsa) / Esa\\n\\n        for (uint256 i = 1; i <= currentEscrowId; i++) {\\n            if (\\n                escrows[i].merchantAddress == _merchantAddress &&\\n                escrows[i].status != DISPUTE\\n            ) {\\n                if (\\n                    escrows[i].status != DEFAULT ||\\n                    escrows[i].escrowWithdrawableTime < block.timestamp\\n                ) {\\n                    Es = Es + 1;\\n                    Esa = Esa + escrows[i].amount;\\n\\n                    if (\\n                        escrows[i].status == REFUNDABLE ||\\n                        escrows[i].status == REFUNDED\\n                    ) {\\n                        Ds = Ds + 1;\\n                        Dsa = Dsa + escrows[i].amount;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (Es == 0) {\\n            return 0;\\n        }\\n\\n        Er = ((60 * (Es - Ds)) / Es); //60 percent reputation for successful escrows\\n        Ar = ((40 * (Esa - Dsa)) / Esa); ////60 percent reputation for successful escrows Amount\\n        uint256 total = Er + Ar;\\n        return total;\\n    }\\n\\n    function applyADM(uint256 _disputeId, uint256 _decision)\\n        external\\n        onlyOwner\\n    {\\n        Dispute storage dispute = disputes[_disputeId];\\n        Escrow storage escrow = escrows[dispute.escrowId];\\n        require(dispute.status == INIT, \\\"Dispute is not in init state\\\");\\n        require(\\n            _decision == _APPROVED || _decision == _DISAPPROVED,\\n            \\\"Invalid decision value\\\"\\n        );\\n        //APPROVE\\n        if (_decision == _APPROVED) {\\n            dispute.status = WIN;\\n            dispute.updatedAt = block.timestamp;\\n            emit DisputeApproved(_disputeId);\\n\\n            escrow.status = REFUNDED;\\n            TransferHelper.safeTransfer(\\n                token,\\n                escrow.buyerAddress,\\n                escrow.amount\\n            );\\n            emit Refunded(escrow.buyerAddress, dispute.escrowId, escrow.amount);\\n        } else {\\n            //FAIL\\n            dispute.status = FAIL;\\n            dispute.updatedAt = block.timestamp;\\n            emit DisputeDisapproved(_disputeId);\\n\\n            escrow.status = COMPLETED;\\n\\n            TransferHelper.safeTransfer(\\n                token,\\n                escrow.merchantAddress,\\n                escrow.amount\\n            );\\n\\n            emit Withdraw(\\n                escrow.merchantAddress,\\n                dispute.escrowId,\\n                escrow.amount\\n            );\\n        }\\n    }\\n\\n    // TODO 1: fee, 2: reset global variables 3: auto assign system\\n\\n    function _removeFromPickedAgents(uint256 disputeId, address agent) internal {\\n        address[] storage agents = pickedAgents[disputeId];\\n        uint i = _findIndex(agents, agent);\\n        _removeByIndex(agents, i);\\n    }\\n\\n    function _removeByIndex(address[] storage agents, uint index) internal {\\n        if (index >= agents.length) return;\\n\\n        agents[index] = agents[agents.length - 1];\\n        agents.pop();\\n    }\\n\\n    function _findIndex(address[] storage agents, address submitter) internal view returns(uint) {\\n        uint i = 0;\\n        while (agents[i] != submitter) {\\n            i++;\\n        }\\n        return i;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Escrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"./interfaces/IEscrow.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\nabstract contract Escrow is IEscrow {\\n    // Escrow Status\\n    uint256 public currentEscrowId;\\n    uint8 constant DEFAULT = 1;\\n    uint8 constant DISPUTE = 2;\\n    uint8 constant REFUNDABLE = 3;\\n    uint8 constant COMPLETED = 4;\\n    uint8 constant REFUNDED = 5;\\n\\n    mapping(uint256 => Escrow) public escrows;\\n\\n    // _escrowDisputableTime(Epoch time in seconds) - After this time, a customer can make a dispute case\\n    // _escrowWithdrawableTime(Epoch time in seconds) - After this time, a merchant can withdraw funds from an escrow contract\\n    function _purchase(\\n        address _token,\\n        address _currentCaller,\\n        uint256 _productId,\\n        address _merchantAddress,\\n        uint256 _amount,\\n        uint256 _escrowDisputableTime,\\n        uint256 _escrowWithdrawableTime\\n    ) internal {\\n        require(_merchantAddress != address(0), \\\"Invalid Merchant Address\\\");\\n        require(_amount > 0, \\\"Amount should be bigger than zero\\\");\\n        require(\\n            TransferHelper.balanceOf(_token, _currentCaller) >= _amount,\\n            \\\"You don't have enough token amount\\\"\\n        );\\n        require(\\n            TransferHelper.allowance(_token, _currentCaller, address(this)) >=\\n                _amount,\\n            \\\"You should approve token transfer to this contract first\\\"\\n        );\\n        require(\\n            _escrowDisputableTime > block.timestamp,\\n            \\\"Disputable time should be later than current time\\\"\\n        );\\n        require(\\n            _escrowWithdrawableTime > _escrowDisputableTime,\\n            \\\"Withdraw Time should be later than Disputable time\\\"\\n        );\\n\\n        escrows[currentEscrowId + 1] = Escrow(\\n            _productId,\\n            _currentCaller,\\n            _merchantAddress,\\n            _amount,\\n            _escrowWithdrawableTime,\\n            _escrowDisputableTime,\\n            DEFAULT,\\n            block.timestamp\\n        );\\n        currentEscrowId = currentEscrowId + 1;\\n        TransferHelper.safeTransferFrom(\\n            _token,\\n            _currentCaller,\\n            address(this),\\n            _amount\\n        );\\n        emit Escrowed(_currentCaller, _productId, _amount, currentEscrowId);\\n    }\\n    function _withdraw(\\n        address _token,\\n        address _currentCaller,\\n        uint256 _escrowId\\n    ) public {\\n        require(\\n            escrows[_escrowId].status == DEFAULT ||\\n                escrows[_escrowId].status == REFUNDABLE,\\n            \\\"Invalid Status\\\"\\n        );\\n        require(\\n            block.timestamp > escrows[_escrowId].escrowWithdrawableTime,\\n            \\\"Escrowd time has not passed yet\\\"\\n        );\\n        require(\\n            _currentCaller == escrows[_escrowId].buyerAddress ||\\n                _currentCaller == escrows[_escrowId].merchantAddress,\\n            \\\"Caller is neither Buyer nor Merchant\\\"\\n        );\\n        /*\\n        require(\\n            TransferHelper.balanceOf(_token, address(this)) >=\\n                escrows[_escrowId].amount,\\n            \\\"Contract doesn't have enough funds\\\"\\n        );\\n        */\\n        if (\\n            escrows[_escrowId].status == DEFAULT &&\\n            escrows[_escrowId].buyerAddress == _currentCaller\\n        ) {\\n            revert(\\\"Buyer cannot withdraw in default status\\\");\\n        }\\n        if (\\n            escrows[_escrowId].status == REFUNDABLE &&\\n            escrows[_escrowId].merchantAddress == _currentCaller\\n        ) {\\n            revert(\\\"Merchant cannot withdraw in refund status\\\");\\n        }\\n        if (\\n            escrows[_escrowId].status == REFUNDABLE &&\\n            escrows[_escrowId].buyerAddress == _currentCaller\\n        ) {\\n            // Transfers tokens to buyer\\n            TransferHelper.safeTransfer(\\n                _token,\\n                escrows[_escrowId].buyerAddress,\\n                escrows[_escrowId].amount\\n            );\\n            // Update the escrow status as REFUNDED\\n            escrows[_escrowId].status = REFUNDED;\\n            // emit Withdraw(_currentCaller, _escrowId, escrows[_escrowId].amount);\\n            emit Refunded(_currentCaller, _escrowId, escrows[_escrowId].amount);\\n        } else if (\\n            escrows[_escrowId].status == DEFAULT &&\\n            escrows[_escrowId].merchantAddress == _currentCaller\\n        ) {\\n            // Update the escrow status as COMPLETED\\n            escrows[_escrowId].status = COMPLETED;\\n            // Transfers tokens to merchant\\n            TransferHelper.safeTransfer(\\n                _token,\\n                escrows[_escrowId].merchantAddress,\\n                escrows[_escrowId].amount\\n            );\\n            emit Withdraw(_currentCaller, _escrowId, escrows[_escrowId].amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dispute.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"./interfaces/IDispute.sol\\\";\\nimport \\\"./interfaces/IEscrow.sol\\\";\\n\\nabstract contract Dispute is IDispute {\\n    // Dispute Status\\n    uint256 public currentDisputeId;\\n    uint8 constant INIT = 1;\\n    uint8 constant WAITING = 2;\\n    uint8 constant REVIEW = 3;\\n    uint8 constant WIN = 4;\\n    uint8 constant FAIL = 5;\\n\\n    mapping(uint256 => Dispute) public disputes;\\n\\n    function _dispute(address msgSender, uint256 _escrowId) internal {\\n        disputes[currentDisputeId + 1] = Dispute(\\n            _escrowId,\\n            0, // approvedCount\\n            0, // disapprovedCount\\n            INIT,// status\\n            0, // applied_agents_count\\n            block.timestamp,\\n            block.timestamp\\n        );\\n        currentDisputeId = currentDisputeId + 1;\\n        emit Disputed(msgSender, currentDisputeId, _escrowId);\\n    }\\n\\n    function _setDispute(\\n        Dispute storage dispute,\\n        uint8 status,\\n        uint256 approvedCount,\\n        uint256 updatedAt\\n    ) internal {\\n        dispute.status = status;\\n        dispute.approvedCount += approvedCount;\\n        dispute.updatedAt = updatedAt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Agent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IAgent.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Agent is IAgent, Ownable {\\n    // Agent related params, should be able to reset this by an owner\\n    uint256 public initialAgentScore = 100;\\n    uint256 public criteriaScore = 70;\\n    uint256 public disputeBonusAmount = 10 * (10**18);\\n    uint256 public scoreUp = 10;\\n    uint256 public scoreDown = 10;\\n    uint256 public disputeReviewGroupCount = 5;//  maximum required agent to resolve a dispute\\n    uint256 public disputeReviewConsensusCount = 3;\\n    uint256 public agentPaticipateAmount = 5 * (10**18);\\n    uint public maxReviewDelay = 20 seconds; // maximum period to resolve a dispute\\n    // Agent Status\\n    uint256 constant _INIT = 1;\\n    uint256 constant _WAITING = 2;\\n    uint256 constant _REVIEW = 3;\\n    uint256 constant _APPROVED = 4;\\n    uint256 constant _DISAPPROVED = 5;\\n    uint256 constant _EARNED = 6;\\n    uint256 constant _LOST = 7;\\n    uint256 constant _BAN = 8;\\n\\n    mapping(address => Agent) public agents;\\n\\n    function resetInitialAgentScore(uint256 _newInitialAgentScore)\\n        external\\n        onlyOwner\\n    {\\n        require(_newInitialAgentScore > 0, \\\"Invalid value\\\");\\n        initialAgentScore = _newInitialAgentScore;\\n    }\\n    function resetMaxReviewDelay(uint256 newMaxReviewDelay) external onlyOwner{\\n        require(newMaxReviewDelay > 0, \\\"Invalid value\\\");\\n        maxReviewDelay = newMaxReviewDelay;\\n    }\\n    function resetCriteriaScore(uint256 _newCriteriaScore) external onlyOwner {\\n        require(_newCriteriaScore >= 0, \\\"Invalid value\\\");\\n        criteriaScore = _newCriteriaScore;\\n    }\\n\\n    function resetDisputeBonusAmount(uint256 _newDisputeBonusAmount)\\n        external\\n        onlyOwner\\n    {\\n        require(_newDisputeBonusAmount >= 0, \\\"Invalid value\\\");\\n        disputeBonusAmount = _newDisputeBonusAmount * (10**18);\\n    }\\n\\n    function resetScoreUp(uint256 _newScoreUp) external onlyOwner {\\n        require(_newScoreUp >= 0, \\\"Invalid value\\\");\\n        scoreUp = _newScoreUp;\\n    }\\n\\n    function resetScoreDown(uint256 _newScoreDown) external onlyOwner {\\n        require(_newScoreDown >= 0, \\\"Invalid value\\\");\\n        scoreDown = _newScoreDown;\\n    }\\n\\n    function resetDisputeReviewGroupCount(uint256 _newDisputeReviewGroupCount)\\n        external\\n        onlyOwner\\n    {\\n        require(_newDisputeReviewGroupCount > 0, \\\"Invalid value\\\");\\n        require(\\n            _newDisputeReviewGroupCount >= disputeReviewConsensusCount,\\n            \\\"Should be larger number than the Consensus count\\\"\\n        );\\n        disputeReviewGroupCount = _newDisputeReviewGroupCount;\\n    }\\n\\n    function resetDisputeReviewConsensusCount(\\n        uint256 _newDisputeReviewConsensusCount\\n    ) external onlyOwner {\\n        require(_newDisputeReviewConsensusCount > 0, \\\"Invalid value\\\");\\n        require(\\n            _newDisputeReviewConsensusCount <= disputeReviewGroupCount,\\n            \\\"Should be smaller number than the Group count\\\"\\n        );\\n        disputeReviewConsensusCount = _newDisputeReviewConsensusCount;\\n    }\\n\\n    function resetAgentPaticipateAmount(uint256 _newAgentPaticipateAmount)\\n        external\\n        onlyOwner\\n    {\\n        require(_newAgentPaticipateAmount > 0, \\\"Invalid value\\\");\\n        agentPaticipateAmount = _newAgentPaticipateAmount * (10**18);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IGateway {}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n\\n    function allowance(\\n        address token,\\n        address owner,\\n        address spender\\n    ) internal view returns (uint256) {\\n        return IERC20(token).allowance(owner, spender);\\n    }\\n\\n    function balanceOf(address token, address account)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return IERC20(token).balanceOf(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IEscrow {\\n    struct Escrow {\\n        uint256 productId;\\n        address buyerAddress;\\n        address merchantAddress;\\n        uint256 amount;\\n        uint256 escrowWithdrawableTime;\\n        uint256 escrowDisputableTime;\\n        uint256 status;\\n        uint256 createdAt;\\n    }\\n    event Escrowed(\\n        address indexed _from,\\n        uint256 indexed _productID,\\n        uint256 _amount,\\n        uint256 indexed _escrowId\\n    );\\n    event Withdraw(\\n        address indexed _withdrawer,\\n        uint256 indexed _escrowId,\\n        uint256 _amount\\n    );\\n    event Refunded(\\n        address indexed _withdrawer,\\n        uint256 indexed _escrowId,\\n        uint256 _amount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDispute.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IDispute {\\n    struct Dispute {\\n        uint256 escrowId;\\n        uint256 approvedCount; // (default: 0)\\n        uint256 disapprovedCount; // (default: 0)\\n        uint256 status; // (default: 0)  1: init, 2: waiting, 3: review, 4: win, 4: fail\\n        uint256 applied_agents_count;\\n        uint256 createdAt;\\n        uint256 updatedAt;\\n    }\\n    event Disputed(\\n        address indexed _from,\\n        uint256 indexed _disputeId,\\n        uint256 indexed _escrowId\\n    );\\n    event SubmittedDispute(\\n        address indexed _agentAddress,\\n        uint256 indexed _disputeId,\\n        uint256 indexed _decision\\n    );\\n\\n    event DisputeApproved(uint256 indexed _disputeId);\\n    event DisputeDisapproved(uint256 indexed _disputeId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAgent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IAgent {\\n    struct Agent {\\n        uint256 score; // (default: initial_agent_score)\\n        uint256 participationCount;\\n        uint256 accumulatedAmount;\\n        uint256 assignedDisputeId;\\n        uint256 status;\\n    }\\n    event AgentParticipated(address indexed _agentAddress);\\n    event AssignAgent(\\n        address indexed _agentAddress,\\n        uint256 indexed _disputeId\\n    );\\n    event AgentWithdraw(address indexed _withdrawer, uint256 _amount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"AgentParticipated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AgentWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"AssignAgent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"DisputeApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"DisputeDisapproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"Disputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_productID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"Escrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_decision\",\"type\":\"uint256\"}],\"name\":\"SubmittedDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currentCaller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"_withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adminWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"agentPaticipateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"agentWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"agents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"participationCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assignedDisputeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decision\",\"type\":\"uint256\"}],\"name\":\"applyADM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"criteriaScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDisputeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEscrowId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeBonusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeReviewConsensusCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeReviewGroupCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disapprovedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"applied_agents_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"productId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"merchantAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"escrowWithdrawableTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"escrowDisputableTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchantAddress\",\"type\":\"address\"}],\"name\":\"getMerchantReputation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialAgentScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxReviewDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"participate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"pickDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pickedAgents\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_productId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_merchantAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_escrowDisputableTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_escrowWithdrawableTime\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAgentPaticipateAmount\",\"type\":\"uint256\"}],\"name\":\"resetAgentPaticipateAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCriteriaScore\",\"type\":\"uint256\"}],\"name\":\"resetCriteriaScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDisputeBonusAmount\",\"type\":\"uint256\"}],\"name\":\"resetDisputeBonusAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDisputeReviewConsensusCount\",\"type\":\"uint256\"}],\"name\":\"resetDisputeReviewConsensusCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDisputeReviewGroupCount\",\"type\":\"uint256\"}],\"name\":\"resetDisputeReviewGroupCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newInitialAgentScore\",\"type\":\"uint256\"}],\"name\":\"resetInitialAgentScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxReviewDelay\",\"type\":\"uint256\"}],\"name\":\"resetMaxReviewDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newScoreDown\",\"type\":\"uint256\"}],\"name\":\"resetScoreDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newScoreUp\",\"type\":\"uint256\"}],\"name\":\"resetScoreUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAddress\",\"type\":\"address\"}],\"name\":\"resetTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reviewers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scoreDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scoreUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"startDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decision\",\"type\":\"uint256\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Gateway", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000e66b3aa360bb78468c00bebe163630269db3324f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}