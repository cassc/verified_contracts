{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BalanceScanner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\n/**\\n * @title An Ether or token balance scanner\\n * @author Maarten Zuidhoorn\\n * @author Luit Hollander\\n */\\ncontract BalanceScanner {\\n  struct Result {\\n    bool success;\\n    bytes data;\\n  }\\n\\n  /**\\n   * @notice Get the Ether balance for all addresses specified\\n   * @param addresses The addresses to get the Ether balance for\\n   * @return results The Ether balance for all addresses in the same order as specified\\n   */\\n  function etherBalances(address[] calldata addresses) external view returns (Result[] memory results) {\\n    results = new Result[](addresses.length);\\n\\n    for (uint256 i = 0; i < addresses.length; i++) {\\n      results[i] = Result(true, abi.encode(addresses[i].balance));\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC-20 token balance of `token` for all addresses specified\\n   * @dev This does not check if the `token` address specified is actually an ERC-20 token\\n   * @param addresses The addresses to get the token balance for\\n   * @param token The address of the ERC-20 token contract\\n   * @return results The token balance for all addresses in the same order as specified\\n   */\\n  function tokenBalances(address[] calldata addresses, address token) external view returns (Result[] memory results) {\\n    results = new Result[](addresses.length);\\n\\n    for (uint256 i = 0; i < addresses.length; i++) {\\n      bytes memory data = abi.encodeWithSignature(\\\"balanceOf(address)\\\", addresses[i]);\\n      results[i] = staticCall(token, data, 20000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC-20 token balance from multiple contracts for a single owner\\n   * @param owner The address of the token owner\\n   * @param contracts The addresses of the ERC-20 token contracts\\n   * @return results The token balances in the same order as the addresses specified\\n   */\\n  function tokensBalance(address owner, address[] calldata contracts) external view returns (Result[] memory results) {\\n    results = new Result[](contracts.length);\\n\\n    bytes memory data = abi.encodeWithSignature(\\\"balanceOf(address)\\\", owner);\\n    for (uint256 i = 0; i < contracts.length; i++) {\\n      results[i] = staticCall(contracts[i], data, 20000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC-20 allowances for one contract and multiple spenders for a single owner\\n   * @param owner The address of the token owner\\n   * @param _contract The address of the ERC-20 token contract\\n   * @param spenders The spenders to query allowances to spend owner's funds for in the specified ERC-20 token contract\\n   * @return results The erc20 allowances in the same order as the spender addresses specified\\n   */\\n  function spendersAllowances(\\n    address owner,\\n    address _contract,\\n    address[] calldata spenders\\n  ) public view returns (Result[] memory results) {\\n    results = new Result[](spenders.length);\\n\\n    for (uint256 i = 0; i < spenders.length; i++) {\\n      bytes memory data = abi.encodeWithSignature(\\\"allowance(address,address)\\\", owner, spenders[i]);\\n      results[i] = staticCall(_contract, data, 20000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC721 owner addresses for multiple tokenIds from a single contractAddress\\n   * @param token The address of the contract\\n   * @param tokenIds The tokenIds we want to fetch owner for\\n   * @return results The list of owner addresses of each tokenId\\n   */\\n  function ownersOfTokenIdsForToken(address token, uint256[] calldata tokenIds)\\n    public\\n    view\\n    returns (Result[] memory results)\\n  {\\n    results = new Result[](tokenIds.length);\\n\\n    for (uint256 i = 0; i < tokenIds.length; i++) {\\n      bytes memory data = abi.encodeWithSignature(\\\"ownerOf(uint256)\\\", tokenIds[i]);\\n      results[i] = staticCall(token, data, 20000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC721 token URI for multiple tokenIds from a single contractAddress\\n   * @param token The address of the contract\\n   * @param tokenIds The tokenIds we want to fetch owner for\\n   * @return results The list of owner addresses of each tokenId\\n   */\\n  function tokenURIsOfTokenIdsForToken(address token, uint256[] calldata tokenIds)\\n    public\\n    view\\n    returns (Result[] memory results)\\n  {\\n    results = new Result[](tokenIds.length);\\n\\n    for (uint256 i = 0; i < tokenIds.length; i++) {\\n      bytes memory data = abi.encodeWithSignature(\\\"tokenURI(uint256)\\\", tokenIds[i]);\\n      results[i] = staticCallStringify(token, data, 1000000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC721 owner addresses for multiple tokenIds from multiple contractAddresses\\n   * @param contracts The array of contract addresses to fetch owners of tokenId from\\n   * @param tokenIds The 2D array of tokenIds to fetch owners for\\n   * @return results The list of owner addresses of each tokenId and contractAddress\\n   */\\n\\n  function ownersOfTokenIdsForTokens(address[] calldata contracts, uint256[][] calldata tokenIds)\\n    external\\n    view\\n    returns (Result[][] memory results)\\n  {\\n    require(contracts.length == tokenIds.length, \\\"Contracts and tokenIds array length mismatch\\\");\\n\\n    results = new Result[][](contracts.length);\\n    for (uint256 i = 0; i < contracts.length; i++) {\\n      results[i] = ownersOfTokenIdsForToken(contracts[i], tokenIds[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC-20 allowances for multiple contract and multiple spenders for a single owner\\n   * @param owner The address of the token owner\\n   * @param contracts The addresses of the ERC-20 token contracts\\n   * @param spenders The spenders to query allowances to spend owner's funds for in the specified ERC-20 token contract\\n   * @return results The erc20 allowances in the same order as the spender addresses specified\\n   */\\n  function spendersAllowancesForTokens(\\n    address owner,\\n    address[] calldata contracts,\\n    address[][] calldata spenders\\n  ) external view returns (Result[][] memory results) {\\n    require(contracts.length == spenders.length, \\\"Contracts and spenders array length mismatch\\\");\\n\\n    results = new Result[][](contracts.length);\\n    for (uint256 i = 0; i < contracts.length; i++) {\\n      results[i] = spendersAllowances(owner, contracts[i], spenders[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC721 token metadata URIs for multiple tokenIds from multiple contractAddresses\\n   * @param contracts The array of contract addresses to fetch owners of tokenId from\\n   * @param tokenIds The 2D array of tokenIds to fetch owners for\\n   * @return results The list of token metadata URIs of each tokenId and contractAddress\\n   */\\n\\n  function tokenURIsofTokenIdsForTokens(address[] calldata contracts, uint256[][] calldata tokenIds)\\n    external\\n    view\\n    returns (Result[][] memory results)\\n  {\\n    require(contracts.length == tokenIds.length, \\\"Contracts and tokenIds array length mismatch\\\");\\n\\n    results = new Result[][](contracts.length);\\n    for (uint256 i = 0; i < contracts.length; i++) {\\n      results[i] = tokenURIsOfTokenIdsForToken(contracts[i], tokenIds[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get the ERC1155 balance of an accountAddress and tokenId for multiple contractAddress\\n   * @param tokens The array of contract addresses to fetch balances from\\n   * @param accounts The array of account addresses to fetch balances for\\n   * @param tokenIds The array of tokenIds to fetch balances for\\n   * @return results The list of balances of each owner addresses and tokenId\\n   */\\n  function balanceOfAccountAndTokenIdForTokens(\\n    address[] calldata tokens,\\n    address[][] calldata accounts,\\n    uint256[][] calldata tokenIds\\n  ) external view returns (Result[] memory results) {\\n    require(tokens.length == accounts.length && tokens.length == tokenIds.length, \\\"Arrays length mismatch\\\");\\n\\n    results = new Result[](tokens.length);\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      bytes memory data = abi.encodeWithSignature(\\\"balanceOfBatch(address[],uint256[])\\\", accounts[i], tokenIds[i]);\\n\\n      results[i] = staticCall(tokens[i], data, 20000);\\n    }\\n  }\\n\\n  /**\\n   * @notice Call multiple contracts with the provided arbitrary data\\n   * @param contracts The contracts to call\\n   * @param data The data to call the contracts with\\n   * @return results The raw result of the contract calls\\n   */\\n  function call(address[] calldata contracts, bytes[] calldata data) external view returns (Result[] memory results) {\\n    return call(contracts, data, gasleft());\\n  }\\n\\n  /**\\n   * @notice Call multiple contracts with the provided arbitrary data\\n   * @param contracts The contracts to call\\n   * @param data The data to call the contracts with\\n   * @param gas The amount of gas to call the contracts with\\n   * @return results The raw result of the contract calls\\n   */\\n  function call(\\n    address[] calldata contracts,\\n    bytes[] calldata data,\\n    uint256 gas\\n  ) public view returns (Result[] memory results) {\\n    require(contracts.length == data.length, \\\"Length must be equal\\\");\\n    results = new Result[](contracts.length);\\n\\n    for (uint256 i = 0; i < contracts.length; i++) {\\n      results[i] = staticCall(contracts[i], data[i], gas);\\n    }\\n  }\\n\\n  /**\\n   * @notice Static call a contract with the provided data\\n   * @param target The address of the contract to call\\n   * @param data The data to call the contract with\\n   * @param gas The amount of gas to forward to the call\\n   * @return result The result of the contract call\\n   */\\n  function staticCall(\\n    address target,\\n    bytes memory data,\\n    uint256 gas\\n  ) private view returns (Result memory) {\\n    uint256 size = codeSize(target);\\n\\n    if (size > 0) {\\n      (bool success, bytes memory result) = target.staticcall{ gas: gas }(data);\\n      if (success) {\\n        return Result(success, result);\\n      }\\n    }\\n\\n    return Result(false, \\\"\\\");\\n  }\\n\\n  /**\\n   * @notice Static call a contract with the provided data\\n   * @param target The address of the contract to call\\n   * @param data The data to call the contract with\\n   * @param gas The amount of gas to forward to the call\\n   * @return result The result of the contract call\\n   */\\n  function staticCallStringify(\\n    address target,\\n    bytes memory data,\\n    uint256 gas\\n  ) private view returns (Result memory) {\\n    uint256 size = codeSize(target);\\n\\n    if (size > 0) {\\n      string memory decodedResult;\\n      (bool success, bytes memory result) = target.staticcall{ gas: gas }(data);\\n      if (success) {\\n        decodedResult = abi.decode(result, (string));\\n        return Result(success, bytes(decodedResult));\\n      }\\n    }\\n\\n    return Result(false, \\\"\\\");\\n  }\\n\\n  /**\\n   * @notice Get code size of address\\n   * @param _address The address to get code size from\\n   * @return size Unsigned 256-bits integer\\n   */\\n  function codeSize(address _address) private view returns (uint256 size) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(_address)\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"accounts\",\"type\":\"address[][]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"balanceOfAccountAndTokenIdForTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"call\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"call\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"etherBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"ownersOfTokenIdsForToken\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"ownersOfTokenIdsForTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[][]\",\"name\":\"results\",\"type\":\"tuple[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"spenders\",\"type\":\"address[]\"}],\"name\":\"spendersAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"spenders\",\"type\":\"address[][]\"}],\"name\":\"spendersAllowancesForTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[][]\",\"name\":\"results\",\"type\":\"tuple[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"tokenURIsOfTokenIdsForToken\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"tokenURIsofTokenIdsForTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[][]\",\"name\":\"results\",\"type\":\"tuple[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"tokensBalance\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct BalanceScanner.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BalanceScanner", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}