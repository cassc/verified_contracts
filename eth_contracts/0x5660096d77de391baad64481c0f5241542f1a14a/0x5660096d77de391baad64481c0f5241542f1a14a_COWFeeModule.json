{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/COWFeeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport { ISafe } from \\\"./interfaces/ISafe.sol\\\";\\nimport { IGPv2Settlement } from \\\"./interfaces/IGPv2Settlement.sol\\\";\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\nimport { GPv2Order } from \\\"./libraries/GPv2Order.sol\\\";\\n\\ncontract COWFeeModule {\\n    error OnlyKeeper();\\n\\n    // not public to save deployment costs\\n    ISafe public immutable targetSafe;\\n    address public immutable toToken;\\n    address public immutable keeper;\\n    bytes32 public immutable domainSeparator;\\n    bytes32 public immutable appData;\\n    IGPv2Settlement public immutable settlement;\\n    address public immutable vaultRelayer;\\n    address public immutable receiver;\\n\\n    struct Revocation {\\n        address token;\\n        address spender;\\n    }\\n\\n    struct SwapToken {\\n        address token;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n    }\\n\\n    modifier onlyKeeper() {\\n        if (msg.sender != keeper) {\\n            revert OnlyKeeper();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address _settlement,\\n        address _targetSafe,\\n        address _toToken,\\n        address _keeper,\\n        bytes32 _appData,\\n        address _receiver\\n    ) {\\n        settlement = IGPv2Settlement(_settlement);\\n        vaultRelayer = settlement.vaultRelayer();\\n        targetSafe = ISafe(_targetSafe);\\n        toToken = _toToken;\\n        keeper = _keeper;\\n        domainSeparator = settlement.domainSeparator();\\n        appData = _appData;\\n        receiver = _receiver;\\n    }\\n\\n    /// @notice Approve given tokens of settlement contract to vault relayer\\n    function approve(address[] calldata _tokens) external onlyKeeper {\\n        _approve(_tokens);\\n    }\\n\\n    /// @notice Revoke approvals for given tokens to given contracts\\n    function revoke(Revocation[] calldata _revocations) external onlyKeeper {\\n        IGPv2Settlement.InteractionData[] memory revokeInteractions =\\n            new IGPv2Settlement.InteractionData[](_revocations.length);\\n        for (uint256 i = 0; i < _revocations.length;) {\\n            Revocation calldata revocation = _revocations[i];\\n            revokeInteractions[i] = IGPv2Settlement.InteractionData({\\n                to: revocation.token,\\n                value: 0,\\n                callData: abi.encodeCall(IERC20.approve, (revocation.spender, 0))\\n            });\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        _execInteractions(revokeInteractions);\\n    }\\n\\n    /// @notice Commit presignatures for sell orders of given tokens of given amounts.\\n    ///         Optionally, also approve the tokens to be spent to the vault relayer.\\n    function drip(address[] calldata _approveTokens, SwapToken[] calldata _swapTokens) external onlyKeeper {\\n        _approve(_approveTokens);\\n\\n        IGPv2Settlement.InteractionData[] memory dripInteractions =\\n            new IGPv2Settlement.InteractionData[](_swapTokens.length);\\n\\n        GPv2Order.Data memory order = GPv2Order.Data({\\n            sellToken: IERC20(address(0)),\\n            buyToken: IERC20(toToken),\\n            receiver: receiver,\\n            sellAmount: 0,\\n            buyAmount: 0,\\n            validTo: nextValidTo(),\\n            appData: appData,\\n            feeAmount: 0,\\n            kind: GPv2Order.KIND_SELL,\\n            partiallyFillable: true,\\n            sellTokenBalance: GPv2Order.BALANCE_ERC20,\\n            buyTokenBalance: GPv2Order.BALANCE_ERC20\\n        });\\n\\n        for (uint256 i = 0; i < dripInteractions.length;) {\\n            SwapToken calldata swapToken = _swapTokens[i];\\n            order.sellToken = IERC20(swapToken.token);\\n            order.sellAmount = swapToken.sellAmount;\\n            order.buyAmount = swapToken.buyAmount;\\n            bytes memory preSignature = _computePreSignature(order);\\n\\n            dripInteractions[i] = IGPv2Settlement.InteractionData({\\n                to: address(settlement),\\n                value: 0,\\n                callData: abi.encodeCall(IGPv2Settlement.setPreSignature, (preSignature, true))\\n            });\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _execInteractions(dripInteractions);\\n    }\\n\\n    /// @notice The `validTo` that the orders will be createad with\\n    /// @dev deterministic so the script can push the orders before dripping onchain\\n    function nextValidTo() public view returns (uint32) {\\n        uint256 remainder = block.timestamp % 1 hours;\\n        return uint32((block.timestamp - remainder) + 2 hours);\\n    }\\n\\n    function _approve(address[] calldata _tokens) internal {\\n        IGPv2Settlement.InteractionData[] memory approveInteractions =\\n            new IGPv2Settlement.InteractionData[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length;) {\\n            address token = _tokens[i];\\n            approveInteractions[i] = IGPv2Settlement.InteractionData({\\n                to: token,\\n                value: 0,\\n                callData: abi.encodeCall(IERC20.approve, (vaultRelayer, type(uint256).max))\\n            });\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _execInteractions(approveInteractions);\\n    }\\n\\n    function _execFromModule(address _to, bytes memory _cd) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) =\\n            targetSafe.execTransactionFromModuleReturnData(_to, 0, _cd, ISafe.Operation.Call);\\n        if (!success) {\\n            assembly (\\\"memory-safe\\\") {\\n                revert(add(returnData, 0x20), mload(returnData))\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    function _execInteractions(IGPv2Settlement.InteractionData[] memory _interactions) internal {\\n        address[] memory tokens = new address[](0);\\n        uint256[] memory clearingPrices = new uint256[](0);\\n        IGPv2Settlement.TradeData[] memory trades = new IGPv2Settlement.TradeData[](0);\\n        IGPv2Settlement.InteractionData[][3] memory interactions =\\n            [new IGPv2Settlement.InteractionData[](0), _interactions, new IGPv2Settlement.InteractionData[](0)];\\n        bytes memory cd = abi.encodeCall(IGPv2Settlement.settle, (tokens, clearingPrices, trades, interactions));\\n        _execFromModule(address(settlement), cd);\\n    }\\n\\n    function _computePreSignature(GPv2Order.Data memory order) internal view returns (bytes memory) {\\n        bytes32 orderDigest = GPv2Order.hash(order, domainSeparator);\\n        return abi.encodePacked(orderDigest, address(settlement), order.validTo);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\ninterface ISafe {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n\\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Operation operation)\\n        external\\n        returns (bool success, bytes memory returnData);\\n\\n    function enableModule(address module) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGPv2Settlement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\ninterface IGPv2Settlement {\\n    struct OrderData {\\n        address sellToken;\\n        address buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    struct TradeData {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    struct InteractionData {\\n        address to;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    function settle(\\n        address[] memory tokens,\\n        uint256[] memory clearingPrices,\\n        TradeData[] memory trades,\\n        InteractionData[][3] memory interactions\\n    ) external;\\n\\n    function setPreSignature(bytes calldata orderUid, bool signed) external;\\n\\n    function domainSeparator() external view returns (bytes32);\\n\\n    function vaultRelayer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\ninterface IERC20 {\\n    function approve(address, uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/GPv2Order.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.8.25;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Order Library\\n/// @author Gnosis Developers\\nlibrary GPv2Order {\\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\\n    /// all order parameters that are signed for submitting to GP.\\n    struct Data {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"address receiver,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"bytes32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable,\\\" +\\n    ///         \\\"string sellTokenBalance,\\\" +\\n    ///         \\\"string buyTokenBalance\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant TYPE_HASH = hex\\\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\\\";\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant KIND_SELL = hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant KIND_BUY = hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\\n    /// computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"erc20\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_ERC20 = hex\\\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault external\\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\\n    /// order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"external\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_EXTERNAL = hex\\\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\\n    /// balances for computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"internal\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_INTERNAL = hex\\\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\\\";\\n\\n    /// @dev Marker address used to indicate that the receiver of the trade\\n    /// proceeds should the owner of the order.\\n    ///\\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\\n    /// to be the most common case.\\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 internal constant UID_LENGTH = 56;\\n\\n    /// @dev Returns the actual receiver for an order. This function checks\\n    /// whether or not the [`receiver`] field uses the marker value to indicate\\n    /// it is the same as the order owner.\\n    ///\\n    /// @return receiver The actual receiver of trade proceeds.\\n    function actualReceiver(Data memory order, address owner) internal pure returns (address receiver) {\\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\\n            receiver = owner;\\n        } else {\\n            receiver = order.receiver;\\n        }\\n    }\\n\\n    /// @dev Return the EIP-712 signing hash for the specified order.\\n    ///\\n    /// @param order The order to compute the EIP-712 signing hash for.\\n    /// @param domainSeparator The EIP-712 domain separator to use.\\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\\n    function hash(Data memory order, bytes32 domainSeparator) internal pure returns (bytes32 orderDigest) {\\n        bytes32 structHash;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n        // in the EIP proposal, noting that the order struct has 12 fields, and\\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, TYPE_HASH)\\n            structHash := keccak256(dataStart, 416)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\\n        // hash using scratch memory past the free memory pointer. The signing\\n        // hash is computed from `\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash`.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n    }\\n\\n    /// @dev Packs order UID parameters into the specified memory location. The\\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\\n    /// it allows re-using the memory for packing the order UID.\\n    ///\\n    /// This function reverts if the order UID buffer is not the correct size.\\n    ///\\n    /// @param orderUid The buffer pack the order UID parameters into.\\n    /// @param orderDigest The EIP-712 struct digest derived from the order\\n    /// parameters.\\n    /// @param owner The address of the user who owns this order.\\n    /// @param validTo The epoch time at which the order will stop being valid.\\n    function packOrderUidParams(bytes memory orderUid, bytes32 orderDigest, address owner, uint32 validTo)\\n        internal\\n        pure\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: uid buffer overflow\\\");\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // Additionally, since Solidity `bytes memory` are length prefixed,\\n        // 32 needs to be added to all the offsets.\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(add(orderUid, 56), validTo)\\n            mstore(add(orderUid, 52), owner)\\n            mstore(add(orderUid, 32), orderDigest)\\n        }\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(bytes calldata orderUid)\\n        internal\\n        pure\\n        returns (bytes32 orderDigest, address owner, uint32 validTo)\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: invalid uid\\\");\\n\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_targetSafe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_appData\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyKeeper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"appData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_approveTokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct COWFeeModule.SwapToken[]\",\"name\":\"_swapTokens\",\"type\":\"tuple[]\"}],\"name\":\"drip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextValidTo\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"internalType\":\"struct COWFeeModule.Revocation[]\",\"name\":\"_revocations\",\"type\":\"tuple[]\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlement\",\"outputs\":[{\"internalType\":\"contract IGPv2Settlement\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSafe\",\"outputs\":[{\"internalType\":\"contract ISafe\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultRelayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "COWFeeModule", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009008d19f58aabd9ed0d60971565aa8510560ab41000000000000000000000000423cec87f19f0778f549846e0801ee267a917935000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000005c5494572e4ab2d48d3ab3aaf6bd4e7b1c98382bcca8463f460f14bca0185afeeb75923ee4434612f41063d0171b1e743ffe84b000000000000000000000000a03be496e67ec29bc62f01a428683d7f9c204930", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}