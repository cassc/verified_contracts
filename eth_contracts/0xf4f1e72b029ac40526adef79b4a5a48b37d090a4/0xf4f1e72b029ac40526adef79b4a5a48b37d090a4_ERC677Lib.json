{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"CanReclaimToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n/**\\n * @title Contracts that should be able to recover tokens\\n * @author SylTi\\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\\n * This will prevent any accidental loss of tokens.\\n */\\ncontract CanReclaimToken is Ownable {\\n    using SafeERC20 for ERC20Basic;\\n\\n    /**\\n     * @dev Reclaim all ERC20Basic compatible tokens\\n     * @param _token ERC20Basic The address of the token contract\\n     */\\n    function reclaimToken(ERC20Basic _token) external onlyOwner {\\n        uint256 balance = _token.balanceOf(address(this));\\n        _token.safeTransfer(owner, balance);\\n    }\\n}\\n\"},\"Claimable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\nabstract contract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    /**\\n     * @dev emitted when the pendingOwner address is changed\\n     * @param previousPendingOwner previous pendingOwner address\\n     * @param newPendingOwner new pendingOwner address\\n     */\\n    event OwnershipTransferPending(\\n        address indexed previousPendingOwner,\\n        address indexed newPendingOwner\\n    );\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingOwner.\\n     */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to set the pendingOwner address.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public virtual override onlyOwner {\\n        emit OwnershipTransferPending(pendingOwner, newOwner);\\n        pendingOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\n     */\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\nabstract contract ERC20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function balanceOf(address _who) public view virtual returns (uint256);\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public virtual returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"ERC20Lib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./TokenStorage.sol\\\";\\n\\n/**\\n * @title ERC20Lib\\n * @dev Standard ERC20 token functionality.\\n * https://github.com/ethereum/EIPs/issues/20\\n */\\nlibrary ERC20Lib {\\n    /**\\n     * @dev Transfers tokens [ERC20].\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transfer(\\n        TokenStorage db,\\n        address caller,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        db.subBalance(caller, amount);\\n        db.addBalance(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from a specific address [ERC20].\\n     * The address owner has to approve the spender beforehand.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param from Address to debet the tokens from.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     */\\n    function transferFrom(\\n        TokenStorage db,\\n        address caller,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        uint256 allowance_ = db.getAllowed(from, caller);\\n        db.subBalance(from, amount);\\n        db.addBalance(to, amount);\\n        db.setAllowed(from, caller, allowance_ - amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a spender [ERC20].\\n     * Note that using the approve/transferFrom presents a possible\\n     * security vulnerability described in:\\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\\n     * Use transferAndCall to mitigate.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param spender The address of the future spender.\\n     * @param amount The allowance of the spender.\\n     */\\n    function approve(\\n        TokenStorage db,\\n        address caller,\\n        address spender,\\n        uint256 amount\\n    ) public returns (bool success) {\\n        db.setAllowed(caller, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the number tokens associated with an address.\\n     * @param db Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return balance Balance of address.\\n     */\\n    function balanceOf(\\n        TokenStorage db,\\n        address who\\n    ) external view returns (uint256 balance) {\\n        return db.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender\\n     * @param db Token storage to operate on.\\n     * @param owner The address of the owner of the tokens.\\n     * @param spender The address of the spender.\\n     * @return remaining Number of tokens the spender is allowed to spend.\\n     */\\n    function allowance(\\n        TokenStorage db,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256 remaining) {\\n        return db.getAllowed(owner, spender);\\n    }\\n}\\n\"},\"ERC677Lib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC677Recipient.sol\\\";\\nimport \\\"./TokenStorage.sol\\\";\\nimport \\\"./ERC20Lib.sol\\\";\\n\\n/**\\n * @title ERC677\\n * @dev ERC677 token functionality.\\n * https://github.com/ethereum/EIPs/issues/677\\n */\\nlibrary ERC677Lib {\\n    using ERC20Lib for TokenStorage;\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfers tokens and subsequently calls a method on the recipient [ERC677].\\n     * If the recipient is a non-contract address this method behaves just like transfer.\\n     * @notice db.transfer either returns true or reverts.\\n     * @param db Token storage to operate on.\\n     * @param caller Address of the caller passed through the frontend.\\n     * @param to Recipient address.\\n     * @param amount Number of tokens to transfer.\\n     * @param data Additional data passed to the recipient\\u0027s tokenFallback method.\\n     */\\n    function transferAndCall(\\n        TokenStorage db,\\n        address caller,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        require(db.transfer(caller, to, amount), \\\"unable to transfer\\\");\\n        if (to.isContract()) {\\n            IERC677Recipient recipient = IERC677Recipient(to);\\n            require(\\n                recipient.onTokenTransfer(caller, amount, data),\\n                \\\"token handler returns false\\\"\\n            );\\n        }\\n        return true;\\n    }\\n}\\n\"},\"HasNoContracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Contracts\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\\n * of this contract to reclaim ownership of the contracts.\\n */\\ncontract HasNoContracts is Ownable {\\n    /**\\n     * @dev Reclaim ownership of Ownable contracts\\n     * @param _contractAddr The address of the Ownable to be reclaimed.\\n     */\\n    function reclaimContract(address _contractAddr) external onlyOwner {\\n        Ownable contractInst = Ownable(_contractAddr);\\n        contractInst.transferOwnership(owner);\\n    }\\n}\\n\"},\"HasNoEther.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Ether\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\\n * in the contract, it will allow the owner to reclaim this Ether.\\n * @notice Ether can still be sent to this contract by:\\n * calling functions labeled `payable`\\n * `selfdestruct(contract_address)`\\n * mining directly to the contract address\\n */\\ncontract HasNoEther is Ownable {\\n    /**\\n     * @dev Constructor that rejects incoming Ether\\n     * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\\n     * leave out payable, then Solidity will allow inheriting contracts to implement a payable\\n     * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\\n     * we could use assembly to access msg.value.\\n     */\\n    constructor() payable {\\n        require(msg.value == 0);\\n    }\\n\\n    /**\\n     * @dev Disallows direct send by setting a default function without the `payable` flag.\\n     */\\n    fallback() external {}\\n\\n    /**\\n     * @dev Transfer all Ether held by the contract to the owner.\\n     */\\n    function reclaimEther() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"},\"HasNoTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./CanReclaimToken.sol\\\";\\n\\n/**\\n * @title Contracts that should not own Tokens\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\\n * owner to reclaim the tokens.\\n */\\ncontract HasNoTokens is CanReclaimToken {\\n    /**\\n     * @dev Reject all ERC223 compatible tokens\\n     * @param _from address The address that is transferring the tokens\\n     * @param _value uint256 the amount of the specified token\\n     * @param _data Bytes The data passed from the caller.\\n     */\\n    function tokenFallback(\\n        address _from,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external pure {\\n        _from;\\n        _value;\\n        _data;\\n        revert();\\n    }\\n}\\n\"},\"IERC677Recipient.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\n/**\\n * @title IERC677Recipient\\n * @dev Contracts implementing this interface can participate in [ERC677].\\n */\\ninterface IERC677Recipient {\\n    /**\\n     * @dev Receives notification from [ERC677] transferAndCall.\\n     * @param from Sender address.\\n     * @param amount Number of tokens.\\n     * @param data Additional data.\\n     */\\n    function onTokenTransfer(\\n        address from,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"},\"NoOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./HasNoEther.sol\\\";\\nimport \\\"./HasNoTokens.sol\\\";\\nimport \\\"./HasNoContracts.sol\\\";\\n\\n/**\\n * @title Base contract for contracts that should not own things.\\n * @author Remco Bloemen \\u003cremco@2\u03c0.com\\u003e\\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\\n * Owned contracts. See respective base contracts for details.\\n */\\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0));\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20Basic _token,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        require(_token.transfer(_to, _value));\\n    }\\n}\\n\"},\"TokenStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./Claimable.sol\\\";\\nimport \\\"./CanReclaimToken.sol\\\";\\nimport \\\"./NoOwner.sol\\\";\\nimport \\\"./TokenStorageLib.sol\\\";\\n\\n/**\\n * @title TokenStorage\\n * @dev External storage for tokens.\\n * The storage is implemented in a separate contract to maintain state\\n * between token upgrades.\\n */\\ncontract TokenStorage is Claimable, CanReclaimToken, NoOwner {\\n    using TokenStorageLib for TokenStorageLib.TokenStorage;\\n\\n    TokenStorageLib.TokenStorage internal tokenStorage;\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(address to, uint256 amount) external onlyOwner {\\n        tokenStorage.addBalance(to, amount);\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(address from, uint256 amount) external onlyOwner {\\n        tokenStorage.subBalance(from, amount);\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Quantity of allowance.\\n     */\\n    function setAllowed(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external onlyOwner {\\n        tokenStorage.setAllowed(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @return Total supply.\\n     */\\n    function getSupply() external view returns (uint256) {\\n        return tokenStorage.getSupply();\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(address who) external view returns (uint256) {\\n        return tokenStorage.getBalance(who);\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256) {\\n        return tokenStorage.getAllowed(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Explicit override of transferOwnership from Claimable and Ownable\\n     * @param newOwner Address to transfer ownership to.\\n     */\\n    function transferOwnership(\\n        address newOwner\\n    ) public override(Claimable, Ownable) {\\n        Claimable.transferOwnership(newOwner);\\n    }\\n}\\n\"},\"TokenStorageLib.sol\":{\"content\":\"/* SPDX-License-Identifier: apache-2.0 */\\n/**\\n * Copyright 2022 Monerium ehf.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity 0.8.11;\\n\\n/*\\n * @title TokenStorageLib\\n * @dev Implementation of an[external storage for tokens.\\n */\\nlibrary TokenStorageLib {\\n    struct TokenStorage {\\n        mapping(address =\\u003e uint) balances;\\n        mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n        uint256 totalSupply;\\n    }\\n\\n    /**\\n     * @dev Increases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param to Address to increase.\\n     * @param amount Number of units to add.\\n     */\\n    function addBalance(\\n        TokenStorage storage self,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply + amount;\\n        self.balances[to] = self.balances[to] + amount;\\n    }\\n\\n    /**\\n     * @dev Decreases balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param from Address to decrease.\\n     * @param amount Number of units to subtract.\\n     */\\n    function subBalance(\\n        TokenStorage storage self,\\n        address from,\\n        uint256 amount\\n    ) external {\\n        self.totalSupply = self.totalSupply - amount;\\n        self.balances[from] = self.balances[from] - amount;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @param amount Qunatity of allowance.\\n     */\\n    function setAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external {\\n        self.allowed[owner][spender] = amount;\\n    }\\n\\n    /**\\n     * @dev Returns the supply of tokens.\\n     * @param self Token storage to operate on.\\n     * @return Total supply.\\n     */\\n    function getSupply(TokenStorage storage self) external view returns (uint) {\\n        return self.totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the balance of an address.\\n     * @param self Token storage to operate on.\\n     * @param who Address to lookup.\\n     * @return Number of units.\\n     */\\n    function getBalance(\\n        TokenStorage storage self,\\n        address who\\n    ) external view returns (uint) {\\n        return self.balances[who];\\n    }\\n\\n    /**\\n     * @dev Returns the allowance for a spender.\\n     * @param self Token storage to operate on.\\n     * @param owner Address of the owner of the tokens to spend.\\n     * @param spender Address of the spender.\\n     * @return Number of units.\\n     */\\n    function getAllowed(\\n        TokenStorage storage self,\\n        address owner,\\n        address spender\\n    ) external view returns (uint) {\\n        return self.allowed[owner][spender];\\n    }\\n}\\n\"}}", "ABI": "[]", "ContractName": "ERC677Lib", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "ERC20Lib:e75f9618bfc1772a35568bd95ed1a0b57a13297b", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://96f020904f41d988e28d327304de8195a4714dd05b21eed467f70d85c0129ffa"}