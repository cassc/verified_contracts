{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DssLitePsm.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: \u00a9 2023 Dai Foundation <www.daifoundation.org>\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.16;\\n\\ninterface VatLike {\\n    function frob(bytes32, address, address, address, int256, int256) external;\\n    function hope(address) external;\\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\\n    function debt() external view returns (uint256);\\n    function Line() external view returns (uint256);\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n    function live() external view returns (uint256);\\n}\\n\\ninterface GemLike {\\n    function balanceOf(address) external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function approve(address, uint256) external;\\n    function transfer(address, uint256) external;\\n    function transferFrom(address, address, uint256) external;\\n}\\n\\ninterface DaiJoinLike {\\n    function dai() external view returns (address);\\n    function vat() external view returns (address);\\n    function exit(address, uint256) external;\\n    function join(address, uint256) external;\\n}\\n\\n/**\\n * @title A lightweight PSM implementation.\\n * @notice Swaps Dai for `gem` at a 1:1 exchange rate.\\n * @notice Fees `tin` and `tout` might apply.\\n * @dev `gem` balance is kept in `pocket` instead of this contract.\\n * @dev A few assumptions are made:\\n *      1. There are no other urns for the same `ilk`\\n *      2. Stability fee is always zero for the `ilk`\\n *      3. The `spot` price for gem is always 1 (`10**27`).\\n *      4. The `spotter.par` (Dai parity) is always 1 (`10**27`).\\n *      5. This contract can freely transfer `gem` on behalf of `pocket`.\\n */\\ncontract DssLitePsm {\\n    /// @notice Special value for `tin` and/or `tout` to indicate swaps are halted.\\n    /// @dev Setting `tin` or `tout` to `type(uint256).max` will cause sell gem and buy gem functions respectively to revert.\\n    uint256 public constant HALTED = type(uint256).max;\\n    /// @notice Collateral type identifier.\\n    bytes32 public immutable ilk;\\n    /// @notice Maker Protocol core engine.\\n    VatLike public immutable vat;\\n    /// @notice Dai adapter.\\n    DaiJoinLike public immutable daiJoin;\\n    /// @notice Dai token.\\n    GemLike public immutable dai;\\n    /// @notice Gem to exchange with Dai.\\n    GemLike public immutable gem;\\n    /// @notice Precision conversion factor for `gem`, since Dai is expected to always have 18 decimals.\\n    uint256 public immutable to18ConversionFactor;\\n    /// @notice The ultimate holder of the gems.\\n    /// @dev This contract should be able to freely transfer `gem` on behalf of `pocket`.\\n    address public immutable pocket;\\n\\n    /// @notice Addresses with admin access on this contract. `wards[usr]`.\\n    mapping(address => uint256) public wards;\\n    /// @notice Addresses with permission to swap with no fees. `bud[usr]`.\\n    mapping(address => uint256) public bud;\\n    /// @notice Maker Protocol balance sheet.\\n    address public vow;\\n    /// @notice Fee for selling gems.\\n    /// @dev `wad` precision. 1 * WAD means a 100% fee.\\n    uint256 public tin;\\n    /// @notice Fee for buying gems.\\n    /// @dev `wad` precision. 1 * WAD means a 100% fee.\\n    uint256 public tout;\\n    /// @notice Buffer for pre-minted Dai.\\n    /// @dev `wad` precision.\\n    uint256 public buf;\\n\\n    /// @dev `wad` precision.\\n    uint256 internal constant WAD = 10 ** 18;\\n    /// @dev `ray` precision for `vat` manipulation.\\n    uint256 internal constant RAY = 10 ** 27;\\n    /// @dev Workaround to explicitly revert with an arithmetic error.\\n    string internal constant ARITHMETIC_ERROR = string(abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11));\\n\\n    /**\\n     * @notice `usr` was granted admin access.\\n     * @param usr The user address.\\n     */\\n    event Rely(address indexed usr);\\n    /**\\n     * @notice `usr` admin access was revoked.\\n     * @param usr The user address.\\n     */\\n    event Deny(address indexed usr);\\n    /**\\n     * @notice `usr` was granted permission to swap without any fees.\\n     * @param usr The user address.\\n     */\\n    event Kiss(address indexed usr);\\n    /**\\n     * @notice Permission revoked for `usr` to swap without any fees.\\n     * @param usr The user address.\\n     */\\n    event Diss(address indexed usr);\\n    /**\\n     * @notice A contract parameter was updated.\\n     * @param what The changed parameter name. [\\\"vow\\\"].\\n     * @param data The new value of the parameter.\\n     */\\n    event File(bytes32 indexed what, address data);\\n    /**\\n     * @notice A contract parameter was updated.\\n     * @param what The changed parameter name. [\\\"tin\\\", \\\"tout\\\", \\\"buf\\\"].\\n     * @param data The new value of the parameter.\\n     */\\n    event File(bytes32 indexed what, uint256 data);\\n    /**\\n     * @notice A user sold `gem` for Dai.\\n     * @param owner The address receiving Dai.\\n     * @param value The amount of `gem` sold. [`gem` precision].\\n     * @param fee The fee in Dai paid by the user. [`wad`].\\n     */\\n    event SellGem(address indexed owner, uint256 value, uint256 fee);\\n    /**\\n     * @notice A user bought `gem` with Dai.\\n     * @param owner The address receiving `gem`.\\n     * @param value The amount of `gem` bought. [`gem` precision].\\n     * @param fee The fee in Dai paid by the user. [`wad`].\\n     */\\n    event BuyGem(address indexed owner, uint256 value, uint256 fee);\\n    /**\\n     * @notice The contract was filled with Dai.\\n     * @param wad The amount of Dai filled.\\n     */\\n    event Fill(uint256 wad);\\n    /**\\n     * @notice The contract was trimmed of excess Dai.\\n     * @param wad The amount of Dai trimmed.\\n     */\\n    event Trim(uint256 wad);\\n    /**\\n     * @notice Dai accumulated as swap fees was added to the surplus buffer.\\n     * @param wad The amount of Dai added.\\n     */\\n    event Chug(uint256 wad);\\n\\n    modifier auth() {\\n        require(wards[msg.sender] == 1, \\\"DssLitePsm/not-authorized\\\");\\n        _;\\n    }\\n\\n    modifier toll() {\\n        require(bud[msg.sender] == 1, \\\"DssLitePsm/not-whitelisted\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @param ilk_ The collateral type identifier.\\n     * @param gem_ The gem to exchange with Dai.\\n     * @param daiJoin_ The Dai adapter.\\n     * @param pocket_ The ultimate holder of `gem`.\\n     */\\n    constructor(bytes32 ilk_, address gem_, address daiJoin_, address pocket_) {\\n        ilk = ilk_;\\n        gem = GemLike(gem_);\\n        daiJoin = DaiJoinLike(daiJoin_);\\n        vat = VatLike(daiJoin.vat());\\n        dai = GemLike(daiJoin.dai());\\n        pocket = pocket_;\\n\\n        to18ConversionFactor = 10 ** (18 - gem.decimals());\\n\\n        dai.approve(daiJoin_, type(uint256).max);\\n        vat.hope(daiJoin_);\\n\\n        wards[msg.sender] = 1;\\n        emit Rely(msg.sender);\\n    }\\n\\n    /*//////////////////////////////////\\n                    Math\\n    //////////////////////////////////*/\\n\\n    ///@dev Safely converts `uint256` to `int256`. Reverts if it overflows.\\n    function _int256(uint256 x) internal pure returns (int256 y) {\\n        require((y = int256(x)) >= 0, ARITHMETIC_ERROR);\\n    }\\n\\n    ///@dev Returns the min between `x` and `y`.\\n    function _min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x < y ? x : y;\\n    }\\n\\n    ///@dev Returns the max between `x` and `y`.\\n    function _max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x > y ? x : y;\\n    }\\n\\n    ///@dev Returns the difference between `x` and `y` if `x > y` or zero otherwise.\\n    function _subcap(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x > y ? x - y : 0;\\n        }\\n    }\\n\\n    /*//////////////////////////////////\\n               Administration\\n    //////////////////////////////////*/\\n\\n    /**\\n     * @notice Grants `usr` admin access to this contract.\\n     * @param usr The user address.\\n     */\\n    function rely(address usr) external auth {\\n        wards[usr] = 1;\\n        emit Rely(usr);\\n    }\\n\\n    /**\\n     * @notice Revokes `usr` admin access from this contract.\\n     * @param usr The user address.\\n     */\\n    function deny(address usr) external auth {\\n        wards[usr] = 0;\\n        emit Deny(usr);\\n    }\\n\\n    /**\\n     * @notice Grants `usr` permission to swap without any fees.\\n     * @param usr The user address.\\n     */\\n    function kiss(address usr) external auth {\\n        bud[usr] = 1;\\n        emit Kiss(usr);\\n    }\\n\\n    /**\\n     * @notice Revokes `usr` permission to swap without any fees.\\n     * @param usr The user address.\\n     */\\n    function diss(address usr) external auth {\\n        bud[usr] = 0;\\n        emit Diss(usr);\\n    }\\n\\n    /**\\n     * @notice Updates a contract parameter.\\n     * @param what The changed parameter name. [\\\"vow\\\"].\\n     * @param data The new value of the parameter.\\n     */\\n    function file(bytes32 what, address data) external auth {\\n        if (what == \\\"vow\\\") {\\n            vow = data;\\n        } else {\\n            revert(\\\"DssLitePsm/file-unrecognized-param\\\");\\n        }\\n\\n        emit File(what, data);\\n    }\\n\\n    /**\\n     * @notice Updates a contract parameter.\\n     * @dev Swapping fees may not apply due to rounding errors for small swaps where\\n     *      `gemAmt < 10**gem.decimals() / tin` or\\n     *      `gemAmt < 10**gem.decimals() / tout`.\\n     * @dev Setting `tin` or `tout` to `HALTED` effectively disables selling and buying gems respectively.\\n     * @param what The changed parameter name. [\\\"tin\\\", \\\"tout\\\", \\\"buf\\\"].\\n     * @param data The new value of the parameter.\\n     */\\n    function file(bytes32 what, uint256 data) external auth {\\n        if (what == \\\"tin\\\") {\\n            require(data == HALTED || data <= WAD, \\\"DssLitePsm/tin-out-of-range\\\");\\n            tin = data;\\n        } else if (what == \\\"tout\\\") {\\n            require(data == HALTED || data <= WAD, \\\"DssLitePsm/tout-out-of-range\\\");\\n            tout = data;\\n        } else if (what == \\\"buf\\\") {\\n            buf = data;\\n        } else {\\n            revert(\\\"DssLitePsm/file-unrecognized-param\\\");\\n        }\\n\\n        emit File(what, data);\\n    }\\n\\n    /*//////////////////////////////////\\n                  Swapping\\n    //////////////////////////////////*/\\n\\n    /**\\n     * @notice Function that swaps `gem` into Dai.\\n     * @dev Reverts if `tin` is set to `HALTED`.\\n     * @param usr The destination of the bought Dai.\\n     * @param gemAmt The amount of gem to sell. [`gem` precision].\\n     * @return daiOutWad The amount of Dai bought.\\n     */\\n    function sellGem(address usr, uint256 gemAmt) external returns (uint256 daiOutWad) {\\n        uint256 tin_ = tin;\\n        require(tin_ != HALTED, \\\"DssLitePsm/sell-gem-halted\\\");\\n        daiOutWad = _sellGem(usr, gemAmt, tin_);\\n    }\\n\\n    /**\\n     * @notice Function that swaps `gem` into Dai without any fees.\\n     * @dev Only users whitelisted through `kiss()` can call this function.\\n     *      Reverts if `tin` is set to `HALTED`.\\n     * @param usr The destination of the bought Dai.\\n     * @param gemAmt The amount of gem to sell. [`gem` precision].\\n     * @return daiOutWad The amount of Dai bought.\\n     */\\n    function sellGemNoFee(address usr, uint256 gemAmt) external toll returns (uint256 daiOutWad) {\\n        require(tin != HALTED, \\\"DssLitePsm/sell-gem-halted\\\");\\n        daiOutWad = _sellGem(usr, gemAmt, 0);\\n    }\\n\\n    /**\\n     * @notice Internal function that implements the logic to swaps `gem` into Dai.\\n     * @param usr The destination of the bought Dai.\\n     * @param gemAmt The amount of gem to sell. [`gem` precision].\\n     * @param tin_ The fee rate applicable to the swap [`1 * WAD` = 100%].\\n     * @return daiOutWad The amount of Dai bought.\\n     */\\n    function _sellGem(address usr, uint256 gemAmt, uint256 tin_) internal returns (uint256 daiOutWad) {\\n        daiOutWad = gemAmt * to18ConversionFactor;\\n        uint256 fee;\\n        if (tin_ > 0) {\\n            fee = daiOutWad * tin_ / WAD;\\n            // At this point, `tin_ <= 1 WAD`, so an underflow is not possible.\\n            unchecked {\\n                daiOutWad -= fee;\\n            }\\n        }\\n\\n        gem.transferFrom(msg.sender, pocket, gemAmt);\\n        // This can consume the whole balance including system fees not withdrawn.\\n        dai.transfer(usr, daiOutWad);\\n\\n        emit SellGem(usr, gemAmt, fee);\\n    }\\n\\n    /**\\n     * @notice Function that swaps Dai into `gem`.\\n     * @dev Reverts if `tout` is set to `HALTED`.\\n     * @param usr The destination of the bought gems.\\n     * @param gemAmt The amount of gem to buy. [`gem` precision].\\n     * @return daiInWad The amount of Dai required to sell.\\n     */\\n    function buyGem(address usr, uint256 gemAmt) external returns (uint256 daiInWad) {\\n        uint256 tout_ = tout;\\n        require(tout_ != HALTED, \\\"DssLitePsm/buy-gem-halted\\\");\\n        daiInWad = _buyGem(usr, gemAmt, tout_);\\n    }\\n\\n    /**\\n     * @notice Function that swaps Dai into `gem` without any fees.\\n     * @dev Only users whitelisted through `kiss()` can call this function.\\n     *      Reverts if `tout` is set to `HALTED`.\\n     * @param usr The destination of the bought gems.\\n     * @param gemAmt The amount of gem to buy. [`gem` precision].\\n     * @return daiInWad The amount of Dai required to sell.\\n     */\\n    function buyGemNoFee(address usr, uint256 gemAmt) external toll returns (uint256 daiInWad) {\\n        require(tout != HALTED, \\\"DssLitePsm/buy-gem-halted\\\");\\n        daiInWad = _buyGem(usr, gemAmt, 0);\\n    }\\n\\n    /**\\n     * @notice Internal function implementing the logic that swaps Dai into `gem`.\\n     * @param usr The destination of the bought gems.\\n     * @param gemAmt The amount of gem to buy. [`gem` precision].\\n     * @param tout_ The fee rate applicable to the swap [`1 * WAD` = 100%].\\n     * @return daiInWad The amount of Dai required to sell.\\n     */\\n    function _buyGem(address usr, uint256 gemAmt, uint256 tout_) internal returns (uint256 daiInWad) {\\n        daiInWad = gemAmt * to18ConversionFactor;\\n        uint256 fee;\\n        if (tout_ > 0) {\\n            fee = daiInWad * tout_ / WAD;\\n            daiInWad += fee;\\n        }\\n\\n        dai.transferFrom(msg.sender, address(this), daiInWad);\\n        gem.transferFrom(pocket, usr, gemAmt);\\n\\n        emit BuyGem(usr, gemAmt, fee);\\n    }\\n\\n    /*//////////////////////////////////\\n                Bookkeeping\\n    //////////////////////////////////*/\\n\\n    /**\\n     * @notice Mints Dai into this contract.\\n     * @dev Both `buf`, the local and global debt ceilings limit the actual minted amount.\\n     *      Notice that `gem` donations or extraneous debt repayments can also affect the amount.\\n     * @return wad The amount of Dai minted.\\n     */\\n    function fill() external returns (uint256 wad) {\\n        wad = rush();\\n        require(wad > 0, \\\"DssLitePsm/nothing-to-fill\\\");\\n\\n        // The `urn` for this contract in the `Vat` is expected to have \\\"unlimited\\\" `ink`.\\n        vat.frob(ilk, address(this), address(0), address(this), 0, _int256(wad));\\n        daiJoin.exit(address(this), wad);\\n\\n        emit Fill(wad);\\n    }\\n\\n    /**\\n     * @notice Burns any excess of Dai from this contract.\\n     * @dev The total outstanding debt can still be larger than the debt ceiling after `trim`.\\n     *      Additional `buyGem` calls will enable further `trim` calls.\\n     * @return wad The amount of Dai burned.\\n     */\\n    function trim() external returns (uint256 wad) {\\n        wad = gush();\\n        require(wad > 0, \\\"DssLitePsm/nothing-to-trim\\\");\\n\\n        daiJoin.join(address(this), wad);\\n        // The `urn` for this contract in the `Vat` is expected to have \\\"unlimited\\\" `ink`.\\n        vat.frob(ilk, address(this), address(0), address(this), 0, -_int256(wad));\\n\\n        emit Trim(wad);\\n    }\\n\\n    /**\\n     * @notice Incorporates any outstanding accumulated fees into the surplus buffer.\\n     * @return wad The amount added to the surplus buffer.\\n     */\\n    function chug() external returns (uint256 wad) {\\n        address vow_ = vow;\\n        require(vow_ != address(0), \\\"DssLitePsm/chug-missing-vow\\\");\\n\\n        wad = cut();\\n        require(wad > 0, \\\"DssLitePsm/nothing-to-chug\\\");\\n\\n        daiJoin.join(vow_, wad);\\n\\n        emit Chug(wad);\\n    }\\n\\n    /*//////////////////////////////////\\n                  Getters\\n    //////////////////////////////////*/\\n\\n    /**\\n     * @notice Returns the missing Dai that can be filled into this contract.\\n     * @return wad The amount of Dai.\\n     */\\n    function rush() public view returns (uint256 wad) {\\n        (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);\\n        require(rate == RAY, \\\"DssLitePsm/rate-not-RAY\\\");\\n        uint256 tArt = gem.balanceOf(pocket) * to18ConversionFactor + buf;\\n\\n        wad = _min(\\n            _min(\\n                // To avoid two extra SLOADs it assumes urn.art == ilk.Art.\\n                _subcap(tArt, Art),\\n                _subcap(line / RAY, Art)\\n            ),\\n            _subcap(vat.Line(), vat.debt()) / RAY\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the excess Dai that can be trimmed from this contract.\\n     * @return wad The amount of Dai.\\n     */\\n    function gush() public view returns (uint256 wad) {\\n        (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);\\n        require(rate == RAY, \\\"DssLitePsm/rate-not-RAY\\\");\\n        uint256 tArt = gem.balanceOf(pocket) * to18ConversionFactor + buf;\\n\\n        wad = _min(\\n            _max(\\n                // To avoid two extra SLOADs it assumes urn.art == ilk.Art.\\n                _subcap(Art, tArt),\\n                _subcap(Art, line / RAY)\\n            ),\\n            // Cannot burn more than the current balance.\\n            dai.balanceOf(address(this))\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the amount of swapping fees that can be chugged by this contract.\\n     * @dev To keep `_sellGem` gas usage low, it allows users to take pre-minted Dai up to the whole balance, regardless\\n     *      if part of it consist of collected fees.\\n     *      If there is not enough balance, it will need to wait for new pre-minted Dai to be generated or Dai swapped\\n     *      back to complete the withdrawal of fees.\\n     * @return wad The amount of Dai.\\n     */\\n    function cut() public view returns (uint256 wad) {\\n        (, uint256 art) = vat.urns(ilk, address(this));\\n        uint256 cash = dai.balanceOf(address(this));\\n\\n        wad = _min(cash, cash + gem.balanceOf(pocket) * to18ConversionFactor - art);\\n    }\\n\\n    /*//////////////////////////////////\\n            Compatibility Layer\\n    //////////////////////////////////*/\\n\\n    /**\\n     * @notice Returns the address of the LitePsm contract itself.\\n     * @dev LitePsm does not have an external gem join. All logic is handled internally.\\n     *      This function is required because there are some dependencies that assume every PSM has a gem join.\\n     * @return The address of this contract.\\n     */\\n    function gemJoin() external view returns (address) {\\n        return address(this);\\n    }\\n\\n    /**\\n     * @notice Returns the number of decimals for `gem`.\\n     * @return The number of decimals for `gem`.\\n     */\\n    function dec() external view returns (uint256) {\\n        return gem.decimals();\\n    }\\n\\n    /**\\n     * @notice Returns whether the contract is live or not.\\n     * @return Whether the contract is live or not.\\n     */\\n    function live() external view returns (uint256) {\\n        return vat.live();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/dss-test/lib/forge-std/lib/ds-test/src/\",\r\n      \"dss-interfaces/=lib/dss-test/lib/dss-interfaces/src/\",\r\n      \"dss-test/=lib/dss-test/src/\",\r\n      \"forge-std/=lib/dss-test/lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"gem_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daiJoin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pocket_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"BuyGem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Chug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Diss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Fill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Kiss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SellGem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Trim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HALTED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bud\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gemAmt\",\"type\":\"uint256\"}],\"name\":\"buyGem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiInWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gemAmt\",\"type\":\"uint256\"}],\"name\":\"buyGemNoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiInWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chug\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract GemLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiJoin\",\"outputs\":[{\"internalType\":\"contract DaiJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"internalType\":\"contract GemLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemJoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilk\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pocket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gemAmt\",\"type\":\"uint256\"}],\"name\":\"sellGem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiOutWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gemAmt\",\"type\":\"uint256\"}],\"name\":\"sellGemNoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiOutWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"to18ConversionFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DssLitePsm", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "4c4954452d50534d2d555344432d410000000000000000000000000000000000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a2800000000000000000000000037305b1cd40574e4c5ce33f8e8306be057fd7341", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}