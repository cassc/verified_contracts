{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UserProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./utils/UserProxyStorage.sol\\\";\\nimport \\\"./utils/Multicall.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxy is Multicall {\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version; // Current version of the contract\\n    address private nominatedOperator;\\n\\n    // Operator events\\n    event OperatorNominated(address indexed newOperator);\\n    event OperatorChanged(address indexed oldOperator, address indexed newOperator);\\n    event SetAMMStatus(bool enable);\\n    event UpgradeAMMWrapper(address newAMMWrapper);\\n    event SetPMMStatus(bool enable);\\n    event UpgradePMM(address newPMM);\\n    event SetRFQStatus(bool enable);\\n    event UpgradeRFQ(address newRFQ);\\n    event SetRFQv2Status(bool enable);\\n    event UpgradeRFQv2(address newRFQv2);\\n    event SetLimitOrderStatus(bool enable);\\n    event UpgradeLimitOrder(address newLimitOrder);\\n\\n    receive() external payable {}\\n\\n    /************************************************************\\n     *          Access control and ownership management          *\\n     *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"UserProxy: not the operator\\\");\\n        _;\\n    }\\n\\n    function nominateNewOperator(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"UserProxy: operator can not be zero address\\\");\\n        nominatedOperator = _newOperator;\\n\\n        emit OperatorNominated(_newOperator);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOperator, \\\"UserProxy: not nominated\\\");\\n        emit OperatorChanged(operator, nominatedOperator);\\n\\n        operator = nominatedOperator;\\n        nominatedOperator = address(0);\\n    }\\n\\n    /************************************************************\\n     *              Constructor and init functions               *\\n     *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize(address _operator) external {\\n        require(keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"UserProxy: not upgrading from empty\\\");\\n        require(_operator != address(0), \\\"UserProxy: operator can not be zero address\\\");\\n        operator = _operator;\\n\\n        // Upgrade version\\n        version = \\\"5.3.0\\\";\\n    }\\n\\n    /************************************************************\\n     *                     Getter functions                      *\\n     *************************************************************/\\n    function ammWrapperAddr() public view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function isAMMEnabled() public view returns (bool) {\\n        return AMMWrapperStorage.getStorage().isEnabled;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PMMStorage.getStorage().pmmAddr;\\n    }\\n\\n    function isPMMEnabled() public view returns (bool) {\\n        return PMMStorage.getStorage().isEnabled;\\n    }\\n\\n    function rfqAddr() public view returns (address) {\\n        return RFQStorage.getStorage().rfqAddr;\\n    }\\n\\n    function isRFQEnabled() public view returns (bool) {\\n        return RFQStorage.getStorage().isEnabled;\\n    }\\n\\n    function rfqv2Addr() public view returns (address) {\\n        return RFQv2Storage.getStorage().rfqv2Addr;\\n    }\\n\\n    function isRFQv2Enabled() public view returns (bool) {\\n        return RFQv2Storage.getStorage().isEnabled;\\n    }\\n\\n    function limitOrderAddr() public view returns (address) {\\n        return LimitOrderStorage.getStorage().limitOrderAddr;\\n    }\\n\\n    function isLimitOrderEnabled() public view returns (bool) {\\n        return LimitOrderStorage.getStorage().isEnabled;\\n    }\\n\\n    /************************************************************\\n     *           Management functions for Operator               *\\n     *************************************************************/\\n    function setAMMStatus(bool _enable) public onlyOperator {\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n\\n        emit SetAMMStatus(_enable);\\n    }\\n\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr, bool _enable) external onlyOperator {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n\\n        emit UpgradeAMMWrapper(_newAMMWrapperAddr);\\n        emit SetAMMStatus(_enable);\\n    }\\n\\n    function setPMMStatus(bool _enable) public onlyOperator {\\n        PMMStorage.getStorage().isEnabled = _enable;\\n\\n        emit SetPMMStatus(_enable);\\n    }\\n\\n    function upgradePMM(address _newPMMAddr, bool _enable) external onlyOperator {\\n        PMMStorage.getStorage().pmmAddr = _newPMMAddr;\\n        PMMStorage.getStorage().isEnabled = _enable;\\n\\n        emit UpgradePMM(_newPMMAddr);\\n        emit SetPMMStatus(_enable);\\n    }\\n\\n    function setRFQStatus(bool _enable) public onlyOperator {\\n        RFQStorage.getStorage().isEnabled = _enable;\\n\\n        emit SetRFQStatus(_enable);\\n    }\\n\\n    function upgradeRFQ(address _newRFQAddr, bool _enable) external onlyOperator {\\n        RFQStorage.getStorage().rfqAddr = _newRFQAddr;\\n        RFQStorage.getStorage().isEnabled = _enable;\\n\\n        emit UpgradeRFQ(_newRFQAddr);\\n        emit SetRFQStatus(_enable);\\n    }\\n\\n    function setRFQv2Status(bool _enable) public onlyOperator {\\n        RFQv2Storage.getStorage().isEnabled = _enable;\\n\\n        emit SetRFQv2Status(_enable);\\n    }\\n\\n    function upgradeRFQv2(address _newRFQv2Addr, bool _enable) external onlyOperator {\\n        RFQv2Storage.getStorage().rfqv2Addr = _newRFQv2Addr;\\n        RFQv2Storage.getStorage().isEnabled = _enable;\\n\\n        emit UpgradeRFQv2(_newRFQv2Addr);\\n        emit SetRFQv2Status(_enable);\\n    }\\n\\n    function setLimitOrderStatus(bool _enable) public onlyOperator {\\n        LimitOrderStorage.getStorage().isEnabled = _enable;\\n\\n        emit SetLimitOrderStatus(_enable);\\n    }\\n\\n    function upgradeLimitOrder(address _newLimitOrderAddr, bool _enable) external onlyOperator {\\n        LimitOrderStorage.getStorage().limitOrderAddr = _newLimitOrderAddr;\\n        LimitOrderStorage.getStorage().isEnabled = _enable;\\n\\n        emit UpgradeLimitOrder(_newLimitOrderAddr);\\n        emit SetLimitOrderStatus(_enable);\\n    }\\n\\n    /************************************************************\\n     *                   External functions                      *\\n     *************************************************************/\\n    /**\\n     * @dev proxy the call to AMM\\n     */\\n    function toAMM(bytes calldata _payload) external payable {\\n        require(isAMMEnabled(), \\\"UserProxy: AMM is disabled\\\");\\n\\n        (bool callSucceed, ) = ammWrapperAddr().call{ value: msg.value }(_payload);\\n        if (!callSucceed) {\\n            // revert with data from last call\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev proxy the call to PMM\\n     */\\n    function toPMM(bytes calldata _payload) external payable {\\n        require(isPMMEnabled(), \\\"UserProxy: PMM is disabled\\\");\\n        require(msg.sender == tx.origin, \\\"UserProxy: only EOA\\\");\\n\\n        (bool callSucceed, ) = pmmAddr().call{ value: msg.value }(_payload);\\n        if (!callSucceed) {\\n            // revert with data from last call\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev proxy the call to RFQ\\n     */\\n    function toRFQ(bytes calldata _payload) external payable {\\n        require(isRFQEnabled(), \\\"UserProxy: RFQ is disabled\\\");\\n        require(msg.sender == tx.origin, \\\"UserProxy: only EOA\\\");\\n\\n        (bool callSucceed, ) = rfqAddr().call{ value: msg.value }(_payload);\\n        if (!callSucceed) {\\n            // revert with data from last call\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev proxy the call to RFQv2\\n     */\\n    function toRFQv2(bytes calldata _payload) external payable {\\n        require(isRFQv2Enabled(), \\\"UserProxy: RFQv2 is disabled\\\");\\n        require(msg.sender == tx.origin, \\\"UserProxy: only EOA\\\");\\n\\n        (bool callSucceed, ) = rfqv2Addr().call{ value: msg.value }(_payload);\\n        if (!callSucceed) {\\n            // revert with data from last call\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev proxy the call to Limit Order\\n     */\\n    function toLimitOrder(bytes calldata _payload) external {\\n        require(isLimitOrderEnabled(), \\\"UserProxy: Limit Order is disabled\\\");\\n        require(msg.sender == tx.origin, \\\"UserProxy: only EOA\\\");\\n\\n        (bool callSucceed, ) = limitOrderAddr().call(_payload);\\n        if (!callSucceed) {\\n            // revert with data from last call\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/UserProxyStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xbf49677e3150252dfa801a673d2d5ec21eaa360a4674864e55e79041e3f65a6b;\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the AMMWrapper contract.\\n        address ammWrapperAddr;\\n        // Is AMM enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly {\\n            stor.slot := slot\\n        }\\n    }\\n}\\n\\nlibrary PMMStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x8f135983375ba6442123d61647e7325c1753eabc2e038e44d3b888a970def89a;\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the PMM contract.\\n        address pmmAddr;\\n        // Is PMM enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.pmm.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly {\\n            stor.slot := slot\\n        }\\n    }\\n}\\n\\nlibrary RFQStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x857df08bd185dc66e3cc5e11acb4e1dd65290f3fee6426f52f84e8faccf229cf;\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the RFQ contract.\\n        address rfqAddr;\\n        // Is RFQ enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.rfq.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly {\\n            stor.slot := slot\\n        }\\n    }\\n}\\n\\nlibrary RFQv2Storage {\\n    bytes32 private constant STORAGE_SLOT = 0xd5f1768ede616e352f32123fd6fe01064898ae4e55a2678c79b8ad79680ff744;\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the RFQv2 contract.\\n        address rfqv2Addr;\\n        // Is RFQv2 enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.rfqv2.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly {\\n            stor.slot := slot\\n        }\\n    }\\n}\\n\\nlibrary LimitOrderStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xf1a59a985b4002cdf0db464f05bed7182ee06372a999d820ea1883b8bf067ce5;\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the Limit Order contract.\\n        address limitOrderAddr;\\n        // Is Limit Order enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.limitorder.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly {\\n            stor.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../interfaces/IMulticall.sol\\\";\\n\\n// Modified from https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.1.1/contracts/base/Multicall.sol\\nabstract contract Multicall is IMulticall {\\n    function multicall(bytes[] calldata data, bool revertOnFail) external override returns (bool[] memory successes, bytes[] memory results) {\\n        successes = new bool[](data.length);\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; ++i) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            successes[i] = success;\\n            results[i] = result;\\n\\n            if (!success) {\\n                // Get failed reason\\n                string memory revertReason;\\n                if (result.length < 68) {\\n                    revertReason = \\\"Delegatecall failed\\\";\\n                } else {\\n                    assembly {\\n                        result := add(result, 0x04)\\n                    }\\n                    revertReason = abi.decode(result, (string));\\n                }\\n\\n                if (revertOnFail) {\\n                    revert(revertReason);\\n                }\\n                emit MulticallFailure(i, revertReason);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\ninterface IMulticall {\\n    event MulticallFailure(uint256 index, string reason);\\n\\n    function multicall(bytes[] calldata data, bool revertOnFail) external returns (bool[] memory successes, bytes[] memory results);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"MulticallFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetAMMStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetLimitOrderStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetPMMStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetRFQStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetRFQv2Status\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAMMWrapper\",\"type\":\"address\"}],\"name\":\"UpgradeAMMWrapper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLimitOrder\",\"type\":\"address\"}],\"name\":\"UpgradeLimitOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPMM\",\"type\":\"address\"}],\"name\":\"UpgradePMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRFQ\",\"type\":\"address\"}],\"name\":\"UpgradeRFQ\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRFQv2\",\"type\":\"address\"}],\"name\":\"UpgradeRFQv2\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ammWrapperAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAMMEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLimitOrderEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPMMEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRFQEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRFQv2Enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitOrderAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"revertOnFail\",\"type\":\"bool\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successes\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"nominateNewOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pmmAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rfqAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rfqv2Addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setAMMStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setLimitOrderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setPMMStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setRFQStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setRFQv2Status\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"toAMM\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"toLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"toPMM\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"toRFQ\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"toRFQv2\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAMMWrapperAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"upgradeAMMWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newLimitOrderAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"upgradeLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPMMAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"upgradePMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRFQAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"upgradeRFQ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRFQv2Addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"upgradeRFQv2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UserProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}