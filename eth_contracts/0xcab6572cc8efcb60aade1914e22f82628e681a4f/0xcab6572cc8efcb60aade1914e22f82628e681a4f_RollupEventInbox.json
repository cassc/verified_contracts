{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IBridge {\\n    /// @dev This is an instruction to offchain readers to inform them where to look\\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\\n    ///      reader where to find the data so that they can supply it to the replay binary\\n    enum BatchDataLocation {\\n        /// @notice The data can be found in the transaction call data\\n        TxInput,\\n        /// @notice The data can be found in an event emitted during the transaction\\n        SeparateBatchEvent,\\n        /// @notice This batch contains no data\\n        NoData,\\n        /// @notice The data can be found in the 4844 data blobs on this transaction\\n        Blob\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event DepositMessageDelivered(address indexed sender);\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    event RollupUpdated(address rollup);\\n\\n    function allowedDelayedInboxList(uint256) external returns (address);\\n\\n    function allowedOutboxList(uint256) external returns (address);\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function delayedInboxAccs(uint256) external view returns (bytes32);\\n\\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function sequencerReportedSubMessageCount() external view returns (uint256);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    // ---------- onlySequencerInbox functions ----------\\n\\n    function enqueueSequencerMessage(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    /**\\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\\n     *      every delayed inbox or every sequencer inbox call.\\n     */\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function updateRollupAddress(IOwnable _rollup) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IEthBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface IEthBridge is IBridge {\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     *      These messages are later sequenced in the SequencerInbox, either\\n     *      by the sequencer as part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IOwnable rollup_) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.21 <0.9.0;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArbitrumChecker.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../precompiles/ArbSys.sol\\\";\\n\\nlibrary ArbitrumChecker {\\n    function runningOnArbitrum() internal view returns (bool) {\\n        (bool ok, bytes memory data) = address(100).staticcall(\\n            abi.encodeWithSelector(ArbSys.arbOSVersion.selector)\\n        );\\n        return ok && data.length == 32;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// @dev Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when post upgrade init validation fails\\nerror BadPostUpgradeInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\\n// Bridge Errors\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\n/// @dev The provided token address isn't valid\\n/// @param token address of token being set\\nerror InvalidTokenSet(address token);\\n\\n/// @dev Call to this specific address is not allowed\\n/// @param target address of the call receiver\\nerror CallTargetNotAllowed(address target);\\n\\n/// @dev Call that changes the balance of ERC20Bridge is not allowed\\nerror CallNotAllowed();\\n\\n// Inbox Errors\\n\\n/// @dev The contract is paused, so cannot be paused\\nerror AlreadyPaused();\\n\\n/// @dev The contract is unpaused, so cannot be unpaused\\nerror AlreadyUnpaused();\\n\\n/// @dev The contract is paused\\nerror Paused();\\n\\n/// @dev msg.value sent to the inbox isn't high enough\\nerror InsufficientValue(uint256 expected, uint256 actual);\\n\\n/// @dev submission cost provided isn't enough to create retryable ticket\\nerror InsufficientSubmissionCost(uint256 expected, uint256 actual);\\n\\n/// @dev address not allowed to interact with the given contract\\nerror NotAllowedOrigin(address origin);\\n\\n/// @dev used to convey retryable tx data in eth calls without requiring a tx trace\\n/// this follows a pattern similar to EIP-3668 where reverts surface call information\\nerror RetryableData(\\n    address from,\\n    address to,\\n    uint256 l2CallValue,\\n    uint256 deposit,\\n    uint256 maxSubmissionCost,\\n    address excessFeeRefundAddress,\\n    address callValueRefundAddress,\\n    uint256 gasLimit,\\n    uint256 maxFeePerGas,\\n    bytes data\\n);\\n\\n/// @dev Thrown when a L1 chainId fork is detected\\nerror L1Forked();\\n\\n/// @dev Thrown when a L1 chainId fork is not detected\\nerror NotForked();\\n\\n/// @dev The provided gasLimit is larger than uint64\\nerror GasLimitTooLarge();\\n\\n// Outbox Errors\\n\\n/// @dev The provided proof was too long\\n/// @param proofLength The length of the too-long proof\\nerror ProofTooLong(uint256 proofLength);\\n\\n/// @dev The output index was greater than the maximum\\n/// @param index The output index\\n/// @param maxIndex The max the index could be\\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\\n\\n/// @dev The calculated root does not exist\\n/// @param root The calculated root\\nerror UnknownRoot(bytes32 root);\\n\\n/// @dev The record has already been spent\\n/// @param index The index of the spent record\\nerror AlreadySpent(uint256 index);\\n\\n/// @dev A call to the bridge failed with no return data\\nerror BridgeCallFailed();\\n\\n// Sequencer Inbox Errors\\n\\n/// @dev Thrown when someone attempts to read fewer messages than have already been read\\nerror DelayedBackwards();\\n\\n/// @dev Thrown when someone attempts to read more messages than exist\\nerror DelayedTooFar();\\n\\n/// @dev Force include can only read messages more blocks old than the delay period\\nerror ForceIncludeBlockTooSoon();\\n\\n/// @dev Force include can only read messages more seconds old than the delay period\\nerror ForceIncludeTimeTooSoon();\\n\\n/// @dev The message provided did not match the hash in the delayed inbox\\nerror IncorrectMessagePreimage();\\n\\n/// @dev This can only be called by the batch poster\\nerror NotBatchPoster();\\n\\n/// @dev The sequence number provided to this message was inconsistent with the number of batches already included\\nerror BadSequencerNumber(uint256 stored, uint256 received);\\n\\n/// @dev The sequence message number provided to this message was inconsistent with the previous one\\nerror BadSequencerMessageNumber(uint256 stored, uint256 received);\\n\\n/// @dev Tried to create an already valid Data Availability Service keyset\\nerror AlreadyValidDASKeyset(bytes32);\\n\\n/// @dev Tried to use or invalidate an already invalid Data Availability Service keyset\\nerror NoSuchKeyset(bytes32);\\n\\n/// @dev Thrown when the provided address is not the designated batch poster manager\\nerror NotBatchPosterManager(address);\\n\\n/// @dev Thrown when a data blob feature is attempted to be used on a chain that doesnt support it\\nerror DataBlobsNotSupported();\\n\\n/// @dev Thrown when an init param was supplied as empty\\nerror InitParamZero(string name);\\n\\n/// @dev Thrown when data hashes where expected but not where present on the tx\\nerror MissingDataHashes();\\n\\n/// @dev Thrown when rollup is not updated with updateRollupAddress\\nerror RollupNotChanged();\\n\\n/// @dev Unsupported header flag was provided\\nerror InvalidHeaderFlag(bytes1);\\n\\n/// @dev SequencerInbox and Bridge are not in the same feeToken/ETH mode\\nerror NativeTokenMismatch();\\n\\n/// @dev Thrown when a deprecated function is called\\nerror Deprecated();\\n\\n/// @dev Thrown when any component of maxTimeVariation is over uint64\\nerror BadMaxTimeVariation();\\n\"\r\n    },\r\n    \"src/libraries/MessageTypes.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nuint8 constant L2_MSG = 3;\\nuint8 constant L1MessageType_L2FundedByL1 = 7;\\nuint8 constant L1MessageType_submitRetryableTx = 9;\\nuint8 constant L1MessageType_ethDeposit = 12;\\nuint8 constant L1MessageType_batchPostingReport = 13;\\nuint8 constant L2MessageType_unsignedEOATx = 0;\\nuint8 constant L2MessageType_unsignedContractTx = 1;\\n\\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\\n\"\r\n    },\r\n    \"src/precompiles/ArbGasInfo.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/// @title Provides insight into the cost of using the chain.\\n/// @notice These methods have been adjusted to account for Nitro's heavy use of calldata compression.\\n/// Of note to end-users, we no longer make a distinction between non-zero and zero-valued calldata bytes.\\n/// Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006c.\\ninterface ArbGasInfo {\\n    /// @notice Get gas prices for a provided aggregator\\n    /// @return return gas prices in wei\\n    ///        (\\n    ///            per L2 tx,\\n    ///            per L1 calldata byte\\n    ///            per storage allocation,\\n    ///            per ArbGas base,\\n    ///            per ArbGas congestion,\\n    ///            per ArbGas total\\n    ///        )\\n    function getPricesInWeiWithAggregator(address aggregator)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get gas prices. Uses the caller's preferred aggregator, or the default if the caller doesn't have a preferred one.\\n    /// @return return gas prices in wei\\n    ///        (\\n    ///            per L2 tx,\\n    ///            per L1 calldata byte\\n    ///            per storage allocation,\\n    ///            per ArbGas base,\\n    ///            per ArbGas congestion,\\n    ///            per ArbGas total\\n    ///        )\\n    function getPricesInWei()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get prices in ArbGas for the supplied aggregator\\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\\n    function getPricesInArbGasWithAggregator(address aggregator)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get prices in ArbGas. Assumes the callers preferred validator, or the default if caller doesn't have a preferred one.\\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\\n    function getPricesInArbGas()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get the gas accounting parameters. `gasPoolMax` is always zero, as the exponential pricing model has no such notion.\\n    /// @return (speedLimitPerSecond, gasPoolMax, maxTxGasLimit)\\n    function getGasAccountingParams()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    /// @notice Get the minimum gas price needed for a tx to succeed\\n    function getMinimumGasPrice() external view returns (uint256);\\n\\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\\n    function getL1BaseFeeEstimate() external view returns (uint256);\\n\\n    /// @notice Get how slowly ArbOS updates its estimate of the L1 basefee\\n    function getL1BaseFeeEstimateInertia() external view returns (uint64);\\n\\n    /// @notice Get the L1 pricer reward rate, in wei per unit\\n    /// Available in ArbOS version 11\\n    function getL1RewardRate() external view returns (uint64);\\n\\n    /// @notice Get the L1 pricer reward recipient\\n    /// Available in ArbOS version 11\\n    function getL1RewardRecipient() external view returns (address);\\n\\n    /// @notice Deprecated -- Same as getL1BaseFeeEstimate()\\n    function getL1GasPriceEstimate() external view returns (uint256);\\n\\n    /// @notice Get L1 gas fees paid by the current transaction\\n    function getCurrentTxL1GasFees() external view returns (uint256);\\n\\n    /// @notice Get the backlogged amount of gas burnt in excess of the speed limit\\n    function getGasBacklog() external view returns (uint64);\\n\\n    /// @notice Get how slowly ArbOS updates the L2 basefee in response to backlogged gas\\n    function getPricingInertia() external view returns (uint64);\\n\\n    /// @notice Get the forgivable amount of backlogged gas ArbOS will ignore when raising the basefee\\n    function getGasBacklogTolerance() external view returns (uint64);\\n\\n    /// @notice Returns the surplus of funds for L1 batch posting payments (may be negative).\\n    function getL1PricingSurplus() external view returns (int256);\\n\\n    /// @notice Returns the base charge (in L1 gas) attributed to each data batch in the calldata pricer\\n    function getPerBatchGasCharge() external view returns (int64);\\n\\n    /// @notice Returns the cost amortization cap in basis points\\n    function getAmortizedCostCapBips() external view returns (uint64);\\n\\n    /// @notice Returns the available funds from L1 fees\\n    function getL1FeesAvailable() external view returns (uint256);\\n\\n    /// @notice Returns the equilibration units parameter for L1 price adjustment algorithm\\n    /// Available in ArbOS version 20\\n    function getL1PricingEquilibrationUnits() external view returns (uint256);\\n\\n    /// @notice Returns the last time the L1 calldata pricer was updated.\\n    /// Available in ArbOS version 20\\n    function getLastL1PricingUpdateTime() external view returns (uint64);\\n\\n    /// @notice Returns the amount of L1 calldata payments due for rewards (per the L1 reward rate)\\n    /// Available in ArbOS version 20\\n    function getL1PricingFundsDueForRewards() external view returns (uint256);\\n\\n    /// @notice Returns the amount of L1 calldata posted since the last update.\\n    /// Available in ArbOS version 20\\n    function getL1PricingUnitsSinceUpdate() external view returns (uint64);\\n\\n    /// @notice Returns the L1 pricing surplus as of the last update (may be negative).\\n    /// Available in ArbOS version 20\\n    function getLastL1PricingSurplus() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"src/precompiles/ArbSys.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title System level functionality\\n * @notice For use by contracts to interact with core L2-specific functionality.\\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\\n */\\ninterface ArbSys {\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\\n     * @return block hash\\n     */\\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\\n\\n    /**\\n     * @notice Gets the rollup's unique chain identifier\\n     * @return Chain identifier as int\\n     */\\n    function arbChainID() external view returns (uint256);\\n\\n    /**\\n     * @notice Get internal version number identifying an ArbOS build\\n     * @return version number as int\\n     */\\n    function arbOSVersion() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns 0 since Nitro has no concept of storage gas\\n     * @return uint 0\\n     */\\n    function getStorageGasAvailable() external view returns (uint256);\\n\\n    /**\\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\\n     * @dev this call has been deprecated and may be removed in a future release\\n     * @return true if current execution frame is not a call by another L2 contract\\n     */\\n    function isTopLevelCall() external view returns (bool);\\n\\n    /**\\n     * @notice map L1 sender contract address to its L2 alias\\n     * @param sender sender address\\n     * @param unused argument no longer used\\n     * @return aliased sender address\\n     */\\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused)\\n        external\\n        pure\\n        returns (address);\\n\\n    /**\\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\\n     * @return true iff the caller's address is an alias for an L1 contract address\\n     */\\n    function wasMyCallersAddressAliased() external view returns (bool);\\n\\n    /**\\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\\n     * @return address of the caller's caller, without applying L1 contract address aliasing\\n     */\\n    function myCallersAddressWithoutAliasing() external view returns (address);\\n\\n    /**\\n     * @notice Send given amount of Eth to dest from sender.\\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\\n     * @param destination recipient address on L1\\n     * @return unique identifier for this L2-to-L1 transaction.\\n     */\\n    function withdrawEth(address destination) external payable returns (uint256);\\n\\n    /**\\n     * @notice Send a transaction to L1\\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\\n     * to a contract address without any code (as enforced by the Bridge contract).\\n     * @param destination recipient address on L1\\n     * @param data (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata data)\\n        external\\n        payable\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get send Merkle tree state\\n     * @return size number of sends in the history\\n     * @return root root hash of the send history\\n     * @return partials hashes of partial subtrees in the send history tree\\n     */\\n    function sendMerkleTreeState()\\n        external\\n        view\\n        returns (\\n            uint256 size,\\n            bytes32 root,\\n            bytes32[] memory partials\\n        );\\n\\n    /**\\n     * @notice creates a send txn from L2 to L1\\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\\n     */\\n    event L2ToL1Tx(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed hash,\\n        uint256 indexed position,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n\\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\\n    event L2ToL1Transaction(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed uniqueId,\\n        uint256 indexed batchNumber,\\n        uint256 indexInBatch,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n\\n    /**\\n     * @notice logs a merkle branch for proof synthesis\\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\\n     * @param hash the merkle hash\\n     * @param position = (level << 192) + leaf\\n     */\\n    event SendMerkleUpdate(\\n        uint256 indexed reserved,\\n        bytes32 indexed hash,\\n        uint256 indexed position\\n    );\\n\\n    error InvalidBlockNumber(uint256 requested, uint256 current);\\n}\\n\"\r\n    },\r\n    \"src/rollup/AbsRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IEthBridge.sol\\\";\\nimport \\\"../precompiles/ArbGasInfo.sol\\\";\\nimport \\\"../libraries/ArbitrumChecker.sol\\\";\\nimport \\\"../bridge/IDelayedMessageProvider.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {INITIALIZATION_MSG_TYPE} from \\\"../libraries/MessageTypes.sol\\\";\\nimport {AlreadyInit, HadZeroInit, RollupNotChanged} from \\\"../libraries/Error.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\nabstract contract AbsRollupEventInbox is\\n    IRollupEventInbox,\\n    IDelayedMessageProvider,\\n    DelegateCallAware\\n{\\n    IBridge public override bridge;\\n    address public override rollup;\\n\\n    modifier onlyRollup() {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        _;\\n    }\\n\\n    function initialize(IBridge _bridge) external override onlyDelegated {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        if (address(_bridge) == address(0)) revert HadZeroInit();\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    /// @notice Allows the rollup owner to sync the rollup address\\n    function updateRollupAddress() external {\\n        if (msg.sender != IOwnable(rollup).owner())\\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\\n        address newRollup = address(bridge.rollup());\\n        if (rollup == newRollup) revert RollupNotChanged();\\n        rollup = newRollup;\\n    }\\n\\n    function rollupInitialized(uint256 chainId, string calldata chainConfig)\\n        external\\n        override\\n        onlyRollup\\n    {\\n        require(bytes(chainConfig).length > 0, \\\"EMPTY_CHAIN_CONFIG\\\");\\n        uint8 initMsgVersion = 1;\\n        uint256 currentDataCost = block.basefee;\\n        if (ArbitrumChecker.runningOnArbitrum()) {\\n            currentDataCost += ArbGasInfo(address(0x6c)).getL1BaseFeeEstimate();\\n        }\\n        bytes memory initMsg = abi.encodePacked(\\n            chainId,\\n            initMsgVersion,\\n            currentDataCost,\\n            chainConfig\\n        );\\n        uint256 num = _enqueueInitializationMsg(initMsg);\\n        emit InboxMessageDelivered(num, initMsg);\\n    }\\n\\n    function _enqueueInitializationMsg(bytes memory initMsg) internal virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function updateRollupAddress() external;\\n\\n    function rollupInitialized(uint256 chainId, string calldata chainConfig) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AbsRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IEthBridge.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\ncontract RollupEventInbox is AbsRollupEventInbox {\\n    constructor() AbsRollupEventInbox() {}\\n\\n    function _enqueueInitializationMsg(bytes memory initMsg) internal override returns (uint256) {\\n        return\\n            IEthBridge(address(bridge)).enqueueDelayedMessage(\\n                INITIALIZATION_MSG_TYPE,\\n                address(0),\\n                keccak256(initMsg)\\n            );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollupNotChanged\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"chainConfig\",\"type\":\"string\"}],\"name\":\"rollupInitialized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RollupEventInbox", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}