{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CXCPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface Aggregator {\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\nabstract contract Pausable is Context {\\n    event Paused(address account);\\n\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\\ncontract CXCPresale is Ownable, Pausable {\\n    IERC20 public token;\\n    IERC20 public usdt;\\n\\n    uint256 public maxTokensToBuy;\\n    uint256 public totalTokensSold;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public currentStep;\\n    uint256 public referralPercentage;\\n    uint256 public totalReferralAmount;\\n    uint256 public withdrawReferralAmount;\\n\\n    Aggregator public aggregatorInterface;\\n\\n    event MaxTokensUpdated(\\n        uint256 prevValue,\\n        uint256 newValue,\\n        uint256 timestamp\\n    );\\n    event WithdrawReferralRewards(\\n        address indexed user,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    constructor() {\\n        token = IERC20(0x7FcF94C0EA1628f654DDe5ccBfBddC69208bb196);\\n        usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\n        aggregatorInterface = Aggregator(\\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\\n        );\\n        maxTokensToBuy = 25000 ether;\\n        startTime = 1693728000;\\n        endTime = 1696132740;\\n        referralPercentage = 1000;\\n        setRounds();\\n    }\\n\\n    struct round {\\n        uint256 amount;\\n        uint256 rate;\\n        uint256 soldToken;\\n    }\\n\\n    struct user {\\n        uint256 amount;\\n        uint256 remaining;\\n        uint256 buyTime;\\n        uint256 checkTime;\\n        uint256 quarter;\\n    }\\n    mapping(address => user[]) public deposits;\\n    mapping(address => uint256) private _referralRewards;\\n    mapping(address => bool) private checkReferral;\\n\\n    round[] public rounds;\\n\\n    function setRounds() private {\\n        rounds.push(round({amount: 25000000 ether, rate: 3030, soldToken: 0}));\\n        rounds.push(round({amount: 40000000 ether, rate: 2500, soldToken: 0}));\\n        rounds.push(round({amount: 10000000 ether, rate: 1739, soldToken: 0}));\\n    }\\n\\n    function setcurrentStep(uint256 step) public onlyOwner {\\n        round storage setRound = rounds[step];\\n        require(step < rounds.length, \\\"Invalid rounds Id\\\");\\n        require(step != currentStep, \\\"This round is already active\\\");\\n        uint256 ourAllowance = token.allowance(_msgSender(), address(this));\\n        require(\\n            setRound.amount <= ourAllowance,\\n            \\\"Make sure to add enough allowance\\\"\\n        );\\n        token.transferFrom(_msgSender(), address(this), setRound.amount);\\n        currentStep = step;\\n    }\\n\\n    function updateRounds(\\n        uint256 step,\\n        uint256 amount,\\n        uint256 rate\\n    ) external onlyOwner {\\n        require(step < rounds.length, \\\"Invalid rounds Id\\\");\\n        require(amount > 0 || rate > 0, \\\"Invalid value\\\");\\n        round storage setRound = rounds[step];\\n        if (amount > 0) setRound.amount = amount;\\n        if (rate > 0) setRound.rate = rate;\\n    }\\n\\n    function changeMaxTokensToBuy(uint256 _maxTokensToBuy) external onlyOwner {\\n        require(_maxTokensToBuy > 0, \\\"Zero max tokens to buy value\\\");\\n        maxTokensToBuy = _maxTokensToBuy;\\n        emit MaxTokensUpdated(maxTokensToBuy, _maxTokensToBuy, block.timestamp);\\n    }\\n\\n    function changeSaleStartTime(uint256 _startTime) external onlyOwner {\\n        require(block.timestamp < _startTime, \\\"Sale time in past\\\");\\n        startTime = _startTime;\\n    }\\n\\n    function changeSaleEndTime(uint256 _endTime) external onlyOwner {\\n        require(_endTime > startTime, \\\"Invalid endTime\\\");\\n        endTime = _endTime;\\n    }\\n\\n    function updateReferralPercentage(\\n        uint256 _newPercentage\\n    ) external onlyOwner {\\n        referralPercentage = _newPercentage;\\n    }\\n\\n    function pause() external onlyOwner returns (bool success) {\\n        _pause();\\n        return true;\\n    }\\n\\n    function unpause() external onlyOwner returns (bool success) {\\n        _unpause();\\n        return true;\\n    }\\n\\n    function withdrawETH() public onlyOwner {\\n        require(address(this).balance > 0, \\\"contract balance is 0\\\");\\n        payable(owner()).transfer(address(this).balance);\\n    }\\n\\n    function withdrawTokens(address _token, uint256 amount) external onlyOwner {\\n        require(isContract(_token), \\\"Invalid contract address\\\");\\n        require(\\n            IERC20(_token).balanceOf(address(this)) >= amount,\\n            \\\"Insufficient tokens\\\"\\n        );\\n        IERC20(_token).transfer(_msgSender(), amount);\\n    }\\n\\n    function isContract(address _addr) private view returns (bool iscontract) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    modifier checkSaleState(uint256 amount) {\\n        require(\\n            block.timestamp >= startTime && block.timestamp <= endTime,\\n            \\\"Invalid time for buying\\\"\\n        );\\n        require(amount > 0, \\\"Invalid amount\\\");\\n        _;\\n    }\\n\\n    modifier checkClaimTime(uint256 id) {\\n        user memory users = deposits[_msgSender()][id];\\n        require(users.remaining > 0, \\\"You have no remaining tokens\\\");\\n        require(\\n            block.timestamp > users.checkTime + 91.31 days,\\n            \\\"claim time not reached yet\\\"\\n        );\\n        _;\\n    }\\n\\n    function removeId(uint256 indexnum) internal {\\n        for (uint256 i = indexnum; i < deposits[_msgSender()].length - 1; i++) {\\n            deposits[_msgSender()][i] = deposits[_msgSender()][i + 1];\\n        }\\n        deposits[_msgSender()].pop();\\n    }\\n\\n    function buyWithUSDT(\\n        uint256 amount,\\n        address _referral\\n    ) external checkSaleState(amount) whenNotPaused {\\n        uint256 numOfTokens = calculateToken(amount * 1e12);\\n        require(numOfTokens <= maxTokensToBuy, \\\"max tokens buy\\\");\\n        uint256 ourAllowance = usdt.allowance(_msgSender(), address(this));\\n        require(amount <= ourAllowance, \\\"Make sure to add enough allowance\\\");\\n        uint256 instantTokens = (numOfTokens * 20) / 100;\\n        uint256 remaingTokens = numOfTokens - instantTokens;\\n        usdt.transferFrom(_msgSender(), address(this), amount);\\n        token.transfer(_msgSender(), instantTokens);\\n        deposits[_msgSender()].push(\\n            user(\\n                numOfTokens,\\n                remaingTokens,\\n                block.timestamp,\\n                block.timestamp,\\n                0\\n            )\\n        );\\n        referralAmount(numOfTokens, _referral);\\n        rounds[currentStep].soldToken += numOfTokens;\\n        totalTokensSold += numOfTokens;\\n    }\\n\\n    function buyWithETH(\\n        address _referral\\n    ) external payable checkSaleState(msg.value) whenNotPaused {\\n        uint256 ethToUsdt = (getLatestPrice() * msg.value) / 1e8;\\n        uint256 numOfTokens = calculateToken(ethToUsdt);\\n        require(numOfTokens <= maxTokensToBuy, \\\"max tokens buy\\\");\\n        uint256 instantTokens = (numOfTokens * 20) / 100;\\n        token.transfer(_msgSender(), instantTokens);\\n        uint256 remaingTokens = numOfTokens - instantTokens;\\n        deposits[_msgSender()].push(\\n            user(\\n                numOfTokens,\\n                remaingTokens,\\n                block.timestamp,\\n                block.timestamp,\\n                0\\n            )\\n        );\\n        referralAmount(numOfTokens, _referral);\\n        rounds[currentStep].soldToken += numOfTokens;\\n        totalTokensSold += numOfTokens;\\n    }\\n\\n    function claim(uint256 id) external checkClaimTime(id) {\\n        require(id < deposits[_msgSender()].length, \\\"Not enough records\\\");\\n        user storage users = deposits[_msgSender()][id];\\n        uint256 quartersTokens = (users.amount * 10) / 100;\\n        token.transfer(_msgSender(), quartersTokens);\\n        users.remaining = users.remaining - quartersTokens;\\n        users.checkTime = block.timestamp;\\n        users.quarter += 1;\\n        if (users.quarter == 8) {\\n            removeId(id);\\n        }\\n    }\\n\\n    function withdrawReferral() external whenNotPaused {\\n        uint256 rewards = _referralRewards[_msgSender()];\\n        require(rewards > 0, \\\"You do not have referral rewards.\\\");\\n        token.transfer(_msgSender(), rewards);\\n        withdrawReferralAmount += rewards;\\n        emit WithdrawReferralRewards(_msgSender(), rewards, block.timestamp);\\n        _referralRewards[_msgSender()] = 0;\\n    }\\n\\n    function referralAmount(uint256 amount, address _referral) private {\\n        if (\\n            !checkReferral[_msgSender()] &&\\n            _referral != address(0) &&\\n            _referral != _msgSender()\\n        ) {\\n            uint256 refferTax = (amount * referralPercentage) / 10000;\\n            _referralRewards[_referral] += refferTax;\\n            totalReferralAmount += refferTax;\\n        }\\n        checkReferral[_msgSender()] = true;\\n    }\\n\\n    function getContractBalacne() public view returns (uint256 cxc) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    function calculateToken(uint256 _usdtAmount) public view returns (uint256) {\\n        uint256 numOfTokens = _usdtAmount * rounds[currentStep].rate;\\n        return (numOfTokens / 100);\\n    }\\n\\n    function ethBuyHelper(\\n        uint256 amount\\n    ) public view returns (uint256 numOfTokens) {\\n        uint256 ethToUsdt = (getLatestPrice() * amount) / 1e8;\\n        numOfTokens = calculateToken(ethToUsdt);\\n    }\\n\\n    function usdtBuyHelper(\\n        uint256 amount\\n    ) public view returns (uint256 numOfTokens) {\\n        numOfTokens = calculateToken(amount * 1e12);\\n    }\\n\\n    function getLatestPrice() public view returns (uint256) {\\n        (, int256 price, , , ) = aggregatorInterface.latestRoundData();\\n        return uint256(price);\\n    }\\n\\n    function getCxcBalance() public view returns (uint256 cxcBalance) {\\n        cxcBalance = token.balanceOf(address(this));\\n    }\\n\\n    function getUsdtBalance() public view returns (uint256 cxcBalance) {\\n        cxcBalance = usdt.balanceOf(address(this));\\n    }\\n\\n    function getEthBalance() public view returns (uint256 ETH) {\\n        ETH = address(this).balance;\\n    }\\n\\n    function totalRounds() public view returns (uint256 _rounds) {\\n        _rounds = rounds.length;\\n    }\\n\\n    function referralOf(address account) external view returns (uint256) {\\n        return _referralRewards[account];\\n    }\\n\\n    function userDepositIndex(address _user) public view returns (uint256) {\\n        return deposits[_user].length;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MaxTokensUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawReferralRewards\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aggregatorInterface\",\"outputs\":[{\"internalType\":\"contract Aggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"buyWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"buyWithUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"calculateToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTokensToBuy\",\"type\":\"uint256\"}],\"name\":\"changeMaxTokensToBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeSaleEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"changeSaleStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quarter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ethBuyHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numOfTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalacne\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cxc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCxcBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cxcBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cxcBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensToBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"referralOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"soldToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"step\",\"type\":\"uint256\"}],\"name\":\"setcurrentStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReferralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_rounds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPercentage\",\"type\":\"uint256\"}],\"name\":\"updateReferralPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"step\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateRounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"usdtBuyHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numOfTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userDepositIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReferralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CXCPresale", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}