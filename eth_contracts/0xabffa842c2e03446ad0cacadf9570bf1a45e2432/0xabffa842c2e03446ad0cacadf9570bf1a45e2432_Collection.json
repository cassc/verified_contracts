{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Collection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./utils/Base64.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\n\\nimport \\\"./CollectionDescriptor.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract Collection is ERC721 {\\n\\n    address public owner = 0xaF69610ea9ddc95883f97a6a3171d52165b69B03; // for opensea integration. doesn't do anything else.\\n\\n    address public collector; // address authorised to withdraw funds recipient\\n    address payable public recipient; // in this instance, it will be a mirror split on mainnet (to be deployed)\\n\\n    // minting time\\n    uint256 public startDate;\\n    uint256 public endDate;\\n\\n    CollectionDescriptor public descriptor;\\n\\n    mapping (address => bool) public claimed;\\n    bytes32 public loyaltyRoot;\\n\\n    // todo: for testing\\n    // uint256 public newlyMinted;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_, address collector_, address payable recipient_, uint256 startDate_, uint256 endDate_, bytes32 root_) ERC721(name_, symbol_) {\\n        collector = collector_; \\n        recipient = recipient_;\\n        startDate = startDate_;\\n        endDate = endDate_;\\n        descriptor = new CollectionDescriptor();\\n        loyaltyRoot = root_;\\n\\n        // mint first claim UF. It's a known address in the merkle tree to populate NFT marketplaces before launch\\n        _createNFT(owner);\\n        claimed[owner] =  true;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory name = descriptor.generateName(tokenId); \\n        string memory description = \\\"Ceramic beings with simulated souls collected by the Martian, Nyx.\\\";\\n\\n        string memory image = generateBase64Image(tokenId);\\n        string memory attributes = generateTraits(tokenId);\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"', \\n                            name,\\n                            '\\\", \\\"description\\\":\\\"', \\n                            description,\\n                            '\\\", \\\"image\\\": \\\"', \\n                            'data:image/svg+xml;base64,', \\n                            image,'\\\",',\\n                            attributes,\\n                            '}'\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function generateBase64Image(uint256 tokenId) public view returns (string memory) {\\n        bytes memory img = bytes(generateImage(tokenId));\\n        return Base64.encode(img);\\n    }\\n\\n    function generateImage(uint256 tokenId) public view returns (string memory) {\\n        return descriptor.generateImage(tokenId);\\n    }\\n\\n    function generateTraits(uint256 tokenId) public view returns (string memory) {\\n        return descriptor.generateTraits(tokenId);\\n    }\\n\\n    function mint() public payable {\\n        require(msg.value >= 0.032 ether, 'MORE ETH NEEDED'); //~$100\\n        _mint(msg.sender);\\n    }\\n\\n    function loyalMint(bytes32[] calldata proof) public {\\n        loyalMintLeaf(proof, msg.sender);\\n    }\\n\\n    // anyone can mint for someone in the merkle tree\\n    // you just need the correct proof\\n    function loyalMintLeaf(bytes32[] calldata proof, address leaf) public {\\n        // if one of addresses in the overlap set\\n        require(claimed[leaf] == false, \\\"Already claimed\\\");\\n        claimed[leaf] = true;\\n\\n        bytes32 hashedLeaf = keccak256(abi.encodePacked(leaf));\\n        require(MerkleProof.verify(proof, loyaltyRoot, hashedLeaf), \\\"Invalid Proof\\\");\\n        _mint(leaf);\\n    }\\n\\n    // internal mint\\n    function _mint(address _owner) internal {\\n        require(block.timestamp > startDate, \\\"NOT_STARTED\\\"); // ~ 2000 gas\\n        require(block.timestamp < endDate, \\\"ENDED\\\");\\n        _createNFT(_owner);\\n    }\\n\\n    function _createNFT(address _owner) internal {\\n        uint256 tokenId = uint(keccak256(abi.encodePacked(block.timestamp, _owner)));\\n        super._mint(_owner, tokenId);\\n    }\\n\\n    function withdrawETH() public {\\n        require(msg.sender == collector, \\\"NOT_COLLECTOR\\\");\\n        recipient.call{value: address(this).balance}(\\\"\\\"); // this is safe because the recipient is known\\n    }\\n}\"\r\n    },\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC721.sol\\\";\\nimport \\\"./interfaces/IERC721Receiver.sol\\\";\\nimport \\\"./interfaces/IERC721Metadata.sol\\\";\\nimport \\\"./utils/Address.sol\\\";\\n// import \\\"../../utils/Context.sol\\\";\\nimport \\\"./utils/Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n            || interfaceId == type(IERC721Metadata).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n            : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty \\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        // _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        // _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        // _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    // modified from ERC721 template:\\n    // removed BeforeTokenTransfer\\n}\"\r\n    },\r\n    \"contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal view returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            // console.logBytes32(computedHash);\\n            // console.logBytes32(proofElement);\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                //computedHash = _efficientHash(computedHash, proofElement);\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                // computedHash = _efficientHash(proofElement, computedHash);\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/CollectionDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/*\\nContract that's primarily responsible for generating the metadata, including the image itself in SVG.\\nParts of the SVG is encapsulated into custom re-usable components specific to this collection.\\n*/\\n\\n/*\\nLittle Martians have the following randomised components.\\n\\n1) 1 of 10 hardcoded shells.\\n2) Degree of blur + random seed. \\n3) Step pattern with 2 vars + random seed.\\n4) Background pattern\\n5) Foreground pattern with colour shifting + alpha slope\\n*/\\ncontract CollectionDescriptor {\\n\\n    function generateName(uint nr) public pure returns (string memory) {\\n        return string(abi.encodePacked('Little Martian #', substring(toString(nr),0,8)));\\n    }\\n\\n    function generateTraits(uint256 tokenId) public pure returns (string memory) {\\n        bytes memory hash = abi.encodePacked(bytes32(tokenId));\\n        uint256 index = uint256(toUint8(hash,0))*100/256; // 0 - 100\\n        string memory ceramicType = '{\\\"trait_type\\\": \\\"Ceramic Shell\\\", \\\"value\\\":';\\n        string memory ceramicValue = \\\"\\\";\\n\\n        if(index < 10) { ceramicValue = '\\\"Type One\\\"}'; }\\n        if(index < 20) { ceramicValue = '\\\"Type Two\\\"}'; }\\n        if(index < 30) { ceramicValue = '\\\"Type Three\\\"}'; }\\n        if(index < 40) { ceramicValue = '\\\"Type Four\\\"}'; }\\n        if(index < 50) { ceramicValue = '\\\"Type Five\\\"}'; }\\n        if(index < 60) { ceramicValue = '\\\"Type Six\\\"}'; }\\n        if(index < 70) { ceramicValue = '\\\"Type Seven\\\"}'; }\\n        if(index < 80) { ceramicValue = '\\\"Type Eight\\\"}'; }\\n        if(index < 90) { ceramicValue = '\\\"Type Nine\\\"}'; }\\n        if(index < 100) { ceramicValue = '\\\"Type Ten\\\"}'; }\\n\\n        return string(abi.encodePacked(\\n            '\\\"attributes\\\": [',\\n            ceramicType,\\n            ceramicValue,\\n            ']'\\n        ));\\n    }\\n\\n    function generateImage(uint256 tokenId) public pure returns (string memory) {\\n        bytes memory hash = abi.encodePacked(bytes32(tokenId));\\n        uint256 fillI = uint256(toUint8(hash,1));\\n        string memory fill = 'none';\\n        if(fillI < 128) { fill = 'white'; }\\n        return string(\\n            abi.encodePacked(\\n                '<svg width=\\\"480\\\" height=\\\"460\\\" viewBox=\\\"0 0 480 460\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">',\\n                '<style type=\\\"text/css\\\">.c{fill:white}</style>',\\n                '<rect width=\\\"480\\\" height=\\\"460\\\" fill=\\\"black\\\"/>',\\n                generatePath(hash),\\n                generateBlur(hash),\\n                generateSteps(hash),\\n                generateTurbs1(hash),\\n                generateTurbs2(hash),\\n                svgRect(\\\"0.7\\\", \\\"blur\\\", fill),\\n                svgRect(\\\"0.5\\\", \\\"steps\\\", 'none'),\\n                svgRect(\\\"1\\\", \\\"turb1\\\", 'none'),\\n                svgRect(\\\"0.7\\\", \\\"turb2\\\", 'none'),\\n                generateFace(hash),\\n                '</svg>'\\n            )\\n        );\\n    }\\n\\n    function generatePath(bytes memory hash) public pure returns (string memory) {\\n        uint256 index = uint256(toUint8(hash,0))*100/256; // 0 - 100\\n        string memory path;\\n\\n        if(index < 10) { path = \\\"M189 49c-23 7-35 24-40 32-12 16-15 31-17 41-6 26 1 29-2 73-1 13-2 21-1 35s4 26 5 33l14 42 11 28 6 12c1 3 5 11 18 27l13 15c14 9 29 6 31 5 9-2 15-7 20-11 10-8 15-17 24-35 6-10 9-16 11-23 6-17 2-20 8-35 6-14 11-13 14-26 2-8 1-11 4-21 3-8 5-9 5-15 0-7-2-8-4-17-2-11 1-13 0-27-2-11-4-12-3-17 2-9 8-11 11-19 4-10 0-21-2-27-2-4-3-6-22-30l-16-18c-4-3-10-9-19-14-3-2-13-7-27-10-8-1-24-4-42 2z\\\"; }\\n        else if(index < 20) { path = \\\"M240 23c17 3 25 5 35 11 13 8 19 17 29 33a197 197 0 0135 106c2 21 2 31 0 40-3 9-8 16-10 31l-2 14c0 4-3 18-10 31-3 7-9 13-22 27-13 12-17 15-21 24-3 6-2 9-6 15-4 7-8 12-14 17-9 10-11 9-22 19-9 9-8 10-14 14-8 6-17 9-25 10-14 1-25-7-45-23-10-8-40-32-43-57l-1-11-3-29c-3-22-8-23-9-37 0-13 3-13 7-38 4-20 1-21 5-53 3-24 4-20 5-34 1-22-1-32 4-48l8-18c2-3 8-14 20-25 6-5 20-17 41-22 18-5 33-2 58 3z\\\"; }\\n        else if(index < 30) { path = \\\"M188 21c3-1 43 1 60 4 33 6 70 47 79 65 2 5 17 60 17 81 0 15-4 3-4 44 0 24-6 40-16 61-9 26-7 34-18 60a113 113 0 01-50 63c-12 7-23 14-40 13-18-1-33-17-37-24-21-37-41-65-45-73-3-8-21-33-25-67-1-12 5-37 4-56-1-29-7-39-4-50 8-26 6-16 11-42 4-20 8-52 26-64 15-12 32-14 42-15z\\\"; }\\n        else if(index < 40) { path = \\\"M71 93v21l1 24c3 22 5 23 9 48l2 13c4 12 13 20 15 23 9 8 21 30 45 74 9 18 13 26 22 36 9 8 16 13 27 20 18 12 45 28 78 32a57 57 0 0049-18c8-9 11-18 16-37 6-21 9-31 6-40-2-6-5-10-6-18l2-18c2-10 6-26 5-42 0-14-5-26-7-33l-10-22c-6-18-2-21-8-32-5-9-8-9-17-22-8-12-9-18-14-25-9-17-23-25-38-33-35-20-69-20-82-19-15 1-36 2-58 16-3 2-35 24-37 52z\\\"; }\\n        else if(index < 50) { path = \\\"M147 43c6-6 14-14 27-18 15-6 30-4 49-1a129 129 0 0193 52c8 13 15 35 15 57 0 17-6 24-7 52v25c-1 6-2 16-15 54l-10 29c-5 20-11 27-14 39-7 23-14 36-21 43-22 24-47 32-53 34-12 4-23-1-32-5-10-5-9-6-23-23-12-15-13-12-20-23-10-13-11-22-18-49-10-40-16-37-18-59-2-25 8-24 6-55 0-20-1-24 1-44 1-10 3-34 7-53 2-8 15-36 33-55z\\\"; }\\n        else if(index < 60) { path = \\\"M135 47c-6 10-14 23-22 52-2 11-4 19-5 38-1 11-6 20-10 31-9 29-9 27-11 39-1 8 1 36 4 55l6 29c4 25 3 28 7 41a216 216 0 0027 58c10 15 14 21 28 25 6 2 15 7 26 6 10-1 25-3 42-11 2-2 11-6 24-17 9-8 28-25 43-54 14-26 8-31 24-55 11-18 16-18 19-31 6-18 2-16 6-41 4-16 1-30 1-43 1-13-2-15-2-31 0-29-2-35-5-47-9-34-51-59-81-68-42-14-101-7-121 24z\\\"; }\\n        else if(index < 70) { path = \\\"M92 75c7-14 15-21 17-23a179 179 0 01104-22c11 1 28 3 49 13 8 4 19 9 31 21 5 3 15 14 24 31l12 33 7 19 11 30c5 17 8 26 8 38 0 14-4 16-10 46-2 14-4 21-4 29-2 26 1 30-1 54-1 6-4 10-8 19-8 17-13 26-21 33-9 7-18 9-27 11-7 1-38 8-62-8-10-6-10-11-26-19l-16-8s-13-6-24-15c-6-4-18-16-39-71l-15-45c-11-29-15-36-17-52v-42c1-47 0-58 7-72z\\\"; }\\n        else if(index < 80) { path = \\\"M174 35c-8 8-7 13-22 30-11 13-15 14-19 22-6 13-2 18-8 33l-15 24c-20 29-22 33-24 39l-5 29c-2 17-1 20-2 41l-5 45-2 35c1 13 2 39 21 58 8 9 17 13 22 15 15 6 28 6 36 6 18 0 30-4 44-9 16-5 25-8 35-16s10-12 25-33c13-16 20-26 31-36 18-17 25-15 39-32 9-10 14-20 17-25 6-14 8-23 14-43 12-43 13-38 15-48 3-30-9-54-17-69-5-11-20-39-51-59-9-6-35-23-71-23-16 0-41 0-58 16z\\\"; }\\n        else if(index < 90) { path = \\\"M223 17c-11 0-42 2-72 23-36 25-63 73-57 111 1 8 5 22 2 42-3 15-7 18-9 31-3 13 0 27 6 53 5 20 9 39 19 62l12 24c8 21 7 25 13 34 2 3 12 17 30 21 15 3 28-2 42-8l19-11a443 443 0 0067-81c9-16 16-27 23-43l15-48c11-33 16-50 17-62 3-20 5-39-2-61-11-37-41-56-52-63-9-7-35-24-73-24z\\\"; }\\n        else if(index < 100) { path = \\\"M194 15c-18 2-20 0-45 4-29 4-31 6-47 12-2 2-25 12-35 35-4 9-5 17-5 22-5 66 24 136 24 136 21 49 32 41 48 85 6 16 11 34 27 52 10 11 19 16 36 27 35 22 54 35 79 30 15-3 27-12 31-15 3-3 17-14 25-34 9-24 2-37 5-76l6-42c6-43 9-52 4-67-4-12-7-10-14-30-6-14-6-19-11-36l-14-34c-10-20-18-37-34-50-32-25-74-20-80-19z\\\"; }\\n\\n        return string(abi.encodePacked(\\n            '<clipPath id=\\\"m\\\"> <path d=\\\"',path,'\\\"/></clipPath>'\\n        ));\\n    }\\n\\n    function generateFace(bytes memory hash) public pure returns (string memory) {\\n        uint256 index = uint256(toUint8(hash,0))*100/256; // 0 - 100\\n        string memory path;\\n\\n        if(index < 10) { path = \\\"M182 223c0-3-4-5-7-6-5-1-8 1-14 3-12 4-19 2-19 4s8 6 17 6c11 1 23-3 23-7zM235 227c0-2 9-5 14-6s11-2 18-1c7 2 16 7 15 10 0 3-9 3-10 4-7 0-10-2-18-4-12-3-18-1-19-3z M241 300c0 2-3 3-4 3-13 6-10 8-21 12-7 3-15 5-25 4-4 0-12-1-18-7-6-5-10-14-10-14 13-9 16-15 16-15l3-6c4-10 2-11 5-19l5-11v-2c6-16 3-31 3-31-1-3-3-14-10-19l-2-2a39 39 0 00-15-5c-2-1-9-2-16 0-8 1-11 4-13 3-1-1 1-8 6-12 8-7 20-4 27-2 5 1 12 2 19 8a40 40 0 0114 31v19c-2 12-2 18-6 26l-5 10c-12 21-14 25-12 29 1 6 7 9 8 10 11 4 23-4 24-5 9-6 9-13 15-14 6 0 12 5 12 9z M174 338c1-2 3-1 27-2h14c4 2 6 4 9 3s2-5 5-7c4-3 7-1 14 1 12 2 17 0 18 1 1 4-15 14-32 19-8 3-16 5-25 4-17-3-31-15-30-19z\\\"; }\\n        else if(index < 20) { path = \\\"M326 200c-1 1-9-6-29-12-23-7-32-5-35-4-3 0-11 3-18 10a38 38 0 00-10 26c0 6 2 6 5 18 1 4 4 16 5 31 1 13-1 13 1 21s5 11 5 18c-1 2-1 8-5 13-7 10-21 10-22 10-10 0-9-5-28-12-9-3-25-11-24-18 1-4 10-12 7-12l8 13c6 9 16 17 27 18 7 1 19 0 24-7 3-7-2-12-6-30s0-17-4-48c-2-13-4-19-2-28 1-5 3-14 11-21 6-5 21-14 40-11 28 5 51 23 50 25zM131 175c16-14 51-8 60-3 3 2 0 1 0 0 0 0-3-9-18-13-4-2-19-2-31 7-6 4-9 6-11 9zM125 210c2-5 20-5 33-3 3 0 16 0 22 11l1 6c1 8 3 10 3 10-4 1-9-5-17-8h-16c-13 0-27-10-26-16z M257 236c0-5 14-10 26-10 19 1 36 14 34 17 0 2-3 1-13 3l-18 3c-13 0-29-7-29-13zM151 355c1-2 5 2 15 4 11 1 21-1 24-1 7-2 10-4 14-2 5 2 5 7 9 7s6-6 12-7l8 2c11 4 20 0 20 1 1 2-10 13-32 21-10 4-14 2-20 2-11 1-20-2-23-4-17-7-27-23-27-23z\\\"; }\\n        else if(index < 30) { path = \\\"M152 205s25 10 37 1c3-2-5-9-8-11-7-3-10-6-14-5-12 2-17 12-15 15zM265 214c-2-2 6-9 17-14 5-2 9-2 11-2 13 0 21 12 21 12 0 3-9 4-10 4-8 2-7-3-15-4-13-2-22 6-24 4zM191 289c-3 1-6 8-3 13s10 6 14 9c2 1 6 4 15 4 6-1 6-4 13-6l14-4c7-2 10-3 10-8s-5-9-5-9 2 7-1 12c-3 4-11 2-19 5-11 5-8 6-18 5-7 0-17-4-21-8-3-3 1-13 1-13zM184 351c-1 1 10 11 26 16l13 2c3 0 10 0 18-5 6-3 12-9 11-11s-8 1-21 4c-8 2-17 3-26 2-13-2-21-9-21-8zM252 175c1 1 10-10 25-12 13-3 26 2 28 3 7 3 12 7 13 6 1-2-4-9-11-14-14-9-32-2-34-1-14 6-21 17-21 18zM144 168c1 2 14-12 30-10 18 2 17 13 26 9 0 0 1-3-4-7-11-5-15-11-34-4-11 4-20 10-18 12zM213 215c1-5 3 27 2 38l-5 18c-1 4-5 5-5 5 2-4 4-6 6-16 2-17 1-40 2-45z\\\"; }\\n        else if(index < 40) { path = \\\"M159 239c0-2 7 0 14-4l4-4 6-7 5-11s4 6 4 11c1 7-5 16-14 19s-19-3-19-4zM270 199c-1-2 6-9 13-12l10-3c7-5 8-12 10-11 2 0 3 9 0 15-4 5-9 7-18 9-4 1-14 4-15 2zM134 218c1 0 3-9 13-16l1-2 16-7c13-5 12-12 21-13 7-1 12 1 12 1s-8-6-15-6c-8 0-8 3-21 10-10 6-9 1-15 6-10 9-13 27-12 27z M305 141s-11-9-23-6c-3 1-5 2-21 18l-13 14c-4 6-11 14-12 26-2 16 7 30 17 45l10 13 2 2 10 10c8 6 16 9 17 9 5 2 7 2 7 4 1 2-3 5-8 9-10 10-8 14-14 18l-20 2c-8 1-8 2-12 1-6-1-15-5-14-7l14 3c14 2 28-3 29-4 7-7 12-14 13-18 1-6-12-3-26-17-6-6-12-12-17-20-9-13-12-24-13-27-4-16-2-28-2-31 1-10 5-16 13-24 5-5 5-9 15-17s10-10 14-12c15-6 34 8 34 9zM245 345s7-11 15-14c4-2 5-1 14-3 7-2 10-3 14-6l8-9c6-7 6-9 9-10 3-2 9-6 11-4 2 1 2 3 0 16l-4 16c-5 8-12 11-18 14-8 3-14 4-19 4-9 1-30-4-30-4z\\\"; }\\n        else if(index < 50) { path = \\\"M126 216l7-6c3-3 6-4 10-4 9-1 7 0 12 1l4 2s4 4 2 4-8 7-15 7c-15 1-20-4-20-4z M124 172c0 1 6-5 12-6 13-1 24 2 33 11l1 1c10 11 10 25 10 28l-4 18-6 28c-1 14 1 21-4 27l-6 6c-5 5-8 6-8 8 0 4 4 6 5 7l9 6 9 5c4 1 6-4 13-6s9 2 18 0c7-1 13-5 12-6l-17 1c-19 1-16 5-23 6-10 0-19-8-20-10-1-6 5-10 10-17 4-5 4-15 5-25 3-24 4-21 7-34 3-10 3-15 2-22-2-17-2-24-17-32-9-5-23-9-32-2-5 4-10 7-9 8zM234 219l10-7c4-2 9-1 13-1 4 1 9 1 16 6l3 5c4 5 9 3 9 4s-4 2-9 2c-4 0-7 0-12-2-6-1-11-5-17-6-11-2-13-1-13-1zM294 190c0 1-4-6-11-11-8-5-15-6-25-6-11-1-21-1-29 5l-5 5c-1-1 1-6 5-9 7-7 19-6 32-4 10 1 16 2 22 6 8 6 11 14 11 14zM236 339c0 4-11 6-20 14l-6 4c-3 2-6 2-7 2-13 1-18 2-23 0-10-3-9-2-12-5l-10-7-9-6c-1-1-5-1-4-2l4-2c6-3 5-1 10-3 4-2 7-3 10-2 5 0 3 2 8 2 4 1 6-2 12-3 4-1 7-1 17 1 19 3 29 5 30 7z\\\"; }\\n        else if(index < 60) { path = \\\"M120 168c0-4 13-5 18-5h13l11-2c2 2 0 8-5 13-7 7-19 4-21 4-8-2-17-7-16-10z M122 126c1 1 10-8 25-7 8 0 14-1 19 1 7 3 13 9 17 15l3 12c1 5 1 11-2 19l-10 28-7 25c-4 14-13 20-16 25-5 8-7 7-9 14-2 3-3 8-1 13 3 4 3 3 9 6l10 7c4 2 7 4 11 3 3 0 3-2 8-3 1-1 6-3 13-2 8 2 9 7 14 7 6 0 12-8 10-10-1-2-1 6-10 5-12-1-12-6-21-6s-12 3-19 2c-6-1-18-6-19-12-1-1-2-7 5-17l9-13c6-7 8-11 12-24 5-16 1-10 5-20l13-31c2-7 1-17-3-27-4-8-6-13-12-17-7-4-17-10-30-8-15 2-25 13-24 15zM128 316c2-3 12-2 17-2l9 2s3 5 7 6c4 2 5-1 10-1 5-1 9 0 14 1 4 1 7 2 15 7l28 15-17 9c-10 3-18 3-25 3-18-1-29-7-32-8-9-5-15-11-17-13-1-1-13-14-9-19zM241 192c0-3 6-6 11-7 6-2 12-1 14-1 7 1 12 4 16 7 7 4 11 8 14 11s8 8 7 9-9-6-23-11c-8-3-16-4-21-5-12-2-17-1-18-3zM316 163s-3-12-13-21l-4-3c-2-2-7-9-18-12l-15-1c-7 0-17 6-17 6 2-2 2-5 13-9 6-2 14-3 24 1 11 4 13 6 19 11 11 11 12 27 11 28z\\\"; }\\n        else if(index < 70) { path = \\\"M329 180s4 0-11-4l-14-3c-3 0-11 1-17 6-1 0-7 5-6 7 1 1 6 0 15-1l17 1c11 0 17-4 16-6z M321 138s-18-5-31-2c-4 1-9 1-20 9-13 10-16 13-17 23-2 9-2 17 2 25 3 8 0 4 10 21 8 13 12 17 12 23 1 10-3 13-1 22 0 2 3 14 10 15h1c6 1 13-1 14-2 4-4 2-11 3-11 2 0 4 8 0 15-2 4-4 4-15 13l-13 8-17 1c-12 0-13 4-19 3-8-2-15-9-15-16 0-3 6-7 4-7s1 16 9 18c7 1 6-3 12-2 6 0 13-1 20-6 2-1 6-4 6-7 2-7-2-10-6-20-3-8 3-12 1-24-1-8-6-9-12-21-8-16-11-17-14-27-1-3-3-21 2-30 3-6 2-9 12-16 7-5 12-8 20-10 15-3 19-1 25-1 9 1 17 6 17 6zM199 193c0-3-7-5-12-4-6 1-8 5-13 9-4 4-11 8-22 10 3 2 6 4 11 4 7 1 18 0 27-5 8-4 10-10 9-14zM190 156c-1 1-2-1-5-3 0 0-5-3-12-4-13-2-25 7-28 9-9 6-12 13-14 12s-1-9 4-16c8-14 27-14 30-15 5 0 11 0 16 4 7 4 10 13 9 13zM319 324s1 11-3 16c-2 3-6 5-17 9-15 5-23 8-33 7-9-1-15-4-22-7-2-1-7-3-7-5 0-1 13 5 25 0 6-3 8-7 15-7h10c4-1 6-4 10-7 7-6 22-6 22-6z\\\"; }\\n        else if(index < 80) { path = \\\"M118 152c0-2 8-3 15-4 9-1 13 0 15 1 5 1 7 4 7 5 2 1 4 4 4 8l-5 7s-2-7-7-10c-4-3-7 1-16-1-6-1-14-4-13-6z M143 103c1 1 8-3 17-3 24 1 25 28 25 39-1 11 0 18-8 25-9 8-7 3-18 18-6 7-6 11-12 18-5 7-29 23-35 32-3 5-4 9-4 15-1 12 18 16 22 20 9 7 11 12 20 14 7 3 14 5 21-1 5-4 7-10 5-12-2-3-12 12-22 9-7-2 0 0-17-14-11-9-17-6-20-17-2-11 7-18 21-28 12-8 12-11 16-15 7-10 6-13 13-22 9-11 25-11 25-38 0-10-2-18-3-25-1-9-7-14-11-19-5-5-14-9-22-7s-14 9-13 11zM230 199c1-3 5-6 9-7 2 0 12-3 21 0 10 3 12 8 17 14 7 9 2 22 5 24 2 1-7-7-16-13-7-5-6-4-17-8-9-5-19-4-19-10zM300 164s-3-10-14-18c-3-2-13-10-26-10-17 0-27 11-29 9-1-2 7-14 19-18 14-4 25 3 28 4 18 10 23 33 22 33zM164 332c1 4-12 10-25 11-3 0-12 0-21-5-8-4-12-10-14-14-4-6-6-19-6-19l12 2 15 5c4 7 6 7 6 7 2 2 4-1 8 0 4 0 6 2 9 4 10 8 16 7 16 9z\\\"; }\\n        else if(index < 90) { path = \\\"M103 206c2-2 7 4 16 5 12 1 22-2 22-2s-3 6-9 10c-1 1-10 6-19 2-7-4-12-13-10-15z M106 164c0 4 30-7 43 12 8 11 7 36 2 49-3 9-11 20-14 39v1c-4 20-9 29-10 30-3 3-6 10-6 18v2c2 8 8 12 10 14a31 31 0 0019 7c3 0 9 0 17-3 5-1 16-6 16-8-1-4-36 17-52-3-10-13 5-27 14-66 3-11 16-33 17-53 1-19-2-29-15-38-17-12-41-5-41-1zM261 241l-8-4c-6-4-11-15-28-11-5 1-11 7-11 9 0 1 3 3 12 5 8 2 12-3 21 2 6 3 14-1 14-1zM277 205c-1 2-8-9-21-13-11-2-22 0-28 2l-13 3c-1-1 8-9 20-12 2-1 16-4 29 4 10 6 14 15 13 16zM195 370c1 2-7 11-19 13-9 3-17 0-23-2-7-2-16-5-18-12 0-2 0-6 2-7s4 4 11 6c5 2 7 0 14 1l9 3c12 5 23-3 24-2z\\\"; }\\n        else if(index < 100) { path = \\\"M313 128c0 1-14-6-31-1a46 46 0 00-30 52c0 3 4 9 10 20 10 18 11 17 15 26 9 18 7 20 14 30 2 3 10 7 12 16l1 1c2 10-8 21-10 23a60 60 0 01-35 18c-12 3-27 6-36-2-7-6-9-16-7-17 2-2 6 2 13 6 16 6 32 2 38 1 9-3 18-5 23-14 0-1 5-10 1-17l-19-39c-5-10-31-43-32-61-1-5-2-12 5-25 1-3 9-20 28-25 21-6 40 6 40 8z M328 172c1-3-5-9-12-10-3-1-8-3-20 1-8 3-13 8-15 11-5 5-9 10-7 12 2 1 8-8 19-10 7-1 8 2 18 1 3 0 16-1 17-5zM198 201c-1-6-11-11-18-9-7 1-6 7-16 14-9 6-14 4-20 11-2 3-6 9-4 11 2 3 8-1 26-6 13-3 17-3 23-8 3-2 10-7 9-13zM197 156c-1 2-12-6-31-5-14 1-25 7-27 8-11 6-16 13-18 11-2-1 0-12 7-18 5-5 9-3 24-7 13-5 13-7 19-7 15 0 28 15 26 18zM322 315s3 18-3 28c-5 9-12 13-16 15-4 3-15 9-31 9-10 0-10-4-31-8l-16-4c0-3 11-4 27-14 10-6 13-7 20-7 6 0 8 3 12 1 4-1 4-5 9-9l12-6c13-2 14-7 17-5z\\\"; }\\n\\n        return string(abi.encodePacked(\\n            '<path class=\\\"c\\\" d=\\\"',path,'\\\"/>'\\n        ));\\n    }\\n\\n    function generateBlur(bytes memory hash) public pure returns (string memory) {\\n        uint256 blurDegree = uint256(toUint8(hash,2))/64; // 1 - 4\\n        uint256 blurSeed = uint256(toUint8(hash,3));\\n\\n        return string(abi.encodePacked(\\n            svgFilter('blur'), \\n            '<feTurbulence baseFrequency=\\\"',generateDecimalString(5,blurDegree+1),'\\\" seed=\\\"',toString(blurSeed),'\\\" result=\\\"turbs\\\"/>',\\n            '<feSpecularLighting surfaceScale=\\\"200\\\" result=\\\"out\\\" specularExponent=\\\"20\\\">',\\n            '<fePointLight x=\\\"216\\\" y=\\\"17\\\" z=\\\"200\\\"/>',\\n            '</feSpecularLighting>',\\n            '<feGaussianBlur in=\\\"out\\\" stdDeviation=\\\"4\\\" result=\\\"blurred\\\"/>',\\n            '<feComposite in=\\\"SourceGraphic\\\" in2=\\\"blurred\\\" operator=\\\"arithmetic\\\" k1=\\\"0\\\" k2=\\\"1\\\" k3=\\\"1\\\" k4=\\\"0\\\"/>',\\n            '</filter>'\\n        ));\\n    }\\n\\n    function generateSteps(bytes memory hash) public pure returns (string memory) {\\n        uint256 stepsDegree = uint256(toUint8(hash,4))/64; // 1 - 4\\n        uint256 stepsInterDegree = 1+uint256(toUint8(hash,5))*100/256/10;\\n        uint256 stepsSeed = uint256(toUint8(hash,6));\\n        uint256 stepsScale = 80+uint256(toUint8(hash,7))/2;\\n        return string(abi.encodePacked(\\n            svgFilter('steps'), \\n            '<feTurbulence baseFrequency=\\\"',generateDecimalString(stepsInterDegree,stepsDegree+1),'\\\" seed=\\\"',toString(stepsSeed),'\\\" result=\\\"turbs\\\"/>',\\n            '<feSpecularLighting surfaceScale=\\\"',toString(stepsScale),'\\\" result=\\\"specOut\\\" specularExponent=\\\"20\\\">',\\n            '<fePointLight x=\\\"210\\\" y=\\\"17\\\" z=\\\"200\\\"/>',\\n            '</feSpecularLighting>',\\n            '<feComposite in=\\\"SourceGraphic\\\" in2=\\\"blurred\\\" operator=\\\"arithmetic\\\" k1=\\\"0\\\" k2=\\\"1\\\" k3=\\\"1\\\" k4=\\\"0\\\"/>',\\n            '</filter>'\\n        ));\\n    }\\n\\n    function generateTurbs1(bytes memory hash) public pure returns (string memory) {\\n        uint256 turbs1Degree = uint256(toUint8(hash,8))/128; // 0 - 2 (2 is very slightly rarer due to it ending at 2.965)\\n        uint256 turbs1InterDegree = 1+uint256(toUint8(hash,9))*100/256/10;\\n        uint256 turbs1Seed = uint256(toUint8(hash,10));\\n        return string(abi.encodePacked(\\n            svgFilter('turb1'), \\n            '<feTurbulence baseFrequency=\\\"',generateDecimalString(turbs1InterDegree,turbs1Degree+2),'\\\" seed=\\\"',toString(turbs1Seed),'\\\" result=\\\"turbs\\\"/>',\\n            '</filter>'\\n        ));\\n    }\\n\\n    function generateTurbs2(bytes memory hash) public pure returns (string memory) {\\n        uint256 turbs2Degree = uint256(toUint8(hash,11))/64; // 0 - 3\\n        uint256 turbs2InterDegree = 1+uint256(toUint8(hash,12))*100/256/10;\\n        uint256 turbs2Seed = uint256(toUint8(hash,13));\\n        // do colour tempering next\\n        string memory redOffset = getColourOffset(hash, 14);\\n        string memory greenOffset = getColourOffset(hash, 15);\\n        string memory blueOffset = getColourOffset(hash, 16);\\n\\n        uint256 alphaSlope = 1+uint256(toUint8(hash,17))/64;\\n\\n        return string(abi.encodePacked(\\n            svgFilter('turb2'), \\n            '<feTurbulence baseFrequency=\\\"',generateDecimalString(turbs2InterDegree,turbs2Degree+1),'\\\" seed=\\\"',toString(turbs2Seed),'\\\" result=\\\"turbs\\\"/>',\\n            '<feComponentTransfer result=\\\"wave\\\">',\\n            '<feFuncR type=\\\"gamma\\\" offset=\\\"',redOffset,'\\\"/>',\\n            '<feFuncG type=\\\"gamma\\\" offset=\\\"',greenOffset,'\\\"/>',\\n            '<feFuncB type=\\\"gamma\\\" offset=\\\"',blueOffset,'\\\"/>',\\n            '<feFuncA type=\\\"linear\\\" slope=\\\"',toString(alphaSlope),'\\\"/>',\\n            '</feComponentTransfer>',\\n            '</filter>'\\n        ));\\n    }\\n\\n    function getColourOffset(bytes memory hash, uint256 hashIndex) public pure returns (string memory) {\\n        uint256 shift = uint256(toUint8(hash,hashIndex))/128; // 0 or 1. Positive or Negative\\n        uint256 change = uint256(toUint8(hash,hashIndex))*100/256; // 0 - 99 \\n        string memory sign = \\\"\\\";\\n        if(shift == 1) { sign = \\\"-\\\"; }\\n        return string(abi.encodePacked(\\n            sign,generateDecimalString(change,1)\\n        ));\\n    }\\n\\n    function svgRect(string memory opacity, string memory filter, string memory fill) public pure returns (string memory) {\\n        return string(abi.encodePacked('<rect width=\\\"100%\\\" height=\\\"200%\\\" clip-path=\\\"url(#m)\\\" opacity=\\\"',opacity,'\\\" filter=\\\"url(#',filter,')\\\" fill=\\\"',fill,'\\\"/>'));\\n    }\\n\\n    function svgFilter(string memory id) public pure returns (string memory) {\\n        return string(abi.encodePacked('<filter id=\\\"',id,'\\\" width=\\\"100%\\\" height=\\\"100%\\\">'));\\n    }\\n\\n    function svgFeTurbulence(string memory seed, string memory baseFrequency) public pure returns (string memory) {\\n        return string(abi.encodePacked(\\n            '<feTurbulence type=\\\"turbulence\\\" seed=\\\"',seed,'\\\" baseFrequency=\\\"',baseFrequency,'\\\" result=\\\"turbs\\\"/>'\\n        ));\\n    }\\n\\n    // helper function for generation\\n    // from: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol \\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n        return tempUint;\\n    }\\n\\n        // from: https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/utils/Strings.sol\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function generateDecimalString(uint nr, uint decimals) public pure returns (string memory) {\\n        if(decimals == 1) { return string(abi.encodePacked('0.',toString(nr))); }\\n        if(decimals == 2) { return string(abi.encodePacked('0.0',toString(nr))); }\\n        if(decimals == 3) { return string(abi.encodePacked('0.00',toString(nr))); }\\n        if(decimals == 4) { return string(abi.encodePacked('0.000',toString(nr))); }\\n    }\\n\\n    // from: https://ethereum.stackexchange.com/questions/31457/substring-in-solidity/31470\\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex-startIndex);\\n        for(uint i = startIndex; i < endIndex; i++) {\\n            result[i-startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collector_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startDate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate_\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"root_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descriptor\",\"outputs\":[{\"internalType\":\"contract CollectionDescriptor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generateBase64Image\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generateImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generateTraits\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"loyalMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"leaf\",\"type\":\"address\"}],\"name\":\"loyalMintLeaf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loyaltyRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Collection", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000af69610ea9ddc95883f97a6a3171d52165b69b030000000000000000000000002c48763e807f51d58cfc72f3d903513e12af355100000000000000000000000000000000000000000000000000000000625d6ee000000000000000000000000000000000000000000000000000000000628258e05a205b661dc03e3b33329ec05c331ddb579d0a146b5a14e68d88d5eafaaa5d15000000000000000000000000000000000000000000000000000000000000000f4c6974746c65204d61727469616e73000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034c4d530000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}