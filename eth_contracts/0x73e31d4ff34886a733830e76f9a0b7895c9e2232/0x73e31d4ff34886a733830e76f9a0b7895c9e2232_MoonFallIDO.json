{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ico.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.16;\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ncontract MoonFallIDO {\\r\\n    //Administration Details\\r\\n    address public admin;\\r\\n    address payable public ICOWallet;\\r\\n    mapping(address => bool) private whitelist;\\r\\n    //Token\\r\\n    IERC20 public token;\\r\\n    // IERC20 public stETH;\\r\\n\\r\\n    //ICO Details\\r\\n    uint public tokenPrice = 0.00000529 ether;\\r\\n    uint public hardCap = 500 ether;\\r\\n    uint public raisedAmount;\\r\\n    uint public minInvestment = 0.06 ether;\\r\\n    uint public maxInvestment = 50 ether;\\r\\n    uint public icoStartTime;\\r\\n    uint public icoEndTime;\\r\\n\\r\\n    //Investor\\r\\n    mapping(address => uint) public investedAmountOf;\\r\\n\\r\\n    //ICO State\\r\\n    enum State {\\r\\n        BEFORE,\\r\\n        RUNNING,\\r\\n        END,\\r\\n        HALTED\\r\\n    }\\r\\n    State public ICOState;\\r\\n\\r\\n    //Events\\r\\n    event Invest(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint value,\\r\\n        uint tokens\\r\\n    );\\r\\n    event TokenBurn(address to, uint amount, uint time);\\r\\n\\r\\n    //Initialize Variables\\r\\n    constructor() {\\r\\n       address payable _icoWallet = payable(msg.sender);\\r\\n       admin = msg.sender;\\r\\n       ICOWallet = _icoWallet;\\r\\n\\r\\n    }\\r\\n\\r\\n    //Access Control\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Admin Only function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //Receive Ether Directly\\r\\n    receive() external payable {\\r\\n        invest();\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        invest();\\r\\n    }\\r\\n\\r\\n    /* Functions */\\r\\n\\r\\n    //Get ICO State\\r\\n    function getICOState() external view returns (string memory) {\\r\\n        if (ICOState == State.BEFORE) {\\r\\n            return \\\"Not Started\\\";\\r\\n        } else if (ICOState == State.RUNNING) {\\r\\n            return \\\"Running\\\";\\r\\n        } else if (ICOState == State.END) {\\r\\n            return \\\"End\\\";\\r\\n        } else {\\r\\n            return \\\"Halted\\\";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* Admin Functions */\\r\\n\\r\\n    //Start, Halt and End ICO\\r\\n    function startICO() external onlyAdmin {\\r\\n        require(ICOState == State.BEFORE, \\\"ICO isn't in before state\\\");\\r\\n\\r\\n        icoStartTime = block.timestamp;\\r\\n        icoEndTime = icoStartTime + (86400 * 365);\\r\\n        ICOState = State.RUNNING;\\r\\n    }\\r\\n\\r\\n    function haltICO() external onlyAdmin {\\r\\n        require(ICOState == State.RUNNING, \\\"ICO isn't running yet\\\");\\r\\n        ICOState = State.HALTED;\\r\\n    }\\r\\n\\r\\n    function resumeICO() external onlyAdmin {\\r\\n        require(ICOState == State.HALTED, \\\"ICO State isn't halted yet\\\");\\r\\n        ICOState = State.RUNNING;\\r\\n    }\\r\\n\\r\\n    //Change ICO Wallet\\r\\n    function changeICOWallet(address payable _newICOWallet) external onlyAdmin {\\r\\n        ICOWallet = _newICOWallet;\\r\\n    }\\r\\n\\r\\n    //Change Admin\\r\\n    function changeAdmin(address _newAdmin) external onlyAdmin {\\r\\n        admin = _newAdmin;\\r\\n    }\\r\\n\\r\\n    /* User Function */\\r\\n    \\r\\n    //Invest\\r\\n    function invest() public payable returns (bool) {\\r\\n        require(isWhitelisted(msg.sender), \\\"Not in Whitelist\\\");\\r\\n        require(ICOState == State.RUNNING, \\\"ICO isn't running\\\");\\r\\n        require(\\r\\n            msg.value >= minInvestment && msg.value <= maxInvestment,\\r\\n            \\\"Check Min and Max Investment\\\"\\r\\n        );\\r\\n        require(\\r\\n            investedAmountOf[msg.sender] + msg.value <= maxInvestment,\\r\\n            \\\"Investor reached maximum Investment Amount\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            raisedAmount + msg.value <= hardCap,\\r\\n            \\\"Send within hardcap range\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp <= icoEndTime,\\r\\n            \\\"ICO already Reached Maximum time limit\\\"\\r\\n        );\\r\\n\\r\\n        raisedAmount += msg.value;\\r\\n        investedAmountOf[msg.sender] += msg.value;\\r\\n\\r\\n        (bool transferSuccess, ) = ICOWallet.call{value: msg.value}(\\\"\\\");\\r\\n        require(transferSuccess, \\\"Failed to Invest\\\");\\r\\n\\r\\n        // uint tokens = (msg.value / tokenPrice) * 1e18;\\r\\n        // bool saleSuccess = token.transfer(msg.sender, tokens);\\r\\n        // require(saleSuccess, \\\"Failed to Invest\\\");\\r\\n\\r\\n        // bool saleDone = stETH.transfer(msg.sender, msg.value);\\r\\n        // require(saleDone, \\\"Failed to Invest\\\");\\r\\n\\r\\n        // emit Invest(address(this), msg.sender, msg.value, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Burn Tokens\\r\\n    function burn() external returns (bool) {\\r\\n        require(ICOState == State.END, \\\"ICO isn't over yet\\\");\\r\\n\\r\\n        uint remainingTokens = token.balanceOf(address(this));\\r\\n        bool success = token.transfer(address(0), remainingTokens);\\r\\n        require(success, \\\"Failed to burn remaining tokens\\\");\\r\\n\\r\\n        emit TokenBurn(address(0), remainingTokens, block.timestamp);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //End ICO After reaching Hardcap or ICO Timelimit\\r\\n    function endIco() public {\\r\\n        require(ICOState == State.RUNNING, \\\"ICO Should be in Running State\\\");\\r\\n        require(\\r\\n            block.timestamp > icoEndTime || raisedAmount >= hardCap,\\r\\n            \\\"ICO Hardcap or timelimit not reached\\\"\\r\\n        );\\r\\n        ICOState = State.END;\\r\\n    }\\r\\n\\r\\n    //Check ICO Contract Token Balance\\r\\n    function getICOTokenBalance() external view returns (uint) {\\r\\n        return token.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    //Check ICO Contract Investor Token Balance\\r\\n    function investorBalanceOf(address _investor) external view returns (uint) {\\r\\n        return token.balanceOf(_investor);\\r\\n    }\\r\\n    function addToWhitelist(address addr) public onlyAdmin {\\r\\n        whitelist[addr] = true;\\r\\n    }\\r\\n        function removeFromWhitelist(address addr) public onlyAdmin{\\r\\n        whitelist[addr] = false;\\r\\n    }\\r\\n\\r\\n    // Check if an address is whitelisted\\r\\n    function isWhitelisted(address addr) public view returns (bool) {\\r\\n        return whitelist[addr];\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokenBurn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ICOState\",\"outputs\":[{\"internalType\":\"enum MoonFallIDO.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ICOWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newICOWallet\",\"type\":\"address\"}],\"name\":\"changeICOWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endIco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getICOState\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getICOTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"haltICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"investorBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raisedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MoonFallIDO", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}