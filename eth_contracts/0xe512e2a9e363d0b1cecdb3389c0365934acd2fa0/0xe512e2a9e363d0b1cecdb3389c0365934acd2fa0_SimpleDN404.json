{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/new1.sol\": {\r\n      \"content\": \"/**\\n * Telegram: https://t.me/C4SH_404\\n * Twitter: https://twitter.com/C4SH404\\n * Doc: https://c4sh-404.gitbook.io/c4sh-404/\\n */\\n \\n // SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// File: https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol\\n\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                       CUSTOM ERRORS                        */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The ETH transfer has failed.\\n\\terror ETHTransferFailed();\\n\\n\\t/// @dev The ERC20 `transferFrom` has failed.\\n\\terror TransferFromFailed();\\n\\n\\t/// @dev The ERC20 `transfer` has failed.\\n\\terror TransferFailed();\\n\\n\\t/// @dev The ERC20 `approve` has failed.\\n\\terror ApproveFailed();\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                         CONSTANTS                          */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n\\tuint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n\\t/// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n\\t/// storage reads and writes, but low enough to prevent griefing.\\n\\tuint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                       ETH OPERATIONS                       */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t// If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n\\t//\\n\\t// The regular variants:\\n\\t// - Forwards all remaining gas to the target.\\n\\t// - Reverts if the target reverts.\\n\\t// - Reverts if the current contract has insufficient balance.\\n\\t//\\n\\t// The force variants:\\n\\t// - Forwards with an optional gas stipend\\n\\t//   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n\\t// - If the target reverts, or if the gas stipend is exhausted,\\n\\t//   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n\\t//   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n\\t// - Reverts if the current contract has insufficient balance.\\n\\t//\\n\\t// The try variants:\\n\\t// - Forwards with a mandatory gas stipend.\\n\\t// - Instead of reverting, returns whether the transfer succeeded.\\n\\n\\t/// @dev Sends `amount` (in wei) ETH to `to`.\\n\\tfunction safeTransferETH(address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends all the ETH in the current contract to `to`.\\n\\tfunction safeTransferAllETH(address to) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Transfer all the ETH and check if it succeeded or not.\\n\\t\\t\\tif iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n\\tfunction forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif lt(selfbalance(), amount) {\\n\\t\\t\\t\\tmstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tif iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, to) // Store the address in scratch space.\\n\\t\\t\\t\\tmstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n\\t\\t\\t\\tmstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n\\t\\t\\t\\tif iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n\\tfunction forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, to) // Store the address in scratch space.\\n\\t\\t\\t\\tmstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n\\t\\t\\t\\tmstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n\\t\\t\\t\\tif iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n\\tfunction forceSafeTransferETH(address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif lt(selfbalance(), amount) {\\n\\t\\t\\t\\tmstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tif iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, to) // Store the address in scratch space.\\n\\t\\t\\t\\tmstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n\\t\\t\\t\\tmstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n\\t\\t\\t\\tif iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n\\tfunction forceSafeTransferAllETH(address to) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// forgefmt: disable-next-item\\n\\t\\t\\tif iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n\\t\\t\\t\\tmstore(0x00, to) // Store the address in scratch space.\\n\\t\\t\\t\\tmstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n\\t\\t\\t\\tmstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n\\t\\t\\t\\tif iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n\\tfunction trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n\\t\\tinternal\\n\\t\\treturns (bool success)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tsuccess := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n\\tfunction trySafeTransferAllETH(address to, uint256 gasStipend)\\n\\t\\tinternal\\n\\t\\treturns (bool success)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tsuccess := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                      ERC20 OPERATIONS                      */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n\\t/// Reverts upon failure.\\n\\t///\\n\\t/// The `from` account must have at least `amount` approved for\\n\\t/// the current contract to manage.\\n\\tfunction safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet m := mload(0x40) // Cache the free memory pointer.\\n\\t\\t\\tmstore(0x60, amount) // Store the `amount` argument.\\n\\t\\t\\tmstore(0x40, to) // Store the `to` argument.\\n\\t\\t\\tmstore(0x2c, shl(96, from)) // Store the `from` argument.\\n\\t\\t\\tmstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n\\t\\t\\t// Perform the transfer, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x60, 0) // Restore the zero slot to zero.\\n\\t\\t\\tmstore(0x40, m) // Restore the free memory pointer.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends all of ERC20 `token` from `from` to `to`.\\n\\t/// Reverts upon failure.\\n\\t///\\n\\t/// The `from` account must have their entire balance approved for\\n\\t/// the current contract to manage.\\n\\tfunction safeTransferAllFrom(address token, address from, address to)\\n\\t\\tinternal\\n\\t\\treturns (uint256 amount)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet m := mload(0x40) // Cache the free memory pointer.\\n\\t\\t\\tmstore(0x40, to) // Store the `to` argument.\\n\\t\\t\\tmstore(0x2c, shl(96, from)) // Store the `from` argument.\\n\\t\\t\\tmstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n\\t\\t\\t// Read the balance, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tgt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n\\t\\t\\t\\t\\tstaticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n\\t\\t\\tamount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n\\t\\t\\t// Perform the transfer, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x60, 0) // Restore the zero slot to zero.\\n\\t\\t\\tmstore(0x40, m) // Restore the free memory pointer.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n\\t/// Reverts upon failure.\\n\\tfunction safeTransfer(address token, address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x14, to) // Store the `to` argument.\\n\\t\\t\\tmstore(0x34, amount) // Store the `amount` argument.\\n\\t\\t\\tmstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n\\t\\t\\t// Perform the transfer, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n\\t/// Reverts upon failure.\\n\\tfunction safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n\\t\\t\\tmstore(0x20, address()) // Store the address of the current contract.\\n\\t\\t\\t// Read the balance, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tgt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n\\t\\t\\t\\t\\tstaticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x14, to) // Store the `to` argument.\\n\\t\\t\\tamount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n\\t\\t\\tmstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n\\t\\t\\t// Perform the transfer, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n\\t/// Reverts upon failure.\\n\\tfunction safeApprove(address token, address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x14, to) // Store the `to` argument.\\n\\t\\t\\tmstore(0x34, amount) // Store the `amount` argument.\\n\\t\\t\\tmstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n\\t\\t\\t// Perform the approval, reverting upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n\\t/// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n\\t/// then retries the approval again (some tokens, e.g. USDT, requires this).\\n\\t/// Reverts upon failure.\\n\\tfunction safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x14, to) // Store the `to` argument.\\n\\t\\t\\tmstore(0x34, amount) // Store the `amount` argument.\\n\\t\\t\\tmstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n\\t\\t\\t// Perform the approval, retrying upon failure.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tmstore(0x34, 0) // Store 0 for the `amount`.\\n\\t\\t\\t\\tmstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n\\t\\t\\t\\tpop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n\\t\\t\\t\\tmstore(0x34, amount) // Store back the original `amount`.\\n\\t\\t\\t\\t// Retry the approval, reverting upon failure.\\n\\t\\t\\t\\tif iszero(\\n\\t\\t\\t\\t\\tand(\\n\\t\\t\\t\\t\\t\\tor(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n\\t\\t\\t\\t\\t\\tcall(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tmstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n\\t\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the amount of ERC20 `token` owned by `account`.\\n\\t/// Returns zero if the `token` does not exist.\\n\\tfunction balanceOf(address token, address account) internal view returns (uint256 amount) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x14, account) // Store the `account` argument.\\n\\t\\t\\tmstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n\\t\\t\\tamount :=\\n\\t\\t\\t\\tmul(\\n\\t\\t\\t\\t\\tmload(0x20),\\n\\t\\t\\t\\t\\tand( // The arguments of `and` are evaluated from right to left.\\n\\t\\t\\t\\t\\t\\tgt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n\\t\\t\\t\\t\\t\\tstaticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n}\\n\\n// File: https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol\\n\\n\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                        CUSTOM ERRORS                       */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The length of the output is too small to contain all the hex digits.\\n\\terror HexLengthInsufficient();\\n\\n\\t/// @dev The length of the string is more than 32 bytes.\\n\\terror TooBigForSmallString();\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                         CONSTANTS                          */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The constant returned when the `search` is not found in the string.\\n\\tuint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                     DECIMAL OPERATIONS                     */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Returns the base 10 decimal representation of `value`.\\n\\tfunction toString(uint256 value) internal pure returns (string memory str) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n\\t\\t\\t// we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n\\t\\t\\t// We will need 1 word for the trailing zeros padding, 1 word for the length,\\n\\t\\t\\t// and 3 words for a maximum of 78 digits.\\n\\t\\t\\tstr := add(mload(0x40), 0x80)\\n\\t\\t\\t// Update the free memory pointer to allocate.\\n\\t\\t\\tmstore(0x40, add(str, 0x20))\\n\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\tmstore(str, 0)\\n\\n\\t\\t\\t// Cache the end of the memory to calculate the length later.\\n\\t\\t\\tlet end := str\\n\\n\\t\\t\\tlet w := not(0) // Tsk.\\n\\t\\t\\t// We write the string from rightmost digit to leftmost digit.\\n\\t\\t\\t// The following is essentially a do-while loop that also handles the zero case.\\n\\t\\t\\tfor { let temp := value } 1 {} {\\n\\t\\t\\t\\tstr := add(str, w) // `sub(str, 1)`.\\n\\t\\t\\t\\t// Write the character to the pointer.\\n\\t\\t\\t\\t// The ASCII index of the '0' character is 48.\\n\\t\\t\\t\\tmstore8(str, add(48, mod(temp, 10)))\\n\\t\\t\\t\\t// Keep dividing `temp` until zero.\\n\\t\\t\\t\\ttemp := div(temp, 10)\\n\\t\\t\\t\\tif iszero(temp) { break }\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet length := sub(end, str)\\n\\t\\t\\t// Move the pointer 32 bytes leftwards to make room for the length.\\n\\t\\t\\tstr := sub(str, 0x20)\\n\\t\\t\\t// Store the length.\\n\\t\\t\\tmstore(str, length)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the base 10 decimal representation of `value`.\\n\\tfunction toString(int256 value) internal pure returns (string memory str) {\\n\\t\\tif (value >= 0) {\\n\\t\\t\\treturn toString(uint256(value));\\n\\t\\t}\\n\\t\\tunchecked {\\n\\t\\t\\tstr = toString(~uint256(value) + 1);\\n\\t\\t}\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// We still have some spare memory space on the left,\\n\\t\\t\\t// as we have allocated 3 words (96 bytes) for up to 78 digits.\\n\\t\\t\\tlet length := mload(str) // Load the string length.\\n\\t\\t\\tmstore(str, 0x2d) // Store the '-' character.\\n\\t\\t\\tstr := sub(str, 1) // Move back the string pointer by a byte.\\n\\t\\t\\tmstore(str, add(length, 1)) // Update the string length.\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                   HEXADECIMAL OPERATIONS                   */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`,\\n\\t/// left-padded to an input length of `length` bytes.\\n\\t/// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n\\t/// giving a total length of `length * 2 + 2` bytes.\\n\\t/// Reverts if `length` is too small for the output to contain all the digits.\\n\\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(value, length);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet strLength := add(mload(str), 2) // Compute the length.\\n\\t\\t\\tmstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n\\t\\t\\tstr := sub(str, 2) // Move the pointer.\\n\\t\\t\\tmstore(str, strLength) // Write the length.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`,\\n\\t/// left-padded to an input length of `length` bytes.\\n\\t/// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n\\t/// giving a total length of `length * 2` bytes.\\n\\t/// Reverts if `length` is too small for the output to contain all the digits.\\n\\tfunction toHexStringNoPrefix(uint256 value, uint256 length)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory str)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n\\t\\t\\t// for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n\\t\\t\\t// We add 0x20 to the total and round down to a multiple of 0x20.\\n\\t\\t\\t// (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n\\t\\t\\tstr := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n\\t\\t\\t// Allocate the memory.\\n\\t\\t\\tmstore(0x40, add(str, 0x20))\\n\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\tmstore(str, 0)\\n\\n\\t\\t\\t// Cache the end to calculate the length later.\\n\\t\\t\\tlet end := str\\n\\t\\t\\t// Store \\\"0123456789abcdef\\\" in scratch space.\\n\\t\\t\\tmstore(0x0f, 0x30313233343536373839616263646566)\\n\\n\\t\\t\\tlet start := sub(str, add(length, length))\\n\\t\\t\\tlet w := not(1) // Tsk.\\n\\t\\t\\tlet temp := value\\n\\t\\t\\t// We write the string from rightmost digit to leftmost digit.\\n\\t\\t\\t// The following is essentially a do-while loop that also handles the zero case.\\n\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\tstr := add(str, w) // `sub(str, 2)`.\\n\\t\\t\\t\\tmstore8(add(str, 1), mload(and(temp, 15)))\\n\\t\\t\\t\\tmstore8(str, mload(and(shr(4, temp), 15)))\\n\\t\\t\\t\\ttemp := shr(8, temp)\\n\\t\\t\\t\\tif iszero(xor(str, start)) { break }\\n\\t\\t\\t}\\n\\n\\t\\t\\tif temp {\\n\\t\\t\\t\\tmstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Compute the string's length.\\n\\t\\t\\tlet strLength := sub(end, str)\\n\\t\\t\\t// Move the pointer and write the length.\\n\\t\\t\\tstr := sub(str, 0x20)\\n\\t\\t\\tmstore(str, strLength)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n\\t/// As address are 20 bytes long, the output will left-padded to have\\n\\t/// a length of `20 * 2 + 2` bytes.\\n\\tfunction toHexString(uint256 value) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(value);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet strLength := add(mload(str), 2) // Compute the length.\\n\\t\\t\\tmstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n\\t\\t\\tstr := sub(str, 2) // Move the pointer.\\n\\t\\t\\tmstore(str, strLength) // Write the length.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is prefixed with \\\"0x\\\".\\n\\t/// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n\\t/// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n\\tfunction toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(value);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n\\t\\t\\tlet strLength := add(mload(str), 2) // Compute the length.\\n\\t\\t\\tmstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n\\t\\t\\tstr := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n\\t\\t\\tmstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n\\t/// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n\\tfunction toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(value);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n\\t\\t\\tlet strLength := mload(str) // Get the length.\\n\\t\\t\\tstr := add(str, o) // Move the pointer, accounting for leading zero.\\n\\t\\t\\tmstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is encoded using 2 hexadecimal digits per byte.\\n\\t/// As address are 20 bytes long, the output will left-padded to have\\n\\t/// a length of `20 * 2` bytes.\\n\\tfunction toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n\\t\\t\\t// 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n\\t\\t\\t// The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n\\t\\t\\tstr := add(mload(0x40), 0x80)\\n\\t\\t\\t// Allocate the memory.\\n\\t\\t\\tmstore(0x40, add(str, 0x20))\\n\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\tmstore(str, 0)\\n\\n\\t\\t\\t// Cache the end to calculate the length later.\\n\\t\\t\\tlet end := str\\n\\t\\t\\t// Store \\\"0123456789abcdef\\\" in scratch space.\\n\\t\\t\\tmstore(0x0f, 0x30313233343536373839616263646566)\\n\\n\\t\\t\\tlet w := not(1) // Tsk.\\n\\t\\t\\t// We write the string from rightmost digit to leftmost digit.\\n\\t\\t\\t// The following is essentially a do-while loop that also handles the zero case.\\n\\t\\t\\tfor { let temp := value } 1 {} {\\n\\t\\t\\t\\tstr := add(str, w) // `sub(str, 2)`.\\n\\t\\t\\t\\tmstore8(add(str, 1), mload(and(temp, 15)))\\n\\t\\t\\t\\tmstore8(str, mload(and(shr(4, temp), 15)))\\n\\t\\t\\t\\ttemp := shr(8, temp)\\n\\t\\t\\t\\tif iszero(temp) { break }\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Compute the string's length.\\n\\t\\t\\tlet strLength := sub(end, str)\\n\\t\\t\\t// Move the pointer and write the length.\\n\\t\\t\\tstr := sub(str, 0x20)\\n\\t\\t\\tmstore(str, strLength)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n\\t/// and the alphabets are capitalized conditionally according to\\n\\t/// https://eips.ethereum.org/EIPS/eip-55\\n\\tfunction toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n\\t\\tstr = toHexString(value);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n\\t\\t\\tlet o := add(str, 0x22)\\n\\t\\t\\tlet hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n\\t\\t\\tlet t := shl(240, 136) // `0b10001000 << 240`\\n\\t\\t\\tfor { let i := 0 } 1 {} {\\n\\t\\t\\t\\tmstore(add(i, i), mul(t, byte(i, hashed)))\\n\\t\\t\\t\\ti := add(i, 1)\\n\\t\\t\\t\\tif eq(i, 20) { break }\\n\\t\\t\\t}\\n\\t\\t\\tmstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n\\t\\t\\to := add(o, 0x20)\\n\\t\\t\\tmstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n\\tfunction toHexString(address value) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(value);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet strLength := add(mload(str), 2) // Compute the length.\\n\\t\\t\\tmstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n\\t\\t\\tstr := sub(str, 2) // Move the pointer.\\n\\t\\t\\tmstore(str, strLength) // Write the length.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hexadecimal representation of `value`.\\n\\t/// The output is encoded using 2 hexadecimal digits per byte.\\n\\tfunction toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tstr := mload(0x40)\\n\\n\\t\\t\\t// Allocate the memory.\\n\\t\\t\\t// We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n\\t\\t\\t// 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n\\t\\t\\t// The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n\\t\\t\\tmstore(0x40, add(str, 0x80))\\n\\n\\t\\t\\t// Store \\\"0123456789abcdef\\\" in scratch space.\\n\\t\\t\\tmstore(0x0f, 0x30313233343536373839616263646566)\\n\\n\\t\\t\\tstr := add(str, 2)\\n\\t\\t\\tmstore(str, 40)\\n\\n\\t\\t\\tlet o := add(str, 0x20)\\n\\t\\t\\tmstore(add(o, 40), 0)\\n\\n\\t\\t\\tvalue := shl(96, value)\\n\\n\\t\\t\\t// We write the string from rightmost digit to leftmost digit.\\n\\t\\t\\t// The following is essentially a do-while loop that also handles the zero case.\\n\\t\\t\\tfor { let i := 0 } 1 {} {\\n\\t\\t\\t\\tlet p := add(o, add(i, i))\\n\\t\\t\\t\\tlet temp := byte(i, value)\\n\\t\\t\\t\\tmstore8(add(p, 1), mload(and(temp, 15)))\\n\\t\\t\\t\\tmstore8(p, mload(shr(4, temp)))\\n\\t\\t\\t\\ti := add(i, 1)\\n\\t\\t\\t\\tif eq(i, 20) { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hex encoded string from the raw bytes.\\n\\t/// The output is encoded using 2 hexadecimal digits per byte.\\n\\tfunction toHexString(bytes memory raw) internal pure returns (string memory str) {\\n\\t\\tstr = toHexStringNoPrefix(raw);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet strLength := add(mload(str), 2) // Compute the length.\\n\\t\\t\\tmstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n\\t\\t\\tstr := sub(str, 2) // Move the pointer.\\n\\t\\t\\tmstore(str, strLength) // Write the length.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the hex encoded string from the raw bytes.\\n\\t/// The output is encoded using 2 hexadecimal digits per byte.\\n\\tfunction toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet length := mload(raw)\\n\\t\\t\\tstr := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n\\t\\t\\tmstore(str, add(length, length)) // Store the length of the output.\\n\\n\\t\\t\\t// Store \\\"0123456789abcdef\\\" in scratch space.\\n\\t\\t\\tmstore(0x0f, 0x30313233343536373839616263646566)\\n\\n\\t\\t\\tlet o := add(str, 0x20)\\n\\t\\t\\tlet end := add(raw, length)\\n\\n\\t\\t\\tfor {} iszero(eq(raw, end)) {} {\\n\\t\\t\\t\\traw := add(raw, 1)\\n\\t\\t\\t\\tmstore8(add(o, 1), mload(and(mload(raw), 15)))\\n\\t\\t\\t\\tmstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n\\t\\t\\t\\to := add(o, 2)\\n\\t\\t\\t}\\n\\t\\t\\tmstore(o, 0) // Zeroize the slot after the string.\\n\\t\\t\\tmstore(0x40, add(o, 0x20)) // Allocate the memory.\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                   RUNE STRING OPERATIONS                   */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Returns the number of UTF characters in the string.\\n\\tfunction runeCount(string memory s) internal pure returns (uint256 result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif mload(s) {\\n\\t\\t\\t\\tmstore(0x00, div(not(0), 255))\\n\\t\\t\\t\\tmstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n\\t\\t\\t\\tlet o := add(s, 0x20)\\n\\t\\t\\t\\tlet end := add(o, mload(s))\\n\\t\\t\\t\\tfor { result := 1 } 1 { result := add(result, 1) } {\\n\\t\\t\\t\\t\\to := add(o, byte(0, mload(shr(250, mload(o)))))\\n\\t\\t\\t\\t\\tif iszero(lt(o, end)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns if this string is a 7-bit ASCII string.\\n\\t/// (i.e. all characters codes are in [0..127])\\n\\tfunction is7BitASCII(string memory s) internal pure returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet mask := shl(7, div(not(0), 255))\\n\\t\\t\\tresult := 1\\n\\t\\t\\tlet n := mload(s)\\n\\t\\t\\tif n {\\n\\t\\t\\t\\tlet o := add(s, 0x20)\\n\\t\\t\\t\\tlet end := add(o, n)\\n\\t\\t\\t\\tlet last := mload(end)\\n\\t\\t\\t\\tmstore(end, 0)\\n\\t\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\t\\tif and(mask, mload(o)) {\\n\\t\\t\\t\\t\\t\\tresult := 0\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\to := add(o, 0x20)\\n\\t\\t\\t\\t\\tif iszero(lt(o, end)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmstore(end, last)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                   BYTE STRING OPERATIONS                   */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t// For performance and bytecode compactness, byte string operations are restricted\\n\\t// to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n\\t// Usage of byte string operations on charsets with runes spanning two or more bytes\\n\\t// can lead to undefined behavior.\\n\\n\\t/// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n\\tfunction replace(string memory subject, string memory search, string memory replacement)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet subjectLength := mload(subject)\\n\\t\\t\\tlet searchLength := mload(search)\\n\\t\\t\\tlet replacementLength := mload(replacement)\\n\\n\\t\\t\\tsubject := add(subject, 0x20)\\n\\t\\t\\tsearch := add(search, 0x20)\\n\\t\\t\\treplacement := add(replacement, 0x20)\\n\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\n\\t\\t\\tlet subjectEnd := add(subject, subjectLength)\\n\\t\\t\\tif iszero(gt(searchLength, subjectLength)) {\\n\\t\\t\\t\\tlet subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n\\t\\t\\t\\tlet h := 0\\n\\t\\t\\t\\tif iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n\\t\\t\\t\\tlet m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n\\t\\t\\t\\tlet s := mload(search)\\n\\t\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\t\\tlet t := mload(subject)\\n\\t\\t\\t\\t\\t// Whether the first `searchLength % 32` bytes of\\n\\t\\t\\t\\t\\t// `subject` and `search` matches.\\n\\t\\t\\t\\t\\tif iszero(shr(m, xor(t, s))) {\\n\\t\\t\\t\\t\\t\\tif h {\\n\\t\\t\\t\\t\\t\\t\\tif iszero(eq(keccak256(subject, searchLength), h)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tmstore(result, t)\\n\\t\\t\\t\\t\\t\\t\\t\\tresult := add(result, 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// Copy the `replacement` one word at a time.\\n\\t\\t\\t\\t\\t\\tfor { let o := 0 } 1 {} {\\n\\t\\t\\t\\t\\t\\t\\tmstore(add(result, o), mload(add(replacement, o)))\\n\\t\\t\\t\\t\\t\\t\\to := add(o, 0x20)\\n\\t\\t\\t\\t\\t\\t\\tif iszero(lt(o, replacementLength)) { break }\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tresult := add(result, replacementLength)\\n\\t\\t\\t\\t\\t\\tsubject := add(subject, searchLength)\\n\\t\\t\\t\\t\\t\\tif searchLength {\\n\\t\\t\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmstore(result, t)\\n\\t\\t\\t\\t\\tresult := add(result, 1)\\n\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet resultRemainder := result\\n\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\t\\t\\tlet k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n\\t\\t\\t// Copy the rest of the string one word at a time.\\n\\t\\t\\tfor {} lt(subject, subjectEnd) {} {\\n\\t\\t\\t\\tmstore(resultRemainder, mload(subject))\\n\\t\\t\\t\\tresultRemainder := add(resultRemainder, 0x20)\\n\\t\\t\\t\\tsubject := add(subject, 0x20)\\n\\t\\t\\t}\\n\\t\\t\\tresult := sub(result, 0x20)\\n\\t\\t\\tlet last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n\\t\\t\\tmstore(last, 0)\\n\\t\\t\\tmstore(0x40, add(last, 0x20)) // Allocate the memory.\\n\\t\\t\\tmstore(result, k) // Store the length.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the byte index of the first location of `search` in `subject`,\\n\\t/// searching from left to right, starting from `from`.\\n\\t/// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n\\tfunction indexOf(string memory subject, string memory search, uint256 from)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tfor { let subjectLength := mload(subject) } 1 {} {\\n\\t\\t\\t\\tif iszero(mload(search)) {\\n\\t\\t\\t\\t\\tif iszero(gt(from, subjectLength)) {\\n\\t\\t\\t\\t\\t\\tresult := from\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresult := subjectLength\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlet searchLength := mload(search)\\n\\t\\t\\t\\tlet subjectStart := add(subject, 0x20)\\n\\n\\t\\t\\t\\tresult := not(0) // Initialize to `NOT_FOUND`.\\n\\n\\t\\t\\t\\tsubject := add(subjectStart, from)\\n\\t\\t\\t\\tlet end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n\\t\\t\\t\\tlet m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n\\t\\t\\t\\tlet s := mload(add(search, 0x20))\\n\\n\\t\\t\\t\\tif iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n\\t\\t\\t\\tif iszero(lt(searchLength, 0x20)) {\\n\\t\\t\\t\\t\\tfor { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n\\t\\t\\t\\t\\t\\tif iszero(shr(m, xor(mload(subject), s))) {\\n\\t\\t\\t\\t\\t\\t\\tif eq(keccak256(subject, searchLength), h) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresult := sub(subject, subjectStart)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\t\\tif iszero(lt(subject, end)) { break }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\t\\tif iszero(shr(m, xor(mload(subject), s))) {\\n\\t\\t\\t\\t\\t\\tresult := sub(subject, subjectStart)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\tif iszero(lt(subject, end)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the byte index of the first location of `search` in `subject`,\\n\\t/// searching from left to right.\\n\\t/// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n\\tfunction indexOf(string memory subject, string memory search)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 result)\\n\\t{\\n\\t\\tresult = indexOf(subject, search, 0);\\n\\t}\\n\\n\\t/// @dev Returns the byte index of the first location of `search` in `subject`,\\n\\t/// searching from right to left, starting from `from`.\\n\\t/// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n\\tfunction lastIndexOf(string memory subject, string memory search, uint256 from)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\tresult := not(0) // Initialize to `NOT_FOUND`.\\n\\t\\t\\t\\tlet searchLength := mload(search)\\n\\t\\t\\t\\tif gt(searchLength, mload(subject)) { break }\\n\\t\\t\\t\\tlet w := result\\n\\n\\t\\t\\t\\tlet fromMax := sub(mload(subject), searchLength)\\n\\t\\t\\t\\tif iszero(gt(fromMax, from)) { from := fromMax }\\n\\n\\t\\t\\t\\tlet end := add(add(subject, 0x20), w)\\n\\t\\t\\t\\tsubject := add(add(subject, 0x20), from)\\n\\t\\t\\t\\tif iszero(gt(subject, end)) { break }\\n\\t\\t\\t\\t// As this function is not too often used,\\n\\t\\t\\t\\t// we shall simply use keccak256 for smaller bytecode size.\\n\\t\\t\\t\\tfor { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n\\t\\t\\t\\t\\tif eq(keccak256(subject, searchLength), h) {\\n\\t\\t\\t\\t\\t\\tresult := sub(subject, add(end, 1))\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsubject := add(subject, w) // `sub(subject, 1)`.\\n\\t\\t\\t\\t\\tif iszero(gt(subject, end)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the byte index of the first location of `search` in `subject`,\\n\\t/// searching from right to left.\\n\\t/// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n\\tfunction lastIndexOf(string memory subject, string memory search)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256 result)\\n\\t{\\n\\t\\tresult = lastIndexOf(subject, search, uint256(int256(-1)));\\n\\t}\\n\\n\\t/// @dev Returns true if `search` is found in `subject`, false otherwise.\\n\\tfunction contains(string memory subject, string memory search) internal pure returns (bool) {\\n\\t\\treturn indexOf(subject, search) != NOT_FOUND;\\n\\t}\\n\\n\\t/// @dev Returns whether `subject` starts with `search`.\\n\\tfunction startsWith(string memory subject, string memory search)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet searchLength := mload(search)\\n\\t\\t\\t// Just using keccak256 directly is actually cheaper.\\n\\t\\t\\t// forgefmt: disable-next-item\\n\\t\\t\\tresult := and(\\n\\t\\t\\t\\tiszero(gt(searchLength, mload(subject))),\\n\\t\\t\\t\\teq(\\n\\t\\t\\t\\t\\tkeccak256(add(subject, 0x20), searchLength),\\n\\t\\t\\t\\t\\tkeccak256(add(search, 0x20), searchLength)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns whether `subject` ends with `search`.\\n\\tfunction endsWith(string memory subject, string memory search)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bool result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet searchLength := mload(search)\\n\\t\\t\\tlet subjectLength := mload(subject)\\n\\t\\t\\t// Whether `search` is not longer than `subject`.\\n\\t\\t\\tlet withinRange := iszero(gt(searchLength, subjectLength))\\n\\t\\t\\t// Just using keccak256 directly is actually cheaper.\\n\\t\\t\\t// forgefmt: disable-next-item\\n\\t\\t\\tresult := and(\\n\\t\\t\\t\\twithinRange,\\n\\t\\t\\t\\teq(\\n\\t\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\t// `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n\\t\\t\\t\\t\\t\\tadd(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n\\t\\t\\t\\t\\t\\tsearchLength\\n\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\tkeccak256(add(search, 0x20), searchLength)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns `subject` repeated `times`.\\n\\tfunction repeat(string memory subject, uint256 times)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet subjectLength := mload(subject)\\n\\t\\t\\tif iszero(or(iszero(times), iszero(subjectLength))) {\\n\\t\\t\\t\\tsubject := add(subject, 0x20)\\n\\t\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\t\\tlet output := add(result, 0x20)\\n\\t\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\t\\t// Copy the `subject` one word at a time.\\n\\t\\t\\t\\t\\tfor { let o := 0 } 1 {} {\\n\\t\\t\\t\\t\\t\\tmstore(add(output, o), mload(add(subject, o)))\\n\\t\\t\\t\\t\\t\\to := add(o, 0x20)\\n\\t\\t\\t\\t\\t\\tif iszero(lt(o, subjectLength)) { break }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toutput := add(output, subjectLength)\\n\\t\\t\\t\\t\\ttimes := sub(times, 1)\\n\\t\\t\\t\\t\\tif iszero(times) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmstore(output, 0) // Zeroize the slot after the string.\\n\\t\\t\\t\\tlet resultLength := sub(output, add(result, 0x20))\\n\\t\\t\\t\\tmstore(result, resultLength) // Store the length.\\n\\t\\t\\t\\t// Allocate the memory.\\n\\t\\t\\t\\tmstore(0x40, add(result, add(resultLength, 0x20)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n\\t/// `start` and `end` are byte offsets.\\n\\tfunction slice(string memory subject, uint256 start, uint256 end)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet subjectLength := mload(subject)\\n\\t\\t\\tif iszero(gt(subjectLength, end)) { end := subjectLength }\\n\\t\\t\\tif iszero(gt(subjectLength, start)) { start := subjectLength }\\n\\t\\t\\tif lt(start, end) {\\n\\t\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\t\\tlet resultLength := sub(end, start)\\n\\t\\t\\t\\tmstore(result, resultLength)\\n\\t\\t\\t\\tsubject := add(subject, start)\\n\\t\\t\\t\\tlet w := not(0x1f)\\n\\t\\t\\t\\t// Copy the `subject` one word at a time, backwards.\\n\\t\\t\\t\\tfor { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n\\t\\t\\t\\t\\tmstore(add(result, o), mload(add(subject, o)))\\n\\t\\t\\t\\t\\to := add(o, w) // `sub(o, 0x20)`.\\n\\t\\t\\t\\t\\tif iszero(o) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\t\\tmstore(add(add(result, 0x20), resultLength), 0)\\n\\t\\t\\t\\t// Allocate memory for the length and the bytes,\\n\\t\\t\\t\\t// rounded up to a multiple of 32.\\n\\t\\t\\t\\tmstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n\\t/// `start` is a byte offset.\\n\\tfunction slice(string memory subject, uint256 start)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\tresult = slice(subject, start, uint256(int256(-1)));\\n\\t}\\n\\n\\t/// @dev Returns all the indices of `search` in `subject`.\\n\\t/// The indices are byte offsets.\\n\\tfunction indicesOf(string memory subject, string memory search)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256[] memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet subjectLength := mload(subject)\\n\\t\\t\\tlet searchLength := mload(search)\\n\\n\\t\\t\\tif iszero(gt(searchLength, subjectLength)) {\\n\\t\\t\\t\\tsubject := add(subject, 0x20)\\n\\t\\t\\t\\tsearch := add(search, 0x20)\\n\\t\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\n\\t\\t\\t\\tlet subjectStart := subject\\n\\t\\t\\t\\tlet subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n\\t\\t\\t\\tlet h := 0\\n\\t\\t\\t\\tif iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n\\t\\t\\t\\tlet m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n\\t\\t\\t\\tlet s := mload(search)\\n\\t\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\t\\tlet t := mload(subject)\\n\\t\\t\\t\\t\\t// Whether the first `searchLength % 32` bytes of\\n\\t\\t\\t\\t\\t// `subject` and `search` matches.\\n\\t\\t\\t\\t\\tif iszero(shr(m, xor(t, s))) {\\n\\t\\t\\t\\t\\t\\tif h {\\n\\t\\t\\t\\t\\t\\t\\tif iszero(eq(keccak256(subject, searchLength), h)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// Append to `result`.\\n\\t\\t\\t\\t\\t\\tmstore(result, sub(subject, subjectStart))\\n\\t\\t\\t\\t\\t\\tresult := add(result, 0x20)\\n\\t\\t\\t\\t\\t\\t// Advance `subject` by `searchLength`.\\n\\t\\t\\t\\t\\t\\tsubject := add(subject, searchLength)\\n\\t\\t\\t\\t\\t\\tif searchLength {\\n\\t\\t\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\t\\tif iszero(lt(subject, subjectSearchEnd)) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlet resultEnd := result\\n\\t\\t\\t\\t// Assign `result` to the free memory pointer.\\n\\t\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\t\\t// Store the length of `result`.\\n\\t\\t\\t\\tmstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n\\t\\t\\t\\t// Allocate memory for result.\\n\\t\\t\\t\\t// We allocate one more word, so this array can be recycled for {split}.\\n\\t\\t\\t\\tmstore(0x40, add(resultEnd, 0x20))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n\\tfunction split(string memory subject, string memory delimiter)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string[] memory result)\\n\\t{\\n\\t\\tuint256[] memory indices = indicesOf(subject, delimiter);\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet w := not(0x1f)\\n\\t\\t\\tlet indexPtr := add(indices, 0x20)\\n\\t\\t\\tlet indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n\\t\\t\\tmstore(add(indicesEnd, w), mload(subject))\\n\\t\\t\\tmstore(indices, add(mload(indices), 1))\\n\\t\\t\\tlet prevIndex := 0\\n\\t\\t\\tfor {} 1 {} {\\n\\t\\t\\t\\tlet index := mload(indexPtr)\\n\\t\\t\\t\\tmstore(indexPtr, 0x60)\\n\\t\\t\\t\\tif iszero(eq(index, prevIndex)) {\\n\\t\\t\\t\\t\\tlet element := mload(0x40)\\n\\t\\t\\t\\t\\tlet elementLength := sub(index, prevIndex)\\n\\t\\t\\t\\t\\tmstore(element, elementLength)\\n\\t\\t\\t\\t\\t// Copy the `subject` one word at a time, backwards.\\n\\t\\t\\t\\t\\tfor { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n\\t\\t\\t\\t\\t\\tmstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n\\t\\t\\t\\t\\t\\to := add(o, w) // `sub(o, 0x20)`.\\n\\t\\t\\t\\t\\t\\tif iszero(o) { break }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\t\\t\\tmstore(add(add(element, 0x20), elementLength), 0)\\n\\t\\t\\t\\t\\t// Allocate memory for the length and the bytes,\\n\\t\\t\\t\\t\\t// rounded up to a multiple of 32.\\n\\t\\t\\t\\t\\tmstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n\\t\\t\\t\\t\\t// Store the `element` into the array.\\n\\t\\t\\t\\t\\tmstore(indexPtr, element)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprevIndex := add(index, mload(delimiter))\\n\\t\\t\\t\\tindexPtr := add(indexPtr, 0x20)\\n\\t\\t\\t\\tif iszero(lt(indexPtr, indicesEnd)) { break }\\n\\t\\t\\t}\\n\\t\\t\\tresult := indices\\n\\t\\t\\tif iszero(mload(delimiter)) {\\n\\t\\t\\t\\tresult := add(indices, 0x20)\\n\\t\\t\\t\\tmstore(result, sub(mload(indices), 2))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a concatenated string of `a` and `b`.\\n\\t/// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n\\tfunction concat(string memory a, string memory b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet w := not(0x1f)\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tlet aLength := mload(a)\\n\\t\\t\\t// Copy `a` one word at a time, backwards.\\n\\t\\t\\tfor { let o := and(add(aLength, 0x20), w) } 1 {} {\\n\\t\\t\\t\\tmstore(add(result, o), mload(add(a, o)))\\n\\t\\t\\t\\to := add(o, w) // `sub(o, 0x20)`.\\n\\t\\t\\t\\tif iszero(o) { break }\\n\\t\\t\\t}\\n\\t\\t\\tlet bLength := mload(b)\\n\\t\\t\\tlet output := add(result, aLength)\\n\\t\\t\\t// Copy `b` one word at a time, backwards.\\n\\t\\t\\tfor { let o := and(add(bLength, 0x20), w) } 1 {} {\\n\\t\\t\\t\\tmstore(add(output, o), mload(add(b, o)))\\n\\t\\t\\t\\to := add(o, w) // `sub(o, 0x20)`.\\n\\t\\t\\t\\tif iszero(o) { break }\\n\\t\\t\\t}\\n\\t\\t\\tlet totalLength := add(aLength, bLength)\\n\\t\\t\\tlet last := add(add(result, 0x20), totalLength)\\n\\t\\t\\t// Zeroize the slot after the string.\\n\\t\\t\\tmstore(last, 0)\\n\\t\\t\\t// Stores the length.\\n\\t\\t\\tmstore(result, totalLength)\\n\\t\\t\\t// Allocate memory for the length and the bytes,\\n\\t\\t\\t// rounded up to a multiple of 32.\\n\\t\\t\\tmstore(0x40, and(add(last, 0x1f), w))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n\\t/// WARNING! This function is only compatible with 7-bit ASCII strings.\\n\\tfunction toCase(string memory subject, bool toUpper)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet length := mload(subject)\\n\\t\\t\\tif length {\\n\\t\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\t\\t\\t\\tsubject := add(subject, 1)\\n\\t\\t\\t\\tlet flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n\\t\\t\\t\\tlet w := not(0)\\n\\t\\t\\t\\tfor { let o := length } 1 {} {\\n\\t\\t\\t\\t\\to := add(o, w)\\n\\t\\t\\t\\t\\tlet b := and(0xff, mload(add(subject, o)))\\n\\t\\t\\t\\t\\tmstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n\\t\\t\\t\\t\\tif iszero(o) { break }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\t\\tmstore(result, length) // Store the length.\\n\\t\\t\\t\\tlet last := add(add(result, 0x20), length)\\n\\t\\t\\t\\tmstore(last, 0) // Zeroize the slot after the string.\\n\\t\\t\\t\\tmstore(0x40, add(last, 0x20)) // Allocate the memory.\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a string from a small bytes32 string.\\n\\t/// `s` must be null-terminated, or behavior will be undefined.\\n\\tfunction fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tlet n := 0\\n\\t\\t\\tfor {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n\\t\\t\\tmstore(result, n)\\n\\t\\t\\tlet o := add(result, 0x20)\\n\\t\\t\\tmstore(o, s)\\n\\t\\t\\tmstore(add(o, n), 0)\\n\\t\\t\\tmstore(0x40, add(result, 0x40))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n\\tfunction normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tfor {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n\\t\\t\\tmstore(0x00, s)\\n\\t\\t\\tmstore(result, 0x00)\\n\\t\\t\\tresult := mload(0x00)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the string as a normalized null-terminated small string.\\n\\tfunction toSmallString(string memory s) internal pure returns (bytes32 result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(s)\\n\\t\\t\\tif iszero(lt(result, 33)) {\\n\\t\\t\\t\\tmstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\tresult := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a lowercased copy of the string.\\n\\t/// WARNING! This function is only compatible with 7-bit ASCII strings.\\n\\tfunction lower(string memory subject) internal pure returns (string memory result) {\\n\\t\\tresult = toCase(subject, false);\\n\\t}\\n\\n\\t/// @dev Returns an UPPERCASED copy of the string.\\n\\t/// WARNING! This function is only compatible with 7-bit ASCII strings.\\n\\tfunction upper(string memory subject) internal pure returns (string memory result) {\\n\\t\\tresult = toCase(subject, true);\\n\\t}\\n\\n\\t/// @dev Escapes the string to be used within HTML tags.\\n\\tfunction escapeHTML(string memory s) internal pure returns (string memory result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet end := add(s, mload(s))\\n\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\t\\t\\t// Store the bytes of the packed offsets and strides into the scratch space.\\n\\t\\t\\t// `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n\\t\\t\\tmstore(0x1f, 0x900094)\\n\\t\\t\\tmstore(0x08, 0xc0000000a6ab)\\n\\t\\t\\t// Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n\\t\\t\\tmstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n\\t\\t\\tfor {} iszero(eq(s, end)) {} {\\n\\t\\t\\t\\ts := add(s, 1)\\n\\t\\t\\t\\tlet c := and(mload(s), 0xff)\\n\\t\\t\\t\\t// Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n\\t\\t\\t\\tif iszero(and(shl(c, 1), 0x500000c400000000)) {\\n\\t\\t\\t\\t\\tmstore8(result, c)\\n\\t\\t\\t\\t\\tresult := add(result, 1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlet t := shr(248, mload(c))\\n\\t\\t\\t\\tmstore(result, mload(and(t, 0x1f)))\\n\\t\\t\\t\\tresult := add(result, shr(5, t))\\n\\t\\t\\t}\\n\\t\\t\\tlet last := result\\n\\t\\t\\tmstore(last, 0) // Zeroize the slot after the string.\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tmstore(result, sub(last, add(result, 0x20))) // Store the length.\\n\\t\\t\\tmstore(0x40, add(last, 0x20)) // Allocate the memory.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Escapes the string to be used within double-quotes in a JSON.\\n\\t/// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n\\tfunction escapeJSON(string memory s, bool addDoubleQuotes)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet end := add(s, mload(s))\\n\\t\\t\\tresult := add(mload(0x40), 0x20)\\n\\t\\t\\tif addDoubleQuotes {\\n\\t\\t\\t\\tmstore8(result, 34)\\n\\t\\t\\t\\tresult := add(1, result)\\n\\t\\t\\t}\\n\\t\\t\\t// Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n\\t\\t\\t// Store \\\"0123456789abcdef\\\" in scratch space.\\n\\t\\t\\t// Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n\\t\\t\\t// into the scratch space.\\n\\t\\t\\tmstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n\\t\\t\\t// Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n\\t\\t\\tlet e := or(shl(0x22, 1), shl(0x5c, 1))\\n\\t\\t\\tfor {} iszero(eq(s, end)) {} {\\n\\t\\t\\t\\ts := add(s, 1)\\n\\t\\t\\t\\tlet c := and(mload(s), 0xff)\\n\\t\\t\\t\\tif iszero(lt(c, 0x20)) {\\n\\t\\t\\t\\t\\tif iszero(and(shl(c, 1), e)) {\\n\\t\\t\\t\\t\\t\\t// Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n\\t\\t\\t\\t\\t\\tmstore8(result, c)\\n\\t\\t\\t\\t\\t\\tresult := add(result, 1)\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n\\t\\t\\t\\t\\tmstore8(add(result, 1), c)\\n\\t\\t\\t\\t\\tresult := add(result, 2)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif iszero(and(shl(c, 1), 0x3700)) {\\n\\t\\t\\t\\t\\t// Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n\\t\\t\\t\\t\\tmstore8(0x1d, mload(shr(4, c))) // Hex value.\\n\\t\\t\\t\\t\\tmstore8(0x1e, mload(and(c, 15))) // Hex value.\\n\\t\\t\\t\\t\\tmstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n\\t\\t\\t\\t\\tresult := add(result, 6)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n\\t\\t\\t\\tmstore8(add(result, 1), mload(add(c, 8)))\\n\\t\\t\\t\\tresult := add(result, 2)\\n\\t\\t\\t}\\n\\t\\t\\tif addDoubleQuotes {\\n\\t\\t\\t\\tmstore8(result, 34)\\n\\t\\t\\t\\tresult := add(1, result)\\n\\t\\t\\t}\\n\\t\\t\\tlet last := result\\n\\t\\t\\tmstore(last, 0) // Zeroize the slot after the string.\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tmstore(result, sub(last, add(result, 0x20))) // Store the length.\\n\\t\\t\\tmstore(0x40, add(last, 0x20)) // Allocate the memory.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Escapes the string to be used within double-quotes in a JSON.\\n\\tfunction escapeJSON(string memory s) internal pure returns (string memory result) {\\n\\t\\tresult = escapeJSON(s, false);\\n\\t}\\n\\n\\t/// @dev Returns whether `a` equals `b`.\\n\\tfunction eq(string memory a, string memory b) internal pure returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n\\tfunction eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// These should be evaluated on compile time, as far as possible.\\n\\t\\t\\tlet m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n\\t\\t\\tlet x := not(or(m, or(b, add(m, and(b, m)))))\\n\\t\\t\\tlet r := shl(7, iszero(iszero(shr(128, x))))\\n\\t\\t\\tr := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n\\t\\t\\tr := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\t\\t\\tr := or(r, shl(4, lt(0xffff, shr(r, x))))\\n\\t\\t\\tr := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\t\\t\\t// forgefmt: disable-next-item\\n\\t\\t\\tresult := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n\\t\\t\\t\\txor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Packs a single string with its length into a single word.\\n\\t/// Returns `bytes32(0)` if the length is zero or greater than 31.\\n\\tfunction packOne(string memory a) internal pure returns (bytes32 result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// We don't need to zero right pad the string,\\n\\t\\t\\t// since this is our own custom non-standard packing scheme.\\n\\t\\t\\tresult :=\\n\\t\\t\\t\\tmul(\\n\\t\\t\\t\\t\\t// Load the length and the bytes.\\n\\t\\t\\t\\t\\tmload(add(a, 0x1f)),\\n\\t\\t\\t\\t\\t// `length != 0 && length < 32`. Abuses underflow.\\n\\t\\t\\t\\t\\t// Assumes that the length is valid and within the block gas limit.\\n\\t\\t\\t\\t\\tlt(sub(mload(a), 1), 0x1f)\\n\\t\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Unpacks a string packed using {packOne}.\\n\\t/// Returns the empty string if `packed` is `bytes32(0)`.\\n\\t/// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n\\tfunction unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Grab the free memory pointer.\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\t// Allocate 2 words (1 for the length, 1 for the bytes).\\n\\t\\t\\tmstore(0x40, add(result, 0x40))\\n\\t\\t\\t// Zeroize the length slot.\\n\\t\\t\\tmstore(result, 0)\\n\\t\\t\\t// Store the length and bytes.\\n\\t\\t\\tmstore(add(result, 0x1f), packed)\\n\\t\\t\\t// Right pad with zeroes.\\n\\t\\t\\tmstore(add(add(result, 0x20), mload(result)), 0)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Packs two strings with their lengths into a single word.\\n\\t/// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n\\tfunction packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet aLength := mload(a)\\n\\t\\t\\t// We don't need to zero right pad the strings,\\n\\t\\t\\t// since this is our own custom non-standard packing scheme.\\n\\t\\t\\tresult :=\\n\\t\\t\\t\\tmul(\\n\\t\\t\\t\\t\\t// Load the length and the bytes of `a` and `b`.\\n\\t\\t\\t\\t\\tor(\\n\\t\\t\\t\\t\\t\\tshl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n\\t\\t\\t\\t\\t\\tmload(sub(add(b, 0x1e), aLength))\\n\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t// `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n\\t\\t\\t\\t\\t// Assumes that the lengths are valid and within the block gas limit.\\n\\t\\t\\t\\t\\tlt(sub(add(aLength, mload(b)), 1), 0x1e)\\n\\t\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Unpacks strings packed using {packTwo}.\\n\\t/// Returns the empty strings if `packed` is `bytes32(0)`.\\n\\t/// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n\\tfunction unpackTwo(bytes32 packed)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (string memory resultA, string memory resultB)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Grab the free memory pointer.\\n\\t\\t\\tresultA := mload(0x40)\\n\\t\\t\\tresultB := add(resultA, 0x40)\\n\\t\\t\\t// Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n\\t\\t\\tmstore(0x40, add(resultB, 0x40))\\n\\t\\t\\t// Zeroize the length slots.\\n\\t\\t\\tmstore(resultA, 0)\\n\\t\\t\\tmstore(resultB, 0)\\n\\t\\t\\t// Store the lengths and bytes.\\n\\t\\t\\tmstore(add(resultA, 0x1f), packed)\\n\\t\\t\\tmstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n\\t\\t\\t// Right pad with zeroes.\\n\\t\\t\\tmstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n\\t\\t\\tmstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Directly returns `a` without copying.\\n\\tfunction directReturn(string memory a) internal pure {\\n\\t\\tassembly {\\n\\t\\t\\t// Assumes that the string does not start from the scratch space.\\n\\t\\t\\tlet retStart := sub(a, 0x20)\\n\\t\\t\\tlet retSize := add(mload(a), 0x40)\\n\\t\\t\\t// Right pad with zeroes. Just in case the string is produced\\n\\t\\t\\t// by a method that doesn't zero right pad.\\n\\t\\t\\tmstore(add(retStart, retSize), 0)\\n\\t\\t\\t// Store the return offset.\\n\\t\\t\\tmstore(retStart, 0x20)\\n\\t\\t\\t// End the transaction, returning the string.\\n\\t\\t\\treturn(retStart, retSize)\\n\\t\\t}\\n\\t}\\n}\\n\\n// File: https://github.com/Vectorized/solady/blob/main/src/auth/Ownable.sol\\n\\n\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                       CUSTOM ERRORS                        */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The caller is not authorized to call the function.\\n\\terror Unauthorized();\\n\\n\\t/// @dev The `newOwner` cannot be the zero address.\\n\\terror NewOwnerIsZeroAddress();\\n\\n\\t/// @dev The `pendingOwner` does not have a valid handover request.\\n\\terror NoHandoverRequest();\\n\\n\\t/// @dev Cannot double-initialize.\\n\\terror AlreadyInitialized();\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                           EVENTS                           */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n\\t/// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n\\t/// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n\\t/// despite it not being as lightweight as a single argument event.\\n\\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n\\t/// @dev An ownership handover to `pendingOwner` has been requested.\\n\\tevent OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n\\t/// @dev The ownership handover to `pendingOwner` has been canceled.\\n\\tevent OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n\\t/// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n\\tuint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n\\t\\t0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n\\t/// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n\\tuint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n\\t\\t0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n\\t/// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n\\tuint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n\\t\\t0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                          STORAGE                           */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev The owner slot is given by:\\n\\t/// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n\\t/// It is intentionally chosen to be a high value\\n\\t/// to avoid collision with lower slots.\\n\\t/// The choice of manual storage layout is to enable compatibility\\n\\t/// with both regular and upgradeable contracts.\\n\\tbytes32 internal constant _OWNER_SLOT =\\n\\t\\t0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n\\t/// The ownership handover slot of `newOwner` is given by:\\n\\t/// ```\\n\\t///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n\\t///     let handoverSlot := keccak256(0x00, 0x20)\\n\\t/// ```\\n\\t/// It stores the expiry timestamp of the two-step ownership handover.\\n\\tuint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                     INTERNAL FUNCTIONS                     */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n\\tfunction _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n\\t/// @dev Initializes the owner directly without authorization guard.\\n\\t/// This function must be called upon initialization,\\n\\t/// regardless of whether the contract is upgradeable or not.\\n\\t/// This is to enable generalization to both regular and upgradeable contracts,\\n\\t/// and to save gas in case the initial owner is not the caller.\\n\\t/// For performance reasons, this function will not check if there\\n\\t/// is an existing owner.\\n\\tfunction _initializeOwner(address newOwner) internal virtual {\\n\\t\\tif (_guardInitializeOwner()) {\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet ownerSlot := _OWNER_SLOT\\n\\t\\t\\t\\tif sload(ownerSlot) {\\n\\t\\t\\t\\t\\tmstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n\\t\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Clean the upper 96 bits.\\n\\t\\t\\t\\tnewOwner := shr(96, shl(96, newOwner))\\n\\t\\t\\t\\t// Store the new value.\\n\\t\\t\\t\\tsstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n\\t\\t\\t\\t// Emit the {OwnershipTransferred} event.\\n\\t\\t\\t\\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t// Clean the upper 96 bits.\\n\\t\\t\\t\\tnewOwner := shr(96, shl(96, newOwner))\\n\\t\\t\\t\\t// Store the new value.\\n\\t\\t\\t\\tsstore(_OWNER_SLOT, newOwner)\\n\\t\\t\\t\\t// Emit the {OwnershipTransferred} event.\\n\\t\\t\\t\\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets the owner directly without authorization guard.\\n\\tfunction _setOwner(address newOwner) internal virtual {\\n\\t\\tif (_guardInitializeOwner()) {\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet ownerSlot := _OWNER_SLOT\\n\\t\\t\\t\\t// Clean the upper 96 bits.\\n\\t\\t\\t\\tnewOwner := shr(96, shl(96, newOwner))\\n\\t\\t\\t\\t// Emit the {OwnershipTransferred} event.\\n\\t\\t\\t\\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n\\t\\t\\t\\t// Store the new value.\\n\\t\\t\\t\\tsstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet ownerSlot := _OWNER_SLOT\\n\\t\\t\\t\\t// Clean the upper 96 bits.\\n\\t\\t\\t\\tnewOwner := shr(96, shl(96, newOwner))\\n\\t\\t\\t\\t// Emit the {OwnershipTransferred} event.\\n\\t\\t\\t\\tlog3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n\\t\\t\\t\\t// Store the new value.\\n\\t\\t\\t\\tsstore(ownerSlot, newOwner)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Throws if the sender is not the owner.\\n\\tfunction _checkOwner() internal view virtual {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// If the caller is not the stored owner, revert.\\n\\t\\t\\tif iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n\\t\\t\\t\\tmstore(0x00, 0x82b42900) // `Unauthorized()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n\\t/// Override to return a different value if needed.\\n\\t/// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n\\tfunction _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n\\t\\treturn 48 * 3600;\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                  PUBLIC UPDATE FUNCTIONS                   */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Allows the owner to transfer the ownership to `newOwner`.\\n\\tfunction transferOwnership(address newOwner) public payable virtual onlyOwner {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tif iszero(shl(96, newOwner)) {\\n\\t\\t\\t\\tmstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_setOwner(newOwner);\\n\\t}\\n\\n\\t/// @dev Allows the owner to renounce their ownership.\\n\\tfunction renounceOwnership() public payable virtual onlyOwner {\\n\\t\\t_setOwner(address(0));\\n\\t}\\n\\n\\t/// @dev Request a two-step ownership handover to the caller.\\n\\t/// The request will automatically expire in 48 hours (172800 seconds) by default.\\n\\tfunction requestOwnershipHandover() public payable virtual {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t// Compute and set the handover slot to `expires`.\\n\\t\\t\\t\\tmstore(0x0c, _HANDOVER_SLOT_SEED)\\n\\t\\t\\t\\tmstore(0x00, caller())\\n\\t\\t\\t\\tsstore(keccak256(0x0c, 0x20), expires)\\n\\t\\t\\t\\t// Emit the {OwnershipHandoverRequested} event.\\n\\t\\t\\t\\tlog2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Cancels the two-step ownership handover to the caller, if any.\\n\\tfunction cancelOwnershipHandover() public payable virtual {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Compute and set the handover slot to 0.\\n\\t\\t\\tmstore(0x0c, _HANDOVER_SLOT_SEED)\\n\\t\\t\\tmstore(0x00, caller())\\n\\t\\t\\tsstore(keccak256(0x0c, 0x20), 0)\\n\\t\\t\\t// Emit the {OwnershipHandoverCanceled} event.\\n\\t\\t\\tlog2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n\\t/// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n\\tfunction completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Compute and set the handover slot to 0.\\n\\t\\t\\tmstore(0x0c, _HANDOVER_SLOT_SEED)\\n\\t\\t\\tmstore(0x00, pendingOwner)\\n\\t\\t\\tlet handoverSlot := keccak256(0x0c, 0x20)\\n\\t\\t\\t// If the handover does not exist, or has expired.\\n\\t\\t\\tif gt(timestamp(), sload(handoverSlot)) {\\n\\t\\t\\t\\tmstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t\\t// Set the handover slot to 0.\\n\\t\\t\\tsstore(handoverSlot, 0)\\n\\t\\t}\\n\\t\\t_setOwner(pendingOwner);\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                   PUBLIC READ FUNCTIONS                    */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Returns the owner of the contract.\\n\\tfunction owner() public view virtual returns (address result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := sload(_OWNER_SLOT)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n\\tfunction ownershipHandoverExpiresAt(address pendingOwner)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256 result)\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Compute the handover slot.\\n\\t\\t\\tmstore(0x0c, _HANDOVER_SLOT_SEED)\\n\\t\\t\\tmstore(0x00, pendingOwner)\\n\\t\\t\\t// Load the handover slot.\\n\\t\\t\\tresult := sload(keccak256(0x0c, 0x20))\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n\\t/*                         MODIFIERS                          */\\n\\t/*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n\\t/// @dev Marks a function as only callable by the owner.\\n\\tmodifier onlyOwner() virtual {\\n\\t\\t_checkOwner();\\n\\t\\t_;\\n\\t}\\n}\\n\\n// File: https://github.com/Vectorized/dn404/blob/main/src/DN404Mirror.sol\\n\\n\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror is Ownable {\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                           EVENTS                           */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Emitted when token `id` is transferred from `from` to `to`.\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n\\t/// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n\\tevent Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n\\t/// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n\\t/// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n\\tuint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n\\t\\t0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n\\t/// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n\\tuint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n\\t\\t0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n\\t/// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n\\tuint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n\\t\\t0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                        CUSTOM ERRORS                       */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Thrown when a call for an NFT function did not originate\\n\\t/// from the base DN404 contract.\\n\\terror SenderNotBase();\\n\\n\\t/// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n\\terror SenderNotDeployer();\\n\\n\\t/// @dev Thrown when transferring an NFT to a contract address that\\n\\t/// does not implement ERC721Receiver.\\n\\terror TransferToNonERC721ReceiverImplementer();\\n\\n\\t/// @dev Thrown when linking to the DN404 base contract and the\\n\\t/// DN404 supportsInterface check fails or the call reverts.\\n\\terror CannotLink();\\n\\n\\t/// @dev Thrown when a linkMirrorContract call is received and the\\n\\t/// NFT mirror contract has already been linked to a DN404 base contract.\\n\\terror AlreadyLinked();\\n\\n\\t/// @dev Thrown when retrieving the base DN404 address when a link has not\\n\\t/// been established.\\n\\terror NotLinked();\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                          STORAGE                           */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Struct contain the NFT mirror contract storage.\\n\\tstruct DN404NFTStorage {\\n\\t\\taddress baseERC20;\\n\\t\\taddress deployer;\\n\\t}\\n\\n\\t/// @dev Returns a storage pointer for DN404NFTStorage.\\n\\tfunction _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n\\t\\t\\t$.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                        CONSTRUCTOR                         */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\tconstructor(address deployer) {\\n\\t\\t// For non-proxies, we will store the deployer so that only the deployer can\\n\\t\\t// link the base contract.\\n\\t\\t_getDN404NFTStorage().deployer = deployer;\\n\\t\\t_initializeOwner(deployer);\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                     ERC721 OPERATIONS                      */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the token collection name from the base DN404 contract.\\n\\tfunction name() public view virtual returns (string memory result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tmstore(0x00, 0x06fdde03) // `name()`.\\n\\t\\t\\tif iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n\\t\\t\\t\\treturndatacopy(result, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(result, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\treturndatacopy(0x00, 0x00, 0x20)\\n\\t\\t\\treturndatacopy(result, mload(0x00), 0x20)\\n\\t\\t\\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n\\t\\t\\tmstore(0x40, add(add(result, 0x20), mload(result)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the token collection symbol from the base DN404 contract.\\n\\tfunction symbol() public view virtual returns (string memory result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tmstore(0x00, 0x95d89b41) // `symbol()`.\\n\\t\\t\\tif iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n\\t\\t\\t\\treturndatacopy(result, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(result, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\treturndatacopy(0x00, 0x00, 0x20)\\n\\t\\t\\treturndatacopy(result, mload(0x00), 0x20)\\n\\t\\t\\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n\\t\\t\\tmstore(0x40, add(add(result, 0x20), mload(result)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n\\t/// the base DN404 contract.\\n\\tfunction tokenURI(uint256 id) public view virtual returns (string memory result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(0x40)\\n\\t\\t\\tmstore(0x20, id)\\n\\t\\t\\tmstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n\\t\\t\\tif iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n\\t\\t\\t\\treturndatacopy(result, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(result, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\treturndatacopy(0x00, 0x00, 0x20)\\n\\t\\t\\treturndatacopy(result, mload(0x00), 0x20)\\n\\t\\t\\treturndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n\\t\\t\\tmstore(0x40, add(add(result, 0x20), mload(result)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the total NFT supply from the base DN404 contract.\\n\\tfunction totalSupply() public view virtual returns (uint256 result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(mload(0x40), 0x00, returndatasize())\\n\\t\\t\\t\\trevert(mload(0x40), returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tresult := mload(0x00)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - `owner` must not be the zero address.\\n\\tfunction balanceOf(address owner) public view virtual returns (uint256 result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x20, shr(96, shl(96, owner)))\\n\\t\\t\\tmstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(mload(0x40), 0x00, returndatasize())\\n\\t\\t\\t\\trevert(mload(0x40), returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tresult := mload(0x00)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the owner of token `id` from the base DN404 contract.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - Token `id` must exist.\\n\\tfunction ownerOf(uint256 id) public view virtual returns (address result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n\\t\\t\\tmstore(0x20, id)\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(mload(0x40), 0x00, returndatasize())\\n\\t\\t\\t\\trevert(mload(0x40), returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tresult := shr(96, mload(0x0c))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets `spender` as the approved account to manage token `id` in\\n\\t/// the base DN404 contract.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - Token `id` must exist.\\n\\t/// - The caller must be the owner of the token,\\n\\t///   or an approved operator for the token owner.\\n\\t///\\n\\t/// Emits an {Approval} event.\\n\\tfunction approve(address spender, uint256 id) public virtual {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tspender := shr(96, shl(96, spender))\\n\\t\\t\\tlet m := mload(0x40)\\n\\t\\t\\tmstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n\\t\\t\\tmstore(0x20, spender)\\n\\t\\t\\tmstore(0x40, id)\\n\\t\\t\\tmstore(0x60, caller())\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(\\n\\t\\t\\t\\t\\tgt(returndatasize(), 0x1f),\\n\\t\\t\\t\\t\\tcall(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(m, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(m, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x40, m) // Restore the free memory pointer.\\n\\t\\t\\tmstore(0x60, 0) // Restore the zero pointer.\\n\\t\\t\\t// Emit the {Approval} event.\\n\\t\\t\\tlog4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the account approved to manage token `id` from\\n\\t/// the base DN404 contract.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - Token `id` must exist.\\n\\tfunction getApproved(uint256 id) public view virtual returns (address result) {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n\\t\\t\\tmstore(0x20, id)\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(mload(0x40), 0x00, returndatasize())\\n\\t\\t\\t\\trevert(mload(0x40), returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tresult := shr(96, mload(0x0c))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n\\t/// the base DN404 contract.\\n\\t///\\n\\t/// Emits an {ApprovalForAll} event.\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\toperator := shr(96, shl(96, operator))\\n\\t\\t\\tlet m := mload(0x40)\\n\\t\\t\\tmstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n\\t\\t\\tmstore(0x20, operator)\\n\\t\\t\\tmstore(0x40, iszero(iszero(approved)))\\n\\t\\t\\tmstore(0x60, caller())\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(m, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(m, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\t// Emit the {ApprovalForAll} event.\\n\\t\\t\\tlog3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n\\t\\t\\tmstore(0x40, m) // Restore the free memory pointer.\\n\\t\\t\\tmstore(0x60, 0) // Restore the zero pointer.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n\\t/// the base DN404 contract.\\n\\tfunction isApprovedForAll(address owner, address operator)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (bool result)\\n\\t{\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet m := mload(0x40)\\n\\t\\t\\tmstore(0x40, operator)\\n\\t\\t\\tmstore(0x2c, shl(96, owner))\\n\\t\\t\\tmstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(m, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(m, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tmstore(0x40, m) // Restore the free memory pointer.\\n\\t\\t\\tresult := iszero(iszero(mload(0x00)))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Transfers token `id` from `from` to `to`.\\n\\t///\\n\\t/// Requirements:\\n\\t///\\n\\t/// - Token `id` must exist.\\n\\t/// - `from` must be the owner of the token.\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - The caller must be the owner of the token, or be approved to manage the token.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction transferFrom(address from, address to, uint256 id) public virtual {\\n\\t\\taddress base = baseERC20();\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tfrom := shr(96, shl(96, from))\\n\\t\\t\\tto := shr(96, shl(96, to))\\n\\t\\t\\tlet m := mload(0x40)\\n\\t\\t\\tmstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n\\t\\t\\tmstore(add(m, 0x20), from)\\n\\t\\t\\tmstore(add(m, 0x40), to)\\n\\t\\t\\tmstore(add(m, 0x60), id)\\n\\t\\t\\tmstore(add(m, 0x80), caller())\\n\\t\\t\\tif iszero(\\n\\t\\t\\t\\tand(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturndatacopy(m, 0x00, returndatasize())\\n\\t\\t\\t\\trevert(m, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\t// Emit the {Transfer} event.\\n\\t\\t\\tlog4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n\\tfunction safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n\\t\\ttransferFrom(from, to, id);\\n\\n\\t\\tif (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n\\t}\\n\\n\\t/// @dev Transfers token `id` from `from` to `to`.\\n\\t///\\n\\t/// Requirements:\\n\\t///\\n\\t/// - Token `id` must exist.\\n\\t/// - `from` must be the owner of the token.\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - The caller must be the owner of the token, or be approved to manage the token.\\n\\t/// - If `to` refers to a smart contract, it must implement\\n\\t///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n\\t\\tpublic\\n\\t\\tvirtual\\n\\t{\\n\\t\\ttransferFrom(from, to, id);\\n\\n\\t\\tif (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n\\t}\\n\\n\\t/// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n\\t/// See: https://eips.ethereum.org/EIPS/eip-165\\n\\t/// This function call must use less than 30000 gas.\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet s := shr(224, interfaceId)\\n\\t\\t\\t// ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n\\t\\t\\tresult := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                     MIRROR OPERATIONS                      */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the address of the base DN404 contract.\\n\\tfunction baseERC20() public view virtual returns (address base) {\\n\\t\\tbase = _getDN404NFTStorage().baseERC20;\\n\\t\\tif (base == address(0)) revert NotLinked();\\n\\t}\\n\\n\\t/// @dev Fallback modifier to execute calls from the base DN404 contract.\\n\\tmodifier dn404NFTFallback() virtual {\\n\\t\\tDN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n\\t\\tuint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n\\t\\t// `logTransfer(uint256[])`.\\n\\t\\tif (fnSelector == 0x263c69d6) {\\n\\t\\t\\tif (msg.sender != $.baseERC20) revert SenderNotBase();\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t// When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n\\t\\t\\t\\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n\\t\\t\\t\\tlet o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n\\t\\t\\t\\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n\\t\\t\\t\\tlet end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n\\t\\t\\t\\treturndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n\\t\\t\\t\\tfor {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n\\t\\t\\t\\t\\tlet d := calldataload(o) // Entry in the packed logs.\\n\\t\\t\\t\\t\\tlet a := shr(96, d) // The address.\\n\\t\\t\\t\\t\\tlet b := and(1, d) // Whether it is a burn.\\n\\t\\t\\t\\t\\tlog4(\\n\\t\\t\\t\\t\\t\\tcodesize(),\\n\\t\\t\\t\\t\\t\\t0x00,\\n\\t\\t\\t\\t\\t\\t_TRANSFER_EVENT_SIGNATURE,\\n\\t\\t\\t\\t\\t\\tmul(a, b),\\n\\t\\t\\t\\t\\t\\tmul(a, iszero(b)),\\n\\t\\t\\t\\t\\t\\tshr(168, shl(160, d))\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmstore(0x00, 0x01)\\n\\t\\t\\t\\treturn(0x00, 0x20)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// `linkMirrorContract(address)`.\\n\\t\\tif (fnSelector == 0x0f4599e5) {\\n\\t\\t\\tif ($.deployer != address(0)) {\\n\\t\\t\\t\\tif (address(uint160(_calldataload(0x04))) != $.deployer) {\\n\\t\\t\\t\\t\\trevert SenderNotDeployer();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ($.baseERC20 != address(0)) revert AlreadyLinked();\\n\\t\\t\\t$.baseERC20 = msg.sender;\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(0x00, 0x01)\\n\\t\\t\\t\\treturn(0x00, 0x20)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @dev Fallback function for calls from base DN404 contract.\\n\\tfallback() external payable virtual dn404NFTFallback {}\\n\\n\\treceive() external payable virtual {}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                      PRIVATE HELPERS                       */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the calldata value at `offset`.\\n\\tfunction _calldataload(uint256 offset) private pure returns (uint256 value) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tvalue := calldataload(offset)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns if `a` has bytecode of non-zero length.\\n\\tfunction _hasCode(address a) private view returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := extcodesize(a) // Can handle dirty upper bits.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n\\t/// Reverts if the target does not support the function correctly.\\n\\tfunction _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n\\t\\tprivate\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Prepare the calldata.\\n\\t\\t\\tlet m := mload(0x40)\\n\\t\\t\\tlet onERC721ReceivedSelector := 0x150b7a02\\n\\t\\t\\tmstore(m, onERC721ReceivedSelector)\\n\\t\\t\\tmstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n\\t\\t\\tmstore(add(m, 0x40), shr(96, shl(96, from)))\\n\\t\\t\\tmstore(add(m, 0x60), id)\\n\\t\\t\\tmstore(add(m, 0x80), 0x80)\\n\\t\\t\\tlet n := mload(data)\\n\\t\\t\\tmstore(add(m, 0xa0), n)\\n\\t\\t\\tif n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n\\t\\t\\t// Revert if the call reverts.\\n\\t\\t\\tif iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n\\t\\t\\t\\tif returndatasize() {\\n\\t\\t\\t\\t\\t// Bubble up the revert if the call reverts.\\n\\t\\t\\t\\t\\treturndatacopy(m, 0x00, returndatasize())\\n\\t\\t\\t\\t\\trevert(m, returndatasize())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Load the returndata and compare it.\\n\\t\\t\\tif iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n\\t\\t\\t\\tmstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n// File: https://github.com/Vectorized/dn404/blob/main/src/DN404.sol\\n\\n\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                           EVENTS                           */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n\\tevent Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n\\t/// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n\\t/// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n\\tevent SkipNFTSet(address indexed target, bool status);\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                        CUSTOM ERRORS                       */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Thrown when attempting to double-initialize the contract.\\n\\terror DNAlreadyInitialized();\\n\\n\\t/// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n\\terror InsufficientBalance();\\n\\n\\t/// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n\\terror InsufficientAllowance();\\n\\n\\t/// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n\\terror TotalSupplyOverflow();\\n\\n\\t/// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n\\terror SenderNotMirror();\\n\\n\\t/// @dev Thrown when attempting to transfer tokens to the zero address.\\n\\terror TransferToZeroAddress();\\n\\n\\t/// @dev Thrown when the mirror address provided for initialization is the zero address.\\n\\terror MirrorAddressIsZero();\\n\\n\\t/// @dev Thrown when the link call to the mirror contract reverts.\\n\\terror LinkMirrorContractFailed();\\n\\n\\t/// @dev Thrown when setting an NFT token approval\\n\\t/// and the caller is not the owner or an approved operator.\\n\\terror ApprovalCallerNotOwnerNorApproved();\\n\\n\\t/// @dev Thrown when transferring an NFT\\n\\t/// and the caller is not the owner or an approved operator.\\n\\terror TransferCallerNotOwnerNorApproved();\\n\\n\\t/// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n\\terror TransferFromIncorrectOwner();\\n\\n\\t/// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n\\terror TokenDoesNotExist();\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                         CONSTANTS                          */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Amount of token balance that is equal to one NFT.\\n\\tuint256 internal constant _WAD = 10 ** 18;\\n\\n\\t/// @dev The maximum token ID allowed for an NFT.\\n\\tuint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n\\t/// @dev The maximum possible token supply.\\n\\tuint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n\\t/// @dev The flag to denote that the address data is initialized.\\n\\tuint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n\\t/// @dev The flag to denote that the address should skip NFTs.\\n\\tuint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                          STORAGE                           */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Struct containing an address's token data and settings.\\n\\tstruct AddressData {\\n\\t\\t// Auxiliary data.\\n\\t\\tuint88 aux;\\n\\t\\t// Flags for `initialized` and `skipNFT`.\\n\\t\\tuint8 flags;\\n\\t\\t// The alias for the address. Zero means absence of an alias.\\n\\t\\tuint32 addressAlias;\\n\\t\\t// The number of NFT tokens.\\n\\t\\tuint32 ownedLength;\\n\\t\\t// The token balance in wei.\\n\\t\\tuint96 balance;\\n\\t}\\n\\n\\t/// @dev A uint32 map in storage.\\n\\tstruct Uint32Map {\\n\\t\\tmapping(uint256 => uint256) map;\\n\\t}\\n\\n\\t/// @dev Struct containing the base token contract storage.\\n\\tstruct DN404Storage {\\n\\t\\t// Current number of address aliases assigned.\\n\\t\\tuint32 numAliases;\\n\\t\\t// Next token ID to assign for an NFT mint.\\n\\t\\tuint32 nextTokenId;\\n\\t\\t// Total supply of minted NFTs.\\n\\t\\tuint32 totalNFTSupply;\\n\\t\\t// Total supply of tokens.\\n\\t\\tuint96 totalSupply;\\n\\t\\t// Address of the NFT mirror contract.\\n\\t\\taddress mirrorERC721;\\n\\t\\t// Mapping of a user alias number to their address.\\n\\t\\tmapping(uint32 => address) aliasToAddress;\\n\\t\\t// Mapping of user operator approvals for NFTs.\\n\\t\\tmapping(address => mapping(address => bool)) operatorApprovals;\\n\\t\\t// Mapping of NFT token approvals to approved operators.\\n\\t\\tmapping(uint256 => address) tokenApprovals;\\n\\t\\t// Mapping of user allowances for token spenders.\\n\\t\\tmapping(address => mapping(address => uint256)) allowance;\\n\\t\\t// Mapping of NFT token IDs owned by an address.\\n\\t\\tmapping(address => Uint32Map) owned;\\n\\t\\t// Even indices: owner aliases. Odd indices: owned indices.\\n\\t\\tUint32Map oo;\\n\\t\\t// Mapping of user account AddressData\\n\\t\\tmapping(address => AddressData) addressData;\\n\\t}\\n\\n\\t/// @dev Returns a storage pointer for DN404Storage.\\n\\tfunction _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n\\t\\t\\t$.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                         INITIALIZER                        */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Initializes the DN404 contract with an\\n\\t/// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n\\tfunction _initializeDN404(\\n\\t\\tuint256 initialTokenSupply,\\n\\t\\taddress initialSupplyOwner,\\n\\t\\taddress mirror\\n\\t) internal virtual {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tif ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n\\t\\tif (mirror == address(0)) revert MirrorAddressIsZero();\\n\\t\\t_linkMirrorContract(mirror);\\n\\n\\t\\t$.nextTokenId = 1;\\n\\t\\t$.mirrorERC721 = mirror;\\n\\n\\t\\tif (initialTokenSupply > 0) {\\n\\t\\t\\tif (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n\\t\\t\\tif (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n\\t\\t\\t$.totalSupply = uint96(initialTokenSupply);\\n\\t\\t\\tAddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n\\t\\t\\tinitialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n\\t\\t\\temit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n\\t\\t\\t_setSkipNFT(initialSupplyOwner, true);\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*               METADATA FUNCTIONS TO OVERRIDE               */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the name of the token.\\n\\tfunction name() public view virtual returns (string memory);\\n\\n\\t/// @dev Returns the symbol of the token.\\n\\tfunction symbol() public view virtual returns (string memory);\\n\\n\\t/// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n\\tfunction tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                      ERC20 OPERATIONS                      */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the decimals places of the token. Always 18.\\n\\tfunction decimals() public pure returns (uint8) {\\n\\t\\treturn 18;\\n\\t}\\n\\n\\t/// @dev Returns the amount of tokens in existence.\\n\\tfunction totalSupply() public view virtual returns (uint256) {\\n\\t\\treturn uint256(_getDN404Storage().totalSupply);\\n\\t}\\n\\n\\t/// @dev Returns the amount of tokens owned by `owner`.\\n\\tfunction balanceOf(address owner) public view virtual returns (uint256) {\\n\\t\\treturn _getDN404Storage().addressData[owner].balance;\\n\\t}\\n\\n\\t/// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n\\tfunction allowance(address owner, address spender) public view returns (uint256) {\\n\\t\\treturn _getDN404Storage().allowance[owner][spender];\\n\\t}\\n\\n\\t/// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n\\t///\\n\\t/// Emits a {Approval} event.\\n\\tfunction approve(address spender, uint256 amount) public virtual returns (bool) {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\t$.allowance[msg.sender][spender] = amount;\\n\\n\\t\\temit Approval(msg.sender, spender, amount);\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/// @dev Transfer `amount` tokens from the caller to `to`.\\n\\t///\\n\\t/// Will burn sender NFTs if balance after transfer is less than\\n\\t/// the amount required to support the current NFT balance.\\n\\t///\\n\\t/// Will mint NFTs to `to` if the recipient's new balance supports\\n\\t/// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n\\t/// set to false.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - `from` must at least have `amount`.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction transfer(address to, uint256 amount) public virtual returns (bool) {\\n\\t\\t_transfer(msg.sender, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/// @dev Transfers `amount` tokens from `from` to `to`.\\n\\t///\\n\\t/// Note: Does not update the allowance if it is the maximum uint256 value.\\n\\t///\\n\\t/// Will burn sender NFTs if balance after transfer is less than\\n\\t/// the amount required to support the current NFT balance.\\n\\t///\\n\\t/// Will mint NFTs to `to` if the recipient's new balance supports\\n\\t/// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n\\t/// set to false.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - `from` must at least have `amount`.\\n\\t/// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tuint256 allowed = $.allowance[from][msg.sender];\\n\\n\\t\\tif (allowed != type(uint256).max) {\\n\\t\\t\\tif (amount > allowed) revert InsufficientAllowance();\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t$.allowance[from][msg.sender] = allowed - amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t_transfer(from, to, amount);\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                  INTERNAL MINT FUNCTIONS                   */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n\\t///\\n\\t/// Will mint NFTs to `to` if the recipient's new balance supports\\n\\t/// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n\\t/// set to false.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction _mint(address to, uint256 amount) internal virtual {\\n\\t\\tif (to == address(0)) revert TransferToZeroAddress();\\n\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tAddressData storage toAddressData = _addressData(to);\\n\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n\\t\\t\\tif (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n\\t\\t\\t\\trevert TotalSupplyOverflow();\\n\\t\\t\\t}\\n\\t\\t\\t$.totalSupply = uint96(currentTokenSupply);\\n\\n\\t\\t\\tuint256 toBalance = toAddressData.balance + amount;\\n\\t\\t\\ttoAddressData.balance = uint96(toBalance);\\n\\n\\t\\t\\tif (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n\\t\\t\\t\\tUint32Map storage toOwned = $.owned[to];\\n\\t\\t\\t\\tuint256 toIndex = toAddressData.ownedLength;\\n\\t\\t\\t\\tuint256 toEnd = toBalance / _WAD;\\n\\t\\t\\t\\t_PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n\\t\\t\\t\\tif (packedLogs.logs.length != 0) {\\n\\t\\t\\t\\t\\tuint256 maxNFTId = $.totalSupply / _WAD;\\n\\t\\t\\t\\t\\tuint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n\\t\\t\\t\\t\\tuint256 id = $.nextTokenId;\\n\\t\\t\\t\\t\\t$.totalNFTSupply += uint32(packedLogs.logs.length);\\n\\t\\t\\t\\t\\ttoAddressData.ownedLength = uint32(toEnd);\\n\\t\\t\\t\\t\\t// Mint loop.\\n\\t\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\t\\twhile (_get($.oo, _ownershipIndex(id)) != 0) {\\n\\t\\t\\t\\t\\t\\t\\tif (++id > maxNFTId) id = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t_set(toOwned, toIndex, uint32(id));\\n\\t\\t\\t\\t\\t\\t_setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n\\t\\t\\t\\t\\t\\t_packedLogsAppend(packedLogs, to, id, 0);\\n\\t\\t\\t\\t\\t\\tif (++id > maxNFTId) id = 1;\\n\\t\\t\\t\\t\\t} while (toIndex != toEnd);\\n\\t\\t\\t\\t\\t$.nextTokenId = uint32(id);\\n\\t\\t\\t\\t\\t_packedLogsSend(packedLogs, $.mirrorERC721);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit Transfer(address(0), to, amount);\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                  INTERNAL BURN FUNCTIONS                   */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n\\t///\\n\\t/// Will burn sender NFTs if balance after transfer is less than\\n\\t/// the amount required to support the current NFT balance.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction _burn(address from, uint256 amount) internal virtual {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tAddressData storage fromAddressData = _addressData(from);\\n\\n\\t\\tuint256 fromBalance = fromAddressData.balance;\\n\\t\\tif (amount > fromBalance) revert InsufficientBalance();\\n\\n\\t\\tuint256 currentTokenSupply = $.totalSupply;\\n\\n\\t\\tunchecked {\\n\\t\\t\\tfromBalance -= amount;\\n\\t\\t\\tfromAddressData.balance = uint96(fromBalance);\\n\\t\\t\\tcurrentTokenSupply -= amount;\\n\\t\\t\\t$.totalSupply = uint96(currentTokenSupply);\\n\\n\\t\\t\\tUint32Map storage fromOwned = $.owned[from];\\n\\t\\t\\tuint256 fromIndex = fromAddressData.ownedLength;\\n\\t\\t\\tuint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n\\t\\t\\tif (nftAmountToBurn != 0) {\\n\\t\\t\\t\\t$.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n\\t\\t\\t\\t_PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n\\t\\t\\t\\tuint256 fromEnd = fromIndex - nftAmountToBurn;\\n\\t\\t\\t\\t// Burn loop.\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tuint256 id = _get(fromOwned, --fromIndex);\\n\\t\\t\\t\\t\\t_setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n\\t\\t\\t\\t\\tdelete $.tokenApprovals[id];\\n\\t\\t\\t\\t\\t_packedLogsAppend(packedLogs, from, id, 1);\\n\\t\\t\\t\\t} while (fromIndex != fromEnd);\\n\\n\\t\\t\\t\\tfromAddressData.ownedLength = uint32(fromIndex);\\n\\t\\t\\t\\t_packedLogsSend(packedLogs, $.mirrorERC721);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit Transfer(from, address(0), amount);\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                INTERNAL TRANSFER FUNCTIONS                 */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Moves `amount` of tokens from `from` to `to`.\\n\\t///\\n\\t/// Will burn sender NFTs if balance after transfer is less than\\n\\t/// the amount required to support the current NFT balance.\\n\\t///\\n\\t/// Will mint NFTs to `to` if the recipient's new balance supports\\n\\t/// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n\\t/// set to false.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction _transfer(address from, address to, uint256 amount) internal virtual {\\n\\t\\tif (to == address(0)) revert TransferToZeroAddress();\\n\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tAddressData storage fromAddressData = _addressData(from);\\n\\t\\tAddressData storage toAddressData = _addressData(to);\\n\\n\\t\\t_TransferTemps memory t;\\n\\t\\tt.fromOwnedLength = fromAddressData.ownedLength;\\n\\t\\tt.toOwnedLength = toAddressData.ownedLength;\\n\\t\\tt.fromBalance = fromAddressData.balance;\\n\\n\\t\\tif (amount > t.fromBalance) revert InsufficientBalance();\\n\\n\\t\\tunchecked {\\n\\t\\t\\tt.fromBalance -= amount;\\n\\t\\t\\tfromAddressData.balance = uint96(t.fromBalance);\\n\\t\\t\\ttoAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n\\t\\t\\tt.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n\\t\\t\\tif (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n\\t\\t\\t\\tif (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n\\t\\t\\t\\tt.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n\\t\\t\\t}\\n\\n\\t\\t\\t_PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n\\t\\t\\tif (t.nftAmountToBurn != 0) {\\n\\t\\t\\t\\tUint32Map storage fromOwned = $.owned[from];\\n\\t\\t\\t\\tuint256 fromIndex = t.fromOwnedLength;\\n\\t\\t\\t\\tuint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n\\t\\t\\t\\t$.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n\\t\\t\\t\\tfromAddressData.ownedLength = uint32(fromEnd);\\n\\t\\t\\t\\t// Burn loop.\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tuint256 id = _get(fromOwned, --fromIndex);\\n\\t\\t\\t\\t\\t_setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n\\t\\t\\t\\t\\tdelete $.tokenApprovals[id];\\n\\t\\t\\t\\t\\t_packedLogsAppend(packedLogs, from, id, 1);\\n\\t\\t\\t\\t} while (fromIndex != fromEnd);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (t.nftAmountToMint != 0) {\\n\\t\\t\\t\\tUint32Map storage toOwned = $.owned[to];\\n\\t\\t\\t\\tuint256 toIndex = t.toOwnedLength;\\n\\t\\t\\t\\tuint256 toEnd = toIndex + t.nftAmountToMint;\\n\\t\\t\\t\\tuint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n\\t\\t\\t\\tuint256 maxNFTId = $.totalSupply / _WAD;\\n\\t\\t\\t\\tuint256 id = $.nextTokenId;\\n\\t\\t\\t\\t$.totalNFTSupply += uint32(t.nftAmountToMint);\\n\\t\\t\\t\\ttoAddressData.ownedLength = uint32(toEnd);\\n\\t\\t\\t\\t// Mint loop.\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\twhile (_get($.oo, _ownershipIndex(id)) != 0) {\\n\\t\\t\\t\\t\\t\\tif (++id > maxNFTId) id = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t_set(toOwned, toIndex, uint32(id));\\n\\t\\t\\t\\t\\t_setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n\\t\\t\\t\\t\\t_packedLogsAppend(packedLogs, to, id, 0);\\n\\t\\t\\t\\t\\tif (++id > maxNFTId) id = 1;\\n\\t\\t\\t\\t} while (toIndex != toEnd);\\n\\t\\t\\t\\t$.nextTokenId = uint32(id);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (packedLogs.logs.length != 0) {\\n\\t\\t\\t\\t_packedLogsSend(packedLogs, $.mirrorERC721);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit Transfer(from, to, amount);\\n\\t}\\n\\n\\t/// @dev Transfers token `id` from `from` to `to`.\\n\\t///\\n\\t/// Requirements:\\n\\t///\\n\\t/// - Call must originate from the mirror contract.\\n\\t/// - Token `id` must exist.\\n\\t/// - `from` must be the owner of the token.\\n\\t/// - `to` cannot be the zero address.\\n\\t///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n\\t///\\n\\t/// Emits a {Transfer} event.\\n\\tfunction _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t{\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tif (to == address(0)) revert TransferToZeroAddress();\\n\\n\\t\\taddress owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n\\t\\tif (from != owner) revert TransferFromIncorrectOwner();\\n\\n\\t\\tif (msgSender != from) {\\n\\t\\t\\tif (!$.operatorApprovals[from][msgSender]) {\\n\\t\\t\\t\\tif (msgSender != $.tokenApprovals[id]) {\\n\\t\\t\\t\\t\\trevert TransferCallerNotOwnerNorApproved();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tAddressData storage fromAddressData = _addressData(from);\\n\\t\\tAddressData storage toAddressData = _addressData(to);\\n\\n\\t\\tfromAddressData.balance -= uint96(_WAD);\\n\\n\\t\\tunchecked {\\n\\t\\t\\ttoAddressData.balance += uint96(_WAD);\\n\\n\\t\\t\\t_set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n\\t\\t\\tdelete $.tokenApprovals[id];\\n\\n\\t\\t\\tuint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n\\t\\t\\t_set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n\\t\\t\\tuint256 n = toAddressData.ownedLength++;\\n\\t\\t\\t_set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n\\t\\t\\t_set($.owned[to], n, uint32(id));\\n\\t\\t\\t_set($.oo, _ownedIndex(id), uint32(n));\\n\\t\\t}\\n\\n\\t\\temit Transfer(from, to, _WAD);\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                 DATA HITCHHIKING FUNCTIONS                 */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the auxiliary data for `owner`.\\n\\t/// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n\\t/// Auxiliary data can be set for any address, even if it does not have any tokens.\\n\\tfunction _getAux(address owner) internal view virtual returns (uint88) {\\n\\t\\treturn _getDN404Storage().addressData[owner].aux;\\n\\t}\\n\\n\\t/// @dev Set the auxiliary data for `owner` to `value`.\\n\\t/// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n\\t/// Auxiliary data can be set for any address, even if it does not have any tokens.\\n\\tfunction _setAux(address owner, uint88 value) internal virtual {\\n\\t\\t_getDN404Storage().addressData[owner].aux = value;\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                     SKIP NFT FUNCTIONS                     */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n\\t/// Returns false if account `a` will mint NFTs on token mints and transfers.\\n\\tfunction getSkipNFT(address a) public view virtual returns (bool) {\\n\\t\\tAddressData storage d = _getDN404Storage().addressData[a];\\n\\t\\tif (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n\\t\\treturn d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n\\t}\\n\\n\\t/// @dev Sets the caller's skipNFT flag to `skipNFT`\\n\\t///\\n\\t/// Emits a {SkipNFTSet} event.\\n\\tfunction setSkipNFT(bool skipNFT) public virtual {\\n\\t\\t_setSkipNFT(msg.sender, skipNFT);\\n\\t}\\n\\n\\t/// @dev Internal function to set account `a` skipNFT flag to `state`\\n\\t///\\n\\t/// Initializes account `a` AddressData if it is not currently initialized.\\n\\t///\\n\\t/// Emits a {SkipNFTSet} event.\\n\\tfunction _setSkipNFT(address a, bool state) internal virtual {\\n\\t\\tAddressData storage d = _addressData(a);\\n\\t\\tif ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n\\t\\t\\td.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n\\t\\t}\\n\\t\\temit SkipNFTSet(a, state);\\n\\t}\\n\\n\\t/// @dev Returns a storage data pointer for account `a` AddressData\\n\\t///\\n\\t/// Initializes account `a` AddressData if it is not currently initialized.\\n\\tfunction _addressData(address a) internal virtual returns (AddressData storage d) {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\t\\td = $.addressData[a];\\n\\n\\t\\tif (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n\\t\\t\\tuint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n\\t\\t\\tif (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n\\t\\t\\td.flags = flags;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the `addressAlias` of account `to`.\\n\\t///\\n\\t/// Assigns and registers the next alias if `to` alias was not previously registered.\\n\\tfunction _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (uint32 addressAlias)\\n\\t{\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\t\\taddressAlias = toAddressData.addressAlias;\\n\\t\\tif (addressAlias == 0) {\\n\\t\\t\\taddressAlias = ++$.numAliases;\\n\\t\\t\\ttoAddressData.addressAlias = addressAlias;\\n\\t\\t\\t$.aliasToAddress[addressAlias] = to;\\n\\t\\t}\\n\\t}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                     MIRROR OPERATIONS                      */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Returns the address of the mirror NFT contract.\\n\\tfunction mirrorERC721() public view virtual returns (address) {\\n\\t\\treturn _getDN404Storage().mirrorERC721;\\n\\t}\\n\\n\\t/// @dev Returns the total NFT supply.\\n\\tfunction _totalNFTSupply() internal view virtual returns (uint256) {\\n\\t\\treturn _getDN404Storage().totalNFTSupply;\\n\\t}\\n\\n\\t/// @dev Returns `owner` NFT balance.\\n\\tfunction _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n\\t\\treturn _getDN404Storage().addressData[owner].ownedLength;\\n\\t}\\n\\n\\t/// @dev Returns the owner of token `id`.\\n\\t/// Returns the zero address instead of reverting if the token does not exist.\\n\\tfunction _ownerAt(uint256 id) internal view virtual returns (address) {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\t\\treturn $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\t}\\n\\n\\t/// @dev Returns the owner of token `id`.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - Token `id` must exist.\\n\\tfunction _ownerOf(uint256 id) internal view virtual returns (address) {\\n\\t\\tif (!_exists(id)) revert TokenDoesNotExist();\\n\\t\\treturn _ownerAt(id);\\n\\t}\\n\\n\\t/// @dev Returns if token `id` exists.\\n\\tfunction _exists(uint256 id) internal view virtual returns (bool) {\\n\\t\\treturn _ownerAt(id) != address(0);\\n\\t}\\n\\n\\t/// @dev Returns the account approved to manage token `id`.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - Token `id` must exist.\\n\\tfunction _getApproved(uint256 id) internal view virtual returns (address) {\\n\\t\\tif (!_exists(id)) revert TokenDoesNotExist();\\n\\t\\treturn _getDN404Storage().tokenApprovals[id];\\n\\t}\\n\\n\\t/// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n\\t///\\n\\t/// Requirements:\\n\\t/// - `msgSender` must be the owner or an approved operator for the token owner.\\n\\tfunction _approveNFT(address spender, uint256 id, address msgSender)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (address)\\n\\t{\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\taddress owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n\\t\\tif (msgSender != owner) {\\n\\t\\t\\tif (!$.operatorApprovals[owner][msgSender]) {\\n\\t\\t\\t\\trevert ApprovalCallerNotOwnerNorApproved();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$.tokenApprovals[id] = spender;\\n\\n\\t\\treturn owner;\\n\\t}\\n\\n\\t/// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n\\t/// without authorization checks.\\n\\tfunction _setApprovalForAll(address operator, bool approved, address msgSender)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t{\\n\\t\\t_getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n\\t}\\n\\n\\t/// @dev Calls the mirror contract to link it to this contract.\\n\\t///\\n\\t/// Reverts if the call to the mirror contract reverts.\\n\\tfunction _linkMirrorContract(address mirror) internal virtual {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n\\t\\t\\tmstore(0x20, caller())\\n\\t\\t\\tif iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n\\t\\t\\t\\tmstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n\\t\\t\\t\\trevert(0x1c, 0x04)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n\\t/// to internal functions in this contract.\\n\\tmodifier dn404Fallback() virtual {\\n\\t\\tDN404Storage storage $ = _getDN404Storage();\\n\\n\\t\\tuint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n\\t\\t// `isApprovedForAll(address,address)`.\\n\\t\\tif (fnSelector == 0xe985e9c5) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x44) revert();\\n\\n\\t\\t\\taddress owner = address(uint160(_calldataload(0x04)));\\n\\t\\t\\taddress operator = address(uint160(_calldataload(0x24)));\\n\\n\\t\\t\\t_return($.operatorApprovals[owner][operator] ? 1 : 0);\\n\\t\\t}\\n\\t\\t// `ownerOf(uint256)`.\\n\\t\\tif (fnSelector == 0x6352211e) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x24) revert();\\n\\n\\t\\t\\tuint256 id = _calldataload(0x04);\\n\\n\\t\\t\\t_return(uint160(_ownerOf(id)));\\n\\t\\t}\\n\\t\\t// `transferFromNFT(address,address,uint256,address)`.\\n\\t\\tif (fnSelector == 0xe5eb36c8) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x84) revert();\\n\\n\\t\\t\\taddress from = address(uint160(_calldataload(0x04)));\\n\\t\\t\\taddress to = address(uint160(_calldataload(0x24)));\\n\\t\\t\\tuint256 id = _calldataload(0x44);\\n\\t\\t\\taddress msgSender = address(uint160(_calldataload(0x64)));\\n\\n\\t\\t\\t_transferFromNFT(from, to, id, msgSender);\\n\\t\\t\\t_return(1);\\n\\t\\t}\\n\\t\\t// `setApprovalForAll(address,bool,address)`.\\n\\t\\tif (fnSelector == 0x813500fc) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x64) revert();\\n\\n\\t\\t\\taddress spender = address(uint160(_calldataload(0x04)));\\n\\t\\t\\tbool status = _calldataload(0x24) != 0;\\n\\t\\t\\taddress msgSender = address(uint160(_calldataload(0x44)));\\n\\n\\t\\t\\t_setApprovalForAll(spender, status, msgSender);\\n\\t\\t\\t_return(1);\\n\\t\\t}\\n\\t\\t// `approveNFT(address,uint256,address)`.\\n\\t\\tif (fnSelector == 0xd10b6e0c) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x64) revert();\\n\\n\\t\\t\\taddress spender = address(uint160(_calldataload(0x04)));\\n\\t\\t\\tuint256 id = _calldataload(0x24);\\n\\t\\t\\taddress msgSender = address(uint160(_calldataload(0x44)));\\n\\n\\t\\t\\t_return(uint160(_approveNFT(spender, id, msgSender)));\\n\\t\\t}\\n\\t\\t// `getApproved(uint256)`.\\n\\t\\tif (fnSelector == 0x081812fc) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x24) revert();\\n\\n\\t\\t\\tuint256 id = _calldataload(0x04);\\n\\n\\t\\t\\t_return(uint160(_getApproved(id)));\\n\\t\\t}\\n\\t\\t// `balanceOfNFT(address)`.\\n\\t\\tif (fnSelector == 0xf5b100ea) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x24) revert();\\n\\n\\t\\t\\taddress owner = address(uint160(_calldataload(0x04)));\\n\\n\\t\\t\\t_return(_balanceOfNFT(owner));\\n\\t\\t}\\n\\t\\t// `totalNFTSupply()`.\\n\\t\\tif (fnSelector == 0xe2c79281) {\\n\\t\\t\\tif (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n\\t\\t\\tif (msg.data.length < 0x04) revert();\\n\\n\\t\\t\\t_return(_totalNFTSupply());\\n\\t\\t}\\n\\t\\t// `implementsDN404()`.\\n\\t\\tif (fnSelector == 0xb7a94eb8) {\\n\\t\\t\\t_return(1);\\n\\t\\t}\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @dev Fallback function for calls from mirror NFT contract.\\n\\tfallback() external payable virtual dn404Fallback {}\\n\\n\\treceive() external payable virtual {}\\n\\n\\t/*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n\\t/*                      PRIVATE HELPERS                       */\\n\\t/*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n\\t/// @dev Struct containing packed log data for `Transfer` events to be\\n\\t/// emitted by the mirror NFT contract.\\n\\tstruct _PackedLogs {\\n\\t\\tuint256[] logs;\\n\\t\\tuint256 offset;\\n\\t}\\n\\n\\t/// @dev Initiates memory allocation for packed logs with `n` log items.\\n\\tfunction _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n\\t\\t\\tmstore(logs, n)\\n\\t\\t\\tlet offset := add(0x20, logs)\\n\\t\\t\\tmstore(0x40, add(offset, shl(5, n)))\\n\\t\\t\\tmstore(p, logs)\\n\\t\\t\\tmstore(add(0x20, p), offset)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n\\tfunction _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t{\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet offset := mload(add(0x20, p))\\n\\t\\t\\tmstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n\\t\\t\\tmstore(add(0x20, p), add(offset, 0x20))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n\\tfunction _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet logs := mload(p)\\n\\t\\t\\tlet o := sub(logs, 0x40) // Start of calldata to send.\\n\\t\\t\\tmstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n\\t\\t\\tmstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n\\t\\t\\tlet n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n\\t\\t\\tif iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n\\t\\t\\t\\trevert(o, 0x00)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Struct of temporary variables for transfers.\\n\\tstruct _TransferTemps {\\n\\t\\tuint256 nftAmountToBurn;\\n\\t\\tuint256 nftAmountToMint;\\n\\t\\tuint256 fromBalance;\\n\\t\\tuint256 toBalance;\\n\\t\\tuint256 fromOwnedLength;\\n\\t\\tuint256 toOwnedLength;\\n\\t}\\n\\n\\t/// @dev Returns if `a` has bytecode of non-zero length.\\n\\tfunction _hasCode(address a) private view returns (bool result) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tresult := extcodesize(a) // Can handle dirty upper bits.\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the calldata value at `offset`.\\n\\tfunction _calldataload(uint256 offset) private pure returns (uint256 value) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tvalue := calldataload(offset)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Executes a return opcode to return `x` and end the current call frame.\\n\\tfunction _return(uint256 x) private pure {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x00, x)\\n\\t\\t\\treturn(0x00, 0x20)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns `max(0, x - y)`.\\n\\tfunction _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tz := mul(gt(x, y), sub(x, y))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns `i << 1`.\\n\\tfunction _ownershipIndex(uint256 i) private pure returns (uint256) {\\n\\t\\treturn i << 1;\\n\\t}\\n\\n\\t/// @dev Returns `(i << 1) + 1`.\\n\\tfunction _ownedIndex(uint256 i) private pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn (i << 1) + 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns the uint32 value at `index` in `map`.\\n\\tfunction _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n\\t\\tresult = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n\\t}\\n\\n\\t/// @dev Updates the uint32 value at `index` in `map`.\\n\\tfunction _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tmstore(0x20, map.slot)\\n\\t\\t\\tmstore(0x00, shr(3, index))\\n\\t\\t\\tlet s := keccak256(0x00, 0x40) // Storage slot.\\n\\t\\t\\tlet o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n\\t\\t\\tlet v := sload(s) // Storage slot value.\\n\\t\\t\\tlet m := 0xffffffff // Value mask.\\n\\t\\t\\tsstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets the owner alias and the owned index together.\\n\\tfunction _setOwnerAliasAndOwnedIndex(\\n\\t\\tUint32Map storage map,\\n\\t\\tuint256 id,\\n\\t\\tuint32 ownership,\\n\\t\\tuint32 ownedIndex\\n\\t) private {\\n\\t\\t/// @solidity memory-safe-assembly\\n\\t\\tassembly {\\n\\t\\t\\tlet value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n\\t\\t\\tmstore(0x20, map.slot)\\n\\t\\t\\tmstore(0x00, shr(2, id))\\n\\t\\t\\tlet s := keccak256(0x00, 0x40) // Storage slot.\\n\\t\\t\\tlet o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n\\t\\t\\tlet v := sload(s) // Storage slot value.\\n\\t\\t\\tlet m := 0xffffffffffffffff // Value mask.\\n\\t\\t\\tsstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n\\t\\t}\\n\\t}\\n}\\n\\n// File: contracts/dndblocks.sol\\n\\n\\npragma solidity ^0.8.4;\\n\\n\\n\\n\\n\\n\\ncontract SimpleDN404 is DN404, Ownable {\\n\\tstring private _name;\\n\\tstring private _symbol;\\n\\tstring private _baseURI;\\n\\n\\tconstructor(\\n\\t\\tstring memory name_,\\n\\t\\tstring memory symbol_,\\n\\t\\tuint96 initialTokenSupply,\\n\\t\\taddress initialSupplyOwner\\n\\t) {\\n\\t\\t_initializeOwner(msg.sender);\\n\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\n\\t\\taddress mirror = address(new DN404Mirror(msg.sender));\\n\\t\\t_initializeDN404(initialTokenSupply, initialSupplyOwner, mirror);\\n\\t}\\n\\n\\tfunction name() public view override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction symbol() public view override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) public view override returns (string memory result) {\\n\\t\\tif (bytes(_baseURI).length != 0) {\\n\\t\\t\\tuint256 seed = uint256(keccak256(abi.encodePacked(tokenId, address(this))));\\n\\t\\t\\tresult = string(abi.encodePacked(_baseURI, LibString.toString(seed),\\\".json\\\"));\\n\\t\\t}\\n\\t}\\n\\n\\t// This allows the owner of the contract to mint more tokens.\\n\\tfunction mint(address to, uint256 amount) public onlyOwner {\\n\\t\\t_mint(to, amount);\\n\\t}\\n\\n\\tfunction setBaseURI(string calldata baseURI_) public onlyOwner {\\n\\t\\t_baseURI = baseURI_;\\n\\t}\\n\\n\\tfunction withdraw() public onlyOwner {\\n\\t\\tSafeTransferLib.safeTransferAllETH(msg.sender);\\n\\t}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint96\",\"name\":\"initialTokenSupply\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"initialSupplyOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkMirrorContractFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MirrorAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotMirror\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SkipNFTSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"skipNFT\",\"type\":\"bool\"}],\"name\":\"setSkipNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SimpleDN404", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000669e4674317196c212300bf92ad03f1eee3137030000000000000000000000000000000000000000000000000000000000000007433453483430340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044334303400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}