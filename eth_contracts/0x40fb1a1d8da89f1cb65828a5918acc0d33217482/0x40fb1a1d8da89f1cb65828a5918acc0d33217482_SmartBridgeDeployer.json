{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n// optimize 200\r\n/// Standard IERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function owner() external view returns(address);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function symbol() external view returns(string memory);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/// Transfer Helper to ensure the correct transfer of the tokens or ETH\r\nlibrary SafeTransfer {\r\n    using Address for address;\r\n    function safeApprove(IERC20 token, address spender, uint256 value) \r\n    internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require(\r\n        (value == 0) || (token.allowance(address(this), spender) == 0),\r\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(token, \r\n    abi.encodeWithSelector(token.approve.selector, spender, value));\r\n}\r\n    /** Safe Transfer asset from one wallet with approval of the wallet\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param from: the wallet to take from\r\n    * @param amount: the amount to take from the wallet\r\n    **/\r\n    function _pullUnderlying(IERC20 erc20, address from, uint amount) internal\r\n    {\r\n        safeTransferFrom(erc20,from,address(this),amount);\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /** Safe Transfer asset to one wallet from within the contract\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param to: the wallet to send to\r\n    * @param amount: the amount to send from the contract\r\n    **/\r\n    function _pushUnderlying(IERC20 erc20, address to, uint amount) internal\r\n    {\r\n        safeTransfer(erc20,to,amount);\r\n    }\r\n\r\n    /** Safe Transfer ETH to one wallet from within the contract\r\n    * @param to: the wallet to send to\r\n    * @param value: the amount to send from the contract\r\n    **/\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface dr {\r\n    function superAdmin(address addy) external view returns(bool);\r\n    function isAdmin(address addy) external view returns(bool);\r\n    function bridgeDep() external view returns(address);\r\n    function isBridge(address addy) external view returns(bool);\r\n    function setBridgeSD(address who, address addy) external;\r\n    function wETH() external view returns(address);\r\n    function bridgeSD(address sd) external view returns(address);\r\n    function sdDepAddy() external view returns(address);\r\n    function creatorOfSD(address creator) external view returns(address);\r\n    function SDOfCreator(address sd) external view returns(address);\r\n\r\n}\r\n\r\ninterface warp {    \r\n    function sendPayloadToEvm(uint16 targetChain,address targetAddress,bytes memory payload,uint256 receiverValue,uint256 gasLimit,uint16 refundChain,address refundAddress) external payable returns (uint64 sequence);\r\n}\r\n\r\ninterface dep {\r\n    function relayDeposit(uint256 cost, uint16 toChain, bytes calldata payload, uint16 toChain0, address fund) external payable;\r\n    function relayWithdrawal(uint256 cost, uint16 toChain, bytes calldata payload, uint16 toChain0, address fund) external payable;\r\n    function registerWithdraw(address ad, uint256 amount, uint16 sourceChain, uint256 depositID) external;\r\n    function registerBridge(uint256 depositID) external;\r\n    function fund() external view returns(address);\r\n    function gas0() external view returns(uint256);\r\n    function gas1() external view returns(uint256);\r\n    function recoveryFee() external view returns(uint256);\r\n    function donation() external view returns(uint256);\r\n    function quoteEVMDeliveryPrice(uint16 targetChain, uint256 receiverValue, uint256 gasLimit) external view returns (uint256 nativePriceQuote, uint256);\r\n    function quoteDeposit(uint16 target, uint256 rv) external view returns (uint256 npq);\r\n    function quoteWithdraw(uint16 target, uint256 rv) external view returns (uint256 npq);\r\n    function deposit() external payable;\r\n    function deploy(address sd, address owner) external returns(address bridge);\r\n    function tokenOnChain(address sd, uint16 chain) external view returns(address);\r\n    function coolDown() external view returns(uint256);\r\n}\r\n\r\ncontract SmartBridgeDeployer {\r\n    mapping(address => bool) public isBridge;\r\n    address[] public allBridges;\r\n    address public dataread = 0xdAE383661587232FBd254b05a395CB8e35E6e7B6;\r\n    address public logic = 0x190BE53720e7313d5615d46326cCacE59F1Cc822;\r\n    address public fund = 0x46B6dF78388284088e07aA8F5dda4B5A3Ef3f861;\r\n    uint256 public donation = 300000000000000; //donation\r\n    uint256 public recoveryFee = 10; // 10 = 10%\r\n    uint256 public coolDown = 5 minutes; \r\n    bool public on = true;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {        \r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function setLogic(address addy) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        logic = addy;\r\n    }\r\n\r\n    function setOn(bool _bool) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        on = _bool;\r\n    }\r\n\r\n    function setDonation(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        donation = amt;\r\n    }\r\n    \r\n    function setCooldown(uint256 amt) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        coolDown = amt;\r\n    }\r\n\r\n    function setFund(address addy) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        fund = addy;\r\n    }\r\n\r\n    function setRecoveryFee(uint256 fee) external {\r\n        require(dr(dataread).superAdmin(msg.sender), \"not admin\");\r\n        require(fee <= 10, \"10%max\");\r\n        recoveryFee = fee;\r\n    }\r\n    \r\n    function deploy(address sd, bool originChain) external nonReentrant returns(address bridge){\r\n        require(on, \"deploy paused\");\r\n        require(msg.sender == IERC20(sd).owner(), \"not owner\");\r\n        bridge = dep(logic).deploy(sd,msg.sender);\r\n        require(!isBridge[bridge], \"already bridge\");\r\n        dr(dataread).setBridgeSD(sd,bridge);\r\n        if(!originChain) {\r\n        SafeTransfer.safeTransferFrom(IERC20(sd), msg.sender, bridge, IERC20(sd).totalSupply());        \r\n        }\r\n        isBridge[bridge] = true;\r\n        allBridges.push(bridge);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBridges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coolDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataread\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"originChain\",\"type\":\"bool\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBridge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"on\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setDonation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setRecoveryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SmartBridgeDeployer", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://445b2495c9134ebcf392a63a6e5da94cb34f9f9d9ae4ead4ddf61a76c11ddf6e"}