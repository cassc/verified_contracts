{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface WnsAddressesInterface {\r\n    function owner() external view returns (address);\r\n    function getWnsAddress(string memory _label) external view returns(address);\r\n}\r\n\r\nabstract contract WnsImpl {\r\n    WnsAddressesInterface wnsAddresses;\r\n\r\n    constructor(address addresses_) {\r\n        wnsAddresses = WnsAddressesInterface(addresses_);\r\n    }\r\n\r\n    function setAddresses(address addresses_) public {\r\n        require(msg.sender == owner(), \"Not authorized.\");\r\n        wnsAddresses = WnsAddressesInterface(addresses_);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return wnsAddresses.owner();\r\n    }\r\n\r\n    function getWnsAddress(string memory _label) public view returns (address) {\r\n        return wnsAddresses.getWnsAddress(_label);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeam() {\r\n        require(msg.sender == getWnsAddress(\"team\"), \"Ownable: caller is not team\");\r\n        _;\r\n    }\r\n}\r\n\r\ninterface WnsRegistryInterface {\r\n    function owner() external view returns (address);\r\n    function getWnsAddress(string memory _label) external view returns (address);\r\n    function setRecord(bytes32 _hash, uint256 _tokenId, string memory _name, uint8 _tier) external;\r\n    function setRecord(uint256 _tokenId, string memory _name) external;\r\n    function getRecord(bytes32 _hash) external view returns (uint256);\r\n    function upgradeTier(uint256 _tokenId, uint8 _tier) external;\r\n}\r\n\r\ninterface WnsErc721Interface {\r\n    function mintErc721(address to) external;\r\n    function getNextTokenId() external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ncontract Computation {\r\n    function computeNamehash(string memory _name) public pure returns (bytes32 namehash) {\r\n        namehash = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked('eth')))\r\n        );\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(_name)))\r\n        );\r\n    }\r\n\r\n    function hash(bytes memory value) internal pure returns (bytes32) {\r\n        return keccak256(value);\r\n    }\r\n}\r\n\r\nabstract contract Signatures is Computation {\r\n\r\n    struct Register {\r\n        string name;\r\n        string extension;\r\n        uint8 tier;\r\n        address registrant;\r\n        uint256 chainId; \r\n        uint256 cost;\r\n        uint256 expiration;\r\n        address[] splitAddresses;\r\n        uint256[] splitAmounts;\r\n    }\r\n\r\n    struct GatekeeperRegister {\r\n        bytes name;\r\n        address registrant;\r\n        uint40 chainId;\r\n        uint8 tier;\r\n        uint40 expiration;\r\n        uint64 cost;\r\n        string type_;\r\n        bytes sig;\r\n    }\r\n\r\n    struct TierUpgrade {\r\n        uint256 tokenId;\r\n        uint8 tier;\r\n        uint256 cost;\r\n        uint256 expiration;\r\n    }\r\n\r\n    function verifyGatekeeperSignature(GatekeeperRegister memory gatekeeperRegister) public pure returns(address) {\r\n        bytes memory message = abi.encode(gatekeeperRegister.name, gatekeeperRegister.registrant, gatekeeperRegister.chainId, gatekeeperRegister.tier, gatekeeperRegister.expiration, gatekeeperRegister.cost, gatekeeperRegister.type_);\r\n        bytes32 messageHash = hash(message);\r\n        \r\n        bytes memory messageBytes = abi.encode(messageHash);\r\n        bytes32 messageBytesHash = keccak256(abi.encodePacked(messageBytes));\r\n        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageBytesHash));\r\n\r\n        return recoverSigner(ethSignedMessageHash, gatekeeperRegister.sig);\r\n   }\r\n\r\n   function verifyWnsSignature(bytes memory registerBytes, bytes memory sig) public pure returns(address) {\r\n        bytes32 message = keccak256(registerBytes);\r\n        return recoverSigner(message, sig);\r\n   }\r\n\r\n   function verifyTierUpgradeSignature(TierUpgrade memory _tierUpgrade, bytes memory sig) internal pure returns(address) {\r\n        bytes32 message = keccak256(abi.encode(_tierUpgrade.tokenId, _tierUpgrade.tier, _tierUpgrade.cost, _tierUpgrade.expiration));\r\n        return recoverSigner(message, sig);\r\n   }\r\n\r\n   function recoverSigner(bytes32 message, bytes memory sig)\r\n       public\r\n       pure\r\n       returns (address)\r\n     {\r\n       uint8 v;\r\n       bytes32 r;\r\n       bytes32 s;\r\n       (v, r, s) = splitSignature(sig);\r\n       return ecrecover(message, v, r, s);\r\n   }\r\n\r\n   function splitSignature(bytes memory sig)\r\n       internal\r\n       pure\r\n       returns (uint8, bytes32, bytes32)\r\n     {\r\n       require(sig.length == 65);\r\n\r\n       bytes32 r;\r\n       bytes32 s;\r\n       uint8 v;\r\n\r\n       assembly {\r\n           r := mload(add(sig, 32))\r\n           s := mload(add(sig, 64))\r\n           v := byte(0, mload(add(sig, 96)))\r\n       }\r\n \r\n       return (v, r, s);\r\n   }\r\n}\r\n\r\ninterface IOracle {\r\n    function latestAnswer() external view returns (int256);\r\n}\r\n\r\ncontract WnsRegistrar is Signatures, WnsImpl {\r\n    address nativePriceOracle;\r\n\r\n    constructor(address addresses_, address nativePriceOracle_, uint256 chainId_) WnsImpl(addresses_) {\r\n        nativePriceOracle = nativePriceOracle_;\r\n        chainId = chainId_;\r\n    }\r\n\r\n    bool public isActive = true;\r\n    uint256 private minLength = 3;\r\n    uint256 private maxLength = 15;\r\n    uint256 public chainId;\r\n    uint64 signatureFeesUsd = 1;\r\n\r\n    event Commitment(string indexed nameHash, string name, address indexed registrant, uint40 indexed chainId, uint8 tier);\r\n\r\n    struct CommitParams {\r\n        string name;\r\n        uint8 tier;\r\n    }\r\n\r\n    function wnsCommit(bytes memory commitBytes) public payable {\r\n        (CommitParams[] memory commitParams) = abi.decode(commitBytes, (CommitParams[]));\r\n        require(commitParams.length <= 10, \"Too many commitments\");\r\n        require(msg.value >= getCommitmentFees(uint64(commitParams.length)), \"Value is not correct\");\r\n        \r\n        for(uint256 i = 0; i < commitParams.length; i++) {\r\n            emit Commitment(commitParams[i].name, commitParams[i].name, msg.sender, uint40(chainId), commitParams[i].tier);\r\n        }\r\n    }\r\n\r\n    function wnsRegister(bytes memory registerBytes) public payable {\r\n        (Register[] memory register, bytes[] memory sig) = abi.decode(registerBytes, (Register[], bytes[]));\r\n        bool[] memory success = _registerAll(register, sig);\r\n        settlePayment(register, success);\r\n    }\r\n\r\n    function wnsRegisterWithShare(bytes memory registerBytes, bytes memory wnsSig) public payable {\r\n        require(verifyWnsSignature(registerBytes, wnsSig) == getWnsAddress(\"_wnsSigner\"), \"Not authorised by WNS\");\r\n        (Register[] memory register, bytes[] memory sig) = abi.decode(registerBytes, (Register[], bytes[]));\r\n        bool[] memory success = _registerAll(register, sig);\r\n        settlePaymentWithShare(register, success);\r\n    }\r\n\r\n    function _registerAll(Register[] memory register, bytes[] memory sig) internal returns (bool[] memory) {\r\n        require(isActive, \"Registration must be active.\");\r\n        require(register.length == sig.length, \"Invalid parameters.\");\r\n        require(calculateCost(register) <= msg.value, \"Value is not correct.\");\r\n        \r\n        bool[] memory success = new bool[](register.length);\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            success[i] = _register(register[i], sig[i]);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function _register(Register memory register, bytes memory sig) internal returns (bool) {\r\n        WnsErc721Interface wnsErc721 = WnsErc721Interface(getWnsAddress(\"_wnsErc721\"));\r\n\r\n        GatekeeperRegister memory gatekeeperRegister = GatekeeperRegister(bytes(register.name), register.registrant, uint40(register.chainId), register.tier, uint40(register.expiration), uint64(register.cost), \"register\", sig);\r\n        require(verifyGatekeeperSignature(gatekeeperRegister) == getWnsAddress(\"_wnsGatekeeperSigner\"), \"Not authorized.\");\r\n        \r\n        require(register.expiration >= block.timestamp, \"Expired credentials.\");\r\n        require(register.chainId == chainId, \"Invalid chainId\");\r\n        \r\n        string memory sanitizedName = sanitizeName(register.name);\r\n        require(isLengthValid(sanitizedName), \"Invalid name\");\r\n        \r\n        bytes32 _hash = computeNamehash(sanitizedName);\r\n\r\n        WnsRegistryInterface wnsRegistry = WnsRegistryInterface(getWnsAddress(\"_wnsRegistry\"));\r\n        if(wnsRegistry.getRecord(_hash) == 0) {\r\n            wnsErc721.mintErc721(register.registrant);\r\n            wnsRegistry.setRecord(_hash, wnsErc721.getNextTokenId(), string(abi.encodePacked(sanitizedName, register.extension)), register.tier);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function calculateCost(Register[] memory register) internal pure returns (uint256) {\r\n        uint256 cost;\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            cost = cost + register[i].cost;\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    function settlePayment(Register[] memory register, bool[] memory success) internal {\r\n        require(register.length == success.length, \"Length doesn't match\");\r\n\r\n        uint256 failedCost = 0;\r\n        for(uint256 i = 0; i < register.length; i++) {\r\n            if(!success[i]) {\r\n                failedCost += register[i].cost;\r\n            }\r\n        }\r\n\r\n        if (failedCost > 0) {\r\n            payable(msg.sender).transfer(failedCost);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function settlePaymentWithShare(Register[] memory registers, bool[] memory success) internal {\r\n        require(registers.length == success.length, \"Mismatched array lengths\");\r\n\r\n        address[] memory shareAddresses = new address[](registers.length);\r\n        uint256[] memory shareAmounts = new uint256[](registers.length);\r\n        uint256 addressCount = 0;\r\n        uint256 failedCost = 0;\r\n\r\n        for (uint256 i = 0; i < registers.length; i++) {\r\n            if (success[i]) {\r\n                for (uint256 j = 0; j < registers[i].splitAddresses.length; j++) {\r\n                    address payee = registers[i].splitAddresses[j];\r\n                    uint256 amount = registers[i].splitAmounts[j];\r\n\r\n                    bool addressFound = false;\r\n                    for (uint256 k = 0; k < addressCount; k++) {\r\n                        if (shareAddresses[k] == payee) {\r\n                            shareAmounts[k] += amount;\r\n                            addressFound = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!addressFound) {\r\n                        shareAddresses[addressCount] = payee;\r\n                        shareAmounts[addressCount] = amount;\r\n                        addressCount++;\r\n                    }\r\n                }\r\n            } else {\r\n                failedCost += registers[i].cost;\r\n            }\r\n        }\r\n\r\n        for (uint256 i = 0; i < addressCount; i++) {\r\n            payable(shareAddresses[i]).transfer(shareAmounts[i]);\r\n        }\r\n\r\n        if (failedCost > 0) {\r\n            payable(msg.sender).transfer(failedCost);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function upgradeTier(TierUpgrade[] memory tierUpgrade, bytes[] memory sig) public payable {\r\n        require(isActive, \"Upgradation must be active.\");\r\n        require(tierUpgrade.length == sig.length, \"Invalid parameters\");\r\n        require(calculateCostTierUpgrade(tierUpgrade) <= msg.value, \"Value is not correct.\");\r\n\r\n        for(uint256 i=0; i < tierUpgrade.length; i++) {\r\n            TierUpgrade memory currentTierUpgrade = tierUpgrade[i];\r\n            bytes memory currentSig = sig[i];\r\n\r\n            require(verifyTierUpgradeSignature(currentTierUpgrade, currentSig) == getWnsAddress(\"_wnsSigner\"), \"Not authorised\");\r\n            require(currentTierUpgrade.expiration >= block.timestamp, \"Expired credentials.\");\r\n\r\n            WnsErc721Interface wnsErc721 = WnsErc721Interface(getWnsAddress(\"_wnsErc721\"));\r\n            require(currentTierUpgrade.tokenId < wnsErc721.getNextTokenId(), \"Token does not exist\");\r\n            require(wnsErc721.ownerOf(currentTierUpgrade.tokenId) == msg.sender, \"Token not owned by caller\");\r\n\r\n            WnsRegistryInterface wnsRegistry = WnsRegistryInterface(getWnsAddress(\"_wnsRegistry\"));\r\n            wnsRegistry.upgradeTier(currentTierUpgrade.tokenId, currentTierUpgrade.tier);\r\n        }\r\n\r\n        payable(getWnsAddress(\"_wnsWallet\")).transfer(address(this).balance);\r\n    }\r\n\r\n    function calculateCostTierUpgrade(TierUpgrade[] memory tierUpgrade) internal pure returns (uint256) {\r\n        uint256 cost;\r\n        for(uint256 i=0; i<tierUpgrade.length; i++) {\r\n            cost = cost + tierUpgrade[i].cost;\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    function sanitizeName(string memory name) public pure returns (string memory) {\r\n        bytes memory nameBytes = bytes(name);\r\n\r\n        uint dotPosition = nameBytes.length;\r\n        for (uint i = 0; i < nameBytes.length; i++) {\r\n            // Convert uppercase to lowercase\r\n            if (uint8(nameBytes[i]) >= 65 && uint8(nameBytes[i]) <= 90) {\r\n                nameBytes[i] = bytes1(uint8(nameBytes[i]) + 32);\r\n            }\r\n            // Check for the dot\r\n            if (nameBytes[i] == bytes1(\".\")) {\r\n                dotPosition = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory sanitizedBytes = new bytes(dotPosition);\r\n        for (uint i = 0; i < dotPosition; i++) {\r\n            sanitizedBytes[i] = nameBytes[i];\r\n        }\r\n\r\n        return string(sanitizedBytes);\r\n    }\r\n\r\n    function isLengthValid(string memory name) internal view returns (bool) {\r\n        bytes memory nameBytes = bytes(name);\r\n        uint length = nameBytes.length;\r\n\r\n        return (length >= minLength && length <= maxLength);\r\n    }\r\n\r\n    function getCommitmentFees(uint64 number) public view returns (uint64) {\r\n        //uint256 nativePrice = uint256(IOracle(nativePriceOracle).latestAnswer());\r\n        uint256 nativePrice = 337226359349;\r\n        uint256 fees = ((signatureFeesUsd * 1e18) / nativePrice) * 1e8; \r\n        return uint64(fees * number);\r\n    }\r\n\r\n    function changeOracle(address nativePriceOracle_) public onlyOwner {\r\n        nativePriceOracle = nativePriceOracle_;\r\n    }\r\n\r\n    function setFees(uint64 fees_) public onlyOwner {\r\n        signatureFeesUsd = fees_;\r\n    }\r\n\r\n    function changeLengths(uint256 min, uint256 max) public onlyOwner {\r\n        minLength = min;\r\n        maxLength = max;\r\n    }\r\n\r\n    function setChainId(uint256 id) public onlyOwner {\r\n        chainId = id;\r\n    }\r\n\r\n    function withdraw(address to, uint256 amount) public onlyOwner {\r\n        require(amount <= address(this).balance);\r\n        payable(to).transfer(amount);\r\n    }\r\n    \r\n    function flipActiveState() public onlyOwner {\r\n        isActive = !isActive;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addresses_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nativePriceOracle_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"nameHash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"chainId\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"Commitment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"changeLengths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nativePriceOracle_\",\"type\":\"address\"}],\"name\":\"changeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"computeNamehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"namehash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipActiveState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"number\",\"type\":\"uint64\"}],\"name\":\"getCommitmentFees\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_label\",\"type\":\"string\"}],\"name\":\"getWnsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"sanitizeName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addresses_\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"fees_\",\"type\":\"uint64\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct Signatures.TierUpgrade[]\",\"name\":\"tierUpgrade\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"upgradeTier\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"chainId\",\"type\":\"uint40\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"expiration\",\"type\":\"uint40\"},{\"internalType\":\"uint64\",\"name\":\"cost\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"type_\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct Signatures.GatekeeperRegister\",\"name\":\"gatekeeperRegister\",\"type\":\"tuple\"}],\"name\":\"verifyGatekeeperSignature\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"registerBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verifyWnsSignature\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"commitBytes\",\"type\":\"bytes\"}],\"name\":\"wnsCommit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"registerBytes\",\"type\":\"bytes\"}],\"name\":\"wnsRegister\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"registerBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"wnsSig\",\"type\":\"bytes\"}],\"name\":\"wnsRegisterWithShare\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WnsRegistrar", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001498fccd345c4ba7cddb1054857a6efbc99b858e0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3334f839c46206ad0f92f9a711e885b8aed8bb29ab157a07fa43c4da3a848d10"}