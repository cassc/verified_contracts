{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./IERC20PermitUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/CoreStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../interface/IStrategy.sol\\\";\\n\\n/**\\n * @title Aspida's CoreStrategy module\\n * @dev This contract is an abstract contract that defines the core strategy functions and variables.\\n * @author Aspida engineer\\n */\\nabstract contract CoreStrategy {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    uint256 internal constant MAX_RESERVE_RATIO = 1e18;\\n\\n    uint256 internal reserveRatio_;\\n    uint256 internal strategyReserve_;\\n    uint256 internal depositStrategy_;\\n    uint256 internal receiveStrategy_;\\n\\n    /// @dev EnumerableSet of strategists\\n    EnumerableSet.AddressSet internal strategists_;\\n\\n    /**\\n     * @dev Emitted when \\\"reserveRatio_\\\" has changed.\\n     */\\n    event SetReserveRatio(uint256 reserveRatio);\\n\\n    /**\\n     * @dev Emitted when \\\"strategyReserve_\\\" has been updated.\\n     */\\n    event UpdateStrategyReserve(uint256 strategyReserve);\\n\\n    /**\\n     * @dev Emitted when 'strategy' is added to 'strategists_'.\\n     */\\n    event StrategyAdded(address strategy);\\n\\n    /**\\n     * @dev Emitted when `strategy` is removed from `strategists_`.\\n     */\\n    event StrategyRemoved(address strategy);\\n\\n    /**\\n     * @dev Emitted when a deposit is made to a `strategy`.\\n     */\\n    event DepositToStrategy(address strategy, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when an amount is received from a `strategy`.\\n     */\\n    event ReceiveFromStrategy(address strategy, uint256 amount);\\n\\n    /**\\n     * @dev Throws an exception if strategic addresses are not enabled.\\n     */\\n    modifier isStrategy(address _strategy) {\\n        require(strategists_.contains(_strategy), \\\"isStrategy: invalid strategy address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Set the reserve ratio internally.\\n     * @dev This function sets the reserve ratio to the specified value.\\n     * @param _reserveRatio The new reserve ratio to be set.\\n     */\\n    function _setReserveRatioInternal(uint256 _reserveRatio) internal {\\n        require(_reserveRatio <= MAX_RESERVE_RATIO, \\\"_setReserveRatioInternal: ReserveRatio too large\\\");\\n        require(_reserveRatio != reserveRatio_, \\\"_setReserveRatioInternal: Cannot set the same value\\\");\\n        reserveRatio_ = _reserveRatio;\\n        emit SetReserveRatio(_reserveRatio);\\n    }\\n\\n    /**\\n     * @notice Add `strategy` into strategists_.\\n     * If `strategy` have not been a strategy, emits a `StrategyAdded` event.\\n     *\\n     * @param _strategy The strategy to add\\n     */\\n    function _addStrategyInternal(address _strategy) internal virtual {\\n        require(\\n            _strategy != address(0) && IStrategy(_strategy).core() == address(this),\\n            \\\"_addStrategyInternal: invalid strategy address\\\"\\n        );\\n        require(strategists_.add(_strategy), \\\"_addStrategyInternal: Strategy has been added\\\");\\n        emit StrategyAdded(_strategy);\\n    }\\n\\n    /**\\n     * @notice Remove `strategy` from strategists_.\\n     * If `strategy` is a strategy, emits a `StrategyRemoved` event.\\n     *\\n     * @param _strategy The strategy to remove\\n     */\\n    function _removeStrategyInternal(address _strategy) internal virtual {\\n        require(strategists_.remove(_strategy), \\\"_removeStrategyInternal: Strategy has been removed\\\");\\n        emit StrategyRemoved(_strategy);\\n    }\\n\\n    /**\\n     * @notice Update the strategy reserve with the specified value.\\n     * @dev This function updates the strategy reserve to the given value.\\n     * @param _strategyReserve The new value for the strategy reserve.\\n     */\\n    function _updateStrategyReserve(uint256 _strategyReserve) internal {\\n        strategyReserve_ = _strategyReserve;\\n        emit UpdateStrategyReserve(_strategyReserve);\\n    }\\n\\n    /**\\n     * @notice Increase the strategy reserve by the specified amount.\\n     * @dev This function increases the strategy reserve by the given amount.\\n     * @param _increaseReserve The amount to increase the strategy reserve by.\\n     */\\n    function _increaseStrategyReserve(uint256 _increaseReserve) internal {\\n        _updateStrategyReserve(strategyReserve_ + _increaseReserve);\\n    }\\n\\n    /**\\n     * @notice Decrease the strategy reserve by the specified amount.\\n     * @dev This function decreases the strategy reserve by the given amount.\\n     * @param _decreaseReserve The amount to decrease the strategy reserve by.\\n     */\\n    function _decreaseStrategyReserve(uint256 _decreaseReserve) internal {\\n        _updateStrategyReserve(strategyReserve_ - _decreaseReserve);\\n    }\\n\\n    /**\\n     * @notice Increase the reserves by a ratio of the specified amount.\\n     * @dev This function increases the reserves by a ratio of the given amount.\\n     * @param _amount The amount to increase the reserves by.\\n     */\\n    function _increaseReservesByRatio(uint256 _amount) internal {\\n        _increaseStrategyReserve((_amount * reserveRatio_) / MAX_RESERVE_RATIO);\\n    }\\n\\n    /**\\n     * @notice Deposit ETH into the specified strategy.\\n     * @dev This function deposits the specified amount of ETH into the strategy.\\n     * @param _strategy The address of the strategy to deposit into.\\n     * @param _ethAmount The amount of ETH to deposit.\\n     */\\n    function _depositIntoStrategyInternal(\\n        address _strategy,\\n        uint256 _ethAmount\\n    ) internal virtual isStrategy(_strategy) {\\n        _decreaseStrategyReserve(_ethAmount);\\n        depositStrategy_ += _ethAmount;\\n        IStrategy(_strategy).strategyReceive{ value: _ethAmount }();\\n        emit DepositToStrategy(_strategy, _ethAmount);\\n    }\\n\\n    /**\\n     * @notice Receive strategy earnings from the specified strategy.\\n     * @dev This function receives the earnings from the specified strategy.\\n     * @param _strategy The address of the strategy to receive earnings from.\\n     */\\n    function _receiveStrategyEarning(address _strategy) internal virtual isStrategy(_strategy) {\\n        uint256 _ethValue = msg.value;\\n        _increaseStrategyReserve(_ethValue);\\n        receiveStrategy_ += _ethValue;\\n        emit ReceiveFromStrategy(_strategy, _ethValue);\\n    }\\n\\n    /**\\n     * @notice Get the reserve ratio.\\n     * @return The reserve ratio.\\n     */\\n    function reserveRatio() external view returns (uint256) {\\n        return reserveRatio_;\\n    }\\n\\n    /**\\n     * @notice Get the strategy reserve.\\n     * @return The strategy reserve.\\n     */\\n    function strategyReserve() external view returns (uint256) {\\n        return strategyReserve_;\\n    }\\n\\n    /**\\n     * @notice Get the deposit strategy.\\n     * @return The deposit strategy.\\n     */\\n    function depositStrategy() external view returns (uint256) {\\n        return depositStrategy_;\\n    }\\n\\n    /**\\n     * @notice Get the receive strategy.\\n     * @return The receive strategy.\\n     */\\n    function receiveStrategy() external view returns (uint256) {\\n        return receiveStrategy_;\\n    }\\n\\n    /**\\n     * @notice Get all strategists.\\n     * @return _strategists The list of strategy addresses.\\n     */\\n    function strategists() external view returns (address[] memory _strategists) {\\n        _strategists = strategists_.values();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/CoreTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Aspida's CoreTreasury module\\n * @dev This contract is an abstract contract that defines the core treasury functionality of Aspida.\\n * @dev It contains internal functions to set the treasury and treasury ratio, and a function to calculate the treasury amount.\\n * @dev It also contains external functions to get the treasury address and treasury ratio.\\n * @dev The maximum treasury ratio is set to 1e18.\\n * @author Aspida engineer\\n */\\nabstract contract CoreTreasury {\\n    uint256 internal constant MAX_TREASURY_RATIO = 1e18;\\n\\n    // The address of the treasury\\n    address internal treasury_;\\n\\n    // The treasury ratio\\n    uint256 internal treasuryRatio_;\\n\\n    /**\\n     * @dev Emitted when the treasury address is set\\n     */\\n    event SetTreasury(address treasury);\\n\\n    /**\\n     * @dev Emitted when the treasury ratio is set\\n     */\\n    event SetTreasuryRatio(uint256 treasuryRatio);\\n\\n    /**\\n     * @dev Sets the treasury address.\\n     * @param _treasury The address of the treasury.\\n     */\\n    function _setTreasuryInternal(address _treasury) internal {\\n        require(_treasury != address(0) && _treasury != treasury_, \\\"_setTreasuryInternal: Invalid treasury\\\");\\n        treasury_ = _treasury;\\n        emit SetTreasury(_treasury);\\n    }\\n\\n    /**\\n     * @dev Sets the treasury ratio.\\n     * @param _treasuryRatio The treasury ratio.\\n     */\\n    function _setTreasuryRatioInternal(uint256 _treasuryRatio) internal {\\n        require(_treasuryRatio <= MAX_TREASURY_RATIO, \\\"_setTreasuryRatioInternal: TreasuryRatio too large\\\");\\n        require(_treasuryRatio != treasuryRatio_, \\\"_setTreasuryRatioInternal: Cannot set the same value\\\");\\n        treasuryRatio_ = _treasuryRatio;\\n        emit SetTreasuryRatio(_treasuryRatio);\\n    }\\n\\n    /**\\n     * @dev Calculates the treasury amount.\\n     * @param _amount The amount to calculate the treasury amount for.\\n     * @return The treasury amount.\\n     */\\n    function _getTreasuryAmount(uint256 _amount) internal view returns (uint256) {\\n        return (_amount * treasuryRatio_) / MAX_TREASURY_RATIO;\\n    }\\n\\n    /**\\n     * @dev Gets the treasury address.\\n     * @return The address of the treasury.\\n     */\\n    function treasury() external view returns (address) {\\n        return treasury_;\\n    }\\n\\n    /**\\n     * @dev Gets the treasury ratio.\\n     * @return The treasury ratio.\\n     */\\n    function treasuryRatio() external view returns (uint256) {\\n        return treasuryRatio_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/StakingModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/IDepositContract.sol\\\";\\n\\n/**\\n * @title Aspida's StakingModel\\n * @dev This contract manages the deposit of validators to the Ethereum 2.0 deposit contract.\\n * @author Aspida engineer\\n */\\nabstract contract StakingModel {\\n    uint256 internal constant DEPOSIT_SIZE = 32 ether;\\n    uint256 internal constant SIGNATURE_INDEX = 64;\\n    uint64 internal constant DEPOSIT_SIZE_IN_GWEI_LE64 = 0x0040597307000000;\\n\\n    IDepositContract internal immutable DEPOSIT_CONTRACT; // Deposit contract is immutable\\n\\n    bytes internal withdrawalCredentials_; // Withdrawal credentials are stored as bytes\\n\\n    mapping(bytes => bool) internal pubKeyExpired_; // Mapping to check if a public key has expired\\n\\n    /**\\n     * @dev Emitted when the withdrawal credentials are set.\\n     */\\n    event SetWithdrawalCredentials(bytes withdrawalCredential);\\n\\n    /**\\n     * @dev Emitted when a validator is deposited.\\n     */\\n    event ValidatorDeposited(\\n        address operator,\\n        bytes pubKey,\\n        bytes signature,\\n        bytes withdrawalCredential,\\n        bytes32 depositDataRoot\\n    );\\n\\n    /**\\n     * @dev Event emitted when a deposit is made.\\n     */\\n    event Deposit(uint256 depositValue, uint256 validatorCount);\\n\\n    constructor(IDepositContract _depositContract) {\\n        DEPOSIT_CONTRACT = _depositContract;\\n    }\\n\\n    /**\\n     * @dev Sets the withdrawal credentials.\\n     * @param _withdrawalCredentials The withdrawal credentials.\\n     */\\n    function _setWithdrawalCredentialsInternal(bytes memory _withdrawalCredentials) internal {\\n        require(\\n            _withdrawalCredentials.length == 32,\\n            \\\"_setWithdrawalCredentialsInternal: Invalid withdrawalCredentials length\\\"\\n        );\\n\\n        withdrawalCredentials_ = _withdrawalCredentials;\\n        emit SetWithdrawalCredentials(_withdrawalCredentials);\\n    }\\n\\n    struct Validator {\\n        address operator;\\n        bytes pubKey;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @dev Deposits validators.\\n     * @param _validators The validators to deposit.\\n     */\\n    function _deposit(Validator[] calldata _validators) internal {\\n        require(_validators.length > 0, \\\"_deposit: Deposit 0 is invalid\\\");\\n        bytes memory _withdrawalCredentials = withdrawalCredentials_;\\n        for (uint256 i = 0; i < _validators.length; i++) {\\n            require(!pubKeyExpired_[_validators[i].pubKey], \\\"_deposit: Invalid validator public key\\\");\\n\\n            bytes32 _depositDataRoot = _calculateDepositDataRoot(\\n                _validators[i].pubKey,\\n                _validators[i].signature,\\n                _withdrawalCredentials\\n            );\\n            DEPOSIT_CONTRACT.deposit{ value: DEPOSIT_SIZE }(\\n                _validators[i].pubKey,\\n                _withdrawalCredentials,\\n                _validators[i].signature,\\n                _depositDataRoot\\n            );\\n\\n            pubKeyExpired_[_validators[i].pubKey] = true;\\n            emit ValidatorDeposited(\\n                _validators[i].operator,\\n                _validators[i].pubKey,\\n                _validators[i].signature,\\n                _withdrawalCredentials,\\n                _depositDataRoot\\n            );\\n        }\\n        emit Deposit(_validators.length * DEPOSIT_SIZE, _validators.length);\\n    }\\n\\n    /**\\n     * @dev Checks the deposit root and deposits validators.\\n     * @param _validators The validators to deposit.\\n     * @param _depositRoot The expected deposit root.\\n     */\\n    function _depositCheck(Validator[] calldata _validators, bytes32 _depositRoot) internal {\\n        // Require that the deposit root has not changed\\n        require(\\n            _depositRoot == IDepositContract(DEPOSIT_CONTRACT).get_deposit_root(),\\n            \\\"_depositCheck: Deposit root has changed\\\"\\n        );\\n        _deposit(_validators);\\n    }\\n\\n    /**\\n     * @dev Slices a portion of a bytes array.\\n     * @param _src The source bytes array.\\n     * @param _srcStart The starting index of the slice.\\n     * @param _length The length of the slice.\\n     * @return _dst The sliced bytes array.\\n     */\\n    function _bytesSlice(\\n        bytes memory _src,\\n        uint256 _srcStart,\\n        uint256 _length\\n    ) internal pure returns (bytes memory _dst) {\\n        require(_srcStart + _length <= _src.length, \\\"_bytesSlice: Slice param error\\\");\\n        _dst = new bytes(_length);\\n        for (uint256 i = 0; i < _length; i++) {\\n            _dst[i] = _src[i + _srcStart];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the deposit data root.\\n     * @param _pubKey The public key.\\n     * @param _signature The signature.\\n     * @param _withdrawalCredentials The withdrawal credentials.\\n     * @return _depositDataRoot The deposit data root.\\n     */\\n    function _calculateDepositDataRoot(\\n        bytes memory _pubKey,\\n        bytes memory _signature,\\n        bytes memory _withdrawalCredentials\\n    ) internal pure returns (bytes32 _depositDataRoot) {\\n        bytes32 _pubkeyRoot = sha256(abi.encodePacked(_pubKey, bytes16(0)));\\n        bytes32 _signatureRoot = sha256(\\n            abi.encodePacked(\\n                sha256(abi.encodePacked(_bytesSlice(_signature, 0, SIGNATURE_INDEX))),\\n                sha256(abi.encodePacked(_bytesSlice(_signature, SIGNATURE_INDEX, 32), bytes32(0)))\\n            )\\n        );\\n\\n        _depositDataRoot = sha256(\\n            abi.encodePacked(\\n                sha256(abi.encodePacked(_pubkeyRoot, _withdrawalCredentials)),\\n                sha256(abi.encodePacked(DEPOSIT_SIZE_IN_GWEI_LE64, bytes24(0), _signatureRoot))\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Converts an address to withdrawal credentials.\\n     * @param _withdrawalAddress The withdrawal address.\\n     * @return The withdrawal credentials.\\n     */\\n    function _addressToWithdrawalCredentials(address _withdrawalAddress) internal pure returns (bytes memory) {\\n        return abi.encodePacked(uint256(uint160(_withdrawalAddress)) | (1 << 248));\\n    }\\n\\n    /**\\n     * @dev Returns the deposit contract.\\n     * @return The deposit contract.\\n     */\\n    function depositContract() external view returns (IDepositContract) {\\n        return DEPOSIT_CONTRACT;\\n    }\\n\\n    /**\\n     * @dev Returns the withdrawal credentials.\\n     * @return The withdrawal credentials.\\n     */\\n    function withdrawalCredentials() external view returns (bytes memory) {\\n        return withdrawalCredentials_;\\n    }\\n\\n    /**\\n     * @dev Checks if a public key has expired.\\n     * @param _pubKey The public key.\\n     * @return True if the public key has expired, false otherwise.\\n     */\\n    function pubKeyExpired(bytes memory _pubKey) external view returns (bool) {\\n        return pubKeyExpired_[_pubKey];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Submit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/IaETH.sol\\\";\\nimport \\\"../interface/IsaETH.sol\\\";\\n\\n/**\\n * @title Aspida's Submit model\\n * @dev This contract allows users to submit ETH and mint aETH tokens in return.\\n * Users can also submit ETH and stake it to receive saETH tokens.\\n * @author Aspida engineer\\n */\\nabstract contract Submit {\\n    IaETH internal immutable AETH; // aETH token contract\\n    IsaETH internal immutable SAETH; // saETH token contract\\n\\n    uint256 internal submitted_; // total amount of ETH submitted\\n\\n    /**\\n     * @dev Emitted when the withdrawal credentials are set.\\n     */\\n    event Submitted(address sender, address recipient, uint256 ethValue);\\n\\n    constructor(IaETH _aETH, IsaETH _saETH) {\\n        AETH = _aETH;\\n        SAETH = _saETH;\\n    }\\n\\n    /**\\n     * @dev Internal function to submit ETH and mint aETH tokens\\n     * @param _receiver The address of the receiver of the aETH tokens\\n     */\\n    function _submit(address _receiver) internal virtual {\\n        uint256 _ethValue = msg.value;\\n        require(_ethValue != 0, \\\"_submit: ETH cannot be 0\\\");\\n\\n        submitted_ += _ethValue;\\n\\n        AETH.mint(_receiver, _ethValue);\\n        emit Submitted(msg.sender, _receiver, _ethValue);\\n    }\\n\\n    /**\\n     * @dev External function to submit ETH and mint aETH tokens\\n     */\\n    function submit() external payable {\\n        _submit(msg.sender);\\n    }\\n\\n    /**\\n     * @dev External function to submit ETH and mint aETH tokens for a specific receiver\\n     * @param _receiver The address of the receiver of the aETH tokens\\n     */\\n    function submit(address _receiver) external payable {\\n        _submit(_receiver);\\n    }\\n\\n    /**\\n     * @dev External function to submit ETH, mint aETH tokens and stake them to receive saETH tokens\\n     * @param _receiver The address of the receiver of the saETH tokens\\n     */\\n    function submitAndStake(address _receiver) external payable {\\n        _submit(address(this));\\n\\n        AETH.approve(address(SAETH), msg.value);\\n        require(SAETH.deposit(msg.value, _receiver) > 0, \\\"No saETH was returned\\\");\\n    }\\n\\n    /**\\n     * @dev External function to return the aETH token contract\\n     * @return The aETH token contract\\n     */\\n    function aETH() external view returns (IaETH) {\\n        return AETH;\\n    }\\n\\n    /**\\n     * @dev External function to return the saETH token contract\\n     * @return The saETH token contract\\n     */\\n    function saETH() external view returns (IsaETH) {\\n        return SAETH;\\n    }\\n\\n    /**\\n     * @dev External function to return the total amount of ETH submitted\\n     * @return The total amount of ETH submitted\\n     */\\n    function submitted() external view returns (uint256) {\\n        return submitted_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/WithdrawalQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../library/TransferHelper.sol\\\";\\n\\n/**\\n * @title Aspida's WithdrawalQueue model\\n * @dev This contract implements a withdrawal queue for users to withdraw their funds in a fair manner.\\n * Users can withdraw their funds immediately if there are enough funds available, otherwise they will be added to the queue.\\n * The queue is processed in a first-in-first-out (FIFO) manner.\\n * Users can claim their funds from the queue at any time.\\n * @author Aspida engineer\\n */\\nabstract contract WithdrawalQueue {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using TransferHelper for address;\\n\\n    uint256 internal totalWithdrawn_; // Total amount of funds withdrawn\\n    uint256 internal totalClaimed_; // Total amount of funds claimed\\n    uint256 internal pendingClaimAmount_; // Total amount of funds in the queue\\n\\n    uint256 internal lastQueueId_; // The last queue ID\\n    mapping(address => EnumerableSet.UintSet) internal userQueueIds_; // Mapping of user addresses to their queue IDs\\n\\n    mapping(uint256 => uint256) internal claimAccumulated_; // Mapping of queue IDs to their accumulated claim amounts\\n\\n    /**\\n     * @dev Emitted when the total amount of funds in the queue is updated.\\n     */\\n    event UpdatePendingClaim(uint256 pendingClaimAmount);\\n\\n    /**\\n     * @dev Emitted when the total amount of funds claimed is updated.\\n     */\\n    event UpdateTotalClaimed(uint256 totalClaimed);\\n\\n    /**\\n     * @dev Emitted when a user is added to the withdrawal queue.\\n     */\\n    event EnterWithdrawalQueue(\\n        address sender,\\n        address recipient,\\n        uint256 queueId,\\n        uint256 claimAmount,\\n        uint256 accumulated\\n    );\\n\\n    /**\\n     * @dev Emitted when a user is removed from the withdrawal queue.\\n     */\\n    event ExitWithdrawalQueue(address sender, address recipient, uint256 queueId, uint256 claimAmount);\\n\\n    /**\\n     * @dev Emitted when funds are withdrawn from the contract.\\n     */\\n    event Withdrawn(address sender, address recipient, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when funds are claimed from the queue.\\n     */\\n    event Claimed(address sender, address recipient, uint256 amount);\\n\\n    /**\\n     * @dev Updates the total amount of funds in the queue.\\n     * @param _pendingClaimAmount The new total amount of funds in the queue.\\n     */\\n    function _updatePendingClaim(uint256 _pendingClaimAmount) internal {\\n        pendingClaimAmount_ = _pendingClaimAmount;\\n        emit UpdatePendingClaim(_pendingClaimAmount);\\n    }\\n\\n    /**\\n     * @dev Updates the total amount of funds claimed.\\n     * @param _totalClaimed The new total amount of funds claimed.\\n     */\\n    function _updateTotalClaimed(uint256 _totalClaimed) internal {\\n        totalClaimed_ = _totalClaimed;\\n        emit UpdateTotalClaimed(_totalClaimed);\\n    }\\n\\n    /**\\n     * @dev Adds the user to the withdrawal queue.\\n     * @param _receiver The address of the user to add to the queue.\\n     * @param _amount The amount of funds to add to the queue.\\n     */\\n    function _withdrawalQueue(address _receiver, uint256 _amount) internal {\\n        uint256 _queueId = lastQueueId_;\\n        uint256 _accumulated = claimAccumulated_[_queueId];\\n\\n        _queueId += 1;\\n        userQueueIds_[_receiver].add(_queueId);\\n\\n        uint256 _claimAccumulated = _accumulated + _amount;\\n        claimAccumulated_[_queueId] = _claimAccumulated;\\n\\n        lastQueueId_ = _queueId;\\n        _updatePendingClaim(pendingClaimAmount_ + _amount);\\n        emit EnterWithdrawalQueue(msg.sender, _receiver, _queueId, _amount, _claimAccumulated);\\n    }\\n\\n    /**\\n     * @dev Withdraws funds from the contract.\\n     * @param _sender The address of the user withdrawing the funds.\\n     * @param _receiver The address of the user receiving the funds.\\n     * @param _amount The amount of funds to withdraw.\\n     */\\n    function _withdraw(address _sender, address _receiver, uint256 _amount) internal virtual {\\n        require(_amount > 0, \\\"_withdraw: withdraw amount cannot be 0\\\");\\n        if (_withdrawableAmount() < _amount) {\\n            _withdrawalQueue(_receiver, _amount);\\n            return;\\n        }\\n\\n        totalWithdrawn_ += _amount;\\n        _receiver.safeTransferETH(_amount);\\n        emit Withdrawn(_sender, _receiver, _amount);\\n    }\\n\\n    /**\\n     * @dev Claims funds from the queue for a specific user.\\n     * @param _sender The address of the user claiming the funds.\\n     * @param _receiver The address of the user receiving the funds.\\n     */\\n    function _claimByAddress(address _sender, address _receiver) internal virtual {\\n        EnumerableSet.UintSet storage _userQueueIds = userQueueIds_[_sender];\\n        _claimByQueueId(_sender, _receiver, _userQueueIds.values(), _userQueueIds);\\n    }\\n\\n    /**\\n     * @dev Claims funds from the queue for a specific user and queue IDs.\\n     * @param _sender The address of the user claiming the funds.\\n     * @param _receiver The address of the user receiving the funds.\\n     * @param _queueIds The list of queue IDs to claim from.\\n     * @param _userQueueIds The user's queue IDs.\\n     */\\n    function _claimByQueueId(\\n        address _sender,\\n        address _receiver,\\n        uint256[] memory _queueIds,\\n        EnumerableSet.UintSet storage _userQueueIds\\n    ) internal virtual {\\n        require(_queueIds.length > 0, \\\"_claimByQueueId: Queue list cannot be empty\\\");\\n\\n        uint256 _availableBalance = _claimableAmount();\\n        uint256 _claimAmount;\\n        for (uint256 i = 0; i < _queueIds.length; i++) {\\n            uint256 _amount = _getClaimAmount(_queueIds[i], _availableBalance);\\n            if (_amount == 0) continue;\\n\\n            require(_userQueueIds.remove(_queueIds[i]), \\\"_claimByQueueId: Queue id does not exist\\\");\\n            emit ExitWithdrawalQueue(_sender, _receiver, _queueIds[i], _amount);\\n\\n            _claimAmount += _amount;\\n        }\\n\\n        require(_claimAmount > 0, \\\"_claimByQueueId: No claim amount\\\");\\n\\n        _updatePendingClaim(pendingClaimAmount_ - _claimAmount);\\n        _updateTotalClaimed(totalClaimed_ + _claimAmount);\\n\\n        _receiver.safeTransferETH(_claimAmount);\\n        emit Claimed(_sender, _receiver, _claimAmount);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of funds that can be withdrawn.\\n     * @return _availableAmount The available amount of funds that can be withdrawn.\\n     */\\n    function _withdrawableAmount() internal view virtual returns (uint256 _availableAmount) {\\n        uint256 _balance = address(this).balance;\\n        uint256 _locked = pendingClaimAmount_;\\n        if (_balance > _locked) _availableAmount = _balance - _locked;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of funds that can be claimed.\\n     * @return _claimableAmount The claimable amount of funds.\\n     */\\n    function _claimableAmount() internal view virtual returns (uint256) {\\n        return address(this).balance + totalClaimed_;\\n    }\\n\\n    /**\\n     * @dev Returns the claim amount and accumulated claim amount for a specific queue ID.\\n     * @param _queueId The queue ID.\\n     * @return _claimAmount The claim amount for the queue ID.\\n     * @return _claimAccumulated The accumulated claim amount for the queue ID.\\n     */\\n    function _claimDataByQueueId(\\n        uint256 _queueId\\n    ) internal view returns (uint256 _claimAmount, uint256 _claimAccumulated) {\\n        _claimAccumulated = claimAccumulated_[_queueId];\\n        if (_claimAccumulated > 0) _claimAmount = _claimAccumulated - claimAccumulated_[_queueId - 1];\\n    }\\n\\n    /**\\n     * @dev Returns the claim amount for a specific queue ID.\\n     * @param _queueId The queue ID.\\n     * @param _claimable The claimable amount of funds.\\n     * @return _claimAmount The claim amount for the queue ID.\\n     */\\n    function _getClaimAmount(uint256 _queueId, uint256 _claimable) internal view returns (uint256 _claimAmount) {\\n        uint256 _accumulated;\\n        (_claimAmount, _accumulated) = _claimDataByQueueId(_queueId);\\n        if (_claimable < _accumulated) _claimAmount = 0;\\n    }\\n\\n    /**\\n     * @dev Allows a user to withdraw funds.\\n     * @param _amount The amount of funds to withdraw.\\n     */\\n    function withdraw(uint256 _amount) external {\\n        _withdraw(msg.sender, msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Allows a user to withdraw funds and specify a receiver address.\\n     * @param _amount The amount of funds to withdraw.\\n     * @param _receiver The address of the receiver.\\n     */\\n    function withdraw(uint256 _amount, address _receiver) external {\\n        _withdraw(msg.sender, _receiver, _amount);\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their funds from the queue.\\n     */\\n    function claim() external {\\n        _claimByAddress(msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their funds from the queue and specify a receiver address.\\n     * @param _receiver The address of the receiver.\\n     */\\n    function claim(address _receiver) external {\\n        _claimByAddress(msg.sender, _receiver);\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their funds from the queue using specific queue IDs.\\n     * @param _queueIds The list of queue IDs to claim from.\\n     */\\n    function claim(uint256[] memory _queueIds) external {\\n        _claimByQueueId(msg.sender, msg.sender, _queueIds, userQueueIds_[msg.sender]);\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their funds from the queue using specific queue IDs and specify a receiver address.\\n     * @param _receiver The address of the receiver.\\n     * @param _queueIds The list of queue IDs to claim from.\\n     */\\n    function claim(address _receiver, uint256[] memory _queueIds) external {\\n        _claimByQueueId(msg.sender, _receiver, _queueIds, userQueueIds_[msg.sender]);\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of funds withdrawn.\\n     * @return The total amount of funds withdrawn.\\n     */\\n    function totalWithdrawn() external view returns (uint256) {\\n        return totalWithdrawn_;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of funds claimed.\\n     * @return The total amount of funds claimed.\\n     */\\n    function totalClaimed() external view returns (uint256) {\\n        return totalClaimed_;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of funds in the queue.\\n     * @return The total amount of funds in the queue.\\n     */\\n    function pendingClaimAmount() external view returns (uint256) {\\n        return pendingClaimAmount_;\\n    }\\n\\n    /**\\n     * @dev Returns the last queue ID.\\n     * @return The last queue ID.\\n     */\\n    function lastQueueId() external view returns (uint256) {\\n        return lastQueueId_;\\n    }\\n\\n    /**\\n     * @dev Returns the accumulated amount of funds in the queue.\\n     * @return The accumulated amount of funds in the queue.\\n     */\\n    function accumulated() external view returns (uint256) {\\n        return claimAccumulated_[lastQueueId_];\\n    }\\n\\n    /**\\n     * @dev Returns the amount of funds that can be withdrawn.\\n     * @return The amount of funds that can be withdrawn.\\n     */\\n    function withdrawableAmount() external view returns (uint256) {\\n        return _withdrawableAmount();\\n    }\\n\\n    /**\\n     * @dev Returns the amount of funds that can be claimed.\\n     * @return The amount of funds that can be claimed.\\n     */\\n    function claimableAmount() external view returns (uint256) {\\n        return _claimableAmount();\\n    }\\n\\n    /**\\n     * @dev Returns the claim amount and accumulated claim amount for a specific queue ID.\\n     * @param _queueId The queue ID to get claim data for.\\n     * @return _claimAmount The claim amount for the queue ID.\\n     * @return _claimAccumulated The accumulated claim amount for the queue ID.\\n     */\\n    function claimDataByQueueId(\\n        uint256 _queueId\\n    ) external view returns (uint256 _claimAmount, uint256 _claimAccumulated) {\\n        (_claimAmount, _claimAccumulated) = _claimDataByQueueId(_queueId);\\n    }\\n\\n    /**\\n     * @dev Returns the claim data for a specific address.\\n     * @param _account The address to get claim data for.\\n     * @return _ids The IDs of the claims.\\n     * @return _claimAmounts The amounts of the claims.\\n     * @return _claimStatuses The statuses of the claims.\\n     */\\n    function claimDataByAddress(\\n        address _account\\n    ) external view returns (uint256[] memory _ids, uint256[] memory _claimAmounts, bool[] memory _claimStatuses) {\\n        _ids = userQueueIds_[_account].values();\\n        _claimAmounts = new uint256[](_ids.length);\\n        _claimStatuses = new bool[](_ids.length);\\n\\n        uint256 _claimable = _claimableAmount();\\n        uint256 _accumulated;\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            (_claimAmounts[i], _accumulated) = _claimDataByQueueId(_ids[i]);\\n            _claimStatuses[i] = _claimable >= _accumulated;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the user's queue IDs, claim amounts, and accumulated claim amounts.\\n     * @param _account The address of the user.\\n     * @return _ids The IDs of the user's claims.\\n     * @return _claimAmounts The amounts of the user's claims.\\n     * @return _accumulations The accumulated amounts of the user's claims.\\n     */\\n    function userQueueIds(\\n        address _account\\n    ) external view returns (uint256[] memory _ids, uint256[] memory _claimAmounts, uint256[] memory _accumulations) {\\n        _ids = userQueueIds_[_account].values();\\n        _claimAmounts = new uint256[](_ids.length);\\n        _accumulations = new uint256[](_ids.length);\\n\\n        for (uint256 i = 0; i < _accumulations.length; i++) {\\n            (_claimAmounts[i], _accumulations[i]) = _claimDataByQueueId(_ids[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CorePrimary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./library/PauseGuardian.sol\\\";\\nimport \\\"./library/Manable.sol\\\";\\nimport \\\"./core/CoreTreasury.sol\\\";\\nimport \\\"./core/CoreStrategy.sol\\\";\\nimport \\\"./core/StakingModel.sol\\\";\\nimport \\\"./core/Submit.sol\\\";\\nimport \\\"./core/WithdrawalQueue.sol\\\";\\n\\nimport \\\"./interface/IRewardOracle.sol\\\";\\n\\n/**\\n * @title Aspida's ETH 2.0 staking Core(primary)\\n * @author Aspida engineer\\n * @notice This contract is the primary contract for Aspida's ETH 2.0 staking Core.\\n *         It inherits from several other contracts and contains various functions for managing the Core.\\n * @dev This contract is implemented using the OpenZeppelin library.\\n *      It is used for staking ETH 2.0 and managing the Core's treasury, strategies, and actions.\\n *      It also contains functions for submitting and withdrawing ETH, as well as managing the withdrawal queue.\\n */\\ncontract CorePrimary is\\n    Ownable2StepUpgradeable,\\n    PauseGuardian,\\n    ReentrancyGuardUpgradeable,\\n    Manable,\\n    CoreTreasury,\\n    CoreStrategy,\\n    Submit,\\n    StakingModel,\\n    WithdrawalQueue\\n{\\n    address internal rewardOracle_;\\n\\n    uint256 internal received_;\\n\\n    event SetRewardOracle(address rewardOracle);\\n    event Received(uint256 _ethValue);\\n\\n    /**\\n     * @dev Throws if called by any account other than the rewardOracle.\\n     */\\n    modifier onlyRewardOracle() {\\n        require(rewardOracle_ == msg.sender, \\\"onlyRewardOracle: caller is not the rewardOracle\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to check if the contract has enough balance to deposit for the given validators.\\n     *      It throws if the contract's balance minus the strategy reserve and pending claim amount divided by the deposit size is less than the number of validators.\\n     * @param _validators The array of validators to check for.\\n     */\\n    modifier depositBalanceCheck(Validator[] calldata _validators) {\\n        require(\\n            (address(this).balance - strategyReserve_ - pendingClaimAmount_) / DEPOSIT_SIZE >= _validators.length,\\n            \\\"depositBalanceCheck: Not enough ETH\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only for the implementation contract, as for the proxy pattern,\\n     *            should call `initialize()` separately.\\n     */\\n    constructor(\\n        IDepositContract _depositContract,\\n        IaETH _aETH,\\n        IsaETH _saETH\\n    ) StakingModel(_depositContract) Submit(_aETH, _saETH) {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Expects to call only once to initialize CorePrimary.\\n     */\\n    function initialize() public initializer {\\n        __Ownable2Step_init();\\n        _setTreasuryInternal(owner());\\n        _setWithdrawalCredentialsInternal(_addressToWithdrawalCredentials(address(this)));\\n    }\\n\\n    /**\\n     * @notice Receives ETH sent to the contract.\\n     */\\n    receive() external payable {\\n        received_ += msg.value;\\n        emit Received(msg.value);\\n    }\\n\\n    /**\\n     * @dev Unpause when Core is paused.\\n     */\\n    function _open() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @dev Pause Core.\\n     */\\n    function _close() external onlyPauseGuardian {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Adds a new pause guardian to the Core.\\n     * @param _pauseGuardian The address of the new pause guardian.\\n     */\\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\\n        _addPauseGuardianInternal(_pauseGuardian);\\n    }\\n\\n    /**\\n     * @notice Removes a pause guardian from the Core.\\n     * @param _pauseGuardian The address of the pause guardian to remove.\\n     */\\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\\n        _removePauseGuardianInternal(_pauseGuardian);\\n    }\\n\\n    /**\\n     * @notice Adds a new manager to the Core.\\n     * @param _manager The address of the new manager.\\n     */\\n    function _addManager(address _manager) external onlyOwner {\\n        _addManagerInternal(_manager);\\n    }\\n\\n    /**\\n     * @notice Removes a manager from the Core.\\n     * @param _manager The address of the manager to remove.\\n     */\\n    function _removeManager(address _manager) external onlyOwner {\\n        _removeManagerInternal(_manager);\\n    }\\n\\n    /**\\n     * @notice Sets the treasury address.\\n     * @param _treasury The address of the new treasury.\\n     */\\n    function _setTreasury(address _treasury) external onlyOwner {\\n        _setTreasuryInternal(_treasury);\\n    }\\n\\n    /**\\n     * @notice Sets the treasury ratio.\\n     * @param _treasuryRatio The new treasury ratio.\\n     */\\n    function _setTreasuryRatio(uint256 _treasuryRatio) external onlyOwner {\\n        _setTreasuryRatioInternal(_treasuryRatio);\\n    }\\n\\n    /**\\n     * @notice Sets the reserve ratio.\\n     * @param _reserveRatio The new reserve ratio.\\n     */\\n    function _setReserveRatio(uint256 _reserveRatio) external onlyOwner {\\n        _setReserveRatioInternal(_reserveRatio);\\n    }\\n\\n    /**\\n     * @notice Adds a new strategy.\\n     * @param _strategy The address of the new strategy.\\n     */\\n    function _addStrategy(address _strategy) external onlyOwner {\\n        _addStrategyInternal(_strategy);\\n    }\\n\\n    /**\\n     * @notice Removes a strategy.\\n     * @param _strategy The address of the strategy to remove.\\n     */\\n    function _removeStrategy(address _strategy) external onlyOwner {\\n        _removeStrategyInternal(_strategy);\\n    }\\n\\n    /**\\n     * @notice Releases the strategy reserve.\\n     * @param _releaseAmount The amount to release.\\n     */\\n    function _releaseStrategyReserve(uint256 _releaseAmount) external onlyOwner {\\n        _decreaseStrategyReserve(_releaseAmount);\\n    }\\n\\n    /**\\n     * @notice Sets the reward oracle address.\\n     * @param _rewardOracle The address of the new reward oracle.\\n     */\\n    function _setRewardOracle(address _rewardOracle) external onlyOwner {\\n        require(\\n            _rewardOracle != rewardOracle_ && IRewardOracle(_rewardOracle).core() == address(this),\\n            \\\"_setRewardOracle: Invalid reward oracle address\\\"\\n        );\\n        rewardOracle_ = _rewardOracle;\\n        emit SetRewardOracle(_rewardOracle);\\n    }\\n\\n    /**\\n     * @notice Disables the reward oracle.\\n     */\\n    function _disableRewardOracle() external onlyOwner {\\n        rewardOracle_ = address(0);\\n        emit SetRewardOracle(address(0));\\n    }\\n\\n    /**\\n     * @notice Deposits ETH into a strategy.\\n     * @param _strategy The address of the strategy.\\n     * @param _ethAmount The amount of ETH to deposit.\\n     */\\n    function _depositIntoStrategy(address _strategy, uint256 _ethAmount) external onlyOwner {\\n        _depositIntoStrategyInternal(_strategy, _ethAmount);\\n    }\\n\\n    /**\\n     * @notice Recap the loss(Slashing and strategy losses).\\n     * @param _loss The amount of loss\\n     *\\n     * Requirements:\\n     * - the caller must be `owner`.\\n     */\\n    function _recapLoss(uint256 _loss) external onlyOwner {\\n        // Burn the loss from the treasury\\n        AETH.burnFrom(treasury_, _loss);\\n    }\\n\\n    /**\\n     * @notice Deposits ETH into the contract for staking.\\n     * @param _validators The array of validators to deposit.\\n     */\\n    function deposit(\\n        Validator[] calldata _validators\\n    ) external whenNotPaused nonReentrant onlyManager depositBalanceCheck(_validators) {\\n        _deposit(_validators);\\n    }\\n\\n    /**\\n     * @notice The whitelist operator deposits ETH into the contract for staking.\\n     * @param _validators The array of validators to deposit.\\n     * @param _depositRoot The expected deposit root.\\n     */\\n    function depositCheck(\\n        Validator[] calldata _validators,\\n        bytes32 _depositRoot\\n    ) external whenNotPaused nonReentrant onlyManager depositBalanceCheck(_validators) {\\n        _depositCheck(_validators, _depositRoot);\\n    }\\n\\n    /**\\n     * @notice Supplies reward.\\n     * @param _amount The amount to supply.\\n     */\\n    function supplyReward(uint256 _amount) external whenNotPaused onlyRewardOracle {\\n        require(_amount != 0, \\\"supplyReward: Amount cannot be 0\\\");\\n\\n        uint256 _treasuryAmount = _getTreasuryAmount(_amount);\\n        if (_treasuryAmount > 0) AETH.mint(treasury_, _treasuryAmount);\\n\\n        uint256 _reward = _amount - _treasuryAmount;\\n        if (_reward > 0) AETH.mint(address(SAETH), _reward);\\n    }\\n\\n    /**\\n     * @notice Receives earnings from a strategy.\\n     */\\n    function receiveStrategyEarning() external payable {\\n        _receiveStrategyEarning(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Submits a transaction to the CorePrimary contract.\\n     * @dev This function is called internally when a user submits a transaction.\\n     * @param _receiver The address of the receiver of the transaction.\\n     */\\n    function _submit(address _receiver) internal override whenNotPaused nonReentrant {\\n        _increaseReservesByRatio(msg.value);\\n        Submit._submit(_receiver);\\n    }\\n\\n    /**\\n     * @dev Internal function to withdraw funds from the contract.\\n     * @param _sender The address of the sender.\\n     * @param _receiver The address of the receiver.\\n     * @param _amount The amount to withdraw.\\n     */\\n    function _withdraw(\\n        address _sender,\\n        address _receiver,\\n        uint256 _amount\\n    ) internal override whenNotPaused nonReentrant {\\n        AETH.burnFrom(_sender, _amount);\\n        WithdrawalQueue._withdraw(_sender, _receiver, _amount);\\n    }\\n\\n    /**\\n     * @notice Claims the rewards by queue ID.\\n     * @param _sender The address of the sender.\\n     * @param _receiver The address of the receiver.\\n     * @param _queueIds The array of queue IDs.\\n     * @param _userQueueIds The set of user queue IDs.\\n     */\\n    function _claimByQueueId(\\n        address _sender,\\n        address _receiver,\\n        uint256[] memory _queueIds,\\n        EnumerableSet.UintSet storage _userQueueIds\\n    ) internal override whenNotPaused nonReentrant {\\n        WithdrawalQueue._claimByQueueId(_sender, _receiver, _queueIds, _userQueueIds);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of ETH that can be withdrawn from the contract.\\n     * @return _availableAmount The available amount of ETH that can be withdrawn.\\n     */\\n    function _withdrawableAmount() internal view override returns (uint256 _availableAmount) {\\n        uint256 _balance = address(this).balance;\\n        uint256 _locked = pendingClaimAmount_ + strategyReserve_;\\n        if (_balance > _locked) {\\n            _availableAmount = _balance - _locked;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the amount of ETH that can be claimed from the contract.\\n     * @return _claimableAmount The amount of ETH that can be claimed.\\n     */\\n    function _claimableAmount() internal view override returns (uint256) {\\n        return address(this).balance - strategyReserve_ + totalClaimed_;\\n    }\\n\\n    /**\\n     * @notice Withdraws a specified amount of tokens with permit functionality.\\n     * @param _amount The amount of tokens to withdraw.\\n     * @param _receiver The address to receive the tokens.\\n     * @param _deadline The deadline for the permit.\\n     * @param _approveMax Boolean indicating whether to approve the maximum amount.\\n     * @param _v The recovery id of the permit signature.\\n     * @param _r The R value of the permit signature.\\n     * @param _s The S value of the permit signature.\\n     */\\n    function withdrawWithPermit(\\n        uint256 _amount,\\n        address _receiver,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        // Determine the value to be approved\\n        uint256 _value = _approveMax ? type(uint256).max : _amount;\\n\\n        // Call the permit function of the token contract\\n        AETH.permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\\n\\n        // Withdraw the specified amount of tokens\\n        _withdraw(msg.sender, _receiver, _amount);\\n    }\\n\\n    /**\\n     * @notice Redeems a specified amount of saETH and withdraws the underlying ETH.\\n     * @param _saETHAmount The amount of saETH to redeem.\\n     */\\n    function redeemAndWithdraw(uint256 _saETHAmount) external {\\n        address _sender = msg.sender;\\n        uint256 _amount = SAETH.redeem(_saETHAmount, address(this), _sender);\\n        _withdraw(address(this), _sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Withdraws a specified amount of underlying ETH and saETH.\\n     * @param _amount The amount of underlying ETH to withdraw.\\n     */\\n    function redeemUnderlyingAndWithdraw(uint256 _amount) external {\\n        address _sender = msg.sender;\\n        SAETH.withdraw(_amount, address(this), _sender);\\n        _withdraw(address(this), _sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the reward oracle.\\n     * @return The address of the reward oracle.\\n     */\\n    function rewardOracle() external view returns (address) {\\n        return rewardOracle_;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of ETH received by the contract.\\n     * @return The amount of ETH received by the contract.\\n     */\\n    function received() external view returns (uint256) {\\n        return received_;\\n    }\\n\\n    /**\\n     * @dev Returns whether the given address is a pause guardian.\\n     * @param _pauseGuardian The address to check.\\n     * @return Whether the given address is a pause guardian.\\n     */\\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\\n    }\\n\\n    /**\\n     * @dev Returns the staking reward.\\n     * @param _deposited The amount deposited.\\n     * @param _exited The amount exited.\\n     * @return _stakingReward The staking reward.\\n     */\\n    function stakingReward(uint256 _deposited, uint256 _exited) external view returns (uint256 _stakingReward) {\\n        uint256 _minuend = address(this).balance +\\n            totalWithdrawn_ +\\n            totalClaimed_ +\\n            depositStrategy_ +\\n            _deposited *\\n            DEPOSIT_SIZE;\\n        uint256 _subtrahend = submitted_ + received_ + receiveStrategy_ + _exited * DEPOSIT_SIZE;\\n        if (_minuend > _subtrahend) _stakingReward = _minuend - _subtrahend;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IaETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\\\";\\n\\ninterface IaETH is IERC20Upgradeable, IERC20PermitUpgradeable {\\n    function mint(address _receiver, uint256 _amount) external;\\n\\n    function burn(uint256 _amount) external;\\n\\n    function burnFrom(address _account, uint256 _amount) external;\\n\\n    function minterMint(address _receiver, uint256 _amount) external;\\n\\n    function minterBurn(uint256 _amount) external;\\n\\n    function mintCap(address _minter) external view returns (uint256);\\n\\n    function mintAmount(address _minter) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IDepositContract {\\n    function get_deposit_root() external view returns (bytes32 rootHash);\\n\\n    function deposit(\\n        bytes calldata pubkey, // 48 bytes\\n        bytes calldata withdrawal_credentials, // 32 bytes\\n        bytes calldata signature, // 96 bytes\\n        bytes32 deposit_data_root\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRewardOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IRewardOracle {\\n    function core() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IsaETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IsaETH {\\n    function deposit(uint256 _assets, address _receiver) external returns (uint256 _shares);\\n\\n    function withdraw(uint256 _assets, address _receiver, address _owner) external returns (uint256 _shares);\\n\\n    function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 _assets);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IStrategy {\\n    function strategyReceive() external payable returns (uint256);\\n\\n    function aETH() external view returns (address);\\n\\n    function core() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/library/Manable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @title Aspida's manager module\\n * @author Aspida engineer\\n */\\nabstract contract Manable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev EnumerableSet of managers\\n    EnumerableSet.AddressSet internal managers_;\\n\\n    /**\\n     * @dev Emitted when `manager` is added as `managers`.\\n     */\\n    event ManagerAdded(address manager);\\n\\n    /**\\n     * @dev Emitted when `manager` is removed from `managers`.\\n     */\\n    event ManagerRemoved(address manager);\\n\\n    /**\\n     * @dev Throws if called by any account other than the managers.\\n     */\\n    modifier onlyManager() {\\n        require(managers_.contains(msg.sender), \\\"onlyManager: caller is not manager\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Add `manager` into managers.\\n     * If `manager` have not been a manager, emits a `ManagerAdded` event.\\n     *\\n     * @param _manager The manager to add\\n     */\\n    function _addManagerInternal(address _manager) internal virtual {\\n        require(_manager != address(0), \\\"_addManagerInternal: _manager the zero address\\\");\\n        require(managers_.add(_manager), \\\"_addManagerInternal: _manager has been added\\\");\\n        emit ManagerAdded(_manager);\\n    }\\n\\n    /**\\n     * @notice Remove `manager` from managers.\\n     * If `manager` is a manager, emits a `ManagerRemoved` event.\\n     *\\n     * @param _manager The manager to remove\\n     */\\n    function _removeManagerInternal(address _manager) internal virtual {\\n        require(managers_.remove(_manager), \\\"_removeManagerInternal: _manager has been removed\\\");\\n        emit ManagerRemoved(_manager);\\n    }\\n\\n    /**\\n     * @notice Return all managers\\n     * @return _managers The list of manager addresses\\n     */\\n    function managers() public view returns (address[] memory _managers) {\\n        _managers = managers_.values();\\n    }\\n\\n    /**\\n     * @dev Check if address is manager\\n     * @param _manager The address to check\\n     * @return Is manager boolean, true: is the manager; false: not the manager\\n     */\\n    function isManager(address _manager) public view returns (bool) {\\n        return managers_.contains(_manager);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/PauseGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @title Aspida's PauseGuardian module\\n * @author Aspida engineer\\n */\\nabstract contract PauseGuardian is PausableUpgradeable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev EnumerableSet of pauseGuardians\\n    EnumerableSet.AddressSet internal pauseGuardians_;\\n\\n    /**\\n     * @dev Emitted when `pauseGuardian` is added as `pauseGuardian`.\\n     */\\n    event PauseGuardianAdded(address pauseGuardian);\\n\\n    /**\\n     * @dev Emitted when `pauseGuardian` is removed from `pauseGuardians`.\\n     */\\n    event PauseGuardianRemoved(address pauseGuardian);\\n\\n    /**\\n     * @dev Throws if called by any account other than pauseGuardian.\\n     */\\n    modifier onlyPauseGuardian() {\\n        require(isPauseGuardian(msg.sender), \\\"onlyPauseGuardian: caller is not pauseGuardian\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Add `pauseGuardian` into pauseGuardians.\\n     * If `pauseGuardian` have not been a pauseGuardian, emits a `PauseGuardianAdded` event.\\n     *\\n     * @param _pauseGuardian The pauseGuardian to add\\n     */\\n    function _addPauseGuardianInternal(address _pauseGuardian) internal virtual {\\n        require(_pauseGuardian != address(0), \\\"_addPauseGuardianInternal: _pauseGuardian the zero address\\\");\\n        require(pauseGuardians_.add(_pauseGuardian), \\\"_addPauseGuardianInternal: _pauseGuardian has been added\\\");\\n        emit PauseGuardianAdded(_pauseGuardian);\\n    }\\n\\n    /**\\n     * @notice Remove `pauseGuardian` from pauseGuardians.\\n     * If `pauseGuardian` is a pauseGuardian, emits a `PauseGuardianRemoved` event.\\n     *\\n     * @param _pauseGuardian The pauseGuardian to remove\\n     */\\n    function _removePauseGuardianInternal(address _pauseGuardian) internal virtual {\\n        require(\\n            pauseGuardians_.remove(_pauseGuardian),\\n            \\\"_removePauseGuardianInternal: _pauseGuardian has been removed\\\"\\n        );\\n        emit PauseGuardianRemoved(_pauseGuardian);\\n    }\\n\\n    /**\\n     * @notice Return all pauseGuardians\\n     * @return _pauseGuardians The list of pauseGuardian addresses\\n     */\\n    function pauseGuardians() public view returns (address[] memory _pauseGuardians) {\\n        _pauseGuardians = pauseGuardians_.values();\\n    }\\n\\n    /**\\n     * @dev Check if address is pauseGuardian\\n     * @param _pauseGuardian The address to check\\n     * @return Is pauseGuardian boolean, true: is the pauseGuardian; false: not the pauseGuardian\\n     */\\n    function isPauseGuardian(address _pauseGuardian) public view virtual returns (bool) {\\n        return pauseGuardians_.contains(_pauseGuardian);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/TransferHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for safely executing transfers and approvals of ERC20 tokens and ETH.\\n */\\nlibrary TransferHelper {\\n    /**\\n     * @dev Safely approves `value` tokens for `to` by calling the `approve` function on `token`.\\n     * @param token The address of the ERC20 token.\\n     * @param to The address to approve tokens for.\\n     * @param value The number of tokens to approve.\\n     */\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers `value` tokens to `to` by calling the `transfer` function on `token`.\\n     * @param token The address of the ERC20 token.\\n     * @param to The address to transfer tokens to.\\n     * @param value The number of tokens to transfer.\\n     */\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers `value` tokens from `from` to `to` by calling the `transferFrom` function on `token`.\\n     * @param token The address of the ERC20 token.\\n     * @param from The address to transfer tokens from.\\n     * @param to The address to transfer tokens to.\\n     * @param value The number of tokens to transfer.\\n     */\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers `value` ETH to `to`.\\n     * @param to The address to transfer ETH to.\\n     * @param value The amount of ETH to transfer.\\n     */\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IDepositContract\",\"name\":\"_depositContract\",\"type\":\"address\"},{\"internalType\":\"contract IaETH\",\"name\":\"_aETH\",\"type\":\"address\"},{\"internalType\":\"contract IsaETH\",\"name\":\"_saETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorCount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositToStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"}],\"name\":\"EnterWithdrawalQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"ExitWithdrawalQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauseGuardian\",\"type\":\"address\"}],\"name\":\"PauseGuardianAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauseGuardian\",\"type\":\"address\"}],\"name\":\"PauseGuardianRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveFromStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ethValue\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveRatio\",\"type\":\"uint256\"}],\"name\":\"SetReserveRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardOracle\",\"type\":\"address\"}],\"name\":\"SetRewardOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"SetTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasuryRatio\",\"type\":\"uint256\"}],\"name\":\"SetTreasuryRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"withdrawalCredential\",\"type\":\"bytes\"}],\"name\":\"SetWithdrawalCredentials\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"Submitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingClaimAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatePendingClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strategyReserve\",\"type\":\"uint256\"}],\"name\":\"UpdateStrategyReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"}],\"name\":\"UpdateTotalClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"withdrawalCredential\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"ValidatorDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"_addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauseGuardian\",\"type\":\"address\"}],\"name\":\"_addPauseGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"_addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"_depositIntoStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_disableRewardOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loss\",\"type\":\"uint256\"}],\"name\":\"_recapLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_releaseAmount\",\"type\":\"uint256\"}],\"name\":\"_releaseStrategyReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"_removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauseGuardian\",\"type\":\"address\"}],\"name\":\"_removePauseGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"_removeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveRatio\",\"type\":\"uint256\"}],\"name\":\"_setReserveRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardOracle\",\"type\":\"address\"}],\"name\":\"_setRewardOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"_setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryRatio\",\"type\":\"uint256\"}],\"name\":\"_setTreasuryRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aETH\",\"outputs\":[{\"internalType\":\"contract IaETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_queueIds\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_queueIds\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimDataByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_claimAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_claimStatuses\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_queueId\",\"type\":\"uint256\"}],\"name\":\"claimDataByQueueId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimAccumulated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct StakingModel.Validator[]\",\"name\":\"_validators\",\"type\":\"tuple[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct StakingModel.Validator[]\",\"name\":\"_validators\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"_depositRoot\",\"type\":\"bytes32\"}],\"name\":\"depositCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositContract\",\"outputs\":[{\"internalType\":\"contract IDepositContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauseGuardian\",\"type\":\"address\"}],\"name\":\"isPauseGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastQueueId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_managers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardians\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_pauseGuardians\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingClaimAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"}],\"name\":\"pubKeyExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveStrategyEarning\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"received\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saETHAmount\",\"type\":\"uint256\"}],\"name\":\"redeemAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlyingAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saETH\",\"outputs\":[{\"internalType\":\"contract IsaETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exited\",\"type\":\"uint256\"}],\"name\":\"stakingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategists\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategists\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"submitAndStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"supplyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"userQueueIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_claimAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_accumulations\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"withdrawWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalCredentials\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CorePrimary", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000219ab540356cbb839cbe05303d7705fa000000000000000000000000fc87753df5ef5c368b5fba8d4c5043b77e8c5b39000000000000000000000000f1617882a71467534d14eee865922de1395c9e89", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}