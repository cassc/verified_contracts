{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"XengameV2Live/NFTregistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IXENNFTContract {\\r\\n    function ownerOf(uint256) external view returns (address);\\r\\n}\\r\\n\\r\\ncontract NFTRegistry {\\r\\n    struct NFT {\\r\\n        uint256 tokenId;\\r\\n        string category;\\r\\n    }\\r\\n\\r\\n    struct User {\\r\\n        NFT[] userNFTs;\\r\\n        uint256 userRewards; // Tracks total rewards sebt to user.\\r\\n        uint256 userPoints;\\r\\n        uint256 lastRewardRatio;\\r\\n    }\\r\\n\\r\\n    mapping(address => User) public users;\\r\\n    mapping(uint256 => string) private categoryMap;\\r\\n    mapping(uint256 => address) public currentHolder;\\r\\n    mapping(string => uint256) public globalCounters;\\r\\n\\r\\n    uint256 private constant XUNICORN_MIN_ID = 1;\\r\\n    uint256 private constant XUNICORN_MAX_ID = 100;\\r\\n    uint256 private constant EXOTIC_MIN_ID = 101;\\r\\n    uint256 private constant EXOTIC_MAX_ID = 1000;\\r\\n    uint256 private constant LEGENDARY_MIN_ID = 1001;\\r\\n    uint256 private constant LEGENDARY_MAX_ID = 3000;\\r\\n    uint256 private constant EPIC_MIN_ID = 3001;\\r\\n    uint256 private constant EPIC_MAX_ID = 6000;\\r\\n    uint256 private constant RARE_MIN_ID = 6001;\\r\\n    uint256 private constant RARE_MAX_ID = 10000;\\r\\n\\r\\n    mapping(uint256 => uint256) private rewardsMap;\\r\\n    address public nftContractAddress;\\r\\n    uint256 public totalRewards;\\r\\n    uint256 public totalPoints;\\r\\n    uint256 public rewardRatio;\\r\\n\\r\\n    uint256 private constant XUNICORN_WEIGHT = 50;\\r\\n    uint256 private constant EXOTIC_WEIGHT = 50;\\r\\n    uint256 private constant LEGENDARY_WEIGHT = 25;\\r\\n    uint256 private constant EPIC_WEIGHT = 10;\\r\\n    uint256 private constant RARE_WEIGHT = 5;\\r\\n    uint256 private constant COLLECTOR_WEIGHT = 0;\\r\\n\\r\\n    constructor(address _nftContractAddress) {\\r\\n        nftContractAddress = _nftContractAddress;\\r\\n\\r\\n        rewardsMap[XUNICORN_WEIGHT] = 50;\\r\\n        rewardsMap[EXOTIC_WEIGHT] = 50;\\r\\n        rewardsMap[LEGENDARY_WEIGHT] = 25;\\r\\n        rewardsMap[EPIC_WEIGHT] = 10;\\r\\n        rewardsMap[RARE_WEIGHT] = 5;\\r\\n        rewardsMap[COLLECTOR_WEIGHT] = 0;\\r\\n\\r\\n        // Initialize totalRewards and totalPoints with small non-zero values\\r\\n        totalRewards = 1 wei; // 1 wei\\r\\n        totalPoints = 1;\\r\\n    }\\r\\n\\r\\n    event NFTRegistered(address indexed user, uint256 tokenId, uint256 rewards);\\r\\n    event RewardsWithdrawn(address indexed user, uint256 amount);\\r\\n    \\r\\n    receive() external payable {\\r\\n        totalRewards += msg.value;\\r\\n        rewardRatio += msg.value / totalPoints;\\r\\n    }\\r\\n\\r\\n    function addToPool() external payable {\\r\\n        totalRewards += msg.value;\\r\\n        rewardRatio += msg.value / totalPoints;\\r\\n    }\\r\\n\\r\\n    function registerNFT(uint256 tokenId) public {\\r\\n        address player = msg.sender;\\r\\n        require(IXENNFTContract(nftContractAddress).ownerOf(tokenId) == player, \\\"You don't own this NFT.\\\");\\r\\n\\r\\n        // Calculate the reward points for the NFT\\r\\n        uint256 rewardPoints = getTokenWeight(tokenId);\\r\\n\\r\\n        // Check if the NFT was previously registered to a different user\\r\\n        address  previousOwner = getNFTOwner(tokenId);\\r\\n        require(previousOwner != player, \\\"You already have this NFT regestered\\\");\\r\\n        if (previousOwner != address(0) && previousOwner != player) {\\r\\n            User storage previousOwnerData = users[previousOwner];\\r\\n            \\r\\n            uint256 previousRewardAmount = calculateReward(previousOwner);\\r\\n            address payable previousOwnerpay = payable(previousOwner);\\r\\n            \\r\\n            // Remove the previous owner's points            \\r\\n            previousOwnerData.userPoints -= rewardPoints;\\r\\n            totalPoints -= rewardPoints;\\r\\n            previousOwnerData.userRewards += previousRewardAmount;\\r\\n            previousOwnerData.lastRewardRatio = rewardRatio;\\r\\n            \\r\\n            // Remove the NFT from the previous owner's list\\r\\n            for (uint256 i = 0; i < previousOwnerData.userNFTs.length; i++) {\\r\\n                if (previousOwnerData.userNFTs[i].tokenId == tokenId) {\\r\\n                    // Shift all elements to the left\\r\\n                    for (uint256 j = i; j < previousOwnerData.userNFTs.length - 1; j++) {\\r\\n                        previousOwnerData.userNFTs[j] = previousOwnerData.userNFTs[j + 1];\\r\\n                    }\\r\\n                    // Remove the last element\\r\\n                    previousOwnerData.userNFTs.pop();\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            // Pay the previous owner their rewards\\r\\n            previousOwnerpay.transfer(previousRewardAmount);\\r\\n\\r\\n        }\\r\\n        User storage currentUserData = users[player];\\r\\n\\r\\n        if (currentUserData.lastRewardRatio != rewardRatio && currentUserData.lastRewardRatio != 0) {\\r\\n            withdrawRewards();\\r\\n        }\\r\\n\\r\\n        // Update the user's rewards, points, and last rewarded timestamp\\r\\n\\r\\n        currentUserData.userPoints += rewardPoints;\\r\\n        totalPoints += rewardPoints;\\r\\n        currentUserData.lastRewardRatio = rewardRatio;\\r\\n\\r\\n        // Update the NFT ownership\\r\\n        setNFTOwner(tokenId, player);\\r\\n        emit NFTRegistered(player, tokenId, rewardPoints);\\r\\n    }\\r\\n\\r\\n    function registerNFTs(uint256[] memory tokenIds) external {\\r\\n        uint len = tokenIds.length;\\r\\n            for (uint256 i = 0; i < len; i++) {\\r\\n                registerNFT(tokenIds[i]);\\r\\n            }\\r\\n    }\\r\\n    \\r\\n\\r\\n    function isNFTRegistered(uint256 tokenId) public view returns (bool) {\\r\\n        address player = msg.sender;\\r\\n        NFT[] storage userNFTs = users[player].userNFTs;\\r\\n        uint len = userNFTs.length;\\r\\n        for (uint256 j = 0; j < len; j++) {\\r\\n            if (userNFTs[j].tokenId == tokenId) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function setNFTOwner(uint256 tokenId, address owner) private {\\r\\n        require(currentHolder[tokenId] != owner, \\\"NFT already registered by the caller.\\\");\\r\\n\\r\\n        string memory category = getCategory(tokenId);\\r\\n        currentHolder[tokenId] = owner;\\r\\n\\r\\n        // Increment the global counter for the NFT class\\r\\n        globalCounters[category]++;\\r\\n\\r\\n        // Add the token ID to the user's NFTs\\r\\n        users[owner].userNFTs.push(NFT(tokenId, category));\\r\\n    }\\r\\n\\r\\n    function getNFTOwner(uint256 tokenId) public view returns (address) {\\r\\n        return currentHolder[tokenId];\\r\\n    }\\r\\n\\r\\n    function getCategory(uint256 tokenId) public pure returns (string memory) {\\r\\n        if (tokenId >= XUNICORN_MIN_ID && tokenId <= XUNICORN_MAX_ID) {\\r\\n            return \\\"Xunicorn\\\";\\r\\n        } else if (tokenId >= EXOTIC_MIN_ID && tokenId <= EXOTIC_MAX_ID) {\\r\\n            return \\\"Exotic\\\";\\r\\n        } else if (tokenId >= LEGENDARY_MIN_ID && tokenId <= LEGENDARY_MAX_ID) {\\r\\n            return \\\"Legendary\\\";\\r\\n        } else if (tokenId >= EPIC_MIN_ID && tokenId <= EPIC_MAX_ID) {\\r\\n            return \\\"Epic\\\";\\r\\n        } else if (tokenId >= RARE_MIN_ID && tokenId <= RARE_MAX_ID) {\\r\\n            return \\\"Rare\\\";\\r\\n        } else if (tokenId > RARE_MAX_ID) {\\r\\n            return \\\"Collector\\\";\\r\\n        } else {\\r\\n            revert(\\\"Invalid token ID.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateReward(address user) public view returns (uint256) {\\r\\n        User storage userData = users[user];\\r\\n        uint256 lastRewardRatio = userData.lastRewardRatio;\\r\\n        uint256 newRewards = rewardRatio - lastRewardRatio;\\r\\n\\r\\n        return newRewards * userData.userPoints;\\r\\n    }\\r\\n\\r\\n    function withdrawRewards() public payable {\\r\\n        address player = msg.sender;\\r\\n        User storage userData = users[player];\\r\\n        require(userData.userPoints > 0, \\\"No XenFT's registered for this user\\\");\\r\\n\\r\\n        \\r\\n        if (!_hasValidOwnership(player)) {\\r\\n    for (uint256 i = 0; i < userData.userNFTs.length; i++) {\\r\\n        if(!_isNFTOwner(userData.userNFTs[i].tokenId, player)) {\\r\\n                    // remove points for this NFT\\r\\n                    userData.userPoints -= getTokenWeight(userData.userNFTs[i].tokenId);\\r\\n                    // remove NFT from user's list\\r\\n                    for (uint256 j = i; j < userData.userNFTs.length - 1; j++) {\\r\\n                        userData.userNFTs[j] = userData.userNFTs[j + 1];\\r\\n                    }\\r\\n                    userData.userNFTs.pop();\\r\\n                    // decrease i to rerun the check for the NFT that was shifted from the right\\r\\n                    i--;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 rewardAmount = calculateReward(player);\\r\\n        require(rewardAmount > 0, \\\"No new rewards available for withdrawal.\\\");\\r\\n\\r\\n        // Effects\\r\\n        userData.userRewards += rewardAmount;\\r\\n        userData.lastRewardRatio = rewardRatio;\\r\\n\\r\\n        // Interactions\\r\\n        payable(player).transfer(rewardAmount);\\r\\n        emit RewardsWithdrawn(player, rewardAmount);\\r\\n    }\\r\\n\\r\\n    function _isNFTOwner(uint256 tokenId, address owner) public view returns (bool) {\\r\\n        IXENNFTContract nftContract = IXENNFTContract(nftContractAddress);\\r\\n        address nftOwner = nftContract.ownerOf(tokenId);\\r\\n\\r\\n        return nftOwner == owner;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function getTokenWeight(uint256 tokenId) public pure returns (uint256) {\\r\\n        if (tokenId >= XUNICORN_MIN_ID && tokenId <= XUNICORN_MAX_ID) {\\r\\n            return XUNICORN_WEIGHT;\\r\\n        } else if (tokenId >= EXOTIC_MIN_ID && tokenId <= EXOTIC_MAX_ID) {\\r\\n            return EXOTIC_WEIGHT;\\r\\n        } else if (tokenId >= LEGENDARY_MIN_ID && tokenId <= LEGENDARY_MAX_ID) {\\r\\n            return LEGENDARY_WEIGHT;\\r\\n        } else if (tokenId >= EPIC_MIN_ID && tokenId <= EPIC_MAX_ID) {\\r\\n            return EPIC_WEIGHT;\\r\\n        } else if (tokenId >= RARE_MIN_ID && tokenId <= RARE_MAX_ID) {\\r\\n            return RARE_WEIGHT;\\r\\n        } else if (tokenId > EPIC_MAX_ID) {\\r\\n            return COLLECTOR_WEIGHT;\\r\\n        } else {\\r\\n            revert(\\\"Invalid token ID.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserNFTCounts(address user) external view returns (uint256[] memory) {\\r\\n        uint256[] memory nftCounts = new uint256[](6); // Array to store NFT counts for each category\\r\\n\\r\\n        User storage userData = users[user];\\r\\n        NFT[] storage userNFTs = userData.userNFTs;\\r\\n\\r\\n        // Iterate over the user's registered NFTs and count them for each category\\r\\n        uint len = userNFTs.length;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            NFT storage nft = userNFTs[i];\\r\\n            string memory category = nft.category;\\r\\n\\r\\n            if (keccak256(bytes(category)) == keccak256(bytes(\\\"Xunicorn\\\"))) {\\r\\n                nftCounts[0]++;\\r\\n            } else if (keccak256(bytes(category)) == keccak256(bytes(\\\"Exotic\\\"))) {\\r\\n                nftCounts[1]++;\\r\\n            } else if (keccak256(bytes(category)) == keccak256(bytes(\\\"Legendary\\\"))) {\\r\\n                nftCounts[2]++;\\r\\n            } else if (keccak256(bytes(category)) == keccak256(bytes(\\\"Epic\\\"))) {\\r\\n                nftCounts[3]++;\\r\\n            } else if (keccak256(bytes(category)) == keccak256(bytes(\\\"Rare\\\"))) {\\r\\n                nftCounts[4]++;\\r\\n            } else if (keccak256(bytes(category)) == keccak256(bytes(\\\"Collector\\\"))) {\\r\\n                nftCounts[5]++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return nftCounts;\\r\\n    }\\r\\n\\r\\n    function _hasValidOwnership(address user) public view returns (bool) {\\r\\n        User storage userData = users[user];\\r\\n        uint256 totalPointsOwned = 0;\\r\\n        uint len = userData.userNFTs.length;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            NFT storage nft = userData.userNFTs[i];\\r\\n            if (_isNFTOwner(nft.tokenId, user)) {\\r\\n                totalPointsOwned += getTokenWeight(nft.tokenId);\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return totalPointsOwned == userData.userPoints;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"NFTRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"_hasValidOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"_isNFTOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addToPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCategory\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFTOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserNFTCounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"globalCounters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isNFTRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"registerNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"registerNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NFTRegistry", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000a252663dbcc0b073063d6420a40319e438cfa59", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}