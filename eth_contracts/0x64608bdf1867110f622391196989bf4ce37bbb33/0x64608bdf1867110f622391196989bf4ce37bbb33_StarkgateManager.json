{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"starkware/solidity/libraries/AccessControl.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contract (access/AccessControl.sol)\\n// StarkWare modification (storage slot, change to library).\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"third_party/open_zeppelin/utils/Strings.sol\\\";\\n\\n/*\\n  Library module that allows using contracts to implement role-based access\\n  control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n  members except through off-chain means by accessing the contract event logs. Some\\n  applications may benefit from on-chain enumerability, for those cases see\\n  {AccessControlEnumerable}.\\n \\n  Roles are referred to by their `bytes32` identifier. These should be exposed\\n  in the external API and be unique. The best way to achieve this is by\\n  using `public constant` hash digests:\\n \\n  ```\\n  bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n  ```\\n \\n  Roles can be used to represent a set of permissions. To restrict access to a\\n  function call, use {hasRole}:\\n \\n  ```\\n  function foo() public {\\n      require(hasRole(MY_ROLE, msg.sender));\\n      ...\\n  }\\n  ```\\n \\n  Roles can be granted and revoked dynamically via the {grantRole} and\\n  {revokeRole} functions. Each role has an associated admin role, and only\\n  accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n \\n  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n  that only accounts with this role will be able to grant or revoke other\\n  roles. More complex role relationships can be created by using\\n  {_setRoleAdmin}.\\n \\n  WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n  grant and revoke this role. Extra precautions should be taken to secure\\n  accounts that have been granted it.\\n \\n  OpenZeppelin implementation changed as following:\\n  1. Converted to library.\\n  2. Storage valiable {_roles} moved outside of linear storage,\\n     to avoid potential storage conflicts or corruption.\\n  3. Removed ERC165 support.\\n*/\\nlibrary AccessControl {\\n    /*\\n      Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     \\n      `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n      {RoleAdminChanged} not being emitted signaling this.\\n     \\n      Available since v3.1.\\n    */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /*\\n      Emitted when `account` is granted `role`.\\n     \\n      `sender` is the account that originated the contract call, an admin role\\n      bearer except when using {AccessControl-_setupRole}.\\n    */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /*\\n      Emitted when `account` is revoked `role`.\\n     \\n      `sender` is the account that originated the contract call:\\n        - if using `revokeRole`, it is the admin role bearer\\n        - if using `renounceRole`, it is the role bearer (i.e. `account`).\\n    */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    // Context interface functions.\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal pure returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    // The storage variable `_roles` is located away from the contract linear area (low storage addresses)\\n    // to prevent potential collision/corruption in upgrade scenario.\\n    // Slot = Web3.keccak(text=\\\"AccesControl_Storage_Slot\\\").\\n    bytes32 constant rolesSlot = 0x53e43b954ba190a7e49386f1f78b01dcd9f628db23f432fa029a7dfd6d98e8fb;\\n\\n    function _roles() private pure returns (mapping(bytes32 => RoleData) storage roles) {\\n        assembly {\\n            roles.slot := rolesSlot\\n        }\\n    }\\n\\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /*\\n      Modifier that checks that an account has a specific role. Reverts\\n      with a standardized message including the required role.\\n      \\n      The format of the revert reason is given by the following regular expression:\\n      \\n      /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n      \\n      Available since v4.1.\\n    */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n      Returns `true` if `account` has been granted `role`.\\n    */\\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\\n        return _roles()[role].members[account];\\n    }\\n\\n    /*\\n      Revert with a standard message if `_msgSender()` is missing `role`.\\n      Overriding this function changes the behavior of the {onlyRole} modifier.\\n     \\n      Format of the revert message is described in {_checkRole}.\\n     \\n      Available since v4.6.\\n    */\\n    function _checkRole(bytes32 role) internal view {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /*\\n      Revert with a standard message if `account` is missing `role`.\\n     \\n      The format of the revert reason is given by the following regular expression:\\n     \\n       /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/.\\n    */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n      Returns the admin role that controls `role`. See {grantRole} and\\n      {revokeRole}.\\n     \\n      To change a role's admin, use {_setRoleAdmin}.\\n    */\\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n        return _roles()[role].adminRole;\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      If `account` had not been already granted `role`, emits a {RoleGranted}\\n      event.\\n     \\n      Requirements:\\n     \\n      - the caller must have ``role``'s admin role.\\n     \\n      May emit a {RoleGranted} event.\\n    */\\n    function grantRole(bytes32 role, address account) internal onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /*\\n      Revokes `role` from `account`.\\n     \\n      If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     \\n      Requirements:\\n     \\n      - the caller must have ``role``'s admin role.\\n     \\n      * May emit a {RoleRevoked} event.\\n    */\\n    function revokeRole(bytes32 role, address account) internal onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /*\\n      Revokes `role` from the calling account.\\n     \\n      Roles are often managed via {grantRole} and {revokeRole}: this function's\\n      purpose is to provide a mechanism for accounts to lose their privileges\\n      if they are compromised (such as when a trusted device is misplaced).\\n     \\n      If the calling account had been revoked `role`, emits a {RoleRevoked}\\n      event.\\n     \\n      Requirements:\\n     \\n      - the caller must be `account`.\\n     \\n      May emit a {RoleRevoked} event.\\n    */\\n    function renounceRole(bytes32 role, address account) internal {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      If `account` had not been already granted `role`, emits a {RoleGranted}\\n      event. Note that unlike {grantRole}, this function doesn't perform any\\n      checks on the calling account.\\n     \\n      May emit a {RoleGranted} event.\\n     \\n      [WARNING]virtual\\n      ====\\n      This function should only be called from the constructor when setting\\n      up the initial roles for the system.\\n     \\n      Using this function in any other way is effectively circumventing the admin\\n      system imposed by {AccessControl}.\\n      ====\\n     \\n      NOTE: This function is deprecated in favor of {_grantRole}.\\n    */\\n    function _setupRole(bytes32 role, address account) internal {\\n        _grantRole(role, account);\\n    }\\n\\n    /*\\n      Sets `adminRole` as ``role``'s admin role.\\n     \\n      Emits a {RoleAdminChanged} event.\\n    */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles()[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n      Grants `role` to `account`.\\n     \\n      Internal function without access restriction.\\n     \\n      May emit a {RoleGranted} event.\\n    */\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles()[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /*\\n      Revokes `role` from `account`.\\n     \\n      Internal function without access restriction.\\n     \\n      May emit a {RoleRevoked} event.\\n    */\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            _roles()[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/Addresses.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  Common Utility Libraries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    /*\\n      Note: isContract function has some known limitation.\\n      See https://github.com/OpenZeppelin/\\n      openzeppelin-contracts/blob/master/contracts/utils/Address.sol.\\n    */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        if (amount == 0) return;\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don't return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/BlockDirectCall.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  This contract provides means to block direct call of an external function.\\n  A derived contract (e.g. MainDispatcherBase) should decorate sensitive functions with the\\n  notCalledDirectly modifier, thereby preventing it from being called directly, and allowing only\\n  calling using delegate_call.\\n*/\\nabstract contract BlockDirectCall {\\n    address immutable this_;\\n\\n    constructor() {\\n        this_ = address(this);\\n    }\\n\\n    modifier notCalledDirectly() {\\n        require(this_ != address(this), \\\"DIRECT_CALL_DISALLOWED\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/ContractInitializer.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/**\\n  Interface for contract initialization.\\n  The functions it exposes are the app specific parts of the contract initialization,\\n  and are called by the ProxySupport contract that implement the generic part of behind-proxy\\n  initialization.\\n*/\\nabstract contract ContractInitializer {\\n    /*\\n      The number of sub-contracts that the proxied contract consists of.\\n    */\\n    function numOfSubContracts() internal pure virtual returns (uint256);\\n\\n    /*\\n      Indicates if the proxied contract has already been initialized.\\n      Used to prevent re-init.\\n    */\\n    function isInitialized() internal view virtual returns (bool);\\n\\n    /*\\n      Validates the init data that is passed into the proxied contract.\\n    */\\n    function validateInitData(bytes calldata data) internal view virtual;\\n\\n    /*\\n      For a proxied contract that consists of sub-contracts, this function processes\\n      the sub-contract addresses, e.g. validates them, stores them etc.\\n    */\\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal virtual;\\n\\n    /*\\n      This function applies the logic of initializing the proxied contract state,\\n      e.g. setting root values etc.\\n    */\\n    function initializeContractState(bytes calldata data) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateBridge.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateBridge {\\n    /**\\n       Enrolls a token in the Starknet Token Bridge system.\\n    */\\n    function enrollToken(address token) external payable;\\n\\n    /**\\n      Deactivates token bridging.\\n      Deactivated token does not accept deposits.\\n     */\\n    function deactivate(address token) external;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateManager.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateManager {\\n    /**\\n      Returns the address of the Starkgate Registry contract.\\n    */\\n    function getRegistry() external view returns (address);\\n\\n    /**\\n      Adds an existing bridge to the Starkgate system for a specific token.\\n     */\\n    function addExistingBridge(address token, address bridge) external;\\n\\n    /**\\n      Deactivates bridging of a specific token.\\n      A deactivated token is blocked for deposits and cannot be re-deployed.     \\n      */\\n    function deactivateToken(address token) external;\\n\\n    /**\\n      Block a specific token from being used in the StarkGate.\\n      A blocked token cannot be deployed.\\n      */\\n    function blockToken(address token) external;\\n\\n    /**\\n      Enrolls a token bridge for a specific token.\\n     */\\n    function enrollTokenBridge(address token) external payable;\\n}\\n\"\r\n    },\r\n    \"src/solidity/IStarkgateRegistry.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface IStarkgateRegistry {\\n    /**\\n      Returns the bridge that handles the given token.\\n    */\\n    function getBridge(address token) external view returns (address);\\n\\n    /**\\n      Add a mapping between a token and the bridge handling it.\\n    */\\n    function enlistToken(address token, address bridge) external;\\n\\n    /**\\n      Block a specific token from being used in the StarkGate.\\n      A blocked token cannot be deployed.\\n      */\\n    function blockToken(address token) external;\\n\\n    /**\\n      Retrieves a list of bridge addresses that have facilitated withdrawals \\n      for the specified token.\\n     */\\n    function getWithdrawalBridges(address token) external view returns (address[] memory bridges);\\n\\n    /**\\n      Using this function a bridge removes enlisting of its token from the registry.\\n      The bridge must implement `isServicingToken(address token)` (see `IStarkgateService`).\\n     */\\n    function selfRemove(address token) external;\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/Identity.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\ninterface Identity {\\n    /*\\n      Allows a caller to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/NamedStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\n/*\\n  Library to provide basic storage, in storage location out of the low linear address space.\\n\\n  New types of storage variables should be added here upon need.\\n*/\\nlibrary NamedStorage {\\n    function bytes32ToBoolMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => bool) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function bytes32ToUint256Mapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => uint256) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToUint256Mapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => uint256) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function bytes32ToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function uintToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(uint256 => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToAddressListMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => address[]) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function addressToBoolMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address => bool) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable.slot := location\\n        }\\n    }\\n\\n    function getUintValue(string memory tag_) internal view returns (uint256 retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setUintValue(string memory tag_, uint256 value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setUintValueOnce(string memory tag_, uint256 value) internal {\\n        require(getUintValue(tag_) == 0, \\\"ALREADY_SET\\\");\\n        setUintValue(tag_, value);\\n    }\\n\\n    function getAddressValue(string memory tag_) internal view returns (address retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setAddressValue(string memory tag_, address value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setAddressValueOnce(string memory tag_, address value) internal {\\n        require(getAddressValue(tag_) == address(0x0), \\\"ALREADY_SET\\\");\\n        setAddressValue(tag_, value);\\n    }\\n\\n    function getBoolValue(string memory tag_) internal view returns (bool retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setBoolValue(string memory tag_, bool value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/interfaces/ProxySupport.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/components/Roles.sol\\\";\\nimport \\\"starkware/solidity/libraries/RolesLib.sol\\\";\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/interfaces/BlockDirectCall.sol\\\";\\nimport \\\"starkware/solidity/interfaces/ContractInitializer.sol\\\";\\n\\n/**\\n  This contract contains the code commonly needed for a contract to be deployed behind\\n  an upgradability proxy.\\n  It perform the required semantics of the proxy pattern,\\n  but in a generic manner.\\n*/\\nabstract contract ProxySupport is BlockDirectCall, ContractInitializer, Roles(true) {\\n    using Addresses for address;\\n\\n    // The two function below (isFrozen & initialize) needed to bind to the Proxy.\\n    function isFrozen() external view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /*\\n      The initialize() function serves as an alternative constructor for a proxied deployment.\\n\\n      Flow and notes:\\n      1. This function cannot be called directly on the deployed contract, but only via\\n         delegate call.\\n      2. If an EIC is provided - init is passed onto EIC and the standard init flow is skipped.\\n         This true for both first intialization or a later one.\\n      3. The data passed to this function is as follows:\\n         [sub_contracts addresses, eic address, initData].\\n\\n         When calling on an initialized contract (no EIC scenario), initData.length must be 0.\\n    */\\n    function initialize(bytes calldata data) external notCalledDirectly {\\n        uint256 eicOffset = 32 * numOfSubContracts();\\n        uint256 expectedBaseSize = eicOffset + 32;\\n        require(data.length >= expectedBaseSize, \\\"INIT_DATA_TOO_SMALL\\\");\\n        address eicAddress = abi.decode(data[eicOffset:expectedBaseSize], (address));\\n\\n        bytes calldata subContractAddresses = data[:eicOffset];\\n\\n        processSubContractAddresses(subContractAddresses);\\n\\n        bytes calldata initData = data[expectedBaseSize:];\\n\\n        // EIC Provided - Pass initData to EIC and the skip standard init flow.\\n        if (eicAddress != address(0x0)) {\\n            callExternalInitializer(eicAddress, initData);\\n            return;\\n        }\\n\\n        if (isInitialized()) {\\n            require(initData.length == 0, \\\"UNEXPECTED_INIT_DATA\\\");\\n        } else {\\n            // Contract was not initialized yet.\\n            validateInitData(initData);\\n            initializeContractState(initData);\\n            RolesLib.initialize();\\n        }\\n    }\\n\\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata eicData)\\n        private\\n    {\\n        require(externalInitializerAddr.isContract(), \\\"EIC_NOT_A_CONTRACT\\\");\\n\\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\\n            abi.encodeWithSelector(this.initialize.selector, eicData)\\n        );\\n        require(success, string(returndata));\\n        require(returndata.length == 0, string(returndata));\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/components/Roles.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/RolesLib.sol\\\";\\n\\nabstract contract Roles {\\n    // This flag dermine if the GOVERNANCE_ADMIN role can be renounced.\\n    bool immutable fullyRenouncable;\\n\\n    constructor(bool renounceable) {\\n        fullyRenouncable = renounceable;\\n        RolesLib.initialize();\\n    }\\n\\n    // MODIFIERS.\\n    modifier onlyAppGovernor() {\\n        require(isAppGovernor(AccessControl._msgSender()), \\\"ONLY_APP_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(isOperator(AccessControl._msgSender()), \\\"ONLY_OPERATOR\\\");\\n        _;\\n    }\\n\\n    modifier onlySecurityAdmin() {\\n        require(isSecurityAdmin(AccessControl._msgSender()), \\\"ONLY_SECURITY_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlySecurityAgent() {\\n        require(isSecurityAgent(AccessControl._msgSender()), \\\"ONLY_SECURITY_AGENT\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenAdmin() {\\n        require(isTokenAdmin(AccessControl._msgSender()), \\\"ONLY_TOKEN_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyUpgradeGovernor() {\\n        require(isUpgradeGovernor(AccessControl._msgSender()), \\\"ONLY_UPGRADE_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    modifier notSelf(address account) {\\n        require(account != AccessControl._msgSender(), \\\"CANNOT_PERFORM_ON_SELF\\\");\\n        _;\\n    }\\n\\n    // Is holding role.\\n    function isAppGovernor(address account) public view returns (bool) {\\n        return AccessControl.hasRole(APP_GOVERNOR, account);\\n    }\\n\\n    function isAppRoleAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function isGovernanceAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function isOperator(address account) public view returns (bool) {\\n        return AccessControl.hasRole(OPERATOR, account);\\n    }\\n\\n    function isSecurityAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function isSecurityAgent(address account) public view returns (bool) {\\n        return AccessControl.hasRole(SECURITY_AGENT, account);\\n    }\\n\\n    function isTokenAdmin(address account) public view returns (bool) {\\n        return AccessControl.hasRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function isUpgradeGovernor(address account) public view returns (bool) {\\n        return AccessControl.hasRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Register Role.\\n    function registerAppGovernor(address account) external {\\n        AccessControl.grantRole(APP_GOVERNOR, account);\\n    }\\n\\n    function registerAppRoleAdmin(address account) external {\\n        AccessControl.grantRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function registerGovernanceAdmin(address account) external {\\n        AccessControl.grantRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function registerOperator(address account) external {\\n        AccessControl.grantRole(OPERATOR, account);\\n    }\\n\\n    function registerSecurityAdmin(address account) external {\\n        AccessControl.grantRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function registerSecurityAgent(address account) external {\\n        AccessControl.grantRole(SECURITY_AGENT, account);\\n    }\\n\\n    function registerTokenAdmin(address account) external {\\n        AccessControl.grantRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function registerUpgradeGovernor(address account) external {\\n        AccessControl.grantRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Revoke Role.\\n    function revokeAppGovernor(address account) external {\\n        AccessControl.revokeRole(APP_GOVERNOR, account);\\n    }\\n\\n    function revokeAppRoleAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(APP_ROLE_ADMIN, account);\\n    }\\n\\n    function revokeGovernanceAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(GOVERNANCE_ADMIN, account);\\n    }\\n\\n    function revokeOperator(address account) external {\\n        AccessControl.revokeRole(OPERATOR, account);\\n    }\\n\\n    function revokeSecurityAdmin(address account) external notSelf(account) {\\n        AccessControl.revokeRole(SECURITY_ADMIN, account);\\n    }\\n\\n    function revokeSecurityAgent(address account) external {\\n        AccessControl.revokeRole(SECURITY_AGENT, account);\\n    }\\n\\n    function revokeTokenAdmin(address account) external {\\n        AccessControl.revokeRole(TOKEN_ADMIN, account);\\n    }\\n\\n    function revokeUpgradeGovernor(address account) external {\\n        AccessControl.revokeRole(UPGRADE_GOVERNOR, account);\\n    }\\n\\n    // Renounce Role.\\n    function renounceRole(bytes32 role, address account) external {\\n        if (role == GOVERNANCE_ADMIN && !fullyRenouncable) {\\n            revert(\\\"CANNOT_RENOUNCE_GOVERNANCE_ADMIN\\\");\\n        }\\n        AccessControl.renounceRole(role, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"starkware/solidity/libraries/RolesLib.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.0;\\n\\nimport \\\"starkware/solidity/libraries/AccessControl.sol\\\";\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_APP_GOVERNOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant APP_GOVERNOR = bytes32(\\n    uint256(0xd2ead78c620e94b02d0a996e99298c59ddccfa1d8a0149080ac3a20de06068)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_APP_ROLE_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant APP_ROLE_ADMIN = bytes32(\\n    uint256(0x03e615638e0b79444a70f8c695bf8f2a47033bf1cf95691ec3130f64939cee99)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_GOVERNANCE_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant GOVERNANCE_ADMIN = bytes32(\\n    uint256(0x03711c9d994faf6055172091cb841fd4831aa743e6f3315163b06a122c841846)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_OPERATOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant OPERATOR = bytes32(\\n    uint256(0x023edb77f7c8cc9e38e8afe78954f703aeeda7fffe014eeb6e56ea84e62f6da7)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_SECURITY_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant SECURITY_ADMIN = bytes32(\\n    uint256(0x026bd110619d11cfdfc28e281df893bc24828e89177318e9dbd860cdaedeb6b3)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_SECURITY_AGENT\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant SECURITY_AGENT = bytes32(\\n    uint256(0x037693ba312785932d430dccf0f56ffedd0aa7c0f8b6da2cc4530c2717689b96)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_TOKEN_ADMIN\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant TOKEN_ADMIN = bytes32(\\n    uint256(0x0128d63adbf6b09002c26caf55c47e2f26635807e3ef1b027218aa74c8d61a3e)\\n);\\n\\n// int.from_bytes(Web3.keccak(text=\\\"ROLE_UPGRADE_GOVERNOR\\\"), \\\"big\\\") & MASK_250 .\\nbytes32 constant UPGRADE_GOVERNOR = bytes32(\\n    uint256(0x0251e864ca2a080f55bce5da2452e8cfcafdbc951a3e7fff5023d558452ec228)\\n);\\n\\n/*\\n  Role                |   Role Admin\\n  ----------------------------------------\\n  GOVERNANCE_ADMIN    |   GOVERNANCE_ADMIN\\n  UPGRADE_GOVERNOR    |   GOVERNANCE_ADMIN\\n  APP_ROLE_ADMIN      |   GOVERNANCE_ADMIN\\n  APP_GOVERNOR        |   APP_ROLE_ADMIN\\n  OPERATOR            |   APP_ROLE_ADMIN\\n  TOKEN_ADMIN         |   APP_ROLE_ADMIN\\n  SECURITY_ADMIN      |   SECURITY_ADMIN\\n  SECURITY_AGENT      |   SECURITY_ADMIN .\\n*/\\nlibrary RolesLib {\\n    // INITIALIZERS.\\n    function governanceRolesInitialized() internal view returns (bool) {\\n        return AccessControl.getRoleAdmin(GOVERNANCE_ADMIN) != bytes32(0x00);\\n    }\\n\\n    function securityRolesInitialized() internal view returns (bool) {\\n        return AccessControl.getRoleAdmin(SECURITY_ADMIN) != bytes32(0x00);\\n    }\\n\\n    function initialize() internal {\\n        address provisional = AccessControl._msgSender();\\n        initialize(provisional, provisional);\\n    }\\n\\n    function initialize(address provisionalGovernor, address provisionalSecAdmin) internal {\\n        if (governanceRolesInitialized()) {\\n            // Support Proxied contract initialization.\\n            // In case the Proxy already initialized the roles,\\n            // init will succeed IFF the provisionalGovernor is already `GovernanceAdmin`.\\n            require(\\n                AccessControl.hasRole(GOVERNANCE_ADMIN, provisionalGovernor),\\n                \\\"ROLES_ALREADY_INITIALIZED\\\"\\n            );\\n        } else {\\n            initGovernanceRoles(provisionalGovernor);\\n        }\\n\\n        if (securityRolesInitialized()) {\\n            // If SecurityAdmin initialized,\\n            // then provisionalSecAdmin must already be a `SecurityAdmin`.\\n            // If it's not initilized - initialize it.\\n            require(\\n                AccessControl.hasRole(SECURITY_ADMIN, provisionalSecAdmin),\\n                \\\"SECURITY_ROLES_ALREADY_INITIALIZED\\\"\\n            );\\n        } else {\\n            initSecurityRoles(provisionalSecAdmin);\\n        }\\n    }\\n\\n    function initSecurityRoles(address provisionalSecAdmin) private {\\n        AccessControl._setRoleAdmin(SECURITY_ADMIN, SECURITY_ADMIN);\\n        AccessControl._setRoleAdmin(SECURITY_AGENT, SECURITY_ADMIN);\\n        AccessControl._grantRole(SECURITY_ADMIN, provisionalSecAdmin);\\n    }\\n\\n    function initGovernanceRoles(address provisionalGovernor) private {\\n        AccessControl._grantRole(GOVERNANCE_ADMIN, provisionalGovernor);\\n        AccessControl._setRoleAdmin(APP_GOVERNOR, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(APP_ROLE_ADMIN, GOVERNANCE_ADMIN);\\n        AccessControl._setRoleAdmin(GOVERNANCE_ADMIN, GOVERNANCE_ADMIN);\\n        AccessControl._setRoleAdmin(OPERATOR, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(TOKEN_ADMIN, APP_ROLE_ADMIN);\\n        AccessControl._setRoleAdmin(UPGRADE_GOVERNOR, GOVERNANCE_ADMIN);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solidity/StarkgateConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\n// Starknet L1 handler selectors.\\nuint256 constant HANDLE_DEPOSIT_SELECTOR = 1285101517810983806491589552491143496277809242732141897358598292095611420389;\\nuint256 constant HANDLE_TOKEN_DEPOSIT_SELECTOR = 774397379524139446221206168840917193112228400237242521560346153613428128537;\\n\\nuint256 constant HANDLE_DEPOSIT_WITH_MESSAGE_SELECTOR = 247015267890530308727663503380700973440961674638638362173641612402089762826;\\n\\nuint256 constant HANDLE_TOKEN_DEPLOYMENT_SELECTOR = 1737780302748468118210503507461757847859991634169290761669750067796330642876;\\n\\nuint256 constant TRANSFER_FROM_STARKNET = 0;\\nuint256 constant UINT256_PART_SIZE_BITS = 128;\\nuint256 constant UINT256_PART_SIZE = 2**UINT256_PART_SIZE_BITS;\\nuint256 constant MAX_PENDING_DURATION = 5 days;\\naddress constant BLOCKED_TOKEN = address(0x1);\\n\\n// Cairo felt252 value (short string) of 'ETH'\\naddress constant ETH = address(0x455448);\\n\"\r\n    },\r\n    \"src/solidity/StarkgateManager.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.8.20;\\n\\nimport \\\"starkware/solidity/components/Roles.sol\\\";\\nimport \\\"starkware/solidity/interfaces/Identity.sol\\\";\\nimport \\\"starkware/solidity/interfaces/ProxySupport.sol\\\";\\nimport \\\"starkware/solidity/libraries/Addresses.sol\\\";\\nimport \\\"starkware/solidity/libraries/NamedStorage.sol\\\";\\nimport \\\"src/solidity/IStarkgateBridge.sol\\\";\\nimport \\\"src/solidity/IStarkgateManager.sol\\\";\\nimport \\\"src/solidity/IStarkgateRegistry.sol\\\";\\nimport \\\"src/solidity/StarkgateConstants.sol\\\";\\n\\ncontract StarkgateManager is Identity, IStarkgateManager, ProxySupport {\\n    using Addresses for address;\\n    // Named storage slot tags.\\n    string internal constant REGISTRY_TAG = \\\"STARKGATE_MANAGER_REGISTRY_SLOT_TAG\\\";\\n    string internal constant BRIDGE_TAG = \\\"STARKGATE_MANAGER_BRIDGE_SLOT_TAG\\\";\\n    event TokenEnrolled(address indexed token, address indexed sender);\\n    event ExistingBridgeAdded(address indexed token, address indexed bridge);\\n    event TokenDeactivated(address indexed token, address indexed sender);\\n    event TokenBlocked(address indexed token, address indexed sender);\\n\\n    function getRegistry() external view returns (address) {\\n        return registry();\\n    }\\n\\n    // Storage Getters.\\n    // TODO : add doc.\\n    function registry() internal view returns (address) {\\n        return NamedStorage.getAddressValue(REGISTRY_TAG);\\n    }\\n\\n    function bridge() internal view returns (address) {\\n        return NamedStorage.getAddressValue(BRIDGE_TAG);\\n    }\\n\\n    // Storage Setters.\\n    function setRegistry(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(REGISTRY_TAG, contract_);\\n    }\\n\\n    function setBridge(address contract_) internal {\\n        NamedStorage.setAddressValueOnce(BRIDGE_TAG, contract_);\\n    }\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_StarkgateManager_2.0_1\\\";\\n    }\\n\\n    /*\\n      Initializes the contract.\\n    */\\n    function initializeContractState(bytes calldata data) internal override {\\n        (address registry_, address bridge_) = abi.decode(data, (address, address));\\n        setRegistry(registry_);\\n        setBridge(bridge_);\\n    }\\n\\n    function isInitialized() internal view override returns (bool) {\\n        return registry() != address(0);\\n    }\\n\\n    function numOfSubContracts() internal pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /*\\n      No processing needed, as there are no sub-contracts to this contract.\\n    */\\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal override {}\\n\\n    function validateInitData(bytes calldata data) internal view virtual override {\\n        require(data.length == 64, \\\"ILLEGAL_DATA_SIZE\\\");\\n        (address registry_, address bridge_) = abi.decode(data, (address, address));\\n        require(registry_.isContract(), \\\"INVALID_REGISTRY_CONTRACT_ADDRESS\\\");\\n        require(bridge_.isContract(), \\\"INVALID_BRIDGE_CONTRACT_ADDRESS\\\");\\n    }\\n\\n    function addExistingBridge(address token, address bridge_) external onlyTokenAdmin {\\n        require(bridge() != bridge_, \\\"CANNOT_ADD_MAIN_MULTI_BRIDGE_AS_EXISTING\\\");\\n        IStarkgateRegistry(registry()).enlistToken(token, bridge_);\\n        emit ExistingBridgeAdded(token, bridge_);\\n    }\\n\\n    /**\\n      Deactivates bridging of a specific token.\\n      A deactivated token is blocked for deposits and cannot be re-deployed.\\n      Note: Only serviced tokens can be deactivated. In order to block an unserviced tokens\\n      see 'blockToken'.\\n    */\\n    function deactivateToken(address token) external onlyTokenAdmin {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        address current_bridge = registryContract.getBridge(token);\\n\\n        require(current_bridge != address(0), \\\"TOKEN_NOT_ENROLLED\\\");\\n        if (current_bridge == BLOCKED_TOKEN) {\\n            string memory revertMsg = registryContract.getWithdrawalBridges(token).length == 0\\n                ? \\\"TOKEN_ALREADY_BLOCKED\\\"\\n                : \\\"TOKEN_ALREADY_DEACTIVATED\\\";\\n            revert(revertMsg);\\n        }\\n        emit TokenDeactivated(token, msg.sender);\\n        registryContract.blockToken(token);\\n        if (current_bridge == bridge()) {\\n            IStarkgateBridge(bridge()).deactivate(token);\\n        }\\n    }\\n\\n    /**\\n      Block token from being bridged.\\n      A blocked token cannot be deployed.\\n      Note: Only an unserviced token can be blocked. In order to deactivate a serviced tokens\\n        see 'deactivateToken'.\\n    */\\n    function blockToken(address token) external onlyTokenAdmin {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        address current_bridge = registryContract.getBridge(token);\\n        if (current_bridge == address(0)) {\\n            emit TokenBlocked(token, msg.sender);\\n            registryContract.blockToken(token);\\n        } else if (current_bridge == BLOCKED_TOKEN) {\\n            string memory revertMsg = registryContract.getWithdrawalBridges(token).length == 0\\n                ? \\\"TOKEN_ALREADY_BLOCKED\\\"\\n                : \\\"CANNOT_BLOCK_DEACTIVATED_TOKEN\\\";\\n            revert(revertMsg);\\n        } else {\\n            revert(\\\"CANNOT_BLOCK_TOKEN_IN_SERVICE\\\");\\n        }\\n    }\\n\\n    function enrollTokenBridge(address token) external payable {\\n        IStarkgateRegistry registryContract = IStarkgateRegistry(registry());\\n        require(registryContract.getBridge(token) != BLOCKED_TOKEN, \\\"CANNOT_DEPLOY_BRIDGE\\\");\\n        emit TokenEnrolled(token, msg.sender);\\n        registryContract.enlistToken(token, bridge());\\n        IStarkgateBridge(bridge()).enrollToken{value: msg.value}(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"third_party/open_zeppelin/utils/Strings.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2024 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"}],\"name\":\"ExistingBridgeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TokenBlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TokenDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TokenEnrolled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bridge_\",\"type\":\"address\"}],\"name\":\"addExistingBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"blockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"deactivateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enrollTokenBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAppGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAppRoleAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isGovernanceAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSecurityAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSecurityAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTokenAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isUpgradeGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerAppGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerAppRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerGovernanceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerSecurityAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerSecurityAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"registerUpgradeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAppGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAppRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeGovernanceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeSecurityAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeSecurityAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeUpgradeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StarkgateManager", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}