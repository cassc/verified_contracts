{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"verified-sources/0x4A8826988296843B2132CD4efb21294B01553987/sources/v6/LuckyMeme.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\r\\nimport {IERC20Errors} from \\\"./draft-IERC6093.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the sender.\\r\\n     */\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * The default value of {decimals} is 18. To change this, you should override\\r\\n * this function so it returns a different value.\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC-20\\r\\n * applications.\\r\\n */\\r\\ncontract LuckyMeme is Ownable, IERC20, IERC20Errors {\\r\\n    mapping(address account => uint256) internal _balances;\\r\\n    mapping(address account => mapping(address spender => uint256)) internal _allowances;\\r\\n\\r\\n    uint256 private immutable _decimals;\\r\\n    uint256 public immutable _maxTransaction;    // max of 1% of the total supply per transaction\\r\\n    uint256 public immutable _distributeThreshold;\\r\\n    uint256 public constant _tax = 4;    // 0.4% fee (_tax / _taxDenominator = 4/1000 = 0.004 = 0.4%)\\r\\n    uint256 private constant _taxDenominator = 1000;\\r\\n    uint256 public _distributeCounter = 0;\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    bool public _trading = false;\\r\\n    bool public _presale = true;    // presale tax and everything related\\r\\n    bool public _hardTax = false;    // first month tax\\r\\n    bool public _zeroTax = true;    \\r\\n\\r\\n    string private constant _name = \\\"LuckyMeme\\\";\\r\\n    string private constant _symbol = \\\"LME\\\";\\r\\n\\r\\n    address payable immutable lmeAddress = payable(address(this));\\r\\n    address payable public _annualprizeWallet = payable(0x58c88BC76769B9380F65FA9F8A01dd9F8af81022);\\r\\n    address payable public _monthlyprizeWallet = payable(0x10Eea63dAEDaa2d81e9c29641eF6dCE005164dc1);\\r\\n    address payable public _weeklyprizeWallet = payable(0xb120D280270870E7EF43101250b1b7d5A9F0D8e0);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor() {\\r\\n        _decimals = decimals();\\r\\n        _maxTransaction = 10000000 * 10**_decimals;\\r\\n        _distributeThreshold = 100000 * 10**_decimals;\\r\\n\\r\\n        // Total supply is fixed and equal to the initial supply.\\r\\n        uint256 _initialSupply = 1000000000 * 10**_decimals;\\r\\n        _mint(_msgSender(), _initialSupply);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `value`.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\r\\n        address user = _msgSender();\\r\\n        _zeroTax = true;\\r\\n        _transfer(user, to, value);\\r\\n        _zeroTax = false;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address user, address spender) public view virtual returns (uint256) {\\r\\n        return _allowances[user][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\r\\n        address user = _msgSender();\\r\\n        _approve(user, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\\r\\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `value`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `value`.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _zeroTax = false;\\r\\n        _spendAllowance(from, spender, value);\\r\\n        _transfer(from, to, value);\\r\\n\\r\\n        // Trigger for distributing fees between project addresses.\\r\\n        uint256 tokenBalance = balanceOf(lmeAddress);\\r\\n        if (tokenBalance > _distributeThreshold) {\\r\\n            if (_trading) {\\r\\n                _distributeFee();\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 value) internal {\\r\\n        if (from == address(0)) {\\r\\n            revert ERC20InvalidSender(address(0));\\r\\n        }\\r\\n        if (to == address(0)) {\\r\\n            revert ERC20InvalidReceiver(address(0));\\r\\n        }\\r\\n\\r\\n        require((_trading) || ((from==lmeAddress) && (_presale)) || (to == owner()) || (from == owner()), \\\"Cannot transact now\\\"); \\r\\n\\r\\n        // Penalty imposed on holders who attempt to transact a larger amount than allowed, penalty=1 means there is no \\r\\n        // penalty (fee=0.4%). When the limit is exceeded, the holder suffers a penalty=10 (fee=4%).\\r\\n        uint256 penalty;    \\r\\n\\r\\n        // Situation in which the transaction limit has been exceeded.\\r\\n        if (value > _maxTransaction) {\\r\\n            penalty = 10;\\r\\n        }\\r\\n        // Transaction within the limit. \\r\\n        else {\\r\\n            penalty = 1;    \\r\\n        }\\r\\n\\r\\n        _transferSubroutine(from, to, value, penalty);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subroutine of the fucntion `_transfer`.     \\r\\n     */\\r\\n    function _transferSubroutine(address from, address to, uint256 value, uint256 penalty) internal {\\r\\n        // If it is not one of the project addresses, penalty or fees are applied.\\r\\n        if (from != owner() && from != _annualprizeWallet && from != _monthlyprizeWallet && from != _weeklyprizeWallet && from != lmeAddress) {\\r\\n            if (to != owner() && to != _annualprizeWallet && to != _monthlyprizeWallet && to != _weeklyprizeWallet && to != lmeAddress) {\\r\\n                uint256 taxedValue;    // value after fees                \\r\\n                taxedValue = _applyFee(from, value, penalty);\\r\\n                _update(from, to, taxedValue);\\r\\n            }\\r\\n            // Transaction to a project address. In this case, no penalties and no fees apply.\\r\\n            else {\\r\\n                _update(from, to, value);\\r\\n            }\\r\\n        }\\r\\n        // Transaction from a project address. In this case, no penalties and no fees apply.\\r\\n        else {\\r\\n            _update(from, to, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The contract retains a portion of the 'from' transaction amount (`value`) as a fee (`tax`).     \\r\\n     */\\r\\n    function _applyFee(address from, uint256 value, uint256 penalty) internal virtual returns(uint256) {\\r\\n        uint256 tax;\\r\\n\\r\\n        // Type of tax.\\r\\n        if ((_zeroTax)||(_presale)) {\\r\\n            tax = 0;\\r\\n        }\\r\\n        else if (_hardTax) {\\r\\n            tax = 10 * penalty * (_tax * value) / _taxDenominator;\\r\\n        }\\r\\n        else {\\r\\n            tax = penalty * (_tax * value) / _taxDenominator; \\r\\n        }\\r\\n\\r\\n        // Value of the transaction after tax.\\r\\n        uint256 taxedValue;\\r\\n        taxedValue = value - tax;\\r\\n\\r\\n        // Sender token balance.\\r\\n        uint256 fromBalance = _balances[from];\\r\\n\\r\\n        if (fromBalance < tax) {\\r\\n            revert ERC20InsufficientBalance(from, fromBalance, tax);\\r\\n        }\\r\\n        unchecked {\\r\\n            // Overflow not possible: tax < value <= fromBalance.\\r\\n            _balances[from] = fromBalance - tax;\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + tax is at most totalSupply, which we know fits into a uint256.\\r\\n            _balances[lmeAddress] += tax;\\r\\n        }        \\r\\n\\r\\n        if (tax > 0) {\\r\\n            emit Transfer(from, lmeAddress, tax);\\r\\n        }\\r\\n\\r\\n        return taxedValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\r\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\r\\n     * this function.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _update(address from, address to, uint256 value) internal virtual {\\r\\n        if (from == address(0)) {\\r\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\r\\n            _totalSupply = value;\\r\\n        } \\r\\n        else {\\r\\n            uint256 fromBalance = _balances[from];\\r\\n            if (fromBalance < value) {\\r\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\r\\n            }\\r\\n            unchecked {\\r\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\r\\n                _balances[from] = fromBalance - value;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // The project does not have burns, but someone might want to send their tokens to the null address anyway. \\r\\n        // In this case the total supply is reduced.\\r\\n        if (to == address(0)) {\\r\\n            unchecked {\\r\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\r\\n                _totalSupply -= value;\\r\\n            }\\r\\n        } \\r\\n        else {\\r\\n            unchecked {\\r\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\r\\n                _balances[to] += value;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Distributes the fees between the parties: annual prize wallet, monthly prize wallet, weekly prize wallet \\r\\n     * and project. This function is called every time the contract's token balance exceeds 100,000 LME. With each \\r\\n     * call, the proportional part is sent to only one of the wallets. Once it reaches 100,000 LME again, the \\r\\n     * proportional transfer is made to the next wallet, and so on.     \\r\\n     */\\r\\n    function _distributeFee() internal virtual returns(bool) {\\r\\n        uint256 _prizesWalletPercentage = 275;    // 0.11% is equivalent to 27.5% of 0.4% \\r\\n        uint256 _projectWalletPercentage = 175;    // 0.07% is equivalent to 17.5% of 0.4% \\r\\n        uint256 value = balanceOf(lmeAddress);    \\r\\n        uint256 proportionalValue;\\r\\n        address from = lmeAddress;\\r\\n        address payable to;\\r\\n\\r\\n        if (_distributeCounter == 0) {\\r\\n            proportionalValue = (value * _prizesWalletPercentage) / _taxDenominator;\\r\\n            to = _annualprizeWallet;\\r\\n        }\\r\\n        else if (_distributeCounter == 1) {\\r\\n            proportionalValue = (value * _prizesWalletPercentage) / _taxDenominator;\\r\\n            to = _monthlyprizeWallet;\\r\\n        }\\r\\n        else if (_distributeCounter == 2) {\\r\\n            proportionalValue = (value * _prizesWalletPercentage) / _taxDenominator;\\r\\n            to = _weeklyprizeWallet;\\r\\n        }\\r\\n        else {\\r\\n            proportionalValue = (value * _projectWalletPercentage) / _taxDenominator;\\r\\n            to = payable(owner());\\r\\n        }\\r\\n\\r\\n        // Update counter.\\r\\n        _distributeCounter += 1;\\r\\n        if (_distributeCounter >= 4) {\\r\\n            _distributeCounter = 0;\\r\\n        }\\r\\n\\r\\n        // Transfer tokens to chosen wallet.\\r\\n        _transfer(from, to, proportionalValue);\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\r\\n     * Relies on the `_update` mechanism\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\r\\n     */\\r\\n    function _mint(address account, uint256 value) internal {\\r\\n        if (account == address(0)) {\\r\\n            revert ERC20InvalidReceiver(address(0));\\r\\n        }\\r\\n        _update(address(0), account, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\r\\n     *\\r\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\r\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\r\\n     * `Approval` event during `transferFrom` operations.\\r\\n     *\\r\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\r\\n     * true using the following override:\\r\\n     *\\r\\n     * ```solidity\\r\\n     * function _approve(address user, address spender, uint256 value, bool) internal virtual override {\\r\\n     *     super._approve(user, spender, value, true);\\r\\n     * }\\r\\n     * ```\\r\\n     *\\r\\n     * Requirements are the same as {_approve}.\\r\\n     */\\r\\n    function _approve(address user, address spender, uint256 value) internal virtual {\\r\\n        if (user == address(0)) {\\r\\n            revert ERC20InvalidApprover(address(0));\\r\\n        }\\r\\n        if (spender == address(0)) {\\r\\n            revert ERC20InvalidSpender(address(0));\\r\\n        }\\r\\n        _allowances[user][spender] = value;\\r\\n        emit Approval(user, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `user` s allowance for `spender` based on spent `value`.\\r\\n     *\\r\\n     * Does not update the allowance value in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Does not emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(address user, address spender, uint256 value) internal virtual {\\r\\n        uint256 currentAllowance = allowance(user, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            if (currentAllowance < value) {\\r\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\r\\n            }\\r\\n            unchecked {\\r\\n                _approve(user, spender, currentAllowance - value);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the address of a prize wallet. If any prize wallet is compromised, this function must \\r\\n     * be called to update its address.\\r\\n     */\\r\\n    function changePrizeWallet(uint256 i, address prizeWallet) public virtual onlyOwner {\\r\\n        if (i == 0) {\\r\\n            _annualprizeWallet = payable(prizeWallet);\\r\\n        }\\r\\n        else if (i == 1) {\\r\\n            _monthlyprizeWallet = payable(prizeWallet);\\r\\n        }\\r\\n        else if (i == 2) {\\r\\n            _weeklyprizeWallet = payable(prizeWallet);\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the variable `_trading` state to true, and from then on the token can be traded freely. Note \\r\\n     * that after this there is no turning back, this variable will always be true.\\r\\n     */\\r\\n    function openTrading() public virtual onlyOwner {\\r\\n        _trading = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes _hardTax to false. There is no turning back after that.\\r\\n     */\\r\\n    function hardTaxOver() public virtual onlyOwner {\\r\\n        _hardTax = false;    \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Forces the tax to be zero if needed.\\r\\n     */\\r\\n    function zeroTax() public virtual onlyOwner {\\r\\n        if (_zeroTax) {\\r\\n            _zeroTax = false;    \\r\\n        }\\r\\n        else {\\r\\n            _zeroTax = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev Send ethers to the project's wallet. We don't expect to use this function, but it can be useful.\\r\\n     */\\r\\n    function withdraw(uint256 ethAmount) external onlyOwner {\\r\\n        payable(owner()).transfer(ethAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Receive function.\\r\\n     */\\r\\n    receive() external payable virtual {\\r\\n        address user = msg.sender;\\r\\n        uint256 ethAmount = msg.value;\\r\\n\\r\\n        if ((_presale) && (user!=owner())) {\\r\\n            _swapETHforToken(user, ethAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /***** From now on everything is about the presale. *****/\\r\\n\\r\\n    uint256 public totalPurchases = 0;\\r\\n    uint256 public presalePrice = 2000000000000 wei;    // price of 1 LME in wei (1 LME = 0.000002 ETH)\\r\\n\\r\\n    bool internal locked;    // lock state when executing\\t\\r\\n\\r\\n    modifier noReentrancy() {\\r\\n        require(!locked, \\\"No reentrancy allowed\\\");\\r\\n        locked = true;\\r\\n        _;\\r\\n        locked = false;\\r\\n    }\\r\\n\\r\\n    // When the user send ETH to this contract, it needs to allow the user to be the spender of the transfer.\\r\\n    // This allowance can't be done with the `approve` function since the sender is never the spender. Only \\r\\n    // for the presale we will allow this behavior.\\r\\n    function _presaleApprove(address user, uint256 value) private returns (bool) {\\r\\n        if ((_presale) || (user==owner())) {\\r\\n            _approve(lmeAddress, user, value);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // User is giving ETH to receive tokens\\r\\n    function _swapETHforToken(address user, uint256 ethAmount) private noReentrancy { \\r\\n        require(_presale, \\\"Presale is over\\\");\\r\\n\\r\\n        // Verify min and max limits.\\r\\n        require(ethAmount >= 5000000000000000 wei, \\\"ETH amount must be greater than 0.005 ETH\\\");\\r\\n        require(ethAmount <= 1000000000000000000 wei, \\\"ETH amount must be less than 1 ETH\\\");\\r\\n\\r\\n        // Calculates the amount of tokens the user will receive.\\r\\n        uint256 tokenAmount = (ethAmount / presalePrice) * 10**_decimals;\\r\\n\\r\\n        // Verify if the amount of token in the contract is enough to continue the transaction.   \\r\\n        require(balanceOf(lmeAddress) >= tokenAmount, \\\"Insufficient token balance to complete the transaction\\\");  \\r\\n        payable(owner()).transfer(ethAmount);\\r\\n\\r\\n        // Transfer tokens to the user.\\r\\n\\t\\tbool status;\\r\\n        require(_presaleApprove(user, tokenAmount), \\\"Allowance not approved\\\");\\r\\n        status = transferFrom(lmeAddress, user, tokenAmount);\\r\\n\\t\\t\\r\\n\\t\\t// Updates.\\r\\n        if (status) {\\r\\n\\t\\t    totalPurchases += tokenAmount;\\r\\n        }\\r\\n        // Just to make sure there are no loose ends.\\r\\n        _presaleApprove(user, 0);\\r\\n    } \\r\\n\\r\\n    // Activate this function to finish the presale. There is no turning back after that.\\r\\n    function presaleOver() public onlyOwner {\\r\\n        _presale = false;    \\r\\n        _hardTax = true;    \\r\\n    }\\r\\n\\r\\n    // Send the LME tokens to the project's wallet.\\r\\n    function withdrawTokens(uint256 tokenAmount) external onlyOwner {\\r\\n\\t\\tbool status;\\r\\n        require(_presaleApprove(owner(), tokenAmount), \\\"Allowance not approved\\\");\\r\\n        status = transferFrom(lmeAddress, owner(), tokenAmount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"verified-sources/0x4A8826988296843B2132CD4efb21294B01553987/sources/v6/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.18;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"verified-sources/0x4A8826988296843B2132CD4efb21294B01553987/sources/v6/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.18;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_annualprizeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_distributeCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_distributeThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_hardTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_monthlyprizeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_presale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_trading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_weeklyprizeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_zeroTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"prizeWallet\",\"type\":\"address\"}],\"name\":\"changePrizeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardTaxOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LuckyMeme", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}