{"SourceCode": "// File: .deps/MultiAuction 6/libs/SafeTransferLib.sol\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n///\r\n/// @dev Note:\r\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\r\n/// - For ERC20s, this implementation won't check that a token has code,\r\n/// responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ETH transfer has failed.\r\n    error ETHTransferFailed();\r\n\r\n    /// @dev The ERC20 `transferFrom` has failed.\r\n    error TransferFromFailed();\r\n\r\n    /// @dev The ERC20 `transfer` has failed.\r\n    error TransferFailed();\r\n\r\n    /// @dev The ERC20 `approve` has failed.\r\n    error ApproveFailed();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH\r\n    /// that disallows any storage writes.\r\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\r\n    /// storage reads and writes, but low enough to prevent griefing.\r\n    /// Multiply by a small constant (e.g. 2), if needed.\r\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ETH OPERATIONS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// Note: This implementation does NOT protect against gas griefing.\r\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and check if it succeeded or not.\r\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\r\n                // Store the function selector of `ETHTransferFailed()`.\r\n                mstore(0x00, 0xb12d13eb)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    /// The `gasStipend` can be set to a low enough value to prevent\r\n    /// storage writes or gas griefing.\r\n    ///\r\n    /// If sending via the normal procedure fails, force sends the ETH by\r\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\r\n    ///\r\n    /// Reverts if the current contract has insufficient balance.\r\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If insufficient balance, revert.\r\n            if lt(selfbalance(), amount) {\r\n                // Store the function selector of `ETHTransferFailed()`.\r\n                mstore(0x00, 0xb12d13eb)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Transfer the ETH and check if it succeeded or not.\r\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                // We can directly use `SELFDESTRUCT` in the contract creation.\r\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\r\n                if iszero(create(amount, 0x0b, 0x16)) {\r\n                    // To coerce gas estimation to provide enough gas for the `create` above.\r\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\r\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\r\n    /// for 99% of cases and can be overridden with the three-argument version of this\r\n    /// function if necessary.\r\n    ///\r\n    /// If sending via the normal procedure fails, force sends the ETH by\r\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\r\n    ///\r\n    /// Reverts if the current contract has insufficient balance.\r\n    function forceSafeTransferETH(address to, uint256 amount) internal {\r\n        // Manually inlined because the compiler doesn't inline functions with branches.\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If insufficient balance, revert.\r\n            if lt(selfbalance(), amount) {\r\n                // Store the function selector of `ETHTransferFailed()`.\r\n                mstore(0x00, 0xb12d13eb)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Transfer the ETH and check if it succeeded or not.\r\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                // We can directly use `SELFDESTRUCT` in the contract creation.\r\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\r\n                if iszero(create(amount, 0x0b, 0x16)) {\r\n                    // To coerce gas estimation to provide enough gas for the `create` above.\r\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    /// The `gasStipend` can be set to a low enough value to prevent\r\n    /// storage writes or gas griefing.\r\n    ///\r\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\r\n    ///\r\n    /// Note: Does NOT revert upon failure.\r\n    /// Returns whether the transfer of ETH is successful instead.\r\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and check if it succeeded or not.\r\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      ERC20 OPERATIONS                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have at least `amount` approved for\r\n    /// the current contract to manage.\r\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n\r\n            mstore(0x60, amount) // Store the `amount` argument.\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            // Store the function selector of `transferFrom(address,address,uint256)`.\r\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\r\n\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFromFailed()`.\r\n                mstore(0x00, 0x7939f424)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have their entire balance approved for\r\n    /// the current contract to manage.\r\n    function safeTransferAllFrom(address token, address from, address to)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            // Store the function selector of `balanceOf(address)`.\r\n            mstore(0x0c, 0x70a08231000000000000000000000000)\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFromFailed()`.\r\n                mstore(0x00, 0x7939f424)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Store the function selector of `transferFrom(address,address,uint256)`.\r\n            mstore(0x00, 0x23b872dd)\r\n            // The `amount` argument is already written to the memory word at 0x60.\r\n            amount := mload(0x60)\r\n\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFromFailed()`.\r\n                mstore(0x00, 0x7939f424)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            // Store the function selector of `transfer(address,uint256)`.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\r\n\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFailed()`.\r\n                mstore(0x00, 0x90b8ec18)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Restore the part of the free memory pointer that was overwritten.\r\n            mstore(0x34, 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\r\n            mstore(0x20, address()) // Store the address of the current contract.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFailed()`.\r\n                mstore(0x00, 0x90b8ec18)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            // The `amount` argument is already written to the memory word at 0x34.\r\n            amount := mload(0x34)\r\n            // Store the function selector of `transfer(address,uint256)`.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\r\n\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `TransferFailed()`.\r\n                mstore(0x00, 0x90b8ec18)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Restore the part of the free memory pointer that was overwritten.\r\n            mstore(0x34, 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// Reverts upon failure.\r\n    function safeApprove(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            // Store the function selector of `approve(address,uint256)`.\r\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\r\n\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    // Set success to whether the call reverted, if not we check it either\r\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                // Store the function selector of `ApproveFailed()`.\r\n                mstore(0x00, 0x3e3f8f73)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Restore the part of the free memory pointer that was overwritten.\r\n            mstore(0x34, 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\r\n    /// Returns zero if the `token` does not exist.\r\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, account) // Store the `account` argument.\r\n            // Store the function selector of `balanceOf(address)`.\r\n            mstore(0x00, 0x70a08231000000000000000000000000)\r\n            amount :=\r\n                mul(\r\n                    mload(0x20),\r\n                    and( // The arguments of `and` are evaluated from right to left.\r\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\r\n                    )\r\n                )\r\n        }\r\n    }\r\n}\r\n// File: .deps/MultiAuction 6/libs/MerkleProofLib.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Gas optimized merkle proof verification library.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\r\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\r\nlibrary MerkleProofLib {\r\n    function verify(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool isValid) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if proof.length {\r\n                // Left shifting by 5 is like multiplying by 32.\r\n                let end := add(proof.offset, shl(5, proof.length))\r\n\r\n                // Initialize offset to the offset of the proof in calldata.\r\n                let offset := proof.offset\r\n\r\n                // Iterate over proof elements to compute root hash.\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    // Slot where the leaf should be put in scratch space. If\r\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\r\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\r\n\r\n                    // Store elements to hash contiguously in scratch space.\r\n                    // The xor puts calldataload(offset) in whichever slot leaf\r\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\r\n                    mstore(leafSlot, leaf)\r\n                    mstore(xor(leafSlot, 32), calldataload(offset))\r\n\r\n                    // Reuse leaf to store the hash to reduce stack operations.\r\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\r\n\r\n                    offset := add(offset, 32) // Shift 1 word per cycle.\r\n\r\n                    // prettier-ignore\r\n                    if iszero(lt(offset, end)) { break }\r\n                }\r\n            }\r\n\r\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\r\n        }\r\n    }\r\n}\r\n// File: .deps/MultiAuction 6/interfaces/IDelegationRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @title An immutable registry contract to be deployed as a standalone primitive\r\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\r\n * from here and integrate those permissions into their flow\r\n */\r\ninterface IDelegationRegistry {\r\n    /// @notice Delegation type\r\n    enum DelegationType {\r\n        NONE,\r\n        ALL,\r\n        CONTRACT,\r\n        TOKEN\r\n    }\r\n\r\n    /// @notice Info about a single delegation, used for onchain enumeration\r\n    struct DelegationInfo {\r\n        DelegationType type_;\r\n        address vault;\r\n        address delegate;\r\n        address contract_;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    /// @notice Info about a single contract-level delegation\r\n    struct ContractDelegation {\r\n        address contract_;\r\n        address delegate;\r\n    }\r\n\r\n    /// @notice Info about a single token-level delegation\r\n    struct TokenDelegation {\r\n        address contract_;\r\n        uint256 tokenId;\r\n        address delegate;\r\n    }\r\n\r\n    /// @notice Emitted when a user delegates their entire wallet\r\n    event DelegateForAll(address vault, address delegate, bool value);\r\n\r\n    /// @notice Emitted when a user delegates a specific contract\r\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\r\n\r\n    /// @notice Emitted when a user delegates a specific token\r\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\r\n\r\n    /// @notice Emitted when a user revokes all delegations\r\n    event RevokeAllDelegates(address vault);\r\n\r\n    /// @notice Emitted when a user revoes all delegations for a given delegate\r\n    event RevokeDelegate(address vault, address delegate);\r\n\r\n    /**\r\n     * -----------  WRITE -----------\r\n     */\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for all contracts\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForAll(address delegate, bool value) external;\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for a specific contract\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForContract(address delegate, address contract_, bool value) external;\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for a specific token\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\r\n\r\n    /**\r\n     * @notice Revoke all delegates\r\n     */\r\n    function revokeAllDelegates() external;\r\n\r\n    /**\r\n     * @notice Revoke a specific delegate for all their permissions\r\n     * @param delegate The hotwallet to revoke\r\n     */\r\n    function revokeDelegate(address delegate) external;\r\n\r\n    /**\r\n     * @notice Remove yourself as a delegate for a specific vault\r\n     * @param vault The vault which delegated to the msg.sender, and should be removed\r\n     */\r\n    function revokeSelf(address vault) external;\r\n\r\n    /**\r\n     * -----------  READ -----------\r\n     */\r\n\r\n    /**\r\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\r\n     * @param delegate The delegate that you would like to retrieve delegations for\r\n     * @return info Array of DelegationInfo structs\r\n     */\r\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of wallet-level delegates for a given vault\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @return addresses Array of wallet-level delegates for a given vault\r\n     */\r\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of contract-level delegates for a given vault and contract\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @return addresses Array of contract-level delegates for a given vault and contract\r\n     */\r\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of contract-level delegates for a given vault's token\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @param contract_ The address for the contract holding the token\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @return addresses Array of contract-level delegates for a given vault's token\r\n     */\r\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns all contract-level delegations for a given vault\r\n     * @param vault The cold wallet who issued the delegations\r\n     * @return delegations Array of ContractDelegation structs\r\n     */\r\n    function getContractLevelDelegations(address vault)\r\n        external\r\n        view\r\n        returns (ContractDelegation[] memory delegations);\r\n\r\n    /**\r\n     * @notice Returns all token-level delegations for a given vault\r\n     * @param vault The cold wallet who issued the delegations\r\n     * @return delegations Array of TokenDelegation structs\r\n     */\r\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on the entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForContract(address delegate, address vault, address contract_)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n// File: .deps/MultiAuction 6/MultiAuction.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\n\r\ncontract MultiAuction {\r\n  uint256 private constant BPS = 10_000;\r\n  address private constant DELEGATION_REGISTRY = 0x00000000000076A84feF008CDAbe6409d2FE638B;\r\n  address private constant FPP = 0xA8A425864dB32fCBB459Bf527BdBb8128e6abF21;\r\n  uint256 private constant FPP_PROJECT_ID = 3;\r\n  uint256 private constant MIN_BID = 0.01 ether;\r\n  uint256 private constant MIN_BID_INCREASE = 1_000;\r\n  uint256 private constant MINT_PASS_REBATE = 1_500;\r\n  uint256 private constant SAFE_GAS_LIMIT = 30_000;\r\n  IBaseContract public immutable BASE_CONTRACT;\r\n  uint256 public immutable MAX_SUPPLY;\r\n\r\n\r\n  uint256 public auctionStartTime;\r\n  address public beneficiary1;\r\n  address public beneficiary2;\r\n  bool public paused;\r\n  bytes32 public settlementRoot;\r\n\r\n  struct Auction {\r\n    uint24 offsetFromEnd;\r\n    uint72 amount;\r\n    address bidder;\r\n  }\r\n\r\n  mapping(uint256 => Auction) public tokenIdToAuction;\r\n\r\n  event BidMade(uint256 indexed tokenId, address bidder, uint256 amount, uint256 timestamp);\r\n  event Settled(uint256 indexed tokenId, uint256 timestamp);\r\n\r\n  constructor(\r\n    address baseContract,\r\n    uint256 startTime,\r\n    uint256 maxSupply\r\n  ) {\r\n    BASE_CONTRACT = IBaseContract(baseContract);\r\n    auctionStartTime = startTime;\r\n    MAX_SUPPLY = maxSupply;\r\n    beneficiary1 = msg.sender;\r\n    beneficiary2 = msg.sender;\r\n  }\r\n\r\n  function bid(\r\n    uint256 tokenId\r\n  ) external payable {\r\n    require(!paused, 'Bidding is paused');\r\n    require(isAuctionActive(tokenId), 'Auction Inactive');\r\n    require(0 < tokenId && tokenId <= MAX_SUPPLY, 'Invalid tokenId');\r\n\r\n    Auction memory highestBid = tokenIdToAuction[tokenId];\r\n\r\n    require(\r\n      msg.value >= (highestBid.amount * (BPS + MIN_BID_INCREASE) / BPS)\r\n      && msg.value >= MIN_BID,\r\n      'Bid not high enough'\r\n    );\r\n\r\n    uint256 refundAmount;\r\n    address refundBidder;\r\n    uint256 offset = highestBid.offsetFromEnd;\r\n    uint256 endTime = auctionEndTime(tokenId);\r\n\r\n    if (highestBid.amount > 0) {\r\n      refundAmount = highestBid.amount;\r\n      refundBidder = highestBid.bidder;\r\n    }\r\n\r\n    if (endTime - block.timestamp < 15 minutes) {\r\n      offset += block.timestamp + 15 minutes - endTime;\r\n    }\r\n\r\n    tokenIdToAuction[tokenId] = Auction(uint24(offset), uint72(msg.value), msg.sender);\r\n\r\n    emit BidMade(tokenId, msg.sender, msg.value, block.timestamp);\r\n\r\n    if (refundAmount > 0) {\r\n      SafeTransferLib.forceSafeTransferETH(refundBidder, refundAmount, SAFE_GAS_LIMIT);\r\n    }\r\n  }\r\n\r\n  function bidOnFavs(\r\n    uint256[] calldata favorites,\r\n    uint256[] calldata expectedPrices\r\n  ) external payable {\r\n    require(!paused, 'Bidding is paused');\r\n    require(favorites.length == expectedPrices.length);\r\n\r\n    uint256 totalFailed; uint256 expectedTotal;\r\n    for(uint256 i; i < favorites.length; ++i) {\r\n      uint256 tokenId = favorites[i];\r\n      uint256 expectedPrice = expectedPrices[i];\r\n      expectedTotal += expectedPrice;\r\n      require(0 < tokenId && tokenId <= MAX_SUPPLY, 'Invalid tokenId');\r\n      if(!isAuctionActive(tokenId)) {\r\n        totalFailed += expectedPrice;\r\n        break;\r\n      }\r\n\r\n      Auction memory highestBid = tokenIdToAuction[tokenId];\r\n      if (\r\n        expectedPrice >= (highestBid.amount * (BPS + MIN_BID_INCREASE) / BPS)\r\n        && expectedPrice >= MIN_BID\r\n      ) {\r\n        uint256 refundAmount;\r\n        address refundBidder;\r\n        uint256 offset = highestBid.offsetFromEnd;\r\n        uint256 endTime = auctionEndTime(tokenId);\r\n\r\n        if (highestBid.amount > 0) {\r\n          refundAmount = highestBid.amount;\r\n          refundBidder = highestBid.bidder;\r\n        }\r\n\r\n        if (endTime - block.timestamp < 15 minutes) {\r\n          offset += block.timestamp + 15 minutes - endTime;\r\n        }\r\n\r\n        tokenIdToAuction[tokenId] = Auction(uint24(offset), uint72(expectedPrice), msg.sender);\r\n\r\n        emit BidMade(tokenId, msg.sender, expectedPrice, block.timestamp);\r\n\r\n        if (refundAmount > 0) {\r\n          SafeTransferLib.forceSafeTransferETH(refundBidder, refundAmount, SAFE_GAS_LIMIT);\r\n        }\r\n      } else{\r\n        totalFailed += expectedPrice;\r\n      }\r\n    }\r\n\r\n    require(msg.value >= expectedTotal);\r\n    if (totalFailed > 0) {\r\n      SafeTransferLib.forceSafeTransferETH(msg.sender, totalFailed, SAFE_GAS_LIMIT);\r\n    }\r\n  }\r\n\r\n  function settleAuction(\r\n    uint256 tokenId,\r\n    uint256 mintPassId,\r\n    bytes32[] calldata proof\r\n  ) external payable {\r\n    require(settlementRoot != bytes32(0));\r\n    Auction memory highestBid = tokenIdToAuction[tokenId];\r\n    require(highestBid.bidder == msg.sender || owner() == msg.sender);\r\n    require(0 < tokenId && tokenId <= MAX_SUPPLY, 'Invalid tokenId');\r\n    require(isAuctionOver(tokenId), 'Auction for this tokenId is still active');\r\n\r\n    uint256 amountToPay = highestBid.amount;\r\n    if (amountToPay > 0) {\r\n      BASE_CONTRACT.mint(highestBid.bidder, tokenId);\r\n    } else {\r\n      require(msg.sender == owner(), 'Ownable: caller is not the owner');\r\n      require(msg.value >= MIN_BID, 'Bid not high enough');\r\n      amountToPay = msg.value;\r\n\r\n      BASE_CONTRACT.mint(msg.sender, tokenId);\r\n    }\r\n\r\n    uint256 totalRebate = 0;\r\n    bool mintPassValid;\r\n    if (mintPassId < 1_000) {\r\n      address passHolder = IFPP(FPP).ownerOf(mintPassId);\r\n      mintPassValid = mintPassId < 1_000 && IFPP(FPP).passUses(mintPassId, FPP_PROJECT_ID) < 1 && (\r\n        passHolder == highestBid.bidder ||\r\n        IDelegationRegistry(DELEGATION_REGISTRY).checkDelegateForToken(\r\n          highestBid.bidder,\r\n          passHolder,\r\n          FPP,\r\n          mintPassId\r\n        )\r\n      ) && (\r\n        MerkleProofLib.verify(proof, settlementRoot, keccak256(abi.encodePacked(passHolder, mintPassId)))\r\n      );\r\n    }\r\n\r\n    if (mintPassValid) {\r\n      IFPP(FPP).logPassUse(mintPassId, FPP_PROJECT_ID);\r\n      totalRebate = amountToPay * (MINT_PASS_REBATE) / BPS;\r\n    }\r\n\r\n    tokenIdToAuction[tokenId].bidder = address(0);\r\n    emit Settled(tokenId, block.timestamp);\r\n\r\n    if (totalRebate > 0) {\r\n      SafeTransferLib.forceSafeTransferETH(highestBid.bidder, totalRebate, SAFE_GAS_LIMIT);\r\n      SafeTransferLib.forceSafeTransferETH(beneficiary2, amountToPay - totalRebate, SAFE_GAS_LIMIT);\r\n    } else {\r\n      SafeTransferLib.forceSafeTransferETH(beneficiary1, amountToPay, SAFE_GAS_LIMIT);\r\n    }\r\n  }\r\n\r\n  function settleAll(\r\n    uint256 startId,\r\n    uint256 endId,\r\n    bytes calldata passData\r\n  ) external payable onlyOwner {\r\n    require(settlementRoot == bytes32(0), 'settleAll not active');\r\n    require(passData.length == 2 * (endId - startId + 1), 'Invalid passData length');\r\n    require(0 < startId && endId <= MAX_SUPPLY, 'Invalid tokenId');\r\n\r\n    uint256 unclaimedCost; uint256 amountForBene1; uint256 amountForBene2;\r\n    for (uint256 tokenId = startId; tokenId <= endId; ++tokenId) {\r\n      Auction memory highestBid = tokenIdToAuction[tokenId];\r\n      require(isAuctionOver(tokenId), 'Auction for this tokenId is still active');\r\n\r\n      uint256 amountToPay = highestBid.amount;\r\n      if (amountToPay > 0) {\r\n        BASE_CONTRACT.mint(highestBid.bidder, tokenId);\r\n      } else {\r\n        amountToPay = MIN_BID;\r\n        unclaimedCost += MIN_BID;\r\n        BASE_CONTRACT.mint(msg.sender, tokenId);\r\n      }\r\n\r\n      uint256 totalRebate = 0;\r\n      uint256 mintPassId = uint16(bytes2(passData[(tokenId - 1) * 2: tokenId * 2]));\r\n      bool mintPassValid;\r\n      if (mintPassId < 1_000) {\r\n        address passHolder = IFPP(FPP).ownerOf(mintPassId);\r\n        mintPassValid = mintPassId < 1_000 && IFPP(FPP).passUses(mintPassId, FPP_PROJECT_ID) < 1 && (\r\n          passHolder == highestBid.bidder ||\r\n          IDelegationRegistry(DELEGATION_REGISTRY).checkDelegateForToken(\r\n            highestBid.bidder,\r\n            passHolder,\r\n            FPP,\r\n            mintPassId\r\n          )\r\n        );\r\n      }\r\n  \r\n      if (mintPassValid) {\r\n        IFPP(FPP).logPassUse(mintPassId, FPP_PROJECT_ID);\r\n        totalRebate = amountToPay * (MINT_PASS_REBATE) / BPS;\r\n      }\r\n  \r\n      tokenIdToAuction[tokenId].bidder = address(0);\r\n      emit Settled(tokenId, block.timestamp);\r\n  \r\n      if (totalRebate > 0) {\r\n        SafeTransferLib.forceSafeTransferETH(highestBid.bidder, totalRebate, SAFE_GAS_LIMIT);\r\n        amountForBene2 += amountToPay - totalRebate;\r\n      } else {\r\n        amountForBene1 += amountToPay;\r\n      }\r\n    }\r\n\r\n    require(msg.value >= unclaimedCost, \"Insufficient funds sent for unclaimed\");\r\n    SafeTransferLib.forceSafeTransferETH(beneficiary1, amountForBene1, SAFE_GAS_LIMIT);\r\n    SafeTransferLib.forceSafeTransferETH(beneficiary2, amountForBene2, SAFE_GAS_LIMIT);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return BASE_CONTRACT.owner();\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  function emergencyWithdraw() external onlyOwner {\r\n    require(block.timestamp > auctionStartTime + 48 hours);\r\n    (bool success,) = msg.sender.call{value: address(this).balance}(\"\");\r\n    require(success);\r\n  }\r\n\r\n  function enableSelfSettlement(\r\n    bytes32 root\r\n  ) external onlyOwner {\r\n    settlementRoot = root;\r\n  }\r\n\r\n  function rescheduele(\r\n    uint256 newStartTime\r\n  ) external onlyOwner {\r\n    require(auctionStartTime > block.timestamp);\r\n    auctionStartTime = newStartTime;\r\n  }\r\n\r\n  function setBeneficiary(\r\n    address _beneficiary1,\r\n    address _beneficiary2\r\n  ) external onlyOwner {\r\n    beneficiary1 = _beneficiary1;\r\n    beneficiary2 = _beneficiary2;\r\n  }\r\n\r\n  function setPaused(\r\n    bool _paused\r\n  ) external onlyOwner {\r\n    paused = _paused;\r\n  }\r\n\r\n  function auctionEndTime(\r\n    uint256 tokenId\r\n  ) public view returns (uint256) {\r\n    return auctionStartTime + 24 hours + tokenIdToAuction[tokenId].offsetFromEnd;\r\n  }\r\n\r\n  function isAuctionActive(\r\n    uint256 tokenId\r\n  ) public view returns (bool) {\r\n    uint256 endTime = auctionEndTime(tokenId);\r\n    return (block.timestamp >= auctionStartTime && block.timestamp < endTime);\r\n  }\r\n\r\n  function isAuctionOver(\r\n    uint256 tokenId\r\n  ) public view returns (bool) {\r\n    uint256 endTime = auctionEndTime(tokenId);\r\n    return (block.timestamp >= endTime);\r\n  }\r\n}\r\n\r\ninterface IFPP {\r\n  function logPassUse(uint256 tokenId, uint256 projectId) external;\r\n  function ownerOf(uint256 tokenId) external returns (address);\r\n  function passUses(uint256 tokenId, uint256 projectId) external returns (uint256);\r\n}\r\n\r\ninterface IBaseContract {\r\n  function mint(address to, uint256 tokenId) external;\r\n  function owner() external view returns (address);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IBaseContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"auctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"favorites\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"expectedPrices\",\"type\":\"uint256[]\"}],\"name\":\"bidOnFavs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"enableSelfSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isAuctionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isAuctionOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartTime\",\"type\":\"uint256\"}],\"name\":\"rescheduele\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary2\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"passData\",\"type\":\"bytes\"}],\"name\":\"settleAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPassId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToAuction\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"offsetFromEnd\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiAuction", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f4b84cbeeda78c960eda07da4ae8828594ea51530000000000000000000000000000000000000000000000000000000064ac1cf00000000000000000000000000000000000000000000000000000000000000050", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://821e31f2c4946f230994a41cc7aad62a1094d21b7f9e76818f016327f9290333"}