{"SourceCode": "//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28e4\u28f6\u28fe\u28ff\u28f7\u28fe\u28ff\u28ff\u28ff\u28ff\u28f6\u28fe\u28ff\u28ff\u28f6\u28e6\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u281b\u2809\u2889\u287d\u288b\u28d9\u28e7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28e6\u28c0\u2800\u2880\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28db\u28db\u28d3\u28d2\u2836\u28a4\u28fe\u2800\u2800\u2838\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2833\u28ff\u28f7\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u2844\u2800\u2800\u28b3\u28e6\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u2844\u2800\u2819\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u283f\u28ff\u2866\u2800\u2800\u283b\u283f\u28e6\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28f7\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28bf\u284f\u2800\u281c\u2874\u2801\u2800\u2800\u2800\u2840\u2800\u2800\u2809\u2809\u2832\u28a6\u2840\u2800\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28f7\u287e\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2800\u2800\u28f8\u2800\u2800\u2800\u28a7\u2800\u2800\u2800\u2800\u2839\u2812\u28a4\u28c0\u2800\u2800\u2801\u2808\u28a2\u2800\r\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28ff\u28df\u2800\u2800\u2808\u283b\u28ff\u280f\u28a8\u2814\u28a6\u2808\u28bb\u28ff\u287c\u280b\u2880\u28e4\u28f6\u28f6\u28ff\u28ff\u28ff\u28c4\u28a0\u28c0\u285c\u2806\u2800\u2880\u2860\u2834\u2812\u2802\u2808\u28bb\u28a6\u2840\u2800\u2808\u2847\r\n//\u2800\u2800\u2880\u28f6\u28ff\u28f7\u2800\u2800\u2818\u28ff\u2844\u2800\u2810\u28f6\u28ac\u28c7\u2809\u28a3\u2878\u2800\u28f0\u28ff\u28c1\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28bf\u28fd\u285b\u28e7\u2814\u2812\u284f\u28c0\u2800\u2800\u28c0\u28c0\u28fe\u2800\u2811\u2822\u2824\u2803\r\n//\u2800\u28f4\u285f\u28fe\u285f\u28ff\u2847\u28c0\u28fc\u28ff\u28ff\u28e6\u2840\u2800\u2819\u283b\u2846\u2800\u2807\u28b0\u281f\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28f7\u287f\u281f\u28c7\u2800\u2800\u2899\u28f0\u28fa\u28fd\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\r\n//\u28b8\u287f\u28b8\u287f\u28f0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u2874\u2803\u2800\u2800\u28b8\u2840\u2800\u28b9\u28ff\u28ff\u28ff\u28ff\u28ff\u28b9\u28ff\u28ff\u28ef\u28c0\u28c0\u28c0\u28ed\u28cf\u2801\u2800\u2800\u2808\u283b\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\r\n//\u28ff\u2847\u28b8\u2857\u28b8\u281b\u28ff\u284d\u2809\u2819\u281b\u283b\u28ad\u28fb\u28ff\u28e7\u2800\u2800\u2880\u28f4\u2837\u28c4\u2840\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u287b\u2846\u2800\u2800\u2800\u2800\u2819\u2807\u2800\u2800\u2800\u2800\u2800\r\n//\u28ff\u2847\u28b8\u28f7\u28fd\u2836\u281b\u28b7\u2840\u28e0\u2824\u28a4\u28fe\u28ff\u28ff\u28fd\u28de\u28ff\u28ed\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2859\u28bf\u28ff\u2809\u281b\u28bf\u28ff\u28f7\u2847\u2800\u2880\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n//\u28ff\u28c7\u28fc\u28bf\u2801\u2800\u2800\u28a0\u2877\u2847\u28a0\u28f6\u287d\u28ff\u280b\u2809\u28bb\u283f\u281b\u280b\u2809\u2809\u28b9\u2809\u28bb\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2876\u288f\u2860\u283f\u28ff\u28f7\u285e\u281b\u2819\u28b3\u28e6\u2840\u2800\u2800\u2800\u2800\u2800\r\n//\u28ff\u284f\u28a0\u284b\u28c6\u2800\u2800\u285e\u2800\u2807\u2808\u28bf\u28ff\u28cf\u2800\u2800\u2838\u2840\u2800\u2800\u2800\u2880\u285e\u2800\u28b8\u28b8\u28ff\u284f\u281b\u281b\u281b\u2809\u28e0\u280b\u28e0\u2800\u2838\u2827\u28bb\u285d\u28b7\u2844\u28bf\u28f7\u2800\u2800\u2800\u2800\u2800\r\n//\u28b8\u28e7\u2838\u2879\u284c\u2886\u28f4\u28ff\u2840\u2800\u2800\u2808\u283b\u283f\u28c6\u2800\u2800\u2833\u28c4\u28f0\u28da\u2809\u2809\u2809\u283b\u28fe\u28ff\u287b\u28e6\u28c0\u28e0\u28f4\u2837\u281f\u28fb\u2800\u2800\u2800\u28b8\u2847\u28b8\u28e7\u28a8\u28ff\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u28bf\u28c7\u2813\u2803\u28fc\u28c7\u2848\u283b\u28c4\u2800\u2830\u28a6\u28c0\u2880\u28f7\u2844\u2800\u2800\u2800\u2808\u2809\u2813\u2864\u28c4\u2848\u287f\u28ff\u28f7\u28f6\u28f6\u28f6\u28fe\u28ff\u281f\u2880\u2806\u2800\u287e\u28b7\u28fe\u2847\u28fc\u285f\u2800\u2800\u2800\u2800\u2800\r\n//\u2800\u2808\u28bf\u28b7\u28de\u281b\u28ff\u28ff\u28e4\u284d\u2833\u28e4\u28e4\u28e4\u287f\u2817\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u2800\u2839\u2845\u2800\u2808\u2809\u2809\u2809\u283b\u28e4\u2814\u281a\u2812\u280a\u2800\u2800\u2808\u28ff\u287f\u2803\u2800\u2800\u2800\u2800\u2800\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588  \u2588\u2588\u28e4\u28d4\u284a\u28c0\u2800\u2800\u2877\u2800\u2800\u2800\u2880\u28f4\u281e\u2813\u2832\u2826\u28e4\u2840\u2800\u2800\u28e0\u287f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\r\n// \u2588\u2588         \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2800\u28b9\u2800\u2819\u28e4\u28c3\u28e4\u2836\u281e\u28eb\u28e4\u28df\u28db\u28f7\u28f6\u28ff\u289f\u2866\u28fe\u281f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n// \u2588\u2588\u2588\u2588\u2588     \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588 \u28b8\u2800\u2800\u28ff\u284f\u283e\u283f\u28f6\u28ff\u28ff\u28ff\u283f\u28db\u28fd\u28fe\u287f\u281a\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n// \u2588\u2588       \u2588\u2588        \u2588\u2588  \u2588\u2588 \u2847\u2800\u28e0\u280f\u2809\u281b\u2833\u2836\u28b6\u28f6\u287f\u283f\u281f\u280a\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588        \u2588\u2588  \u2588\u2588\u2809\u2809\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\r\n// A public demonstration in single-contract dual-token implementations\r\n// with zero-conflict events, and function overloading.\r\n// https://github.com/SJ741/E741-Platform\r\n// https://741.gg   (Get the token telegram link from 'telegram' variable)\r\n// Emerald Token Standard\r\n\r\n// WARNING - Fungible NFT specs are universally new, and inherently DANGEROUS\r\n// no systems have been built with these usecases in mind, and there are a number of \r\n// ways that experimental, complex contracts can lead to unforseen consequences.\r\n// INTERACT WITH EXPERIMENTAL SMART CONTRACTS AT YOUR OWN RISK\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n\r\n// libraries to separate ERC20 and ERC721 events, and certain signature-specific functions\r\n// ERC20 events\r\nlibrary libES20 {\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function emitTransfer(address _from, address _to, uint _amount) internal { emit Transfer(_from, _to, _amount); }\r\n    function emitApproval(address _owner, address _spender, uint _value) internal { emit Approval(_owner, _spender, _value); }\r\n}\r\n\r\n// ERC721 events\r\nlibrary libES721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function emitTransfer(address _from, address _to, uint _tokenId) internal { emit Transfer(_from, _to, _tokenId); }\r\n    function emitApproval(address _owner, address _approve, uint _tokenId) internal { emit Approval(_owner, _approve, _tokenId); }\r\n    function emitApprovalForAll(address _owner, address _operator, bool _approved) internal { emit ApprovalForAll(_owner, _operator, _approved); }\r\n}\r\n\r\n// ERC165 https://eips.ethereum.org/EIPS/eip-721\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// ERC20 https://eips.ethereum.org/EIPS/eip-20\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\n// ERC721 https://eips.ethereum.org/EIPS/eip-721\r\ninterface IERC721 is IERC165 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n    // payable removed for erc20 etherscan compatibility\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IE741 is IERC20, IERC721 {\r\n    // supportsInterface 0x5a46575f \r\n    // library transfers can not be included in the interface\r\n    // incorporate them directly with library\r\n    // libES20.Transfer\r\n    // libES20.Approval\r\n    // libES721.Transfer\r\n    // libES721.Approval\r\n    // libES721.ApprovalForAll\r\n    function balanceOf(address account) external override(IERC20, IERC721) view returns (uint256);\r\n    function approve(address spender, uint256 value) external override(IERC20, IERC721) returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external override(IERC20, IERC721) returns (bool);\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory _name);\r\n    function symbol() external view returns (string memory _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC7572 {\r\n    function contractURI() external view returns (string memory);\r\n    event ContractURIUpdated();\r\n}\r\n\r\ninterface IERC20Metadata {\r\n    function name() external view returns (string memory _name);\r\n    function symbol() external view returns (string memory _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IDevable {\r\n    function initialize(bytes memory encodedParameters) external returns (address);\r\n    function dev() external returns (address dev);\r\n    function setContractURI(string memory newContractURI) external;\r\n    function setBaseURI(string memory newBaseURI) external;\r\n    function changeDev(address newDev) external;\r\n    function toggelNFTinterface() external;\r\n    function withdraw() external;\r\n    function setExtension(string memory newExtension) external;\r\n    function setTelegram(string memory newTelegram) external;\r\n    function setSkipMintingGlobal(bool newSkipMintingGlobal) external;\r\n}\r\n\r\n// ERC721 Token Receiver https://eips.ethereum.org/EIPS/eip-721\r\ninterface IERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\r\n}\r\n\r\ncontract ERC721TokenReceiver is IERC721TokenReceiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) external virtual returns(bytes4) {\r\n        return IERC721TokenReceiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\nabstract contract E741V1Base is IDevable, ERC721TokenReceiver, IE741  {\r\n\r\n    address public constant BROKEN_ADDRESS = address(0x5e7ec);\r\n    address public constant DEPOSIT_ADDRESS = address(0x0);\r\n    address public constant MINT_ADDRESS = address(0x0);\r\n\r\n    string public baseURI;\r\n    string internal _contractURI;\r\n    string public extension;\r\n    string public telegram;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint internal _decimals;\r\n    uint internal _totalIds;\r\n    uint internal _totalSupply;\r\n    uint internal ONE; // 1.0 token(s)\r\n    uint internal MAXID; // e.g. 1.00000001 : 1.00007777 is the range for NFT IDs\r\n    uint64 public minted; // number of unique ID mints + ONE\r\n    address public dev;\r\n    bool public supportsNFTinterface;\r\n    bool public skipMintingGlobal = false;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    mapping(address => mapping(address => uint)) internal _allowance;\r\n    mapping(uint256 tokenId => address) public ownerOf;\r\n    mapping(uint256 => address) private _nftApprovals;\r\n    mapping(address => uint) internal _balanceOf;\r\n    mapping(address => uint64[]) public ownedNFTs; // broken NFTs stored in limbo list are at ownedNFTs[BROKEN_ADDRESS]\r\n    mapping(uint64 => uint256) internal idToIndex; \r\n    mapping(address => bool) internal skipMintingUser;\r\n\r\n    error UnsupportedReceiver();\r\n\r\n    modifier onlyDev() {\r\n        require(msg.sender == dev, \"Not the developer\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        dev = msg.sender;\r\n    }\r\n\r\n    function initialize(bytes memory encodedParameters) public override virtual returns (address underlyingToken);\r\n    function deposit(uint[] memory amounts) public virtual;\r\n    function withdraw(uint[] memory amounts) public payable virtual;\r\n\r\n    function name() public view virtual returns (string memory) { return _name; }\r\n    function symbol() public view virtual returns (string memory) { return _symbol; }\r\n    function decimals() public view virtual returns (uint) { return _decimals; }\r\n    function totalSupply() public view virtual returns (uint) { return _totalSupply; }\r\n    function maxSupply() public view virtual returns (uint) { return _totalIds * ONE; }\r\n    function balanceOf( address account) public view override returns (uint) { return _balanceOf[account]; }\r\n    function allowance(address owner, address spender) public view override returns (uint) { return _allowance[owner][spender]; }\r\n    function setBaseURI(string memory newBaseURI) public onlyDev override {baseURI = newBaseURI;}\r\n    function setContractURI(string memory newContractURI) public onlyDev override virtual {_contractURI = newContractURI; emit IERC7572.ContractURIUpdated();}\r\n    function setExtension(string memory newExtension) public onlyDev override virtual {extension = newExtension;}\r\n    function setTelegram(string memory newTelegram) public onlyDev virtual {telegram = newTelegram;}\r\n    function changeDev(address newDev) public onlyDev override  {dev = newDev;}//simple function to change developer address, or revoke ownership (with address(0))\r\n    // @DEV toggleNFTinterface is for the small possibility of frontend system changes leading the contract to favor enabling the disabled supportsNFTinterface flag\r\n    // don't waste it, as frontends don't typically change classification of contracts\r\n    // probably never to be used.\r\n    function toggelNFTinterface() public onlyDev override {supportsNFTinterface = !supportsNFTinterface;}\r\n    function tokensOfOwner(address owner) public view returns (uint64[] memory){return ownedNFTs[owner];}\r\n    function nftBalanceOf(address account) public view returns (uint) {return ownedNFTs[account].length;}\r\n    function contractURI() public view virtual returns (string memory) {return _contractURI;}\r\n    function setSkipMintingGlobal(bool newSkipMintingGlobal) public override virtual onlyDev { skipMintingGlobal = newSkipMintingGlobal; } \r\n    function setSkipMinting(bool newSkipMinting) public virtual { skipMintingUser[msg.sender] = newSkipMinting; }\r\n\r\n    function approve(address spender, uint amount) public override returns (bool) {\r\n\r\n        // if the amount is greater than one token, and within range of IDs for NFTs \r\n        // then set NFT approval for the given ID\r\n        if(amount >= ONE && amount <= MAXID) {\r\n            address owner = ownerOf[amount]; // getting the owner of token ID via the `amount` input\r\n            if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert(\"E741: You are not approved\");\r\n            _nftApprovals[amount] = spender; // calling nft approval for the token and spender\r\n            libES721.emitApproval(owner, spender, amount);\r\n            return true;\r\n        }\r\n        \r\n        // else set the ERC20 allowance\r\n        // the NFT ID range being set within a limited subset of ONE token(s)\r\n        // allows for non-clashing interactions\r\n        _allowance[msg.sender][spender] = amount;\r\n        libES20.emitApproval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer741(address from, address to, uint amount) internal virtual {\r\n        \r\n        require(_balanceOf[from] >= amount, \"E741: transfer amount exceeds balance\");\r\n        \r\n        // checking the decimal amount of tokens owned before transaction for both participants\r\n        uint256 fromDecimalsPre = _balanceOf[from] % ONE;\r\n        uint256 toDecimalsPre = _balanceOf[to] % ONE;\r\n        \r\n        // simple erc20 balance operations\r\n        _transfer20(from, to, amount);\r\n\r\n        // checking the decimal amount of tokens after transaction for both partcipants\r\n        uint256 fromDecimalsPost = _balanceOf[from] % ONE;\r\n        uint256 toDecimalsPost = _balanceOf[to] % ONE;\r\n\r\n        // stores the NFT IDs owned by `from`, enabling NFT management for that address.\r\n        uint64[] storage ownedNFTsArray = ownedNFTs[from];\r\n\r\n        // references NFTs marked as \"broken\", tracking these special state NFTs.\r\n        uint64[] storage brokenIDsArray = ownedNFTs[BROKEN_ADDRESS];\r\n        \r\n\r\n        // if sender has higher decimal count after transaction, then they \"roll under\" and break an NFT\r\n        if (fromDecimalsPre < fromDecimalsPost) {\r\n\r\n            if(ownedNFTsArray.length > 0) { // if the sender has an nft to send\r\n                //pushes the last nft in the owned list into the \"broken list\" for limbo NFTs\r\n                _transfer721Pop(from, BROKEN_ADDRESS, ownedNFTsArray); //transfers the NFT ID ownership to BROKEN address for stewardship\r\n            }\r\n        }\r\n\r\n        // if receiver has lower decimal count after transaction then they \"roll over\" and will \"remake\" an nft \r\n        if (toDecimalsPre > toDecimalsPost) {\r\n\r\n            if(brokenIDsArray.length > 0) { // recover an id from broken list\r\n\r\n                _transfer721Pop(BROKEN_ADDRESS, to, brokenIDsArray);\r\n            }\r\n            else { // mint new id\r\n                _mint(to);\r\n            }\r\n            \r\n        }\r\n        \r\n        // amount of tokens - amount of whole tokens being processed in int\r\n        uint amountInTokens = amount / ONE;\r\n\r\n        uint len = ownedNFTsArray.length; //len is the length, or number of NFTs in the addresses's owned array\r\n\r\n        // ignore minting nfts from dev when they call -- this allows for gas-efficient team operations\r\n        // @DEV if dev gathers NFTs, use the ERC721 transferFrom method to extract\r\n        // @DEV be careful, don't let the wallet fall to some convoluted transferFrom scam to do something unexpected\r\n        if(skipMintingGlobal || from == DEPOSIT_ADDRESS || skipMintingUser[to] || skipMintingUser[from] || from == dev) {\r\n            //  When skipping minting the nft holder can only send out the tokens they hold (reduce gas)\r\n            amountInTokens = amountInTokens < len ? amountInTokens : len;\r\n        }\r\n\r\n        if(amountInTokens > 0) {\r\n            \r\n            len = amountInTokens < len ? amountInTokens : len;\r\n            // transfers owned NFTs from `from` to `to` until either all are transferred or the desired amount is reached\r\n            // Subtracts transferred NFT count from `amountInTokens` to update remaining transfers\r\n            for (uint i = 0; i < len; i++) {\r\n                _transfer721Pop(from, to, ownedNFTsArray); \r\n            }\r\n            amountInTokens -= len;\r\n            len = brokenIDsArray.length;\r\n            len = amountInTokens < len ? amountInTokens : len;\r\n            \r\n            // recovers NFTs from the broken state to `to`, or mints new ones if not enough broken NFTs are available\r\n            // if any tokens remain to be allocated, it mints new NFTs to `to` for the remaining balance\r\n            for (uint i = 0; i < len; i++) {        \r\n                _transfer721Pop(BROKEN_ADDRESS, to, brokenIDsArray);\r\n            }\r\n\r\n            _mintBatch(to, amountInTokens - len);\r\n\r\n        }\r\n    }\r\n\r\n    function _mintBatch(address to, uint256 amount) internal virtual {\r\n        if(amount == 0) return; // Exit if no NFTs to mint\r\n\r\n        if(amount == 1) { // Optimize single mint process\r\n            _mint(to);\r\n            return;\r\n        }\r\n        uint64 id = minted; // Start ID from last minted value\r\n        uint256 ownedLen = ownedNFTs[to].length; // Current number of NFTs owned by 'to'\r\n        for(uint i = 0; i < amount;) {\r\n            unchecked {\r\n                id++; // Increment ID for each new NFT\r\n            }\r\n            ownerOf[id] = to; // Assign new NFT to owner.\r\n            idToIndex[id] = ownedLen; // Map NFT ID to its index in owner's array\r\n            ownedNFTs[to].push(id); // Add new NFT ID to owner's list\r\n\r\n            libES721.emitTransfer(MINT_ADDRESS, to, id); // Emit NFT transfer event\r\n\r\n            unchecked {\r\n                ownedLen++; // Increment count of owned NFTs\r\n                i++; // Move to next NFT\r\n            }\r\n        }\r\n        unchecked {\r\n            minted += uint64(amount); // Update total minted count\r\n        }\r\n    }\r\n\r\n\r\n    function _mint(address to) internal virtual returns(uint64 tokenId){\r\n        unchecked {\r\n            minted++; // Increment the total number of minted tokens\r\n        }\r\n        tokenId = minted; // Assign the newly minted token ID\r\n\r\n        ownerOf[tokenId] = to; // Set ownership of the new token to 'to'\r\n        idToIndex[tokenId] = ownedNFTs[to].length; // Map the new token ID to its index in the owner's list\r\n        ownedNFTs[to].push(tokenId); // Add the new token ID to the owner's list of owned tokens\r\n        \r\n        libES721.emitTransfer(MINT_ADDRESS, to, tokenId); // Emit an event for the token transfer\r\n    }\r\n\r\n\r\n    // Updates the mappings and arrays managing ownership and index of NFTs after a transfer\r\n    function _updateOwnedNFTs(address from, address to, uint64 tokenId) internal { \r\n        uint256 index = idToIndex[tokenId]; // Get current index of the token in the owner's list\r\n        uint64[] storage nftArray = ownedNFTs[from]; // Reference to the list of NFTs owned by 'from'\r\n        uint256 len = nftArray.length; // Current number of NFTs owned by 'from'\r\n        uint64 lastTokenId = nftArray[len - 1]; // Last token in the 'from' array to swap with transferred token\r\n        \r\n        nftArray[index] = lastTokenId; // Replace the transferred token with the last token in the array\r\n        nftArray.pop(); // Remove the last element, effectively deleting the transferred token from 'from'\r\n        \r\n        if(len - 1 != 0){ \r\n            idToIndex[lastTokenId] = index; // Update the index of the swapped token\r\n        } \r\n    \r\n        ownedNFTs[to].push(tokenId); // Add the transferred token to the 'to' array\r\n        idToIndex[tokenId] = ownedNFTs[to].length - 1; // Update the index mapping for the transferred token\r\n    }\r\n\r\n    // Executes a simple ERC20 token transfer.\r\n    function _transfer20(address from, address to, uint256 amount) internal {\r\n        _balanceOf[from] -= amount; // Deduct the amount from the sender's balance\r\n        unchecked {\r\n            _balanceOf[to] += amount; // Add the amount to the recipient's balance\r\n        }\r\n        libES20.emitTransfer(from, to, amount); // Emit an ERC20 transfer event\r\n    }\r\n\r\n    // Handles the transfer of an ERC721 token, ensuring proper ownership and event emission\r\n    function _transfer721(address from, address to, uint64 tokenId) internal virtual {\r\n        require(from == ownerOf[tokenId], \"E741: Incorrect owner\"); // Ensure 'from' is the current owner\r\n        \r\n        delete _nftApprovals[tokenId]; // Clear any approvals for this token\r\n        ownerOf[tokenId] = to; // Transfer ownership of the token to 'to'\r\n        _updateOwnedNFTs(from, to, tokenId); // Update ownership tracking structures\r\n        libES721.emitTransfer(from, to, tokenId); // Emit an ERC721 transfer event\r\n    }\r\n\r\n    // Handles the transfer of an ERC721 token, ensuring proper ownership and event emission\r\n    function _transfer721Pop(address from, address to, uint64[] storage nftArray) internal virtual {\r\n        uint64 tokenId = nftArray[nftArray.length - 1];\r\n        \r\n        delete _nftApprovals[tokenId]; // Clear any approvals for this token\r\n        ownerOf[tokenId] = to; // Transfer ownership of the token to 'to'\r\n        \r\n        // update owned nfts pop edition\r\n        nftArray.pop(); // Remove the last element, effectively deleting the transferred token from 'from'    \r\n        ownedNFTs[to].push(tokenId); // Add the transferred token to the 'to' array\r\n        idToIndex[tokenId] = ownedNFTs[to].length - 1; // Update the index mapping for the transferred token\r\n\r\n        libES721.emitTransfer(from, to, tokenId); // Emit an ERC721 transfer event\r\n    }\r\n\r\n\r\n    // only erc20 calls this\r\n    // if amount is a token id owned my the caller send as an NFT\r\n    // else transfer741\r\n    function transfer(address to, uint amount) public override returns (bool) {\r\n        if(ownerOf[amount] == msg.sender) {\r\n            _transfer721(msg.sender, to, uint64(amount));\r\n            _transfer20(msg.sender, to, ONE);\r\n            return true;\r\n        }\r\n        _transfer741(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // erc20 and erc721 call this\r\n    function transferFrom(address from, address to, uint amount) public override returns (bool) {\r\n\r\n        //if amount is within the NFT id range, then a simple NFT transfer + token amount (ONE)\r\n        if(amount >= ONE && amount <= MAXID) {\r\n            require(\r\n                //require from is the msg caller, or that caller is approved for that specific NFT, or all NFTs \r\n                msg.sender == from || msg.sender == getApproved(amount) || isApprovedForAll(from, msg.sender),\r\n                \"E741: You don't have the right\"\r\n                );\r\n\r\n            _transfer721(from, to, uint64(amount));\r\n            _transfer20(from, to, ONE);\r\n            return true;\r\n        }\r\n\r\n        _spendAllowance(from, msg.sender, amount);\r\n        _transfer741(from, to, amount);\r\n        return true;\r\n\r\n    }\r\n\r\n    // erc721\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override {\r\n        require(\r\n                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),\r\n                \"E741: You don't have the right\"\r\n            );\r\n        _transfer721(from, to, uint64(tokenId)); \r\n        _transfer20(from, to, ONE);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, \"\") !=\r\n            IERC721TokenReceiver.onERC721Received.selector\r\n        ) {\r\n            revert UnsupportedReceiver();\r\n        }\r\n    }\r\n\r\n    // erc721\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable override {\r\n        require(\r\n                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),\r\n                \"E741: You don't have the right\"\r\n            );\r\n        _transfer721(from, to, uint64(tokenId)); \r\n        _transfer20(from, to, ONE);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) !=\r\n            IERC721TokenReceiver.onERC721Received.selector\r\n        ) {\r\n            revert UnsupportedReceiver();\r\n        }\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint amount) internal virtual {\r\n        require(_allowance[owner][spender] >= amount, \"E741: insufficient allowance\");\r\n        _allowance[owner][spender] -= amount;\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        if (ownerOf[tokenId] == address(0)) revert();\r\n        return _nftApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public override {\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        libES721.emitApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\r\n        require(tokenId <= MAXID, \"E741: invalid id\");\r\n        if (bytes(baseURI).length == 0) {return \"\";}\r\n        return string(abi.encodePacked(baseURI, toString(tokenId - ONE), extension));\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {return \"0\";} uint256 temp = value; uint256 digits;\r\n        while (temp != 0) {digits++; temp /= 10;} bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {digits -= 1; buffer[digits] = bytes1(uint8(value % 10) + 48); value /= 10;}\r\n        return string(buffer);\r\n    }\r\n\r\n    function withdraw() external onlyDev override {\r\n        (bool success,) = payable(dev).call{value: address(this).balance}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return\r\n            // Even though we support ERC721 and should return true, etherscan wants to treat us as ERC721 instead of ERC20\r\n            // @DEV ERC165 for ERC721 can be toggled on for reasons of frontend/dapp/script implementations, but is very specific\r\n            (supportsNFTinterface && interfaceId == 0x80ac58cd) || // ERC165 interface ID for ERC721\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165\r\n            interfaceId == 0x36372b07 || // ERC165 interface ID for ERC20\r\n            interfaceId == 0x150b7a02 || // ERC165 interface ID for IERC721TokenReceiver\r\n            interfaceId == 0x5a46575f;   // ERC165 interface ID for IE741\r\n            \r\n    }\r\n}\r\n\r\npragma solidity ^0.8.24;\r\n\r\n\r\ncontract E741V1Wrapped741 is E741V1Base {\r\n\r\n    event Deposit(address indexed from, uint amount741Out, uint[] amounts741In);\r\n    event Withdrawal(address indexed to, uint amountUnderlyingOut, uint[] amounts741In);\r\n\r\n    address constant EMERALDS = 0x382EDfe4c6168858C81893fE00fCB7b68914d929;\r\n    address public underlying741;\r\n    uint public underlyingWeiPerNft;\r\n\r\n    address public feeRecipient;\r\n    uint public withdrawalFees;\r\n    uint internal withdrawalFeesDivisor = 10000;\r\n    uint constant WITHDRAWAL_FEES_MIN = 5; // 0.05%\r\n    uint constant WITHDRAWAL_FEES_MAX = 50; // 0.5%\r\n\r\n    function initialize(bytes memory encodedParameters) public virtual override returns (address) {\r\n        require(_decimals == 0, \"Already initialized\");\r\n        \r\n        {\r\n            // to prevent stack to deep error\r\n            string memory _inputName; \r\n            string memory _inputSymbol;\r\n            (withdrawalFees, underlying741, _inputName, _inputSymbol, _decimals, baseURI, _contractURI, _totalIds, underlyingWeiPerNft) = \r\n                abi.decode(encodedParameters, (uint,address,string,string,uint,string,string,uint,uint));\r\n\r\n            _name = _inputName;\r\n            _symbol = _inputSymbol;\r\n        }\r\n\r\n        {\r\n            address _token = underlying741;\r\n            require(_token != address(0), 'E741V1: ZERO_ADDRESS');\r\n            try IERC165(_token).supportsInterface(0x5a46575f) returns (bool supports741) {\r\n                require(_token == EMERALDS || supports741, \"The underlying token does not support e741\");\r\n            } catch {\r\n                revert(\"The underlying token does not support ERC165\");\r\n            }\r\n        }\r\n\r\n        ONE = 10 ** _decimals;\r\n        MAXID = ONE + _totalIds - 1;\r\n        minted = uint64(ONE) - 1; // start minting from ID ONE-1 so you can get id 0\r\n\r\n        feeRecipient = msg.sender; // our factory is always the fee recipient even if dev of token changes\r\n\r\n        require(_decimals <= 18 && IERC20(underlying741).decimals() <= 18, \"Too many decimals\");\r\n        require(_totalIds > 0, \"Need at least 1 nft\");\r\n        require(withdrawalFees >= WITHDRAWAL_FEES_MIN, \"Min fees of 0.05%\");\r\n        require(withdrawalFees <= WITHDRAWAL_FEES_MAX, \"Max fees of 0.5%\");\r\n        require(ONE > _totalIds, \"Not enough decimals for NFT count\");\r\n\r\n        return underlying741;\r\n    }\r\n\r\n\r\n    // deposit amount of underlying741\r\n    function deposit(uint[] memory _amountsArray) public virtual override {\r\n\r\n        uint _len = _amountsArray.length;\r\n        uint _amount741Out;\r\n        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();\r\n\r\n        if(_len == 1) {\r\n            if(IE741(underlying741).ownerOf(_amountsArray[0]) != msg.sender) { // not single nft transfer\r\n                _amount741Out = (_amountsArray[0] * ONE) / underlyingWeiPerNft;\r\n            }\r\n            else {\r\n                _amount741Out = (_underlyingONE * ONE) / underlyingWeiPerNft; // _len is 1\r\n            }            \r\n            // use direct from array to transfer the nft id if used\r\n            IE741(underlying741).transferFrom(msg.sender, address(this), _amountsArray[0]);\r\n        }\r\n        else {\r\n            for(uint i = 0; i < _len; i++) {\r\n                // reverts if they deposit unowned or invalid id\r\n                IE741(underlying741).safeTransferFrom(msg.sender, address(this), _amountsArray[i]);\r\n            }\r\n            _amount741Out = ((_len * _underlyingONE) * ONE) / underlyingWeiPerNft;\r\n        }\r\n        // spawn raw tokens\r\n        _balanceOf[DEPOSIT_ADDRESS] += _amount741Out;\r\n\r\n        _totalSupply += _amount741Out;\r\n\r\n        _transfer741(DEPOSIT_ADDRESS, msg.sender, _amount741Out); // use _transfer741 to give user broken nfts if necessary\r\n\r\n        // donating tokens to this wrapper will only make the wrapped token more scarce\r\n        require(underlyingWeiPerNft * _totalIds >=  IERC20(underlying741).balanceOf(address(this)), \"NFT capacity reached, wait for someone to withdraw\");\r\n\r\n        emit Deposit(msg.sender, _amount741Out, _amountsArray);\r\n    }\r\n\r\n    // Two modes\r\n    // withdraw([amount])\r\n    // withdraw([id1, id2, id3])\r\n    function withdraw(uint256[] memory _amountsArray741) public virtual override payable {\r\n        uint _arrayLen = _amountsArray741.length;\r\n        require(_arrayLen > 0, \"Trying to withdraw nothing\");\r\n\r\n        uint _amount741; uint _amount741Sum;\r\n        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();\r\n\r\n        if (_arrayLen == 1) {\r\n            _amount741 = _amountsArray741[0];\r\n            if (ownerOf[_amount741] == msg.sender) {\r\n                _amount741Sum = ONE; // only record ONE for owned transfer\r\n            } else {\r\n                _amount741Sum = _amount741;\r\n            }\r\n            transfer(DEPOSIT_ADDRESS, _amount741);\r\n        } else {\r\n            for(uint i = 0; i < _arrayLen;) {\r\n                _amount741 = _amountsArray741[i];\r\n                require(ownerOf[_amount741] == msg.sender, \"Can only withdraw for nfts you own\");\r\n                transfer(DEPOSIT_ADDRESS, _amount741);\r\n                unchecked { i++; }\r\n            }\r\n            _amount741Sum = _arrayLen * ONE; // only record ONE for owned transfer\r\n        }\r\n        // remove raw tokens\r\n        _balanceOf[DEPOSIT_ADDRESS] -= _amount741Sum;\r\n        _totalSupply -= _amount741Sum;\r\n\r\n        uint _totalUnderlyingOut = (_amount741Sum * underlyingWeiPerNft) / ONE; // use ONE not _underlyingONE\r\n        uint _totalUnderlyingFees = (_totalUnderlyingOut * withdrawalFees) / withdrawalFeesDivisor;\r\n\r\n        IE741(underlying741).transfer(feeRecipient, _totalUnderlyingFees);\r\n        \r\n        IE741(underlying741).transfer(msg.sender, (_totalUnderlyingOut - _totalUnderlyingFees));\r\n\r\n        emit Withdrawal(msg.sender, _totalUnderlyingOut, _amountsArray741);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"UnsupportedReceiver\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount741Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts741In\",\"type\":\"uint256[]\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUnderlyingOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts741In\",\"type\":\"uint256[]\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BROKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amountsArray\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedParameters\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nftBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedNFTs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newContractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newExtension\",\"type\":\"string\"}],\"name\":\"setExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newSkipMinting\",\"type\":\"bool\"}],\"name\":\"setSkipMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newSkipMintingGlobal\",\"type\":\"bool\"}],\"name\":\"setSkipMintingGlobal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTelegram\",\"type\":\"string\"}],\"name\":\"setTelegram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skipMintingGlobal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsNFTinterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"telegram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggelNFTinterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying741\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingWeiPerNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amountsArray741\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "E741V1Wrapped741", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e68db4566750c8448bec0263df669a89d4d5586467cae4dc16b0731ab2ffe716"}