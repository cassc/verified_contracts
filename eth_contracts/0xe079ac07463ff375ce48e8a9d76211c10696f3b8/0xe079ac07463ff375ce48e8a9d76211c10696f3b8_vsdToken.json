{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/vsdToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\nimport \\\"src/interfaces/IBooster.sol\\\";\\nimport \\\"src/interfaces/IDepositor.sol\\\";\\nimport \\\"src/interfaces/ILiquidityGauge.sol\\\";\\nimport {ERC20} from \\\"solady/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @title vsdToken\\n/// @notice Contract that accepts tokens, sdTokens, and sdTokens gauges, against vsdToken.\\n/// @author StakeDAO\\n/// @custom:contact contact@stakedao.org\\ncontract vsdToken is ERC20 {\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice Address of the locker token.\\n    address immutable token;\\n\\n    /// @notice Address of the sdToken corresponding to the token.\\n    address immutable sdToken;\\n\\n    /// @notice Address of the veSDT booster contract.\\n    address immutable booster;\\n\\n    /// @notice Address of the gauge contract where sdToken is deposited.\\n    address public gauge;\\n\\n    /// @notice Address of the depositor contract.\\n    address public depositor;\\n\\n    /// @notice Address of the governance.\\n    address public governance;\\n\\n    /// @notice Address of the future governance contract.\\n    address public futureGovernance;\\n\\n    /// @notice Throws if caller is not the governance.\\n    error GOVERNANCE();\\n\\n    /// @notice Event emitted when governance is changed.\\n    /// @param newGovernance Address of the new governance.\\n    event GovernanceChanged(address indexed newGovernance);\\n\\n    ////////////////////////////////////////////////////////////////\\n    /// --- MODIFIERS\\n    ///////////////////////////////////////////////////////////////\\n\\n    modifier onlyGovernance() {\\n        if (msg.sender != governance) revert GOVERNANCE();\\n        _;\\n    }\\n\\n    constructor(address _token, address _depositor, address _booster, address _sdToken, address _gauge) {\\n        token = _token;\\n        gauge = _gauge;\\n        booster = _booster;\\n        sdToken = _sdToken;\\n        depositor = _depositor;\\n\\n        governance = msg.sender;\\n\\n        SafeTransferLib.safeApprove(_sdToken, _gauge, type(uint256).max);\\n        SafeTransferLib.safeApprove(_token, _depositor, type(uint256).max);\\n    }\\n\\n    /// @notice Deposit token through the depositor contract and stake the tokens in the gauge on behalf of the booster contract.\\n    /// @param _amount Amount of tokens to deposit.\\n    function deposit(uint256 _amount) external {\\n        /// Transfer the tokens to this contract.\\n        SafeTransferLib.safeTransferFrom(token, msg.sender, address(this), _amount);\\n\\n        /// Check for any incentive tokens sitting in the depositor contract.\\n        uint256 _incentiveToken = IDepositor(depositor).incentiveToken();\\n\\n        /// Deposit and stake the tokens on behalf the booster contract.\\n        IDepositor(depositor).deposit(_amount, true, true, booster);\\n\\n        /// Mint vsdTokens to the user + any incentive tokens.\\n        _mint(msg.sender, _amount + _incentiveToken);\\n    }\\n\\n    /// @notice Deposit sdToken Gauge to the booster contract.\\n    /// @param _amount Amount of sdToken to deposit.\\n    function depositGauge(uint256 _amount) external {\\n        /// Transfer the tokens directly to the booster contract.\\n        SafeTransferLib.safeTransferFrom(gauge, msg.sender, booster, _amount);\\n\\n        /// Mint vsdTokens to the user.\\n        _mint(msg.sender, _amount);\\n    }\\n\\n    /// @notice Deposit sdToken, stake them in the gauge on behalf of the booster contract.\\n    function depositSdToken(uint256 _amount) external {\\n\\n        /// Transfer the tokens to this contract.\\n        SafeTransferLib.safeTransferFrom(sdToken, msg.sender, address(this), _amount);\\n\\n        /// Stake sdToken in the gauge on behalf of the booster contract.\\n        ILiquidityGauge(gauge).deposit(_amount, booster);\\n\\n        /// Mint vsdTokens to the user.\\n        _mint(msg.sender, _amount);\\n    }\\n\\n    /// @notice Withdraw sdToken from the booster contract.\\n    /// @param _amount Amount of sdToken to withdraw.\\n    /// @param _unstake Boolean indicating whether to unstake the tokens from the gauge and receive sdToken.\\n    function withdraw(uint256 _amount, bool _unstake) external {\\n        /// Burn vsdTokens from the user.\\n        _burn(msg.sender, _amount);\\n\\n        /// Withdraw the tokens from the gauge.\\n        IBooster(booster).withdraw(gauge, _amount);\\n\\n        /// Unstake the tokens from the gauge.\\n        if (_unstake) {\\n            ILiquidityGauge(gauge).withdraw(_amount);\\n\\n            /// Transfer the tokens to the user.\\n            SafeTransferLib.safeTransfer(sdToken, msg.sender, _amount);\\n        } else {\\n            /// Transfer the tokens to the user.\\n            SafeTransferLib.safeTransfer(gauge, msg.sender, _amount);\\n        }\\n    }\\n\\n    /// @notice Returns the name of the contract. (ERC20)\\n    function name() public view override returns (string memory) {\\n        return string(abi.encodePacked(\\\"Vote Boosted \\\", ERC20(sdToken).symbol()));\\n    }\\n\\n    /// @notice Returns the symbol of the contract. (ERC20)\\n    function symbol() public view override returns (string memory) {\\n        return string(abi.encodePacked(\\\"v\\\", ERC20(sdToken).symbol()));\\n    }\\n\\n    /// @notice Returns the decimals of the contract. (ERC20)\\n    function decimals() public view override returns (uint8) {\\n        return ERC20(sdToken).decimals();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////\\n    /// --- GOVERNANCE\\n    ///////////////////////////////////////////////////////////////\\n\\n    /// @notice Sets the depositor address.\\n    function setDepositor(address _depositor) external onlyGovernance {\\n        /// Remove the approval from the old depositor.\\n        SafeTransferLib.safeApprove(token, depositor, 0);\\n\\n        /// Update the depositor address.\\n        depositor = _depositor;\\n\\n        /// Approve the new depositor to spend the token.\\n        SafeTransferLib.safeApprove(token, _depositor, type(uint256).max);\\n    }\\n\\n    /// @notice Sets the gauge address.\\n    /// @param _gauge Address of the gauge contract.\\n    /// @dev In order to update the gauge address, we need to migrate from the old gauge to the new one by withdrawing.\\n    function setGauge(address _gauge) external onlyGovernance {\\n        uint256 _totalSupply = totalSupply();\\n\\n        /// Withdraw the tokens from the booster contract.\\n        IBooster(booster).withdraw(gauge, _totalSupply);\\n\\n        /// Unstake the tokens from the gauge.\\n        ILiquidityGauge(gauge).withdraw(_totalSupply);\\n\\n        /// Remove the approval from the old gauge.\\n        SafeTransferLib.safeApprove(sdToken, gauge, 0);\\n\\n        /// Set the new gauge address.\\n        gauge = _gauge;\\n\\n        /// Approve the new gauge to spend the sdToken.\\n        SafeTransferLib.safeApprove(sdToken, _gauge, type(uint256).max);\\n\\n        /// Stake the tokens in the new gauge on behalf of the booster contract.\\n        ILiquidityGauge(_gauge).deposit(_totalSupply, booster);\\n    }\\n\\n    /// @notice Transfer the governance to a new address.\\n    /// @param _governance Address of the new governance.\\n    function transferGovernance(address _governance) external onlyGovernance {\\n        futureGovernance = _governance;\\n    }\\n\\n    /// @notice Accept the governance transfer.\\n    function acceptGovernance() external {\\n        if (msg.sender != futureGovernance) revert GOVERNANCE();\\n\\n        governance = msg.sender;\\n\\n        futureGovernance = address(0);\\n\\n        emit GovernanceChanged(msg.sender);\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/IBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\ninterface IBooster {\\n    function withdraw(address _gauge, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDepositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\ninterface IDepositor {\\n    function deposit(uint256 _amount, bool _lock, bool _stake, address _user) external;\\n    function incentiveToken() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILiquidityGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.19;\\n\\ninterface ILiquidityGauge {\\n    function deposit(uint256 _amount, address _user) external;\\n\\n    function withdraw(uint256 _amount) external;\\n\\n    function claim_rewards(address _addr, address _receiver) external;\\n\\n    function claimable_reward(address _addr, address _token) external view returns (uint256);\\n\\n    function balanceOf(address _addr) external view returns (uint256);\\n\\n    function working_balances(address _addr) external view returns (uint256);\\n\\n    function working_supply() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    bytes32 private constant _VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solady/=lib/solady/src/\",\r\n      \"address-book/=lib/address-book/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_booster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sdToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositSdToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"setGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"transferGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_unstake\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "vsdToken", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000c1e3ca8a3921719be0ae3690a0e036feb4f6919100000000000000000000000038d10708ce535361f178f55e68df7e85acc66270000000000000000000000000d1b5651e55d4ceed36251c61c50c889b36f6abb50000000000000000000000007f50786a0b15723d741727882ee99a0bf34e3466", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}