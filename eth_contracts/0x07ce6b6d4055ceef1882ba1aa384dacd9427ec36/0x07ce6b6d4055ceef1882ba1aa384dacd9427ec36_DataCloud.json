{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Code bl/Contract.sol\": {\r\n      \"content\": \"/*\\r\\n                                                                                                                                                                                                                                                                                                                                             \\r\\n\\r\\n    X/Twitter - https://twitter.com/DataCloud_ERC\\r\\n    Telegram - https://t.me/DataCloudEntry\\r\\n    Website - https://datacloud.software/\\r\\n\\r\\nDataCloud revolutionizes the world of AI Computing by offering a seamless platform for renting \\r\\nhigh-performance DPUs, GPUs and blockchain Nodes. With DataCloud, users can harness the power of \\r\\nquality processing units for various computing tasks, including AI and machine learning projects, \\r\\nin a decentralized and cost-effective manner.\\r\\n\\r\\n\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./SafeCast.sol\\\";\\r\\nimport \\\"./SignedMath.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n}\\r\\n\\r\\ncontract DataCloud is Context, IERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    string private constant _name = unicode\\\"DataCloud\\\";\\r\\n    string private constant _symbol = unicode\\\"DPU\\\";\\r\\n    uint8 private constant _decimals = 18;\\r\\n\\r\\n    mapping(address => uint256) private _rOwned;\\r\\n    mapping(address => uint256) private _tOwned;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    mapping(address => bool) private _isExcludedFromFee;\\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n    uint256 private constant _tTotal = 1000000000 * 10 ** _decimals;\\r\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\r\\n    uint256 private _tFeeTotal;\\r\\n    uint256 private _redisFeeOnBuy = 0;\\r\\n    uint256 public _taxFeeOnBuy = 5;\\r\\n    uint256 private _redisFeeOnSell = 0;\\r\\n    uint256 public _taxFeeOnSell = 5;\\r\\n\\r\\n    //Original Fee\\r\\n    uint256 private _redisFee = _redisFeeOnSell;\\r\\n    uint256 private _taxFee = _taxFeeOnSell;\\r\\n\\r\\n    uint256 private _previousredisFee = _redisFee;\\r\\n    uint256 private _previoustaxFee = _taxFee;\\r\\n\\r\\n    mapping(address => bool) public bots;\\r\\n    mapping(address => uint256) public _buyMap;\\r\\n    address payable private _developmentAddress =\\r\\n        payable(0x7aa0dc9B8b94365ae09361AF05a1385E9688a878);\\r\\n    address payable private _marketingAddress =\\r\\n        payable(0x7aa0dc9B8b94365ae09361AF05a1385E9688a878);\\r\\n\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    address public uniswapV2Pair;\\r\\n\\r\\n    bool private tradingOpen;\\r\\n    bool private inSwap = false;\\r\\n    bool private swapEnabled = true;\\r\\n\\r\\n    uint256 public _maxTxAmount = (_tTotal * 20) / 100;\\r\\n    uint256 public _maxWalletSize = (_tTotal * 20) / 100;\\r\\n    uint256 public _swapTokensAtAmount = (_tTotal * 10) / 100;\\r\\n\\r\\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\\r\\n    modifier lockTheSwap() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        _rOwned[_msgSender()] = _rTotal;\\r\\n        _isExcludedFromFee[owner()] = true;\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        _isExcludedFromFee[_developmentAddress] = true;\\r\\n        _isExcludedFromFee[_marketingAddress] = true;\\r\\n\\r\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\r\\n    }\\r\\n\\r\\n    function name() public pure returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public pure override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return tokenFromReflection(_rOwned[account]);\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()].sub(\\r\\n                amount,\\r\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function tokenFromReflection(\\r\\n        uint256 rAmount\\r\\n    ) private view returns (uint256) {\\r\\n        require(\\r\\n            rAmount <= _rTotal,\\r\\n            \\\"Amount must be less than total reflections\\\"\\r\\n        );\\r\\n        uint256 currentRate = _getRate();\\r\\n        return rAmount.div(currentRate);\\r\\n    }\\r\\n\\r\\n    function removeAllFee() private {\\r\\n        if (_redisFee == 0 && _taxFee == 0) return;\\r\\n\\r\\n        _previousredisFee = _redisFee;\\r\\n        _previoustaxFee = _taxFee;\\r\\n\\r\\n        _redisFee = 0;\\r\\n        _taxFee = 0;\\r\\n    }\\r\\n\\r\\n    function restoreAllFee() private {\\r\\n        _redisFee = _previousredisFee;\\r\\n        _taxFee = _previoustaxFee;\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) private {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n        if (from != owner() && to != owner()) {\\r\\n            //Trade start check\\r\\n            if (!tradingOpen) {\\r\\n                require(\\r\\n                    from == owner(),\\r\\n                    \\\"TOKEN: This account cannot send tokens until trading is enabled\\\"\\r\\n                );\\r\\n            }\\r\\n\\r\\n            require(amount <= _maxTxAmount, \\\"TOKEN: Max Transaction Limit\\\");\\r\\n\\r\\n            if (to != uniswapV2Pair) {\\r\\n                require(\\r\\n                    balanceOf(to) + amount < _maxWalletSize,\\r\\n                    \\\"TOKEN: Balance exceeds wallet size!\\\"\\r\\n                );\\r\\n            }\\r\\n\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\\r\\n\\r\\n            if (contractTokenBalance >= _maxTxAmount) {\\r\\n                contractTokenBalance = _maxTxAmount;\\r\\n            }\\r\\n\\r\\n            if (\\r\\n                canSwap &&\\r\\n                !inSwap &&\\r\\n                from != uniswapV2Pair &&\\r\\n                swapEnabled &&\\r\\n                !_isExcludedFromFee[from] &&\\r\\n                !_isExcludedFromFee[to]\\r\\n            ) {\\r\\n                swapTokensForEth(contractTokenBalance);\\r\\n                uint256 contractETHBalance = address(this).balance;\\r\\n                if (contractETHBalance > 0) {\\r\\n                    sendETHToFee(address(this).balance);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n\\r\\n        //Transfer Tokens\\r\\n        if (\\r\\n            (_isExcludedFromFee[from] || _isExcludedFromFee[to]) ||\\r\\n            (from != uniswapV2Pair && to != uniswapV2Pair)\\r\\n        ) {\\r\\n            takeFee = false;\\r\\n        } else {\\r\\n            //Set Fee for Buys\\r\\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\\r\\n                _redisFee = _redisFeeOnBuy;\\r\\n                _taxFee = _taxFeeOnBuy;\\r\\n            }\\r\\n\\r\\n            //Set Fee for Sells\\r\\n            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\\r\\n                _redisFee = _redisFeeOnSell;\\r\\n                _taxFee = _taxFeeOnSell;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _tokenTransfer(from, to, amount, takeFee);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function sendETHToFee(uint256 amount) private {\\r\\n        _marketingAddress.transfer(amount);\\r\\n    }\\r\\n\\r\\n    function openTrading(bool _tradingOpen) public onlyOwner {\\r\\n        require(!tradingOpen, \\\"Cannot reenable trading\\\");\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\r\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\r\\n        );\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).getPair(\\r\\n            address(this),\\r\\n            _uniswapV2Router.WETH()\\r\\n        );\\r\\n        tradingOpen = _tradingOpen;\\r\\n    }\\r\\n\\r\\n    function manualswap() external {\\r\\n        require(\\r\\n            _msgSender() == _developmentAddress ||\\r\\n                _msgSender() == _marketingAddress\\r\\n        );\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        swapTokensForEth(contractBalance);\\r\\n    }\\r\\n\\r\\n    function manualsend() external {\\r\\n        require(\\r\\n            _msgSender() == _developmentAddress ||\\r\\n                _msgSender() == _marketingAddress\\r\\n        );\\r\\n        uint256 contractETHBalance = address(this).balance;\\r\\n        sendETHToFee(contractETHBalance);\\r\\n    }\\r\\n\\r\\n    function _tokenTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bool takeFee\\r\\n    ) private {\\r\\n        if (!takeFee) removeAllFee();\\r\\n        _transferStandard(sender, recipient, amount);\\r\\n        if (!takeFee) restoreAllFee();\\r\\n    }\\r\\n\\r\\n    function _transferStandard(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 tAmount\\r\\n    ) private {\\r\\n        (\\r\\n            uint256 rAmount,\\r\\n            uint256 rTransferAmount,\\r\\n            uint256 rFee,\\r\\n            uint256 tTransferAmount,\\r\\n            uint256 tFee,\\r\\n            uint256 tTeam\\r\\n        ) = _getValues(tAmount);\\r\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\r\\n        _takeTeam(tTeam);\\r\\n        _reflectFee(rFee, tFee);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _takeTeam(uint256 tTeam) private {\\r\\n        uint256 currentRate = _getRate();\\r\\n        uint256 rTeam = tTeam.mul(currentRate);\\r\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\\r\\n    }\\r\\n\\r\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\r\\n        _rTotal = _rTotal.sub(rFee);\\r\\n        _tFeeTotal = _tFeeTotal.add(tFee);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function _getValues(\\r\\n        uint256 tAmount\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\\r\\n    {\\r\\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(\\r\\n            tAmount,\\r\\n            _redisFee,\\r\\n            _taxFee\\r\\n        );\\r\\n        uint256 currentRate = _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\r\\n            tAmount,\\r\\n            tFee,\\r\\n            tTeam,\\r\\n            currentRate\\r\\n        );\\r\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\\r\\n    }\\r\\n\\r\\n    function _getTValues(\\r\\n        uint256 tAmount,\\r\\n        uint256 redisFee,\\r\\n        uint256 taxFee\\r\\n    ) private pure returns (uint256, uint256, uint256) {\\r\\n        uint256 tFee = tAmount.mul(redisFee).div(100);\\r\\n        uint256 tTeam = tAmount.mul(taxFee).div(100);\\r\\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\\r\\n        return (tTransferAmount, tFee, tTeam);\\r\\n    }\\r\\n\\r\\n    function _getRValues(\\r\\n        uint256 tAmount,\\r\\n        uint256 tFee,\\r\\n        uint256 tTeam,\\r\\n        uint256 currentRate\\r\\n    ) private pure returns (uint256, uint256, uint256) {\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n        uint256 rFee = tFee.mul(currentRate);\\r\\n        uint256 rTeam = tTeam.mul(currentRate);\\r\\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\\r\\n        return (rAmount, rTransferAmount, rFee);\\r\\n    }\\r\\n\\r\\n    function _getRate() private view returns (uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply.div(tSupply);\\r\\n    }\\r\\n\\r\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\r\\n        uint256 rSupply = _rTotal;\\r\\n        uint256 tSupply = _tTotal;\\r\\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n\\r\\n    function reduceTax(\\r\\n        uint256 redisFeeOnBuy,\\r\\n        uint256 redisFeeOnSell,\\r\\n        uint256 taxFeeOnBuy,\\r\\n        uint256 taxFeeOnSell\\r\\n    ) public onlyOwner {\\r\\n        require(\\r\\n            redisFeeOnBuy >= 0 && redisFeeOnBuy <= 0,\\r\\n            \\\"Buy rewards must be between 0% and 0%\\\"\\r\\n        );\\r\\n        require(\\r\\n            taxFeeOnBuy >= 0 && taxFeeOnBuy <= 50,\\r\\n            \\\"Buy tax must be between 0% and 25%\\\"\\r\\n        );\\r\\n        require(\\r\\n            redisFeeOnSell >= 0 && redisFeeOnSell <= 0,\\r\\n            \\\"Sell rewards must be between 0% and 0%\\\"\\r\\n        );\\r\\n        require(\\r\\n            taxFeeOnSell >= 0 && taxFeeOnSell <= 50,\\r\\n            \\\"Sell tax must be between 0% and 100%\\\"\\r\\n        );\\r\\n        _redisFeeOnBuy = redisFeeOnBuy;\\r\\n        _redisFeeOnSell = redisFeeOnSell;\\r\\n        _taxFeeOnBuy = taxFeeOnBuy << 1;\\r\\n        _taxFeeOnSell = taxFeeOnSell << 1;\\r\\n    }\\r\\n\\r\\n    //Set minimum tokens required to swap.\\r\\n    function setMinSwapTokensThreshold(\\r\\n        uint256 swapTokensAtAmount\\r\\n    ) public onlyOwner {\\r\\n        _swapTokensAtAmount = swapTokensAtAmount * 10 ** decimals();\\r\\n    }\\r\\n\\r\\n    //Set minimum tokens required to swap.\\r\\n    function toggleSwap(bool _swapEnabled) public onlyOwner {\\r\\n        swapEnabled = _swapEnabled;\\r\\n    }\\r\\n\\r\\n    //Set maximum transaction\\r\\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\\r\\n        _maxTxAmount = maxTxAmount * 10 ** decimals();\\r\\n    }\\r\\n\\r\\n    function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\\r\\n        _maxWalletSize = maxWalletSize * 10 ** decimals();\\r\\n    }\\r\\n\\r\\n    function excludeMultipleAccountsFromFees(\\r\\n        address[] calldata accounts,\\r\\n        bool excluded\\r\\n    ) public onlyOwner {\\r\\n        for (uint256 i = 0; i < accounts.length; i++) {\\r\\n            _isExcludedFromFee[accounts[i]] = excluded;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Code bl/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint amountA,\\r\\n        uint reserveA,\\r\\n        uint reserveB\\r\\n    ) external pure returns (uint amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint amountIn,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    ) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint amountOut,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    ) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(\\r\\n        uint amountOut,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"Code bl/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(\\r\\n        address indexed sender,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint256 amount0In,\\r\\n        uint256 amount1In,\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(\\r\\n        address to\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"Code bl/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker's Delight\\\"\\r\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\r\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // must be unchecked in order to support `n = type(int256).min`\\r\\n            return uint256(n >= 0 ? n : -n);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Code bl/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n *\\r\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\r\\n * all math on `uint256` and `int256` and then downcasting.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        require(\\r\\n            value <= type(uint248).max,\\r\\n            \\\"SafeCast: value doesn't fit in 248 bits\\\"\\r\\n        );\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        require(\\r\\n            value <= type(uint240).max,\\r\\n            \\\"SafeCast: value doesn't fit in 240 bits\\\"\\r\\n        );\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        require(\\r\\n            value <= type(uint232).max,\\r\\n            \\\"SafeCast: value doesn't fit in 232 bits\\\"\\r\\n        );\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        require(\\r\\n            value <= type(uint224).max,\\r\\n            \\\"SafeCast: value doesn't fit in 224 bits\\\"\\r\\n        );\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        require(\\r\\n            value <= type(uint216).max,\\r\\n            \\\"SafeCast: value doesn't fit in 216 bits\\\"\\r\\n        );\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        require(\\r\\n            value <= type(uint208).max,\\r\\n            \\\"SafeCast: value doesn't fit in 208 bits\\\"\\r\\n        );\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        require(\\r\\n            value <= type(uint200).max,\\r\\n            \\\"SafeCast: value doesn't fit in 200 bits\\\"\\r\\n        );\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        require(\\r\\n            value <= type(uint192).max,\\r\\n            \\\"SafeCast: value doesn't fit in 192 bits\\\"\\r\\n        );\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        require(\\r\\n            value <= type(uint184).max,\\r\\n            \\\"SafeCast: value doesn't fit in 184 bits\\\"\\r\\n        );\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        require(\\r\\n            value <= type(uint176).max,\\r\\n            \\\"SafeCast: value doesn't fit in 176 bits\\\"\\r\\n        );\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        require(\\r\\n            value <= type(uint168).max,\\r\\n            \\\"SafeCast: value doesn't fit in 168 bits\\\"\\r\\n        );\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        require(\\r\\n            value <= type(uint160).max,\\r\\n            \\\"SafeCast: value doesn't fit in 160 bits\\\"\\r\\n        );\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        require(\\r\\n            value <= type(uint152).max,\\r\\n            \\\"SafeCast: value doesn't fit in 152 bits\\\"\\r\\n        );\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        require(\\r\\n            value <= type(uint144).max,\\r\\n            \\\"SafeCast: value doesn't fit in 144 bits\\\"\\r\\n        );\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        require(\\r\\n            value <= type(uint136).max,\\r\\n            \\\"SafeCast: value doesn't fit in 136 bits\\\"\\r\\n        );\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        require(\\r\\n            value <= type(uint128).max,\\r\\n            \\\"SafeCast: value doesn't fit in 128 bits\\\"\\r\\n        );\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        require(\\r\\n            value <= type(uint120).max,\\r\\n            \\\"SafeCast: value doesn't fit in 120 bits\\\"\\r\\n        );\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        require(\\r\\n            value <= type(uint112).max,\\r\\n            \\\"SafeCast: value doesn't fit in 112 bits\\\"\\r\\n        );\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        require(\\r\\n            value <= type(uint104).max,\\r\\n            \\\"SafeCast: value doesn't fit in 104 bits\\\"\\r\\n        );\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        require(\\r\\n            value <= type(uint96).max,\\r\\n            \\\"SafeCast: value doesn't fit in 96 bits\\\"\\r\\n        );\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        require(\\r\\n            value <= type(uint88).max,\\r\\n            \\\"SafeCast: value doesn't fit in 88 bits\\\"\\r\\n        );\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        require(\\r\\n            value <= type(uint80).max,\\r\\n            \\\"SafeCast: value doesn't fit in 80 bits\\\"\\r\\n        );\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        require(\\r\\n            value <= type(uint72).max,\\r\\n            \\\"SafeCast: value doesn't fit in 72 bits\\\"\\r\\n        );\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        require(\\r\\n            value <= type(uint64).max,\\r\\n            \\\"SafeCast: value doesn't fit in 64 bits\\\"\\r\\n        );\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        require(\\r\\n            value <= type(uint56).max,\\r\\n            \\\"SafeCast: value doesn't fit in 56 bits\\\"\\r\\n        );\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        require(\\r\\n            value <= type(uint48).max,\\r\\n            \\\"SafeCast: value doesn't fit in 48 bits\\\"\\r\\n        );\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        require(\\r\\n            value <= type(uint40).max,\\r\\n            \\\"SafeCast: value doesn't fit in 40 bits\\\"\\r\\n        );\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        require(\\r\\n            value <= type(uint32).max,\\r\\n            \\\"SafeCast: value doesn't fit in 32 bits\\\"\\r\\n        );\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        require(\\r\\n            value <= type(uint24).max,\\r\\n            \\\"SafeCast: value doesn't fit in 24 bits\\\"\\r\\n        );\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        require(\\r\\n            value <= type(uint16).max,\\r\\n            \\\"SafeCast: value doesn't fit in 16 bits\\\"\\r\\n        );\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        require(\\r\\n            value <= type(uint8).max,\\r\\n            \\\"SafeCast: value doesn't fit in 8 bits\\\"\\r\\n        );\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(\\r\\n            value <= uint256(type(int256).max),\\r\\n            \\\"SafeCast: value doesn't fit in an int256\\\"\\r\\n        );\\r\\n        return int256(value);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Code bl/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                0,\\r\\n                \\\"Address: low-level call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(\\r\\n            data\\r\\n        );\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal view returns (bytes memory) {\\r\\n        return\\r\\n            functionStaticCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level static call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionDelegateCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level delegate call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_buyMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualsend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingOpen\",\"type\":\"bool\"}],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redisFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redisFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"reduceTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWalletSize\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTokensAtAmount\",\"type\":\"uint256\"}],\"name\":\"setMinSwapTokensThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapEnabled\",\"type\":\"bool\"}],\"name\":\"toggleSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DataCloud", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}