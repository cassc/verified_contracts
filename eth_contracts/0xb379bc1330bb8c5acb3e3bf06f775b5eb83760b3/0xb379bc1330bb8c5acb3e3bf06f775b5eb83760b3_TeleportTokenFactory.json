{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/teleporteth/contracts/TeleportTokenFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\n/*\\n * SPDX-License-Identifier: MIT\\n */\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./Owner.sol\\\";\\nimport \\\"./TeleportToken.sol\\\";\\n\\ncontract Oracled is Owned {\\n    mapping(address => bool) public oracles;\\n    address[] internal oraclesArr;\\n\\n    modifier onlyOracle() {\\n        require(\\n            oracles[msg.sender] == true,\\n            \\\"Account is not a registered oracle\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    function regOracle(address _newOracle) public onlyOwner {\\n        require(!oracles[_newOracle], \\\"Oracle is already registered\\\");\\n        oraclesArr.push(_newOracle);\\n        oracles[_newOracle] = true;\\n    }\\n\\n    function unregOracle(address _remOracle) public onlyOwner {\\n        require(oracles[_remOracle] == true, \\\"Oracle is not registered\\\");\\n\\n        delete oracles[_remOracle];\\n    }\\n}\\n\\ncontract TeleportTokenFactory is Owned, Oracled {\\n    TeleportToken[] public teleporttokens;\\n    uint256 public creationFee = 0.01 ether;\\n\\n    // Payable constructor can receive Ether\\n    constructor() payable {}\\n\\n    function isOracle(address _address) public view returns (bool) {\\n        return oracles[_address];\\n    }\\n\\n    // Function to deposit Ether into this contract.\\n    // Call this function along with some Ether.\\n    // The balance of this contract will be automatically updated.\\n    function deposit() public payable {}\\n\\n    // Call this function along with some Ether.\\n    // The function will throw an error since this function is not payable.\\n    function notPayable() public {}\\n\\n    // Function to withdraw all Ether from this contract.\\n    function withdraw() public onlyOwner {\\n        // get the amount of Ether stored in this contract\\n        uint256 amount = address(this).balance;\\n\\n        // send all Ether to owner\\n        // Owner can receive Ether since the address of owner is payable\\n        (bool success, ) = owner.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Failed to send Ether\\\");\\n    }\\n\\n    // Function to receive Ether. msg.data must be empty\\n    receive() external payable {}\\n\\n    // Fallback function is called when msg.data is not empty\\n    fallback() external payable {}\\n\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function create(\\n        string memory _symbol,\\n        string memory _name,\\n        uint8 _decimals,\\n        uint256 __totalSupply,\\n        uint8 _threshold,\\n        uint8 _thisChainId\\n    ) public payable {\\n        // correct fee\\n        require(msg.value == creationFee, \\\"Wrong fee\\\");\\n        TeleportToken tt = new TeleportToken(\\n            _symbol,\\n            _name,\\n            _decimals,\\n            __totalSupply,\\n            _threshold,\\n            _thisChainId\\n        );\\n\\n        tt.transferOwnership(msg.sender);\\n\\n        teleporttokens.push(tt);\\n    }\\n\\n    function getTokenAddress(\\n        uint256 _index\\n    ) public view returns (address ttAddress) {\\n        TeleportToken tt = teleporttokens[_index];\\n\\n        return (address(tt));\\n    }\\n\\n    function setFee(uint256 _fee) public onlyOwner {\\n        creationFee = _fee;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/teleporteth/contracts/TeleportToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\n/*\\n * SPDX-License-Identifier: MIT\\n */\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./Owner.sol\\\";\\nimport {TeleportTokenFactory} from \\\"./TeleportTokenFactory.sol\\\";\\n\\ncontract Verify {\\n    function recoverSigner(bytes32 message, bytes memory sig)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        (v, r, s) = splitSignature(sig);\\n\\n        if (v != 27 && v != 28) {\\n            return (address(0));\\n        } else {\\n            // solium-disable-next-line arg-overflow\\n            return ecrecover(message, v, r, s);\\n        }\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n        public\\n        pure\\n        returns (\\n            uint8,\\n            bytes32,\\n            bytes32\\n        )\\n    {\\n        require(sig.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        if (v < 27) v += 27;\\n\\n        return (v, r, s);\\n    }\\n}\\n\\nlibrary Endian {\\n    /* https://ethereum.stackexchange.com/questions/83626/how-to-reverse-byte-order-in-uint256-or-bytes32 */\\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) | ((v & 0x00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) | ((v & 0x0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = (v >> 32) | (v << 32);\\n    }\\n\\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = (v >> 16) | (v << 16);\\n    }\\n\\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = (v >> 8) | (v << 8);\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        require(c >= a);\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        require(b <= a);\\n        c = a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        require(b > 0);\\n        c = a / b;\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC Token Standard #20 Interface\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n// ----------------------------------------------------------------------------\\nabstract contract ERC20Interface {\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        public\\n        virtual\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        public\\n        virtual\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) public virtual returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\\n    event Approval(\\n        address indexed tokenOwner,\\n        address indexed spender,\\n        uint256 tokens\\n    );\\n}\\n\\n// ----------------------------------------------------------------------------\\n// Contract function to receive approval and execute function in one call\\n//\\n// Borrowed from MiniMeToken\\n// ----------------------------------------------------------------------------\\nabstract contract ApproveAndCallFallBack {\\n    function receiveApproval(\\n        address from,\\n        uint256 tokens,\\n        address token,\\n        bytes memory data\\n    ) public virtual;\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of symbol, name and decimals and an\\n// initial fixed supply, added teleport method\\n// ----------------------------------------------------------------------------\\ncontract TeleportToken is ERC20Interface, Owned, Verify {\\n    TeleportTokenFactory factory;\\n\\n    using SafeMath for uint256;\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public decimals;\\n    uint256 public _totalSupply;\\n    uint8 public threshold;\\n    uint8 public thisChainId;\\n\\n    mapping(address => uint256) balances;\\n    mapping(address => mapping(address => uint256)) allowed;\\n\\n    mapping(uint64 => mapping(address => bool)) signed;\\n    mapping(uint64 => bool) public claimed;\\n\\n    event Teleport(\\n        address indexed from,\\n        string to,\\n        uint256 tokens,\\n        uint256 chainId\\n    );\\n    event Claimed(\\n        uint64 id,\\n        address toAddress,\\n        address tokenAddress,\\n        uint256 amount\\n    );\\n\\n    struct TeleportData {\\n        uint64 id;\\n        uint32 ts;\\n        uint64 fromAddr;\\n        uint256 quantity;\\n        uint64 symbolRaw;\\n        uint8 chainId;\\n        address toAddress;\\n        address tokenAddress;\\n        uint8 nativeDecimals;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(\\n        string memory _symbol,\\n        string memory _name,\\n        uint8 _decimals,\\n        uint256 __totalSupply,\\n        uint8 _threshold,\\n        uint8 _thisChainId\\n    ) {\\n        symbol = _symbol;\\n        name = _name;\\n        decimals = _decimals;\\n        _totalSupply = __totalSupply * 10**uint256(_decimals);\\n        balances[address(0)] = _totalSupply;\\n        threshold = _threshold;\\n        thisChainId = _thisChainId;\\n        factory = TeleportTokenFactory(payable(address(msg.sender)));\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply - balances[address(0)];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner)\\n        public\\n        view\\n        override\\n        returns (uint256 balance)\\n    {\\n        return balances[tokenOwner];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner's account to `to` account\\n    // - Owner's account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint256 tokens)\\n        public\\n        override\\n        returns (bool success)\\n    {\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n        balances[to] = balances[to].add(tokens);\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner's account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces\\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint256 tokens)\\n        public\\n        override\\n        returns (bool success)\\n    {\\n        allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    //\\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) public override returns (bool success) {\\n        balances[from] = balances[from].sub(tokens);\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n        balances[to] = balances[to].add(tokens);\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender's account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender)\\n        public\\n        view\\n        override\\n        returns (uint256 remaining)\\n    {\\n        return allowed[tokenOwner][spender];\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner's account. The `spender` contract function\\n    // `receiveApproval(...)` is then executed\\n    // ------------------------------------------------------------------------\\n    function approveAndCall(\\n        address spender,\\n        uint256 tokens,\\n        bytes memory data\\n    ) public returns (bool success) {\\n        allowed[msg.sender][spender] = tokens;\\n        emit Approval(msg.sender, spender, tokens);\\n        ApproveAndCallFallBack(spender).receiveApproval(\\n            msg.sender,\\n            tokens,\\n            address(this),\\n            data\\n        );\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Moves tokens to the inaccessible account and then sends event for the oracles\\n    // to monitor and issue on other chain\\n    // to : EOS address\\n    // tokens : number of tokens in satoshis\\n    // chainId : The chain id that they will be sent to\\n    // ------------------------------------------------------------------------\\n\\n    function teleport(\\n        string memory to,\\n        uint256 tokens,\\n        uint256 chainid\\n    ) public returns (bool success) {\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n        balances[address(0)] = balances[address(0)].add(tokens);\\n\\n        emit Transfer(msg.sender, address(0), tokens);\\n        emit Teleport(msg.sender, to, tokens, chainid);\\n\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Claim tokens sent using signatures supplied to the other chain\\n    // ------------------------------------------------------------------------\\n\\n    function stringToBytes32(string memory source)\\n        public\\n        pure\\n        returns (bytes32 result)\\n    {\\n        bytes memory tempEmptyStringTest = bytes(source);\\n        if (tempEmptyStringTest.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            result := mload(add(source, 32))\\n        }\\n    }\\n\\n    function verifySigData(bytes memory sigData)\\n        private\\n        returns (TeleportData memory)\\n    {\\n        TeleportData memory td;\\n\\n        uint64 id;\\n        uint32 ts;\\n        uint64 fromAddr;\\n        uint64 quantity;\\n        uint64 symbolRaw;\\n        uint8 chainId;\\n        address toAddress;\\n        address tokenAddress;\\n        uint8 nativeDecimals;\\n        // uint64 requiredSymbolRaw;\\n\\n        assembly {\\n            id := mload(add(add(sigData, 0x8), 0))\\n            ts := mload(add(add(sigData, 0x4), 8))\\n            fromAddr := mload(add(add(sigData, 0x8), 12))\\n            quantity := mload(add(add(sigData, 0x8), 20))\\n            symbolRaw := mload(add(add(sigData, 0x8), 29))\\n            chainId := mload(add(add(sigData, 0x1), 36))\\n            toAddress := mload(add(add(sigData, 0x14), 37))\\n            tokenAddress := mload(add(add(sigData, 0x14), 70))\\n            nativeDecimals := mload(add(add(sigData, 0x1), 90))\\n        }\\n        td.id = Endian.reverse64(id);\\n        td.ts = Endian.reverse32(ts);\\n        td.fromAddr = Endian.reverse64(fromAddr);\\n        td.symbolRaw = Endian.reverse64(symbolRaw);\\n        td.chainId = chainId;\\n        td.toAddress = toAddress;\\n        td.tokenAddress = tokenAddress;\\n        td.nativeDecimals = nativeDecimals;\\n        td.quantity =\\n            Endian.reverse64(quantity) *\\n            10**(decimals - nativeDecimals);\\n\\n        // requiredSymbolRaw = uint64(\\n        //     bytes8(stringToBytes32(TeleportToken.symbol))\\n        // );\\n        // require(requiredSymbolRaw == symbolRaw - td.chainId, \\\"Wrong symbol\\\");\\n        require(address(this) == td.tokenAddress, \\\"Invalid token address\\\");\\n        require(thisChainId == td.chainId, \\\"Invalid Chain ID\\\");\\n        require(\\n            block.timestamp < SafeMath.add(td.ts, (60 * 60 * 24 * 30)),\\n            \\\"Teleport has expired\\\"\\n        );\\n        require(!claimed[td.id], \\\"Already Claimed\\\");\\n\\n        claimed[td.id] = true;\\n\\n        return td;\\n    }\\n\\n    function claim(bytes memory sigData, bytes[] calldata signatures)\\n        public\\n        returns (address toAddress)\\n    {\\n        TeleportData memory td = verifySigData(sigData);\\n\\n        // verify signatures\\n        require(sigData.length == 91, \\\"Signature data is the wrong size\\\");\\n        require(\\n            signatures.length <= 10,\\n            \\\"Maximum of 10 signatures can be provided\\\"\\n        );\\n\\n        bytes32 message = keccak256(sigData);\\n\\n        uint8 numberSigs = 0;\\n\\n        for (uint8 i = 0; i < signatures.length; i++) {\\n            address potential = Verify.recoverSigner(message, signatures[i]);\\n\\n            // console.log(potential);\\n            // console.log(oracles[potential]);\\n            // Check that they are an oracle and they haven't signed twice\\n            if (factory.isOracle(potential) && !signed[td.id][potential]) {\\n                signed[td.id][potential] = true;\\n                numberSigs++;\\n\\n                if (numberSigs >= threshold) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        require(\\n            numberSigs >= threshold,\\n            \\\"Not enough valid signatures provided\\\"\\n        );\\n\\n        balances[address(0)] = balances[address(0)].sub(td.quantity);\\n        balances[td.toAddress] = balances[td.toAddress].add(td.quantity);\\n\\n        emit Claimed(td.id, td.toAddress, td.tokenAddress, td.quantity);\\n        emit Transfer(address(0), td.toAddress, td.quantity);\\n\\n        return td.toAddress;\\n    }\\n\\n    function updateThreshold(uint8 newThreshold)\\n        public\\n        onlyOwner\\n        returns (bool success)\\n    {\\n        if (newThreshold > 0) {\\n            require(newThreshold <= 10, \\\"Threshold has maximum of 10\\\");\\n\\n            threshold = newThreshold;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function updateChainId(uint8 newChainId)\\n        public\\n        onlyOwner\\n        returns (bool success)\\n    {\\n        if (newChainId > 0) {\\n            require(newChainId <= 100, \\\"ChainID is too big\\\");\\n            thisChainId = newChainId;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don't accept ETH\\n    // ------------------------------------------------------------------------\\n    receive() external payable {\\n        revert();\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n    // ------------------------------------------------------------------------\\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens)\\n        public\\n        onlyOwner\\n        returns (bool success)\\n    {\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/teleporteth/contracts/Owner.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\n\\n/*\\n * SPDX-License-Identifier: MIT\\n */\\n\\n// ----------------------------------------------------------------------------\\n// Owned contract\\n// ----------------------------------------------------------------------------\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() public {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"__totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_thisChainId\",\"type\":\"uint8\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ttAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notPayable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"regOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teleporttokens\",\"outputs\":[{\"internalType\":\"contract TeleportToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_remOracle\",\"type\":\"address\"}],\"name\":\"unregOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TeleportTokenFactory", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}