{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20Locker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface PriceFeedInterface {\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./LockerPass.sol\\\";\\n\\ncontract ERC20Locker {\\n    mapping(uint256 => DepositData) public deposits;\\n    LockerPass public lockerPass;\\n\\n    struct DepositData {\\n        address token;\\n        uint256 createdAt;\\n        uint256 lockForDays;\\n        int256 minExpectedPrice;\\n        int256 pricePrecision;\\n        address priceFeed;\\n        uint256 balance;\\n    }\\n\\n    modifier onlyDepositOwner(address _account, uint256 _depositId) {\\n        require(lockerPass.ownerOf(_depositId) == _account, \\\"Access denied\\\");\\n        require(deposits[_depositId].createdAt != 0, ERRNOTCONFIGURED);\\n        _;\\n    }\\n\\n    modifier onlyConfigured(uint256 _depositId) {\\n        require(deposits[_depositId].createdAt != 0, ERRNOTCONFIGURED);\\n        _;\\n    }\\n\\n    address private constant ZERO_ADDRESS = address(0x0);\\n    string private constant ERRBADCONFIG = \\\"Invalid price configuration\\\";\\n    string private constant ERRNOTCONFIGURED = \\\"Deposit not configured.\\\";\\n\\n    constructor() {\\n        lockerPass = new LockerPass(address(this), \\\"ERC20LockerPass\\\", \\\"LOP\\\");\\n    }\\n\\n    function configureDepositWithPrice(\\n        address _token,\\n        uint256 _lockForDays,\\n        address _priceFeed,\\n        int256 _minExpectedPrice,\\n        int256 _pricePrecision\\n    ) public {\\n        require(_minExpectedPrice >= 0, \\\"Invalid minExpectedPrice value.\\\");\\n        require(_lockForDays > 0, \\\"Invalid lockForDays value.\\\");\\n\\n        // check feed address interface\\n        if (_minExpectedPrice == 0) {\\n            require(_priceFeed == ZERO_ADDRESS, ERRBADCONFIG);\\n        } else {\\n            require(_priceFeed != ZERO_ADDRESS, ERRBADCONFIG);\\n            // check feed address interface\\n            PriceFeedInterface(_priceFeed).latestRoundData();\\n        }\\n\\n        DepositData memory newDeposit = DepositData({\\n            token: _token,\\n            createdAt: block.timestamp,\\n            minExpectedPrice: _minExpectedPrice,\\n            pricePrecision: _pricePrecision,\\n            priceFeed: _priceFeed,\\n            balance: 0,\\n            lockForDays: _lockForDays\\n        });\\n\\n        uint256 newDepositId = lockerPass.nextId();\\n        lockerPass.mint(msg.sender);\\n        deposits[newDepositId] = newDeposit;\\n    }\\n\\n    function configureDeposit(address _token, uint256 _lockForDays) external {\\n        configureDepositWithPrice(_token, _lockForDays, ZERO_ADDRESS, 0, 0);\\n    }\\n\\n    function deposit(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _depositId\\n    ) external onlyDepositOwner(msg.sender, _depositId) {\\n        DepositData storage depositData = deposits[_depositId];\\n\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n        depositData.balance = depositData.balance + _amount;\\n    }\\n\\n    function canWithdraw(\\n        uint256 _depositId\\n    ) public view onlyConfigured(_depositId) returns (bool) {\\n        DepositData memory depositData = deposits[_depositId];\\n\\n        uint256 releaseAt = depositData.createdAt +\\n            (depositData.lockForDays * 1 days);\\n\\n        if (releaseAt < block.timestamp) {\\n            return true;\\n        } else if (depositData.minExpectedPrice == 0) {\\n            return false;\\n        } else if (depositData.minExpectedPrice < getPrice(_depositId)) {\\n            return true;\\n        } else return false;\\n    }\\n\\n    function withdraw(\\n        uint256 _depositId\\n    ) external onlyDepositOwner(msg.sender, _depositId) {\\n        require(canWithdraw(_depositId), \\\"You cannot withdraw yet!\\\");\\n\\n        DepositData memory depositData = deposits[_depositId];\\n        uint256 balance = depositData.balance;\\n\\n        delete deposits[_depositId];\\n        lockerPass.burn(_depositId);\\n\\n        IERC20(depositData.token).transfer(msg.sender, balance);\\n    }\\n\\n    function increaseMinExpectedPrice(\\n        int256 _newMinExpectedPrice,\\n        uint256 _depositId\\n    ) external onlyDepositOwner(msg.sender, _depositId) {\\n        DepositData storage depositData = deposits[_depositId];\\n\\n        require(\\n            depositData.minExpectedPrice != 0,\\n            \\\"minExpectedPrice not configured!\\\"\\n        );\\n\\n        require(\\n            depositData.minExpectedPrice < _newMinExpectedPrice,\\n            \\\"New price value invalid!\\\"\\n        );\\n\\n        depositData.minExpectedPrice = _newMinExpectedPrice;\\n    }\\n\\n    function increaseLockForDays(\\n        uint256 _newLockForDays,\\n        uint256 _depositId\\n    ) external onlyDepositOwner(msg.sender, _depositId) {\\n        DepositData storage depositData = deposits[_depositId];\\n\\n        require(\\n            depositData.lockForDays < _newLockForDays,\\n            \\\"New lockForDays value invalid!\\\"\\n        );\\n\\n        depositData.lockForDays = _newLockForDays;\\n    }\\n\\n    function checkPriceFeed(\\n        address _feedAddress,\\n        int256 _precision\\n    ) external view returns (int256) {\\n        (, int256 price, , , ) = PriceFeedInterface(_feedAddress)\\n            .latestRoundData();\\n        return price / _precision;\\n    }\\n\\n    function getPrice(\\n        uint256 _depositId\\n    ) public view onlyConfigured(_depositId) returns (int256) {\\n        DepositData memory depositData = deposits[_depositId];\\n\\n        if (depositData.priceFeed == ZERO_ADDRESS) {\\n            return 0;\\n        }\\n\\n        (, int256 price, , , ) = PriceFeedInterface(depositData.priceFeed)\\n            .latestRoundData();\\n        return price / depositData.pricePrecision;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LockerPass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC721 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address operator);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ncontract LockerPass is IERC721 {\\n    address public admin;\\n    uint256 public nextId = 0;\\n    string public name;\\n    string public symbol;\\n    mapping(uint256 => bool) public isFrozen;\\n    mapping(uint256 => address) private _owners;\\n    mapping(address => uint256) private _balances;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    error ERC721NonexistentToken(uint256 tokenId);\\n    error ERC721InvalidReceiver(address receiver);\\n    error ERC721InvalidAddress(address target);\\n\\n    modifier requireMinted(uint256 _tokenId) {\\n        if (_ownerOf(_tokenId) == address(0)) {\\n            revert ERC721NonexistentToken(_tokenId);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Access denied!\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner(uint256 _tokenId) {\\n        require(_ownerOf(_tokenId) == msg.sender, \\\"Access denied!\\\");\\n        _;\\n    }\\n\\n    constructor(address _admin, string memory _name, string memory _symbol) {\\n        admin = _admin;\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    function balanceOf(address _owner) external view returns (uint256) {\\n        if (_owner == address(0)) {\\n            revert ERC721InvalidAddress(_owner);\\n        }\\n\\n        return _balances[_owner];\\n    }\\n\\n    function ownerOf(uint256 _tokenId) external view returns (address) {\\n        return _ownerOf(_tokenId);\\n    }\\n\\n    function _ownerOf(uint256 _tokenId) internal view returns (address) {\\n        return _owners[_tokenId];\\n    }\\n\\n    function mint(address _to) external onlyAdmin {\\n        _owners[nextId] = _to;\\n        unchecked {\\n            _balances[_to] += 1;\\n        }\\n\\n        nextId = nextId + 1;\\n    }\\n\\n    function burn(uint256 _tokenId) external requireMinted(_tokenId) onlyAdmin {\\n        address owner = _ownerOf(_tokenId);\\n        _balances[owner] -= 1;\\n        _owners[_tokenId] = address(0);\\n    }\\n\\n    function approve(\\n        address _to,\\n        uint256 _tokenId\\n    ) external requireMinted(_tokenId) onlyOwner(_tokenId) {\\n        emit Approval(msg.sender, _to, _tokenId);\\n        _tokenApprovals[_tokenId] = _to;\\n    }\\n\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view requireMinted(_tokenId) returns (address) {\\n        return _tokenApprovals[_tokenId];\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved) public {\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n        _operatorApprovals[msg.sender][_operator] = _approved;\\n    }\\n\\n    function isApprovedForAll(\\n        address _owner,\\n        address _operator\\n    ) external view returns (bool) {\\n        return _operatorApprovals[_owner][_operator];\\n    }\\n\\n    function freeze(\\n        uint256 _tokenId\\n    ) public requireMinted(_tokenId) onlyOwner(_tokenId) {\\n        require(isFrozen[_tokenId] == false, \\\"Token is already frozen!\\\");\\n        isFrozen[_tokenId] = true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\\n        require(!isFrozen[_tokenId], \\\"Token is frozen!\\\");\\n\\n        if (_to == address(0)) {\\n            revert ERC721InvalidReceiver(_to);\\n        }\\n        _checkAuthorized(msg.sender, _tokenId);\\n\\n        if (_from != address(0)) {\\n            unchecked {\\n                _balances[_from] -= 1;\\n            }\\n        }\\n\\n        if (_to != address(0)) {\\n            unchecked {\\n                _balances[_to] += 1;\\n            }\\n        }\\n\\n        emit Transfer(_from, _to, _tokenId);\\n        _owners[_tokenId] = _to;\\n    }\\n\\n    function transferFromAndFreeze(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) public onlyOwner(_tokenId) {\\n        transferFrom(_from, _to, _tokenId);\\n        isFrozen[_tokenId] = true;\\n    }\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) public {\\n        _checkOnERC721Received(_from, _to, _tokenId, \\\"\\\");\\n        transferFrom(_from, _to, _tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    ) public {\\n        _checkOnERC721Received(_from, _to, _tokenId, _data);\\n        transferFrom(_from, _to, _tokenId);\\n    }\\n\\n    function safeTransferFromAndFreeze(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external onlyOwner(_tokenId) {\\n        safeTransferFrom(_from, _to, _tokenId);\\n        isFrozen[_tokenId] = true;\\n    }\\n\\n    function safeTransferFromAndFreeze(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    ) external onlyOwner(_tokenId) {\\n        safeTransferFrom(_from, _to, _tokenId, _data);\\n        isFrozen[_tokenId] = true;\\n    }\\n\\n    function _checkAuthorized(\\n        address _operator,\\n        uint256 _tokenId\\n    ) internal view {\\n        address tokenOwner = _owners[_tokenId];\\n        bool isOwner = tokenOwner == _operator;\\n        bool isApproved = _tokenApprovals[_tokenId] == _operator;\\n        bool approvedForAll = _operatorApprovals[tokenOwner][_operator];\\n        require(isOwner || isApproved || approvedForAll, \\\"Access denied\\\");\\n    }\\n\\n    function _checkOnERC721Received(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) private {\\n        if (_to.code.length > 0) {\\n            try\\n                IERC721Receiver(_to).onERC721Received(\\n                    msg.sender,\\n                    _from,\\n                    _tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    revert ERC721InvalidReceiver(_to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721InvalidReceiver(_to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feedAddress\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_precision\",\"type\":\"int256\"}],\"name\":\"checkPriceFeed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockForDays\",\"type\":\"uint256\"}],\"name\":\"configureDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockForDays\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_minExpectedPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_pricePrecision\",\"type\":\"int256\"}],\"name\":\"configureDepositWithPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockForDays\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minExpectedPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"pricePrecision\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLockForDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"increaseLockForDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_newMinExpectedPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"increaseMinExpectedPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockerPass\",\"outputs\":[{\"internalType\":\"contract LockerPass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20Locker", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}