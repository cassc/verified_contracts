{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/payments/PaymentHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IPaymentHelper } from \\\"src/interfaces/IPaymentHelper.sol\\\";\\nimport { ISuperRBAC } from \\\"src/interfaces/ISuperRBAC.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { ISuperformFactory } from \\\"src/interfaces/ISuperformFactory.sol\\\";\\nimport { IBaseStateRegistry } from \\\"src/interfaces/IBaseStateRegistry.sol\\\";\\nimport { IAmbImplementation } from \\\"src/interfaces/IAmbImplementation.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport { DataLib } from \\\"src/libraries/DataLib.sol\\\";\\nimport { ProofLib } from \\\"src/libraries/ProofLib.sol\\\";\\nimport { ArrayCastLib } from \\\"src/libraries/ArrayCastLib.sol\\\";\\nimport {\\n    SingleDirectSingleVaultStateReq,\\n    SingleXChainSingleVaultStateReq,\\n    SingleDirectMultiVaultStateReq,\\n    SingleXChainMultiVaultStateReq,\\n    MultiDstSingleVaultStateReq,\\n    MultiDstMultiVaultStateReq,\\n    LiqRequest,\\n    AMBMessage,\\n    MultiVaultSFData,\\n    SingleVaultSFData,\\n    AMBExtraData,\\n    InitMultiVaultData,\\n    InitSingleVaultData,\\n    ReturnMultiData,\\n    ReturnSingleData\\n} from \\\"src/types/DataTypes.sol\\\";\\nimport { AggregatorV3Interface } from \\\"src/vendor/chainlink/AggregatorV3Interface.sol\\\";\\n\\n/// @dev interface to read public variable from state registry\\ninterface ReadOnlyBaseRegistry is IBaseStateRegistry {\\n    function payloadsCount() external view returns (uint256);\\n}\\n\\n/// @title PaymentHelper\\n/// @dev Helps estimate the cost for the entire transaction lifecycle\\n/// @author ZeroPoint Labs\\ncontract PaymentHelper is IPaymentHelper {\\n    using DataLib for uint256;\\n    using ArrayCastLib for LiqRequest;\\n    using ArrayCastLib for bool;\\n    using ProofLib for bytes;\\n    using ProofLib for AMBMessage;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    uint256 private constant PROOF_LENGTH = 160;\\n    uint8 private constant SUPPORTED_FEED_PRECISION = 8;\\n    uint32 private constant TIMELOCK_FORM_ID = 2;\\n    uint256 private constant MAX_UINT256 = type(uint256).max;\\n\\n    ISuperRegistry public immutable superRegistry;\\n    uint64 public immutable CHAIN_ID;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev xchain params\\n    mapping(uint64 chainId => AggregatorV3Interface) public nativeFeedOracle;\\n    mapping(uint64 chainId => AggregatorV3Interface) public gasPriceOracle;\\n    mapping(uint64 chainId => uint256 gasForSwap) public swapGasUsed;\\n    mapping(uint64 chainId => uint256 gasForUpdate) public updateGasUsed;\\n    mapping(uint64 chainId => uint256 gasForDeposit) public depositGasUsed;\\n    mapping(uint64 chainId => uint256 gasForWithdraw) public withdrawGasUsed;\\n    mapping(uint64 chainId => uint256 defaultNativePrice) public nativePrice;\\n    mapping(uint64 chainId => uint256 defaultGasPrice) public gasPrice;\\n    mapping(uint64 chainId => uint256 gasPerByte) public gasPerByte;\\n    mapping(uint64 chainId => uint256 gasForAck) public ackGasCost;\\n    mapping(uint64 chainId => uint256 gasForTimelock) public timelockCost;\\n    mapping(uint64 chainId => uint256 gasForEmergency) public emergencyCost;\\n\\n    /// @dev register transmuter params\\n    bytes public extraDataForTransmuter;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct EstimateAckCostVars {\\n        uint256 currPayloadId;\\n        uint256 payloadHeader;\\n        uint8 callbackType;\\n        bytes payloadBody;\\n        uint8[] ackAmbIds;\\n        uint8 isMulti;\\n        uint64 srcChainId;\\n        bytes message;\\n    }\\n\\n    struct LocalEstimateVars {\\n        uint256 len;\\n        uint256 superformIdsLen;\\n        uint256 totalDstGas;\\n        uint256 ambFees;\\n        bool paused;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlyProtocolAdmin() {\\n        if (!ISuperRBAC(_getAddress(keccak256(\\\"SUPER_RBAC\\\"))).hasProtocolAdminRole(msg.sender)) {\\n            revert Error.NOT_PROTOCOL_ADMIN();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEmergencyAdmin() {\\n        if (!ISuperRBAC(_getAddress(keccak256(\\\"SUPER_RBAC\\\"))).hasEmergencyAdminRole(msg.sender)) {\\n            revert Error.NOT_EMERGENCY_ADMIN();\\n        }\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(address superRegistry_) {\\n        if (superRegistry_ == address(0)) {\\n            revert Error.ZERO_ADDRESS();\\n        }\\n\\n        if (block.chainid > type(uint64).max) {\\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n        }\\n\\n        CHAIN_ID = uint64(block.chainid);\\n        superRegistry = ISuperRegistry(superRegistry_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IPaymentHelper\\n    function calculateAMBData(\\n        uint64 dstChainId_,\\n        uint8[] calldata ambIds_,\\n        bytes memory message_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 totalFees, bytes memory extraData)\\n    {\\n        (uint256[] memory gasPerAMB, bytes[] memory extraDataPerAMB, uint256 fees) =\\n            _estimateAMBFeesReturnExtraData(dstChainId_, ambIds_, message_);\\n\\n        extraData = abi.encode(AMBExtraData(gasPerAMB, extraDataPerAMB));\\n        totalFees = fees;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function getRegisterTransmuterAMBData() external view override returns (bytes memory) {\\n        return extraDataForTransmuter;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateMultiDstMultiVault(\\n        MultiDstMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount)\\n    {\\n        LocalEstimateVars memory v;\\n        v.len = req_.dstChainIds.length;\\n\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n        for (uint256 i; i < v.len; ++i) {\\n            bool xChain = req_.dstChainIds[i] != CHAIN_ID;\\n\\n            v.totalDstGas = 0;\\n\\n            /// @dev step 1: estimate amb costs\\n            v.ambFees = xChain\\n                ? _estimateAMBFees(req_.ambIds[i], req_.dstChainIds[i], _generateMultiVaultMessage(req_.superformsData[i]))\\n                : 0;\\n\\n            v.superformIdsLen = req_.superformsData[i].superformIds.length;\\n\\n            srcAmount += v.ambFees;\\n\\n            if (isDeposit_) {\\n                /// @dev step 2: estimate liq amount\\n                liqAmount += _estimateLiqAmount(req_.superformsData[i].liqRequests);\\n\\n                if (xChain) {\\n                    /// @dev step 3: estimate update cost (only for deposit)\\n                    v.totalDstGas += _estimateUpdateCost(req_.dstChainIds[i], v.superformIdsLen);\\n\\n                    uint256 ackLen;\\n                    for (uint256 j; j < v.superformIdsLen; ++j) {\\n                        if (!req_.superformsData[i].retain4626s[j]) ++ackLen;\\n                    }\\n                    /// @dev step 4: estimation processing cost of acknowledgement on source\\n                    srcAmount += _estimateAckProcessingCost(v.superformIdsLen);\\n\\n                    /// @dev step 5: estimate dst swap cost if it exists\\n                    v.totalDstGas += _estimateSwapFees(req_.dstChainIds[i], req_.superformsData[i].hasDstSwaps);\\n                }\\n            } else {\\n                /// @dev step 6: estimate if timelock form processing costs are involved\\n                for (uint256 j; j < v.superformIdsLen; ++j) {\\n                    (, uint32 formId,) = req_.superformsData[i].superformIds[j].getSuperform();\\n                    v.paused = factory.isFormImplementationPaused(formId);\\n\\n                    if (!v.paused && formId == TIMELOCK_FORM_ID) {\\n                        v.totalDstGas += timelockCost[req_.dstChainIds[i]];\\n                    } else if (v.paused) {\\n                        v.totalDstGas += emergencyCost[req_.dstChainIds[i]];\\n                    }\\n                }\\n            }\\n\\n            /// @dev step 7: estimate execution costs in destination including sending acknowledgement to source\\n            /// @dev ensure that acknowledgement costs from dst to src are not double counted\\n            v.totalDstGas += xChain ? _estimateDstExecutionCost(isDeposit_, req_.dstChainIds[i], v.superformIdsLen) : 0;\\n\\n            /// @dev step 8: convert all dst gas estimates to src chain estimate  (withdraw / deposit)\\n            dstAmount += _convertToNativeFee(req_.dstChainIds[i], v.totalDstGas);\\n        }\\n\\n        totalAmount = srcAmount + dstAmount + liqAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateMultiDstSingleVault(\\n        MultiDstSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount)\\n    {\\n        uint256 len = req_.dstChainIds.length;\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n\\n        for (uint256 i; i < len; ++i) {\\n            bool xChain = req_.dstChainIds[i] != CHAIN_ID;\\n            uint256 totalDstGas;\\n\\n            /// @dev step 1: estimate amb costs\\n            uint256 ambFees = xChain\\n                ? _estimateAMBFees(req_.ambIds[i], req_.dstChainIds[i], _generateSingleVaultMessage(req_.superformsData[i]))\\n                : 0;\\n\\n            srcAmount += ambFees;\\n\\n            if (isDeposit_) {\\n                /// @dev step 2: estimate the liqAmount\\n                liqAmount += _estimateLiqAmount(req_.superformsData[i].liqRequest.castLiqRequestToArray());\\n\\n                if (xChain) {\\n                    /// @dev step 3: estimate update cost (only for deposit)\\n                    totalDstGas += _estimateUpdateCost(req_.dstChainIds[i], 1);\\n\\n                    /// @dev step 4: estimation execution cost of acknowledgement on source\\n                    if (!req_.superformsData[i].retain4626) {\\n                        srcAmount += _estimateAckProcessingCost(1);\\n                    }\\n\\n                    /// @dev step 5: estimate if swap costs are involved\\n                    totalDstGas +=\\n                        _estimateSwapFees(req_.dstChainIds[i], req_.superformsData[i].hasDstSwap.castBoolToArray());\\n                }\\n            } else {\\n                /// @dev step 6: estimate if timelock form processing costs are involved\\n                (, uint32 formId,) = req_.superformsData[i].superformId.getSuperform();\\n\\n                bool paused = factory.isFormImplementationPaused(formId);\\n\\n                if (!paused && formId == TIMELOCK_FORM_ID) {\\n                    totalDstGas += timelockCost[req_.dstChainIds[i]];\\n                } else if (paused) {\\n                    totalDstGas += emergencyCost[req_.dstChainIds[i]];\\n                }\\n            }\\n\\n            /// @dev step 7: estimate execution costs in destination including sending acknowledgement to source\\n            totalDstGas += xChain ? _estimateDstExecutionCost(isDeposit_, req_.dstChainIds[i], 1) : 0;\\n\\n            /// @dev step 8: convert all dst gas estimates to src chain estimate\\n            dstAmount += _convertToNativeFee(req_.dstChainIds[i], totalDstGas);\\n        }\\n\\n        totalAmount = srcAmount + dstAmount + liqAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateSingleXChainMultiVault(\\n        SingleXChainMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount)\\n    {\\n        uint256 totalDstGas;\\n        uint256 superformIdsLen = req_.superformsData.superformIds.length;\\n\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n\\n        /// @dev step 1: estimate AMB costs\\n        uint256 ambFees =\\n            _estimateAMBFees(req_.ambIds, req_.dstChainId, _generateMultiVaultMessage(req_.superformsData));\\n        srcAmount += ambFees;\\n\\n        if (isDeposit_) {\\n            /// @dev step 2: estimate the liqAmount\\n            liqAmount += _estimateLiqAmount(req_.superformsData.liqRequests);\\n\\n            /// @dev step 3: estimate update cost (only for deposit)\\n            totalDstGas += _estimateUpdateCost(req_.dstChainId, superformIdsLen);\\n\\n            uint256 ackLen;\\n            for (uint256 i; i < superformIdsLen; ++i) {\\n                if (!req_.superformsData.retain4626s[i]) ++ackLen;\\n            }\\n\\n            /// @dev step 4: estimation execution cost of acknowledgement on source\\n            srcAmount += _estimateAckProcessingCost(ackLen);\\n\\n            /// @dev step 5: estimate if swap costs are involved\\n            totalDstGas += _estimateSwapFees(req_.dstChainId, req_.superformsData.hasDstSwaps);\\n        } else {\\n            /// @dev step 6: process non-deposit logic for timelock form processing costs\\n            for (uint256 i; i < superformIdsLen; ++i) {\\n                (, uint32 formId,) = req_.superformsData.superformIds[i].getSuperform();\\n\\n                bool paused = factory.isFormImplementationPaused(formId);\\n\\n                if (!paused && formId == TIMELOCK_FORM_ID) {\\n                    totalDstGas += timelockCost[req_.dstChainId];\\n                } else if (paused) {\\n                    totalDstGas += emergencyCost[req_.dstChainId];\\n                }\\n            }\\n        }\\n\\n        /// @dev step 7: estimate execution costs in destination including sending acknowledgement to source\\n        /// @dev ensure that acknowledgement costs from dst to src are not double counted\\n        totalDstGas += _estimateDstExecutionCost(isDeposit_, req_.dstChainId, superformIdsLen);\\n\\n        /// @dev step 8: convert all destination gas estimates to source chain estimate\\n        dstAmount += _convertToNativeFee(req_.dstChainId, totalDstGas);\\n\\n        totalAmount = srcAmount + dstAmount + liqAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateSingleXChainSingleVault(\\n        SingleXChainSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount)\\n    {\\n        uint256 totalDstGas;\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n\\n        /// @dev step 1: estimate AMB costs\\n        uint256 ambFees =\\n            _estimateAMBFees(req_.ambIds, req_.dstChainId, _generateSingleVaultMessage(req_.superformData));\\n        srcAmount += ambFees;\\n\\n        if (isDeposit_) {\\n            /// @dev step 2: estimate the liqAmount\\n            liqAmount += _estimateLiqAmount(req_.superformData.liqRequest.castLiqRequestToArray());\\n\\n            /// @dev step 3: estimate update cost (only for deposit)\\n            totalDstGas += _estimateUpdateCost(req_.dstChainId, 1);\\n\\n            /// @dev step 4: estimation execution cost of acknowledgement on source\\n            if (!req_.superformData.retain4626) {\\n                srcAmount += _estimateAckProcessingCost(1);\\n            }\\n\\n            /// @dev step 5: estimate if swap costs are involved\\n            totalDstGas += _estimateSwapFees(req_.dstChainId, req_.superformData.hasDstSwap.castBoolToArray());\\n        } else {\\n            /// @dev step 6: process non-deposit logic for timelock form processing costs\\n            (, uint32 formId,) = req_.superformData.superformId.getSuperform();\\n\\n            bool paused = factory.isFormImplementationPaused(formId);\\n\\n            if (!paused && formId == TIMELOCK_FORM_ID) {\\n                totalDstGas += timelockCost[req_.dstChainId];\\n            } else if (paused) {\\n                totalDstGas += emergencyCost[req_.dstChainId];\\n            }\\n        }\\n\\n        /// @dev step 7: estimate execution costs in destination including sending acknowledgement to source\\n        totalDstGas += _estimateDstExecutionCost(isDeposit_, req_.dstChainId, 1);\\n\\n        /// @dev step 8: convert all destination gas estimates to source chain estimate\\n        dstAmount += _convertToNativeFee(req_.dstChainId, totalDstGas);\\n\\n        totalAmount = srcAmount + dstAmount + liqAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateSingleDirectSingleVault(\\n        SingleDirectSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount)\\n    {\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n\\n        if (!isDeposit_) {\\n            /// @dev only if timelock form withdrawal is involved\\n            (, uint32 formId,) = req_.superformData.superformId.getSuperform();\\n\\n            bool paused = factory.isFormImplementationPaused(formId);\\n\\n            if (!paused && formId == TIMELOCK_FORM_ID) {\\n                srcAmount += timelockCost[CHAIN_ID] * _getGasPrice(CHAIN_ID);\\n            } else if (paused) {\\n                srcAmount += emergencyCost[CHAIN_ID] * _getGasPrice(CHAIN_ID);\\n            }\\n        } else {\\n            liqAmount = _estimateLiqAmount(req_.superformData.liqRequest.castLiqRequestToArray());\\n        }\\n\\n        /// @dev not adding dstAmount to save some GAS\\n        totalAmount = liqAmount + srcAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateSingleDirectMultiVault(\\n        SingleDirectMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount)\\n    {\\n        ISuperformFactory factory = ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")));\\n\\n        if (!isDeposit_) {\\n            uint256 len = req_.superformData.superformIds.length;\\n            uint256 timelockPrice = timelockCost[CHAIN_ID] * _getGasPrice(CHAIN_ID);\\n            uint256 emergencyPrice = emergencyCost[CHAIN_ID] * _getGasPrice(CHAIN_ID);\\n            for (uint256 i; i < len; ++i) {\\n                (, uint32 formId,) = req_.superformData.superformIds[i].getSuperform();\\n                bool paused = factory.isFormImplementationPaused(formId);\\n\\n                if (!paused && formId == TIMELOCK_FORM_ID) {\\n                    srcAmount += timelockPrice;\\n                } else if (paused) {\\n                    srcAmount += emergencyPrice;\\n                }\\n            }\\n        } else {\\n            liqAmount += _estimateLiqAmount(req_.superformData.liqRequests);\\n        }\\n\\n        /// @dev not adding dstAmount to save some GAS\\n        totalAmount = liqAmount + srcAmount;\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateAMBFees(\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes[] memory extraData_\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256 totalFees, uint256[] memory)\\n    {\\n        uint256 len = ambIds_.length;\\n        uint256[] memory fees = new uint256[](len);\\n\\n        /// @dev just checks the estimate for sending message from src -> dst\\n        if (CHAIN_ID != dstChainId_) {\\n            for (uint256 i; i < len; ++i) {\\n                fees[i] = IAmbImplementation(superRegistry.getAmbAddress(ambIds_[i])).estimateFees(\\n                    dstChainId_, message_, extraData_[i]\\n                );\\n\\n                totalFees += fees[i];\\n            }\\n        }\\n\\n        return (totalFees, fees);\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateAckCost(uint256 payloadId_) external view override returns (uint256 totalFees) {\\n        EstimateAckCostVars memory v;\\n        IBaseStateRegistry coreStateRegistry = IBaseStateRegistry(_getAddress(keccak256(\\\"CORE_STATE_REGISTRY\\\")));\\n        v.currPayloadId = coreStateRegistry.payloadsCount();\\n\\n        if (payloadId_ > v.currPayloadId) revert Error.INVALID_PAYLOAD_ID();\\n\\n        v.payloadHeader = coreStateRegistry.payloadHeader(payloadId_);\\n        v.payloadBody = coreStateRegistry.payloadBody(payloadId_);\\n\\n        (, v.callbackType, v.isMulti,,, v.srcChainId) = DataLib.decodeTxInfo(v.payloadHeader);\\n\\n        /// if callback type is return then return 0\\n        if (v.callbackType != 0) return 0;\\n\\n        if (v.isMulti == 1) {\\n            InitMultiVaultData memory data = abi.decode(v.payloadBody, (InitMultiVaultData));\\n            v.payloadBody = abi.encode(ReturnMultiData(v.currPayloadId, data.superformIds, data.amounts));\\n        } else {\\n            InitSingleVaultData memory data = abi.decode(v.payloadBody, (InitSingleVaultData));\\n            v.payloadBody = abi.encode(ReturnSingleData(v.currPayloadId, data.superformId, data.amount));\\n        }\\n\\n        v.ackAmbIds = coreStateRegistry.getMessageAMB(payloadId_);\\n\\n        v.message = abi.encode(AMBMessage(coreStateRegistry.payloadHeader(payloadId_), v.payloadBody));\\n\\n        return _estimateAMBFees(v.ackAmbIds, v.srcChainId, v.message);\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateAckCostDefault(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256 totalFees)\\n    {\\n        bytes memory payloadBody;\\n        if (multi) {\\n            uint256 vaultLimitPerDst = superRegistry.getVaultLimitPerDestination(srcChainId);\\n            uint256[] memory maxUints = new uint256[](vaultLimitPerDst);\\n\\n            for (uint256 i; i < vaultLimitPerDst; ++i) {\\n                maxUints[i] = type(uint256).max;\\n            }\\n            payloadBody = abi.encode(ReturnMultiData(type(uint256).max, maxUints, maxUints));\\n        } else {\\n            payloadBody = abi.encode(ReturnSingleData(type(uint256).max, type(uint256).max, type(uint256).max));\\n        }\\n\\n        return _estimateAMBFees(ackAmbIds, srcChainId, abi.encode(AMBMessage(type(uint256).max, payloadBody)));\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function estimateAckCostDefaultNativeSource(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _convertToSrcNativeAmount(srcChainId, estimateAckCostDefault(multi, ackAmbIds, srcChainId));\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IPaymentHelper\\n    function addRemoteChain(\\n        uint64 chainId_,\\n        PaymentHelperConfig calldata config_\\n    )\\n        external\\n        override\\n        onlyProtocolAdmin\\n    {\\n        if (config_.nativeFeedOracle != address(0)) {\\n            AggregatorV3Interface nativeFeedOracleContract = AggregatorV3Interface(config_.nativeFeedOracle);\\n            if (nativeFeedOracleContract.decimals() != SUPPORTED_FEED_PRECISION) {\\n                revert Error.CHAINLINK_UNSUPPORTED_DECIMAL();\\n            }\\n\\n            nativeFeedOracle[chainId_] = nativeFeedOracleContract;\\n        }\\n\\n        if (config_.gasPriceOracle != address(0)) {\\n            AggregatorV3Interface gasPriceOracleContract = AggregatorV3Interface(config_.gasPriceOracle);\\n            if (gasPriceOracleContract.decimals() != SUPPORTED_FEED_PRECISION) {\\n                revert Error.CHAINLINK_UNSUPPORTED_DECIMAL();\\n            }\\n\\n            gasPriceOracle[chainId_] = gasPriceOracleContract;\\n        }\\n\\n        swapGasUsed[chainId_] = config_.swapGasUsed;\\n        updateGasUsed[chainId_] = config_.updateGasUsed;\\n        depositGasUsed[chainId_] = config_.depositGasUsed;\\n        withdrawGasUsed[chainId_] = config_.withdrawGasUsed;\\n        nativePrice[chainId_] = config_.defaultNativePrice;\\n        gasPrice[chainId_] = config_.defaultGasPrice;\\n        gasPerByte[chainId_] = config_.dstGasPerByte;\\n        ackGasCost[chainId_] = config_.ackGasCost;\\n        timelockCost[chainId_] = config_.timelockCost;\\n        emergencyCost[chainId_] = config_.emergencyCost;\\n\\n        emit ChainConfigAdded(chainId_, config_);\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function updateRemoteChain(\\n        uint64 chainId_,\\n        uint256 configType_,\\n        bytes memory config_\\n    )\\n        external\\n        override\\n        onlyEmergencyAdmin\\n    {\\n        /// @dev Type 1: DST TOKEN PRICE FEED ORACLE\\n        if (configType_ == 1) {\\n            AggregatorV3Interface nativeFeedOracleContract = AggregatorV3Interface(abi.decode(config_, (address)));\\n\\n            /// @dev allows setting price feed to address(0), equivalent for resetting native price\\n            if (\\n                address(nativeFeedOracleContract) != address(0)\\n                    && nativeFeedOracleContract.decimals() != SUPPORTED_FEED_PRECISION\\n            ) {\\n                revert Error.CHAINLINK_UNSUPPORTED_DECIMAL();\\n            }\\n\\n            nativeFeedOracle[chainId_] = nativeFeedOracleContract;\\n        }\\n\\n        /// @dev Type 2: DST GAS PRICE ORACLE\\n        if (configType_ == 2) {\\n            AggregatorV3Interface gasPriceOracleContract = AggregatorV3Interface(abi.decode(config_, (address)));\\n\\n            /// @dev allows setting gas price to address(0), equivalent for resetting gas price\\n            if (\\n                address(gasPriceOracleContract) != address(0)\\n                    && gasPriceOracleContract.decimals() != SUPPORTED_FEED_PRECISION\\n            ) {\\n                revert Error.CHAINLINK_UNSUPPORTED_DECIMAL();\\n            }\\n\\n            gasPriceOracle[chainId_] = gasPriceOracleContract;\\n        }\\n\\n        /// @dev Type 3: SWAP GAS USED\\n        if (configType_ == 3) {\\n            swapGasUsed[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 4: PAYLOAD UPDATE GAS COST PER TX FOR DEPOSIT\\n        if (configType_ == 4) {\\n            updateGasUsed[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 5: DEPOSIT GAS COST PER TX\\n        if (configType_ == 5) {\\n            depositGasUsed[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 6: WITHDRAW GAS COST PER TX\\n        if (configType_ == 6) {\\n            withdrawGasUsed[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 7: DEFAULT NATIVE PRICE\\n        if (configType_ == 7) {\\n            nativePrice[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 8: DEFAULT GAS PRICE\\n        if (configType_ == 8) {\\n            gasPrice[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 9: GAS PRICE PER Byte of Message\\n        if (configType_ == 9) {\\n            gasPerByte[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 10: ACK GAS COST\\n        if (configType_ == 10) {\\n            ackGasCost[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 11: TIMELOCK PROCESSING COST\\n        if (configType_ == 11) {\\n            timelockCost[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        /// @dev Type 12: EMERGENCY PROCESSING COST\\n        if (configType_ == 12) {\\n            emergencyCost[chainId_] = abi.decode(config_, (uint256));\\n        }\\n\\n        emit ChainConfigUpdated(chainId_, configType_, config_);\\n    }\\n\\n    /// @inheritdoc IPaymentHelper\\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external onlyEmergencyAdmin {\\n        extraDataForTransmuter = extraDataForTransmuter_;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev helps generate extra data per amb\\n    function _generateExtraData(\\n        uint64 dstChainId_,\\n        uint8[] memory ambIds_,\\n        bytes memory message_\\n    )\\n        internal\\n        view\\n        returns (bytes[] memory extraDataPerAMB)\\n    {\\n        AMBMessage memory ambIdEncodedMessage = abi.decode(message_, (AMBMessage));\\n        ambIdEncodedMessage.params = abi.encode(ambIds_, ambIdEncodedMessage.params);\\n\\n        uint256 len = ambIds_.length;\\n        uint256 gasReqPerByte = gasPerByte[dstChainId_];\\n        uint256 totalDstGasReqInWei = abi.encode(ambIdEncodedMessage).length * gasReqPerByte;\\n\\n        /// @dev proof length is always of fixed length\\n        uint256 totalDstGasReqInWeiForProof = PROOF_LENGTH * gasReqPerByte;\\n\\n        extraDataPerAMB = new bytes[](len);\\n\\n        for (uint256 i; i < len; ++i) {\\n            uint256 gasReq = i != 0 ? totalDstGasReqInWeiForProof : totalDstGasReqInWei;\\n            extraDataPerAMB[i] = IAmbImplementation(superRegistry.getAmbAddress(ambIds_[i])).generateExtraData(gasReq);\\n        }\\n    }\\n\\n    /// @dev helps estimate the cross-chain message costs\\n    function _estimateAMBFees(\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_\\n    )\\n        internal\\n        view\\n        returns (uint256 totalFees)\\n    {\\n        uint256 len = ambIds_.length;\\n\\n        bytes[] memory extraDataPerAMB = _generateExtraData(dstChainId_, ambIds_, message_);\\n\\n        AMBMessage memory ambIdEncodedMessage = abi.decode(message_, (AMBMessage));\\n        ambIdEncodedMessage.params = abi.encode(ambIds_, ambIdEncodedMessage.params);\\n\\n        bytes memory proof_ = abi.encode(AMBMessage(MAX_UINT256, abi.encode(keccak256(message_))));\\n\\n        /// @dev just checks the estimate for sending message from src -> dst\\n        /// @dev only ambIds_[0] = primary amb (rest of the ambs send only the proof)\\n        if (CHAIN_ID != dstChainId_) {\\n            for (uint256 i; i < len; ++i) {\\n                uint256 tempFee = IAmbImplementation(superRegistry.getAmbAddress(ambIds_[i])).estimateFees(\\n                    dstChainId_, i != 0 ? proof_ : abi.encode(ambIdEncodedMessage), extraDataPerAMB[i]\\n                );\\n\\n                totalFees += tempFee;\\n            }\\n        }\\n    }\\n\\n    /// @dev helps estimate the cross-chain message costs\\n    function _estimateAMBFeesReturnExtraData(\\n        uint64 dstChainId_,\\n        uint8[] calldata ambIds_,\\n        bytes memory message_\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory feeSplitUp, bytes[] memory extraDataPerAMB, uint256 totalFees)\\n    {\\n        AMBMessage memory ambIdEncodedMessage = abi.decode(message_, (AMBMessage));\\n        ambIdEncodedMessage.params = abi.encode(ambIds_, ambIdEncodedMessage.params);\\n\\n        uint256 len = ambIds_.length;\\n\\n        extraDataPerAMB = _generateExtraData(dstChainId_, ambIds_, message_);\\n\\n        feeSplitUp = new uint256[](len);\\n\\n        bytes memory proof_ = abi.encode(AMBMessage(MAX_UINT256, abi.encode(keccak256(message_))));\\n\\n        /// @dev just checks the estimate for sending message from src -> dst\\n        if (CHAIN_ID != dstChainId_) {\\n            for (uint256 i; i < len; ++i) {\\n                uint256 tempFee = IAmbImplementation(superRegistry.getAmbAddress(ambIds_[i])).estimateFees(\\n                    dstChainId_, i != 0 ? proof_ : abi.encode(ambIdEncodedMessage), extraDataPerAMB[i]\\n                );\\n\\n                totalFees += tempFee;\\n                feeSplitUp[i] = tempFee;\\n            }\\n        }\\n    }\\n\\n    /// @dev helps estimate the liq amount involved in the tx\\n    function _estimateLiqAmount(LiqRequest[] memory req_) internal pure returns (uint256 liqAmount) {\\n        uint256 len = req_.length;\\n        for (uint256 i; i < len; ++i) {\\n            liqAmount += req_[i].nativeAmount;\\n        }\\n    }\\n\\n    /// @dev helps estimate the dst chain swap gas limit (if multi-tx is involved)\\n    function _estimateSwapFees(\\n        uint64 dstChainId_,\\n        bool[] memory hasDstSwaps_\\n    )\\n        internal\\n        view\\n        returns (uint256 gasUsed)\\n    {\\n        uint256 totalSwaps;\\n\\n        if (CHAIN_ID == dstChainId_) {\\n            return 0;\\n        }\\n\\n        uint256 len = hasDstSwaps_.length;\\n        for (uint256 i; i < len; ++i) {\\n            /// @dev checks if hasDstSwap is true\\n            if (hasDstSwaps_[i]) {\\n                ++totalSwaps;\\n            }\\n        }\\n\\n        if (totalSwaps == 0) {\\n            return 0;\\n        }\\n\\n        return totalSwaps * swapGasUsed[dstChainId_];\\n    }\\n\\n    /// @dev helps estimate the dst chain update payload gas limit\\n    function _estimateUpdateCost(uint64 dstChainId_, uint256 vaultsCount_) internal view returns (uint256 gasUsed) {\\n        return vaultsCount_ * updateGasUsed[dstChainId_];\\n    }\\n\\n    /// @dev helps estimate the dst chain processing cost including the dst->src message cost\\n    /// @dev assumes that withdrawals optimisically succeed\\n    function _estimateDstExecutionCost(\\n        bool isDeposit_,\\n        uint64 dstChainId_,\\n        uint256 vaultsCount_\\n    )\\n        internal\\n        view\\n        returns (uint256 gasUsed)\\n    {\\n        uint256 executionGasPerVault = isDeposit_ ? depositGasUsed[dstChainId_] : withdrawGasUsed[dstChainId_];\\n        gasUsed = executionGasPerVault * vaultsCount_;\\n    }\\n\\n    /// @dev helps estimate the src chain processing fee\\n    function _estimateAckProcessingCost(uint256 vaultsCount_) internal view returns (uint256 nativeFee) {\\n        uint256 gasCost = vaultsCount_ * ackGasCost[CHAIN_ID];\\n\\n        return gasCost * _getGasPrice(CHAIN_ID);\\n    }\\n\\n    /// @dev generates the amb message for single vault data\\n    function _generateSingleVaultMessage(SingleVaultSFData memory sfData_)\\n        internal\\n        view\\n        returns (bytes memory message_)\\n    {\\n        bytes memory ambData = abi.encode(\\n            InitSingleVaultData(\\n                _getNextPayloadId(),\\n                sfData_.superformId,\\n                sfData_.amount,\\n                sfData_.outputAmount,\\n                sfData_.maxSlippage,\\n                sfData_.liqRequest,\\n                sfData_.hasDstSwap,\\n                sfData_.retain4626,\\n                sfData_.receiverAddress,\\n                sfData_.extraFormData\\n            )\\n        );\\n        message_ = abi.encode(AMBMessage(MAX_UINT256, ambData));\\n    }\\n\\n    /// @dev generates the amb message for multi vault data\\n    function _generateMultiVaultMessage(MultiVaultSFData memory sfData_)\\n        internal\\n        view\\n        returns (bytes memory message_)\\n    {\\n        bytes memory ambData = abi.encode(\\n            InitMultiVaultData(\\n                _getNextPayloadId(),\\n                sfData_.superformIds,\\n                sfData_.amounts,\\n                sfData_.outputAmounts,\\n                sfData_.maxSlippages,\\n                sfData_.liqRequests,\\n                sfData_.hasDstSwaps,\\n                sfData_.retain4626s,\\n                sfData_.receiverAddress,\\n                sfData_.extraFormData\\n            )\\n        );\\n        message_ = abi.encode(AMBMessage(MAX_UINT256, ambData));\\n    }\\n\\n    /// @dev helps convert the dst gas fee into src chain native fee\\n    /// @dev https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#ether-units\\n    /// @dev all native tokens should be 18 decimals across all EVMs\\n    function _convertToNativeFee(uint64 dstChainId_, uint256 dstGas_) internal view returns (uint256 nativeFee) {\\n        /// @dev gas fee * gas price (to get the gas amounts in dst chain's native token)\\n        /// @dev gas price is 9 decimal (in gwei)\\n        /// @dev assumption: all evm native tokens are 18 decimals\\n        uint256 dstNativeFee = dstGas_ * _getGasPrice(dstChainId_);\\n\\n        if (dstNativeFee == 0) {\\n            return 0;\\n        }\\n\\n        /// @dev converts the gas to pay in terms of native token to usd value\\n        /// @dev native token price is 8 decimal\\n        uint256 dstUsdValue = dstNativeFee * _getNativeTokenPrice(dstChainId_); // native token price - 8 decimal\\n\\n        if (dstUsdValue == 0) {\\n            return 0;\\n        }\\n\\n        /// @dev converts the usd value to source chain's native token\\n        /// @dev native token price is 8 decimal which cancels the 8 decimal multiplied in previous step\\n        uint256 nativeTokenPrice = _getNativeTokenPrice(CHAIN_ID); // native token price - 8 decimal\\n        if (nativeTokenPrice == 0) revert Error.INVALID_NATIVE_TOKEN_PRICE();\\n        nativeFee = (dstUsdValue) / _getNativeTokenPrice(CHAIN_ID);\\n    }\\n\\n    /// @dev helps convert a native token of one chain to another\\n    /// @dev https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#ether-units\\n    /// @dev all native tokens should be 18 decimals across all EVMs\\n    function _convertToSrcNativeAmount(\\n        uint64 srcChainId_,\\n        uint256 dstAmount_\\n    )\\n        internal\\n        view\\n        returns (uint256 nativeFee)\\n    {\\n        if (dstAmount_ == 0) {\\n            return 0;\\n        }\\n\\n        /// @dev converts the native token value to usd value\\n        /// @dev dstAmount_ is 18 decimal\\n        /// @dev native token price is 8 decimal\\n        uint256 dstUsdValue = dstAmount_ * _getNativeTokenPrice(CHAIN_ID);\\n\\n        if (dstUsdValue == 0) {\\n            return 0;\\n        }\\n\\n        /// @dev converts the usd value to source chain's native token\\n        /// @dev native token price is 8 decimal which cancels the 8 decimal multiplied in previous step\\n        uint256 nativeTokenPrice = _getNativeTokenPrice(srcChainId_);\\n        if (nativeTokenPrice == 0) revert Error.INVALID_NATIVE_TOKEN_PRICE();\\n\\n        nativeFee = dstUsdValue / nativeTokenPrice;\\n    }\\n\\n    /// @dev helps generate the new payload id\\n    /// @dev next payload id = current payload id + 1\\n    function _getNextPayloadId() internal view returns (uint256 nextPayloadId) {\\n        nextPayloadId = ReadOnlyBaseRegistry(_getAddress(keccak256(\\\"CORE_STATE_REGISTRY\\\"))).payloadsCount();\\n        ++nextPayloadId;\\n    }\\n\\n    /// @dev helps return the current gas price of different networks\\n    /// @return native token price\\n    function _getGasPrice(uint64 chainId_) internal view returns (uint256) {\\n        address oracleAddr = address(gasPriceOracle[chainId_]);\\n        if (oracleAddr != address(0)) {\\n            try AggregatorV3Interface(oracleAddr).latestRoundData() returns (\\n                uint80, int256 value, uint256, uint256 updatedAt, uint80\\n            ) {\\n                if (value <= 0) revert Error.CHAINLINK_MALFUNCTION();\\n                if (updatedAt == 0) revert Error.CHAINLINK_INCOMPLETE_ROUND();\\n                return uint256(value);\\n            } catch {\\n                /// @dev do nothing and return the default price at the end of the function\\n            }\\n        }\\n\\n        return gasPrice[chainId_];\\n    }\\n\\n    /// @dev helps return the dst chain token price of different networks\\n    /// @return native token price\\n    function _getNativeTokenPrice(uint64 chainId_) internal view returns (uint256) {\\n        address oracleAddr = address(nativeFeedOracle[chainId_]);\\n        if (oracleAddr != address(0)) {\\n            try AggregatorV3Interface(oracleAddr).latestRoundData() returns (\\n                uint80, int256 dstTokenPrice, uint256, uint256 updatedAt, uint80\\n            ) {\\n                if (dstTokenPrice <= 0) revert Error.CHAINLINK_MALFUNCTION();\\n                if (updatedAt == 0) revert Error.CHAINLINK_INCOMPLETE_ROUND();\\n                return uint256(dstTokenPrice);\\n            } catch {\\n                /// @dev do nothing and return the default price at the end of the function\\n            }\\n        }\\n\\n        return nativePrice[chainId_];\\n    }\\n\\n    /// @dev returns the address from super registry\\n    function _getAddress(bytes32 id_) internal view returns (address) {\\n        return superRegistry.getAddress(id_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPaymentHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport {\\n    MultiDstMultiVaultStateReq,\\n    MultiDstSingleVaultStateReq,\\n    SingleXChainMultiVaultStateReq,\\n    SingleXChainSingleVaultStateReq,\\n    SingleDirectSingleVaultStateReq,\\n    SingleDirectMultiVaultStateReq\\n} from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title IPaymentHelper\\n/// @dev Interface for PaymentHelper\\n/// @author ZeroPoint Labs\\ninterface IPaymentHelper {\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @param nativeFeedOracle is the native price feed oracle\\n    /// @param gasPriceOracle is the gas price oracle\\n    /// @param swapGasUsed is the swap gas params\\n    /// @param updateGasUsed is the update gas params\\n    /// @param depositGasUsed is the deposit per vault gas on the chain\\n    /// @param withdrawGasUsed is the withdraw per vault gas on the chain\\n    /// @param defaultNativePrice is the native price on the specified chain\\n    /// @param defaultGasPrice is the gas price on the specified chain\\n    /// @param dstGasPerByte is the gas per size of data on the specified chain\\n    /// @param ackGasCost is the gas cost for sending and processing from dst->src\\n    /// @param timelockCost is the extra cost for processing timelocked payloads\\n    /// @param emergencyCost is the extra cost for processing emergency payloads\\n    struct PaymentHelperConfig {\\n        address nativeFeedOracle;\\n        address gasPriceOracle;\\n        uint256 swapGasUsed;\\n        uint256 updateGasUsed;\\n        uint256 depositGasUsed;\\n        uint256 withdrawGasUsed;\\n        uint256 defaultNativePrice;\\n        uint256 defaultGasPrice;\\n        uint256 dstGasPerByte;\\n        uint256 ackGasCost;\\n        uint256 timelockCost;\\n        uint256 emergencyCost;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    event ChainConfigUpdated(uint64 indexed chainId_, uint256 indexed configType_, bytes config_);\\n    event ChainConfigAdded(uint64 chainId_, PaymentHelperConfig config_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @param dstChainId_ is the unique dst chain identifier\\n    /// @param ambIds_ is the identifiers of arbitrary message bridges to be used\\n    /// @param message_ is the encoded cross-chain payload\\n    function calculateAMBData(\\n        uint64 dstChainId_,\\n        uint8[] calldata ambIds_,\\n        bytes memory message_\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees, bytes memory extraData);\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @return extraData the amb specific override information\\n    function getRegisterTransmuterAMBData() external view returns (bytes memory extraData);\\n\\n    /// @dev estimates the gas fees for multiple destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstMultiVault(\\n        MultiDstMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstSingleVault(\\n        MultiDstSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainMultiVault(\\n        SingleXChainMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainSingleVault(\\n        SingleXChainSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectSingleVault(\\n        SingleDirectSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectMultiVault(\\n        SingleDirectMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    /// @dev returns the gas fees estimation in native tokens if we send message through a combination of AMBs\\n    /// @param ambIds_ is the identifier of different AMBs\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message\\n    /// @param extraData_ is any amb-specific information\\n    /// @return ambFees is the native_tokens to be sent along the transaction for all the ambIds_ included\\n    function estimateAMBFees(\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes[] memory extraData_\\n    )\\n        external\\n        view\\n        returns (uint256 ambFees, uint256[] memory);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing\\n    /// @param payloadId_ is the payload identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCost(uint256 payloadId_) external view returns (uint256 totalFees);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing without relying on payloadId (using max values)\\n    /// @param multi is the flag indicating if the payload is multi or single\\n    /// @param ackAmbIds is the list of ambIds to be used for acknowledgement\\n    /// @param srcChainId is the source chain identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCostDefault(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing without relying on payloadId (using max values)\\n    /// with source native amounts\\n    /// @param multi is the flag indicating if the payload is multi or single\\n    /// @param ackAmbIds is the list of ambIds to be used for acknowledgement\\n    /// @param srcChainId is the source chain identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCostDefaultNativeSource(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees);\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev admin can configure a remote chain for first time\\n    /// @param chainId_ is the identifier of new chain id\\n    /// @param config_ is the chain config\\n    function addRemoteChain(uint64 chainId_, PaymentHelperConfig calldata config_) external;\\n\\n    /// @dev admin can specifically configure/update certain configuration of a remote chain\\n    /// @param chainId_ is the remote chain's identifier\\n    /// @param configType_ is the type of config from 1 -> 6\\n    /// @param config_ is the encoded new configuration\\n    function updateRemoteChain(uint64 chainId_, uint256 configType_, bytes memory config_) external;\\n\\n    /// @dev admin updates config for register transmuter amb params\\n    /// @param extraDataForTransmuter_ is the broadcast extra data\\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IAccessControl } from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\n/// @title ISuperRBAC\\n/// @dev Interface for SuperRBAC\\n/// @author Zeropoint Labs\\ninterface ISuperRBAC is IAccessControl {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct InitialRoleSetup {\\n        address admin;\\n        address emergencyAdmin;\\n        address paymentAdmin;\\n        address csrProcessor;\\n        address tlProcessor;\\n        address brProcessor;\\n        address csrUpdater;\\n        address srcVaaRelayer;\\n        address dstSwapper;\\n        address csrRescuer;\\n        address csrDisputer;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when superRegistry is set\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev is emitted when an admin is set for a role\\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the id of the protocol admin role\\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency admin role\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin role\\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcaster role\\n    function BROADCASTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor role\\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock state registry processor role\\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry processor role\\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater role\\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper role\\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescuer role\\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescue disputer role\\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of wormhole vaa relayer role\\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns whether the given address has the protocol admin role\\n    /// @param admin_ the address to check\\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\\n\\n    /// @dev returns whether the given address has the emergency admin role\\n    /// @param admin_ the address to check\\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev updates the super registry address\\n    function setSuperRegistry(address superRegistry_) external;\\n\\n    /// @dev configures a new role in superForm\\n    /// @param role_ the role to set\\n    /// @param adminRole_ the admin role to set as admin\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\\n\\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\\n    /// @param role_ the role to revoke\\n    /// @param extraData_ amb config if broadcasting is required\\n    /// @param superRegistryAddressId_ the super registry address id\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows sync of global roles from different chains using broadcast registry\\n    /// @notice may not work for all roles\\n    function stateSyncBroadcast(bytes memory data_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperRegistry\\n/// @dev Interface for SuperRegistry\\n/// @author Zeropoint Labs\\ninterface ISuperRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when permit2 is set.\\n    event SetPermit2(address indexed permit2);\\n\\n    /// @dev is emitted when an address is set.\\n    event AddressUpdated(\\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\\n    );\\n\\n    /// @dev is emitted when a new token bridge is configured.\\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\\n\\n    /// @dev is emitted when a new bridge validator is configured.\\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\\n\\n    /// @dev is emitted when a new amb is configured.\\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\\n\\n    /// @dev is emitted when a new state registry is configured.\\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\\n\\n    /// @dev is emitted when a new delay is configured.\\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\\n\\n    /// @dev is emitted when a new vault limit is configured\\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the deposit rescue delay\\n    function delay() external view returns (uint256);\\n\\n    /// @dev returns the permit2 address\\n    function PERMIT2() external view returns (address);\\n\\n    /// @dev returns the id of the superform router module\\n    function SUPERFORM_ROUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform factory module\\n    function SUPERFORM_FACTORY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform paymaster contract\\n    function PAYMASTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform payload helper contract\\n    function PAYMENT_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry module\\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry module\\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry module\\n    function BROADCAST_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super positions module\\n    function SUPER_POSITIONS() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super rbac module\\n    function SUPER_RBAC() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payload helper module\\n    function PAYLOAD_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper keeper\\n    function DST_SWAPPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency queue\\n    function EMERGENCY_QUEUE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform receiver\\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin keeper\\n    function PAYMENT_ADMIN() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor keeper\\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast registry processor keeper\\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry processor keeper\\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev gets the address of a contract on current chain\\n    /// @param id_ is the id of the contract\\n    function getAddress(bytes32 id_) external view returns (address);\\n\\n    /// @dev gets the address of a contract on a target chain\\n    /// @param id_ is the id of the contract\\n    /// @param chainId_ is the chain id of that chain\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\\n\\n    /// @dev gets the address of a bridge\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeAddress_ is the address of the form\\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\\n\\n    /// @dev gets the address of a bridge validator\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeValidator_ is the address of the form\\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\\n\\n    /// @dev gets the address of a amb\\n    /// @param ambId_ is the id of a bridge\\n    /// @return ambAddress_ is the address of the form\\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\\n\\n    /// @dev gets the id of the amb\\n    /// @param ambAddress_ is the address of an amb\\n    /// @return ambId_ is the identifier of an amb\\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\\n\\n    /// @dev gets the address of the registry\\n    /// @param registryId_ is the id of the state registry\\n    /// @return registryAddress_ is the address of the state registry\\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\\n\\n    /// @dev gets the id of the registry\\n    /// @notice reverts if the id is not found\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return registryId_ is the id of the state registry\\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\\n\\n    /// @dev gets the safe vault limit\\n    /// @param chainId_ is the id of the remote chain\\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\\n    /// without hitting out of gas error\\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\\n\\n    /// @dev helps validate if an address is a valid state registry\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid amb implementation\\n    /// @param ambAddress_ is the address of the amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid broadcast amb implementation\\n    /// @param ambAddress_ is the address of the broadcast amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev sets the deposit rescue delay\\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\\n    function setDelay(uint256 delay_) external;\\n\\n    /// @dev sets the permit2 address\\n    /// @param permit2_ the address of the permit2 contract\\n    function setPermit2(address permit2_) external;\\n\\n    /// @dev sets the safe vault limit\\n    /// @param chainId_ is the remote chain identifier\\n    /// @param vaultLimit_ is the max limit of vaults per transaction\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\\n\\n    /// @dev sets new addresses on specific chains.\\n    /// @param ids_ are the identifiers of the address on that chain\\n    /// @param newAddresses_  are the new addresses on that chain\\n    /// @param chainIds_ are the chain ids of that chain\\n    function batchSetAddress(\\n        bytes32[] calldata ids_,\\n        address[] calldata newAddresses_,\\n        uint64[] calldata chainIds_\\n    )\\n        external;\\n\\n    /// @dev sets a new address on a specific chain.\\n    /// @param id_ the identifier of the address on that chain\\n    /// @param newAddress_ the new address on that chain\\n    /// @param chainId_ the chain id of that chain\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\\n\\n    /// @dev allows admin to set the bridge address for an bridge id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param bridgeId_         represents the bridge unique identifier.\\n    /// @param bridgeAddress_    represents the bridge address.\\n    /// @param bridgeValidator_  represents the bridge validator address.\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the amb address for an amb id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param ambId_         represents the bridge unique identifier.\\n    /// @param ambAddress_    represents the bridge address.\\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the state registry address for an state registry id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param registryId_    represents the state registry's unique identifier.\\n    /// @param registryAddress_    represents the state registry's address.\\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperformFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperformFactory\\n/// @dev Interface for SuperformFactory\\n/// @author ZeroPoint Labs\\ninterface ISuperformFactory {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    enum PauseStatus {\\n        NON_PAUSED,\\n        PAUSED\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when a new formImplementation is entered into the factory\\n    /// @param formImplementation is the address of the new form implementation\\n    /// @param formImplementationId is the id of the formImplementation\\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\\n    event FormImplementationAdded(\\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\\n    );\\n\\n    /// @dev emitted when a new Superform is created\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param vault is the address of the vault\\n    /// @param superformId is the id of the superform\\n    /// @param superform is the address of the superform\\n    event SuperformCreated(\\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\\n    );\\n\\n    /// @dev emitted when a new SuperRegistry is set\\n    /// @param superRegistry is the address of the super registry\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev emitted when a form implementation is paused\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param paused is the new paused status\\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the number of forms\\n    /// @return forms_ is the number of forms\\n    function getFormCount() external view returns (uint256 forms_);\\n\\n    /// @dev returns the number of superforms\\n    /// @return superforms_ is the number of superforms\\n    function getSuperformCount() external view returns (uint256 superforms_);\\n\\n    /// @dev returns the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return formImplementation_ is the address of the form implementation\\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\\n\\n    /// @dev returns the form state registry id of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return stateRegistryId_ is the additional state registry id of the form\\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\\n\\n    /// @dev returns the paused status of form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return paused_ is the current paused status of the form formImplementationId_\\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\\n\\n    /// @dev returns the address of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the id of the form implementation\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        external\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\\n\\n    /// @dev returns if an address has been added to a Form\\n    /// @param superformId_ is the id of the superform\\n    /// @return isSuperform_ bool if it exists\\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\\n\\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\\n    /// @param vault_ is the address of a vault\\n    /// @return superformIds_ is the id of the superform\\n    /// @return superforms_ is the address of the superform\\n    function getAllSuperformsFromVault(address vault_)\\n        external\\n        view\\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows an admin to add a Form implementation to the factory\\n    /// @param formImplementation_ is the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\\n    /// additional state registry is required\\n    function addFormImplementation(\\n        address formImplementation_,\\n        uint32 formImplementationId_,\\n        uint8 formStateRegistryId_\\n    )\\n        external;\\n\\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\\n    /// @param vault_ is the address of the vault\\n    /// @return superformId_ is the id of the created superform\\n    /// @return superform_ is the address of the created superform\\n    function createSuperform(\\n        uint32 formImplementationId_,\\n        address vault_\\n    )\\n        external\\n        returns (uint256 superformId_, address superform_);\\n\\n    /// @dev to synchronize superforms added to different chains using broadcast registry\\n    /// @param data_ is the cross-chain superform id\\n    function stateSyncBroadcast(bytes memory data_) external payable;\\n\\n    /// @dev allows an admin to change the status of a form\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @param status_ is the new status\\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\\n    function changeFormImplementationPauseStatus(\\n        uint32 formImplementationId_,\\n        PauseStatus status_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBaseStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { PayloadState } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title IBaseStateRegistry\\n/// @dev Interface for BaseStateRegistry\\n/// @author ZeroPoint Labs\\ninterface IBaseStateRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a cross-chain payload is received in the state registry\\n    event PayloadReceived(uint64 indexed srcChainId, uint64 indexed dstChainId, uint256 indexed payloadId);\\n\\n    /// @dev is emitted when a cross-chain proof is received in the state registry\\n    /// NOTE: comes handy if quorum required is more than 0\\n    event ProofReceived(bytes32 indexed proof);\\n\\n    /// @dev is emitted when a payload id gets updated\\n    event PayloadUpdated(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when a payload id gets processed\\n    event PayloadProcessed(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when the super registry address is updated\\n    event SuperRegistryUpdated(address indexed superRegistry);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows users to read the total payloads received by the registry\\n    function payloadsCount() external view returns (uint256);\\n\\n    /// @dev allows user to read the payload state\\n    /// uint256 payloadId_ is the unique payload identifier allocated on the destination chain\\n    function payloadTracking(uint256 payloadId_) external view returns (PayloadState payloadState_);\\n\\n    /// @dev allows users to read the bytes payload_ stored per payloadId_\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return payloadBody_ the crosschain data received\\n    function payloadBody(uint256 payloadId_) external view returns (bytes memory payloadBody_);\\n\\n    /// @dev allows users to read the uint256 payloadHeader stored per payloadId_\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return payloadHeader_ the crosschain header received\\n    function payloadHeader(uint256 payloadId_) external view returns (uint256 payloadHeader_);\\n\\n    /// @dev allows users to read the ambs that delivered the payload id\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return ambIds_ is the identifier of ambs that delivered the message and proof\\n    function getMessageAMB(uint256 payloadId_) external view returns (uint8[] memory ambIds_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows core contracts to send payload to a destination chain.\\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\\n    /// @param ambIds_ is the identifier of the arbitrary message bridge to be used\\n    /// @param dstChainId_ is the internal chainId used throughout the protocol\\n    /// @param message_ is the crosschain payload to be sent\\n    /// @param extraData_ defines all the message bridge related overrides\\n    /// NOTE: dstChainId_ is mapped to message bridge's destination id inside it's implementation contract\\n    /// NOTE: ambIds_ are superform assigned unique identifier for arbitrary message bridges\\n    function dispatchPayload(\\n        address srcSender_,\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows state registry to receive messages from message bridge implementations\\n    /// @param srcChainId_ is the superform chainId from which the payload is dispatched/sent\\n    /// @param message_ is the crosschain payload received\\n    /// NOTE: Only {IMPLEMENTATION_CONTRACT} role can call this function.\\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external;\\n\\n    /// @dev allows privileged actors to process cross-chain payloads\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    /// NOTE: Only {CORE_STATE_REGISTRY_PROCESSOR_ROLE} role can call this function\\n    /// NOTE: this should handle reverting the state on source chain in-case of failure\\n    /// (or) can implement scenario based reverting like in coreStateRegistry\\n    function processPayload(uint256 payloadId_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAmbImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IAmbImplementation\\n/// @dev Interface for arbitrary message bridge (AMB) implementations\\n/// @author ZeroPoint Labs\\ninterface IAmbImplementation {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    event ChainAdded(uint64 indexed superChainId);\\n    event AuthorizedImplAdded(uint64 indexed superChainId, address indexed authImpl);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the gas fees estimation in native tokens\\n    /// @notice not all AMBs will have on-chain estimation for which this function will return 0\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message\\n    /// @param extraData_ is any amb-specific information\\n    /// @return fees is the native_tokens to be sent along the transaction\\n    function estimateFees(\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        view\\n        returns (uint256 fees);\\n\\n    /// @dev returns the extra data for the given gas request\\n    /// @param gasLimit is the amount of gas limit in wei to override\\n    /// @return extraData is the bytes encoded extra data\\n    /// NOTE: this process is unique to the message bridge\\n    function generateExtraData(uint256 gasLimit) external pure returns (bytes memory extraData);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows state registry to send message via implementation.\\n    /// @param srcSender_ is the caller (used for gas refunds)\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message to be sent\\n    /// @param extraData_ is message amb specific override information\\n    function dispatchPayload(\\n        address srcSender_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows for the permissionless calling of the retry mechanism for encoded data\\n    /// @param data_ is the encoded retry data (different per AMB implementation)\\n    function retryPayload(bytes memory data_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nlibrary Error {\\n    //////////////////////////////////////////////////////////////\\n    //                  CONFIGURATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown in protocol setup\\n\\n    /// @dev thrown if chain id exceeds max(uint64)\\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if not possible to revoke a role in broadcasting\\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n\\n    /// @dev thrown if not possible to revoke last admin\\n    error CANNOT_REVOKE_LAST_ADMIN();\\n\\n    /// @dev thrown if trying to set again pseudo immutables in super registry\\n    error DISABLED();\\n\\n    /// @dev thrown if rescue delay is not yet set for a chain\\n    error DELAY_NOT_SET();\\n\\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\\n    error INVALID_NATIVE_TOKEN_PRICE();\\n\\n    /// @dev thrown if wormhole refund chain id is not set\\n    error REFUND_CHAIN_ID_NOT_SET();\\n\\n    /// @dev thrown if wormhole relayer is not set\\n    error RELAYER_NOT_SET();\\n\\n    /// @dev thrown if a role to be revoked is not assigned\\n    error ROLE_NOT_ASSIGNED();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  AUTHORIZATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if functions cannot be called\\n\\n    /// COMMON AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if caller is not address(this), internal call\\n    error INVALID_INTERNAL_CALL();\\n\\n    /// @dev thrown if msg.sender is not a valid amb implementation\\n    error NOT_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not an allowed broadcaster\\n    error NOT_ALLOWED_BROADCASTER();\\n\\n    /// @dev thrown if msg.sender is not broadcast amb implementation\\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not broadcast state registry\\n    error NOT_BROADCAST_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not core state registry\\n    error NOT_CORE_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not emergency admin\\n    error NOT_EMERGENCY_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not emergency queue\\n    error NOT_EMERGENCY_QUEUE();\\n\\n    /// @dev thrown if msg.sender is not minter\\n    error NOT_MINTER();\\n\\n    /// @dev thrown if msg.sender is not minter state registry\\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\\n\\n    /// @dev thrown if msg.sender is not paymaster\\n    error NOT_PAYMASTER();\\n\\n    /// @dev thrown if msg.sender is not payment admin\\n    error NOT_PAYMENT_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not protocol admin\\n    error NOT_PROTOCOL_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not state registry\\n    error NOT_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not super registry\\n    error NOT_SUPER_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not superform router\\n    error NOT_SUPERFORM_ROUTER();\\n\\n    /// @dev thrown if msg.sender is not a superform\\n    error NOT_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not superform factory\\n    error NOT_SUPERFORM_FACTORY();\\n\\n    /// @dev thrown if msg.sender is not timelock form\\n    error NOT_TIMELOCK_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not timelock state registry\\n    error NOT_TIMELOCK_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not user or disputer\\n    error NOT_VALID_DISPUTER();\\n\\n    /// @dev thrown if the msg.sender is not privileged caller\\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\\n\\n    /// STATE REGISTRY AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\\n    error CALLER_NOT_ENDPOINT();\\n\\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\\n    error CALLER_NOT_MAILBOX();\\n\\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\\n    error CALLER_NOT_RELAYER();\\n\\n    /// @dev thrown if src chain sender is not valid\\n    error INVALID_SRC_SENDER();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INPUT VALIDATION ERRORS                 //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if input variables are not valid\\n\\n    /// COMMON INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if there is an array length mismatch\\n    error ARRAY_LENGTH_MISMATCH();\\n\\n    /// @dev thrown if payload id does not exist\\n    error INVALID_PAYLOAD_ID();\\n\\n    /// @dev error thrown when msg value should be zero in certain payable functions\\n    error MSG_VALUE_NOT_ZERO();\\n\\n    /// @dev thrown if amb ids length is 0\\n    error ZERO_AMB_ID_LENGTH();\\n\\n    /// @dev thrown if address input is address 0\\n    error ZERO_ADDRESS();\\n\\n    /// @dev thrown if amount input is 0\\n    error ZERO_AMOUNT();\\n\\n    /// @dev thrown if final token is address 0\\n    error ZERO_FINAL_TOKEN();\\n\\n    /// @dev thrown if value input is 0\\n    error ZERO_INPUT_VALUE();\\n\\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the vaults data is invalid\\n    error INVALID_SUPERFORMS_DATA();\\n\\n    /// @dev thrown if receiver address is not set\\n    error RECEIVER_ADDRESS_NOT_SET();\\n\\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if a form is not ERC165 compatible\\n    error ERC165_UNSUPPORTED();\\n\\n    /// @dev thrown if a form is not form interface compatible\\n    error FORM_INTERFACE_UNSUPPORTED();\\n\\n    /// @dev error thrown if form implementation address already exists\\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\\n\\n    /// @dev error thrown if form implementation id already exists\\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\\n\\n    /// @dev thrown if a form does not exist\\n    error FORM_DOES_NOT_EXIST();\\n\\n    /// @dev thrown if form id is larger than max uint16\\n    error INVALID_FORM_ID();\\n\\n    /// @dev thrown if superform not on factory\\n    error SUPERFORM_ID_NONEXISTENT();\\n\\n    /// @dev thrown if same vault and form implementation is used to create new superform\\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\\n\\n    /// FORM INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\\n    /// in case of txData, if token output of swap != vault.asset()\\n    error DIFFERENT_TOKENS();\\n\\n    /// @dev thrown if the amount in direct withdraw is not correct\\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// @dev thrown if the amount in xchain withdraw is not correct\\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if route id is blacklisted in socket\\n    error BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev thrown if route id is not blacklisted in socket\\n    error NOT_BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is a blacklisted selector\\n    error BLACKLISTED_SELECTOR();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is not a blacklisted selector\\n    error NOT_BLACKLISTED_SELECTOR();\\n\\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\\n    error INVALID_ACTION();\\n\\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\\n\\n    /// @dev thrown if index is invalid\\n    error INVALID_INDEX();\\n\\n    /// @dev thrown if the chain id in the txdata is invalid\\n    error INVALID_TXDATA_CHAIN_ID();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\\n    error INVALID_TXDATA_RECEIVER();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\\n    error INVALID_TXDATA_TOKEN();\\n\\n    /// @dev thrown if txData is not present (in case of xChain actions)\\n    error NO_TXDATA_PRESENT();\\n\\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n\\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n\\n    /// @dev thrown if keeper update final token is different than the vault underlying\\n    error INVALID_UPDATE_FINAL_TOKEN();\\n\\n    /// @dev thrown if broadcast finality for wormhole is invalid\\n    error INVALID_BROADCAST_FINALITY();\\n\\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\\n    error INVALID_BRIDGE_ID();\\n\\n    /// @dev thrown if chain id involved in xchain message is invalid\\n    error INVALID_CHAIN_ID();\\n\\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\\n    error INVALID_DST_SWAP_AMOUNT();\\n\\n    /// @dev thrown if message amb and proof amb are the same\\n    error INVALID_PROOF_BRIDGE_ID();\\n\\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\\n    error INVALID_PROOF_BRIDGE_IDS();\\n\\n    /// @dev thrown if rescue data lengths are invalid\\n    error INVALID_RESCUE_DATA();\\n\\n    /// @dev thrown if delay is invalid\\n    error INVALID_TIMELOCK_DELAY();\\n\\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\\n    error NEGATIVE_SLIPPAGE();\\n\\n    /// @dev thrown if slippage is outside of bounds\\n    error SLIPPAGE_OUT_OF_BOUNDS();\\n\\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if src senders mismatch in state sync\\n    error SRC_SENDER_MISMATCH();\\n\\n    /// @dev thrown if src tx types mismatch in state sync\\n    error SRC_TX_TYPE_MISMATCH();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  EXECUTION ERRORS                        //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown due to function execution logic\\n\\n    /// COMMON EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\\n    error DIRECT_DEPOSIT_SWAP_FAILED();\\n\\n    /// @dev thrown if payload is not unique\\n    error DUPLICATE_PAYLOAD();\\n\\n    /// @dev thrown if native tokens fail to be sent to superform contracts\\n    error FAILED_TO_SEND_NATIVE();\\n\\n    /// @dev thrown if allowance is not correct to deposit\\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\\n\\n    /// @dev thrown if contract has insufficient balance for operations\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @dev thrown if native amount is not at least equal to the amount in the request\\n    error INSUFFICIENT_NATIVE_AMOUNT();\\n\\n    /// @dev thrown if payload cannot be decoded\\n    error INVALID_PAYLOAD();\\n\\n    /// @dev thrown if payload status is invalid\\n    error INVALID_PAYLOAD_STATUS();\\n\\n    /// @dev thrown if payload type is invalid\\n    error INVALID_PAYLOAD_TYPE();\\n\\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\\n\\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\\n    error FAILED_TO_EXECUTE_TXDATA(address token);\\n\\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\\n    error INVALID_DEPOSIT_TOKEN();\\n\\n    /// STATE REGISTRY EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if bridge tokens haven't arrived to destination\\n    error BRIDGE_TOKENS_PENDING();\\n\\n    /// @dev thrown if withdrawal tx data cannot be updated\\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n\\n    /// @dev thrown if rescue passed dispute deadline\\n    error DISPUTE_TIME_ELAPSED();\\n\\n    /// @dev thrown if message failed to reach the specified level of quorum needed\\n    error INSUFFICIENT_QUORUM();\\n\\n    /// @dev thrown if broadcast payload is invalid\\n    error INVALID_BROADCAST_PAYLOAD();\\n\\n    /// @dev thrown if broadcast fee is invalid\\n    error INVALID_BROADCAST_FEE();\\n\\n    /// @dev thrown if retry fees is less than required\\n    error INVALID_RETRY_FEE();\\n\\n    /// @dev thrown if broadcast message type is wrong\\n    error INVALID_MESSAGE_TYPE();\\n\\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\\n    error INVALID_PAYLOAD_HASH();\\n\\n    /// @dev thrown if update payload function was called on a wrong payload\\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\\n\\n    /// @dev thrown if a state registry id is 0\\n    error INVALID_REGISTRY_ID();\\n\\n    /// @dev thrown if a form state registry id is 0\\n    error INVALID_FORM_REGISTRY_ID();\\n\\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\\n    error LOCKED();\\n\\n    /// @dev thrown if payload is already updated (during xChain deposits)\\n    error PAYLOAD_ALREADY_UPDATED();\\n\\n    /// @dev thrown if payload is already processed\\n    error PAYLOAD_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if payload is not in UPDATED state\\n    error PAYLOAD_NOT_UPDATED();\\n\\n    /// @dev thrown if rescue is still in timelocked state\\n    error RESCUE_LOCKED();\\n\\n    /// @dev thrown if rescue is already proposed\\n    error RESCUE_ALREADY_PROPOSED();\\n\\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\\n    error ZERO_PAYLOAD_HASH();\\n\\n    /// DST SWAPPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if process dst swap is tried for processed payload id\\n    error DST_SWAP_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if indices have duplicates\\n    error DUPLICATE_INDEX();\\n\\n    /// @dev thrown if failed dst swap is already updated\\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\\n\\n    /// @dev thrown if indices are out of bounds\\n    error INDEX_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if failed swap token amount is 0\\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\\n\\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\\n    error INVALID_INTERIM_TOKEN();\\n\\n    /// @dev thrown if dst swap output is less than minimum expected\\n    error INVALID_SWAP_OUTPUT();\\n\\n    /// FORM EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if try to forward 4626 share from the superform\\n    error CANNOT_FORWARD_4646_TOKEN();\\n\\n    /// @dev thrown in KYCDAO form if no KYC token is present\\n    error NO_VALID_KYC_TOKEN();\\n\\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\\n    error PAUSED();\\n\\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\\n    error VAULT_IMPLEMENTATION_FAILED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TOKEN_NOT_UPDATED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\\n\\n    /// @dev thrown when redeeming from vault yields zero collateral\\n    error WITHDRAW_ZERO_COLLATERAL();\\n\\n    /// PAYMENT HELPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if chainlink is reporting an improper price\\n    error CHAINLINK_MALFUNCTION();\\n\\n    /// @dev thrown if chainlink is reporting an incomplete round\\n    error CHAINLINK_INCOMPLETE_ROUND();\\n\\n    /// @dev thrown if feed decimals is not 8\\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\\n\\n    /// EMERGENCY QUEUE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if emergency withdraw is not queued\\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\\n\\n    /// @dev thrown if emergency withdraw is already processed\\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\\n\\n    /// SUPERPOSITION EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if uri cannot be updated\\n    error DYNAMIC_URI_FROZEN();\\n\\n    /// @dev thrown if tx history is not found while state sync\\n    error TX_HISTORY_NOT_FOUND();\\n}\\n\"\r\n    },\r\n    \"src/libraries/DataLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\nlibrary DataLib {\\n    function packTxInfo(\\n        uint8 txType_,\\n        uint8 callbackType_,\\n        uint8 multi_,\\n        uint8 registryId_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 txInfo)\\n    {\\n        txInfo = uint256(txType_);\\n        txInfo |= uint256(callbackType_) << 8;\\n        txInfo |= uint256(multi_) << 16;\\n        txInfo |= uint256(registryId_) << 24;\\n        txInfo |= uint256(uint160(srcSender_)) << 32;\\n        txInfo |= uint256(srcChainId_) << 192;\\n    }\\n\\n    function decodeTxInfo(uint256 txInfo_)\\n        internal\\n        pure\\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\\n    {\\n        txType = uint8(txInfo_);\\n        callbackType = uint8(txInfo_ >> 8);\\n        multi = uint8(txInfo_ >> 16);\\n        registryId = uint8(txInfo_ >> 24);\\n        srcSender = address(uint160(txInfo_ >> 32));\\n        srcChainId = uint64(txInfo_ >> 192);\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the form id\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        internal\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\\n    {\\n        superform_ = address(uint160(superformId_));\\n        formImplementationId_ = uint32(superformId_ >> 160);\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of an array of superforms\\n    /// @param superformIds_  array of superforms\\n    /// @return superforms_ are the address of the vaults\\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\\n        uint256 len = superformIds_.length;\\n        superforms_ = new address[](len);\\n\\n        for (uint256 i; i < len; ++i) {\\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\\n        }\\n    }\\n\\n    /// @dev returns the destination chain of a given superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return chainId_ is the chain id\\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev generates the superformId\\n    /// @param superform_ is the address of the superform\\n    /// @param formImplementationId_ is the type of the form\\n    /// @param chainId_ is the chain id on which the superform is deployed\\n    function packSuperform(\\n        address superform_,\\n        uint32 formImplementationId_,\\n        uint64 chainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 superformId_)\\n    {\\n        superformId_ = uint256(uint160(superform_));\\n        superformId_ |= uint256(formImplementationId_) << 160;\\n        superformId_ |= uint256(chainId_) << 192;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { AMBMessage } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @dev generates proof for amb message and bytes encoded message\\nlibrary ProofLib {\\n    function computeProof(AMBMessage memory message_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(message_));\\n    }\\n\\n    function computeProofBytes(AMBMessage memory message_) internal pure returns (bytes memory) {\\n        return abi.encode(keccak256(abi.encode(message_)));\\n    }\\n\\n    function computeProof(bytes memory message_) internal pure returns (bytes32) {\\n        return keccak256(message_);\\n    }\\n\\n    function computeProofBytes(bytes memory message_) internal pure returns (bytes memory) {\\n        return abi.encode(keccak256(message_));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArrayCastLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { InitSingleVaultData, InitMultiVaultData, LiqRequest } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @dev library to cast single values into array for streamlining helper functions\\n/// @notice not gas optimized, suggested for usage only in view/pure functions\\nlibrary ArrayCastLib {\\n    function castLiqRequestToArray(LiqRequest memory value_) internal pure returns (LiqRequest[] memory values) {\\n        values = new LiqRequest[](1);\\n\\n        values[0] = value_;\\n    }\\n\\n    function castBoolToArray(bool value_) internal pure returns (bool[] memory values) {\\n        values = new bool[](1);\\n\\n        values[0] = value_;\\n    }\\n\\n    function castToMultiVaultData(InitSingleVaultData memory data_)\\n        internal\\n        pure\\n        returns (InitMultiVaultData memory castedData_)\\n    {\\n        uint256[] memory superformIds = new uint256[](1);\\n        superformIds[0] = data_.superformId;\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = data_.amount;\\n\\n        uint256[] memory outputAmounts = new uint256[](1);\\n        outputAmounts[0] = data_.outputAmount;\\n\\n        uint256[] memory maxSlippage = new uint256[](1);\\n        maxSlippage[0] = data_.maxSlippage;\\n\\n        LiqRequest[] memory liqData = new LiqRequest[](1);\\n        liqData[0] = data_.liqData;\\n\\n        castedData_ = InitMultiVaultData(\\n            data_.payloadId,\\n            superformIds,\\n            amounts,\\n            outputAmounts,\\n            maxSlippage,\\n            liqData,\\n            castBoolToArray(data_.hasDstSwap),\\n            castBoolToArray(data_.retain4626),\\n            data_.receiverAddress,\\n            data_.extraFormData\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @dev contains all the common struct and enums used for data communication between chains.\\n\\n/// @dev There are two transaction types in Superform Protocol\\nenum TransactionType {\\n    DEPOSIT,\\n    WITHDRAW\\n}\\n\\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\\nenum CallbackType {\\n    INIT,\\n    RETURN,\\n    FAIL\\n}\\n\\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\\nenum PayloadState {\\n    STORED,\\n    UPDATED,\\n    PROCESSED\\n}\\n\\n/// @dev contains all the common struct used for interchain token transfers.\\nstruct LiqRequest {\\n    /// @dev generated data\\n    bytes txData;\\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\\n    /// txData to be updated on destination for withdraws\\n    address token;\\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\\n    /// validation purposes\\n    address interimToken;\\n    /// @dev what bridge to use to move tokens\\n    uint8 bridgeId;\\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\\n    /// is to be delivered\\n    uint64 liqDstChainId;\\n    /// @dev currently this amount is used as msg.value in the txData call.\\n    uint256 nativeAmount;\\n}\\n\\n/// @dev main struct that holds required multi vault data for an action\\nstruct MultiVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256[] superformIds;\\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev main struct that holds required single vault data for an action\\nstruct SingleVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256 maxSlippage;\\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool hasDstSwap;\\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev overarching struct for multiDst requests with multi vaults\\nstruct MultiDstMultiVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    MultiVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with multi vaults\\nstruct SingleXChainMultiVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    MultiVaultSFData superformsData;\\n}\\n\\n/// @dev overarching struct for multiDst requests with single vaults\\nstruct MultiDstSingleVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    SingleVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with single vaults\\nstruct SingleXChainSingleVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with single vaults\\nstruct SingleDirectSingleVaultStateReq {\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with multi vaults\\nstruct SingleDirectMultiVaultStateReq {\\n    MultiVaultSFData superformData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\\nstruct InitMultiVaultData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n    uint256[] outputAmounts;\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqData;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\nstruct InitSingleVaultData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount;\\n    uint256 maxSlippage;\\n    LiqRequest liqData;\\n    bool hasDstSwap;\\n    bool retain4626;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for Emergency Queue\\nstruct QueuedWithdrawal {\\n    address receiverAddress;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 srcPayloadId;\\n    bool isProcessed;\\n}\\n\\n/// @dev all statuses of the timelock payload\\nenum TimelockStatus {\\n    UNAVAILABLE,\\n    PENDING,\\n    PROCESSED\\n}\\n\\n/// @dev holds information about the timelock payload\\nstruct TimelockPayload {\\n    uint8 isXChain;\\n    uint64 srcChainId;\\n    uint256 lockedTill;\\n    InitSingleVaultData data;\\n    TimelockStatus status;\\n}\\n\\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\\n/// data in params\\nstruct AMBMessage {\\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\\n        // srcSender and srcChainId\\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\\n}\\n\\n/// @dev struct that contains the information required for broadcasting changes\\nstruct BroadcastMessage {\\n    bytes target;\\n    bytes32 messageType;\\n    bytes message;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnMultiData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnSingleData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs\\nstruct AMBExtraData {\\n    uint256[] gasPerAMB;\\n    bytes[] extraDataPerAMB;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\\nstruct BroadCastAMBExtraData {\\n    uint256[] gasPerDst;\\n    bytes[] extraDataPerDst;\\n}\\n\"\r\n    },\r\n    \"src/vendor/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/ERC1155A/lib/solmate/src/\",\r\n      \"ERC1155A/=lib/ERC1155A/src/\",\r\n      \"@openzeppelin/contracts/=lib/ERC1155A/lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ERC1155A/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/ERC1155A/lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\",\r\n      \"super-vaults/=lib/super-vaults/src/\",\r\n      \"v2-core/=lib/super-vaults/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/super-vaults/lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/super-vaults/lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CHAINLINK_INCOMPLETE_ROUND\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CHAINLINK_MALFUNCTION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CHAINLINK_UNSUPPORTED_DECIMAL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_NATIVE_TOKEN_PRICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_EMERGENCY_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PROTOCOL_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nativeFeedOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasPriceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultNativePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstGasPerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ackGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelockCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyCost\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IPaymentHelper.PaymentHelperConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"ChainConfigAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"configType_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"config_\",\"type\":\"bytes\"}],\"name\":\"ChainConfigUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"ackGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForAck\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nativeFeedOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasPriceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawGasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultNativePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstGasPerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ackGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelockCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyCost\",\"type\":\"uint256\"}],\"internalType\":\"struct IPaymentHelper.PaymentHelperConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"addRemoteChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId_\",\"type\":\"uint64\"},{\"internalType\":\"uint8[]\",\"name\":\"ambIds_\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"calculateAMBData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"depositGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"emergencyCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForEmergency\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds_\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId_\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"extraData_\",\"type\":\"bytes[]\"}],\"name\":\"estimateAMBFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"estimateAckCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"multi\",\"type\":\"bool\"},{\"internalType\":\"uint8[]\",\"name\":\"ackAmbIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"}],\"name\":\"estimateAckCostDefault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"multi\",\"type\":\"bool\"},{\"internalType\":\"uint8[]\",\"name\":\"ackAmbIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"}],\"name\":\"estimateAckCostDefaultNativeSource\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateMultiDstMultiVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"ambIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[]\",\"name\":\"dstChainIds\",\"type\":\"uint64[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData[]\",\"name\":\"superformsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiDstSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateMultiDstSingleVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateSingleDirectMultiVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleDirectSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateSingleDirectSingleVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"liqRequests\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool[]\",\"name\":\"hasDstSwaps\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"retain4626s\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVaultSFData\",\"name\":\"superformsData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainMultiVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateSingleXChainMultiVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ambIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"superformId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interimToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"liqDstChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest\",\"name\":\"liqRequest\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit2data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"hasDstSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"retain4626\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraFormData\",\"type\":\"bytes\"}],\"internalType\":\"struct SingleVaultSFData\",\"name\":\"superformData\",\"type\":\"tuple\"}],\"internalType\":\"struct SingleXChainSingleVaultStateReq\",\"name\":\"req_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isDeposit_\",\"type\":\"bool\"}],\"name\":\"estimateSingleXChainSingleVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liqAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraDataForTransmuter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"gasPerByte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasPerByte\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"defaultGasPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"gasPriceOracle\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterTransmuterAMBData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"nativeFeedOracle\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"nativePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"defaultNativePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"swapGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForSwap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"timelockCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForTimelock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"updateGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForUpdate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extraDataForTransmuter_\",\"type\":\"bytes\"}],\"name\":\"updateRegisterAERC20Params\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"configType_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"config_\",\"type\":\"bytes\"}],\"name\":\"updateRemoteChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"withdrawGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasForWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PaymentHelper", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000017a332dc7b40ae701485023b219e9d6f493a2514", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}