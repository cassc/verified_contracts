{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {MessageHashUtils} from \\\"./MessageHashUtils.sol\\\";\\nimport {ShortStrings, ShortString} from \\\"../ShortStrings.sol\\\";\\nimport {IERC5267} from \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {IERC-5267}.\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _name which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Name() internal view returns (string memory) {\\n        return _name.toStringWithFallback(_nameFallback);\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _version which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Version() internal view returns (string memory) {\\n        return _version.toStringWithFallback(_versionFallback);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\nimport {IERC1271} from \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Safe Wallet (previously Gnosis Safe).\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ShortStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/ListHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/// @title A list helper contract\\nabstract contract ListHelper {\\n    uint16 internal constant LOOP_LIMIT = 500;\\n    bool internal constant ALLOW_ZERO = true;\\n    bool internal constant DISALLOW_ZERO = false;\\n\\n    error InvalidStart();\\n    error InvalidEnd();\\n    error InvalidSequence();\\n\\n    /**\\n     * @param _start Start\\n     * @param _end End\\n     * @param _total List total\\n     * @param _allowZero true - zero is a valid start or end, false - zero is an invalid start or end\\n     */\\n    modifier onlyValidSequence(\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _total,\\n        bool _allowZero\\n    ) {\\n        _checkSequence(_start, _end, _total, _allowZero);\\n        _;\\n    }\\n\\n    /**\\n     * @param _start Start\\n     * @param _end End\\n     * @param _total Total\\n     * @param _allowZero true - zero is a valid start or end, false - zero is an invalid start or end\\n     * @dev check that a range of indexes is valid.\\n     */\\n    function _checkSequence(\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _total,\\n        bool _allowZero\\n    ) private pure {\\n        if (_allowZero) {\\n            if (_start >= _total) revert InvalidStart();\\n            if (_end >= _total) revert InvalidEnd();\\n        } else {\\n            if (_start == 0 || _start > _total) revert InvalidStart();\\n            if (_end == 0 || _end > _total) revert InvalidEnd();\\n        }\\n        if (_start > _end) revert InvalidStart();\\n        if (_end - _start + 1 > LOOP_LIMIT) revert InvalidSequence();\\n    }\\n\\n    /// @dev _length List length\\n    function _validateListLength(uint256 _length) internal pure {\\n        if (_length == 0 || LOOP_LIMIT < _length) revert OTSeaErrors.InvalidArrayLength();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/SignatureHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/// @title Abstract signature helper contract\\nabstract contract SignatureHelper is EIP712, Ownable {\\n    address public signer;\\n\\n    error ExpiredSignature();\\n    error InvalidSignature();\\n    error SignatureRequired();\\n\\n    event SignerUpdated(address signer);\\n\\n    /**\\n     * @param _name Name of contract\\n     * @param _version Version of contract\\n     * @param _signer Address of signer\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _version,\\n        address _signer\\n    ) EIP712(_name, _version) {\\n        if (_signer == address(0)) revert OTSeaErrors.InvalidAddress();\\n        signer = _signer;\\n    }\\n\\n    /**\\n     * @notice Set the signer\\n     * @param _signer New signer address\\n     */\\n    function setSigner(address _signer) external onlyOwner {\\n        if (_signer == address(0)) revert OTSeaErrors.InvalidAddress();\\n        signer = _signer;\\n        emit SignerUpdated(_signer);\\n    }\\n\\n    /**\\n     * @param _data Reconstructed message\\n     * @param _signature Signature\\n     * @dev reverts if signature is invalid\\n     */\\n    function _checkSignature(\\n        bytes memory _data,\\n        bytes calldata _signature,\\n        uint256 _expiration\\n    ) internal view {\\n        if (_expiration < block.number) revert ExpiredSignature();\\n        if (\\n            !SignatureChecker.isValidSignatureNow(\\n                signer,\\n                _hashTypedDataV4(keccak256(_data)),\\n                _signature\\n            )\\n        ) revert InvalidSignature();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/// @title A transfer helper contract for ETH and tokens\\ncontract TransferHelper is Context {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev account -> Amount of ETH that failed to transfer\\n    mapping(address => uint256) private _maroonedETH;\\n\\n    error NativeTransferFailed();\\n\\n    event MaroonedETH(address account, uint256 amount);\\n    event MaroonedETHClaimed(address account, address receiver, uint256 amount);\\n\\n    /**\\n     * @notice Claim marooned ETH\\n     * @param _receiver Address to receive the marooned ETH\\n     */\\n    function claimMaroonedETH(address _receiver) external {\\n        if (_receiver == address(0)) revert OTSeaErrors.InvalidAddress();\\n        uint256 amount = _maroonedETH[_msgSender()];\\n        if (amount == 0) revert OTSeaErrors.NotAvailable();\\n        _maroonedETH[_msgSender()] = 0;\\n        _transferETHOrRevert(_receiver, amount);\\n        emit MaroonedETHClaimed(_msgSender(), _receiver, amount);\\n    }\\n\\n    /**\\n     * @notice Get the amount of marooned ETH for an account\\n     * @param _account Account to check\\n     * @return uint256 Marooned ETH\\n     */\\n    function getMaroonedETH(address _account) external view returns (uint256) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _maroonedETH[_account];\\n    }\\n\\n    /**\\n     * @param _account Account to transfer ETH to\\n     * @param _amount Amount of ETH to transfer to _account\\n     * @dev Rather than reverting if the transfer fails, the _amount is stored for the _account to later claim\\n     */\\n    function _safeETHTransfer(address _account, uint256 _amount) internal {\\n        (bool success, ) = _account.call{value: _amount}(\\\"\\\");\\n        if (!success) {\\n            _maroonedETH[_account] += _amount;\\n            emit MaroonedETH(_account, _amount);\\n        }\\n    }\\n\\n    /**\\n     * @param _account Account to transfer ETH to\\n     * @param _amount Amount of ETH to transfer to _account\\n     * @dev The following will revert if the transfer fails\\n     */\\n    function _transferETHOrRevert(address _account, uint256 _amount) internal {\\n        (bool success, ) = _account.call{value: _amount}(\\\"\\\");\\n        if (!success) revert NativeTransferFailed();\\n    }\\n\\n    /**\\n     * @param _token Token to transfer into the contract from msg.sender\\n     * @param _amount Amount of _token to transfer\\n     * @return uint256 Actual amount transferred into the contract\\n     * @dev This function exists due to _token potentially having taxes\\n     */\\n    function _transferInTokens(IERC20 _token, uint256 _amount) internal returns (uint256) {\\n        uint256 balanceBefore = _token.balanceOf(address(this));\\n        _token.safeTransferFrom(_msgSender(), address(this), _amount);\\n        return _token.balanceOf(address(this)) - balanceBefore;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/WhitelistHelper.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"contracts/helpers/ListHelper.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\n\\n/**\\n * @title Abstract whitelist helper contract\\n * @dev Up to 500 addresses can be added or removed to/from the whitelist within a single TX.\\n * This is to prevent the TX reverting due to running out of gas. If a user wishes to add or remove more than 500\\n * addresses, they must do so by performing multiple transactions.\\n */\\nabstract contract WhitelistHelper is ListHelper {\\n    struct WhitelistUpdate {\\n        address account;\\n        /// @dev \\\"operation\\\" represents whether or not to add (true) or remove (false) \\\"account\\\" to/from an order's whitelist.\\n        bool operation;\\n    }\\n    /**\\n     * @dev associated ID => wallet => whitelist ID\\n     * if whitelist ID > 0, then the wallet is whitelisted for the associated ID.\\n     */\\n    mapping(uint72 => mapping(address => uint256)) private _whitelistIDs;\\n    /// @dev associated ID => whitelist\\n    mapping(uint72 => address[]) private _whitelists;\\n\\n    event WhitelistUpdated(uint72 indexed id, uint256 totalWhitelist);\\n\\n    /**\\n     * @notice Update a whitelist associated with an ID\\n     * @param _id ID\\n     * @param _updates Updates to make to the whitelist associated with _id\\n     */\\n    function updateWhitelist(uint72 _id, WhitelistUpdate[] calldata _updates) external virtual;\\n\\n    /**\\n     * @notice Get the total whitelisted accounts associated with an ID\\n     * @param _id ID\\n     * @return uint256 Total whitelisted\\n     */\\n    function getTotalWhitelisted(uint72 _id) external view returns (uint256) {\\n        _checkIDExists(_id);\\n        return _getTotalWhitelisted(_id);\\n    }\\n\\n    /**\\n     * @notice Get a whitelist associated with an ID\\n     * @param _id ID\\n     * @param _start Start whitelist ID\\n     * @param _end End whitelist ID\\n     * @return whitelist An array of whitelisted accounts for _id within the range of _start and _end (inclusive)\\n     */\\n    function getWhitelist(\\n        uint72 _id,\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        onlyValidSequence(_start, _end, _getTotalWhitelisted(_id), DISALLOW_ZERO)\\n        returns (address[] memory whitelist)\\n    {\\n        whitelist = new address[](_end - _start + 1);\\n        uint256 index;\\n        uint256 whitelistIndex = _start - 1;\\n        /// @dev whitelistIndex < _end is the same as whitelistIndex <= _end - 1\\n        for (whitelistIndex; whitelistIndex < _end; ) {\\n            whitelist[index] = _whitelists[_id][whitelistIndex];\\n            unchecked {\\n                index++;\\n                whitelistIndex++;\\n            }\\n        }\\n        return whitelist;\\n    }\\n\\n    /**\\n     * @notice Check if an account is whitelisted for an associated ID\\n     * @param _account Account to check\\n     * @param _id ID\\n     * @return bool true if whitelisted, false if not\\n     */\\n    function checkIsWhitelisted(address _account, uint72 _id) external view returns (bool) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        _checkIDExists(_id);\\n        return _checkIsWhitelisted(_account, _id);\\n    }\\n\\n    /**\\n     * @notice Check if an account is whitelisted for against many IDs\\n     * @param _account Account to check\\n     * @param _ids A list of IDs\\n     * @return isWhitelisted A list of booleans containing true if whitelisted, false if not, each index related to the index in _ids\\n     */\\n    function checkMultipleIsWhitelisted(\\n        address _account,\\n        uint72[] calldata _ids\\n    ) external view returns (bool[] memory isWhitelisted) {\\n        uint256 total = _ids.length;\\n        _validateListLength(total);\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        isWhitelisted = new bool[](total);\\n        uint256 i;\\n        for (i; i < total; ) {\\n            _checkIDExists(_ids[i]);\\n            isWhitelisted[i] = _checkIsWhitelisted(_account, _ids[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return isWhitelisted;\\n    }\\n\\n    /**\\n     * @param _id ID\\n     * @param _whitelist A list of accounts to whitelist for the associated _id\\n     */\\n    function _initializeWhitelist(uint72 _id, address[] calldata _whitelist) internal {\\n        uint256 total = _whitelist.length;\\n        if (LOOP_LIMIT < total) revert OTSeaErrors.InvalidArrayLength();\\n        uint256 i;\\n        for (i; i < total; ) {\\n            if (_whitelist[i] == address(0)) revert OTSeaErrors.InvalidAddressAtIndex(i);\\n            if (_whitelistIDs[_id][_whitelist[i]] != 0)\\n                revert OTSeaErrors.DuplicateAddressAtIndex(i);\\n            _whitelistIDs[_id][_whitelist[i]] = i + 1;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        _whitelists[_id] = _whitelist;\\n        emit WhitelistUpdated(_id, total);\\n    }\\n\\n    /**\\n     * @param _id ID\\n     * @param _updates A list of updates to make to the whitelist for the associated _id\\n     */\\n    function _updateWhitelist(uint72 _id, WhitelistUpdate[] calldata _updates) internal {\\n        uint256 total = _updates.length;\\n        _validateListLength(total);\\n        address[] storage orderWhitelist = _whitelists[_id];\\n        uint256 totalWhitelisted = _whitelists[_id].length;\\n        uint256 i;\\n        for (i; i < total; ) {\\n            if (_updates[i].account == address(0)) revert OTSeaErrors.InvalidAddressAtIndex(i);\\n            if (_updates[i].operation) {\\n                /// @dev add to whitelist, revert if there is a duplicate.\\n                if (_whitelistIDs[_id][_updates[i].account] != 0)\\n                    revert OTSeaErrors.DuplicateAddressAtIndex(i);\\n                _whitelistIDs[_id][_updates[i].account] = ++totalWhitelisted;\\n                orderWhitelist.push(_updates[i].account);\\n            } else {\\n                /// @dev remove from whitelist, revert if it doesn't exist.\\n                uint256 id = _whitelistIDs[_id][_updates[i].account];\\n                if (id == 0) revert OTSeaErrors.AddressNotFoundAtIndex(i);\\n                address lastAddress = orderWhitelist[totalWhitelisted - 1];\\n                if (_updates[i].account != lastAddress) {\\n                    /// @dev reshuffle array and mapping so that the last address is moved in to the current position.\\n                    orderWhitelist[id - 1] = lastAddress;\\n                    _whitelistIDs[_id][lastAddress] = id;\\n                }\\n                _whitelistIDs[_id][_updates[i].account] = 0;\\n                orderWhitelist.pop();\\n                totalWhitelisted--;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        emit WhitelistUpdated(_id, totalWhitelisted);\\n    }\\n\\n    /**\\n     * @param _id ID\\n     * @return uint256 Total whitelisted for _id\\n     */\\n    function _getTotalWhitelisted(uint72 _id) internal view returns (uint256) {\\n        return _whitelists[_id].length;\\n    }\\n\\n    /**\\n     * @param _account Account to check\\n     * @param _id ID\\n     * @return bool true if whitelisted, false if not\\n     */\\n    function _checkIsWhitelisted(address _account, uint72 _id) internal view returns (bool) {\\n        return _whitelistIDs[_id][_account] != 0;\\n    }\\n\\n    /**\\n     * @param _id ID\\n     * @dev _checkIDExists reverts if _id does not exist\\n     */\\n    function _checkIDExists(uint72 _id) internal view virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OTSeaErrors.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title Common OTSea errors\\nlibrary OTSeaErrors {\\n    error InvalidAmount();\\n    error InvalidAddress();\\n    error InvalidIndex(uint256 index);\\n    error InvalidAmountAtIndex(uint256 index);\\n    error InvalidAddressAtIndex(uint256 index);\\n    error DuplicateAddressAtIndex(uint256 index);\\n    error AddressNotFoundAtIndex(uint256 index);\\n    error Unauthorized();\\n    error ExpectationMismatch();\\n    error InvalidArrayLength();\\n    error InvalidFee();\\n    error NotAvailable();\\n    error InvalidPurchase();\\n    error InvalidETH(uint256 expected);\\n    error Unchanged();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OTSeaLibrary.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title Common OTSea variables\\nlibrary OTSeaLibrary {\\n    enum FeeType {\\n        Fish,\\n        Whale\\n    }\\n\\n    uint16 internal constant PERCENT_DENOMINATOR = 10000;\\n    address internal constant DEAD_ADDRESS = address(0xdead);\\n}\\n\"\r\n    },\r\n    \"contracts/otc/OTSea.sol\": {\r\n      \"content\": \"/*\\n        [....     [... [......  [.. ..\\n      [..    [..       [..    [..    [..\\n    [..        [..     [..     [..         [..       [..\\n    [..        [..     [..       [..     [.   [..  [..  [..\\n    [..        [..     [..          [.. [..... [..[..   [..\\n      [..     [..      [..    [..    [..[.        [..   [..\\n        [....          [..      [.. ..    [....     [.. [...\\n\\n    OTSea Platform.\\n\\n    https://otsea.io\\n    https://t.me/OTSeaPortal\\n    https://twitter.com/OTSeaERC20\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"contracts/helpers/ListHelper.sol\\\";\\nimport \\\"contracts/helpers/SignatureHelper.sol\\\";\\nimport \\\"contracts/helpers/TransferHelper.sol\\\";\\nimport \\\"contracts/helpers/WhitelistHelper.sol\\\";\\nimport \\\"contracts/libraries/OTSeaErrors.sol\\\";\\nimport \\\"contracts/libraries/OTSeaLibrary.sol\\\";\\n\\n/**\\n * @title OTSea Over-the-Counter (OTC) Contract\\n * @dev This contract facilitates the creation and execution of buy and sell orders for tokens using ETH.\\n *\\n * Key definitions:\\n *   - Order: An instruction given by a user to buy or sell tokens for a certain amount of ETH.\\n *   - Trade/Swap: The partial or complete execution of an order.\\n *   - Input:\\n *       - For buy orders: The amount of ETH that will be used to purchase tokens.\\n *       - For sell orders: The amount of tokens that will be up for sale.\\n *   - Output:\\n *       - For buy orders: The amount of tokens desired for the ETH input.\\n *       - For sell orders: The amount of ETH desired for the token input.\\n *\\n * Transfer tax tokens:\\n *   - When creating a sell order, if upon transferring tokens into the contract there are fewer tokens than expected. It\\n *     is assumed the token has a transfer tax therefore, the total input and total output are reduced.\\n *\\n * Order features:\\n *   - All-or-Nothing (AON): If enabled, an order must be filled in a single trade. If disabled, orders can be partially filled.\\n *   - Whitelisting: Restricts trading to only whitelisted addresses.\\n *   - Lock-up (for sell orders only): If enabled, when swapping ETH for tokens, the tokens are locked for a duration\\n *     set by the contract with the aim of reducing arbitraging. Traders can claim their tokens after the lockup\\n *     period.\\n *   - Hide on Frontend: Hide an order on the frontend interface.\\n *\\n * Platform fees:\\n *   - The fee is a percentage of the ETH traded.\\n *   - The percentage charged depends on what fee type (fish or whale) the seller is. This is determined by the sellers\\n *     OTSeaERC20 balance off-chain.\\n *   - Initially the fish fee will be 1% and the whale fee will be 0.3%.\\n *   - Fees cannot be increased, only reduced.\\n *\\n * EIP712 is used to sign typed data when creating a sell order or when swapping tokens for ETH. By using a signature,\\n * the contract can reliably know a user's fee type. If this were to be calculated on-chain it could be subject to\\n * flash loan attacks and also would limit this contract to only be deployable on Ethereum mainnet.\\n *\\n * Partners:\\n *   - Partners of OTSea receive a portion of the platform fee (initially 30%).\\n *   - Partners have the ability to toggle on a lock-up for their project's token. If set, all swaps from ETH to their\\n *     project's token will be locked for a duration set by the contract with the aim of reducing arbitraging.\\n *     Traders can claim their tokens after the lockup period ends for a specific lock-up.\\n *\\n * Blacklisting:\\n *   - The owner of the contract has the ability to blacklist user addresses. Doing so results in the blacklisted user\\n *     not being able to create new orders, trade, update the order, on top of this other other users cannot trade with\\n *     orders belonging to blacklisted accounts. Blacklisted users can only cancel orders and claim their\\n *     locked-up tokens.\\n */\\ncontract OTSea is\\n    ListHelper,\\n    Ownable,\\n    Pausable,\\n    ReentrancyGuard,\\n    TransferHelper,\\n    SignatureHelper,\\n    WhitelistHelper\\n{\\n    using SafeERC20 for IERC20;\\n\\n    struct NewOrder {\\n        IERC20 token;\\n        bool isAON;\\n        /**\\n         * @dev withLockUp is a boolean only applicable to sell orders. If true, when swapping ETH for the order's tokens,\\n         * the amount the user should receive will instead be locked up for the duration set by _lockupPeriod.\\n         * After the lockup period has passed, the user is then able to claim their tokens.\\n         */\\n        bool withLockUp;\\n        bool isHidden;\\n        uint256 totalInput;\\n        uint256 totalOutput;\\n    }\\n\\n    struct Order {\\n        address creator;\\n        OrderType orderType;\\n        State state;\\n        OTSeaLibrary.FeeType feeType;\\n        bool isAON;\\n        bool isHidden;\\n        bool withLockUp;\\n        IERC20 token;\\n        uint256 totalInput;\\n        uint256 inputTransacted;\\n        uint256 totalOutput;\\n        uint256 outputTransacted;\\n    }\\n\\n    struct FeeDetailsSignature {\\n        bytes signature;\\n        uint256 expiresAt;\\n        OTSeaLibrary.FeeType feeType;\\n    }\\n\\n    /**\\n     * @dev the Trade struct represents a trade a user wants to perform.\\n     * - If a user wants to swap ETH for tokens, it is a buy trade that interacts with sell orders (BuyTrade struct is used).\\n     * - If a user wants to swap tokens for ETH, it is a sell trade that interacts with buy orders (Trade struct is used).\\n     */\\n    struct Trade {\\n        /// @dev valid orders will always have an orderID greater than 0 and less than or equal to the total orders.\\n        uint72 orderID;\\n        /**\\n         * @dev Definition of amountToSwap:\\n         * Buy trade:\\n         *  - amount of ETH to swap for tokens.\\n         * Sell trade:\\n         *  - amount of tokens to swap for ETH.\\n         */\\n        uint256 amountToSwap;\\n        /**\\n         * @dev \\\"totalOutput\\\" is used to calculate the amount to receive from a trade.\\n         * - Trade.totalOutput must exactly match Order.totalOutput.\\n         * - Any discrepancy between these values causes the TX to revert.\\n         * - This strict equality check prevents the manipulation of order outputs (e.g., front-running) by the order creators.\\n         */\\n        uint256 totalOutput;\\n    }\\n\\n    /**\\n     * @dev The partner struct refers to partners of OTSea. account is set to an address owned by the project for the\\n     * purpose of:\\n     * - Receiving the referral fees\\n     * - Being able to manually enforce lock-ups on orders that exchange the project's token\\n     */\\n    struct Partner {\\n        address account;\\n        bool isLockUpOverrideEnabled;\\n    }\\n\\n    struct LockUp {\\n        address token;\\n        uint88 unlockAt;\\n        uint256 amount;\\n        uint256 withdrawn;\\n    }\\n\\n    struct ClaimLockUp {\\n        uint256 index;\\n        uint256 amount;\\n    }\\n\\n    enum State {\\n        Open,\\n        Fulfilled,\\n        Cancelled\\n    }\\n\\n    enum OrderType {\\n        Buy,\\n        Sell\\n    }\\n\\n    /// @dev Partner referral fees can be set to be between 10-50% (to 2 d.p.) of the platform revenue\\n    uint16 private constant MIN_PARTNER_FEE = 1000;\\n    uint16 private constant MAX_PARTNER_FEE = 5000;\\n    uint8 private constant MAX_TRADES_UPPER_LIMIT = 100;\\n    uint8 private constant MAX_CANCELLATIONS = 100;\\n    uint8 private constant MIN_LOCKUP_TIME = 1 minutes;\\n    uint16 private constant MAX_LOCKUP_TIME = 1 hours;\\n    bytes32 private constant FEE_DETAILS_SIGNATURE_TYPE =\\n        keccak256(\\\"FeeDetails(address account,uint256 expiresAt,uint8 feeType)\\\");\\n    address private _revenueDistributor;\\n    uint72 private _totalOrders;\\n    /// @dev _fishFee = 1% of the ETH traded\\n    uint8 private _fishFee = 100;\\n    /// @dev _whaleFee = 0.3% of the ETH traded\\n    uint8 private _whaleFee = 30;\\n    uint8 private _maxTrades = 10;\\n    uint16 private _partnerFee = 3000;\\n    uint16 private _lockupPeriod = 5 minutes;\\n    mapping(uint72 => Order) private _orders;\\n    /// @dev token => partner\\n    mapping(address => Partner) private _partners;\\n    /// @dev user address => lock-up list\\n    mapping(address => LockUp[]) private _lockUps;\\n    mapping(address => bool) private _blacklist;\\n\\n    /// @dev errors\\n    error UnlockDateNotReached(uint256 index);\\n    error LockUpNotAllowed();\\n    error OrderBlacklisted();\\n    error InvalidTradeOrderType();\\n    error OrderNotFound(uint72 orderID);\\n\\n    /// @dev events\\n    event FeesUpdated(uint8 fishFee, uint8 whaleFee, uint16 partnerFee);\\n    event MaxTradesUpdated(uint8 maxSwaps);\\n    event PartnerUpdated(address indexed token, Partner partner);\\n    event LockUpOverrideUpdated(address indexed account, address indexed token, bool enforced);\\n    event LockupPeriodUpdated(uint16 time);\\n    event BlacklistUpdated(address indexed account, bool operation);\\n    event BuyOrderCreated(\\n        uint72 indexed orderID,\\n        address indexed creator,\\n        NewOrder newOrder,\\n        uint8 decimals\\n    );\\n    event SellOrderCreated(\\n        uint72 indexed orderID,\\n        address indexed creator,\\n        NewOrder newOrder,\\n        uint256 actualTotalInput,\\n        uint256 actualTotalOutput,\\n        OTSeaLibrary.FeeType feeType,\\n        uint8 decimals\\n    );\\n    event SwappedETHForTokens(\\n        address indexed account,\\n        address indexed token,\\n        Trade[] trades,\\n        uint256 swapped,\\n        uint256 received,\\n        uint256 claimable\\n    );\\n    event SwappedTokensForETH(\\n        address indexed account,\\n        address indexed token,\\n        Trade[] trades,\\n        uint256 swapped,\\n        uint256 received,\\n        OTSeaLibrary.FeeType feeType\\n    );\\n    event Traded(\\n        uint72 indexed orderID,\\n        address indexed account,\\n        uint256 swapped,\\n        uint256 received\\n    );\\n    event LockUpsClaimed(address indexed account, address indexed receiver, ClaimLockUp[] claims);\\n    event OrderPriceUpdated(uint72 indexed orderID, uint256 newTotalOutput);\\n    event OrderLockUpUpdated(uint72 indexed orderID, bool enforced);\\n    event CancelledOrders(uint72[] orderIDs);\\n    event RevenueTransferred(uint256 eth);\\n    event PartnerFeePaid(address indexed token, address indexed partner, uint256 eth);\\n\\n    /// @param _orderID Order ID\\n    modifier onlyOrderCreator(uint72 _orderID) {\\n        _checkCallerIsOrderCreator(_orderID);\\n        _;\\n    }\\n\\n    modifier whenNotBlacklisted() {\\n        _checkCallerIsNotBlacklisted();\\n        _;\\n    }\\n\\n    /**\\n     * @param _multiSigAdmin Multi-sig admin\\n     * @param revenueDistributor_ Revenue distributor contract\\n     * @param _signer Signer address\\n     */\\n    constructor(\\n        address _multiSigAdmin,\\n        address revenueDistributor_,\\n        address _signer\\n    ) Ownable(_multiSigAdmin) SignatureHelper(\\\"OTSea\\\", \\\"v1.0.0\\\", _signer) {\\n        if (address(revenueDistributor_) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        _revenueDistributor = revenueDistributor_;\\n    }\\n\\n    /// @notice Update the Revenue Distributor\\n    function setRevenueDistributor(address revenueDistributor_) external onlyOwner {\\n        if (address(_revenueDistributor) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        _revenueDistributor = revenueDistributor_;\\n    }\\n\\n    /// @notice Pause the contract\\n    function pauseContract() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpause the contract\\n    function unpauseContract() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @notice Set the fish and whale fees\\n     * @param _newFishFee Fish fee\\n     * @param _newWhaleFee Whale fee\\n     * @param _newPartnerFee Partner fee relative to the revenue\\n     */\\n    function setFees(\\n        uint8 _newFishFee,\\n        uint8 _newWhaleFee,\\n        uint16 _newPartnerFee\\n    ) external onlyOwner {\\n        if (\\n            _fishFee < _newFishFee ||\\n            _whaleFee < _newWhaleFee ||\\n            _newFishFee < _newWhaleFee ||\\n            _newPartnerFee < MIN_PARTNER_FEE ||\\n            MAX_PARTNER_FEE < _newPartnerFee\\n        ) revert OTSeaErrors.InvalidFee();\\n        _fishFee = _newFishFee;\\n        _whaleFee = _newWhaleFee;\\n        _partnerFee = _newPartnerFee;\\n        emit FeesUpdated(_newFishFee, _newWhaleFee, _newPartnerFee);\\n    }\\n\\n    /**\\n     * @notice Set the maximum number of trades that can occur in a single TX\\n     * @param maxTrades_ Max trades\\n     */\\n    function setMaxTrades(uint8 maxTrades_) external onlyOwner {\\n        if (maxTrades_ == 0 || MAX_TRADES_UPPER_LIMIT < maxTrades_)\\n            revert OTSeaErrors.InvalidAmount();\\n        _maxTrades = maxTrades_;\\n        emit MaxTradesUpdated(maxTrades_);\\n    }\\n\\n    /**\\n     * @notice Add, remove or update a partner's details\\n     * @param _token Token address\\n     * @param _partner Partner details\\n     */\\n    function updatePartner(address _token, Partner calldata _partner) external onlyOwner {\\n        if (_token == address(0)) revert OTSeaErrors.InvalidAddress();\\n        if (\\n            _partners[_token].account == _partner.account &&\\n            _partners[_token].isLockUpOverrideEnabled == _partner.isLockUpOverrideEnabled\\n        ) revert OTSeaErrors.Unchanged();\\n        if (_partner.account == address(0) && _partner.isLockUpOverrideEnabled)\\n            revert OTSeaErrors.NotAvailable();\\n        _partners[_token] = Partner(_partner.account, _partner.isLockUpOverrideEnabled);\\n        emit PartnerUpdated(_token, _partner);\\n    }\\n\\n    /**\\n     * @notice Add/remove a lock-up override for a token, only the partner and the owner can make this change\\n     * @param _token Token address\\n     * @param _enforce enable (true) or disable (false)\\n     * @dev If token lock-up override is enabled, when swapping ETH for tokens, the tokens will be held in the contract\\n     * for the trader to claim after the _lockupPeriod has passed. If disabled, it will fallback to the Order.withLockUp\\n     * boolean when swapping ETH for tokens.\\n     */\\n    function updateLockUpOverride(address _token, bool _enforce) external {\\n        Partner storage partner = _partners[_token];\\n        /// @dev no need to check if _token is the zero address because partner.account would equal the zero address\\n        if (partner.account == address(0)) revert OTSeaErrors.NotAvailable();\\n        if (partner.account != _msgSender() && owner() != _msgSender())\\n            revert OTSeaErrors.Unauthorized();\\n        if (partner.isLockUpOverrideEnabled == _enforce) revert OTSeaErrors.Unchanged();\\n        partner.isLockUpOverrideEnabled = _enforce;\\n        emit LockUpOverrideUpdated(_token, _msgSender(), _enforce);\\n    }\\n\\n    /**\\n     * @notice Set the lockup period for orders using a lock-up or for tokens that have enforced a lock-up override\\n     * @param _time Time (in seconds)\\n     */\\n    function setLockupPeriod(uint16 _time) external onlyOwner {\\n        if (_time < MIN_LOCKUP_TIME || MAX_LOCKUP_TIME < _time) revert OTSeaErrors.InvalidAmount();\\n        _lockupPeriod = _time;\\n        emit LockupPeriodUpdated(_time);\\n    }\\n\\n    /**\\n     * @notice Add/remove an account from the blacklist\\n     * @param _account Account\\n     * @param _operation add (true) or remove (false) \\\"account\\\" to/from the blacklist\\n     * @dev Blacklisting an account prevents them from creating orders, trading, updating an order,\\n     * and other users interacting with their orders. Blacklisted users can only cancel orders and claim\\n     * their locked-up tokens.\\n     */\\n    function blacklistAccount(address _account, bool _operation) external onlyOwner {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        if (_blacklist[_account] == _operation) revert OTSeaErrors.Unchanged();\\n        _blacklist[_account] = _operation;\\n        emit BlacklistUpdated(_account, _operation);\\n    }\\n\\n    /**\\n     * @notice Initiate the creation of a buy order\\n     * @param _newOrder Core new order details\\n     * @param _whitelist List of exclusive users allowed to trade the order (optional)\\n     * @dev no need for nonReentrant modifier because no external calls are made\\n     */\\n    function createBuyOrder(\\n        NewOrder calldata _newOrder,\\n        address[] calldata _whitelist\\n    ) external payable whenNotPaused whenNotBlacklisted {\\n        if (address(_newOrder.token) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        if (msg.value != _newOrder.totalInput) revert OTSeaErrors.InvalidETH(_newOrder.totalInput);\\n        uint72 orderID = _createBuyOrder(_newOrder);\\n        if (_whitelist.length != 0) {\\n            _initializeWhitelist(orderID, _whitelist);\\n        }\\n    }\\n\\n    /**\\n     * @notice Initiate the creation of a sell order\\n     * @param _newOrder Core new order details\\n     * @param _whitelist List of exclusive users allowed to trade the order (optional)\\n     * @param _feeDetailsSignature Fee details signature (optional)\\n     */\\n    function createSellOrder(\\n        NewOrder calldata _newOrder,\\n        address[] calldata _whitelist,\\n        FeeDetailsSignature calldata _feeDetailsSignature\\n    ) external nonReentrant whenNotPaused whenNotBlacklisted {\\n        if (address(_newOrder.token) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        /// @dev retrieve the fee type to be stored against the order\\n        OTSeaLibrary.FeeType feeType = _retrieveFeeDetails(_feeDetailsSignature);\\n        uint72 orderID = _createSellOrder(_newOrder, feeType);\\n        if (_whitelist.length != 0) {\\n            _initializeWhitelist(orderID, _whitelist);\\n        }\\n    }\\n\\n    /**\\n     * @notice Swap ETH for tokens (interacts with sell orders)\\n     * @param _token Token address\\n     * @param _trades Trades\\n     * @param _newOrder Core new order details\\n     * @param _allowLockUps Allow trades to have lock-ups (true), disallow trades to have lock-ups (false)\\n     * @param _expectedLockupPeriod The current lockupPeriod defined by _lockupPeriod\\n     * @dev _allowLockups act as a safety measure to ensure the user is comfortable with some or all trades resulting\\n     * in tokens being locked. _expectedLockupPeriod should match the current _lockupPeriod, this is in case the owner\\n     * changes the _lockupPeriod.\\n     */\\n    function swapETHForTokens(\\n        IERC20 _token,\\n        Trade[] calldata _trades,\\n        NewOrder calldata _newOrder,\\n        bool _allowLockUps,\\n        uint16 _expectedLockupPeriod\\n    ) external payable nonReentrant whenNotPaused whenNotBlacklisted {\\n        if (_allowLockUps && _expectedLockupPeriod != _lockupPeriod)\\n            revert OTSeaErrors.ExpectationMismatch();\\n        (\\n            uint256 totalAmountToSwap,\\n            uint256 totalAmountToReceive,\\n            uint256 totalAmountToClaim,\\n            uint256 totalRevenue\\n        ) = _executeBuy(_token, _trades, _allowLockUps);\\n        if (_newOrder.token == _token) {\\n            /// @dev create a buy order\\n            if (totalAmountToSwap + _newOrder.totalInput != msg.value)\\n                revert OTSeaErrors.InvalidETH(totalAmountToSwap + _newOrder.totalInput);\\n            /// @dev _newOrder.totalInput (ETH) is left in the contract for users to sell tokens for\\n            _createBuyOrder(_newOrder);\\n        } else if (totalAmountToSwap != msg.value) {\\n            /**\\n             * @dev if _newOrder.token != _token then the user does not wish to place a new order therefore if\\n             * msg.value is not equal to totalAmountToSwap, then the incorrect amount of ETH has been paid\\n             */\\n            revert OTSeaErrors.InvalidETH(totalAmountToSwap);\\n        }\\n        _transferRevenue(totalRevenue, address(_token));\\n        /// @dev a swap results in tokens either being locked, directly transferred to the user, or both\\n        if (totalAmountToClaim != 0) {\\n            /// @dev lock-up the (totalAmountToClaim) tokens for the user to claim after the lockup period has passed\\n            _lockUps[_msgSender()].push(\\n                LockUp(\\n                    address(_token),\\n                    uint88(block.timestamp + _lockupPeriod),\\n                    totalAmountToClaim,\\n                    0\\n                )\\n            );\\n        }\\n        if (totalAmountToReceive != 0) {\\n            /// @dev transfer the purchased tokens to the caller\\n            _token.safeTransfer(_msgSender(), totalAmountToReceive);\\n        }\\n        emit SwappedETHForTokens(\\n            _msgSender(),\\n            address(_token),\\n            _trades,\\n            totalAmountToSwap,\\n            totalAmountToReceive,\\n            totalAmountToClaim\\n        );\\n    }\\n\\n    /**\\n     * @notice Swap tokens for ETH (interacts with buy orders)\\n     * @param _token Token address\\n     * @param _trades Trades\\n     * @param _newOrder Core new order details\\n     * @param _feeDetailsSignature Signature containing data about msg.sender's fee type\\n     */\\n    function swapTokensForETH(\\n        IERC20 _token,\\n        Trade[] calldata _trades,\\n        NewOrder calldata _newOrder,\\n        FeeDetailsSignature calldata _feeDetailsSignature\\n    ) external nonReentrant whenNotPaused whenNotBlacklisted {\\n        OTSeaLibrary.FeeType feeType = _retrieveFeeDetails(_feeDetailsSignature);\\n        (uint256 totalAmountToSwap, uint256 totalAmountToReceive) = _executeSell(_token, _trades);\\n        if (_newOrder.token == _token) {\\n            /// @dev create a sell order.\\n            _createSellOrder(_newOrder, feeType);\\n        }\\n        /// @dev transfer out ETH.\\n        uint256 revenue = _handleETHPayment(_msgSender(), totalAmountToReceive, feeType);\\n        _transferRevenue(revenue, address(_token));\\n        emit SwappedTokensForETH(\\n            _msgSender(),\\n            address(_token),\\n            _trades,\\n            totalAmountToSwap,\\n            totalAmountToReceive,\\n            feeType\\n        );\\n    }\\n\\n    /**\\n     * @notice Claim multiple lock-ups (supports lock-ups with different tokens)\\n     * @param _receiver Address to receive tokens\\n     * @param _claims A list of claims\\n     * @dev The purpose of the _receiver is in case the transfer were to fail (e.g. max wallet reached). ClaimLockUp\\n     * includes an amount, this is essential because a token may have a max tx limit in place wish could result\\n     * in a transfer failing. Therefore the user simply needs to claim in small chunks.\\n     * Blacklisted users can claim their lock-ups.\\n     */\\n    function claimLockUps(address _receiver, ClaimLockUp[] calldata _claims) external {\\n        uint256 total = _lockUps[_msgSender()].length;\\n        if (total == 0) revert OTSeaErrors.NotAvailable();\\n        uint256 length = _claims.length;\\n        _validateListLength(length);\\n        for (uint256 i; i < length; ) {\\n            ClaimLockUp calldata _claim = _claims[i];\\n            if (total <= _claim.index) revert OTSeaErrors.InvalidIndex(i);\\n            LockUp memory lockUp = _lockUps[_msgSender()][_claim.index];\\n            if (block.timestamp < lockUp.unlockAt) revert UnlockDateNotReached(i);\\n            uint256 remaining = lockUp.amount - lockUp.withdrawn;\\n            if (_claim.amount == 0 || remaining < _claim.amount)\\n                revert OTSeaErrors.InvalidAmountAtIndex(i);\\n            _lockUps[_msgSender()][_claim.index].withdrawn += _claim.amount;\\n            IERC20(lockUp.token).safeTransfer(_receiver, _claim.amount);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        emit LockUpsClaimed(_msgSender(), _receiver, _claims);\\n    }\\n\\n    /**\\n     * @notice Claim multiple lock-ups (supports only lock-ups with the same tokens)\\n     * @param _token Token address\\n     * @param _receiver Address to receive tokens\\n     * @param _claims A list of claims\\n     * @dev use this function if claiming lock-ups for the same token as it is more gas efficient. The purpose of\\n     * the _receiver is in case the transfer were to fail (e.g. max wallet reached). ClaimLockUp\\n     * includes an amount, this is essential because a token may have a max tx limit in place wish could result\\n     * in a transfer failing. Therefore the user simply needs to claim in small chunks over multiple txs.\\n     * Blacklisted users can claim their lock-ups.\\n     */\\n    function claimLockUpByToken(\\n        IERC20 _token,\\n        address _receiver,\\n        ClaimLockUp[] calldata _claims\\n    ) external {\\n        if (address(_token) == address(0)) revert OTSeaErrors.InvalidAddress();\\n        uint256 total = _lockUps[_msgSender()].length;\\n        if (total == 0) revert OTSeaErrors.NotAvailable();\\n        uint256 length = _claims.length;\\n        _validateListLength(length);\\n        uint256 totalToClaim;\\n        for (uint256 i; i < length; ) {\\n            ClaimLockUp calldata _claim = _claims[i];\\n            if (total <= _claim.index) revert OTSeaErrors.InvalidIndex(i);\\n            LockUp memory lockUp = _lockUps[_msgSender()][_claim.index];\\n            if (lockUp.token != address(_token)) revert OTSeaErrors.InvalidAddressAtIndex(i);\\n            if (block.timestamp < lockUp.unlockAt) revert UnlockDateNotReached(i);\\n            uint256 remaining = lockUp.amount - lockUp.withdrawn;\\n            if (_claim.amount == 0 || remaining < _claim.amount)\\n                revert OTSeaErrors.InvalidAmountAtIndex(i);\\n            _lockUps[_msgSender()][_claim.index].withdrawn += _claim.amount;\\n            totalToClaim += _claim.amount;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        _token.safeTransfer(_receiver, totalToClaim);\\n        emit LockUpsClaimed(_msgSender(), _receiver, _claims);\\n    }\\n\\n    /**\\n     * @notice Update the price of an order\\n     * @param _orderID Order ID\\n     * @param _expectedRemainingInput Expected remaining input\\n     * @param _newRemainingOutput New output value for the remaining input\\n     */\\n    function updatePrice(\\n        uint72 _orderID,\\n        uint256 _expectedRemainingInput,\\n        uint256 _newRemainingOutput\\n    ) external onlyOrderCreator(_orderID) whenNotPaused whenNotBlacklisted {\\n        Order storage order = _orders[_orderID];\\n        if (order.state != State.Open) revert OTSeaErrors.NotAvailable();\\n        if (_newRemainingOutput == 0) revert OTSeaErrors.InvalidAmount();\\n        if (order.totalInput - order.inputTransacted != _expectedRemainingInput)\\n            revert OTSeaErrors.ExpectationMismatch();\\n        uint256 newTotalOutput = order.outputTransacted + _newRemainingOutput;\\n        order.totalOutput = newTotalOutput;\\n        emit OrderPriceUpdated(_orderID, newTotalOutput);\\n    }\\n\\n    /**\\n     * @notice Update an order's whitelist\\n     * @param _orderID Order ID\\n     * @param _updates Whitelist updates\\n     */\\n    function updateWhitelist(\\n        uint72 _orderID,\\n        WhitelistUpdate[] calldata _updates\\n    ) external override onlyOrderCreator(_orderID) whenNotPaused whenNotBlacklisted {\\n        if (_orders[_orderID].state != State.Open) revert OTSeaErrors.NotAvailable();\\n        _updateWhitelist(_orderID, _updates);\\n    }\\n\\n    /**\\n     * @notice Update a sell order to enforce or remove a lock-up when traded with\\n     * @param _orderID Order ID\\n     * @param _enforce enable (true) or disable (false)\\n     */\\n    function updateOrderLockUp(\\n        uint72 _orderID,\\n        bool _enforce\\n    ) external onlyOrderCreator(_orderID) whenNotPaused whenNotBlacklisted {\\n        Order storage order = _orders[_orderID];\\n        if (order.state != State.Open || order.orderType == OrderType.Buy)\\n            revert OTSeaErrors.NotAvailable();\\n        if (order.withLockUp == _enforce) revert OTSeaErrors.Unchanged();\\n        order.withLockUp = _enforce;\\n        emit OrderLockUpUpdated(_orderID, _enforce);\\n    }\\n\\n    /**\\n     * @notice Cancel multiple orders (supports orders with different tokens)\\n     * @param _orderIDs A list of order IDs to cancel\\n     * @dev Blacklisted users can cancel orders\\n     */\\n    function cancelOrders(uint72[] calldata _orderIDs) external nonReentrant {\\n        uint256 total = _orderIDs.length;\\n        if (total == 0 || MAX_CANCELLATIONS < total) revert OTSeaErrors.InvalidArrayLength();\\n        uint256 totalETHOwed;\\n        uint256 i;\\n        for (i; i < total; ) {\\n            Order storage order = _orders[_orderIDs[i]];\\n            if (order.creator != _msgSender()) revert OTSeaErrors.Unauthorized();\\n            if (order.state != State.Open) revert OTSeaErrors.NotAvailable();\\n            order.state = State.Cancelled;\\n            uint256 outstanding = order.totalInput - order.inputTransacted;\\n            if (order.orderType == OrderType.Buy) {\\n                /// @dev transfer unsold ETH.\\n                totalETHOwed += outstanding;\\n            } else {\\n                /// @dev transfer unsold tokens.\\n                order.token.safeTransfer(order.creator, outstanding);\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        if (totalETHOwed != 0) {\\n            _safeETHTransfer(_msgSender(), totalETHOwed);\\n        }\\n        emit CancelledOrders(_orderIDs);\\n    }\\n\\n    /**\\n     * @notice Cancel multiple orders (supports only orders with the same tokens)\\n     * @param _token Token address\\n     * @param _orderIDs A list of order IDs to cancel\\n     * @dev use this function if cancelling orders with the same token as it is more gas efficient.\\n     * Blacklisted users can cancel orders\\n     */\\n    function cancelTokenOrders(IERC20 _token, uint72[] calldata _orderIDs) external nonReentrant {\\n        uint256 total = _orderIDs.length;\\n        if (total == 0 || MAX_CANCELLATIONS < total) revert OTSeaErrors.InvalidArrayLength();\\n        uint256 totalETHOwed;\\n        uint256 totalTokensOwed;\\n        uint256 i;\\n        for (i; i < total; ) {\\n            Order storage order = _orders[_orderIDs[i]];\\n            if (order.creator != _msgSender()) revert OTSeaErrors.Unauthorized();\\n            if (order.state != State.Open || order.token != _token)\\n                revert OTSeaErrors.NotAvailable();\\n            order.state = State.Cancelled;\\n            uint256 outstanding = order.totalInput - order.inputTransacted;\\n            if (order.orderType == OrderType.Buy) {\\n                /// @dev transfer unsold ETH.\\n                totalETHOwed += outstanding;\\n            } else {\\n                /// @dev transfer unsold tokens.\\n                totalTokensOwed += outstanding;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        if (totalETHOwed != 0) {\\n            _safeETHTransfer(_msgSender(), totalETHOwed);\\n        }\\n        if (totalTokensOwed != 0) {\\n            _token.safeTransfer(_msgSender(), totalTokensOwed);\\n        }\\n        emit CancelledOrders(_orderIDs);\\n    }\\n\\n    /**\\n     * @notice Get the total number of orders\\n     * @return uint72 Total orders\\n     */\\n    function getTotalOrders() external view returns (uint72) {\\n        return _totalOrders;\\n    }\\n\\n    /**\\n     * @notice Get an order by ID\\n     * @param _orderID Order ID\\n     * @return order Order details\\n     */\\n    function getOrder(uint72 _orderID) external view returns (Order memory order) {\\n        _checkIDExists(_orderID);\\n        return _orders[_orderID];\\n    }\\n\\n    /**\\n     * @notice Get a list of orders in a sequence from an order ID to another order ID\\n     * @param _start Start order ID\\n     * @param _end End order ID\\n     * @return orders A list of orders starting and _start and ending at _end\\n     */\\n    function getOrdersInSequence(\\n        uint256 _start,\\n        uint256 _end\\n    )\\n        external\\n        view\\n        onlyValidSequence(_start, _end, _totalOrders, DISALLOW_ZERO)\\n        returns (Order[] memory orders)\\n    {\\n        orders = new Order[](_end - _start + 1);\\n        uint256 index;\\n        uint256 orderId = _start;\\n        for (orderId; orderId <= _end; ) {\\n            orders[index++] = _orders[uint72(orderId)];\\n            unchecked {\\n                orderId++;\\n            }\\n        }\\n        return orders;\\n    }\\n\\n    /**\\n     * @notice Get a list of orders by a list of order IDs\\n     * @param _orderIDs Order IDs\\n     * @return orders A list of orders with each index corresponding to _orderIDs\\n     */\\n    function getOrdersByIDs(\\n        uint72[] calldata _orderIDs\\n    ) external view returns (Order[] memory orders) {\\n        uint256 length = _orderIDs.length;\\n        _validateListLength(length);\\n        orders = new Order[](length);\\n        uint256 i;\\n        for (i; i < length; ) {\\n            _checkIDExists(_orderIDs[i]);\\n            orders[i] = _orders[_orderIDs[i]];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return orders;\\n    }\\n\\n    /**\\n     * @notice Get the lockup period\\n     * @return uint16 Lockup period\\n     */\\n    function getLockupPeriod() public view returns (uint16) {\\n        return _lockupPeriod;\\n    }\\n\\n    /**\\n     * @notice Get the total lock-ups for a user\\n     * @param _account Account\\n     * @return uint256 Total lock-ups for _account\\n     */\\n    function getTotalLockUps(address _account) public view returns (uint256) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _lockUps[_account].length;\\n    }\\n\\n    /**\\n     * @notice Get lock-ups for a user\\n     * @param _account Account\\n     * @param _indexes Indexes\\n     * @return lockUps Lock-up list\\n     */\\n    function getLockUps(\\n        address _account,\\n        uint256[] calldata _indexes\\n    ) external view returns (LockUp[] memory lockUps) {\\n        uint256 total = getTotalLockUps(_account);\\n        uint256 length = _indexes.length;\\n        _validateListLength(length);\\n        lockUps = new LockUp[](length);\\n        uint256 i;\\n        for (i; i < length; ) {\\n            if (total <= _indexes[i]) revert OTSeaErrors.InvalidIndex(i);\\n            lockUps[i] = _lockUps[_account][_indexes[i]];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return lockUps;\\n    }\\n\\n    /**\\n     * @notice Get fee percents\\n     * @return fishFee Fish fee percent\\n     * @return whaleFee Whale fee percent\\n     * @return partnerFee Partner fee percent\\n     */\\n    function getFees() external view returns (uint8 fishFee, uint8 whaleFee, uint16 partnerFee) {\\n        return (_fishFee, _whaleFee, _partnerFee);\\n    }\\n\\n    /**\\n     * @notice Get the maximum number of trades that can be executed in a single TX\\n     * @return uint8 Maximum number of trades\\n     */\\n    function getMaxTrades() external view returns (uint8) {\\n        return _maxTrades;\\n    }\\n\\n    /**\\n     * @notice Get partner details for a token\\n     * @param _token Token address\\n     * @return Partner Partner details\\n     */\\n    function getPartner(address _token) external view returns (Partner memory) {\\n        if (_token == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _partners[_token];\\n    }\\n\\n    /**\\n     * @notice Check if an account is blacklisted\\n     * @param _account Account\\n     * @return bool true if blacklisted, false if not\\n     */\\n    function isAccountBlacklisted(address _account) external view returns (bool) {\\n        if (_account == address(0)) revert OTSeaErrors.InvalidAddress();\\n        return _blacklist[_account];\\n    }\\n\\n    /**\\n     * @notice Check if an order is blacklisted\\n     * @param _orderID Order ID\\n     * @return bool true if blacklisted, false if not\\n     */\\n    function isOrderBlacklisted(uint72 _orderID) external view returns (bool) {\\n        _checkIDExists(_orderID);\\n        return _blacklist[_orders[_orderID].creator];\\n    }\\n\\n    /**\\n     * @param _newOrder Core new order details\\n     * @return orderID Order ID\\n     */\\n    function _createBuyOrder(NewOrder calldata _newOrder) private returns (uint72 orderID) {\\n        /// @dev lock-ups can only be used on sell orders\\n        if (_newOrder.withLockUp) revert LockUpNotAllowed();\\n        if (_newOrder.totalInput == 0 || _newOrder.totalOutput == 0)\\n            revert OTSeaErrors.InvalidAmount();\\n        orderID = ++_totalOrders;\\n        _orders[orderID] = Order({\\n            creator: _msgSender(),\\n            orderType: OrderType.Buy,\\n            state: State.Open,\\n            /// @dev feeType is set to the default FeeType (fish) because it is ignored for buy orders\\n            feeType: OTSeaLibrary.FeeType.Fish,\\n            isAON: _newOrder.isAON,\\n            isHidden: _newOrder.isHidden,\\n            withLockUp: false,\\n            token: _newOrder.token,\\n            totalInput: _newOrder.totalInput,\\n            inputTransacted: 0,\\n            totalOutput: _newOrder.totalOutput,\\n            outputTransacted: 0\\n        });\\n        emit BuyOrderCreated(\\n            orderID,\\n            _msgSender(),\\n            _newOrder,\\n            IERC20Metadata(address(_newOrder.token)).decimals()\\n        );\\n    }\\n\\n    /**\\n     * @param _newOrder Core new order details\\n     * @param _feeType Fee type\\n     * @return orderID Order ID\\n     */\\n    function _createSellOrder(\\n        NewOrder calldata _newOrder,\\n        OTSeaLibrary.FeeType _feeType\\n    ) private returns (uint72 orderID) {\\n        if (_newOrder.totalInput == 0 || _newOrder.totalOutput == 0)\\n            revert OTSeaErrors.InvalidAmount();\\n        orderID = ++_totalOrders;\\n        uint256 totalInput = _transferInTokens(_newOrder.token, _newOrder.totalInput);\\n        /// @dev if the tokens transferred does not match the amount, then the total ETH should be adjusted to account for taxes.\\n        uint256 totalOutput = totalInput == _newOrder.totalInput\\n            ? _newOrder.totalOutput\\n            : (_newOrder.totalOutput * totalInput) / _newOrder.totalInput;\\n        _orders[orderID] = Order({\\n            creator: _msgSender(),\\n            orderType: OrderType.Sell,\\n            state: State.Open,\\n            feeType: _feeType,\\n            isAON: _newOrder.isAON,\\n            isHidden: _newOrder.isHidden,\\n            withLockUp: _newOrder.withLockUp,\\n            token: _newOrder.token,\\n            totalInput: totalInput,\\n            inputTransacted: 0,\\n            totalOutput: totalOutput,\\n            outputTransacted: 0\\n        });\\n        emit SellOrderCreated(\\n            orderID,\\n            _msgSender(),\\n            _newOrder,\\n            totalInput,\\n            totalOutput,\\n            _feeType,\\n            IERC20Metadata(address(_newOrder.token)).decimals()\\n        );\\n    }\\n\\n    /**\\n     * @param _token Token to buy\\n     * @param _trades Trades to execute\\n     * @param _allowLockUps Allow trades to have lock-ups (true), disallow trades to have lock-ups (false)\\n     * @return totalAmountToSwap Total ETH to swap\\n     * @return totalAmountToReceive Total tokens to receive\\n     * @return totalAmountToClaim Total tokens to claim after the _lockupPeriod\\n     * @return totalRevenue Total revenue\\n     */\\n    function _executeBuy(\\n        IERC20 _token,\\n        Trade[] calldata _trades,\\n        bool _allowLockUps\\n    )\\n        private\\n        returns (\\n            uint256 totalAmountToSwap,\\n            uint256 totalAmountToReceive,\\n            uint256 totalAmountToClaim,\\n            uint256 totalRevenue\\n        )\\n    {\\n        uint256 total = _trades.length;\\n        if (total == 0 || _maxTrades < total) revert OTSeaErrors.InvalidArrayLength();\\n        bool isLockUpOverrideEnabled = _partners[address(_token)].isLockUpOverrideEnabled;\\n        if (isLockUpOverrideEnabled && !_allowLockUps) revert OTSeaErrors.ExpectationMismatch();\\n        uint256 i;\\n        for (i; i < total; ) {\\n            Trade calldata trade = _trades[i];\\n            Order storage order = _orders[trade.orderID];\\n            if (_blacklist[order.creator]) revert OrderBlacklisted();\\n            /// @dev orders should only be sell orders (which means there is no need to check if the order ID exists).\\n            if (order.orderType == OrderType.Buy) revert InvalidTradeOrderType();\\n            uint256 amountToReceive = _executeTrade(_token, trade);\\n            totalRevenue += _handleETHPayment(order.creator, trade.amountToSwap, order.feeType);\\n            /// @dev total tokens to send to msg.sender.\\n            totalAmountToSwap += trade.amountToSwap;\\n            if (isLockUpOverrideEnabled || order.withLockUp) {\\n                if (!_allowLockUps) revert OTSeaErrors.ExpectationMismatch();\\n                totalAmountToClaim += amountToReceive;\\n            } else {\\n                totalAmountToReceive += amountToReceive;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return (totalAmountToSwap, totalAmountToReceive, totalAmountToClaim, totalRevenue);\\n    }\\n\\n    /**\\n     * @param _token Token to sell\\n     * @param _trades Trades to execute\\n     * @return totalAmountToSwap Total tokens to swap\\n     * @return totalAmountToReceive Total ETH to receive\\n     */\\n    function _executeSell(\\n        IERC20 _token,\\n        Trade[] calldata _trades\\n    ) private returns (uint256 totalAmountToSwap, uint256 totalAmountToReceive) {\\n        uint256 total = _trades.length;\\n        if (total == 0 || _maxTrades < total) revert OTSeaErrors.InvalidArrayLength();\\n        uint256 i;\\n        for (i; i < total; ) {\\n            Trade calldata trade = _trades[i];\\n            _checkIDExists(trade.orderID);\\n            Order storage order = _orders[trade.orderID];\\n            if (_blacklist[order.creator]) revert OrderBlacklisted();\\n            /// @dev orders should only be buy orders.\\n            if (order.orderType == OrderType.Sell) revert InvalidTradeOrderType();\\n            uint256 amountToReceive = _executeTrade(_token, trade);\\n            _token.safeTransferFrom(_msgSender(), order.creator, trade.amountToSwap);\\n            /// @dev total ETH swapped.\\n            totalAmountToSwap += trade.amountToSwap;\\n            /// @dev total tokens to send to msg.sender.\\n            totalAmountToReceive += amountToReceive;\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return (totalAmountToSwap, totalAmountToReceive);\\n    }\\n\\n    /**\\n     * @param _token Token to trade\\n     * @param _trade Trade to execute\\n     * @return amountToReceive Amount to receive\\n     * @dev a generic function used both when buying and selling\\n     */\\n    function _executeTrade(\\n        IERC20 _token,\\n        Trade calldata _trade\\n    ) private returns (uint256 amountToReceive) {\\n        Order storage order = _orders[_trade.orderID];\\n        if (order.state != State.Open || order.token != _token) revert OTSeaErrors.NotAvailable();\\n        if (\\n            _getTotalWhitelisted(_trade.orderID) != 0 &&\\n            !_checkIsWhitelisted(_msgSender(), _trade.orderID)\\n        ) revert OTSeaErrors.Unauthorized();\\n        if (_trade.amountToSwap == 0) revert OTSeaErrors.InvalidAmount();\\n        /// @dev owner of order can change price therefore we much check the trade totalOutput matches the on-chain value\\n        if (order.totalOutput != _trade.totalOutput) revert OTSeaErrors.ExpectationMismatch();\\n        uint256 remainingInput = order.totalInput - order.inputTransacted;\\n        uint256 remainingOutput = order.totalOutput - order.outputTransacted;\\n        if (\\n            order.isAON\\n                ? _trade.amountToSwap != remainingOutput\\n                : remainingOutput < _trade.amountToSwap\\n        ) revert OTSeaErrors.InvalidPurchase();\\n        if (_trade.amountToSwap == remainingOutput) {\\n            amountToReceive = remainingInput;\\n            order.state = State.Fulfilled;\\n        } else {\\n            amountToReceive = (remainingInput * _trade.amountToSwap) / remainingOutput;\\n        }\\n        order.inputTransacted += amountToReceive;\\n        order.outputTransacted += _trade.amountToSwap;\\n        emit Traded(_trade.orderID, _msgSender(), _trade.amountToSwap, amountToReceive);\\n    }\\n\\n    /**\\n     * @param _account Account to send ETH to\\n     * @param _amount Amount of ETH to send to _account\\n     * @param _feeType Fee type of _account\\n     * @return revenue Amount of ETH revenue\\n     * @dev a function to calculate the revenue and transfer the remaining ETH to an account\\n     */\\n    function _handleETHPayment(\\n        address _account,\\n        uint256 _amount,\\n        OTSeaLibrary.FeeType _feeType\\n    ) private returns (uint256 revenue) {\\n        revenue =\\n            (_amount * (_feeType == OTSeaLibrary.FeeType.Fish ? _fishFee : _whaleFee)) /\\n            OTSeaLibrary.PERCENT_DENOMINATOR;\\n        _safeETHTransfer(_account, _amount - revenue);\\n    }\\n\\n    /**\\n     * @param _revenue Revenue\\n     * @param _token Token\\n     * @dev Pays partner fee (if applicable) and transfers the remaining revenue to the revenue distributor\\n     */\\n    function _transferRevenue(uint256 _revenue, address _token) private {\\n        address partner = _partners[_token].account;\\n        if (partner != address(0)) {\\n            uint256 fee = (_revenue * _partnerFee) / OTSeaLibrary.PERCENT_DENOMINATOR;\\n            _revenue -= fee;\\n            _safeETHTransfer(partner, fee);\\n            emit PartnerFeePaid(_token, partner, fee);\\n        }\\n        /// @dev no need to safely transfer ETH because revenueDistributor has a receive() function\\n        _transferETHOrRevert(_revenueDistributor, _revenue);\\n        emit RevenueTransferred(_revenue);\\n    }\\n\\n    /// @param _orderID Order ID\\n    function _checkIDExists(uint72 _orderID) internal view override {\\n        if (_orderID == 0 || _totalOrders < _orderID) revert OrderNotFound(_orderID);\\n    }\\n\\n    /**\\n     * @param _feeDetailsSignature Fee details signature\\n     * @return feeType Fee type\\n     * @dev verifies the signature (if present) and returns the fee type\\n     */\\n    function _retrieveFeeDetails(\\n        FeeDetailsSignature calldata _feeDetailsSignature\\n    ) private view returns (OTSeaLibrary.FeeType feeType) {\\n        /// @dev if no signature is present then the user is a fish\\n        if (_feeDetailsSignature.signature.length == 0) {\\n            return feeType;\\n        }\\n        /// @dev reconstruct data that was signed off-chain\\n        bytes memory data = abi.encode(\\n            FEE_DETAILS_SIGNATURE_TYPE,\\n            _msgSender(),\\n            _feeDetailsSignature.expiresAt,\\n            _feeDetailsSignature.feeType\\n        );\\n        /// @dev check the signature was signed by the signer\\n        _checkSignature(data, _feeDetailsSignature.signature, _feeDetailsSignature.expiresAt);\\n        return _feeDetailsSignature.feeType;\\n    }\\n\\n    /// @param _orderID Order ID\\n    function _checkCallerIsOrderCreator(uint72 _orderID) private view {\\n        /**\\n         * @dev it is more efficient calling _checkIDExists(_orderID) here than in the modifier because using it\\n         * in a modifier would duplicate the same code across all functions where it is used.\\n         */\\n        _checkIDExists(_orderID);\\n        if (_orders[_orderID].creator != _msgSender()) revert OTSeaErrors.Unauthorized();\\n    }\\n\\n    function _checkCallerIsNotBlacklisted() private view {\\n        if (_blacklist[_msgSender()]) revert OTSeaErrors.Unauthorized();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multiSigAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"revenueDistributor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AddressNotFoundAtIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DuplicateAddressAtIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectationMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidAddressAtIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidAmountAtIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InvalidETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPurchase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSequence\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStart\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTradeOrderType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockUpNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderBlacklisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"}],\"name\":\"OrderNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureRequired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unchanged\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"UnlockDateNotReached\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"operation\",\"type\":\"bool\"}],\"name\":\"BlacklistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"newOrder\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"BuyOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint72[]\",\"name\":\"orderIDs\",\"type\":\"uint72[]\"}],\"name\":\"CancelledOrders\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"fishFee\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"whaleFee\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"partnerFee\",\"type\":\"uint16\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enforced\",\"type\":\"bool\"}],\"name\":\"LockUpOverrideUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OTSea.ClaimLockUp[]\",\"name\":\"claims\",\"type\":\"tuple[]\"}],\"name\":\"LockUpsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"time\",\"type\":\"uint16\"}],\"name\":\"LockupPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaroonedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaroonedETHClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"maxSwaps\",\"type\":\"uint8\"}],\"name\":\"MaxTradesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enforced\",\"type\":\"bool\"}],\"name\":\"OrderLockUpUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalOutput\",\"type\":\"uint256\"}],\"name\":\"OrderPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"PartnerFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockUpOverrideEnabled\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct OTSea.Partner\",\"name\":\"partner\",\"type\":\"tuple\"}],\"name\":\"PartnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"RevenueTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"newOrder\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualTotalInput\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualTotalOutput\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"SellOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OTSea.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"name\":\"SwappedETHForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OTSea.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"}],\"name\":\"SwappedTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Traded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint72\",\"name\":\"id\",\"type\":\"uint72\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWhitelist\",\"type\":\"uint256\"}],\"name\":\"WhitelistUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_operation\",\"type\":\"bool\"}],\"name\":\"blacklistAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72[]\",\"name\":\"_orderIDs\",\"type\":\"uint72[]\"}],\"name\":\"cancelOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint72[]\",\"name\":\"_orderIDs\",\"type\":\"uint72[]\"}],\"name\":\"cancelTokenOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint72\",\"name\":\"_id\",\"type\":\"uint72\"}],\"name\":\"checkIsWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint72[]\",\"name\":\"_ids\",\"type\":\"uint72[]\"}],\"name\":\"checkMultipleIsWhitelisted\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"isWhitelisted\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.ClaimLockUp[]\",\"name\":\"_claims\",\"type\":\"tuple[]\"}],\"name\":\"claimLockUpByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.ClaimLockUp[]\",\"name\":\"_claims\",\"type\":\"tuple[]\"}],\"name\":\"claimLockUps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"claimMaroonedETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"_newOrder\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_whitelist\",\"type\":\"address[]\"}],\"name\":\"createBuyOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"_newOrder\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_whitelist\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"}],\"internalType\":\"struct OTSea.FeeDetailsSignature\",\"name\":\"_feeDetailsSignature\",\"type\":\"tuple\"}],\"name\":\"createSellOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"fishFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"whaleFee\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"partnerFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"getLockUps\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"unlockAt\",\"type\":\"uint88\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.LockUp[]\",\"name\":\"lockUps\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockupPeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getMaroonedETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTrades\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_orderID\",\"type\":\"uint72\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum OTSea.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSea.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputTransacted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputTransacted\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72[]\",\"name\":\"_orderIDs\",\"type\":\"uint72[]\"}],\"name\":\"getOrdersByIDs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum OTSea.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSea.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputTransacted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputTransacted\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getOrdersInSequence\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum OTSea.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSea.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputTransacted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputTransacted\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPartner\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockUpOverrideEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct OTSea.Partner\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalLockUps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalOrders\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_id\",\"type\":\"uint72\"}],\"name\":\"getTotalWhitelisted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_id\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getWhitelist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"whitelist\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isAccountBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_orderID\",\"type\":\"uint72\"}],\"name\":\"isOrderBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newFishFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_newWhaleFee\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_newPartnerFee\",\"type\":\"uint16\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_time\",\"type\":\"uint16\"}],\"name\":\"setLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxTrades_\",\"type\":\"uint8\"}],\"name\":\"setMaxTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"revenueDistributor_\",\"type\":\"address\"}],\"name\":\"setRevenueDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.Trade[]\",\"name\":\"_trades\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"_newOrder\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_allowLockUps\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"_expectedLockupPeriod\",\"type\":\"uint16\"}],\"name\":\"swapETHForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint72\",\"name\":\"orderID\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.Trade[]\",\"name\":\"_trades\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAON\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withLockUp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isHidden\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"internalType\":\"struct OTSea.NewOrder\",\"name\":\"_newOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"enum OTSeaLibrary.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"}],\"internalType\":\"struct OTSea.FeeDetailsSignature\",\"name\":\"_feeDetailsSignature\",\"type\":\"tuple\"}],\"name\":\"swapTokensForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enforce\",\"type\":\"bool\"}],\"name\":\"updateLockUpOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_orderID\",\"type\":\"uint72\"},{\"internalType\":\"bool\",\"name\":\"_enforce\",\"type\":\"bool\"}],\"name\":\"updateOrderLockUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLockUpOverrideEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct OTSea.Partner\",\"name\":\"_partner\",\"type\":\"tuple\"}],\"name\":\"updatePartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_orderID\",\"type\":\"uint72\"},{\"internalType\":\"uint256\",\"name\":\"_expectedRemainingInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newRemainingOutput\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"_orderID\",\"type\":\"uint72\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"operation\",\"type\":\"bool\"}],\"internalType\":\"struct WhitelistHelper.WhitelistUpdate[]\",\"name\":\"_updates\",\"type\":\"tuple[]\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OTSea", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000adedc7487c59ece60178cf69b8df7e3c4730d9000000000000000000000000034bccf4af03870265fe99cec262524f343cca7ff00000000000000000000000084cf61259efb32244258c0ab910ab4f11e13842b", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}