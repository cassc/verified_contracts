{"SourceCode": "// SPDX-License-Identifier: CC-BY-4.0\r\n/*\r\n\r\n\u2022 \u258c \u2584 \u00b7.  \u2584\u2584\u2584\u00b7 \u2584\u2584\u2584\u2584\u00b7 \u2584\u2584\u258c   \u2584\u2584\u2584\u00b7 \u2584\u2584\u2584\u2584\u00b7\r\n\u00b7\u2588\u2588 \u2590\u2588\u2588\u2588\u25aa\u2590\u2588 \u2580\u2588 \u2590\u2588 \u2580\u2588\u25aa\u2588\u2588\u2022  \u2590\u2588 \u2580\u2588 \u2590\u2588 \u2580\u2588\u25aa\r\n\u2590\u2588 \u258c\u2590\u258c\u2590\u2588\u00b7\u2584\u2588\u2580\u2580\u2588 \u2590\u2588\u2580\u2580\u2588\u2584\u2588\u2588\u25aa  \u2584\u2588\u2580\u2580\u2588 \u2590\u2588\u2580\u2580\u2588\u2584\r\n\u2588\u2588 \u2588\u2588\u258c\u2590\u2588\u258c\u2590\u2588 \u25aa\u2590\u258c\u2588\u2588\u2584\u25aa\u2590\u2588\u2590\u2588\u258c\u2590\u258c\u2590\u2588 \u25aa\u2590\u258c\u2588\u2588\u2584\u25aa\u2590\u2588\r\n\u2580\u2580  \u2588\u25aa\u2580\u2580\u2580 \u2580  \u2580 \u00b7\u2580\u2580\u2580\u2580 .\u2580\u2580\u2580  \u2580  \u2580 \u00b7\u2580\u2580\u2580\u2580\r\n\r\nMABLAB. Piranesi. Fields of Chain.\r\n\r\nv1.0 - December 2023\r\n\r\nwritten by Ariel Sebasti\u00e1n Becker\r\n\r\nNOTICE\r\n======\r\n\r\nThis is a custom contract, tailored and pruned to fit Spurious Dragon's limit of 24,576 bytes.\r\nBecause of that, you will see some modifications made to third-party libraries such as OpenZeppelin's.\r\n\r\nTHIS SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n\r\nTHE AUTHOR WILL NOT BE LIABLE, UNDER ANY CIRCUMSTANCE, FOR THE CONTENT STORED BY THE OWNERS.\r\n\r\n*/\r\n\r\npragma solidity ^0.8.22;\r\nstring constant _strVersion = 'v1.0';\r\nstring constant _strTokenTicker = 'MABLAB';\r\nstring constant _strTokenName = string(abi.encodePacked('MABLAB. Piranesi. Fields of Chain. ', _strVersion));\r\nstring constant _strReverted = 'Unable to send value; recipient may have reverted!';\r\nstring constant _strLowCallFailed = 'Low-level call failed.';\r\nstring constant _strNonContract = 'Call to non-contract.';\r\nstring constant _strDelegateCallFailed = 'Low-level delegate call failed.';\r\nstring constant _strDelegateCallNonContract = 'Low-level delegate call to non-contract.';\r\nstring constant _strBalanceZeroAddy = 'Balance query for the zero address.';\r\nstring constant _strTransferZeroAddy = 'Cannot transfer to the zero address!';\r\nstring constant _strNotAuthorized = 'Not authorized!';\r\nstring constant _strInvalidMultiproof = 'Invalid multiproof.';\r\nstring constant _strTransferFailed = 'Transfer failed.';\r\nstring constant _strBlacklisted = \"Blacklisted address.\";\r\nstring constant _strNotBlacklisted = \"Not a blacklisted address.\";\r\nstring constant _strOutOfBounds = 'Out of bounds!';\r\nstring constant _strAlreadyMinted = 'Already minted!';\r\nstring constant _strPaused = 'Contract is paused.';\r\nstring constant _strNotEnoughBalance = 'Insufficient balance!';\r\nstring constant _strTransferToNon721 = 'Attempted transfer to non ERC721Receiver implementer!';\r\nstring constant _strInvalidParams = 'Invalid params!';\r\n\r\npragma solidity ^0.8.22;\r\ninterface IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns(bool);\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ninterface IERC721 is IERC165 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\tfunction balanceOf(address owner) external view returns(uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns(address owner);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction getApproved(uint256 tokenId) external view returns(address operator);\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns(bool);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ninterface BlackListable {\r\n\tfunction blacklist(address addy) external;\r\n\tfunction unblacklist(address addy) external;\r\n\tfunction isBlacklisted(address addy) external view returns(string memory message);\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ninterface IERC721Receiver {\r\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns(bytes4);\r\n}\r\n\r\npragma solidity ^0.8.22;\r\nlibrary Address {\r\n\r\n\tfunction isContract(address account) internal view returns(bool) {\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, _strNotEnoughBalance);\r\n\t\t(bool success, ) = recipient.call{value: amount}('');\r\n\t\trequire(success, _strReverted);\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns(bytes memory) {\r\n\t\treturn functionCall(target, data, _strLowCallFailed);\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, _strLowCallFailed);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {\r\n\t\trequire(address(this).balance >= value, _strNotEnoughBalance);\r\n\t\trequire(isContract(target), _strNonContract);\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns(bytes memory) {\r\n\t\treturn functionStaticCall(target, data, _strLowCallFailed);\r\n\t}\r\n\r\n\tfunction functionStaticCall( address target, bytes memory data, string memory errorMessage) internal view returns(bytes memory) {\r\n\t\trequire(isContract(target), _strNonContract);\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns(bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, _strDelegateCallFailed);\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n\t\trequire(isContract(target), _strDelegateCallNonContract);\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns(bytes memory) {\r\n\t\tif(success) {\r\n\t\t\treturn returndata;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(returndata.length > 0) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns(address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns(bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\nlibrary Strings {\r\n\tbytes16 private constant _SYMBOLS = '0123456789abcdef';\r\n\tuint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n\tfunction toString(uint256 value) internal pure returns(string memory) {\r\n\t\tif(value == 0) {\r\n\t\t\treturn '0';\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns(string memory) {\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = '0';\r\n\t\tbuffer[1] = 'x';\r\n\t\tfor(uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = _SYMBOLS[value & 0xf];\r\n\t\t\tvalue >>= 4;\r\n\t\t}\r\n\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\tfunction toHexString(address addr) internal pure returns(string memory) {\r\n\t\treturn toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n\t}\r\n\r\n\tfunction stringLength(string memory s) internal pure returns(uint256) {\r\n\t\treturn bytes(s).length;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\nabstract contract ERC165 is IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns(bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ncontract ERC721 is Context, ERC165, IERC721, BlackListable {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\tmapping(uint256 => address) private _owners;\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\tmapping(address => bool) private _blackListedAddresses;\r\n\r\n\tmodifier checkBlacklistOperator(address addy) {\r\n\t\trequire(!_blackListedAddresses[addy], _strBlacklisted);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier checkBlacklistTransfer(address from, address to) {\r\n\t\trequire(!_blackListedAddresses[from] && !_blackListedAddresses[to], _strBlacklisted);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @notice Blacklists an address, preventing it from transfer\r\n\t/// @param addy Address to blacklist.\r\n\tfunction blacklist(address addy) public {\r\n\t\tif(!_blackListedAddresses[addy]) {\r\n\t\t\t_blackListedAddresses[addy] = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Unblacklists an address, allowing it to transfer again.\r\n\t/// @param addy Address to unblacklist.\r\n\tfunction unblacklist(address addy) public {\r\n\t\tif(_blackListedAddresses[addy]) {\r\n\t\t\t_blackListedAddresses[addy] = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Returns whether or not an address is blacklisted.\r\n\t/// @param addy Address to check.\r\n\tfunction isBlacklisted(address addy) public view returns(string memory) {\r\n\t\tif(_blackListedAddresses[addy]) {\r\n\t\t\treturn _strBlacklisted;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn _strNotBlacklisted;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns(bool) {\r\n\t\treturn\r\n\t\tinterfaceId == type(IERC721).interfaceId ||\r\n\t\tsuper.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view virtual override returns(uint256) {\r\n\t\trequire(owner != address(0), _strBalanceZeroAddy);\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns(address) {\r\n\t\taddress owner = _owners[tokenId];\r\n\t\trequire(owner != address(0), _strOutOfBounds);\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction approve(address to, uint256 tokenId) public checkBlacklistOperator(to) virtual override {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\trequire(to != owner, _strNotAuthorized);\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\t_strNotAuthorized\r\n\t\t);\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\tfunction getApproved(uint256 tokenId) public view virtual override returns(address) {\r\n\t\trequire(_exists(tokenId), _strOutOfBounds);\r\n\t\treturn _tokenApprovals[tokenId];\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address operator, bool approved) public checkBlacklistOperator(operator) virtual override {\r\n\t\trequire(operator != _msgSender(), _strNotAuthorized);\r\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\r\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns(bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) public checkBlacklistTransfer(from, to) virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), _strNotAuthorized);\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public checkBlacklistTransfer(from, to) virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenId, '');\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public checkBlacklistTransfer(from, to) virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), _strNotAuthorized);\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal checkBlacklistTransfer(from, to) virtual {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), _strTransferToNon721);\r\n\t}\r\n\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns(bool) {\r\n\t\treturn _owners[tokenId] != address(0);\r\n\t}\r\n\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns(bool) {\r\n\t\trequire(_exists(tokenId), _strOutOfBounds);\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\t\t_safeMint(to, tokenId, '');\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\t\t_mint(to, tokenId);\r\n\t\trequire(\r\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\r\n\t\t\t\t_strTransferToNon721\r\n\t\t);\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(!_exists(tokenId), _strOutOfBounds);\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\t\temit Transfer(address(0), to, tokenId);\r\n\t}\r\n\r\n\tfunction _transfer(address from, address to, uint256 tokenId) internal checkBlacklistTransfer(from, to) virtual {\r\n\t\trequire(ERC721.ownerOf(tokenId) == from, _strNotAuthorized);\r\n\t\trequire(to != address(0), _strTransferZeroAddy);\r\n\t\trequire(_exists(tokenId), _strOutOfBounds);\r\n\t\t_approve(address(0), tokenId);\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId) internal checkBlacklistOperator(to) virtual {\r\n\t\t_tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns(bool) {\r\n\t\tif(to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns(bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif(reason.length == 0) {\r\n\t\t\t\t\trevert(_strTransferToNon721);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ninterface IERC4906 is IERC165, IERC721 {\r\n\t/// @notice This event emits when the metadata of a token is changed.\r\n\t/// So that the third-party platforms such as NFT market could\r\n\t/// timely update the images and related attributes of the NFT.\r\n\tevent MetadataUpdate(uint256 _tokenId);\r\n\r\n\t/// @notice This event emits when the metadata of a range of tokens is changed.\r\n\t/// So that the third-party platforms such as NFT market could\r\n\t/// timely update the images and related attributes of the NFTs.\r\n\tevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ncontract Ownable {\r\n\tstring public constant NOT_CURRENT_OWNER = '018001';\r\n\tstring public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = '018002';\r\n\taddress public owner;\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tconstructor() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, NOT_CURRENT_OWNER);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\trequire(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n\t\temit OwnershipTransferred(owner, _newOwner);\r\n\t\towner = _newOwner;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\n\r\n/**\r\n * @dev Tailored and pruned.\r\n */\r\nlibrary MerkleProof {\r\n\tfunction verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n\t\treturn processProof(proof, leaf) == root;\r\n\t}\r\n\r\n\tfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n\t\tbytes32 computedHash = leaf;\r\n\t\tfor(uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tcomputedHash = _hashPair(computedHash, proof[i]);\r\n\t\t}\r\n\t\treturn computedHash;\r\n\t}\r\n\r\n\tfunction processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n\t\tbytes32 computedHash = leaf;\r\n\t\tfor(uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tcomputedHash = _hashPair(computedHash, proof[i]);\r\n\t\t}\r\n\t\treturn computedHash;\r\n\t}\r\n\r\n\tfunction processMultiProof(bytes32[] memory proof, bool[] memory proofFlags, bytes32[] memory leaves) internal pure returns (bytes32 merkleRoot) {\r\n\t\tuint256 leavesLen = leaves.length;\r\n\t\tuint256 totalHashes = proofFlags.length;\r\n\r\n\t\trequire(leavesLen + proof.length - 1 == totalHashes, _strInvalidMultiproof);\r\n\r\n\t\tbytes32[] memory hashes = new bytes32[](totalHashes);\r\n\t\tuint256 leafPos = 0;\r\n\t\tuint256 hashPos = 0;\r\n\t\tuint256 proofPos = 0;\r\n\r\n\t\tfor(uint256 i = 0; i < totalHashes; i++) {\r\n\t\t\tbytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n\t\t\tbytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n\t\t\thashes[i] = _hashPair(a, b);\r\n\t\t}\r\n\r\n\t\tif(totalHashes > 0) {\r\n\t\t\treturn hashes[totalHashes - 1];\r\n\t\t}\r\n\t\telse if(leavesLen > 0) {\r\n\t\t\treturn leaves[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn proof[0];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction processMultiProofCalldata(bytes32[] calldata proof, bool[] calldata proofFlags, bytes32[] memory leaves) internal pure returns (bytes32 merkleRoot) {\r\n\t\tuint256 leavesLen = leaves.length;\r\n\t\tuint256 totalHashes = proofFlags.length;\r\n\r\n\t\trequire(leavesLen + proof.length - 1 == totalHashes, _strInvalidMultiproof);\r\n\r\n\t\tbytes32[] memory hashes = new bytes32[](totalHashes);\r\n\t\tuint256 leafPos = 0;\r\n\t\tuint256 hashPos = 0;\r\n\t\tuint256 proofPos = 0;\r\n\r\n\t\tfor(uint256 i = 0; i < totalHashes; i++) {\r\n\t\t\tbytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n\t\t\tbytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n\t\t\thashes[i] = _hashPair(a, b);\r\n\t\t}\r\n\r\n\t\tif(totalHashes > 0) {\r\n\t\t\treturn hashes[totalHashes - 1];\r\n\t\t}\r\n\t\telse if(leavesLen > 0) {\r\n\t\t\treturn leaves[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn proof[0];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n\t\treturn a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n\t}\r\n\r\n\tfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, a)\r\n\t\t\tmstore(0x20, b)\r\n\t\t\tvalue := keccak256(0x00, 0x40)\r\n\t\t}\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.22;\r\ncontract Mablab is Context, ERC721, IERC4906 {\r\n\tusing MerkleProof for bytes32[];\r\n\tevent ReceivedRoyalties(address indexed creator, address indexed buyer, uint256 indexed amount);\r\n\r\n\tbool private _boolPaused = true;\r\n\r\n\tbytes32 _legitMerkleRoot = 0x9da2d7260bb59a40371b7bfb656798384e73b9b05f2f57c7bab1a451a0db48fd;\r\n\r\n\tuint256 private _mintFee = 39900000000000000; //39900000000000000, 0.0399 ETH.\r\n\tuint256 private _mintedTokens = 0;\r\n\tuint256 private _maxCap = 1669;\r\n\tuint256 private _sellerFeePoints = 1000; // 10%.\r\n\r\n\tuint256[] private tokenTracker;\r\n\r\n\taddress private _addrContractOwner = 0x389D43178ad6076521C7F2Ca19bEEc806ef00D2a;\r\n\taddress private _addrContractCopilot = 0x4DaE7E6c0Ca196643012cDc526bBc6b445A2ca59;\r\n\r\n\tstring private _strMetadataURI = 'https://mablab.mypinata.cloud/ipfs/QmPAvaxvjw5UnfVxgj8vyp938Juh1YBZ6xXBYkNk4BojHm/';\r\n\tstring private _strContractJSON = 'https://mablab.mypinata.cloud/ipfs/QmYYUuaaBWFGok1bAiZL7QsGnVuiQHZMYXCMduswGY2kGZ';\r\n\r\n// ==================================================================\r\n//                              MODIFIERS\r\n// ==================================================================\r\n\r\n\tmodifier isUnpaused() {\r\n\t\trequire(!_boolPaused, _strPaused);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isWithinExistence(uint256 tokenId) {\r\n\t\trequire(tokenId > 0, _strOutOfBounds);\r\n\t\trequire(tokenId <= _maxCap, _strOutOfBounds);\r\n\t\trequire(_exists(tokenId), _strOutOfBounds);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isMintable(uint256 tokenId) {\r\n\t\trequire(tokenId > 0, _strOutOfBounds);\r\n\t\trequire(tokenId <= _maxCap, _strOutOfBounds);\r\n\t\trequire(!_exists(tokenId), _strAlreadyMinted);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isAudited(uint256 tokenId, bytes32[] memory proof, string memory hash) {\r\n\t\tbytes32 _leaf = keccak256(bytes.concat(keccak256(abi.encode(tokenId, hash))));\r\n\t\trequire(MerkleProof.verify(proof, _legitMerkleRoot, _leaf), _strNotAuthorized);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyAdmin {\r\n\t\trequire(_msgSender() == _addrContractOwner, _strNotAuthorized);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyPilots {\r\n\t\trequire((_msgSender() == _addrContractOwner || _msgSender() == _addrContractCopilot), _strNotAuthorized);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor() ERC721() {}\r\n\r\n// ==================================================================\r\n//                       MAIN PUBLIC FUNCTIONS\r\n// ==================================================================\r\n\r\n// ------------------------------------------------------------------\r\n//                               GETTERS\r\n// ------------------------------------------------------------------\r\n\t/// @notice Returns a URI to the contract's JSON.\r\n\tfunction contractURI() public view returns(string memory) {\r\n\t\treturn _strContractJSON;\r\n\t}\r\n\r\n\t/// @notice Returns 1 if a given tokenId exists, 0 if it does not exist.\r\n\t/// @param tokenId Token ID.\r\n\tfunction isMinted(uint256 tokenId) public view returns(bool) {\r\n\t\treturn _exists(tokenId);\r\n\t}\r\n\r\n\t/// @notice Returns how many minted tokens are at the moment.\r\n\tfunction mintedTokens() public view returns(uint256) {\r\n\t\treturn _mintedTokens;\r\n\t}\r\n\r\n\t/// @notice Returns the mint value expressed in wei.\r\n\tfunction mintFee() public view returns(uint256) {\r\n\t\treturn _mintFee;\r\n\t}\r\n\r\n\t/// @notice Returns the current Merkle root.\r\n\tfunction merkleRoot() public view returns(bytes32) {\r\n\t\treturn _legitMerkleRoot;\r\n\t}\r\n\r\n\t/// @notice Returns the contract's name.\r\n\tfunction name() public view returns(string memory) {\r\n\t\treturn _strTokenName;\r\n\t}\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns(bool) {\r\n\t\treturn interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\t/// @notice Returns the contract's symbol, or ticker.\r\n\tfunction symbol() public view returns(string memory) {\r\n\t\treturn _strTokenTicker;\r\n\t}\r\n\r\n\t/// @notice Returns a URI to the external JSON holding the token's metadata.\r\n\t/// @param tokenId Token ID.\r\n\tfunction tokenURI(uint256 tokenId) isWithinExistence(tokenId) public view returns(string memory) {\r\n\t\t// Convert this to external JSON, located on the specific path.\r\n\t\treturn string(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t_strMetadataURI,\r\n\t\t\t\tStrings.toString(tokenId),\r\n\t\t\t\t'.json'\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice Returns contract's max supply.\r\n\tfunction totalSupply() public view returns(uint256) {\r\n\t\treturn _maxCap;\r\n\t}\r\n\r\n// ------------------------------------------------------------------\r\n//                               SETTERS\r\n// ------------------------------------------------------------------\r\n\r\n\t/// @notice Mints a new token without the need of a Merkle proof. Only for admins.\r\n\t/// @param tokenId A number between 1 and 1669, that uniquely identifies this token.\r\n\tfunction adminMint(uint256 tokenId) public isMintable(tokenId) onlyPilots payable {\r\n\t\t_mintedTokens++;\r\n\t\t_mint(_msgSender(), tokenId);\r\n\t}\r\n\r\n\t/// @notice Changes the contract's owner.\r\n\t///\t Note: Only current contract's owner can change this.\r\n\t/// @param _newOwner Address of the new owner.\r\n\tfunction changeContractOwner(address _newOwner) onlyPilots public {\r\n\t\t_addrContractOwner = _newOwner;\r\n\t}\r\n\r\n\t/// @notice Changes mint fee.\r\n\t///\t Note: Only contract's owner can change this.\r\n\t/// @param _newValue New value in wei.\r\n\tfunction changeMintFee(uint256 _newValue) onlyAdmin public {\r\n\t\t_mintFee = _newValue;\r\n\t}\r\n\r\n\t/// @notice Changes onchain contents.\r\n\t///\t Note: Only contract's owner can change this.\r\n\t/// @param _string New content, minified.\r\n\t/// @param _index 1 for metadata URI, 3 for contract's metadata.\r\n\tfunction changeOnchainData(string memory _string, uint8 _index) onlyAdmin public {\r\n\t\tif(_index == 1) {\r\n\t\t\t_strMetadataURI = _string;\r\n\t\t}\r\n\t\telse if(_index == 2) {\r\n\t\t\t_strContractJSON = _string;\r\n\t\t}\r\n\t\tif(_mintedTokens > 0) {\r\n\t\t\temit BatchMetadataUpdate(1, 1669);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Mints a new token.\r\n\t/// @param tokenId A number between 1 and 1669, that uniquely identifies this token.\r\n\t/// @param proof Merkle proof.\r\n\t/// @param hash Merkled hash, to avoid tampering.\r\n\tfunction mint(uint256 tokenId, bytes32[] memory proof, string memory hash) public isMintable(tokenId) isAudited(tokenId, proof, hash) payable {\r\n\t\trequire(msg.value >= _mintFee, string(abi.encodePacked('Must pay ', Strings.toString(_mintFee), ' wei.')));\r\n\t\trequire(!_boolPaused, _strPaused);\r\n\t\t_mintedTokens++;\r\n\t\t_mint(_msgSender(), tokenId);\r\n\t}\r\n\r\n\t/// @notice Sets the merkle root.\r\n\t///\t Note: Only contract's owner can use this function.\r\n\t/// @param _merkleRoot merkle root.\r\n\tfunction setMerkleRoot(bytes32 _merkleRoot) public onlyAdmin {\r\n\t\t_legitMerkleRoot = _merkleRoot;\r\n\t}\r\n\r\n\t/// @notice Pauses or unpauses the contract\r\n\t///\t Note: Only contract's owner can change this.\r\n\t/// @param _state boolean, true to pause, false to unpause\r\n\tfunction setPauseStatus(bool _state) onlyPilots public {\r\n\t\t_boolPaused = _state;\r\n\t}\r\n\r\n\t/// @notice Allows to withdraw any ETH available on this contract.\r\n\t///\t Note: Only contract's owner can withdraw.\r\n\tfunction withdraw() public onlyPilots isUnpaused payable {\r\n\t\tuint balance = address(this).balance;\r\n\t\tuint myBalance = balance * 30 / 100;\r\n\t\tuint remaining = balance - myBalance;\r\n\t\trequire(balance > 0, _strNotEnoughBalance);\r\n\t\t(bool firstTX, ) = (_addrContractCopilot).call{value: myBalance}('');\r\n\t\t(bool secondTX, ) = (_addrContractOwner).call{value: remaining}('');\r\n\t\trequire(firstTX && secondTX, _strTransferFailed);\r\n\t}\r\n\r\n\t/// @notice Allows to withdraw any ETH available on this contract.\r\n\t///\t Note: This function is set in place to withdraw only if for some reason the normal function isn't working properly, or one of the addresses is no longer available.\r\n\tfunction overrideWithdraw() public onlyPilots isUnpaused payable {\r\n\t\tuint balance = address(this).balance;\r\n\t\trequire(balance > 0, _strNotEnoughBalance);\r\n\t\t(bool success, ) = (msg.sender).call{value: balance}(\"\");\r\n\t\trequire(success, _strTransferFailed);\r\n\t}\r\n\r\n\tfunction royaltiesReceived(address _creator, address _buyer, uint256 _amount) external {\r\n\t\temit ReceivedRoyalties(_creator, _buyer, _amount);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedRoyalties\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"changeMintFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_string\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"changeOnchainData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"string\",\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overrideWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"royaltiesReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setPauseStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"unblacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Mablab", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6b0103a9098b89a210e216e0fd95bb2e3a53797a12ca93b21cc8a4351085976c"}