{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TeamNick2Baseless.sol\": {\r\n      \"content\": \"/// @author raffy.eth\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n// interfaces\\nimport {ENS} from \\\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IEVMVerifier} from \\\"./evm-verifier2/IEVMVerifier.sol\\\";\\nimport {IExtendedResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddrResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\\\";\\nimport {IAddressResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\\\";\\nimport {ITextResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\\\";\\n\\n// libraries\\nimport {BytesUtils} from \\\"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {EVMFetcher} from \\\"./evm-verifier2/EVMFetcher.sol\\\";\\n\\n// bases\\nimport {EVMFetchTarget} from \\\"./evm-verifier2/EVMFetchTarget.sol\\\";\\n\\ncontract TeamNick2Baseless is IERC165, IExtendedResolver, EVMFetchTarget {\\n\\tusing BytesUtils for bytes;\\n\\tusing EVMFetcher for EVMFetcher.EVMFetchRequest;\\n\\n\\terror Unreachable(bytes name);\\n\\n\\tENS immutable ens;\\n\\tIEVMVerifier immutable verifier;\\n\\n\\tuint256 constant SLOT_RECORDS = 7;\\n\\tuint256 constant SLOT_SUPPLY = 8;\\n\\n\\taddress constant TEAMNICK_ADDRESS = 0x7C6EfCb602BC88794390A0d74c75ad2f1249A17f;\\n\\n\\tconstructor(ENS _ens, IEVMVerifier _verifier) {\\n\\t\\tens = _ens;\\n\\t\\tverifier = _verifier;\\n\\t}\\n\\n\\tfunction supportsInterface(bytes4 x) external pure returns (bool) {\\n\\t\\treturn x == type(IERC165).interfaceId || x == type(IExtendedResolver).interfaceId;\\n\\t}\\n\\n\\tfunction _resolveBasename(bytes calldata data) internal view returns (bytes memory) {\\n\\t\\tbytes4 selector = bytes4(data);\\n\\t\\tif (selector == IAddrResolver.addr.selector) {\\n\\t\\t\\treturn abi.encode(address(0));\\n\\t\\t} else if (selector == IAddressResolver.addr.selector) {\\n\\t\\t\\t(, uint256 cty) = abi.decode(data[4:], (bytes32, uint256));\\n\\t\\t\\tif (cty == 0x80002105) { // base (8453) {\\n\\t\\t\\t\\treturn abi.encode(abi.encodePacked(TEAMNICK_ADDRESS));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn abi.encode('');\\n\\t\\t\\t}\\n\\t\\t} else if (selector == ITextResolver.text.selector) {\\n\\t\\t\\t(, string memory key) = abi.decode(data[4:], (bytes32, string));\\n\\t\\t\\tbytes32 keyhash = keccak256(bytes(key));\\n\\t\\t\\tif (keyhash == 0xb68b5f5089998f2978a1dcc681e8ef27962b90d5c26c4c0b9c1945814ffa5ef0) {\\n\\t\\t\\t\\t// https://adraffy.github.io/keccak.js/test/demo.html#algo=keccak-256&s=url&escape=1&encoding=utf8\\n\\t\\t\\t\\treturn abi.encode(\\\"https://teamnick.xyz\\\");\\n\\t\\t\\t} else if (keyhash == 0x1596dc38e2ac5a6ddc5e019af4adcc1e017a04f510d57e69d6879d5d2996bb8e) {\\n\\t\\t\\t\\t// https://adraffy.github.io/keccak.js/test/demo.html#algo=keccak-256&s=description&escape=1&encoding=utf8\\n\\t\\t\\t\\tEVMFetcher.newFetchRequest(verifier, TEAMNICK_ADDRESS).getStatic(SLOT_SUPPLY).fetch(this.descriptionCallback.selector, '');\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn abi.encode('');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction resolve(bytes calldata name, bytes calldata data) external view returns (bytes memory) {\\n\\t\\tuint256 offset = _findSelf(name);\\n\\t\\tif (offset == 0) return _resolveBasename(data);\\n\\t\\t(bytes32 label, uint256 pos) = name.readLabel(0);\\n\\t\\tuint256 token = pos == offset ? uint256(label) : 0;\\n\\t\\tbytes4 selector = bytes4(data);\\n\\t\\tif (selector == IAddrResolver.addr.selector) {\\n\\t\\t\\tEVMFetcher.newFetchRequest(verifier, TEAMNICK_ADDRESS).getStatic(SLOT_RECORDS).element(token).fetch(this.addrCallback.selector, '');\\n\\t\\t} else if (selector == IAddressResolver.addr.selector) {\\n\\t\\t\\t(, uint256 cty) = abi.decode(data[4:], (bytes32, uint256));\\n\\t\\t\\tif (cty == 60) {\\n\\t\\t\\t\\tEVMFetcher.newFetchRequest(verifier, TEAMNICK_ADDRESS).getStatic(SLOT_RECORDS).element(token).fetch(this.addressCallback.selector, '');\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn abi.encode('');\\n\\t\\t\\t}\\n\\t\\t} else if (selector == ITextResolver.text.selector) {\\n\\t\\t\\t(, string memory key) = abi.decode(data[4:], (bytes32, string));\\n\\t\\t\\tbytes32 keyhash = keccak256(bytes(key));\\n\\t\\t\\tif (keyhash == 0x2361458367e696363fbcc70777d07ebbd2394e89fd0adcaf147faccd1d294d60) {\\n\\t\\t\\t\\treturn abi.encode(name[1:pos]);\\n\\t\\t\\t} else if (keyhash == 0xd1f86c93d831119ad98fe983e643a7431e4ac992e3ead6e3007f4dd1adf66343) { \\n\\t\\t\\t\\t// https://adraffy.github.io/keccak.js/test/demo.html#algo=keccak-256&s=avatar&escape=1&encoding=utf8\\n\\t\\t\\t\\tEVMFetcher.newFetchRequest(verifier, TEAMNICK_ADDRESS).getDynamic(SLOT_RECORDS).element(token).add(1).fetch(this.textCallback.selector, '');\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn abi.encode('');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _findSelf(bytes memory name) internal view returns (uint256 offset) {\\n\\t\\tunchecked {\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tbytes32 node = name.namehash(offset);\\n\\t\\t\\t\\tif (ens.resolver(node) == address(this)) break;\\n\\t\\t\\t\\tuint256 size = uint8(name[offset]);\\n\\t\\t\\t\\tif (size == 0) revert Unreachable(name);\\n\\t\\t\\t\\toffset += 1 + size;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addrCallback(bytes[] calldata values, bytes calldata) external pure returns (bytes memory) {\\n\\t\\treturn abi.encode(bytes32(values[0]));\\n\\t}\\n\\tfunction addressCallback(bytes[] calldata values, bytes calldata) external pure returns (bytes memory) {\\n\\t\\treturn abi.encode(values[0][12:]);\\n\\t}\\n\\tfunction textCallback(bytes[] calldata values, bytes calldata) external pure returns (bytes memory) {\\n\\t\\treturn abi.encode(values[0]);\\n\\t}\\n\\tfunction descriptionCallback(bytes[] calldata values, bytes calldata) external pure returns (bytes memory) {\\n\\t\\treturn abi.encode(string.concat(Strings.toString(uint256(bytes32(values[0]))), \\\" names registered\\\"));\\n\\t}\\n\\t\\n} \"\r\n    },\r\n    \"lib/ens-contracts/contracts/registry/ENS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/evm-verifier2/IEVMVerifier.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IEVMVerifier {\\n\\tfunction getStorageContext() external view returns(string[] memory urls, bytes memory context);\\n\\tfunction getStorageValues(bytes memory context, address target, bytes32[] memory commands, bytes[] memory constants, bytes memory proof) external view returns(bytes[] memory values);\\n}\\n\"\r\n    },\r\n    \"lib/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"lib/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the legacy (ETH-only) addr function.\\n */\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\"\r\n    },\r\n    \"lib/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"lib/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(\\n        bytes32 indexed node,\\n        string indexed indexedKey,\\n        string key,\\n        string value\\n    );\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(\\n        bytes32 node,\\n        string calldata key\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/ens-contracts/contracts/wrapper/BytesUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nlibrary BytesUtils {\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\n     * @param self The DNS-encoded name to hash.\\n     * @param offset The offset at which to start hashing.\\n     * @return The namehash of the name.\\n     */\\n    function namehash(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\n        if (labelhash == bytes32(0)) {\\n            require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\n            return bytes32(0);\\n        }\\n        return\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\n     * @param self The byte string to read a label from.\\n     * @param idx The index to read a label at.\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\n     * @return newIdx The index of the start of the next label.\\n     */\\n    function readLabel(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\n        require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\n        uint256 len = uint256(uint8(self[idx]));\\n        if (len > 0) {\\n            labelhash = keccak(self, idx + 1, len);\\n        } else {\\n            labelhash = bytes32(0);\\n        }\\n        newIdx = idx + len + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/evm-verifier2/EVMFetcher.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport { IEVMVerifier } from \\\"./IEVMVerifier.sol\\\";\\r\\nimport { EVMFetchTarget } from \\\"./EVMFetchTarget.sol\\\";\\r\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\ninterface IEVMGateway {\\r\\n    function getStorageSlots(bytes memory context, address addr, bytes32[] memory commands, bytes[] memory constants) external pure returns (bytes memory witness);\\r\\n}\\r\\n\\r\\nuint8 constant FLAG_DYNAMIC = 0x01;\\r\\nuint8 constant OP_FOLLOW_REF = 1 << 5;\\r\\nuint8 constant OP_ADD_CONST = 2 << 5;\\r\\nuint8 constant OP_END = 0xff;\\r\\n\\r\\n/**\\r\\n * @dev A library to facilitate requesting storage data proofs from contracts, possibly on a different chain.\\r\\n *      See l1-verifier/test/TestL1.sol for example usage.\\r\\n */\\r\\nlibrary EVMFetcher {\\r\\n    uint256 constant MAX_COMMANDS = 32;\\r\\n    uint256 constant MAX_CONSTANTS = 32; // Must not be greater than 32\\r\\n\\r\\n    using Address for address;\\r\\n\\r\\n    error TooManyCommands(uint256 max);\\r\\n    error CommandTooLong();\\r\\n    error InvalidReference(uint256 value, uint256 max);\\r\\n    error OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData);\\r\\n\\r\\n\\tstruct EVMFetchRequest {\\r\\n        IEVMVerifier verifier;\\r\\n        address target;\\r\\n        bytes32[] commands;\\r\\n        uint256 operationIdx;\\r\\n        bytes[] constants;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates a request to fetch the value of multiple storage slots from a contract via CCIP-Read, possibly from\\r\\n     *      another chain.\\r\\n     *      Supports dynamic length values and slot numbers derived from other retrieved values.\\r\\n     * @param verifier An instance of a verifier contract that can provide and verify the storage slot information.\\r\\n     * @param target The address of the contract to fetch storage proofs for.\\r\\n     */\\r\\n    function newFetchRequest(IEVMVerifier verifier, address target) internal pure returns (EVMFetchRequest memory) {\\r\\n        bytes32[] memory commands = new bytes32[](MAX_COMMANDS);\\r\\n        bytes[] memory constants = new bytes[](MAX_CONSTANTS);\\r\\n        assembly {\\r\\n            mstore(commands, 0) // Set current array length to 0\\r\\n            mstore(constants, 0)\\r\\n        }        \\r\\n        return EVMFetchRequest(verifier, target, commands, 0, constants);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Starts describing a new fetch request.\\r\\n     *      Paths specify a series of hashing operations to derive the final slot ID.\\r\\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\\r\\n     *      lays out storage variables.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param baseSlot The base slot ID that forms the root of the path.\\r\\n     */\\r\\n    function getStatic(EVMFetchRequest memory request, uint256 baseSlot) internal pure returns (EVMFetchRequest memory) {\\r\\n        bytes32[] memory commands = request.commands;\\r\\n        uint256 commandIdx = commands.length;\\r\\n        if(commandIdx > 0 && request.operationIdx < 32) {\\r\\n            // Terminate previous command\\r\\n            _addOperation(request, OP_END);\\r\\n        }\\r\\n        assembly {\\r\\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\\r\\n        }\\r\\n        if(request.commands.length > MAX_COMMANDS) {\\r\\n            revert TooManyCommands(MAX_COMMANDS);\\r\\n        }\\r\\n        request.operationIdx = 0;\\r\\n        _addOperation(request, 0);\\r\\n        _addOperation(request, OP_ADD_CONST | _addConstant(request, abi.encode(baseSlot)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Starts describing a new fetch request.\\r\\n     *      Paths specify a series of hashing operations to derive the final slot ID.\\r\\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\\r\\n     *      lays out storage variables.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param baseSlot The base slot ID that forms the root of the path.\\r\\n     */\\r\\n    function getDynamic(EVMFetchRequest memory request, uint256 baseSlot) internal pure returns (EVMFetchRequest memory) {\\r\\n        bytes32[] memory commands = request.commands;\\r\\n        uint256 commandIdx = commands.length;\\r\\n        if(commandIdx > 0 && request.operationIdx < 32) {\\r\\n            // Terminate previous command\\r\\n            _addOperation(request, OP_END);\\r\\n        }\\r\\n        assembly {\\r\\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\\r\\n        }\\r\\n        if(request.commands.length > MAX_COMMANDS) {\\r\\n            revert TooManyCommands(MAX_COMMANDS);\\r\\n        }\\r\\n        request.operationIdx = 0;\\r\\n        _addOperation(request, FLAG_DYNAMIC);\\r\\n        _addOperation(request, OP_ADD_CONST | _addConstant(request, abi.encode(baseSlot)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a `uint256` element to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param el The element to add.\\r\\n     */\\r\\n    function element(EVMFetchRequest memory request, uint256 el) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, _addConstant(request, abi.encode(el)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a `bytes32` element to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param el The element to add.\\r\\n     */\\r\\n    function element(EVMFetchRequest memory request, bytes32 el) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, _addConstant(request, abi.encode(el)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds an `address` element to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param el The element to add.\\r\\n     */\\r\\n    function element(EVMFetchRequest memory request, address el) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, _addConstant(request, abi.encode(el)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a `bytes` element to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param el The element to add.\\r\\n     */\\r\\n    function element(EVMFetchRequest memory request, bytes memory el) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, _addConstant(request, el));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a `string` element to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param el The element to add.\\r\\n     */\\r\\n    function element(EVMFetchRequest memory request, string memory el) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, _addConstant(request, bytes(el)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a reference to a previous fetch to the current path.\\r\\n     * @param request The request object being operated on.\\r\\n     * @param idx The index of the previous fetch request, starting at 0.\\r\\n     */\\r\\n    function ref(EVMFetchRequest memory request, uint8 idx) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        if(idx > request.commands.length || idx > 31) {\\r\\n            revert InvalidReference(idx, request.commands.length);\\r\\n        }\\r\\n        _addOperation(request, OP_FOLLOW_REF | idx);\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n\\tfunction add(EVMFetchRequest memory request, uint256 offset) internal pure returns (EVMFetchRequest memory) {\\r\\n        if(request.operationIdx >= 32) {\\r\\n            revert CommandTooLong();\\r\\n        }\\r\\n        _addOperation(request, OP_ADD_CONST | _addConstant(request, abi.encode(offset)));\\r\\n        return request;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initiates the fetch request.\\r\\n     *      Calling this function terminates execution; clients that implement CCIP-Read will make a callback to\\r\\n     *      `callback` with the results of the operation.\\r\\n     * @param callbackId A callback function selector on this contract that will be invoked via CCIP-Read with the result of the lookup.\\r\\n     *        The function must have a signature matching `(bytes[] memory values, bytes callbackData)` with a return type matching the call in which\\r\\n     *        this function was invoked. Its return data will be returned as the return value of the entire CCIP-read operation.\\r\\n     * @param callbackData Extra data to supply to the callback.\\r\\n     */\\r\\n    function fetch(EVMFetchRequest memory request, bytes4 callbackId, bytes memory callbackData) internal view {\\r\\n        if(request.commands.length > 0 && request.operationIdx < 32) {\\r\\n            // Terminate last command\\r\\n            _addOperation(request, OP_END);\\r\\n        }\\r\\n\\t\\t(string[] memory urls, bytes memory context) = request.verifier.getStorageContext();\\r\\n        revert OffchainLookup(\\r\\n            address(this),\\r\\n            urls,\\r\\n            abi.encodeCall(IEVMGateway.getStorageSlots, (context, request.target, request.commands, request.constants)),\\r\\n            EVMFetchTarget.getStorageSlotsCallback.selector,\\r\\n            abi.encode(request.verifier, context, request.target, request.commands, request.constants, callbackId, callbackData)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addConstant(EVMFetchRequest memory request, bytes memory value) private pure returns(uint8 idx) {\\r\\n        bytes[] memory constants = request.constants;\\r\\n        idx = uint8(constants.length);\\r\\n        assembly {\\r\\n            mstore(constants, add(idx, 1)) // Increment constant array length\\r\\n        }\\r\\n        constants[idx] = value;\\r\\n    }\\r\\n\\r\\n    function _addOperation(EVMFetchRequest memory request, uint8 op) private pure {\\r\\n        uint256 commandIdx = request.commands.length - 1;\\r\\n        request.commands[commandIdx] = request.commands[commandIdx] | (bytes32(bytes1(op)) >> (8 * request.operationIdx++));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/evm-verifier2/EVMFetchTarget.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IEVMVerifier } from \\\"./IEVMVerifier.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev Callback implementation for users of `EVMFetcher`. If you use `EVMFetcher`, your contract must\\n *      inherit from this contract in order to handle callbacks correctly.\\n */\\nabstract contract EVMFetchTarget {\\n    using Address for address;\\n\\n    error ResponseLengthMismatch(uint256 actual, uint256 expected);\\n\\n    /**\\n     * @dev Internal callback function invoked by CCIP-Read in response to a `getStorageSlots` request.\\n     */\\n    function getStorageSlotsCallback(bytes calldata response, bytes calldata carry) external {\\n\\t\\tbytes memory proof = abi.decode(response, (bytes));\\n        (\\n\\t\\t\\tIEVMVerifier verifier,\\n\\t\\t\\tbytes memory context,\\n\\t\\t\\taddress addr, \\n\\t\\t\\tbytes32[] memory commands, \\n\\t\\t\\tbytes[] memory constants, \\n\\t\\t\\tbytes4 callback, \\n\\t\\t\\tbytes memory callbackData\\n\\t\\t) = abi.decode(carry, (IEVMVerifier, bytes, address, bytes32[], bytes[], bytes4, bytes));\\n        bytes[] memory values = verifier.getStorageValues(context, addr, commands, constants, proof);\\n\\t\\tif(values.length != commands.length) {\\n            revert ResponseLengthMismatch(values.length, commands.length);\\n        }\\n        bytes memory ret = address(this).functionCall(abi.encodeWithSelector(callback, values, callbackData));\\n        assembly {\\n            return(add(ret, 32), mload(ret))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@ensdomains/ens-contracts/=lib/ens-contracts/\",\r\n      \"@eth-optimism/=lib/optimism/packages/\",\r\n      \"clones-with-immutable-args/=lib/optimism/packages/contracts-bedrock/lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"ens-contracts/=lib/ens-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"kontrol-cheatcodes/=lib/optimism/packages/contracts-bedrock/lib/kontrol-cheatcodes/src/\",\r\n      \"lib-keccak/=lib/optimism/packages/contracts-bedrock/lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/optimism/packages/contracts-bedrock/lib/safe-contracts/contracts/\",\r\n      \"solady/=lib/optimism/packages/contracts-bedrock/lib/solady/\",\r\n      \"solmate/=lib/optimism/packages/contracts-bedrock/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"contract IEVMVerifier\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommandTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ResponseLengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"TooManyCommands\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"Unreachable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"values\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"addrCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"values\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"addressCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"values\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"descriptionCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"carry\",\"type\":\"bytes\"}],\"name\":\"getStorageSlotsCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"x\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"values\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"textCallback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TeamNick2Baseless", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e000000000000000000000000ec2244b547bd782fc7deefc6d45e0b3a3cbd488d", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}