{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/ExecutorPlugin.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {ReentrancyGuard} from \\\"openzeppelin-contracts/security/ReentrancyGuard.sol\\\";\\nimport {SignatureCheckerLib} from \\\"solady/utils/SignatureCheckerLib.sol\\\";\\nimport {EIP712} from \\\"solady/utils/EIP712.sol\\\";\\nimport {ISafeWallet} from \\\"interfaces/external/ISafeWallet.sol\\\";\\nimport {AddressProviderService} from \\\"src/core/AddressProviderService.sol\\\";\\nimport {TransactionValidator} from \\\"src/core/TransactionValidator.sol\\\";\\nimport {ExecutorRegistry} from \\\"src/core/registries/ExecutorRegistry.sol\\\";\\nimport {SafeHelper} from \\\"src/libraries/SafeHelper.sol\\\";\\nimport {TypeHashHelper} from \\\"src/libraries/TypeHashHelper.sol\\\";\\nimport {Types} from \\\"interfaces/Types.sol\\\";\\n\\n/**\\n * @title ExecutorPlugin\\n * @author Brahma.fi\\n * @notice Responsible for executing transactions on safes with module permissions\\n * @dev ExecutorPlugin needs to be enabled as a module on the safe\\n */\\ncontract ExecutorPlugin is AddressProviderService, ReentrancyGuard, EIP712 {\\n    error InvalidExecutor();\\n    error InvalidSignature();\\n    error ModuleExecutionFailed();\\n\\n    /**\\n     * @notice datatype for execution requests\\n     * @param exec txn params\\n     * @param account address of safe to execute txn on\\n     * @param executor address that initiated execution request\\n     * @param executorSignature executor's signature for execution\\n     * @param validatorSignature validator's signature for execution\\n     * @dev Signature formats:\\n     *  executorSignature = executor's signatures (arbitrary bytes length)\\n     *  validatorSignature = abi.encodePacked(policySignature, length, expiryEpoch)\\n     *  where:\\n     *      policySignature = validity signature signed by validator (arbitrary bytes length)\\n     *      length = length of `policySignature` (4 bytes)\\n     *      expiryEpoch = expiry timestamp (4 bytes)\\n     */\\n    struct ExecutionRequest {\\n        Types.Executable exec;\\n        address account;\\n        address executor;\\n        bytes executorSignature;\\n        bytes validatorSignature;\\n    }\\n\\n    /// @notice EIP712 domain name\\n    string private constant _NAME = \\\"ExecutorPlugin\\\";\\n    /// @notice EIP712 domain version\\n    string private constant _VERSION = \\\"1.0\\\";\\n\\n    /// @notice mapping of account to nonce of executors\\n    mapping(address account => mapping(address executor => uint256 nonce)) public executorNonce;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Enables executors to raise execution requests that will be executed via a module transaction\\n     * @dev The Executors are expected to sign the EIP712 digest generated from following struct: TypeHashHelper.ExecutionParams\\n     * @param execRequest params for execution request\\n     * @return returnData of txn\\n     */\\n    function executeTransaction(ExecutionRequest calldata execRequest) external nonReentrant returns (bytes memory) {\\n        address transactionValidator = AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH);\\n        _validateExecutionRequest(execRequest, transactionValidator);\\n\\n        bytes memory txnResult = _executeTxnAsModule(execRequest.account, execRequest.exec);\\n\\n        TransactionValidator(transactionValidator).validatePostExecutorTransaction(msg.sender, execRequest.account);\\n\\n        return txnResult;\\n    }\\n\\n    /**\\n     * @notice internal helper to execute transaction on a safe as a module\\n     * @dev executes txn as a module on `_account`\\n     * @param _account address of safe to execute on\\n     * @param _executable params of txn to execute\\n     * @return returnData of txn\\n     */\\n    function _executeTxnAsModule(address _account, Types.Executable memory _executable)\\n        internal\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory txnResult) = ISafeWallet(_account).execTransactionFromModuleReturnData(\\n            _executable.target,\\n            _executable.value,\\n            _executable.data,\\n            SafeHelper._parseOperationEnum(_executable.callType)\\n        );\\n        if (!success) revert ModuleExecutionFailed();\\n        return txnResult;\\n    }\\n\\n    /**\\n     * @notice internal helper to validate the execution request\\n     * @dev - validates executor's signature and checks if the executor is valid for given account.\\n     *      - validates policy\\n     * @param execRequest params for execution request\\n     */\\n    function _validateExecutionRequest(ExecutionRequest calldata execRequest, address transactionValidator) internal {\\n        if (!ExecutorRegistry(executorRegistry).isExecutor(execRequest.account, execRequest.executor)) {\\n            revert InvalidExecutor();\\n        }\\n\\n        // Empty Signature check for EOA executor\\n        if (execRequest.executor.code.length == 0 && execRequest.executorSignature.length == 0) {\\n            // Executor is an EOA and no executor signature is provided\\n            revert InvalidSignature();\\n        }\\n\\n        // Build execution struct hash\\n        bytes32 _executionStructHash = TypeHashHelper._buildExecutionParamsHash(\\n            TypeHashHelper.ExecutionParams({\\n                to: execRequest.exec.target,\\n                value: execRequest.exec.value,\\n                data: execRequest.exec.data,\\n                operation: uint8(SafeHelper._parseOperationEnum(execRequest.exec.callType)),\\n                account: execRequest.account,\\n                executor: execRequest.executor,\\n                nonce: executorNonce[execRequest.account][execRequest.executor]++,\\n                safeTxGas: 0,\\n                baseGas: 0,\\n                gasPrice: 0,\\n                gasToken: address(0),\\n                refundReceiver: address(0)\\n            })\\n        );\\n\\n        // Build EIP712 digest for execution struct hash\\n        bytes32 _transactionDigest = _hashTypedData(_executionStructHash);\\n\\n        // Validate executor signature\\n        if (\\n            !SignatureCheckerLib.isValidSignatureNow(\\n                execRequest.executor, _transactionDigest, execRequest.executorSignature\\n            )\\n        ) {\\n            revert InvalidExecutor();\\n        }\\n\\n        // Validate policy signature\\n        TransactionValidator(transactionValidator).validatePreExecutorTransaction(\\n            msg.sender, execRequest.account, _executionStructHash, execRequest.validatorSignature\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal helper to get EIP712 domain name and version\\n     * @return name domainName\\n     * @return version domainVersion\\n     */\\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\\n        return (_NAME, _VERSION);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SignatureCheckerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\\n///\\n/// @dev Note:\\n/// - The signature checking functions use the ecrecover precompile (0x1).\\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\\n///   to copy memory internally.\\n/// - Unlike ECDSA signatures, contract signatures are revocable.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers.\\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary SignatureCheckerLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*               SIGNATURE CHECKING OPERATIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                if eq(mload(signature), 65) {\\n                    mstore(0x00, hash)\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                // Copy the `signature` over.\\n                let n := add(0x20, mload(signature))\\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                if eq(signature.length, 65) {\\n                    mstore(0x00, hash)\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), signature.length)\\n                // Copy the `signature` over.\\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(signature.length, 0x64), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, s) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), s) // `s`.\\n                mstore8(add(m, 0xa4), v) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            // Copy the `signature` over.\\n            let n := add(0x20, mload(signature))\\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNowCalldata(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), signature.length)\\n            // Copy the `signature` over.\\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(signature.length, 0x64), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), s) // `s`.\\n            mstore8(add(m, 0xa4), v) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n///\\n/// @dev Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    address private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = address(this);\\n        _cachedChainId = block.chainid;\\n\\n        string memory name;\\n        string memory version;\\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\\n        bytes32 versionHash =\\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        if (!_domainNameAndVersionMayChange()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let m := mload(0x40) // Load the free memory pointer.\\n                mstore(m, _DOMAIN_TYPEHASH)\\n                mstore(add(m, 0x20), nameHash)\\n                mstore(add(m, 0x40), versionHash)\\n                mstore(add(m, 0x60), chainid())\\n                mstore(add(m, 0x80), address())\\n                separator := keccak256(m, 0xa0)\\n            }\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    ///\\n    /// Note: If the returned result may change after the contract has been deployed,\\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\\n    function _domainNameAndVersion()\\n        internal\\n        view\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /// @dev Returns if `_domainNameAndVersion()` may change\\n    /// after the contract has been deployed (i.e. after the constructor).\\n    /// Default: false.\\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        if (_domainNameAndVersionMayChange()) {\\n            separator = _buildDomainSeparator();\\n        } else {\\n            separator = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        bytes32 separator;\\n        if (_domainNameAndVersionMayChange()) {\\n            separator = _buildDomainSeparator();\\n        } else {\\n            separator = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, separator) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        bytes32 nameHash;\\n        bytes32 versionHash;\\n        if (_domainNameAndVersionMayChange()) {\\n            (string memory name, string memory version) = _domainNameAndVersion();\\n            nameHash = keccak256(bytes(name));\\n            versionHash = keccak256(bytes(version));\\n        } else {\\n            nameHash = _cachedNameHash;\\n            versionHash = _cachedVersionHash;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        address cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/external/ISafeWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\nimport {IERC165} from \\\"openzeppelin-contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface ISafeWallet {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation)\\n        external\\n        returns (bool success);\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\\n        external\\n        returns (bool success, bytes memory returnData);\\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\\n    function isOwner(address owner) external view returns (bool);\\n    function nonce() external view returns (uint256);\\n    function getThreshold() external view returns (uint256);\\n    function isModuleEnabled(address module) external view returns (bool);\\n    function enableModule(address module) external;\\n    function disableModule(address prevModule, address module) external;\\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\\n    function getOwners() external view returns (address[] memory);\\n    function approveHash(bytes32 hashToApprove) external;\\n    function signedMessages(bytes32 _dataHash) external returns (uint256 _signatures);\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures\\n    ) external payable returns (bool);\\n\\n    function setup(\\n        address[] memory _owners,\\n        uint256 _threshold,\\n        address to,\\n        bytes memory data,\\n        address fallbackHandler,\\n        address paymentToken,\\n        uint256 payment,\\n        address paymentReceiver\\n    ) external;\\n\\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\\n    function domainSeparator() external view returns (bytes32);\\n    function setFallbackHandler(address _fallbackHandler) external;\\n    function setGuard(address guard) external;\\n    function encodeTransactionData(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    ) external view returns (bytes memory);\\n}\\n\\ninterface Guard is IERC165 {\\n    function checkTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures,\\n        address msgSender\\n    ) external;\\n\\n    function checkAfterExecution(bytes32 txHash, bool success) external;\\n}\\n\"\r\n    },\r\n    \"src/core/AddressProviderService.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {IAddressProviderService} from \\\"../../interfaces/IAddressProviderService.sol\\\";\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {Constants} from \\\"./Constants.sol\\\";\\n\\n/**\\n * @title AddressProviderService\\n * @author Brahma.fi\\n * @notice Provides a base contract for services to resolve other services through AddressProvider\\n * @dev This contract is designed to be inheritable by other contracts\\n *  Provides quick and easy access to all contracts in Console Ecosystem\\n */\\nabstract contract AddressProviderService is IAddressProviderService, Constants {\\n    error InvalidAddressProvider();\\n    error NotGovernance(address);\\n    error InvalidAddress();\\n\\n    /// @notice address of addressProvider\\n    // solhint-disable-next-line immutable-vars-naming\\n    AddressProvider public immutable addressProvider;\\n    address public immutable walletRegistry;\\n    address public immutable policyRegistry;\\n    address public immutable executorRegistry;\\n\\n    constructor(address _addressProvider) {\\n        if (_addressProvider == address(0)) revert InvalidAddressProvider();\\n        addressProvider = AddressProvider(_addressProvider);\\n\\n        walletRegistry = addressProvider.getRegistry(_WALLET_REGISTRY_HASH);\\n        policyRegistry = addressProvider.getRegistry(_POLICY_REGISTRY_HASH);\\n        executorRegistry = addressProvider.getRegistry(_EXECUTOR_REGISTRY_HASH);\\n\\n        _notNull(walletRegistry);\\n        _notNull(policyRegistry);\\n        _notNull(executorRegistry);\\n    }\\n\\n    /**\\n     * @inheritdoc IAddressProviderService\\n     */\\n    function addressProviderTarget() external view override returns (address) {\\n        return address(addressProvider);\\n    }\\n\\n    /**\\n     * @notice Helper to get authorized address from address provider\\n     * @param _key keccak256 key corresponding to authorized address\\n     * @return authorizedAddress\\n     */\\n    function _getAuthorizedAddress(bytes32 _key) internal view returns (address authorizedAddress) {\\n        authorizedAddress = addressProvider.getAuthorizedAddress(_key);\\n        _notNull(authorizedAddress);\\n    }\\n\\n    /**\\n     * @notice Helper to revert if address is null\\n     * @param _addr address to check\\n     */\\n    function _notNull(address _addr) internal pure {\\n        if (_addr == address(0)) revert InvalidAddress();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/TransactionValidator.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {ISafeWallet, Enum} from \\\"interfaces/external/ISafeWallet.sol\\\";\\nimport {PolicyValidator} from \\\"src/core/PolicyValidator.sol\\\";\\nimport {SafeHelper} from \\\"src/libraries/SafeHelper.sol\\\";\\nimport {AddressProviderService} from \\\"src/core/AddressProviderService.sol\\\";\\nimport {WalletRegistry} from \\\"src/core/registries/WalletRegistry.sol\\\";\\nimport {TypeHashHelper} from \\\"src/libraries/TypeHashHelper.sol\\\";\\n\\n/**\\n * @title TransactionValidator\\n * @author Brahma.fi\\n * @notice Allows validation of transactions pre and post execution\\n */\\ncontract TransactionValidator is AddressProviderService {\\n    error AccountNotFound(address);\\n    error InvalidGuard();\\n    error InvalidFallbackHandler();\\n    error InvalidModule();\\n    error InvalidExecutorPlugin();\\n    error TxnUnAuthorized();\\n\\n    /**\\n     * @notice datatype for safe transaction params\\n     * @param from address of safe\\n     * @param to target address\\n     * @param value txn value\\n     * @param data txn callData\\n     * @param operation type of operation\\n     * @param safeTxGas gas that should be used for safe txn\\n     * @param baseGas gas cost independent of txn cost\\n     * @param gasPrice gas price in current block\\n     * @param gasToken address of token used for gas\\n     * @param refundReceiver address of receiver of gas payment\\n     * @param signatures user signatures appended with validation signature\\n     * @param msgSender address of msg.sender of original txn\\n     */\\n    struct SafeTransactionParams {\\n        Enum.Operation operation;\\n        address from;\\n        address to;\\n        address payable refundReceiver;\\n        address gasToken;\\n        address msgSender;\\n        uint256 value;\\n        uint256 safeTxGas;\\n        uint256 baseGas;\\n        uint256 gasPrice;\\n        bytes data;\\n        bytes signatures;\\n    }\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   CONSOLE GUARD HOOKS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /**\\n     * @notice Validates a txn on guard before execution, for Brahma console accounts\\n     * @dev checks for possible console overrides and then performs policy validation\\n     * @param txParams params of transaction\\n     */\\n    function validatePreTransactionOverridable(SafeTransactionParams memory txParams) external view {\\n        // Validate policy\\n        _validatePolicySignature(\\n            TypeHashHelper.ExecutionParams({\\n                to: txParams.to,\\n                value: txParams.value,\\n                data: txParams.data,\\n                operation: uint8(txParams.operation),\\n                account: txParams.from,\\n                executor: address(0),\\n                nonce: ISafeWallet(txParams.from).nonce(),\\n                safeTxGas: txParams.safeTxGas,\\n                baseGas: txParams.baseGas,\\n                gasPrice: txParams.gasPrice,\\n                gasToken: txParams.gasToken,\\n                refundReceiver: txParams.refundReceiver\\n            }),\\n            txParams.signatures\\n        );\\n    }\\n\\n    /* solhint-disable no-empty-blocks */\\n    /**\\n     * @notice Provides on-chain guarantees on security critical expected states of a Brhma console account\\n     * @dev Empty hook available for future use\\n     */\\n    function validatePostTransactionOverridable(bytes32, /*txHash */ bool, /*success */ address /*console */ )\\n        external\\n        view\\n    {}\\n    /* solhint-enable no-empty-blocks */\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   SUBACCOUNT GUARD HOOKS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /**\\n     * @notice Validates a txn on guard before execution, for subAccounts\\n     * @dev calls policy validator to check if policy signature is valid\\n     * @param txParams params of transaction\\n     */\\n    function validatePreTransaction(SafeTransactionParams memory txParams) external view {\\n        _validatePolicySignature(\\n            TypeHashHelper.ExecutionParams({\\n                to: txParams.to,\\n                value: txParams.value,\\n                data: txParams.data,\\n                operation: uint8(txParams.operation),\\n                account: txParams.from,\\n                executor: address(0),\\n                nonce: ISafeWallet(txParams.from).nonce(),\\n                safeTxGas: txParams.safeTxGas,\\n                baseGas: txParams.baseGas,\\n                gasPrice: txParams.gasPrice,\\n                gasToken: txParams.gasToken,\\n                refundReceiver: txParams.refundReceiver\\n            }),\\n            txParams.signatures\\n        );\\n    }\\n\\n    /**\\n     * @notice Provides on-chain guarantees on security critical expected states of subAccount for guard\\n     * @param subAccount address of subAccount to validate\\n     */\\n    function validatePostTransaction(bytes32, /*txHash */ bool, /*success */ address subAccount) external view {\\n        _checkSubAccountSecurityConfig(subAccount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EXECUTOR PLUGIN GUARD HOOKS              */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /**\\n     * @notice Validates a module txn before execution\\n     * @dev calls policy validator to check if policy signature is valid\\n     * @param from address of safe\\n     * @param executionStructHash execution struct hash\\n     * @param signatures user signatures appended with validation signature\\n     */\\n    function validatePreExecutorTransaction(\\n        address, /*msgSender */\\n        address from,\\n        bytes32 executionStructHash,\\n        bytes calldata signatures\\n    ) external view {\\n        _validatePolicySignature(from, executionStructHash, signatures);\\n    }\\n\\n    /**\\n     * @notice Provides on-chain guarantees on security critical expected states of account for executor plugin\\n     * @param account address of account to validate\\n     */\\n    function validatePostExecutorTransaction(address, /*msgSender */ address account) external view {\\n        // Check if account has executor plugin still enabled as a module on it\\n        if (!ISafeWallet(account).isModuleEnabled(AddressProviderService._getAuthorizedAddress(_EXECUTOR_PLUGIN_HASH)))\\n        {\\n            revert InvalidExecutorPlugin();\\n        }\\n\\n        if (WalletRegistry(walletRegistry).isWallet(account)) {\\n            _checkConsoleAccountSecurityConfig(account);\\n        } else if (WalletRegistry(walletRegistry).subAccountToWallet(account) != address(0)) {\\n            _checkSubAccountSecurityConfig(account);\\n        } else {\\n            revert AccountNotFound(account);\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   INTERNAL METHODS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /**\\n     * @notice Internal helper to validate the module, guard and fallback handler for a subaccount\\n     * @dev Ensures that guard has not been disabled/updated and the owner console as a module has not been disabled\\n     * @param _subAccount address of subAccount\\n     */\\n    function _checkSubAccountSecurityConfig(address _subAccount) internal view {\\n        address guard = SafeHelper._getGuard(_subAccount);\\n        address fallbackHandler = SafeHelper._getFallbackHandler(_subAccount);\\n\\n        // Ensure guard has not been disabled\\n        if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)) revert InvalidGuard();\\n\\n        // Ensure fallback handler has not been altered\\n        if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) {\\n            revert InvalidFallbackHandler();\\n        }\\n\\n        address ownerConsole = WalletRegistry(walletRegistry).subAccountToWallet(_subAccount);\\n\\n        // Ensure owner console as a module has not been disabled\\n        if (!ISafeWallet(_subAccount).isModuleEnabled(ownerConsole)) revert InvalidModule();\\n    }\\n\\n    /**\\n     * @notice Internal helper to validate the module, guard and fallback handler for a console account\\n     * @dev Ensures that guard has not been disabled/updated\\n     * @param _consoleAccount address of consoleAccount\\n     */\\n    function _checkConsoleAccountSecurityConfig(address _consoleAccount) internal view {\\n        address guard = SafeHelper._getGuard(_consoleAccount);\\n        address fallbackHandler = SafeHelper._getFallbackHandler(_consoleAccount);\\n\\n        // Ensure guard has not been disabled\\n        if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_OVERRIDABLE_HASH)) {\\n            revert InvalidGuard();\\n        }\\n\\n        // Ensure fallback handler has not been altered\\n        if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) {\\n            revert InvalidFallbackHandler();\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal helper to validate policy signature for a safe txn\\n     * @dev Calls policy validator to check if policy signature is valid\\n     * @param _executionParams execution params struct\\n     * @param _signatures user signatures appended with validation signature\\n     */\\n    function _validatePolicySignature(TypeHashHelper.ExecutionParams memory _executionParams, bytes memory _signatures)\\n        internal\\n        view\\n    {\\n        if (\\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\\n                _executionParams, _signatures\\n            )\\n        ) {\\n            revert TxnUnAuthorized();\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal helper to validate policy signature for a module txn\\n     * @dev Calls policy validator to check if policy signature is valid\\n     * @param _from address of safe\\n     * @param _executionStructHash execution struct hash\\n     * @param _signatures user signatures appended with validation signature\\n     */\\n    function _validatePolicySignature(address _from, bytes32 _executionStructHash, bytes memory _signatures)\\n        internal\\n        view\\n    {\\n        if (\\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\\n                _from, _executionStructHash, _signatures\\n            )\\n        ) {\\n            revert TxnUnAuthorized();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/registries/ExecutorRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {AddressProviderService} from \\\"../AddressProviderService.sol\\\";\\nimport {WalletRegistry} from \\\"./WalletRegistry.sol\\\";\\nimport {EnumerableSet} from \\\"openzeppelin-contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @title ExecutorRegistry\\n * @author Brahma.fi\\n * @notice Registry for executors for sub accounts\\n */\\ncontract ExecutorRegistry is AddressProviderService {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    error NotAuthorized();\\n    error AlreadyExists();\\n    error DoesNotExist();\\n    error NoPolicyCommit();\\n\\n    event RegisterExecutor(address indexed _account, address indexed _authorizer, address indexed _executor);\\n    event DeRegisterExecutor(address indexed _account, address indexed _authorizer, address indexed _executor);\\n\\n    /// @notice account addresses mapped to executor addresses\\n    mapping(address account => EnumerableSet.AddressSet) private accountExecutors;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Registers an executor for account\\n     * @dev Adds new executor if it doesn't already exists else reverts with AlreadyExists()\\n     * @dev Can be only called by main console\\n     * @param _account console/subaccount address to add executor to\\n     * @param _executor executor to add\\n     */\\n    function registerExecutor(address _account, address _executor) external {\\n        _validateMsgSenderConsoleAccount(_account);\\n        if (!accountExecutors[_account].add(_executor)) revert AlreadyExists();\\n        emit RegisterExecutor(_account, msg.sender, _executor);\\n    }\\n\\n    /**\\n     * @notice De-registers an executor for console account/ subaccount\\n     * @dev removes an executor if it exists else reverts with DoesNotExist()\\n     * @dev Can be only called by main console\\n     * @param _account console/subaccount address to remove executor from\\n     * @param _executor executor to remove\\n     */\\n    function deRegisterExecutor(address _account, address _executor) external {\\n        _validateMsgSenderConsoleAccount(_account);\\n\\n        if (!accountExecutors[_account].remove(_executor)) revert DoesNotExist();\\n        emit DeRegisterExecutor(_account, msg.sender, _executor);\\n    }\\n\\n    /**\\n     * @notice checks if _executor is registered for _account\\n     * @param _account address of account\\n     * @param _executor address of executor\\n     * @return isExecutorValid\\n     */\\n    function isExecutor(address _account, address _executor) external view returns (bool) {\\n        return accountExecutors[_account].contains(_executor);\\n    }\\n\\n    /**\\n     * @return all the executors for a console account / subaccount\\n     * @param _account address of account\\n     */\\n    function getExecutorsForAccount(address _account) external view returns (address[] memory) {\\n        return accountExecutors[_account].values();\\n    }\\n\\n    function _validateMsgSenderConsoleAccount(address _account) internal view {\\n        // msg.sender is console account\\n        if (msg.sender == _account && WalletRegistry(walletRegistry).isWallet(msg.sender)) return;\\n\\n        // msg.sender is console account and owns the _account\\n        if (WalletRegistry(walletRegistry).subAccountToWallet(_account) == msg.sender) return;\\n\\n        revert NotAuthorized();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeHelper.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {Enum, ISafeWallet} from \\\"interfaces/external/ISafeWallet.sol\\\";\\nimport {Types} from \\\"interfaces/Types.sol\\\";\\n\\n/**\\n * @title SafeHelper\\n * @author Brahma.fi\\n * @notice Helper library containing functions to interact with safe wallet\\n */\\nlibrary SafeHelper {\\n    error InvalidMultiSendInput();\\n    error UnableToParseOperation();\\n\\n    /// @notice uint256(keccak256(\\\"guard_manager.guard.address\\\"))\\n    /// @dev This refers to the storage slot where guard is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/GuardManager.sol#L77\\n    uint256 internal constant _GUARD_STORAGE_SLOT =\\n        33528237782592280163068556224972516439282563014722366175641814928123294921928;\\n    /// @notice uint256(keccak256(\\\"fallback_manager.handler.address\\\"))\\n    /// @dev This refers to the storage slot where fallback handler is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/FallbackManager.sol#L14\\n    uint256 internal constant _FALLBACK_HANDLER_STORAGE_SLOT =\\n        49122629484629529244014240937346711770925847994644146912111677022347558721749;\\n\\n    /**\\n     * @notice Contains hash for expected overridable guard removal calldata\\n     * @dev This is the hash of the calldata for the following function call\\n     *\\n     * abi.encodeCall(ISafeWallet.setGuard, (address(0))) = 0xe19a9dd90000000000000000000000000000000000000000000000000000000000000000\\n     * keccak256(abi.encodeCall(ISafeWallet.setGuard, (address(0)))) = 0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079\\n     */\\n    bytes32 internal constant _GUARD_REMOVAL_CALLDATA_HASH =\\n        0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079;\\n\\n    /**\\n     * @notice Contains hash for expected overridable fallback handler removal calldata\\n     * @dev This is the hash of the calldata for the following function call\\n     *\\n     * abi.encodeCall(ISafeWallet.setFallbackHandler, (address(0))) = 0xf08a03230000000000000000000000000000000000000000000000000000000000000000\\n     * keccak256(abi.encodeCall(ISafeWallet.setFallbackHandler, (address(0)))) = 0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7\\n     */\\n    bytes32 internal constant _FALLBACK_REMOVAL_CALLDATA_HASH =\\n        0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7;\\n\\n    /**\\n     * @notice Packs multiple executables into a single bytes array compatible with Safe's MultiSend contract which can be used as argument for multicall method\\n     * @dev Reference contract at https://github.com/safe-global/safe-contracts/blob/main/contracts/libraries/MultiSend.sol\\n     * @param _txns Array of executables to pack\\n     * @return packedTxns bytes array containing packed transactions\\n     */\\n    function _packMultisendTxns(Types.Executable[] memory _txns) internal pure returns (bytes memory packedTxns) {\\n        uint256 len = _txns.length;\\n        if (len == 0) revert InvalidMultiSendInput();\\n\\n        uint256 i = 0;\\n        do {\\n            uint8 call = uint8(_parseOperationEnum(_txns[i].callType));\\n\\n            uint256 calldataLength = _txns[i].data.length;\\n\\n            bytes memory encodedTxn = abi.encodePacked(\\n                bytes1(call), bytes20(_txns[i].target), bytes32(_txns[i].value), bytes32(calldataLength), _txns[i].data\\n            );\\n\\n            if (i != 0) {\\n                // If not first transaction, append to packedTxns\\n                packedTxns = abi.encodePacked(packedTxns, encodedTxn);\\n            } else {\\n                // If first transaction, set packedTxns to encodedTxn\\n                packedTxns = encodedTxn;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        } while (i < len);\\n    }\\n\\n    /**\\n     * @notice Gets the guard for a safe\\n     * @param safe address of safe\\n     * @return address of guard, address(0) if no guard exists\\n     */\\n    function _getGuard(address safe) internal view returns (address) {\\n        bytes memory guardAddress = ISafeWallet(safe).getStorageAt(_GUARD_STORAGE_SLOT, 1);\\n        return address(uint160(uint256(bytes32(guardAddress))));\\n    }\\n\\n    /**\\n     * @notice Gets the fallback handler for a safe\\n     * @param safe address of safe\\n     * @return address of fallback handler, address(0) if no fallback handler exists\\n     */\\n    function _getFallbackHandler(address safe) internal view returns (address) {\\n        bytes memory fallbackHandlerAddress = ISafeWallet(safe).getStorageAt(_FALLBACK_HANDLER_STORAGE_SLOT, 1);\\n        return address(uint160(uint256(bytes32(fallbackHandlerAddress))));\\n    }\\n\\n    /**\\n     * @notice Converts a CallType enum to an Operation enum.\\n     * @dev Reverts with UnableToParseOperation error if the CallType is not supported.\\n     * @param callType The CallType enum to be converted.\\n     * @return operation The converted Operation enum.\\n     */\\n    function _parseOperationEnum(Types.CallType callType) internal pure returns (Enum.Operation operation) {\\n        if (callType == Types.CallType.DELEGATECALL) {\\n            operation = Enum.Operation.DelegateCall;\\n        } else if (callType == Types.CallType.CALL) {\\n            operation = Enum.Operation.Call;\\n        } else {\\n            revert UnableToParseOperation();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/TypeHashHelper.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title TypeHashHelper\\n * @author Brahma.fi\\n * @notice Helper library containing functions to build EIP712 struct and type hashes\\n */\\nlibrary TypeHashHelper {\\n    /**\\n     * @notice Structural representation of execution details\\n     * @param operation type of operation\\n     * @param to address to send tx to\\n     * @param account address of safe\\n     * @param executor address of executor if executed via executor plugin, address(0) if executed via execTransaction\\n     * @param gasToken address of token used for gas\\n     * @param refundReceiver address of receiver of gas payment\\n     * @param value txn value\\n     * @param nonce txn nonce\\n     * @param safeTxGas gas that should be used for safe txn\\n     * @param baseGas gas cost independent of txn cost\\n     * @param gasPrice gas price in current block\\n     * @param data txn callData\\n     */\\n    struct ExecutionParams {\\n        uint8 operation;\\n        address to;\\n        address account;\\n        address executor;\\n        address gasToken;\\n        address refundReceiver;\\n        uint256 value;\\n        uint256 nonce;\\n        uint256 safeTxGas;\\n        uint256 baseGas;\\n        uint256 gasPrice;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @notice Type of validation struct to hash\\n     * @param expiryEpoch max time till validity of the signature\\n     * @param executionStructHash txn digest generated using TypeHashHelper._buildExecutionParamsHash()\\n     * @param policyHash policy commit hash of the safe account\\n     */\\n    struct ValidationParams {\\n        uint32 expiryEpoch;\\n        bytes32 executionStructHash;\\n        bytes32 policyHash;\\n    }\\n\\n    /**\\n     * @notice EIP712 typehash for execution params data\\n     * @dev keccak256(\\\"ExecutionParams(uint8 operation,address to,address account,address executor,address gasToken,address refundReceiver,uint256 value,uint256 nonce,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,bytes data)\\\");\\n     */\\n    bytes32 public constant EXECUTION_PARAMS_TYPEHASH =\\n        0x483ad580f0a8d7881e792d04b2128f3b214b18aa7336126dc2e77a59752bd6f5;\\n\\n    /**\\n     * @notice EIP712 typehash for validation data\\n     * @dev keccak256(\\\"ValidationParams(uint32 expiryEpoch,ExecutionParams executionParams,bytes32 policyHash)ExecutionParams(uint8 operation,address to,address account,address executor,address gasToken,address refundReceiver,uint256 value,uint256 nonce,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,bytes data)\\\");\\n     */\\n    bytes32 public constant VALIDATION_PARAMS_TYPEHASH =\\n        0x37af4ddfcab5e0a0d11676ce89534ca59ffac1c30a5a4cc21f840d2f4704a952;\\n\\n    /**\\n     * @notice Builds EIP712 execution struct hash\\n     * @param txn execution params struct\\n     * @return executionStructHash\\n     */\\n    function _buildExecutionParamsHash(ExecutionParams memory txn) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                EXECUTION_PARAMS_TYPEHASH,\\n                txn.operation,\\n                txn.to,\\n                txn.account,\\n                txn.executor,\\n                txn.gasToken,\\n                txn.refundReceiver,\\n                txn.value,\\n                txn.nonce,\\n                txn.safeTxGas,\\n                txn.baseGas,\\n                txn.gasPrice,\\n                keccak256(txn.data)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Builds EIP712 validation struct hash\\n     * @param validation validation params struct\\n     * @return validationStructHash\\n     */\\n    function _buildValidationParamsHash(ValidationParams memory validation) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                VALIDATION_PARAMS_TYPEHASH,\\n                validation.expiryEpoch,\\n                validation.executionStructHash,\\n                validation.policyHash\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\ninterface Types {\\n    enum CallType {\\n        CALL,\\n        DELEGATECALL,\\n        STATICCALL\\n    }\\n\\n    struct Executable {\\n        CallType callType;\\n        address target;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct TokenRequest {\\n        address token;\\n        uint256 amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/IAddressProviderService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\ninterface IAddressProviderService {\\n    /// @notice Returns the address of the AddressProvider\\n    function addressProviderTarget() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/core/AddressProvider.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {IAddressProviderService} from \\\"interfaces/IAddressProviderService.sol\\\";\\nimport {Constants} from \\\"src/core/Constants.sol\\\";\\n\\n/**\\n * @title AddressProvider\\n * @author Brahma.fi\\n * @notice Single source of truth for resolving addresses of core components and external contracts\\n */\\ncontract AddressProvider is Constants {\\n    error RegistryAlreadyExists();\\n    error AddressProviderUnsupported();\\n    error NotGovernance(address);\\n    error NotPendingGovernance(address);\\n    error NullAddress();\\n\\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /// @notice address of governance\\n    address public governance;\\n    /// @notice address of pending governance before accepting\\n    address public pendingGovernance;\\n\\n    /**\\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\\n     * @dev Core & Roles are used as keys for this mapping. These addresses are mutable\\n     * @dev authorizedAddresses are updatable by governance\\n     */\\n    mapping(bytes32 => address) internal authorizedAddresses;\\n\\n    /**\\n     * @notice keccak256 hash of registry keys mapped to their addresses\\n     * @dev registries are only set once by governance and immutable\\n     */\\n    mapping(bytes32 => address) internal registries;\\n\\n    constructor(address _governance, address walletRegistry, address policyRegistry, address executorRegistry) {\\n        _notNull(_governance);\\n        governance = _governance;\\n\\n        _notNull(walletRegistry);\\n        _notNull(policyRegistry);\\n        _notNull(executorRegistry);\\n        registries[_WALLET_REGISTRY_HASH] = walletRegistry;\\n        registries[_POLICY_REGISTRY_HASH] = policyRegistry;\\n        registries[_EXECUTOR_REGISTRY_HASH] = executorRegistry;\\n    }\\n\\n    /**\\n     * @notice Governance setter\\n     * @param _newGovernance address of new governance\\n     */\\n    function setGovernance(address _newGovernance) external {\\n        _notNull(_newGovernance);\\n        _onlyGov();\\n        emit GovernanceTransferRequested(governance, _newGovernance);\\n        pendingGovernance = _newGovernance;\\n    }\\n\\n    /**\\n     * @notice Governance accepter\\n     */\\n    function acceptGovernance() external {\\n        if (msg.sender != pendingGovernance) {\\n            revert NotPendingGovernance(msg.sender);\\n        }\\n        emit GovernanceTransferred(governance, msg.sender);\\n        governance = msg.sender;\\n        delete pendingGovernance;\\n    }\\n\\n    /**\\n     * @notice Authorized address setter\\n     * @param _key key of authorizedAddress\\n     * @param _authorizedAddress address to set\\n     * @param _overrideCheck overrides check for supported address provider\\n     */\\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\\n        _onlyGov();\\n        _notNull(_authorizedAddress);\\n\\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\\n        if (!_overrideCheck) {\\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\\n        }\\n\\n        authorizedAddresses[_key] = _authorizedAddress;\\n\\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\\n    }\\n\\n    /**\\n     * @notice Registry address setter\\n     * @param _key key of registry address\\n     * @param _registry address to set\\n     */\\n    function setRegistry(bytes32 _key, address _registry) external {\\n        _onlyGov();\\n        _ensureAddressProvider(_registry);\\n\\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\\n        registries[_key] = _registry;\\n\\n        emit RegistryInitialised(_registry, _key);\\n    }\\n\\n    /**\\n     * @notice Authorized address getter\\n     * @param _key key of authorized address\\n     * @return address of authorized address\\n     */\\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\\n        return authorizedAddresses[_key];\\n    }\\n\\n    /**\\n     * @notice Registry address getter\\n     * @param _key key of registry address\\n     * @return address of registry address\\n     */\\n    function getRegistry(bytes32 _key) external view returns (address) {\\n        return registries[_key];\\n    }\\n\\n    /**\\n     * @notice Ensures that the new address supports the AddressProviderService interface\\n     * and is pointing to this AddressProvider\\n     * @param _newAddress address to check\\n     */\\n    function _ensureAddressProvider(address _newAddress) internal view {\\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\\n            revert AddressProviderUnsupported();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if msg.sender is governance\\n     */\\n    function _onlyGov() internal view {\\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Checks and reverts if address is null\\n     * @param addr address to check if null\\n     */\\n    function _notNull(address addr) internal pure {\\n        if (addr == address(0)) revert NullAddress();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/Constants.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Constants\\n * @author Brahma.fi\\n * @notice Contains constants used by multiple contracts\\n * @dev Inflates bytecode size by approximately 560 bytes on deployment, but saves gas on runtime\\n */\\nabstract contract Constants {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        REGISTRIES                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /// @notice Key to map address of ExecutorRegistry\\n    bytes32 internal constant _EXECUTOR_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutorRegistry\\\")) - 1);\\n\\n    /// @notice Key to map address of WalletRegistry\\n    bytes32 internal constant _WALLET_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.WalletRegistry\\\")) - 1);\\n\\n    /// @notice Key to map address of PolicyRegistry\\n    bytes32 internal constant _POLICY_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.PolicyRegistry\\\")) - 1);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          CORE                              */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /// @notice Key to map address of ExecutorPlugin\\n    bytes32 internal constant _EXECUTOR_PLUGIN_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutorPlugin\\\")) - 1);\\n\\n    /// @notice Key to map address of ConsoleFallbackHandler\\n    bytes32 internal constant _CONSOLE_FALLBACK_HANDLER_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.FallbackHandler\\\")) - 1);\\n\\n    /// @notice Key to map address of Safe FallbackHandler\\n    bytes32 internal constant _SAFE_FALLBACK_HANDLER_HASH = bytes32(uint256(keccak256(\\\"safe.FallbackHandler\\\")) - 1);\\n\\n    /// @notice Key to map address of Safe MultiSend\\n    bytes32 internal constant _SAFE_MULTI_SEND_HASH = bytes32(uint256(keccak256(\\\"safe.MultiSend\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeProxyFactory\\n    bytes32 internal constant _SAFE_PROXY_FACTORY_HASH = bytes32(uint256(keccak256(\\\"safe.ProxyFactory\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeSingleton\\n    bytes32 internal constant _SAFE_SINGLETON_HASH = bytes32(uint256(keccak256(\\\"safe.Singleton\\\")) - 1);\\n\\n    /// @notice Key to map address of PolicyValidator\\n    bytes32 internal constant _POLICY_VALIDATOR_HASH = bytes32(uint256(keccak256(\\\"console.core.PolicyValidator\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeDeployer\\n    bytes32 internal constant _SAFE_DEPLOYER_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeDeployer\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeEnabler\\n    bytes32 internal constant _SAFE_ENABLER_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeEnabler\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeModerator\\n    bytes32 internal constant _SAFE_MODERATOR_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeModerator\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeModeratorOverridable\\n    bytes32 internal constant _SAFE_MODERATOR_OVERRIDABLE_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.SafeModeratorOverridable\\\")) - 1);\\n\\n    /// @notice Key to map address of TransactionValidator\\n    bytes32 internal constant _TRANSACTION_VALIDATOR_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.TransactionValidator\\\")) - 1);\\n\\n    /// @notice Key to map address of ConsoleOpBuilder\\n    bytes32 internal constant _CONSOLE_OP_BUILDER_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.ConsoleOpBuilder\\\")) - 1);\\n\\n    /// @notice Key to map address of ExecutionBlocker\\n    bytes32 internal constant _EXECUTION_BLOCKER_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutionBlocker\\\")) - 1);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ROLES                             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @notice Key to map address of Role PolicyAuthenticator\\n    bytes32 internal constant _POLICY_AUTHENTICATOR_HASH =\\n        bytes32(uint256(keccak256(\\\"console.roles.PolicyAuthenticator\\\")) - 1);\\n}\\n\"\r\n    },\r\n    \"src/core/PolicyValidator.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {SignatureCheckerLib} from \\\"solady/utils/SignatureCheckerLib.sol\\\";\\nimport {EIP712} from \\\"solady/utils/EIP712.sol\\\";\\nimport {AddressProviderService} from \\\"src/core/AddressProviderService.sol\\\";\\nimport {PolicyRegistry} from \\\"src/core/registries/PolicyRegistry.sol\\\";\\nimport {TypeHashHelper} from \\\"src/libraries/TypeHashHelper.sol\\\";\\nimport {ISafeWallet, Enum} from \\\"interfaces/external/ISafeWallet.sol\\\";\\n\\n/**\\n * @title PolicyValidator\\n * @author Brahma.fi\\n * @notice Responsible for validating policy signatures for safe transactions\\n */\\ncontract PolicyValidator is AddressProviderService, EIP712 {\\n    error InvalidSignature();\\n    error NoPolicyCommit();\\n    error TxnExpired(uint32 expiryEpoch);\\n    error InvalidSignatures();\\n\\n    /// @notice EIP712 domain name\\n    string private constant _NAME = \\\"PolicyValidator\\\";\\n    /// @notice EIP712 domain version\\n    string private constant _VERSION = \\\"1.0\\\";\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice generates digest and validates signature against policies for safe transaction\\n     * @dev The POLICY_AUTHENTICATOR is expected to sign EIP712 digest generated from the following struct:\\n     * TypeHashHelper.ValidationParams, where -\\n     *  txnDigest = EIP712 digest generated from struct: TypeHashHelper.ExecutionParams\\n     *  policyHash = policy commit hash of the safe account\\n     *  expiryEpoch = expiry timestamp\\n     *\\n     * @dev signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\\n     *  validatorSignature = EIP 712 digest signature (arbitrary bytes length)\\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\\n     *  expiryEpoch = expiry timestamp (4 bytes)\\n     *\\n     * @param executionParams execution params struct\\n     * @param signatures user signatures appended with validation signature\\n     * @return isSignatureValid boolean\\n     */\\n    function isPolicySignatureValid(TypeHashHelper.ExecutionParams memory executionParams, bytes calldata signatures)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        // Build transaction struct hash\\n        bytes32 executionStructHash = TypeHashHelper._buildExecutionParamsHash(executionParams);\\n\\n        // Validate signature\\n        return isPolicySignatureValid(executionParams.account, executionStructHash, signatures);\\n    }\\n\\n    /**\\n     * @notice generates digest and validates signature against policies for module execution\\n     * @dev signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\\n     *      safeSignature = safe owners signatures (arbitrary bytes length)\\n     *      validatorSignature = EIP 712 digest signed by `POLICY_AUTHENTICATOR`(arbitrary bytes length)\\n     *      validatorSignatureLength = length of `validatorSignature` (4 bytes)\\n     *      expiryEpoch = expiry timestamp (4 bytes)\\n     *  Here,\\n     *  The `POLICY_AUTHENTICATOR` is expected to sign the EIP 712 digest generated from following struct:\\n     *  TypeHashHelper.ValidationParams -\\n     *      txnDigest = EIP712 digest generated from struct: TypeHashHelper.ExecutionParams, with valid executor\\n     *      policyHash = policy commit hash of the safe account\\n     *      expiryEpoch = expiry timestamp\\n     *\\n     * @param account address of account to validate txn for\\n     * @param executionStructHash execution digest from ExecutorPlugin\\n     * @param signatures user signatures appended with validation signature\\n     * @return isSignatureValid boolean\\n     */\\n    function isPolicySignatureValid(address account, bytes32 executionStructHash, bytes calldata signatures)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        // Get policy hash from registry\\n        bytes32 policyHash = PolicyRegistry(policyRegistry).commitments(account);\\n        if (policyHash == bytes32(0)) {\\n            revert NoPolicyCommit();\\n        }\\n\\n        // Get expiry epoch and validator signature from signatures\\n        (uint32 expiryEpoch, bytes memory validatorSignature) = _decompileSignatures(signatures);\\n\\n        // Ensure transaction has not expired\\n        if (expiryEpoch < uint32(block.timestamp)) {\\n            revert TxnExpired(expiryEpoch);\\n        }\\n\\n        // Build validation struct hash\\n        bytes32 validationStructHash = TypeHashHelper._buildValidationParamsHash(\\n            TypeHashHelper.ValidationParams({\\n                executionStructHash: executionStructHash,\\n                policyHash: policyHash,\\n                expiryEpoch: expiryEpoch\\n            })\\n        );\\n\\n        // Build EIP712 digest with validation struct hash\\n        bytes32 txnValidityDigest = _hashTypedData(validationStructHash);\\n\\n        address policyAuthenticator = AddressProviderService._getAuthorizedAddress(_POLICY_AUTHENTICATOR_HASH);\\n\\n        // Empty Signature check for EOA signer\\n        if (validatorSignature.length == 0) {\\n            uint256 _codesize;\\n            assembly {\\n                _codesize := extcodesize(policyAuthenticator)\\n            }\\n            if (_codesize == 0) {\\n                // PolicyAuthenticator is an EOA and no policyAuthenticator signature is provided\\n                revert InvalidSignature();\\n            }\\n        }\\n\\n        // Validate signature\\n        return SignatureCheckerLib.isValidSignatureNow(policyAuthenticator, txnValidityDigest, validatorSignature);\\n    }\\n\\n    /**\\n     * @notice Internal helper to extract validity signature from overall safe transaction signature\\n     * @dev _signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\\n     *  validatorSignature = EIP 712 digest signed (arbitrary bytes length)\\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\\n     *  expiryEpoch = expiry timestamp (4 bytes)\\n     *\\n     * @param _signatures packed transaction signature\\n     * @return expiryEpoch extracted expiry epoch signed by brahma backend\\n     * @return validatorSignature extracted validity signature\\n     */\\n    function _decompileSignatures(bytes calldata _signatures)\\n        internal\\n        pure\\n        returns (uint32 expiryEpoch, bytes memory validatorSignature)\\n    {\\n        if (_signatures.length < 8) revert InvalidSignatures();\\n\\n        uint32 sigLength = uint32(bytes4(_signatures[_signatures.length - 8:_signatures.length - 4]));\\n        if (_signatures.length - 8 < sigLength) revert InvalidSignatures();\\n\\n        expiryEpoch = uint32(bytes4(_signatures[_signatures.length - 4:_signatures.length]));\\n        validatorSignature = _signatures[_signatures.length - 8 - sigLength:_signatures.length - 8];\\n    }\\n\\n    /**\\n     * @notice Internal helper to get EIP712 domain name and version\\n     * @return name domainName\\n     * @return version domainVersion\\n     */\\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\\n        return (_NAME, _VERSION);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/registries/WalletRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {AddressProviderService} from \\\"../AddressProviderService.sol\\\";\\n\\n/**\\n * @title WalletRegistry\\n * @author Brahma.fi\\n * @notice Registry for wallet and sub account addresses\\n */\\ncontract WalletRegistry is AddressProviderService {\\n    error AlreadyRegistered();\\n    error InvalidSender();\\n    error IsSubAccount();\\n\\n    event RegisterWallet(address indexed wallet);\\n    event RegisterSubAccount(address indexed wallet, address indexed subAccount);\\n\\n    /// @notice subAccount addresses mapped to owner wallet\\n    mapping(address subAccount => address wallet) public subAccountToWallet;\\n    /// @notice wallet addresses mapped to list of subAccounts\\n    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;\\n    /// @notice address of wallet mapped to boolean indicating if it's a wallet\\n    mapping(address => bool) public isWallet;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Registers a wallet\\n     * @dev Can only be called by wallet to register itself\\n     */\\n    function registerWallet() external {\\n        if (isWallet[msg.sender]) revert AlreadyRegistered();\\n        if (subAccountToWallet[msg.sender] != address(0)) revert IsSubAccount();\\n        isWallet[msg.sender] = true;\\n        emit RegisterWallet(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Registers a sub account for a Safe\\n     * @param _wallet Console account address, owner of sub account\\n     * @param _subAccount Sub account address to register\\n     * @dev Can only be called by safe deployer\\n     */\\n\\n    function registerSubAccount(address _wallet, address _subAccount) external {\\n        if (msg.sender != AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)) revert InvalidSender();\\n\\n        if (subAccountToWallet[_subAccount] != address(0) || isWallet[_subAccount]) revert AlreadyRegistered();\\n\\n        subAccountToWallet[_subAccount] = _wallet;\\n        walletToSubAccountList[_wallet].push(_subAccount);\\n        emit RegisterSubAccount(_wallet, _subAccount);\\n    }\\n\\n    /**\\n     * @notice sub account list getter\\n     * @dev returns sub account list associated with _wallet\\n     * @param _wallet safe address\\n     * @return list of subAccounts for wallet\\n     */\\n    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {\\n        return walletToSubAccountList[_wallet];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/registries/PolicyRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {AddressProviderService} from \\\"src/core/AddressProviderService.sol\\\";\\nimport {WalletRegistry} from \\\"src/core/registries/WalletRegistry.sol\\\";\\n\\n/**\\n * @title PolicyRegistry\\n * @author Brahma.fi\\n * @notice Registry for policy commits for wallets and sub accounts\\n */\\ncontract PolicyRegistry is AddressProviderService {\\n    error PolicyCommitInvalid();\\n    error UnauthorizedPolicyUpdate();\\n\\n    event UpdatedPolicyCommit(address indexed account, bytes32 policyCommit, bytes32 oldPolicyCommit);\\n\\n    /// @notice account addresses mapped to their policy commits\\n    mapping(address account => bytes32 policyCommit) public commitments;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Enables setting policy commits for accounts\\n     * @param account address of account to set policy commit for\\n     * @param policyCommit policy commit hash to set\\n     * @dev policyCommit for an account can be set by:\\n     *  1. by safe deployer, if the account is uninitialized\\n     *  2. by the registered wallet, if the account is a subAccount\\n     *  3. by the account itself, if account is a registered wallet\\n     */\\n    function updatePolicy(address account, bytes32 policyCommit) external {\\n        if (policyCommit == bytes32(0)) {\\n            revert PolicyCommitInvalid();\\n        }\\n\\n        bytes32 currentCommit = commitments[account];\\n\\n        // solhint-disable no-empty-blocks\\n        if (\\n            currentCommit == bytes32(0)\\n                && msg.sender == AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)\\n        ) {\\n            // In case invoker is safe  deployer\\n        } else {\\n            if (WalletRegistry(walletRegistry).subAccountToWallet(account) == msg.sender) {\\n                //In case invoker is updating on behalf of sub account\\n            } else if (msg.sender == account && WalletRegistry(walletRegistry).isWallet(msg.sender)) {\\n                // In case invoker is a registered wallet\\n            } else {\\n                revert UnauthorizedPolicyUpdate();\\n            }\\n        }\\n        // solhint-enable no-empty-blocks\\n        _updatePolicy(account, policyCommit, currentCommit);\\n    }\\n\\n    /**\\n     * @notice Internal function to update policy commit for an account\\n     * @param account address of account to set policy commit for\\n     * @param policyCommit policy commit hash to set\\n     */\\n    function _updatePolicy(address account, bytes32 policyCommit, bytes32 oldPolicyCommit) internal {\\n        emit UpdatedPolicyCommit(account, policyCommit, oldPolicyCommit);\\n        commitments[account] = policyCommit;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solady/lib/solmate/src/\",\r\n      \"solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddressProvider\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleExecutionFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableToParseOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"addressProvider\",\"outputs\":[{\"internalType\":\"contract AddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressProviderTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum Types.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Executable\",\"name\":\"exec\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"executorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"validatorSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct ExecutorPlugin.ExecutionRequest\",\"name\":\"execRequest\",\"type\":\"tuple\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executorNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executorRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ExecutorPlugin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000006fcf22e22f736d9ead75de8a1f12ca869287e229", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}