{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Platform/Meta/MetaSpaceController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IMetaSpace.sol\\\";\\r\\nimport {Pausable} from \\\"../../Pausable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract MetaSpaceController is IMetaSpace, Pausable, ReentrancyGuard {\\r\\n    address _platform_address;\\r\\n    address _metaspace_token_address;\\r\\n\\r\\n    MetaSpace[] public _metaSpaces;\\r\\n    mapping(uint256 => Token[]) _tokens;\\r\\n    mapping(uint256 => Curator[]) _curators;\\r\\n    mapping(uint256 => Partner[]) _partners;\\r\\n    uint256 tokenId;\\r\\n\\r\\n    mapping(uint256 => uint256) _tokens_metaspace_uid; \\r\\n    mapping(uint256 => uint256) _global_to_local_token_uids;\\r\\n\\r\\n    mapping(uint256 => mapping(address => mapping(uint256 => bool)))\\r\\n        private _submited_tokens;\\r\\n    mapping(uint256 => mapping(uint256 => bool))\\r\\n        private _curator_approved_tokens;\\r\\n\\r\\n    mapping(uint256 => mapping(address => bool)) private _is_curator_address;\\r\\n    mapping(uint256 => mapping(address => bool)) private _is_partner_address;\\r\\n\\r\\n    modifier onlyOwner(uint256 uid) {\\r\\n        require(msg.sender == _metaSpaces[uid].owner_of, \\\"Only for owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address platform_address_\\r\\n    ) Pausable(msg.sender) {\\r\\n        _platform_address = platform_address_;\\r\\n    }\\r\\n\\r\\n    function createSpace(string memory uri_) external {\\r\\n        uint256 uid = _metaSpaces.length;\\r\\n        _metaSpaces.push(MetaSpace(uid, msg.sender, 0, uri_, 0, 0, address(0)));\\r\\n        _curators[uid].push(Curator(msg.sender, 0));\\r\\n        IERC721MetaSpace(_metaspace_token_address).mint(msg.sender, uid);\\r\\n    }\\r\\n\\r\\n    function updateTerms(\\r\\n        uint256 uid,\\r\\n        Access memory access_,\\r\\n        address[] memory partners_,\\r\\n        uint256[] memory partners_fees_,\\r\\n        OwnerMeta memory owner_meta_,\\r\\n        address[] memory curators_,\\r\\n        uint256[] memory curator_fees_\\r\\n    ) external onlyOwner(uid) {\\r\\n        MetaSpace memory _metaSpace = _metaSpaces[uid];\\r\\n        require(\\r\\n            curators_.length == curator_fees_.length,\\r\\n            \\\"Invalid inputs for curators\\\"\\r\\n        );\\r\\n        require(\\r\\n            partners_.length == partners_fees_.length,\\r\\n            \\\"Invalid inputs for partners\\\"\\r\\n        );\\r\\n        require(curators_.length <= 2, \\\"To much curators for Space\\\");\\r\\n        uint256 percentages = (owner_meta_.owner_fee_ * 10) + 25;\\r\\n        for (uint256 i = 0; i < partners_fees_.length; i++) {\\r\\n            percentages += partners_fees_[i] * 10;\\r\\n        }\\r\\n        for (uint256 i = 0; i < curator_fees_.length; i++) {\\r\\n            percentages += curator_fees_[i] * 10;\\r\\n        }\\r\\n        require(percentages <= 1000, \\\"Percentage too big\\\");\\r\\n\\r\\n        _metaSpace.owner_of = owner_meta_.owner_of_;\\r\\n        _metaSpace.owner_fee = owner_meta_.owner_fee_;\\r\\n        _metaSpace.access_token_address = access_.token_address;\\r\\n        _metaSpace.access_fee = access_.access_fee;\\r\\n        _metaSpace.submit_fee = access_.submit_fee;\\r\\n        _metaSpaces[uid] = _metaSpace;\\r\\n\\r\\n        for (uint256 i = 0; i < partners_.length; i++) {\\r\\n            _partners[uid].push(Partner(partners_[i], partners_fees_[i]));\\r\\n            _is_partner_address[uid][partners_[i]] = true;\\r\\n        }\\r\\n        for (uint256 i = 0; i < curators_.length; i++) {\\r\\n            _curators[uid].push(Curator(curators_[i], curator_fees_[i]));\\r\\n            _is_curator_address[uid][curators_[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function submitToken(\\r\\n        uint256 space_uid,\\r\\n        address token_address_,\\r\\n        uint256 token_id_,\\r\\n        uint256 amount_,\\r\\n        ContractType contract_type_,\\r\\n        uint256 price_\\r\\n    ) external {\\r\\n        MetaSpace memory _metaSpace = _metaSpaces[space_uid];\\r\\n        if (\\r\\n            _metaSpace.access_token_address != address(0) &&\\r\\n            _metaSpace.submit_fee != 0\\r\\n        ) {\\r\\n            require(\\r\\n                IERC20MetaSpace(_metaSpace.access_token_address).balanceOf(\\r\\n                    msg.sender\\r\\n                ) >= _metaSpace.submit_fee,\\r\\n                \\\"Not enough tokens for submit your nft\\\"\\r\\n            );\\r\\n        }\\r\\n        require(\\r\\n            !_submited_tokens[space_uid][token_address_][token_id_],\\r\\n            \\\"Token is submited to this Space\\\"\\r\\n        );\\r\\n        if (contract_type_ == ContractType.single_token) {\\r\\n            IERC721MetaSpace token = IERC721MetaSpace(token_address_);\\r\\n            require(\\r\\n                token.ownerOf(token_id_) == msg.sender,\\r\\n                \\\"You are not an owner of this token\\\"\\r\\n            );\\r\\n            require(\\r\\n                token.getApproved(token_id_) == address(this),\\r\\n                \\\"Not approved to this Space\\\"\\r\\n            );\\r\\n        } else {\\r\\n            IERC1155MetaSpace token = IERC1155MetaSpace(token_address_);\\r\\n            require(\\r\\n                token.balanceOf(msg.sender, token_id_) >= amount_,\\r\\n                \\\"Not enough tokens in your wallet\\\"\\r\\n            );\\r\\n            require(\\r\\n                token.isApprovedForAll(msg.sender, address(this)),\\r\\n                \\\"Not approved to this Space\\\"\\r\\n            );\\r\\n        }\\r\\n        uint256 newTokenIdGlobal = tokenId;\\r\\n        uint256 newTokenIdLocal = _tokens[space_uid].length;\\r\\n        _global_to_local_token_uids[newTokenIdGlobal] = newTokenIdLocal;\\r\\n        _submited_tokens[space_uid][token_address_][token_id_] = true;\\r\\n        _tokens_metaspace_uid[newTokenIdGlobal] = space_uid;\\r\\n        tokenId++;\\r\\n        _tokens[space_uid].push(\\r\\n            Token(\\r\\n                newTokenIdGlobal,\\r\\n                space_uid,\\r\\n                token_address_,\\r\\n                token_id_,\\r\\n                amount_,\\r\\n                contract_type_,\\r\\n                price_,\\r\\n                false,\\r\\n                false,\\r\\n                false,\\r\\n                msg.sender\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function approvedToken(uint256 uid) external {\\r\\n        uint256 _space_uid = _tokens_metaspace_uid[uid];\\r\\n        uint256 _uid_local = _global_to_local_token_uids[uid];\\r\\n        require(\\r\\n            !_curator_approved_tokens[_space_uid][_uid_local],\\r\\n            \\\"Already approved by curator\\\"\\r\\n        );\\r\\n        require(\\r\\n            _is_curator_address[_space_uid][msg.sender],\\r\\n            \\\"You are not curator\\\"\\r\\n        );\\r\\n        _curator_approved_tokens[_space_uid][_uid_local] = true;\\r\\n        _tokens[_space_uid][_uid_local].approved = true;\\r\\n    }\\r\\n\\r\\n    function buy(uint256 uid) external payable nonReentrant {\\r\\n        uint256 _space_uid = _tokens_metaspace_uid[uid];\\r\\n        uint256 _uid_local = _global_to_local_token_uids[uid];\\r\\n        require(_uid_local <= _tokens[_space_uid].length, \\\"Order does not exist\\\");\\r\\n        Token memory order = _tokens[_space_uid][_uid_local];\\r\\n        require(\\r\\n            _curator_approved_tokens[_space_uid][_uid_local] && order.approved,\\r\\n            \\\"Not curator approved\\\"\\r\\n        );\\r\\n        address _access_token_address = _metaSpaces[_space_uid]\\r\\n            .access_token_address;\\r\\n        uint256 _access_fee = _metaSpaces[_space_uid].access_fee;\\r\\n        address _metaspace_owner = _metaSpaces[_space_uid].owner_of;\\r\\n        uint256 _metaspace_owner_fee = _metaSpaces[_space_uid].owner_fee;\\r\\n        if (_access_token_address != address(0) && _access_fee != 0) {\\r\\n            require(\\r\\n                IERC20MetaSpace(_access_token_address).balanceOf(msg.sender) >=\\r\\n                    _access_fee,\\r\\n                \\\"Permission denied\\\"\\r\\n            );\\r\\n        }\\r\\n        require(msg.value >= order.price, \\\"Not enough ETH sent\\\");\\r\\n        require(!order.is_sold, \\\"Already resolved\\\");\\r\\n        if (order.contract_type == ContractType.single_token) {\\r\\n            IERC721MetaSpace token = IERC721MetaSpace(order.token_address);\\r\\n            require(\\r\\n                token.ownerOf(order.token_id) == order.owner_of,\\r\\n                \\\"Not an owner of this token\\\"\\r\\n            );\\r\\n            require(\\r\\n                token.getApproved(order.token_id) == address(this),\\r\\n                \\\"Not approved to this Space\\\"\\r\\n            );\\r\\n            token.safeTransferFrom(\\r\\n                order.owner_of,\\r\\n                msg.sender,\\r\\n                order.token_id,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        } else {\\r\\n            IERC1155MetaSpace token = IERC1155MetaSpace(order.token_address);\\r\\n            require(\\r\\n                token.balanceOf(order.owner_of, order.token_id) >= order.amount,\\r\\n                \\\"Not enough tokens in wallet\\\"\\r\\n            );\\r\\n            require(\\r\\n                token.isApprovedForAll(_metaspace_owner, address(this)),\\r\\n                \\\"Not approved to this Space\\\"\\r\\n            );\\r\\n            token.safeTransferFrom(\\r\\n                order.owner_of,\\r\\n                msg.sender,\\r\\n                order.token_id,\\r\\n                order.amount,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 summ = 0;\\r\\n        payable(_platform_address).transfer((msg.value * 25) / 1000);\\r\\n        summ += (msg.value * 25) / 1000;\\r\\n        payable(_metaspace_owner).send(\\r\\n            (msg.value * _metaspace_owner_fee) / 100\\r\\n        );\\r\\n        summ += (msg.value * _metaspace_owner_fee) / 100;\\r\\n        for (uint256 i = 0; i < _partners[_space_uid].length; i++) {\\r\\n            payable(_partners[_space_uid][i].eth_address).send(\\r\\n                (msg.value * _partners[_space_uid][i].percentage) / 100\\r\\n            );\\r\\n            summ += (msg.value * _partners[_space_uid][i].percentage) / 100;\\r\\n        }\\r\\n        for (uint256 i = 0; i < _curators[_space_uid].length; i++) {\\r\\n            payable(_curators[_space_uid][i].eth_address).send(\\r\\n                (msg.value * _curators[_space_uid][i].percentage) / 100\\r\\n            );\\r\\n            summ += (msg.value * _curators[_space_uid][i].percentage) / 100;\\r\\n        }\\r\\n        payable(order.owner_of).send(msg.value - summ);\\r\\n        _submited_tokens[_space_uid][order.token_address][\\r\\n            order.token_id\\r\\n        ] = false;\\r\\n        _tokens[_space_uid][_uid_local].is_sold = true;\\r\\n    }\\r\\n\\r\\n    function setMetaspaceToken(address token) external {\\r\\n        require(msg.sender == _owner_of, \\\"Only for owner\\\");\\r\\n        _metaspace_token_address = token;\\r\\n    }\\r\\n\\r\\n    function updateOwner(uint256 uid, address new_owner) external {\\r\\n        require(msg.sender == _metaspace_token_address, \\\"Only for platform\\\");\\r\\n        _metaSpaces[uid].owner_of = new_owner;\\r\\n    }\\r\\n\\r\\n    function getSpace(\\r\\n        uint256 uid\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            address owner_of,\\r\\n            string memory uri,\\r\\n            uint256 access_fee,\\r\\n            uint256 submition_fee,\\r\\n            uint256 owner_fee,\\r\\n            address access_token_address,\\r\\n            Partner[] memory partners,\\r\\n            Curator[] memory curators,\\r\\n            Token[] memory tokens\\r\\n        )\\r\\n    {\\r\\n        MetaSpace memory _metaSpace = _metaSpaces[uid];\\r\\n        Partner[] memory partners = _partners[uid];\\r\\n        Curator[] memory curators = _curators[uid];\\r\\n        Token[] memory tokens = _tokens[uid];\\r\\n        {\\r\\n            if (\\r\\n                msg.sender != _metaSpace.owner_of &&\\r\\n                !_is_partner_address[uid][msg.sender] &&\\r\\n                !_is_curator_address[uid][msg.sender] &&\\r\\n                _metaSpace.access_token_address != address(0) &&\\r\\n                _metaSpace.access_fee != 0\\r\\n            ) {\\r\\n                require(\\r\\n                    IERC20MetaSpace(_metaSpace.access_token_address).balanceOf(\\r\\n                        msg.sender\\r\\n                    ) >= _metaSpace.access_fee,\\r\\n                    \\\"Permission denied\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n        return (\\r\\n            _metaSpace.owner_of,\\r\\n            _metaSpace.uri,\\r\\n            _metaSpace.access_fee,\\r\\n            _metaSpace.submit_fee,\\r\\n            _metaSpace.owner_fee,\\r\\n            _metaSpace.access_token_address,\\r\\n            partners,\\r\\n            curators,\\r\\n            tokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getSpaceSecure(\\r\\n        uint256 uid\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            address owner_of,\\r\\n            string memory uri,\\r\\n            uint256 access_fee,\\r\\n            uint256 submition_fee,\\r\\n            address access_token_address\\r\\n        )\\r\\n    {\\r\\n        MetaSpace memory _metaSpace = _metaSpaces[uid];\\r\\n        return (\\r\\n            _metaSpace.owner_of,\\r\\n            _metaSpace.uri,\\r\\n            _metaSpace.access_fee,\\r\\n            _metaSpace.submit_fee,\\r\\n            _metaSpace.access_token_address\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Platform/Meta/IMetaSpace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IMetaSpace {\\r\\n    struct Metadata {\\r\\n        string title;\\r\\n        string short_description;\\r\\n        string description;\\r\\n        string scene_uri;\\r\\n    }\\r\\n\\r\\n    struct Access {\\r\\n        address token_address;\\r\\n        uint256 access_fee;\\r\\n        uint256 submit_fee;\\r\\n    }\\r\\n\\r\\n    struct Partner {\\r\\n        address eth_address;\\r\\n        uint256 percentage;\\r\\n    }\\r\\n\\r\\n    struct Curator {\\r\\n        address eth_address;\\r\\n        uint256 percentage;\\r\\n    }\\r\\n\\r\\n    struct OwnerMeta {\\r\\n        address owner_of_;\\r\\n        uint256 owner_fee_;\\r\\n    }\\r\\n\\r\\n    struct Token {\\r\\n        uint256 uid;\\r\\n        uint256 space_uid;\\r\\n        address token_address;\\r\\n        uint256 token_id;\\r\\n        uint256 amount;\\r\\n        ContractType contract_type;\\r\\n        uint256 price;\\r\\n        bool is_sold;\\r\\n        bool approved;\\r\\n        bool canceled;\\r\\n        address owner_of;\\r\\n    }\\r\\n\\r\\n    struct MetaSpace {\\r\\n        uint256 uid;\\r\\n        address owner_of;\\r\\n        uint256 owner_fee;\\r\\n        string uri;\\r\\n        uint256 submit_fee;\\r\\n        uint256 access_fee;\\r\\n        address access_token_address;\\r\\n    }\\r\\n\\r\\n    enum ContractType {\\r\\n        single_token,\\r\\n        multiple_token\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20MetaSpace {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IERC721MetaSpace {\\r\\n    function mint(address to, uint256 tokenId) external;\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n}\\r\\n\\r\\ninterface IERC1155MetaSpace {\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @author MetaPlayerOne DAO\\r\\n * @title Pausable\\r\\n */\\r\\ncontract Pausable {\\r\\n    address internal _owner_of;\\r\\n    bool internal _paused = false;\\r\\n\\r\\n    /**\\r\\n     * @dev setup owner of this contract with paused off state.\\r\\n     */\\r\\n    constructor(address owner_of_) {\\r\\n        _owner_of = owner_of_;\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier which can be used on child contract for checking if contract services are paused.\\r\\n     */\\r\\n    modifier notPaused() {\\r\\n        require(!_paused, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup paused variable.\\r\\n     * @param paused_ new boolean value of paused condition.\\r\\n     */\\r\\n    function setPaused(bool paused_) external {\\r\\n        require(_paused == paused_, \\\"Param has been asigned already\\\");\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _paused = paused_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup owner variable.\\r\\n     * @param owner_of_ new owner of contract.\\r\\n     */\\r\\n    function setOwner(address owner_of_) external {\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _owner_of = owner_of_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function returns owner of contract.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner_of;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform_address_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_metaSpaces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"owner_fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"submit_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"access_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"access_token_address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"approvedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"createSpace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"getSpace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_of\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"access_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submition_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owner_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"access_token_address\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eth_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMetaSpace.Partner[]\",\"name\":\"partners\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eth_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IMetaSpace.Curator[]\",\"name\":\"curators\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"space_uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum IMetaSpace.ContractType\",\"name\":\"contract_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner_of\",\"type\":\"address\"}],\"internalType\":\"struct IMetaSpace.Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"getSpaceSecure\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_of\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"access_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submition_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"access_token_address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setMetaspaceToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"space_uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_address_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"enum IMetaSpace.ContractType\",\"name\":\"contract_type_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"submitToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"access_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submit_fee\",\"type\":\"uint256\"}],\"internalType\":\"struct IMetaSpace.Access\",\"name\":\"access_\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"partners_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"partners_fees_\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"owner_fee_\",\"type\":\"uint256\"}],\"internalType\":\"struct IMetaSpace.OwnerMeta\",\"name\":\"owner_meta_\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"curators_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"curator_fees_\",\"type\":\"uint256[]\"}],\"name\":\"updateTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetaSpaceController", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ce56eaa1bd07c33e9096ac808db56a852ac185b8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}