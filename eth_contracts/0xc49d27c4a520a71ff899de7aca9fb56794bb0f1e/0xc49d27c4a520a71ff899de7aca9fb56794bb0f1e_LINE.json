{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/LINE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\n/// @title LINE by Figure31\\r\\n/// @notice LINE is a photographic series of 250 tokens placed within a synthetic landscape. \\r\\n/// Using photographic and post-production techniques similar to Figure31's SALT, the images in \\r\\n/// LINE are captured using a digital camera combined with ultra-telephoto lenses. All photographs \\r\\n/// are taken in remote empty landscapes at sundown or night. There is no artificial light, only \\r\\n/// indirect natural light hitting the camera sensor. Photographs are arranged as panoramas \\r\\n/// to recreate a unified landscape.\\r\\n///\\r\\n/// @author wilt.eth\\r\\nimport {Constants} from \\\"./Constants.sol\\\";\\r\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\nimport {Descriptor} from \\\"./Descriptor.sol\\\";\\r\\nimport {ITokenDescriptor} from \\\"./ITokenDescriptor.sol\\\";\\r\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\r\\n\\r\\n/// @dev Thrown when attempting to change a token to a star, which is already a star.\\r\\nerror AlreadyStarToken();\\r\\n\\r\\n/// @dev Thrown when too many tokens are attempted to be minted within a single transaction.\\r\\nerror ExceedsMaxMintPerTransaction();\\r\\n\\r\\n/// @dev Thrown when a token has not yet reached the end of the grid.\\r\\nerror HasNotReachedEnd();\\r\\n\\r\\n/// @dev Thrown when the eth passed to purchase a token is incorrect.\\r\\nerror IncorrectPrice();\\r\\n\\r\\n/// @dev Thrown when attempting to move in a direction opposite of the token's designated direction.\\r\\nerror InvalidDirection();\\r\\n\\r\\n/// @dev Thrown when the max number of star tokens has already occurred.\\r\\nerror MaxStarTokensReached();\\r\\n\\r\\n/// @dev Thrown when attempting to mint a token after minting has closed.\\r\\nerror MintingClosed();\\r\\n\\r\\n/// @dev Thrown when attempting to move a token, and the ability to move tokens has not started yet or is a star token.\\r\\nerror MovementLocked();\\r\\n\\r\\n/// @dev Thrown when checking the owner or approved address for a non-existent NFT.\\r\\nerror NotMinted();\\r\\n\\r\\n/// @dev Thrown when checking that the caller is not the owner of the NFT.\\r\\nerror NotTokenOwner();\\r\\n\\r\\n/// @dev Thrown when attempting to move a token to a place on the grid that is already taken.\\r\\nerror PositionCurrentlyTaken(uint256 x, uint256 y);\\r\\n\\r\\n/// @dev Thrown when attempting to mint a token to a place on the grid that was not marked to be minted from.\\r\\nerror PositionNotMintable(uint256 x, uint256 y);\\r\\n\\r\\n/// @dev Thrown when attempting to move a token to a place that is outside the bounds of the grid.\\r\\nerror PositionOutOfBounds(uint256 x, uint256 y);\\r\\n\\r\\ncontract LINE is ERC721, Ownable2Step, ReentrancyGuard, Constants {\\r\\n\\r\\n    using SafeTransferLib for address payable;\\r\\n\\r\\n    /// @dev Struct containing the details of the Dutch auction\\r\\n    struct SalesConfig {\\r\\n        // start time of the auction\\r\\n        uint64 startTime;\\r\\n\\r\\n        // end time of the auction\\r\\n        uint64 endTime;\\r\\n        \\r\\n        // initial price of the Dutch auction\\r\\n        uint256 startPriceInWei;\\r\\n\\r\\n        // resting price of the Dutch auction\\r\\n        uint256 endPriceInWei;\\r\\n\\r\\n        // recepient of the funds from the Dutch auction\\r\\n        address payable fundsRecipient;\\r\\n    }\\r\\n\\r\\n    /// @dev The maximum allowed number of star tokens.\\r\\n    uint256 public constant MAX_STAR_TOKENS = 25;\\r\\n\\r\\n    /// @dev The maximum allowed number of tokens to be minted within a single transaction.\\r\\n    uint256 public constant MAX_MINT_PER_TX = 5;\\r\\n    \\r\\n    /// @dev The maximum number of tokens to be minted.\\r\\n    uint256 public constant MAX_SUPPLY = 250;\\r\\n    uint256 internal immutable FUNDS_SEND_GAS_LIMIT = 210_000;\\r\\n\\r\\n    /// @dev The merkle root for collectors/holders.\\r\\n    bytes32 public holdersMerkleRoot;\\r\\n\\r\\n    /// @dev The merkle root for members of FingerprintsDAO.\\r\\n    bytes32 public fpMembersMerkleRoot;\\r\\n\\r\\n    /// @dev Keeps track of the current token id.\\r\\n    uint256 public currentTokenId = 1;\\r\\n    \\r\\n    /// @dev Keeps track of the number of tokens that have become star tokens.\\r\\n    uint256 public numStarTokens;\\r\\n    \\r\\n    /// @dev The flag to determine if tokens have the ability to move.\\r\\n    bool public canMove;\\r\\n    bool private _isMintingClosed;\\r\\n    uint256 private  _totalSupply;\\r\\n\\r\\n    ITokenDescriptor public descriptor;\\r\\n    SalesConfig public config;\\r\\n\\r\\n    uint256[NUM_COLUMNS][NUM_ROWS] internal _grid;\\r\\n    ITokenDescriptor.Coordinate[] internal _availableCoordinates;\\r\\n    mapping(bytes32 => uint256) internal _coordinateHashToIndex;\\r\\n    mapping(bytes32 => bool) internal _mintableCoordinates;\\r\\n    mapping(uint256 => ITokenDescriptor.Token) public tokenIdToTokenInfo;\\r\\n\\r\\n    constructor(address _descriptor) ERC721(\\\"LINE\\\", \\\"LINE\\\") Ownable(msg.sender) {\\r\\n        descriptor = ITokenDescriptor(_descriptor);\\r\\n        config.startTime = uint64(1708538400);\\r\\n        config.endTime = uint64(1708538400 + 3600);\\r\\n        config.startPriceInWei = 1000000000000000000; // 1 eth\\r\\n        config.endPriceInWei = 150000000000000000; // .15 eth\\r\\n        config.fundsRecipient = payable(0x943ccdd95803e35369Ccf42e9618f992fD2Fea2E);\\r\\n    }\\r\\n    \\r\\n    /// @dev Mints a token at a random position on the grid.\\r\\n    function mintRandom(uint256 quantity, bytes32[] calldata merkleProof) external payable nonReentrant {\\r\\n        if (block.timestamp < config.startTime || _isMintingClosed) {\\r\\n            revert MintingClosed();\\r\\n        }\\r\\n\\r\\n        if (quantity > MAX_MINT_PER_TX) {\\r\\n            revert ExceedsMaxMintPerTransaction();\\r\\n        }\\r\\n        \\r\\n        uint256 currentPrice = getCurrentPrice();\\r\\n        if (merkleProof.length > 0) {\\r\\n            currentPrice = _getDiscountedCurrentPrice(merkleProof, msg.sender, currentPrice);\\r\\n        }\\r\\n\\r\\n        uint256 totalPrice = currentPrice * quantity;\\r\\n        if (msg.value < totalPrice) {\\r\\n            revert IncorrectPrice();\\r\\n        }\\r\\n\\r\\n        uint256 ethToReturn;\\r\\n        for (uint256 i=0; i < quantity;) {\\r\\n            bool success;\\r\\n            if (_availableCoordinates.length == 0) {\\r\\n                success = false;\\r\\n            } else {\\r\\n                ITokenDescriptor.Coordinate memory coordinateToMint = _availableCoordinates[0];\\r\\n                success = _mintWithChecks(coordinateToMint, msg.sender);\\r\\n            }\\r\\n\\r\\n            if (!success) {\\r\\n                ethToReturn += currentPrice;\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // return eth for any pieces that failed to mint because a point on the board was already taken when the mint occurred\\r\\n        if (ethToReturn > 0) {\\r\\n            payable(msg.sender).safeTransferETH(ethToReturn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Mints a token at the specified on the grid.\\r\\n    function mintAtPosition(ITokenDescriptor.Coordinate[] memory coordinates, bytes32[] calldata merkleProof) external payable nonReentrant {\\r\\n        if (block.timestamp < config.startTime || _isMintingClosed) {\\r\\n            revert MintingClosed();\\r\\n        }\\r\\n\\r\\n        uint256 numCoordinates = coordinates.length;\\r\\n        if (numCoordinates > MAX_MINT_PER_TX) {\\r\\n            revert ExceedsMaxMintPerTransaction();\\r\\n        }\\r\\n        \\r\\n        uint256 currentPrice = getCurrentPrice();\\r\\n        if (merkleProof.length > 0) {\\r\\n            currentPrice = _getDiscountedCurrentPrice(merkleProof, msg.sender, currentPrice);\\r\\n        }\\r\\n\\r\\n        if (msg.value < (currentPrice * numCoordinates)) {\\r\\n            revert IncorrectPrice();\\r\\n        }\\r\\n\\r\\n        uint256 ethToReturn;\\r\\n        for (uint256 i=0; i < numCoordinates;) {\\r\\n            bool success = _mintWithChecks(coordinates[i], msg.sender);\\r\\n            if (!success) {\\r\\n                ethToReturn += currentPrice;\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // return eth for any pieces that failed to mint because a point on the board was already taken when the mint occurred\\r\\n        if (ethToReturn > 0) {\\r\\n            payable(msg.sender).safeTransferETH(ethToReturn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function artistMint(address receiver, ITokenDescriptor.Coordinate[] memory coordinates) external onlyOwner {\\r\\n        if (_isMintingClosed) {\\r\\n            revert MintingClosed();\\r\\n        }\\r\\n\\r\\n        uint256 numCoordinates = coordinates.length;\\r\\n        for (uint256 i=0; i < numCoordinates;) {\\r\\n            _mintWithChecks(coordinates[i], receiver);\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Ends the ability to mint.\\r\\n    function closeMint() external onlyOwner {\\r\\n        _closeMint();\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the north on the cartesian grid.\\r\\n    function moveNorth(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.UP) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, 0, -1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the northwest on the cartesian grid.\\r\\n    function moveNorthwest(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.UP) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, -1, -1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the northeast on the cartesian grid.\\r\\n    function moveNortheast(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.UP) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, 1, -1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the south on the cartesian grid.\\r\\n    function moveSouth(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.DOWN) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, 0, 1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the southwest on the cartesian grid.\\r\\n    function moveSouthwest(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.DOWN) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, -1, 1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the southeast on the cartesian grid.\\r\\n    function moveSoutheast(uint256 tokenId) external {\\r\\n        if (tokenIdToTokenInfo[tokenId].direction != ITokenDescriptor.Direction.DOWN) {\\r\\n            revert InvalidDirection();\\r\\n        }\\r\\n\\r\\n        _move(tokenId, 1, 1);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the west on the cartesian grid.\\r\\n    function moveWest(uint256 tokenId) external {\\r\\n        _move(tokenId, -1, 0);\\r\\n    }\\r\\n\\r\\n    /// @dev Moves a token one spot to the east on the cartesian grid.\\r\\n    function moveEast(uint256 tokenId) external {\\r\\n        _move(tokenId, 1, 0);\\r\\n    }\\r\\n\\r\\n    /// @dev Converts a token to be a star token and locks their token at the given position.\\r\\n    function lockAsStar(uint256 tokenId, uint256 x, uint256 y) external {\\r\\n        if (msg.sender != ownerOf(tokenId)) {\\r\\n            revert NotTokenOwner();\\r\\n        }\\r\\n\\r\\n        ITokenDescriptor.Token memory token = tokenIdToTokenInfo[tokenId];\\r\\n        if (!_isPositionWithinBounds(x, y, token.direction)) {\\r\\n            revert PositionOutOfBounds(x,y);\\r\\n        }\\r\\n\\r\\n        uint256 yGridIndex = _calculateYGridIndex(y);\\r\\n        if (_grid[yGridIndex][x] > 0) {\\r\\n            revert PositionCurrentlyTaken(x,y);\\r\\n        }\\r\\n\\r\\n        if (numStarTokens == MAX_STAR_TOKENS) {\\r\\n            revert MaxStarTokensReached();\\r\\n        }\\r\\n\\r\\n        if (!token.hasReachedEnd) {\\r\\n            revert HasNotReachedEnd();\\r\\n        }\\r\\n        \\r\\n        if (token.isStar) {\\r\\n            revert AlreadyStarToken();\\r\\n        }\\r\\n\\r\\n        _grid[_calculateYGridIndex(token.current.y)][token.current.x] = 0;\\r\\n        _grid[yGridIndex][x] = tokenId;\\r\\n\\r\\n        tokenIdToTokenInfo[tokenId].current = ITokenDescriptor.Coordinate({x: x, y: y});\\r\\n        tokenIdToTokenInfo[tokenId].timestamp = block.timestamp;\\r\\n        tokenIdToTokenInfo[tokenId].isStar = true;\\r\\n        numStarTokens++;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the coordinates that are available to minted.\\r\\n    function setInitialAvailableCoordinates(ITokenDescriptor.Coordinate[] calldata coordinates) external onlyOwner {\\r\\n        uint256 currentNumTokens = _availableCoordinates.length;\\r\\n        for (uint256 i = 0; i < coordinates.length;) {\\r\\n            bytes32 hash = _getCoordinateHash(coordinates[i]);\\r\\n            _mintableCoordinates[hash] = true;\\r\\n            _coordinateHashToIndex[hash] = currentNumTokens + i;\\r\\n            _availableCoordinates.push(coordinates[i]);\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Updates the details of the Dutch auction.\\r\\n    function updateConfig(\\r\\n        uint64 startTime,\\r\\n        uint64 endTime,\\r\\n        uint256 startPriceInWei,\\r\\n        uint256 endPriceInWei,\\r\\n        address payable fundsRecipient\\r\\n    ) external onlyOwner {\\r\\n        config.startTime = startTime;\\r\\n        config.endTime = endTime;\\r\\n        config.startPriceInWei = startPriceInWei;\\r\\n        config.endPriceInWei = endPriceInWei;\\r\\n        config.fundsRecipient = fundsRecipient;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the address of the descriptor.\\r\\n    function setDescriptor(address _descriptor) external onlyOwner {\\r\\n        descriptor = ITokenDescriptor(_descriptor);\\r\\n    }\\r\\n\\r\\n    /// @dev Updates the merkle roots\\r\\n    function updateMerkleRoots(bytes32 _holdersRoot, bytes32 _fpMembersRoot) external onlyOwner {\\r\\n        holdersMerkleRoot = _holdersRoot;\\r\\n        fpMembersMerkleRoot = _fpMembersRoot;\\r\\n    }\\r\\n\\r\\n    /// @dev Withdraws the eth from the contract to the set funds receipient.\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint256 balance = address(this).balance;\\r\\n        (bool success, ) = config.fundsRecipient.call{\\r\\n            value: balance,\\r\\n            gas: FUNDS_SEND_GAS_LIMIT\\r\\n        }(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the available coordinates that are still available for mint.\\r\\n    function getAvailableCoordinates() external view returns (ITokenDescriptor.Coordinate[] memory) {\\r\\n        return _availableCoordinates;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the cartesian grid of where tokens are placed at within the grid.\\r\\n    function getGrid() external view returns (uint256[NUM_COLUMNS][NUM_ROWS] memory) {\\r\\n        return _grid;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the details of a token.\\r\\n    function getToken(uint256 tokenId) external view returns (ITokenDescriptor.Token memory) {\\r\\n        return tokenIdToTokenInfo[tokenId];\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the details of all tokens.\\r\\n    function getTokens() external view returns (ITokenDescriptor.Token[] memory) {\\r\\n        ITokenDescriptor.Token[] memory tokens = new ITokenDescriptor.Token[](_totalSupply);\\r\\n\\r\\n        for(uint256 i=0;i < _totalSupply;) {\\r\\n            tokens[i] = tokenIdToTokenInfo[i+1];\\r\\n\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return tokens;\\r\\n    }\\r\\n    \\r\\n    /// @dev Returns if a wallet address/proof is part of the given merkle root.\\r\\n    function checkMerkleProof(\\r\\n        bytes32[] calldata merkleProof,\\r\\n        address _address,\\r\\n        bytes32 _root\\r\\n    ) public pure returns (bool) {\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(_address));\\r\\n        return MerkleProof.verify(merkleProof, _root, leaf);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the current price of the Dutch auction.\\r\\n    function getCurrentPrice() public view returns (uint256) {      \\r\\n        uint256 duration = config.endTime - config.startTime;\\r\\n        uint256 halflife = 950; // adjust this to adjust speed of decay\\r\\n\\r\\n        if (block.timestamp < config.startTime) {\\r\\n            return config.startPriceInWei;\\r\\n        }\\r\\n\\r\\n        uint256 elapsedTime = ((block.timestamp - config.startTime) / 10 ) * 10;  \\r\\n        if (elapsedTime >= duration) {\\r\\n            return config.endPriceInWei;\\r\\n        }\\r\\n\\r\\n        // h/t artblocks for exponential decaying price math\\r\\n        uint256 decayedPrice = config.startPriceInWei;\\r\\n        // Divide by two (via bit-shifting) for the number of entirely completed\\r\\n        // half-lives that have elapsed since auction start time.\\r\\n        decayedPrice >>= elapsedTime / halflife;\\r\\n        // Perform a linear interpolation between partial half-life points, to\\r\\n        // approximate the current place on a perfect exponential decay curve.\\r\\n        decayedPrice -= (decayedPrice * (elapsedTime % halflife)) / halflife / 2;\\r\\n        if (decayedPrice < config.endPriceInWei) {\\r\\n            // Price may not decay below stay `basePrice`.\\r\\n            return config.endPriceInWei;\\r\\n        }\\r\\n        \\r\\n        return (decayedPrice / 1000000000000000) * 1000000000000000;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the token ids that a wallet has ownership of.\\r\\n    function tokensOfOwner(address _owner) public view returns (uint256[] memory) {\\r\\n        uint256 balance = balanceOf(_owner);\\r\\n        uint256[] memory tokens = new uint256[](balance);\\r\\n        uint256 index;\\r\\n        unchecked {\\r\\n            for (uint256 i=1; i <= _totalSupply; i++) {\\r\\n                if (ownerOf(i) == _owner) {\\r\\n                    tokens[index] = i;\\r\\n                    index++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return tokens;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the tokenURI of the given token id.\\r\\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\\r\\n        if (ownerOf(id) == address(0)) {\\r\\n            revert NotMinted();\\r\\n        }\\r\\n\\r\\n        ITokenDescriptor.Token memory token = tokenIdToTokenInfo[id];\\r\\n        return descriptor.generateMetadata(id, token);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total supply.\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function _mintWithChecks(ITokenDescriptor.Coordinate memory coordinate, address receiver) internal returns (bool) {        \\r\\n        uint256 tokenId = currentTokenId;\\r\\n        uint256 x = coordinate.x;\\r\\n        uint256 y = coordinate.y;\\r\\n        uint256 yIndex = _calculateYGridIndex(y); \\r\\n\\r\\n        if (_grid[yIndex][x] > 0) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        bytes32 hash = _getCoordinateHash(ITokenDescriptor.Coordinate({x: x, y: y}));\\r\\n        if (!_mintableCoordinates[hash]) {\\r\\n            revert PositionNotMintable(x, y);\\r\\n        }\\r\\n\\r\\n        _grid[yIndex][x] = tokenId;\\r\\n        tokenIdToTokenInfo[tokenId] = ITokenDescriptor.Token({\\r\\n            initial: ITokenDescriptor.Coordinate({x: x, y: y}),\\r\\n            current: ITokenDescriptor.Coordinate({x: x, y: y}),\\r\\n            timestamp: block.timestamp,\\r\\n            hasReachedEnd: false,\\r\\n            isStar: false,\\r\\n            direction: y >= 12 ? ITokenDescriptor.Direction.DOWN : ITokenDescriptor.Direction.UP,\\r\\n            numMovements: 0\\r\\n        });\\r\\n\\r\\n        if (tokenId != MAX_SUPPLY) {\\r\\n            currentTokenId++;\\r\\n        } else {\\r\\n            _closeMint();\\r\\n        }\\r\\n        \\r\\n        _totalSupply++;\\r\\n        _removeFromAvailability(_coordinateHashToIndex[hash]);\\r\\n        _mint(receiver, tokenId);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _move(uint256 tokenId, int256 xDelta, int256 yDelta) private {\\r\\n        if (msg.sender != ownerOf(tokenId)) {\\r\\n            revert NotTokenOwner();\\r\\n        }\\r\\n\\r\\n        if (!canMove) {\\r\\n            revert MovementLocked();\\r\\n        }\\r\\n\\r\\n        ITokenDescriptor.Token memory token = tokenIdToTokenInfo[tokenId];\\r\\n        if (token.isStar) {\\r\\n            revert MovementLocked();\\r\\n        }\\r\\n\\r\\n        uint256 x = token.current.x;\\r\\n        if (xDelta == -1) {\\r\\n            x--;\\r\\n        } else if (xDelta == 1) {\\r\\n            x++;\\r\\n        }\\r\\n\\r\\n        uint256 y = token.current.y;\\r\\n        if (yDelta == -1) {\\r\\n            y++;\\r\\n        } else if (yDelta == 1) {\\r\\n            y--;\\r\\n        }\\r\\n\\r\\n        if (!_isPositionWithinBounds(x, y, token.direction)) {\\r\\n            revert PositionOutOfBounds(x,y);\\r\\n        }\\r\\n\\r\\n        uint256 yGridIndex = _calculateYGridIndex(y);\\r\\n        if (_grid[yGridIndex][x] > 0) {\\r\\n            revert PositionCurrentlyTaken(x,y);\\r\\n        }\\r\\n\\r\\n        _grid[_calculateYGridIndex(token.current.y)][token.current.x] = 0;\\r\\n        _grid[yGridIndex][x] = tokenId;\\r\\n\\r\\n        tokenIdToTokenInfo[tokenId].current = ITokenDescriptor.Coordinate({x: x, y: y});\\r\\n        tokenIdToTokenInfo[tokenId].hasReachedEnd = ((token.direction == ITokenDescriptor.Direction.UP && y == (NUM_ROWS - 2)) || (token.direction == ITokenDescriptor.Direction.DOWN && y == 1));\\r\\n        tokenIdToTokenInfo[tokenId].numMovements = ++token.numMovements;\\r\\n        tokenIdToTokenInfo[tokenId].timestamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function _closeMint() private {\\r\\n        _isMintingClosed = true;\\r\\n        canMove = true;\\r\\n    }\\r\\n\\r\\n    function _calculateYGridIndex(uint256 y) private pure returns (uint256) {\\r\\n        return (NUM_ROWS - 1) - y;\\r\\n    }\\r\\n\\r\\n    function _getCoordinateHash(ITokenDescriptor.Coordinate memory coordinate) private pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(coordinate));\\r\\n    }\\r\\n\\r\\n    function _getDiscountedCurrentPrice(bytes32[] calldata merkleProof, address addressToCheck, uint256 currentPrice) private view returns (uint256) {\\r\\n        bool isFp = checkMerkleProof(merkleProof, addressToCheck, fpMembersMerkleRoot);\\r\\n        bool isPartner = checkMerkleProof(merkleProof, addressToCheck, holdersMerkleRoot);\\r\\n        \\r\\n        if (isFp) {\\r\\n            currentPrice = (currentPrice * 75) / 100; // 25% off\\r\\n        } else if (isPartner) {\\r\\n            currentPrice = (currentPrice * 85) / 100; // 15% off\\r\\n        }\\r\\n\\r\\n        return currentPrice;\\r\\n    }\\r\\n\\r\\n    function _isPositionWithinBounds(uint256 x, uint256 y, ITokenDescriptor.Direction tokenDirection) private pure returns (bool) {\\r\\n        if (x < 1 || x >= NUM_COLUMNS - 1) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if (tokenDirection == ITokenDescriptor.Direction.DOWN) {\\r\\n            return y > 0;\\r\\n        } else {\\r\\n            return y < NUM_ROWS - 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _removeFromAvailability(uint256 index) private {\\r\\n        uint256 lastCoordinateIndex = _availableCoordinates.length - 1;\\r\\n        ITokenDescriptor.Coordinate memory lastCoordinate = _availableCoordinates[lastCoordinateIndex];\\r\\n        ITokenDescriptor.Coordinate memory coordinateToBeRemoved = _availableCoordinates[index];\\r\\n\\r\\n        _availableCoordinates[index] = lastCoordinate;\\r\\n        _coordinateHashToIndex[_getCoordinateHash(lastCoordinate)] = index;\\r\\n        delete _coordinateHashToIndex[_getCoordinateHash(coordinateToBeRemoved)];\\r\\n        _availableCoordinates.pop();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\ncontract Constants {\\r\\n    uint256 public constant NUM_ROWS = 25;\\r\\n    uint256 public constant NUM_COLUMNS = 25;\\r\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Tree proofs.\\r\\n *\\r\\n * The tree and the proofs can be generated using our\\r\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\r\\n * You will find a quickstart guide in the readme.\\r\\n *\\r\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\r\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\r\\n * This is because the concatenation of a sorted pair of internal nodes in\\r\\n * the Merkle tree could be reinterpreted as a leaf value.\\r\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\r\\n * against this attack out of the box.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     *@dev The multiproof provided is not valid.\\r\\n     */\\r\\n    error MerkleProofInvalidMultiproof();\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProof(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {verify}\\r\\n     */\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProofCalldata(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\r\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\r\\n     * hash matches the root of the tree. When processing the proof, the pairs\\r\\n     * of leafs & pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processProof}\\r\\n     */\\r\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\r\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerify(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {multiProofVerify}\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function multiProofVerifyCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\r\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\r\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\r\\n     * respectively.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\r\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\r\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\r\\n     */\\r\\n    function processMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the Merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen != totalHashes + 1) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     */\\r\\n    function processMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the Merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        if (leavesLen + proofLen != totalHashes + 1) {\\r\\n            revert MerkleProofInvalidMultiproof();\\r\\n        }\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            if (proofPos != proofLen) {\\r\\n                revert MerkleProofInvalidMultiproof();\\r\\n            }\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sorts the pair (a, b) and hashes the result.\\r\\n     */\\r\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\r\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\r\\n     */\\r\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, a)\\r\\n            mstore(0x20, b)\\r\\n            value := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Descriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\nimport {Constants} from \\\"./Constants.sol\\\";\\r\\nimport {ITokenDescriptor} from \\\"./ITokenDescriptor.sol\\\";\\r\\nimport {JsonWriter} from \\\"solidity-json-writer/JsonWriter.sol\\\";\\r\\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\\r\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\n\\r\\ncontract Descriptor is ITokenDescriptor, Constants {\\r\\n    using JsonWriter for JsonWriter.Json;\\r\\n\\r\\n    function generateMetadata(uint256 tokenId, Token calldata token) \\r\\n        external \\r\\n        view \\r\\n        returns (string memory) \\r\\n    {\\r\\n        JsonWriter.Json memory writer;\\r\\n        writer = writer.writeStartObject();\\r\\n\\r\\n        writer = writer.writeStringProperty(\\r\\n            'name',\\r\\n            string.concat('LINE ', Strings.toString(tokenId))\\r\\n        );\\r\\n\\r\\n        writer = writer.writeStringProperty(\\r\\n            'description',\\r\\n            'LINE is a dynamic photographic series of 250 tokens, each positioned within a meticulously crafted landscape of 625 coordinates. Tokens act like lenses, where location influences perception. They may cross this terrain while their paths intersect in time and space. By Figure31'\\r\\n        );\\r\\n\\r\\n        writer = writer.writeStringProperty(\\r\\n            'external_url',\\r\\n            'https://line.fingerprintsdao.xyz'\\r\\n        );\\r\\n\\r\\n        uint256 currentImageIndex = _getCurrentPanoramicImageIndex(token);\\r\\n        writer = writer.writeStringProperty(\\r\\n            'image',\\r\\n            string.concat('ar://Y-05cY1jiKkVn9aCL3Di3sOWfCUZRPLaoASs0LYJOsU/', Strings.toString(currentImageIndex), '.jpg')\\r\\n        );\\r\\n\\r\\n        writer = _generateAttributes(writer, token);\\r\\n\\r\\n        writer = writer.writeEndObject();\\r\\n\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                'data:application/json;base64,',\\r\\n                Base64.encode(abi.encodePacked(writer.value))\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _determineCurrentImagePoint(Token calldata token)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        uint256 numDaysPassed = (block.timestamp - token.timestamp) / 1 days;\\r\\n        uint256 numPanoramicPoints;\\r\\n\\r\\n        if (!token.isStar) {\\r\\n            numPanoramicPoints = 10; // 180\u00b0 panoramic view\\r\\n        } else {\\r\\n            numPanoramicPoints = 16; // 360\u00b0 panoramic view\\r\\n        }\\r\\n\\r\\n        uint256 panoramicPoint = numDaysPassed % numPanoramicPoints;\\r\\n\\r\\n        // is at the origin point for the day\\r\\n        if (panoramicPoint % 2 == 0) {\\r\\n            return (token.current.x, token.current.y);            \\r\\n        }\\r\\n\\r\\n        uint256 x;\\r\\n        uint256 y;\\r\\n\\r\\n        // full panoramic view\\r\\n        // 1 = west\\r\\n        // 3 = northwest\\r\\n        // 5 = north\\r\\n        // 7 = northeast\\r\\n        // 9 = east\\r\\n        // 11 = southeast\\r\\n        // 13 = south\\r\\n        // 15 = southwest\\r\\n        if (token.isStar) {\\r\\n            if (panoramicPoint == 1) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y;\\r\\n            } else if (panoramicPoint == 3) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 5) {\\r\\n                x = token.current.x;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 7) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 9) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y;\\r\\n            } else if (panoramicPoint == 11) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y - 1;\\r\\n            } else if (panoramicPoint == 13) {\\r\\n                x = token.current.x;\\r\\n                y = token.current.y - 1;\\r\\n            } else if (panoramicPoint == 15) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y - 1;\\r\\n            }\\r\\n\\r\\n            return (x,y);\\r\\n        }\\r\\n\\r\\n        // 1 = look west\\r\\n        // 3 = look southwest\\r\\n        // 5 = look south\\r\\n        // 7 = look southeast\\r\\n        // 9 = look east\\r\\n        if (token.direction == Direction.DOWN) {\\r\\n            if (panoramicPoint == 1) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y;\\r\\n            } else if (panoramicPoint == 3) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y - 1;\\r\\n            } else if (panoramicPoint == 5) {\\r\\n                x = token.current.x;\\r\\n                y = token.current.y - 1;\\r\\n            } else if (panoramicPoint == 7) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y - 1;\\r\\n            } else if (panoramicPoint == 9) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // 1 = look west\\r\\n        // 3 = look northwest\\r\\n        // 5 = look north\\r\\n        // 7 = look northeast\\r\\n        // 9 = look east\\r\\n        if (token.direction == Direction.UP) {\\r\\n            if (panoramicPoint == 1) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y;\\r\\n            } else if (panoramicPoint == 3) {\\r\\n                x = token.current.x - 1;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 5) {\\r\\n                x = token.current.x;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 7) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y + 1;\\r\\n            } else if (panoramicPoint == 9) {\\r\\n                x = token.current.x + 1;\\r\\n                y = token.current.y;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (x,y);\\r\\n    }\\r\\n\\r\\n    function _getCurrentPanoramicImageIndex(Token calldata token) \\r\\n        private\\r\\n        view\\r\\n        returns (uint256) \\r\\n    {\\r\\n        (uint256 x, uint256 y) = _determineCurrentImagePoint(token);\\r\\n        return _calculateImageIndex(x, y);\\r\\n    }\\r\\n    \\r\\n    function _calculateImageIndex(uint256 x, uint256 y)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256) \\r\\n    {\\r\\n        uint256 yIndex = (NUM_ROWS - 1) - y;\\r\\n        return ((NUM_ROWS - yIndex - 1) * NUM_COLUMNS) + x;\\r\\n    }\\r\\n\\r\\n    function _generateAttributes(JsonWriter.Json memory _writer, Token calldata token) \\r\\n        private \\r\\n        view \\r\\n        returns (JsonWriter.Json memory writer)\\r\\n    {\\r\\n        writer = _writer.writeStartArray('attributes');\\r\\n\\r\\n        (uint256 imagePointX, uint256 imagePointY) = _determineCurrentImagePoint(token);\\r\\n        writer = _addStringAttribute(writer, 'Origin Point', string.concat(Strings.toString(token.current.x), ',', Strings.toString(token.current.y)));\\r\\n        writer = _addStringAttribute(writer, 'Image Point', string.concat(Strings.toString(imagePointX), ',', Strings.toString(imagePointY)));\\r\\n        writer = _addStringAttribute(writer, 'Type', token.direction == Direction.UP ? 'Up' : 'Down');\\r\\n        writer = _addStringAttribute(writer, 'Starting Point', string.concat(Strings.toString(token.initial.x), ',', Strings.toString(token.initial.y)));\\r\\n        writer = _addStringAttribute(writer, 'Has Reached End', token.hasReachedEnd == true ? 'Yes' : 'No');\\r\\n        writer = _addStringAttribute(writer, 'Is Star', token.isStar == true ? 'Yes' : 'No');\\r\\n        writer = _addStringAttribute(writer, 'Movements', Strings.toString(token.numMovements));\\r\\n\\r\\n        writer = writer.writeEndArray();\\r\\n    }\\r\\n\\r\\n    function _addStringAttribute(\\r\\n        JsonWriter.Json memory _writer,\\r\\n        string memory key,\\r\\n        string memory value\\r\\n    ) private pure returns (JsonWriter.Json memory writer) {\\r\\n        writer = _writer.writeStartObject();\\r\\n        writer = writer.writeStringProperty('trait_type', key);\\r\\n        writer = writer.writeStringProperty('value', value);\\r\\n        writer = writer.writeEndObject();\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/ITokenDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\ninterface ITokenDescriptor {\\r\\n    enum Direction {\\r\\n        UP,\\r\\n        DOWN\\r\\n    }\\r\\n\\r\\n    struct Coordinate {\\r\\n        uint256 x;\\r\\n        uint256 y;\\r\\n    }\\r\\n\\r\\n    struct Token {\\r\\n        Coordinate initial;\\r\\n        Coordinate current;\\r\\n        uint256 timestamp;\\r\\n        bool hasReachedEnd;\\r\\n        bool isStar;\\r\\n        Direction direction;\\r\\n        uint256 numMovements;\\r\\n    }\\r\\n\\r\\n    function generateMetadata(uint256 tokenId, ITokenDescriptor.Token calldata token)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n}\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\r\\nabstract contract ERC721 {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\r\\n\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                         METADATA STORAGE/LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                      ERC721 BALANCE/OWNER STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    mapping(uint256 => address) internal _ownerOf;\\r\\n\\r\\n    mapping(address => uint256) internal _balanceOf;\\r\\n\\r\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\r\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\r\\n    }\\r\\n\\r\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\r\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\r\\n\\r\\n        return _balanceOf[owner];\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                         ERC721 APPROVAL STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    mapping(uint256 => address) public getApproved;\\r\\n\\r\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(string memory _name, string memory _symbol) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC721 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address owner = _ownerOf[id];\\r\\n\\r\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\r\\n\\r\\n        getApproved[id] = spender;\\r\\n\\r\\n        emit Approval(owner, spender, id);\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        isApprovedForAll[msg.sender][operator] = approved;\\r\\n\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public virtual {\\r\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\r\\n\\r\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        require(\\r\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\r\\n            \\\"NOT_AUTHORIZED\\\"\\r\\n        );\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        unchecked {\\r\\n            _balanceOf[from]--;\\r\\n\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        _ownerOf[id] = to;\\r\\n\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(from, to, id);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes calldata data\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC165 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\r\\n        return\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\r\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\r\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address to, uint256 id) internal virtual {\\r\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\r\\n\\r\\n        // Counter overflow is incredibly unrealistic.\\r\\n        unchecked {\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        _ownerOf[id] = to;\\r\\n\\r\\n        emit Transfer(address(0), to, id);\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 id) internal virtual {\\r\\n        address owner = _ownerOf[id];\\r\\n\\r\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\r\\n\\r\\n        // Ownership check above ensures no underflow.\\r\\n        unchecked {\\r\\n            _balanceOf[owner]--;\\r\\n        }\\r\\n\\r\\n        delete _ownerOf[id];\\r\\n\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(owner, address(0), id);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        INTERNAL SAFE MINT LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _safeMint(address to, uint256 id) internal virtual {\\r\\n        _mint(to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        _mint(to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\r\\nabstract contract ERC721TokenReceiver {\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external virtual returns (bytes4) {\\r\\n        return ERC721TokenReceiver.onERC721Received.selector;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Context} from \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\r\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available all functions\\r\\n * from parent (Ownable).\\r\\n */\\r\\nabstract contract Ownable2Step is Ownable {\\r\\n    address private _pendingOwner;\\r\\n\\r\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the pending owner.\\r\\n     */\\r\\n    function pendingOwner() public view virtual returns (address) {\\r\\n        return _pendingOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\r\\n        _pendingOwner = newOwner;\\r\\n        emit OwnershipTransferStarted(owner(), newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual override {\\r\\n        delete _pendingOwner;\\r\\n        super._transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The new owner accepts the ownership transfer.\\r\\n     */\\r\\n    function acceptOwnership() public virtual {\\r\\n        address sender = _msgSender();\\r\\n        if (pendingOwner() != sender) {\\r\\n            revert OwnableUnauthorizedAccount(sender);\\r\\n        }\\r\\n        _transferOwnership(sender);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant NOT_ENTERED = 1;\\r\\n    uint256 private constant ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    /**\\r\\n     * @dev Unauthorized reentrant call.\\r\\n     */\\r\\n    error ReentrancyGuardReentrantCall();\\r\\n\\r\\n    constructor() {\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\r\\n        if (_status == ENTERED) {\\r\\n            revert ReentrancyGuardReentrantCall();\\r\\n        }\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\r\\n\\r\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\r\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\r\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\r\\nlibrary SafeTransferLib {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             ETH OPERATIONS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function safeTransferETH(address to, uint256 amount) internal {\\r\\n        bool success;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Transfer the ETH and store if it succeeded or not.\\r\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\r\\n        }\\r\\n\\r\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            ERC20 OPERATIONS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        ERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool success;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\r\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\r\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\r\\n\\r\\n            success := and(\\r\\n                // Set success to whether the call reverted, if not we check it either\\r\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\r\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\r\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\r\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\r\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\r\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\r\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\r\\n            )\\r\\n        }\\r\\n\\r\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        ERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool success;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\r\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\r\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\r\\n\\r\\n            success := and(\\r\\n                // Set success to whether the call reverted, if not we check it either\\r\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\r\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\r\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\r\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\r\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\r\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\r\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\r\\n            )\\r\\n        }\\r\\n\\r\\n        require(success, \\\"TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        ERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool success;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\r\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\r\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\r\\n\\r\\n            success := and(\\r\\n                // Set success to whether the call reverted, if not we check it either\\r\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\r\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\r\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\r\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\r\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\r\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\r\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\r\\n            )\\r\\n        }\\r\\n\\r\\n        require(success, \\\"APPROVE_FAILED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-json-writer/contracts/JsonWriter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary JsonWriter {\\r\\n\\r\\n    using JsonWriter for string;\\r\\n\\r\\n    struct Json {\\r\\n        int256 depthBitTracker;\\r\\n        string value;\\r\\n    }\\r\\n\\r\\n    bytes1 constant BACKSLASH = bytes1(uint8(92));\\r\\n    bytes1 constant BACKSPACE = bytes1(uint8(8));\\r\\n    bytes1 constant CARRIAGE_RETURN = bytes1(uint8(13));\\r\\n    bytes1 constant DOUBLE_QUOTE = bytes1(uint8(34));\\r\\n    bytes1 constant FORM_FEED = bytes1(uint8(12));\\r\\n    bytes1 constant FRONTSLASH = bytes1(uint8(47));\\r\\n    bytes1 constant HORIZONTAL_TAB = bytes1(uint8(9));\\r\\n    bytes1 constant NEWLINE = bytes1(uint8(10));\\r\\n\\r\\n    string constant TRUE = \\\"true\\\";\\r\\n    string constant FALSE = \\\"false\\\";\\r\\n    bytes1 constant OPEN_BRACE = \\\"{\\\";\\r\\n    bytes1 constant CLOSED_BRACE = \\\"}\\\";\\r\\n    bytes1 constant OPEN_BRACKET = \\\"[\\\";\\r\\n    bytes1 constant CLOSED_BRACKET = \\\"]\\\";\\r\\n    bytes1 constant LIST_SEPARATOR = \\\",\\\";\\r\\n\\r\\n    int256 constant MAX_INT256 = type(int256).max;\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON array.\\r\\n     */\\r\\n    function writeStartArray(Json memory json) \\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeStart(json, OPEN_BRACKET);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON array with a property name as the key.\\r\\n     */\\r\\n    function writeStartArray(Json memory json, string memory propertyName)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeStart(json, propertyName, OPEN_BRACKET);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON object.\\r\\n     */\\r\\n    function writeStartObject(Json memory json)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeStart(json, OPEN_BRACE);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON object with a property name as the key.\\r\\n     */\\r\\n    function writeStartObject(Json memory json, string memory propertyName)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeStart(json, propertyName, OPEN_BRACE);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the end of a JSON array.\\r\\n     */\\r\\n    function writeEndArray(Json memory json)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeEnd(json, CLOSED_BRACKET);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the end of a JSON object.\\r\\n     */\\r\\n    function writeEndObject(Json memory json)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        return writeEnd(json, CLOSED_BRACE);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and address value (as a JSON string) as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeAddressProperty(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        address value\\r\\n    ) internal pure returns (Json memory) {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": \\\"', addressToString(value), '\\\"'));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": \\\"', addressToString(value), '\\\"'));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the address value (as a JSON string) as an element of a JSON array.\\r\\n     */\\r\\n    function writeAddressValue(Json memory json, address value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', addressToString(value), '\\\"'));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', addressToString(value), '\\\"'));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and boolean value (as a JSON literal \\\"true\\\" or \\\"false\\\") as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeBooleanProperty(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        bool value\\r\\n    ) internal pure returns (Json memory) {\\r\\n        string memory strValue;\\r\\n        if (value) {\\r\\n            strValue = TRUE;\\r\\n        } else {\\r\\n            strValue = FALSE;\\r\\n        }\\r\\n\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": ', strValue));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": ', strValue));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the boolean value (as a JSON literal \\\"true\\\" or \\\"false\\\") as an element of a JSON array.\\r\\n     */\\r\\n    function writeBooleanValue(Json memory json, bool value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        string memory strValue;\\r\\n        if (value) {\\r\\n            strValue = TRUE;\\r\\n        } else {\\r\\n            strValue = FALSE;\\r\\n        }\\r\\n\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, strValue));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, strValue));\\r\\n        }\\r\\n        \\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and int value (as a JSON number) as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeIntProperty(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        int256 value\\r\\n    ) internal pure returns (Json memory) {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": ', intToString(value)));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": ', intToString(value)));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the int value (as a JSON number) as an element of a JSON array.\\r\\n     */\\r\\n    function writeIntValue(Json memory json, int256 value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, intToString(value)));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, intToString(value)));\\r\\n        }\\r\\n        \\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and value of null as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeNullProperty(Json memory json, string memory propertyName)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": null'));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": null'));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the value of null as an element of a JSON array.\\r\\n     */\\r\\n    function writeNullValue(Json memory json)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, \\\"null\\\"));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, \\\"null\\\"));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the string text value (as a JSON string) as an element of a JSON array.\\r\\n     */\\r\\n    function writeStringProperty(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        string memory value\\r\\n    ) internal pure returns (Json memory) {\\r\\n        string memory jsonEscapedString = escapeJsonString(value);\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": \\\"', jsonEscapedString, '\\\"'));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": \\\"', jsonEscapedString, '\\\"'));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeStringValue(Json memory json, string memory value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        string memory jsonEscapedString = escapeJsonString(value);\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', jsonEscapedString, '\\\"'));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', jsonEscapedString, '\\\"'));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the property name and uint value (as a JSON number) as part of a name/value pair of a JSON object.\\r\\n     */\\r\\n    function writeUintProperty(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        uint256 value\\r\\n    ) internal pure returns (Json memory) {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": ', uintToString(value)));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": ', uintToString(value)));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the uint value (as a JSON number) as an element of a JSON array.\\r\\n     */\\r\\n    function writeUintValue(Json memory json, uint256 value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, uintToString(value)));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, uintToString(value)));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON array or object based on the token parameter.\\r\\n     */\\r\\n    function writeStart(Json memory json, bytes1 token)\\r\\n        private\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, token));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, token));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker &= MAX_INT256;\\r\\n        json.depthBitTracker++;\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the beginning of a JSON array or object based on the token parameter with a property name as the key.\\r\\n     */\\r\\n    function writeStart(\\r\\n        Json memory json,\\r\\n        string memory propertyName,\\r\\n        bytes1 token\\r\\n    ) private pure returns (Json memory) {\\r\\n        if (json.depthBitTracker < 0) {\\r\\n            json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, '\\\"', propertyName, '\\\": ', token));\\r\\n        } else {\\r\\n            json.value = string(abi.encodePacked(json.value, '\\\"', propertyName, '\\\": ', token));\\r\\n        }\\r\\n\\r\\n        json.depthBitTracker &= MAX_INT256;\\r\\n        json.depthBitTracker++;\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Writes the end of a JSON array or object based on the token parameter.\\r\\n     */\\r\\n    function writeEnd(Json memory json, bytes1 token)\\r\\n        private\\r\\n        pure\\r\\n        returns (Json memory)\\r\\n    {\\r\\n        json.value = string(abi.encodePacked(json.value, token));\\r\\n        json.depthBitTracker = setListSeparatorFlag(json);\\r\\n        \\r\\n        if (getCurrentDepth(json) != 0) {\\r\\n            json.depthBitTracker--;\\r\\n        }\\r\\n\\r\\n        return json;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Escapes any characters that required by JSON to be escaped.\\r\\n     */\\r\\n    function escapeJsonString(string memory value)\\r\\n        private\\r\\n        pure\\r\\n        returns (string memory str)\\r\\n    {\\r\\n        bytes memory b = bytes(value);\\r\\n        bool foundEscapeChars;\\r\\n\\r\\n        for (uint256 i; i < b.length; i++) {\\r\\n            if (b[i] == BACKSLASH) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == DOUBLE_QUOTE) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == FRONTSLASH) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == HORIZONTAL_TAB) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == FORM_FEED) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == NEWLINE) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == CARRIAGE_RETURN) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            } else if (b[i] == BACKSPACE) {\\r\\n                foundEscapeChars = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!foundEscapeChars) {\\r\\n            return value;\\r\\n        }\\r\\n\\r\\n        for (uint256 i; i < b.length; i++) {\\r\\n            if (b[i] == BACKSLASH) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\\\\\\\\\\\\"));\\r\\n            } else if (b[i] == DOUBLE_QUOTE) {\\r\\n                str = string(abi.encodePacked(str, '\\\\\\\\\\\"'));\\r\\n            } else if (b[i] == FRONTSLASH) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\/\\\"));\\r\\n            } else if (b[i] == HORIZONTAL_TAB) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\t\\\"));\\r\\n            } else if (b[i] == FORM_FEED) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\f\\\"));\\r\\n            } else if (b[i] == NEWLINE) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\n\\\"));\\r\\n            } else if (b[i] == CARRIAGE_RETURN) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\r\\\"));\\r\\n            } else if (b[i] == BACKSPACE) {\\r\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\b\\\"));\\r\\n            } else {\\r\\n                str = string(abi.encodePacked(str, b[i]));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return str;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tracks the recursive depth of the nested objects / arrays within the JSON text\\r\\n     * written so far. This provides the depth of the current token.\\r\\n     */\\r\\n    function getCurrentDepth(Json memory json) private pure returns (int256) {\\r\\n        return json.depthBitTracker & MAX_INT256;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The highest order bit of json.depthBitTracker is used to discern whether we are writing the first item in a list or not.\\r\\n     * if (json.depthBitTracker >> 255) == 1, add a list separator before writing the item\\r\\n     * else, no list separator is needed since we are writing the first item.\\r\\n     */\\r\\n    function setListSeparatorFlag(Json memory json)\\r\\n        private\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return json.depthBitTracker | (int256(1) << 255);\\r\\n    }\\r\\n\\r\\n        /**\\r\\n     * @dev Converts an address to a string.\\r\\n     */\\r\\n    function addressToString(address _address)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes32 value = bytes32(uint256(uint160(_address)));\\r\\n        bytes16 alphabet = \\\"0123456789abcdef\\\";\\r\\n\\r\\n        bytes memory str = new bytes(42);\\r\\n        str[0] = \\\"0\\\";\\r\\n        str[1] = \\\"x\\\";\\r\\n        for (uint256 i; i < 20; i++) {\\r\\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\r\\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\r\\n        }\\r\\n\\r\\n        return string(str);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an int to a string.\\r\\n     */\\r\\n    function intToString(int256 i) internal pure returns (string memory) {\\r\\n        if (i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n\\r\\n        if (i == type(int256).min) {\\r\\n            // hard-coded since int256 min value can't be converted to unsigned\\r\\n            return \\\"-57896044618658097711785492504343953926634992332820282019728792003956564819968\\\"; \\r\\n        }\\r\\n\\r\\n        bool negative = i < 0;\\r\\n        uint256 len;\\r\\n        uint256 j;\\r\\n        if(!negative) {\\r\\n            j = uint256(i);\\r\\n        } else {\\r\\n            j = uint256(-i);\\r\\n            ++len; // make room for '-' sign\\r\\n        }\\r\\n        \\r\\n        uint256 l = j;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint256 k = len;\\r\\n        while (l != 0) {\\r\\n            bstr[--k] = bytes1((48 + uint8(l - (l / 10) * 10)));\\r\\n            l /= 10;\\r\\n        }\\r\\n\\r\\n        if (negative) {\\r\\n            bstr[0] = \\\"-\\\"; // prepend '-'\\r\\n        }\\r\\n\\r\\n        return string(bstr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a uint to a string.\\r\\n     */\\r\\n    function uintToString(uint256 _i) internal pure returns (string memory) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n\\r\\n        uint256 j = _i;\\r\\n        uint256 len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint256 k = len;\\r\\n        while (_i != 0) {\\r\\n            bstr[--k] = bytes1((48 + uint8(_i - (_i / 10) * 10)));\\r\\n            _i /= 10;\\r\\n        }\\r\\n\\r\\n        return string(bstr);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Base64.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Provides a set of functions to operate with Base64 strings.\\r\\n */\\r\\nlibrary Base64 {\\r\\n    /**\\r\\n     * @dev Base64 Encoding/Decoding Table\\r\\n     */\\r\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\r\\n     */\\r\\n    function encode(bytes memory data) internal pure returns (string memory) {\\r\\n        /**\\r\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\r\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\r\\n         */\\r\\n        if (data.length == 0) return \\\"\\\";\\r\\n\\r\\n        // Loads the table into memory\\r\\n        string memory table = _TABLE;\\r\\n\\r\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\r\\n        // and split into 4 numbers of 6 bits.\\r\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\r\\n        // - `data.length + 2`  -> Round up\\r\\n        // - `/ 3`              -> Number of 3-bytes chunks\\r\\n        // - `4 *`              -> 4 characters for each chunk\\r\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // Prepare result pointer, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // Run over the input, 3 bytes at a time\\r\\n            for {\\r\\n                let dataPtr := data\\r\\n                let endPtr := add(data, mload(data))\\r\\n            } lt(dataPtr, endPtr) {\\r\\n\\r\\n            } {\\r\\n                // Advance 3 bytes\\r\\n                dataPtr := add(dataPtr, 3)\\r\\n                let input := mload(dataPtr)\\r\\n\\r\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\r\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\r\\n                // and apply logical AND with 0x3F which is the number of\\r\\n                // the previous character in the ASCII table prior to the Base64 Table\\r\\n                // The result is then added to the table to get the character to write,\\r\\n                // and finally write it in the result pointer but with a left shift\\r\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\r\\n\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1) // Advance\\r\\n\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1) // Advance\\r\\n\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1) // Advance\\r\\n\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1) // Advance\\r\\n            }\\r\\n\\r\\n            // When data `bytes` is not exactly 3 bytes long\\r\\n            // it is padded with `=` characters at the end\\r\\n            switch mod(mload(data), 3)\\r\\n            case 1 {\\r\\n                mstore8(sub(resultPtr, 1), 0x3d)\\r\\n                mstore8(sub(resultPtr, 2), 0x3d)\\r\\n            }\\r\\n            case 2 {\\r\\n                mstore8(sub(resultPtr, 1), 0x3d)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Math} from \\\"./math/Math.sol\\\";\\r\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev The `value` string doesn't fit in the specified `length`.\\r\\n     */\\r\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\r\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        uint256 localValue = value;\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\r\\n            localValue >>= 4;\\r\\n        }\\r\\n        if (localValue != 0) {\\r\\n            revert StringsInsufficientHexLength(value, length);\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\r\\n     * representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the two strings are equal.\\r\\n     */\\r\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\r\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\r\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\r\\nabstract contract ERC20 {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\r\\n\\r\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\r\\n\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n\\r\\n        INITIAL_CHAIN_ID = block.chainid;\\r\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\r\\n        allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\r\\n        balanceOf[msg.sender] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(msg.sender, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n\\r\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\r\\n\\r\\n        // Unchecked because the only math done is incrementing\\r\\n        // the owner's nonce which cannot realistically overflow.\\r\\n        unchecked {\\r\\n            address recoveredAddress = ecrecover(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"\\\\x19\\\\x01\\\",\\r\\n                        DOMAIN_SEPARATOR(),\\r\\n                        keccak256(\\r\\n                            abi.encode(\\r\\n                                keccak256(\\r\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n                                ),\\r\\n                                owner,\\r\\n                                spender,\\r\\n                                value,\\r\\n                                nonces[owner]++,\\r\\n                                deadline\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n\\r\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\r\\n\\r\\n            allowance[recoveredAddress][spender] = value;\\r\\n        }\\r\\n\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\r\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n                    keccak256(bytes(name)),\\r\\n                    keccak256(\\\"1\\\"),\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        totalSupply += amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot underflow because a user's balance\\r\\n        // will never be larger than the total supply.\\r\\n        unchecked {\\r\\n            totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Muldiv operation overflow.\\r\\n     */\\r\\n    error MathOverflowedMulDiv();\\r\\n\\r\\n    enum Rounding {\\r\\n        Floor, // Toward negative infinity\\r\\n        Ceil, // Toward positive infinity\\r\\n        Trunc, // Toward zero\\r\\n        Expand // Away from zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\r\\n     * of rounding towards zero.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b == 0) {\\r\\n            // Guarantee the same behavior as in a regular Solidity division.\\r\\n            return a / b;\\r\\n        }\\r\\n\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\r\\n     * denominator == 0.\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\r\\n     * Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            if (denominator <= prod1) {\\r\\n                revert MathOverflowedMulDiv();\\r\\n            }\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\r\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            uint256 twos = denominator & (0 - denominator);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\r\\n            // works in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\r\\n     * towards zero.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\r\\n     */\\r\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\r\\n        return uint8(rounding) % 2 == 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker's Delight\\\"\\r\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\r\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // must be unchecked in order to support `n = type(int256).min`\\r\\n            return uint256(n >= 0 ? n : -n);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-json-writer/=lib/solidity-json-writer/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyStarToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxMintPerTransaction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HasNotReachedEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDirection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxStarTokensReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MovementLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PositionCurrentlyTaken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PositionNotMintable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PositionOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MINT_PER_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STAR_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_COLUMNS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_ROWS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate[]\",\"name\":\"coordinates\",\"type\":\"tuple[]\"}],\"name\":\"artistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canMove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"checkMerkleProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"startPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descriptor\",\"outputs\":[{\"internalType\":\"contract ITokenDescriptor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fpMembersMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableCoordinates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGrid\",\"outputs\":[{\"internalType\":\"uint256[25][25]\",\"name\":\"\",\"type\":\"uint256[25][25]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"initial\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"current\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasReachedEnd\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStar\",\"type\":\"bool\"},{\"internalType\":\"enum ITokenDescriptor.Direction\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numMovements\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"initial\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"current\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasReachedEnd\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStar\",\"type\":\"bool\"},{\"internalType\":\"enum ITokenDescriptor.Direction\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numMovements\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Token[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"lockAsStar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate[]\",\"name\":\"coordinates\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"mintAtPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"mintRandom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveEast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveNorth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveNortheast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveNorthwest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveSouth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveSoutheast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveSouthwest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"moveWest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numStarTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"}],\"name\":\"setDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate[]\",\"name\":\"coordinates\",\"type\":\"tuple[]\"}],\"name\":\"setInitialAvailableCoordinates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"initial\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenDescriptor.Coordinate\",\"name\":\"current\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasReachedEnd\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStar\",\"type\":\"bool\"},{\"internalType\":\"enum ITokenDescriptor.Direction\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numMovements\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"startPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_holdersRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_fpMembersRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LINE", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000018d989a5d0ab92ed19aba879e4cac3735f8685c9", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}