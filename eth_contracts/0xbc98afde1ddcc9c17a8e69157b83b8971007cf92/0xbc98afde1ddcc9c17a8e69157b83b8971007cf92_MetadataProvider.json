{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/renderers/MetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\nimport { MetadataRegistry } from \\\"./MetadataRegistry.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\n\\n/// @notice A contract that provides custom metadata for Party Cards.\\ncontract MetadataProvider is IMetadataProvider, Multicall {\\n    event MetadataSet(address indexed instance, bytes metadata);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @inheritdoc IMetadataProvider\\n    bool public constant supportsRegistrars = true;\\n\\n    // The metadata for each Party instance.\\n    mapping(address instance => bytes metadata) private _metadata;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @inheritdoc IMetadataProvider\\n    function getMetadata(address instance, uint256) external view override returns (bytes memory) {\\n        return _metadata[instance];\\n    }\\n\\n    /// @notice Set the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param metadata The encoded metadata.\\n    function setMetadata(address instance, bytes memory metadata) external {\\n        if (instance != msg.sender) {\\n            MetadataRegistry registry = MetadataRegistry(\\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_METADATA_REGISTRY)\\n            );\\n\\n            // Check if the caller is authorized to set metadata for the instance.\\n            if (!registry.isRegistrar(msg.sender, instance)) {\\n                revert NotAuthorized(msg.sender, instance);\\n            }\\n        }\\n\\n        _metadata[instance] = metadata;\\n\\n        emit MetadataSet(instance, metadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\nabstract contract Multicall {\\n    using LibRawResult for bytes;\\n\\n    /// @notice Perform multiple delegatecalls on ourselves.\\n    function multicall(bytes[] calldata multicallData) external {\\n        for (uint256 i; i < multicallData.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(multicallData[i]);\\n            if (!s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\n\\n/// @notice A registry of custom metadata providers for Party Cards.\\ncontract MetadataRegistry is Multicall {\\n    event ProviderSet(address indexed instance, IMetadataProvider indexed provider);\\n    event RegistrarSet(address indexed registrar, address indexed instance, bool canSetData);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Get the metadata provider for a Party instance.\\n    mapping(address instance => IMetadataProvider provider) public getProvider;\\n\\n    /// @notice Whether or not an address is a registar that can set the\\n    ///         provider and metadata for another instance. If registrar is set\\n    ///         true for `address(1)`, the address is a universal registar and\\n    ///         can set data for any instance.\\n    /// @dev Registrars' ability to set metadata for another instance must also be\\n    ///      supported by the metadata provider used by that instance, indicated by\\n    ///      `IMetadataProvider.supportsRegistrars()`.\\n    mapping(address registrar => mapping(address instance => bool canSetData)) private _isRegistrar;\\n\\n    /// @param globals The address of the `Globals` contract.\\n    /// @param registrars The addresses of the initial universal registrars.\\n    constructor(IGlobals globals, address[] memory registrars) {\\n        _GLOBALS = globals;\\n\\n        // Set the initial universal registrars.\\n        for (uint256 i = 0; i < registrars.length; i++) {\\n            _isRegistrar[registrars[i]][address(1)] = true;\\n        }\\n    }\\n\\n    /// @notice Set the metadata provider for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param provider The address of the metadata provider.\\n    function setProvider(address instance, IMetadataProvider provider) external {\\n        // Check if the caller is authorized to set the provider for the instance.\\n        if (!isRegistrar(msg.sender, instance)) revert NotAuthorized(msg.sender, instance);\\n\\n        getProvider[instance] = provider;\\n\\n        emit ProviderSet(instance, provider);\\n    }\\n\\n    /// @notice Set whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @param canSetData Whether or not the address can set data for the instance.\\n    function setRegistrar(address registrar, address instance, bool canSetData) external {\\n        if (\\n            msg.sender != instance &&\\n            msg.sender != _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET)\\n        ) {\\n            revert NotAuthorized(msg.sender, instance);\\n        }\\n\\n        _isRegistrar[registrar][instance] = canSetData;\\n\\n        emit RegistrarSet(registrar, instance, canSetData);\\n    }\\n\\n    /// @notice Get whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @return canSetData Whether or not the address can set data for the instance.\\n    function isRegistrar(address registrar, address instance) public view returns (bool) {\\n        return\\n            registrar == instance ||\\n            _isRegistrar[registrar][address(1)] ||\\n            _isRegistrar[registrar][instance];\\n    }\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(address instance, uint256 tokenId) external view returns (bytes memory) {\\n        IMetadataProvider provider = getProvider[instance];\\n\\n        return\\n            address(provider) != address(0) ? provider.getMetadata(instance, tokenId) : bytes(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IMetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\ninterface IMetadataProvider {\\n    /// @notice Whether or not the metadata provider supports registrars that can\\n    ///         set metadata for other instances.\\n    /// @dev See `MetadataRegistry` for more information on the registrar role.\\n    function supportsRegistrars() external view returns (bool);\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(\\n        address instance,\\n        uint256 tokenId\\n    ) external view returns (bytes memory metadata);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/IGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/Implementation.sol\\\";\\n\\n// Single registry of global values controlled by multisig.\\n// See `LibGlobals` for all valid keys.\\ninterface IGlobals {\\n    function multiSig() external view returns (address);\\n\\n    function getBytes32(uint256 key) external view returns (bytes32);\\n\\n    function getUint256(uint256 key) external view returns (uint256);\\n\\n    function getBool(uint256 key) external view returns (bool);\\n\\n    function getAddress(uint256 key) external view returns (address);\\n\\n    function getImplementation(uint256 key) external view returns (Implementation);\\n\\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\\n\\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\\n\\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\\n\\n    function setBytes32(uint256 key, bytes32 value) external;\\n\\n    function setUint256(uint256 key, uint256 value) external;\\n\\n    function setBool(uint256 key, bool value) external;\\n\\n    function setAddress(uint256 key, address value) external;\\n\\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\\n\\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\\n\\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\\n}\\n\"\r\n    },\r\n    \"contracts/globals/LibGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Valid keys in `IGlobals`. Append-only.\\nlibrary LibGlobals {\\n    // The Globals commented out below were depreciated in 1.2; factories\\n    // can now choose the implementation address to deploy and no longer\\n    // deploy the latest implementation. They will no longer be updated\\n    // in future releases.\\n    //\\n    // See https://github.com/PartyDAO/party-migrations for\\n    // implementation addresses by release.\\n\\n    uint256 internal constant GLOBAL_PARTY_IMPL = 1;\\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL = 2;\\n    // uint256 internal constant GLOBAL_PARTY_FACTORY = 3;\\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL = 4;\\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL = 5;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT = 6;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION = 7;\\n    // uint256 internal constant GLOBAL_AUCTION_CF_IMPL = 8;\\n    // uint256 internal constant GLOBAL_BUY_CF_IMPL = 9;\\n    // uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL = 10;\\n    uint256 internal constant GLOBAL_DAO_WALLET = 11;\\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR = 12;\\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY = 13;\\n    uint256 internal constant GLOBAL_OPENSEA_ZONE = 14;\\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION = 15;\\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION = 16;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION = 17;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT = 18;\\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION = 19;\\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION = 20;\\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS = 21;\\n    uint256 internal constant GLOBAL_RENDERER_STORAGE = 22;\\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION = 23;\\n    // uint256 internal constant GLOBAL_ROLLING_AUCTION_CF_IMPL = 24;\\n    // uint256 internal constant GLOBAL_COLLECTION_BATCH_BUY_CF_IMPL = 25;\\n    uint256 internal constant GLOBAL_METADATA_REGISTRY = 26;\\n    // uint256 internal constant GLOBAL_CROWDFUND_FACTORY = 27;\\n    // uint256 internal constant GLOBAL_INITIAL_ETH_CF_IMPL = 28;\\n    // uint256 internal constant GLOBAL_RERAISE_ETH_CF_IMPL = 29;\\n    uint256 internal constant GLOBAL_SEAPORT = 30;\\n    uint256 internal constant GLOBAL_CONDUIT_CONTROLLER = 31;\\n    uint256 internal constant GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR = 32;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibRawResult.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibRawResult {\\n    // Revert with the data in `b`.\\n    function rawRevert(bytes memory b) internal pure {\\n        assembly {\\n            revert(add(b, 32), mload(b))\\n        }\\n    }\\n\\n    // Return with the data in `b`.\\n    function rawReturn(bytes memory b) internal pure {\\n        assembly {\\n            return(add(b, 32), mload(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Base contract for all contracts intended to be delegatecalled into.\\nabstract contract Implementation {\\n    error OnlyDelegateCallError();\\n    error OnlyConstructorError();\\n\\n    address public immutable IMPL;\\n\\n    constructor() {\\n        IMPL = address(this);\\n    }\\n\\n    // Reverts if the current function context is not inside of a delegatecall.\\n    modifier onlyDelegateCall() virtual {\\n        if (address(this) == IMPL) {\\n            revert OnlyDelegateCallError();\\n        }\\n        _;\\n    }\\n\\n    // Reverts if the current function context is not inside of a constructor.\\n    modifier onlyConstructor() {\\n        if (address(this).code.length != 0) {\\n            revert OnlyConstructorError();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"viaIR\": true\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IGlobals\",\"name\":\"globals\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"MetadataSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"multicallData\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsRegistrars\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MetadataProvider", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001ca20040ce6ad406bc2a6c89976388829e7fbade", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}