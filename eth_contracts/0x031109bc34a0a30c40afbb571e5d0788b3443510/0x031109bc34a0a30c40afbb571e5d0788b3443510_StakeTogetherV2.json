{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {ERC165Upgradeable} from \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\\n    struct AccessControlStorage {\\n        mapping(bytes32 role => RoleData) _roles;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessControl\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\\n\\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\\n        assembly {\\n            $.slot := AccessControlStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        return $._roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        $._roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (!hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        AccessControlStorage storage $ = _getAccessControlStorage();\\n        if (hasRole(role, account)) {\\n            $._roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n     * See {_onlyProxy}.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {IERC20Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\\n    struct ERC20Storage {\\n        mapping(address account => uint256) _balances;\\n\\n        mapping(address account => mapping(address spender => uint256)) _allowances;\\n\\n        uint256 _totalSupply;\\n\\n        string _name;\\n        string _symbol;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ERC20\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\\n\\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\\n        assembly {\\n            $.slot := ERC20StorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        $._name = name_;\\n        $._symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        return $._allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            $._totalSupply += value;\\n        } else {\\n            uint256 fromBalance = $._balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                $._balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                $._totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                $._balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        ERC20Storage storage $ = _getERC20Storage();\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        $._allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20Upgradeable} from \\\"../ERC20Upgradeable.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Destroys a `value` amount of tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 value) public virtual {\\n        _burn(_msgSender(), value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n     * the caller's allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `value`.\\n     */\\n    function burnFrom(address account, uint256 value) public virtual {\\n        _spendAllowance(account, _msgSender(), value);\\n        _burn(account, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {ERC20Upgradeable} from \\\"../ERC20Upgradeable.sol\\\";\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {EIP712Upgradeable} from \\\"../../../utils/cryptography/EIP712Upgradeable.sol\\\";\\nimport {NoncesUpgradeable} from \\\"../../../utils/NoncesUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\\n    bytes32 private constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Permit deadline has expired.\\n     */\\n    error ERC2612ExpiredSignature(uint256 deadline);\\n\\n    /**\\n     * @dev Mismatched signature.\\n     */\\n    error ERC2612InvalidSigner(address signer, address owner);\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\\n        __EIP712_init_unchained(name, \\\"1\\\");\\n    }\\n\\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\\n\\n    /**\\n     * @inheritdoc IERC20Permit\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) {\\n            revert ERC2612ExpiredSignature(deadline);\\n        }\\n\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        if (signer != owner) {\\n            revert ERC2612InvalidSigner(signer, owner);\\n        }\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Permit\\n     */\\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\\n        return super.nonces(owner);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Permit\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {MessageHashUtils} from \\\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\\\";\\nimport {IERC5267} from \\\"@openzeppelin/contracts/interfaces/IERC5267.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n */\\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\\n    bytes32 private constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\\n    struct EIP712Storage {\\n        /// @custom:oz-renamed-from _HASHED_NAME\\n        bytes32 _hashedName;\\n        /// @custom:oz-renamed-from _HASHED_VERSION\\n        bytes32 _hashedVersion;\\n\\n        string _name;\\n        string _version;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.EIP712\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\\n\\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\\n        assembly {\\n            $.slot := EIP712StorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        $._name = name;\\n        $._version = version;\\n\\n        // Reset prior values in storage if upgrading\\n        $._hashedName = 0;\\n        $._hashedVersion = 0;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator();\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {IERC-5267}.\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\\n        require($._hashedName == 0 && $._hashedVersion == 0, \\\"EIP712: Uninitialized\\\");\\n\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Name() internal view virtual returns (string memory) {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        return $._name;\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Version() internal view virtual returns (string memory) {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        return $._version;\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\\n     */\\n    function _EIP712NameHash() internal view returns (bytes32) {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        string memory name = _EIP712Name();\\n        if (bytes(name).length > 0) {\\n            return keccak256(bytes(name));\\n        } else {\\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\\n            bytes32 hashedName = $._hashedName;\\n            if (hashedName != 0) {\\n                return hashedName;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\\n     */\\n    function _EIP712VersionHash() internal view returns (bytes32) {\\n        EIP712Storage storage $ = _getEIP712Storage();\\n        string memory version = _EIP712Version();\\n        if (bytes(version).length > 0) {\\n            return keccak256(bytes(version));\\n        } else {\\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\\n            bytes32 hashedVersion = $._hashedVersion;\\n            if (hashedVersion != 0) {\\n                return hashedVersion;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\\n */\\nabstract contract NoncesUpgradeable is Initializable {\\n    /**\\n     * @dev The nonce used for an `account` is not the expected current nonce.\\n     */\\n    error InvalidAccountNonce(address account, uint256 currentNonce);\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\\n    struct NoncesStorage {\\n        mapping(address account => uint256) _nonces;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Nonces\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\\n\\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\\n        assembly {\\n            $.slot := NoncesStorageLocation\\n        }\\n    }\\n\\n    function __Nonces_init() internal onlyInitializing {\\n    }\\n\\n    function __Nonces_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the next unused nonce for an address.\\n     */\\n    function nonces(address owner) public view virtual returns (uint256) {\\n        NoncesStorage storage $ = _getNoncesStorage();\\n        return $._nonces[owner];\\n    }\\n\\n    /**\\n     * @dev Consumes a nonce.\\n     *\\n     * Returns the current value and increments nonce.\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256) {\\n        NoncesStorage storage $ = _getNoncesStorage();\\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\\n        // decremented or reset. This guarantees that the nonce never overflows.\\n        unchecked {\\n            // It is important to do x++ and not ++x here.\\n            return $._nonces[owner]++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\\n     */\\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\\n        uint256 current = _useNonce(owner);\\n        if (nonce != current) {\\n            revert InvalidAccountNonce(owner, current);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\\n    struct PausableStorage {\\n        bool _paused;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Pausable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\\n\\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\\n        assembly {\\n            $.slot := PausableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        PausableStorage storage $ = _getPausableStorage();\\n        return $._paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAirdrop.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 Stake Together Labs <legal@staketogether.org>\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\n/// @title Interface for the Airdrop functionality within the Stake Together protocol.\\n/// @notice A contract that represents the Airdrop functionality.\\n/// @custom:security-contact security@staketogether.org\\ninterface IAirdrop {\\n  /// @notice Thrown if a claim has already been made for a given block and index.\\n  error AlreadyClaimed();\\n\\n  /// @notice Thrown if the Merkle Proof verification fails.\\n  error InvalidProof();\\n\\n  /// @notice Thrown if the listed in anti-fraud.\\n  error ListedInAntiFraud();\\n\\n  /// @notice Thrown if the Merkle Root is not set for a given block number.\\n  error MerkleRootNotSet();\\n\\n  /// @notice This error is thrown when trying to set a Merkle Root that has already been set for a given block.\\n  error MerkleRootAlreadySetForBlock();\\n\\n  /// @notice This error is thrown when there is no extra ETH available for transfer.\\n  error NoExtraAmountAvailable();\\n\\n  /// @notice This error is thrown when an action is performed by an address that is not the router.\\n  error OnlyRouter();\\n\\n  /// @notice This error is thrown when trying to set the router address that is already set.\\n  error RouterAlreadySet();\\n\\n  /// @notice This error is thrown when trying to set the stakeTogether address that is already set.\\n  error StakeTogetherAlreadySet();\\n\\n  /// @notice Thrown if the shares amount being claimed is zero.\\n  error ZeroAmount();\\n\\n  /// @notice Thrown if the address trying to make a claim is the zero address.\\n  error ZeroAddress();\\n\\n  /// @notice Emitted when a new Merkle root is added.\\n  /// @param reportBlock The block report number corresponding to the Merkle root.\\n  /// @param merkleRoot The Merkle root.\\n  event AddMerkleRoot(uint256 indexed reportBlock, bytes32 merkleRoot);\\n\\n  /// @notice Emitted when a claim is processed.\\n  /// @param blockNumber The report block number related to the claim.\\n  /// @param index The index of the claim within the Merkle tree.\\n  /// @param account The address of the account making the claim.\\n  /// @param sharesAmount The amount of shares claimed.\\n  /// @param merkleProof The Merkle proof corresponding to the claim.\\n  event Claim(\\n    uint256 indexed blockNumber,\\n    uint256 index,\\n    address indexed account,\\n    uint256 sharesAmount,\\n    bytes32[] merkleProof\\n  );\\n\\n  /// @notice Emitted when a batch of claims is processed.\\n  /// @param claimer The address making the batch claims.\\n  /// @param numClaims The number of claims in the batch.\\n  /// @param totalAmount The total amount of the claims in the batch.\\n  event ClaimBatch(address indexed claimer, uint256 numClaims, uint256 totalAmount);\\n\\n  /// @notice Emitted when ETH is received by the contract.\\n  /// @param amount The amount of ETH received.\\n  event ReceiveEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when the router address is set.\\n  /// @param router The address of the router.\\n  event SetRouter(address indexed router);\\n\\n  /// @notice Emitted when the StakeTogether contract address is set.\\n  /// @param stakeTogether The address of the StakeTogether contract.\\n  event SetStakeTogether(address indexed stakeTogether);\\n\\n  /// @notice Initializes the contract with initial settings.\\n  function initialize() external;\\n\\n  /// @notice Pauses all contract functionalities.\\n  /// @dev Only callable by the admin role.\\n  function pause() external;\\n\\n  /// @notice Unpauses all contract functionalities.\\n  /// @dev Only callable by the admin role.\\n  function unpause() external;\\n\\n  /// @notice Receives Ether and emits an event logging the sender and amount.\\n  receive() external payable;\\n\\n  /// @notice Transfers any extra amount of ETH in the contract to the StakeTogether fee address.\\n  /// @dev Only callable by the admin role.\\n  function transferExtraAmount() external;\\n\\n  /// @notice Sets the StakeTogether contract address.\\n  /// @param _stakeTogether The address of the StakeTogether contract.\\n  /// @dev Only callable by the admin role.\\n  function setStakeTogether(address _stakeTogether) external;\\n\\n  /// @notice Sets the Router contract address.\\n  /// @param _router The address of the router.\\n  /// @dev Only callable by the admin role.\\n  function setRouter(address _router) external;\\n\\n  /// @notice Adds a new Merkle root for a given block number.\\n  /// @param _reportBlock The report block number.\\n  /// @param _root The Merkle root.\\n  /// @dev Only callable by the router.\\n  function addMerkleRoot(uint256 _reportBlock, bytes32 _root) external;\\n\\n  /// @notice Claims a reward for a specific report block number.\\n  /// @param _reportBlock The report block number.\\n  /// @param _index The index in the Merkle tree.\\n  /// @param _account The address claiming the reward.\\n  /// @param _sharesAmount The amount of shares to claim.\\n  /// @param merkleProof The Merkle proof required to claim the reward.\\n  /// @dev Verifies the Merkle proof and transfers the reward shares.\\n  function claim(\\n    uint256 _reportBlock,\\n    uint256 _index,\\n    address _account,\\n    uint256 _sharesAmount,\\n    bytes32[] calldata merkleProof\\n  ) external;\\n\\n  /// @notice Checks if a reward has been claimed for a specific index and block number.\\n  /// @param _reportBlock The block number.\\n  /// @param _index The index in the Merkle tree.\\n  /// @return Returns true if the reward has been claimed, false otherwise.\\n  function isClaimed(uint256 _reportBlock, uint256 _index) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\n// This interface is designed to be compatible with the Vyper version.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ninterface IDepositContract {\\n  /// @notice A processed deposit event.\\n  event DepositEvent(\\n    bytes pubkey,\\n    bytes withdrawal_credentials,\\n    bytes amount,\\n    bytes signature,\\n    bytes index\\n  );\\n\\n  /// @notice Submit a Phase 0 DepositData object.\\n  /// @param pubkey A BLS12-381 public key.\\n  /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n  /// @param signature A BLS12-381 signature.\\n  /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n  /// Used as a protection against malformed input.\\n  function deposit(\\n    bytes calldata pubkey,\\n    bytes calldata withdrawal_credentials,\\n    bytes calldata signature,\\n    bytes32 deposit_data_root\\n  ) external payable;\\n\\n  /// @notice Query the current deposit root hash.\\n  /// @return The deposit root hash.\\n  function get_deposit_root() external view returns (bytes32);\\n\\n  /// @notice Query the current deposit count.\\n  /// @return The deposit count encoded as a little endian 64-bit number.\\n  function get_deposit_count() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 Stake Together Labs <legal@staketogether.org>\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\n/// @title StakeTogether Report Configuration\\n/// @notice This module includes configuration and reports related to the StakeTogether protocol.\\n/// @custom:security-contact security@staketogether.org\\ninterface IRouter {\\n  /// @notice Emitted when a report for a specific block has already been executed.\\n  error AlreadyExecuted();\\n\\n  /// @notice Emitted when an oracle has already reported for a specific block.\\n  error AlreadyReported();\\n\\n  /// @notice Emitted when the beacon's balance is not enough to cover the loss amount.\\n  error BeaconBalanceTooLow();\\n\\n  /// @notice Emitted when the block number has not yet reached the expected value for reporting.\\n  error BlockNumberNotReached();\\n\\n  /// @notice Emitted when the report configuration is not yet set.\\n  error ConfigNotSet();\\n\\n  /// @notice Emitted when the consensus is not yet delayed.\\n  error ConsensusNotDelayed();\\n\\n  /// @notice Emitted when trying to execute too early.\\n  error EarlyExecution();\\n\\n  /// @notice Emitted when the report's profit amount A is not enough for execution.\\n  error IncreaseOraclesToUseMargin();\\n\\n  /// @notice Emitted when ETH balance is not enough for transaction.\\n  error InsufficientEthBalance();\\n\\n  /// @notice Emitted when the oracles' margin is too high.\\n  error MarginTooHigh();\\n\\n  /// @notice Emitted when there's no active consensus for a report block.\\n  error NoActiveConsensus();\\n\\n  /// @notice Emitted when there is no pending execution for consensus.\\n  error NoPendingExecution();\\n\\n  /// @notice Emitted when the report block is not yet reached.\\n  error OracleAlreadyReported();\\n\\n  /// @notice Emitted when an oracle is not in the report oracles list.\\n  error OracleNotExists();\\n\\n  /// @notice Emitted when an oracle is already in the report oracles list.\\n  error OracleExists();\\n\\n  /// @notice Emitted when an oracle is already blacklisted.\\n  error OracleAlreadyBlacklisted();\\n\\n  /// @notice Emitted when an oracle is blacklisted.\\n  error OracleBlacklisted();\\n\\n  /// @notice Emitted when an oracle is not blacklisted.\\n  error OracleNotBlacklisted();\\n\\n  /// @notice Emitted when an oracle is active.\\n  error OnlyActiveOracle();\\n\\n  /// @notice Emitted when an action is attempted by an address other than the stakeTogether contract.\\n  error OnlyStakeTogether();\\n\\n  /// @notice Emitted when there is a pending execution for consensus.\\n  error PendingExecution();\\n\\n  /// @notice Emitted when the report delay blocks are too high.\\n  error ReportDelayBlocksTooHigh();\\n\\n  /// @notice Emitted when a report for a specific block has already been revoked.\\n  error ReportRevoked();\\n\\n  /// Emits when the report block is not greater than the last executed reportBlock.\\n  error ReportBlockShouldBeGreater();\\n\\n  /// @notice Emitted when there are not enough oracles to use the margin.\\n  error RequiredMoreOracles();\\n\\n  /// @notice Emitted when the quorum is not yet reached for consensus.\\n  error QuorumNotReached();\\n\\n  /// @notice Emitted when a sentinel exists in the oracles list.\\n  error SentinelExists();\\n\\n  /// @notice Emitted when a sentinel does not exist in the oracles list.\\n  error SentinelNotExists();\\n\\n  /// @notice Emitted when trying to set the stakeTogether address that is already set.\\n  error StakeTogetherAlreadySet();\\n\\n  /// @notice Emitted when the stakeTogether's withdraw balance is not enough.\\n  error WithdrawBalanceTooLow();\\n\\n  /// @notice Thrown if the address trying to make a claim is the zero address.\\n  error ZeroAddress();\\n\\n  /// @dev Config structure used for configuring the reporting mechanism in StakeTogether protocol.\\n  /// @param bunkerMode A boolean flag to indicate whether the bunker mode is active or not.\\n  /// @param reportFrequency The frequency in which reports need to be generated.\\n  /// @param reportDelayBlock The number of blocks to delay before a report is considered.\\n  /// @param oracleQuorum The quorum required among oracles for a report to be considered.\\n  struct Config {\\n    uint256 reportFrequency;\\n    uint256 reportDelayBlock;\\n    uint256 reportNoConsensusMargin;\\n    uint256 oracleQuorum;\\n  }\\n\\n  /// @dev Report structure used for reporting the state of the protocol at different report blocks.\\n  /// @param reportBlock The specific block period for which this report is generated.\\n  /// @param merkleRoot The Merkle root hash representing the state of the data at this reportBlock.\\n  /// @param profitAmount The total profit amount generated during this reportBlock.\\n  /// @param profitShares The distribution of profits among stakeholders for this reportBlock.\\n  /// @param lossAmount The total loss amount incurred during this reportBlock.\\n  /// @param withdrawAmount The total amount withdrawn by users during this reportBlock.\\n  /// @param withdrawRefundAmount The amount refunded to users on withdrawal during this reportBlock.\\n  /// @param accumulatedReports The total number of reports accumulated up to this reportBlock.\\n  struct Report {\\n    uint256 reportBlock;\\n    bytes32 merkleRoot;\\n    uint256 profitAmount;\\n    uint256 profitShares;\\n    uint256 lossAmount;\\n    uint256 withdrawAmount;\\n    uint256 withdrawRefundAmount;\\n    uint256 accumulatedReports;\\n  }\\n\\n  /// @notice Emitted when a new oracle is added for reporting.\\n  /// @param reportOracle The address of the oracle that was added.\\n  event AddReportOracle(address indexed reportOracle);\\n\\n  /// @notice Emitted when an oracle is blacklisted.\\n  /// @param reportOracle The address of the oracle that was blacklisted.\\n  event BlacklistReportOracle(address indexed reportOracle);\\n\\n  /// @notice Emitted when a report is approved by consensus.\\n  /// @param report The report details.\\n  event ConsensusApprove(uint256 indexed reportBlock, Report report);\\n\\n  /// @notice Emitted when a report is approved by consensus.\\n  /// @param report The report details.\\n  event ConsensusFail(uint256 indexed reportBlock, Report report);\\n\\n  /// @notice Emitted when a report is executed.\\n  /// @param sender The sneder oracle that execute the report.\\n  /// @param report The report details.\\n  event ExecuteReport(address indexed sender, uint256 indexed reportBlock, Report report);\\n\\n  /// @notice Emitted when the contract receives ether.\\n  /// @param amount The amount of ether received.\\n  event ReceiveEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when Ether is received from Stake Together\\n  /// @param amount The amount of Ether received\\n  event ReceiveWithdrawEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when an oracle is removed from reporting.\\n  /// @param reportOracle The address of the oracle that was removed.\\n  event RemoveReportOracle(address indexed reportOracle);\\n\\n  /// @notice Emitted when a consensus report is revoked.\\n  /// @param sender The sentinel that execute the revoke.\\n  /// @param reportBlock The block number at which the consensus was revoked.\\n  event RevokeConsensusReport(address indexed sender, uint256 indexed reportBlock);\\n\\n  /// @notice Emitted when bunker mode is set.\\n  /// @param bunkerMode The bunker mode flag.\\n  event SetBunkerMode(bool indexed bunkerMode);\\n\\n  /// @notice Emitted when the protocol configuration is updated.\\n  /// @param config The updated configuration.\\n  event SetConfig(Config indexed config);\\n\\n  /// @notice Emitted when the StakeTogether address is set.\\n  /// @param stakeTogether The address of the StakeTogether contract.\\n  event SetStakeTogether(address indexed stakeTogether);\\n\\n  /// @notice Emitted when the next report frequency is skipped.\\n  /// @param reportBlock The reportBlock for which the report frequency was skipped.\\n  /// @param reportNextBlock The block number at which the report frequency was skipped.\\n  event AdvanceNextBlock(uint256 indexed reportBlock, uint256 indexed reportNextBlock);\\n\\n  /// @notice Emitted when a report is submitted.\\n  /// @param sender The address of the oracle that submitted the report.\\n  /// @param report The details of the submitted report.\\n  event SubmitReport(address indexed sender, Report indexed report);\\n\\n  /// @notice Emitted when an oracle is unblacklisted.\\n  /// @param reportOracle The address of the oracle that was unblacklisted.\\n  event UnBlacklistReportOracle(address indexed reportOracle);\\n\\n  /// @notice Initializes the contract after deployment.\\n  /// @dev Initializes various base contract functionalities and sets the initial state.\\n  /// @param _airdrop The address of the Airdrop contract.\\n  /// @param _withdrawals The address of the Withdrawals contract.\\n  function initialize(address _airdrop, address _withdrawals) external;\\n\\n  /// @notice Pauses the contract functionalities.\\n  /// @dev Only the ADMIN_ROLE can pause the contract.\\n  function pause() external;\\n\\n  /// @notice Resumes the contract functionalities after being paused.\\n  /// @dev Only the ADMIN_ROLE can unpause the contract.\\n  function unpause() external;\\n\\n  /// @notice Receive ether to the contract.\\n  /// @dev An event is emitted with the amount of ether received.\\n  receive() external payable;\\n\\n  /// @notice Allows the Stake Together to send ETH to the contract.\\n  /// @dev This function can only be called by the Stake Together.\\n  function receiveWithdrawEther() external payable;\\n\\n  /// @notice Sets the address for the StakeTogether contract.\\n  /// @dev Only the ADMIN_ROLE can set the address, and the provided address must not be zero.\\n  /// @param _stakeTogether The address of the StakeTogether contract.\\n  function setStakeTogether(address _stakeTogether) external;\\n\\n  /// @notice Sets the configuration parameters for the contract.\\n  /// @dev Only the ADMIN_ROLE can set the configuration, and it ensures a minimum report delay block.\\n  /// @param _config A struct containing various configuration parameters.\\n  function setConfig(Config memory _config) external;\\n\\n  /// @notice Checks if an address is an active report oracle.\\n  /// @param _account Address of the oracle to be checked.\\n  function isReportOracle(address _account) external returns (bool);\\n\\n  /// @notice Checks if a report oracle is blacklisted.\\n  /// @param _account Address of the oracle to be checked.\\n  function isReportOracleBlackListed(address _account) external view returns (bool);\\n\\n  /// @notice Adds a new report oracle.\\n  /// @dev Only an account with the ORACLE_REPORT_MANAGER_ROLE can call this function.\\n  /// @param _account Address of the oracle to be added.\\n  function addReportOracle(address _account) external;\\n\\n  /// @notice Removes an existing report oracle.\\n  /// @dev Only an account with the ORACLE_REPORT_MANAGER_ROLE can call this function.\\n  /// @param _account Address of the oracle to be removed.\\n  function removeReportOracle(address _account) external;\\n\\n  /// @notice Blacklists a report oracle.\\n  /// @dev Only an account with the ORACLE_SENTINEL_ROLE can call this function.\\n  /// @param _account Address of the oracle to be blacklisted.\\n  function blacklistReportOracle(address _account) external;\\n\\n  /// @notice Removes a report oracle from the blacklist.\\n  /// @dev Only an account with the ORACLE_SENTINEL_ROLE can call this function.\\n  /// @param _account Address of the oracle to be removed from the blacklist.\\n  function unBlacklistReportOracle(address _account) external;\\n\\n  /// @notice Adds a new sentinel account.\\n  /// @dev Only an account with the ADMIN_ROLE can call this function.\\n  /// @param _account Address of the account to be added as sentinel.\\n  function addSentinel(address _account) external;\\n\\n  /// @notice Removes an existing sentinel account.\\n  /// @dev Only an account with the ADMIN_ROLE can call this function.\\n  /// @param _account Address of the sentinel account to be removed.\\n  function removeSentinel(address _account) external;\\n\\n  /// @notice Submit a report for the current reporting block.\\n  /// @dev Handles report submissions, checking for consensus or thresholds and preps next block if needed.\\n  /// It uses a combination of total votes for report to determine consensus.\\n  /// @param _report Data structure of the report.\\n  function submitReport(Report calldata _report) external;\\n\\n  /// @notice Allows an active report oracle to execute an approved report.\\n  /// @dev Executes the actions based on the consensus-approved report.\\n  /// @param _report The data structure containing report details.\\n  function executeReport(Report calldata _report) external;\\n\\n  /// @notice Forces to advance to nextReportBlock.\\n  function forceNextReportBlock() external;\\n\\n  /// @notice Computes and returns the hash of a given report.\\n  /// @param _report The data structure containing report details.\\n  function getReportHash(Report calldata _report) external pure returns (bytes32);\\n\\n  // @notice Revokes a consensus-approved report for a given reportBlock.\\n  /// @dev Only accounts with the ORACLE_SENTINEL_ROLE can call this function.\\n  /// @param _reportBlock The reportBlock for which the report was approved.\\n  function revokeConsensusReport(uint256 _reportBlock) external;\\n\\n  /// @notice Validates if conditions to submit a report for an reportBlock are met.\\n  /// @dev Verifies conditions such as block number, consensus reportBlock, executed reports, and oracle votes.\\n  /// @param _report The data structure containing report details.\\n  function isReadyToSubmit(Report calldata _report) external view returns (bytes32);\\n\\n  /// @notice Validates if conditions to execute a report are met.\\n  /// @dev Verifies conditions like revoked reports, executed reports, consensus reports, and beacon balance.\\n  /// @param _report The data structure containing report details.\\n  function isReadyToExecute(Report calldata _report) external view returns (bytes32);\\n\\n  /// @notice Returns the next report block.\\n  function reportBlock() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakeTogether.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 Stake Together Labs <legal@staketogether.org>\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\n/// @title StakeTogether Interface\\n/// @notice This interface defines the essential structures and functions for the StakeTogether protocol.\\n/// @custom:security-contact security@staketogether.org\\ninterface IStakeTogether {\\n  /// @notice Thrown if the deposit limit is reached.\\n  error DepositLimitReached();\\n\\n  /// @notice Thrown if the transfer is too early to be executed.\\n  error EarlyTransfer();\\n\\n  /// @notice Thrown if the feature is disabled.\\n  error FeatureDisabled();\\n\\n  /// @notice Thrown if the operation is a FlashLoan.\\n  error FlashLoan();\\n\\n  /// @notice Thrown if there is insufficient beacon balance.\\n  error InsufficientBeaconBalance();\\n\\n  /// @notice Thrown if there are insufficient funds in the account.\\n  error InsufficientAccountBalance();\\n\\n  /// @notice Thrown if the allowance is insufficient.\\n  error InsufficientAllowance();\\n\\n  /// @notice Thrown if there is insufficient pool balance.\\n  error InsufficientPoolBalance();\\n\\n  /// @notice Thrown if there are insufficient shares.\\n  error InsufficientShares();\\n\\n  /// @notice Thrown if the allocations length is invalid.\\n  error InvalidLength();\\n\\n  /// @notice Thrown if the total percentage is invalid.\\n  error InvalidSum();\\n\\n  /// @notice Thrown if the value is invalid.\\n  error InvalidValue();\\n\\n  /// @notice Thrown if the pool size is less than the validator size.\\n  error InvalidSize();\\n\\n  /// @notice Thrown if the total percentage is not equal to 1 ether.\\n  error InvalidTotalPercentage();\\n\\n  /// @notice Thrown if the total supply is invalid.\\n  error InvalidTotalSupply();\\n\\n  /// @notice Thrown if the number of delegations exceeds the maximum limit.\\n  error MaxDelegations();\\n\\n  /// @notice Thrown if the withdrawal amount is less than the minimum required.\\n  error LessThanMinimumWithdraw();\\n\\n  /// @notice Thrown if the caller is not the airdrop.\\n  error OnlyAirdrop();\\n\\n  /// @notice Thrown if the caller is not the router.\\n  error OnlyRouter();\\n\\n  /// @notice Thrown if the caller is not a validator oracle.\\n  error OnlyValidatorOracle();\\n\\n  /// @notice Thrown if the caller does not have the appropriate role.\\n  error NotAuthorized();\\n\\n  /// @notice Thrown if the account is not in anti-fraud list.\\n  error NotInAntiFraudList();\\n\\n  /// @notice Thrown if the caller is not the current oracle.\\n  error NotIsCurrentValidatorOracle();\\n\\n  /// @notice Thrown if there is not enough pool balance.\\n  error NotEnoughPoolBalance();\\n\\n  /// @notice Thrown if there is not enough balance on pool.\\n  error NotEnoughBalanceOnPool();\\n\\n  /// @notice Thrown if the pool is not found.\\n  error PoolNotFound();\\n\\n  /// @notice Thrown if the pool already exists.\\n  error PoolExists();\\n\\n  /// @notice Thrown if the listed in anti-fraud.\\n  error ListedInAntiFraud();\\n\\n  /// @notice Thrown if the router balance is greater than the withdrawal balance.\\n  error RouterAlreadyHaveBalance();\\n\\n  /// @notice Thrown if the router balance is lower than the withdrawal balance.\\n  error ShouldAnticipateWithdraw();\\n\\n  /// @notice Thrown if the delegations length should be zero.\\n  error ShouldBeZeroLength();\\n\\n  /// @notice Thrown if the validator oracle already exists.\\n  error ValidatorOracleExists();\\n\\n  /// @notice Thrown if the validator oracle is not found.\\n  error ValidatorOracleNotFound();\\n\\n  /// @notice Thrown if the withdrawal amount is zero.\\n  error ZeroAmount();\\n\\n  /// @notice Thrown if the address is the zero address.\\n  error ZeroAddress();\\n\\n  /// @notice Thrown if there is zero supply.\\n  error ZeroSupply();\\n\\n  /// @notice Thrown if the deposit amount is less than the minimum required.\\n  error LessThanMinimumDeposit();\\n\\n  /// @notice Thrown if the withdrawal pool limit is reached.\\n  error WithdrawalsPoolLimitReached();\\n\\n  /// @notice Thrown if the withdrawal validator limit is reached.\\n  error WithdrawalsValidatorLimitWasReached();\\n\\n  /// @notice Thrown if the withdrawal balance is zero.\\n  error WithdrawZeroBalance();\\n\\n  /// @notice Thrown if the amount is not greater than the pool balance.\\n  error WithdrawFromPool();\\n\\n  /// @notice Thrown if the validator already exists.\\n  error ValidatorExists();\\n\\n  /// @notice Configuration for the StakeTogether protocol.\\n  struct Config {\\n    uint256 blocksPerDay; /// Number of blocks per day.\\n    uint256 depositLimit; /// Maximum amount of deposit.\\n    uint256 maxDelegations; /// Maximum number of delegations.\\n    uint256 minDepositAmount; /// Minimum amount to deposit.\\n    uint256 minWithdrawAmount; /// Minimum amount to withdraw.\\n    uint256 poolSize; /// Size of the pool.\\n    uint256 validatorSize; /// Size of the validator.\\n    uint256 withdrawalPoolLimit; /// Maximum amount of pool withdrawal.\\n    uint256 withdrawalValidatorLimit; /// Maximum amount of validator withdrawal.\\n    uint256 withdrawDelay; /// Delay Blocks for withdrawal.\\n    uint256 withdrawBeaconDelay; /// Delay Blocks for beacon withdrawal.\\n    Feature feature; /// Additional features configuration.\\n  }\\n\\n  /// @notice Represents a delegation, including the pool address and shares.\\n  struct Delegation {\\n    address pool; /// Address of the delegated pool.\\n    uint256 percentage; /// Number of percentage in the delegation.\\n  }\\n\\n  /// @notice Toggleable features for the protocol.\\n  struct Feature {\\n    bool AddPool; /// Enable/disable pool addition.\\n    bool Deposit; /// Enable/disable deposits.\\n    bool WithdrawPool; /// Enable/disable pool withdrawals.\\n    bool WithdrawBeacon; /// Enable/disable validator withdrawals.\\n  }\\n\\n  /// @notice Represents the fee structure.\\n  struct Fee {\\n    uint256 value; /// Value of the fee.\\n    mapping(FeeRole => uint256) allocations; /// Allocation of fees among different roles.\\n  }\\n\\n  /// @notice Types of deposits available.\\n  enum DepositType {\\n    Donation, /// Donation type deposit.\\n    Pool /// Pool type deposit.\\n  }\\n\\n  /// @notice Types of withdrawals available.\\n  enum WithdrawType {\\n    Pool, /// Pool type withdrawal.\\n    Validator /// Validator type withdrawal.\\n  }\\n\\n  /// @notice Types of fees within the protocol.\\n  enum FeeType {\\n    Entry, /// Fee for entering a stake.\\n    Rewards, /// Fee for staking rewards.\\n    Pool, /// Fee for pool staking.\\n    Validator /// Fee for validator staking.\\n  }\\n\\n  /// @notice Different roles that are used in fee allocation\\n  enum FeeRole {\\n    Airdrop,\\n    Operator,\\n    StakeTogether,\\n    Sender\\n  }\\n\\n  /// @notice Emitted when a pool is added\\n  /// @param pool The address of the pool\\n  /// @param listed Indicates if the pool is listed\\n  /// @param social Indicates if the pool is social\\n  /// @param index Indicates if the pool is an index\\n  /// @param amount The amount associated with the pool\\n  event AddPool(address indexed pool, bool listed, bool social, bool index, uint256 amount);\\n\\n  /// @notice Emitted when a validator oracle is added\\n  /// @param account The address of the account\\n  event AddValidatorOracle(address indexed account);\\n\\n  /// @notice Emitted when withdraw is prioritized\\n  /// @param oracle The address of the oracle\\n  /// @param amount The amount for the validator\\n  event AnticipateWithdrawBeacon(address indexed oracle, uint256 amount);\\n\\n  /// @notice Emitted when shares are burned\\n  /// @param account The address of the account\\n  /// @param sharesAmount The amount of shares burned\\n  event BurnShares(address indexed account, uint256 sharesAmount);\\n\\n  /// @notice Emitted when a validator is created\\n  /// @param oracle The address of the oracle\\n  /// @param amount The amount for the validator\\n  /// @param publicKey The public key of the validator\\n  /// @param withdrawalCredentials The withdrawal credentials\\n  /// @param signature The signature\\n  /// @param depositDataRoot The deposit data root\\n  event AddValidator(\\n    address indexed oracle,\\n    uint256 amount,\\n    bytes publicKey,\\n    bytes withdrawalCredentials,\\n    bytes signature,\\n    bytes32 depositDataRoot\\n  );\\n\\n  /// @notice Emitted when a base deposit is made\\n  /// @param to The address to deposit to\\n  /// @param amount The deposit amount\\n  /// @param depositType The type of deposit (Donation, Pool)\\n  /// @param pool The address of the pool\\n  /// @param referral The address of the referral\\n  event DepositBase(\\n    address indexed to,\\n    uint256 amount,\\n    DepositType depositType,\\n    address indexed pool,\\n    bytes indexed referral\\n  );\\n\\n  /// @notice Emitted when the deposit limit is reached\\n  /// @param sender The address of the sender\\n  /// @param amount The amount deposited\\n  event DepositLimitWasReached(address indexed sender, uint256 amount);\\n\\n  /// @notice Emitted when rewards are minted\\n  /// @param to The address to mint to\\n  /// @param sharesAmount The amount of shares minted\\n  /// @param feeType The type of fee (e.g., StakeEntry, ProcessStakeRewards)\\n  /// @param feeRole The role associated with the fee\\n  event MintFeeShares(\\n    address indexed to,\\n    uint256 sharesAmount,\\n    FeeType indexed feeType,\\n    FeeRole indexed feeRole\\n  );\\n\\n  /// @notice Emitted when shares are minted\\n  /// @param to The address to mint to\\n  /// @param sharesAmount The amount of shares minted\\n  event MintShares(address indexed to, uint256 sharesAmount);\\n\\n  /// @notice Emitted when the next validator oracle is set\\n  /// @param index The index of the oracle\\n  /// @param account The address of the account\\n  event NextValidatorOracle(uint256 index, address indexed account);\\n\\n  /// @dev This event emits when rewards are processed for staking, indicating the amount and the number of shares.\\n  /// @param amount The total amount of rewards that have been processed for staking.\\n  /// @param sharesAmount The total number of shares associated with the processed staking rewards.\\n  event ProcessStakeRewards(uint256 indexed amount, uint256 indexed sharesAmount);\\n\\n  /// @dev This event emits when a validator's stake has been processed.\\n  /// @param account The address of the account whose stake as a validator has been processed.\\n  /// @param amount The amount the account staked that has been processed.\\n  event ProcessStakeValidator(address indexed account, uint256 amount);\\n\\n  /// @notice Emitted when Ether is received\\n  /// @param amount The amount of Ether received\\n  event ReceiveEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when a pool is removed\\n  /// @param pool The address of the pool\\n  event RemovePool(address indexed pool);\\n\\n  /// @notice Emitted when a validator oracle is removed\\n  /// @param account The address of the account\\n  event RemoveValidatorOracle(address indexed account);\\n\\n  /// @notice Emitted when the beacon balance is set\\n  /// @param amount The amount set for the beacon balance\\n  event SetBeaconBalance(uint256 indexed amount);\\n\\n  /// @notice Emitted when a user's anti-fraud status is changed\\n  /// @param sender The address that is executing\\n  /// @param account The address of the account\\n  /// @param isListed The new anti-fraud status of the account (true if listed, false otherwise)\\n  event SetAntiFraudStatus(address indexed sender, address indexed account, bool isListed);\\n\\n  /// @notice Emitted when the configuration is set\\n  /// @param config The configuration struct\\n  event SetConfig(Config indexed config);\\n\\n  /// @notice Emitted when a fee is set\\n  /// @param feeType The type of fee being set\\n  /// @param value The value of the fee\\n  /// @param allocations The allocations for the fee\\n  event SetFee(FeeType indexed feeType, uint256 value, uint256[] allocations);\\n\\n  /// @notice Emitted when a fee address is set\\n  /// @param role The role associated with the fee\\n  /// @param account The address of the account\\n  event SetFeeAddress(FeeRole indexed role, address indexed account);\\n\\n  /// @notice Emitted when the router is set\\n  /// @param router The address of the router\\n  event SetRouter(address indexed router);\\n\\n  /// @notice Emitted when the StakeTogether address is set\\n  /// @param stakeTogether The address of StakeTogether\\n  event SetStakeTogether(address indexed stakeTogether);\\n\\n  /// @notice Emitted when the validator size is set\\n  /// @param newValidatorSize The new size for the validator\\n  event SetValidatorSize(uint256 indexed newValidatorSize);\\n\\n  /// @notice Emitted when the withdraw balance is set\\n  /// @param amount The amount set for the withdraw balance\\n  event SetWithdrawBalance(uint256 indexed amount);\\n\\n  /// @notice Emitted when the withdrawal credentials are set\\n  /// @param withdrawalCredentials The withdrawal credentials bytes\\n  event SetWithdrawalsCredentials(bytes indexed withdrawalCredentials);\\n\\n  /// @notice Emitted when shares are transferred\\n  /// @param from The address transferring from\\n  /// @param to The address transferring to\\n  /// @param sharesAmount The amount of shares transferred\\n  event TransferShares(address indexed from, address indexed to, uint256 sharesAmount);\\n\\n  /// @notice Emitted when delegations are updated\\n  /// @param account The address of the account\\n  /// @param delegations The delegation array\\n  event UpdateDelegations(address indexed account, Delegation[] delegations);\\n\\n  /// @notice Emitted when a base withdrawal is made\\n  /// @param account The address withdrawing\\n  /// @param amount The withdrawal amount\\n  /// @param withdrawType The type of withdrawal\\n  /// @param pool The address of the pool\\n  event WithdrawBase(\\n    address indexed account,\\n    uint256 amount,\\n    WithdrawType withdrawType,\\n    address indexed pool\\n  );\\n\\n  /// @notice Emitted when the withdrawal limit is reached\\n  /// @param sender The address of the sender\\n  /// @param amount The amount withdrawn\\n  event WithdrawalsLimitWasReached(address indexed sender, uint256 amount, WithdrawType withdrawType);\\n\\n  /// @notice Pauses the contract, preventing certain actions.\\n  /// @dev Only callable by the admin role.\\n  function pause() external;\\n\\n  /// @notice Unpauses the contract, allowing actions to resume.\\n  /// @dev Only callable by the admin role.\\n  function unpause() external;\\n\\n  /// @notice Receive function to accept incoming ETH transfers.\\n  receive() external payable;\\n\\n  /// @notice Sets the configuration for the Stake Together Protocol.\\n  /// @dev Only callable by the admin role.\\n  /// @param _config Configuration settings to be applied.\\n  function setConfig(Config memory _config) external;\\n\\n  /// @notice Returns the total supply of the pool (contract balance + beacon balance).\\n  /// @return Total supply value.\\n  function totalSupply() external view returns (uint256);\\n\\n  /// @notice Calculates the shares amount by wei.\\n  /// @param _account The address of the account.\\n  /// @return Balance value of the given account.\\n  function balanceOf(address _account) external view returns (uint256);\\n\\n  /// @notice Retrieves the current balance of the beacon.\\n  /// @dev This function returns the current stored value within the beacon.\\n  /// @return The balance held within the beacon in uint256 format.\\n  function beaconBalance() external view returns (uint256);\\n\\n  /// @notice Retrieves the available balance for withdrawal.\\n  /// @dev This function returns the balance that is currently available for withdrawal.\\n  /// @return The available balance for withdrawal in uint256 format.\\n  function withdrawBalance() external view returns (uint256);\\n\\n  /// @notice Calculates the wei amount by shares.\\n  /// @param _sharesAmount Amount of shares.\\n  /// @return Equivalent amount in wei.\\n  function weiByShares(uint256 _sharesAmount) external view returns (uint256);\\n\\n  /// @notice Calculates the shares amount by wei.\\n  /// @param _amount Amount in wei.\\n  /// @return Equivalent amount in shares.\\n  function sharesByWei(uint256 _amount) external view returns (uint256);\\n\\n  /// @notice Transfers an amount of wei to the specified address.\\n  /// @param _to The address to transfer to.\\n  /// @param _amount The amount to be transferred.\\n  /// @return True if the transfer was successful.\\n  function transfer(address _to, uint256 _amount) external returns (bool);\\n\\n  /// @notice Transfers tokens from one address to another using an allowance mechanism.\\n  /// @param _from Address to transfer from.\\n  /// @param _to Address to transfer to.\\n  /// @param _amount Amount of tokens to transfer.\\n  /// @return A boolean value indicating whether the operation succeeded.\\n  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\\n\\n  /// @notice Returns the remaining number of tokens that an spender is allowed to spend on behalf of a token owner.\\n  /// @param _account Address of the token owner.\\n  /// @param _spender Address of the spender.\\n  /// @return A uint256 value representing the remaining number of tokens available for the spender.\\n  function allowance(address _account, address _spender) external view returns (uint256);\\n\\n  /// @notice Sets the amount `_amount` as allowance of `_spender` over the caller's tokens.\\n  /// @param _spender Address of the spender.\\n  /// @param _amount Amount of allowance to be set.\\n  /// @return A boolean value indicating whether the operation succeeded.\\n  function approve(address _spender, uint256 _amount) external returns (bool);\\n\\n  /// @notice Deposits into the pool with specific delegations.\\n  /// @param _pool the address of the pool.\\n  /// @param _referral The referral address.\\n  function depositPool(address _pool, bytes calldata _referral) external payable;\\n\\n  /// @notice Deposits a donation to the specified address.\\n  /// @param _to The address to deposit to.\\n  /// @param _pool the address of the pool.\\n  /// @param _referral The referral address.\\n  function depositDonation(address _to, address _pool, bytes calldata _referral) external payable;\\n\\n  /// @notice Withdraws from the pool with specific delegations and transfers the funds to the sender.\\n  /// @param _amount The amount to withdraw.\\n  /// @param _pool the address of the pool.\\n  function withdrawPool(uint256 _amount, address _pool) external;\\n\\n  /// @notice Withdraws from the validators with specific delegations and mints tokens to the sender.\\n  /// @param _amount The amount to withdraw.\\n  /// @param _pool the address of the pool.\\n  function withdrawBeacon(uint256 _amount, address _pool) external;\\n\\n  /// @notice Get the next withdraw block for account\\n  /// @param _account the address of the account.\\n  function getWithdrawBlock(address _account) external view returns (uint256);\\n\\n  /// @notice Get the next withdraw beacon block for account\\n  /// @param _account the address of the account.\\n  function getWithdrawBeaconBlock(address _account) external view returns (uint256);\\n\\n  /// @notice Adds an address to the anti-fraud list.\\n  /// @dev Callable only by accounts with the ANTI_FRAUD_SENTINEL_ROLE or ANTI_FRAUD_MANAGER_ROLE.\\n  /// Reverts if the provided address is the zero address or if the sender is not authorized.\\n  /// @param _account The address to be added to the anti-fraud list.\\n  function addToAntiFraud(address _account) external;\\n\\n  /// @notice Removes an address from the anti-fraud list.\\n  /// @dev Callable only by accounts with the ANTI_FRAUD_MANAGER_ROLE.\\n  /// Reverts if the provided address is the zero address, not in the anti-fraud list, or if the sender is not authorized.\\n  /// @param _account The address to be removed from the anti-fraud list.\\n  function removeFromAntiFraud(address _account) external;\\n\\n  /// @notice Check if an address is listed in the anti-fraud list.\\n  /// @param _account The address to be checked.\\n  /// @return true if the address is in the anti-fraud list, false otherwise.\\n  function isListedInAntiFraud(address _account) external view returns (bool);\\n\\n  /// @notice Adds a permissionless pool with a specified address and listing status if feature enabled.\\n  /// @param _pool Address of the new pool.\\n  /// @param _listed True if the pool is listed.\\n  /// @param _social True if the pool is social.\\n  /// @param _index True if the pool is an index.\\n  function addPool(address _pool, bool _listed, bool _social, bool _index) external payable;\\n\\n  /// @notice Removes a pool by its address.\\n  /// @param _pool The address of the pool to remove.\\n  function removePool(address _pool) external;\\n\\n  /// @notice Updates delegations for the sender's address.\\n  /// @param _delegations The array of delegations to update.\\n  function updateDelegations(Delegation[] memory _delegations) external;\\n\\n  /// @notice Adds a new validator oracle by its address.\\n  /// @param _account The address of the validator oracle to add.\\n  function addValidatorOracle(address _account) external;\\n\\n  /// @notice Removes a validator oracle by its address.\\n  /// @param _account The address of the validator oracle to remove.\\n  function removeValidatorOracle(address _account) external;\\n\\n  /// @notice Checks if an address is a validator oracle.\\n  /// @param _account The address to check.\\n  /// @return True if the address is a validator oracle, false otherwise.\\n  function isValidatorOracle(address _account) external view returns (bool);\\n\\n  /// @notice Forces the selection of the next validator oracle.\\n  function forceNextValidatorOracle() external;\\n\\n  /// @notice Sets the beacon balance to the specified amount.\\n  /// @param _amount The amount to set as the beacon balance.\\n  /// @dev Only the router address can call this function.\\n  function setBeaconBalance(uint256 _amount) external payable;\\n\\n  /// @notice Sets the pending withdraw balance to the specified amount.\\n  /// @param _amount The amount to set as the pending withdraw balance.\\n  /// @dev Only the router address can call this function.\\n  function setWithdrawBalance(uint256 _amount) external payable;\\n\\n  /// @notice Initiates a transfer to anticipate a validator's withdrawal.\\n  /// @dev Only a valid validator oracle can initiate this anticipation request.\\n  /// This function also checks the balance constraints before processing.\\n  function anticipateWithdrawBeacon() external;\\n\\n  /// @notice Creates a new validator with the given parameters.\\n  /// @param _publicKey The public key of the validator.\\n  /// @param _signature The signature of the validator.\\n  /// @param _depositDataRoot The deposit data root for the validator.\\n  /// @dev Only a valid validator oracle can call this function.\\n  function addValidator(\\n    bytes calldata _publicKey,\\n    bytes calldata _signature,\\n    bytes32 _depositDataRoot\\n  ) external;\\n\\n  /// @notice Function to claim rewards by transferring shares, accessible only by the airdrop fee address.\\n  /// @param _account Address to transfer the claimed rewards to.\\n  /// @param _sharesAmount Amount of shares to claim as rewards.\\n  function claimAirdrop(address _account, uint256 _sharesAmount) external;\\n\\n  /// @notice Returns an array of fee roles.\\n  /// @return roles An array of FeeRole.\\n  function getFeesRoles() external pure returns (FeeRole[4] memory);\\n\\n  /// @notice Sets the fee address for a given role.\\n  /// @param _role The role for which the address will be set.\\n  /// @param _address The address to set.\\n  /// @dev Only an admin can call this function.\\n  function setFeeAddress(FeeRole _role, address payable _address) external;\\n\\n  /// @notice Gets the fee address for a given role.\\n  /// @param _role The role for which the address will be retrieved.\\n  /// @return The address associated with the given role.\\n  function getFeeAddress(FeeRole _role) external view returns (address);\\n\\n  /// @notice Sets the fee for a given fee type.\\n  /// @param _feeType The type of fee to set.\\n  /// @param _value The value of the fee.\\n  /// @param _allocations The allocations for the fee.\\n  /// @dev Only an admin can call this function.\\n  function setFee(FeeType _feeType, uint256 _value, uint256[] calldata _allocations) external;\\n\\n  /// @notice Process staking rewards and distributes the rewards based on shares.\\n  /// @param _sharesAmount The amount of shares related to the staking rewards.\\n  /// @dev Requires the caller to be the router contract.\\n  function processFeeRewards(uint256 _sharesAmount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawals.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 Stake Together Labs <legal@staketogether.org>\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.22;\\n\\n/// @title Interface for Validators Withdrawals\\n/// @notice A contract that represent the validator withdrawal functionality\\n/// @custom:security-contact security@staketogether.org\\ninterface IWithdrawals {\\n  /// @notice This error is thrown when use try withdraw before the beacon delay.\\n  error EarlyBeaconTransfer();\\n\\n  /// @notice Thrown if the operation is a FlashLoan.\\n  error FlashLoan();\\n\\n  /// @notice This error is thrown when the sender has insufficient STW balance to perform a transaction.\\n  error InsufficientStwBalance();\\n\\n  /// @notice This error is thrown when the contract has insufficient ETH balance to perform a transaction.\\n  error InsufficientEthBalance();\\n\\n  /// @notice Thrown if the listed in anti-fraud.\\n  error ListedInAntiFraud();\\n\\n  /// @notice This error is thrown when there is no extra amount of ETH available to transfer.\\n  error NoExtraAmountAvailable();\\n\\n  /// @notice This error is thrown when an action is attempted by an address other than the router.\\n  error OnlyRouter();\\n\\n  /// @notice This error is thrown when an action is attempted by an address other than the stakeTogether contract.\\n  error OnlyStakeTogether();\\n\\n  /// @notice This error is thrown when trying to set the router contract that has already been set.\\n  error RouterAlreadySet();\\n\\n  /// @notice This error is thrown when trying to set the stakeTogether address that has already been set.\\n  error StakeTogetherAlreadySet();\\n\\n  /// @notice Thrown if the shares amount being claimed is zero.\\n  error ZeroAmount();\\n\\n  /// @notice Thrown if the address trying to make a claim is the zero address.\\n  error ZeroAddress();\\n\\n  /// @notice Emitted when Ether is received\\n  /// @param amount The amount of Ether received\\n  event ReceiveEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when Ether is received from Router\\n  /// @param amount The amount of Ether received\\n  event ReceiveWithdrawEther(uint256 indexed amount);\\n\\n  /// @notice Emitted when the Router address is set\\n  /// @param router The address of the StakeTogether contract\\n  event SetRouter(address indexed router);\\n\\n  /// @notice Emitted when the StakeTogether address is set\\n  /// @param stakeTogether The address of the StakeTogether contract\\n  event SetStakeTogether(address indexed stakeTogether);\\n\\n  /// @notice Emitted when a user withdraws funds\\n  /// @param user The address of the user who is withdrawing\\n  /// @param amount The amount being withdrawn\\n  event Withdraw(address indexed user, uint256 amount);\\n\\n  /// @notice Initialization function for Withdrawals contract.\\n  function initialize() external;\\n\\n  /// @notice Pauses withdrawals.\\n  /// @dev Only callable by the admin role.\\n  function pause() external;\\n\\n  /// @notice Unpauses withdrawals.\\n  /// @dev Only callable by the admin role.\\n  function unpause() external;\\n\\n  /// @notice Receive function to accept incoming ETH transfers.\\n  receive() external payable;\\n\\n  /// @notice Allows the router to send ETH to the contract.\\n  /// @dev This function can only be called by the router.\\n  function receiveWithdrawEther() external payable;\\n\\n  /// @notice Transfers any extra amount of ETH in the contract to the StakeTogether fee address.\\n  /// @dev Only callable by the admin role and requires that extra amount exists in the contract balance.\\n  function transferExtraAmount() external;\\n\\n  /// @notice Sets the StakeTogether contract address.\\n  /// @param _stakeTogether The address of the new StakeTogether contract.\\n  /// @dev Only callable by the admin role.\\n  function setStakeTogether(address _stakeTogether) external;\\n\\n  /// @notice Sets the Router contract address.\\n  /// @param _router The address of the router.\\n  /// @dev Only callable by the admin role.\\n  function setRouter(address _router) external;\\n\\n  /// @notice Mints tokens to a specific address.\\n  /// @param _to Address to receive the minted tokens.\\n  /// @param _amount Amount of tokens to mint.\\n  /// @dev Only callable by the StakeTogether contract.\\n  function mint(address _to, uint256 _amount) external;\\n\\n  /// @notice Withdraws the specified amount of ETH, burning tokens in exchange.\\n  /// @param _amount Amount of ETH to withdraw.\\n  /// @dev The caller must have a balance greater or equal to the amount, and the contract must have sufficient ETH balance.\\n  function withdraw(uint256 _amount) external;\\n\\n  /// @notice Checks if the contract is ready to withdraw the specified amount.\\n  /// @param _amount Amount of ETH to check.\\n  /// @return A boolean indicating if the contract has sufficient balance to withdraw the specified amount.\\n  function isWithdrawReady(uint256 _amount) external view returns (bool);\\n\\n  /// @notice Transfers an amount of wei to the specified address.\\n  /// @param _to The address to transfer to.\\n  /// @param _amount The amount to be transferred.\\n  /// @return True if the transfer was successful.\\n  function transfer(address _to, uint256 _amount) external returns (bool);\\n\\n  /// @notice Transfers tokens from one address to another using an allowance mechanism.\\n  /// @param _from Address to transfer from.\\n  /// @param _to Address to transfer to.\\n  /// @param _amount Amount of tokens to transfer.\\n  /// @return A boolean value indicating whether the operation succeeded.\\n  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/versions/StakeTogetherV2.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2023 Stake Together Labs <legal@staketogether.org>\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.22;\\n\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '../interfaces/IDepositContract.sol';\\nimport '../interfaces/IAirdrop.sol';\\nimport '../interfaces/IRouter.sol';\\nimport '../interfaces/IStakeTogether.sol';\\nimport '../interfaces/IWithdrawals.sol';\\n\\n/// @title StakeTogether Pool Contract\\n/// @notice The StakeTogether contract is the primary entry point for interaction with the StakeTogether protocol.\\n/// It provides functionalities for staking, withdrawals, fee management, and interactions with pools and validators.\\n/// @custom:security-contact security@staketogether.org\\ncontract StakeTogetherV2 is\\n  Initializable,\\n  ERC20Upgradeable,\\n  ERC20BurnableUpgradeable,\\n  PausableUpgradeable,\\n  AccessControlUpgradeable,\\n  ERC20PermitUpgradeable,\\n  UUPSUpgradeable,\\n  ReentrancyGuardUpgradeable,\\n  IStakeTogether\\n{\\n  bytes32 public constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE'); /// Role for managing upgrades.\\n  bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE'); /// Role for administration.\\n  bytes32 public constant POOL_MANAGER_ROLE = keccak256('POOL_MANAGER_ROLE'); /// Role for managing pools.\\n  bytes32 public constant VALIDATOR_ORACLE_ROLE = keccak256('VALIDATOR_ORACLE_ROLE'); /// Role for managing validator oracles.\\n  bytes32 public constant VALIDATOR_ORACLE_MANAGER_ROLE = keccak256('VALIDATOR_ORACLE_MANAGER_ROLE'); /// Role for managing validator oracle managers.\\n  bytes32 public constant VALIDATOR_ORACLE_SENTINEL_ROLE = keccak256('VALIDATOR_ORACLE_SENTINEL_ROLE'); /// Role for sentinel functionality in validator oracle management.\\n  bytes32 public constant ANTI_FRAUD_MANAGER_ROLE = keccak256('ANTI_FRAUD_MANAGER_ROLE'); // Role for  anti-fraud managers.\\n  bytes32 public constant ANTI_FRAUD_SENTINEL_ROLE = keccak256('ANTI_FRAUD_SENTINEL_ROLE'); // Role for sentinel functionality in anti-fraud management.\\n\\n  uint256 public version; /// Contract version.\\n\\n  IAirdrop public airdrop; /// Airdrop contract instance.\\n  IDepositContract public deposit; /// Deposit contract interface.\\n  IRouter public router; /// Address of the contract router.\\n  IWithdrawals public withdrawals; /// Withdrawals contract instance.\\n\\n  bytes public withdrawalCredentials; /// Credentials for withdrawals.\\n  uint256 public beaconBalance; /// Beacon balance (includes transient Beacon balance on router).\\n  uint256 public withdrawBalance; /// Pending withdraw balance to be withdrawn from router.\\n\\n  Config public config; /// Configuration settings for the protocol.\\n\\n  mapping(address => uint256) public shares; /// Mapping of addresses to their shares.\\n  uint256 public totalShares; /// Total number of shares.\\n  mapping(address => mapping(address => uint256)) private allowances; /// Allowances mapping.\\n\\n  mapping(address => uint256) private lastOperationBlock; // Mapping of addresses to their last operation block.\\n  mapping(address => uint256) private nextWithdrawBlock; // Mapping the next block for withdraw\\n  mapping(address => uint256) private nextWithdrawBeaconBlock; // Mapping the next block for withdraw from beacon\\n  uint256 public lastResetBlock; /// Block number of the last reset.\\n  uint256 public totalDeposited; /// Total amount deposited.\\n  uint256 public totalWithdrawnPool; /// Total amount withdrawn pool.\\n  uint256 public totalWithdrawnValidator; /// Total amount withdrawn validator.\\n\\n  mapping(address => bool) public pools; /// Mapping of pool addresses.\\n\\n  address[] private validatorsOracle; /// List of validator oracles.\\n  mapping(address => uint256) private validatorsOracleIndices; /// Mapping of validator oracle indices.\\n  uint256 public currentOracleIndex; /// Current index of the oracle.\\n\\n  mapping(bytes => bool) public validators; /// Mapping of validators.\\n\\n  mapping(FeeRole => address payable) private feesRole; /// Mapping of fee roles to addresses.\\n  mapping(FeeType => Fee) private fees; /// Mapping of fee types to fee details.\\n\\n  mapping(address => bool) private antiFraudList; /// Mapping of anti-fraud addresses.\\n\\n  /// @custom:oz-upgrades-unsafe-allow constructor\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /// @notice Stake Together Pool Initialization\\n  function initializeV2() public onlyRole(UPGRADER_ROLE) {\\n    version = 2;\\n  }\\n\\n  /// @notice Pauses the contract, preventing certain actions.\\n  /// @dev Only callable by the admin role.\\n  function pause() external onlyRole(ADMIN_ROLE) {\\n    _pause();\\n  }\\n\\n  /// @notice Unpauses the contract, allowing actions to resume.\\n  /// @dev Only callable by the admin role.\\n  function unpause() external onlyRole(ADMIN_ROLE) {\\n    _unpause();\\n  }\\n\\n  /// @notice Internal function to authorize an upgrade.\\n  /// @dev Only callable by the upgrader role.\\n  /// @param _newImplementation Address of the new contract implementation.\\n  function _authorizeUpgrade(address _newImplementation) internal override onlyRole(UPGRADER_ROLE) {}\\n\\n  /// @notice Receive function to accept incoming ETH transfers.\\n  /// @dev Non-reentrant to prevent re-entrancy attacks.\\n  receive() external payable {\\n    emit ReceiveEther(msg.value);\\n  }\\n\\n  modifier nonFlashLoan() {\\n    if (block.number <= lastOperationBlock[msg.sender]) {\\n      revert FlashLoan();\\n    }\\n    _;\\n  }\\n\\n  /************\\n   ** CONFIG **\\n   ************/\\n\\n  /// @notice Sets the configuration for the Stake Together Protocol.\\n  /// @dev Only callable by the admin role.\\n  /// @param _config Configuration settings to be applied.\\n  function setConfig(Config memory _config) external onlyRole(ADMIN_ROLE) {\\n    if (_config.poolSize < config.validatorSize) revert InvalidSize();\\n    config = _config;\\n    emit SetConfig(_config);\\n  }\\n\\n  /************\\n   ** SHARES **\\n   ************/\\n\\n  /// @notice Returns the total supply of the pool (contract balance + beacon balance).\\n  /// @return Total supply value.\\n  function totalSupply() public view override(ERC20Upgradeable, IStakeTogether) returns (uint256) {\\n    return address(this).balance + beaconBalance - withdrawBalance;\\n  }\\n\\n  ///  @notice Calculates the shares amount by wei.\\n  /// @param _account The address of the account.\\n  /// @return Balance value of the given account.\\n  function balanceOf(\\n    address _account\\n  ) public view override(ERC20Upgradeable, IStakeTogether) returns (uint256) {\\n    return weiByShares(shares[_account]);\\n  }\\n\\n  /// @notice Calculates the wei amount by shares.\\n  /// @param _sharesAmount Amount of shares.\\n  /// @return Equivalent amount in wei.\\n  function weiByShares(uint256 _sharesAmount) public view returns (uint256) {\\n    return Math.mulDiv(_sharesAmount, totalSupply(), totalShares, Math.Rounding.Ceil);\\n  }\\n\\n  /// @notice Calculates the shares amount by wei.\\n  /// @param _amount Amount in wei.\\n  /// @return Equivalent amount in shares.\\n  function sharesByWei(uint256 _amount) public view returns (uint256) {\\n    return Math.mulDiv(_amount, totalShares, totalSupply());\\n  }\\n\\n  /// @notice Transfers an amount of wei to the specified address.\\n  /// @param _to The address to transfer to.\\n  /// @param _amount The amount to be transferred.\\n  /// @return True if the transfer was successful.\\n  function transfer(\\n    address _to,\\n    uint256 _amount\\n  ) public override(ERC20Upgradeable, IStakeTogether) returns (bool) {\\n    if (isListedInAntiFraud(msg.sender)) revert ListedInAntiFraud();\\n    if (isListedInAntiFraud(_to)) revert ListedInAntiFraud();\\n    _transfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Transfers tokens from one address to another using an allowance mechanism.\\n  /// @param _from Address to transfer from.\\n  /// @param _to Address to transfer to.\\n  /// @param _amount Amount of tokens to transfer.\\n  /// @return A boolean value indicating whether the operation succeeded.\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) public override(ERC20Upgradeable, IStakeTogether) returns (bool) {\\n    if (isListedInAntiFraud(_from)) revert ListedInAntiFraud();\\n    if (isListedInAntiFraud(_to)) revert ListedInAntiFraud();\\n    if (isListedInAntiFraud(msg.sender)) revert ListedInAntiFraud();\\n    _spendAllowance(_from, msg.sender, _amount);\\n    _transfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Transfers an amount of wei from one address to another.\\n  /// @param _from The address to transfer from.\\n  /// @param _to The address to transfer to.\\n  /// @param _amount The amount to be transferred.\\n  function _update(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal override nonReentrant nonFlashLoan whenNotPaused {\\n    if (block.number < nextWithdrawBlock[msg.sender]) revert EarlyTransfer();\\n    lastOperationBlock[msg.sender] = block.number;\\n    uint256 _sharesToTransfer = sharesByWei(_amount);\\n    _transferShares(_from, _to, _sharesToTransfer);\\n    emit Transfer(_from, _to, _amount);\\n  }\\n\\n  /// @notice Internal function to handle the transfer of shares.\\n  /// @param _from The address to transfer from.\\n  /// @param _to The address to transfer to.\\n  /// @param _sharesAmount The number of shares to be transferred.\\n  function _transferShares(address _from, address _to, uint256 _sharesAmount) private whenNotPaused {\\n    if (isListedInAntiFraud(_from)) revert ListedInAntiFraud();\\n    if (isListedInAntiFraud(_to)) revert ListedInAntiFraud();\\n    if (_from == address(0)) revert ZeroAddress();\\n    if (_to == address(0)) revert ZeroAddress();\\n    if (_sharesAmount > shares[_from]) revert InsufficientShares();\\n    shares[_from] -= _sharesAmount;\\n    shares[_to] += _sharesAmount;\\n    emit TransferShares(_from, _to, _sharesAmount);\\n  }\\n\\n  /// @notice Returns the remaining number of tokens that an spender is allowed to spend on behalf of a token owner.\\n  /// @param _account Address of the token owner.\\n  /// @param _spender Address of the spender.\\n  /// @return A uint256 value representing the remaining number of tokens available for the spender.\\n  function allowance(\\n    address _account,\\n    address _spender\\n  ) public view override(ERC20Upgradeable, IStakeTogether) returns (uint256) {\\n    return allowances[_account][_spender];\\n  }\\n\\n  /// @notice Sets the amount `_amount` as allowance of `_spender` over the caller's tokens.\\n  /// @param _spender Address of the spender.\\n  /// @param _amount Amount of allowance to be set.\\n  /// @return A boolean value indicating whether the operation succeeded.\\n  function approve(\\n    address _spender,\\n    uint256 _amount\\n  ) public override(ERC20Upgradeable, IStakeTogether) returns (bool) {\\n    _approve(msg.sender, _spender, _amount, true);\\n    return true;\\n  }\\n\\n  /// @notice Internal function to set the approval amount for a given spender and owner.\\n  /// @param _account Address of the token owner.\\n  /// @param _spender Address of the spender.\\n  /// @param _amount Amount of allowance to be set.\\n  function _approve(\\n    address _account,\\n    address _spender,\\n    uint256 _amount,\\n    bool emitEvent\\n  ) internal override {\\n    if (_account == address(0)) revert ZeroAddress();\\n    if (_spender == address(0)) revert ZeroAddress();\\n    allowances[_account][_spender] = _amount;\\n    if (emitEvent) {\\n      emit Approval(_account, _spender, _amount);\\n    }\\n  }\\n\\n  /// @notice Internal function to deduct the allowance for a given spender, if any.\\n  /// @param _account Address of the token owner.\\n  /// @param _spender Address of the spender.\\n  /// @param _amount Amount to be deducted from the allowance.\\n  function _spendAllowance(address _account, address _spender, uint256 _amount) internal override {\\n    uint256 currentAllowance = allowances[_account][_spender];\\n    if (currentAllowance != ~uint256(0)) {\\n      if (currentAllowance < _amount) revert InsufficientAllowance();\\n      _approve(_account, _spender, currentAllowance - _amount, true);\\n    }\\n  }\\n\\n  /// @notice Internal function to mint shares to a given address.\\n  /// @param _to Address to mint shares to.\\n  /// @param _sharesAmount Amount of shares to mint.\\n  function _mintShares(address _to, uint256 _sharesAmount) private whenNotPaused {\\n    if (_to == address(0)) revert ZeroAddress();\\n    shares[_to] += _sharesAmount;\\n    totalShares += _sharesAmount;\\n    emit MintShares(_to, _sharesAmount);\\n    emit Transfer(address(0), _to, weiByShares(_sharesAmount));\\n  }\\n\\n  /// @notice Internal function to burn shares from a given address.\\n  /// @param _account Address to burn shares from.\\n  /// @param _sharesAmount Amount of shares to burn.\\n  function _burnShares(address _account, uint256 _sharesAmount) private whenNotPaused {\\n    if (_account == address(0)) revert ZeroAddress();\\n    if (_sharesAmount > shares[_account]) revert InsufficientShares();\\n    shares[_account] -= _sharesAmount;\\n    totalShares -= _sharesAmount;\\n    emit BurnShares(_account, _sharesAmount);\\n    emit Transfer(_account, address(0), weiByShares(_sharesAmount));\\n  }\\n\\n  /***********\\n   ** STAKE **\\n   ***********/\\n\\n  /// @notice Deposits the base amount to the specified address.\\n  /// @param _to The address to deposit to.\\n  /// @param _depositType The type of deposit (Pool or Donation).\\n  /// @param _referral The referral address.\\n  function _depositBase(\\n    address _to,\\n    DepositType _depositType,\\n    address _pool,\\n    bytes calldata _referral\\n  ) private {\\n    if (!config.feature.Deposit) revert FeatureDisabled();\\n    if (!(totalSupply() > 0)) revert ZeroSupply();\\n    if (antiFraudList[_to]) revert ListedInAntiFraud();\\n    if (msg.value < config.minDepositAmount) revert LessThanMinimumDeposit();\\n    if (!pools[_pool]) revert PoolNotFound();\\n\\n    _resetLimits();\\n    totalDeposited += msg.value;\\n    lastOperationBlock[msg.sender] = block.number;\\n    nextWithdrawBlock[msg.sender] = block.number + config.withdrawDelay;\\n\\n    if (totalDeposited > config.depositLimit) {\\n      emit DepositLimitWasReached(_to, msg.value);\\n      revert DepositLimitReached();\\n    }\\n\\n    emit DepositBase(_to, msg.value, _depositType, _pool, _referral);\\n    _processFeeEntry(_to, msg.value);\\n  }\\n\\n  /// @notice Deposits into the pool with specific delegations.\\n  /// @param _pool The address of the pool to deposit to.\\n  /// @param _referral The referral address.\\n  function depositPool(\\n    address _pool,\\n    bytes calldata _referral\\n  ) external payable nonReentrant nonFlashLoan whenNotPaused {\\n    _depositBase(msg.sender, DepositType.Pool, _pool, _referral);\\n  }\\n\\n  /// @notice Deposits a donation to the specified address.\\n  /// @param _to The address to deposit to.\\n  /// @param _referral The referral address.\\n  function depositDonation(\\n    address _to,\\n    address _pool,\\n    bytes calldata _referral\\n  ) external payable nonReentrant nonFlashLoan whenNotPaused {\\n    _depositBase(_to, DepositType.Donation, _pool, _referral);\\n  }\\n\\n  /// @notice Withdraws the base amount with the specified withdrawal type.\\n  /// @param _amount The amount to withdraw.\\n  /// @param _withdrawType The type of withdrawal (Pool or Validator).\\n  function _withdrawBase(uint256 _amount, WithdrawType _withdrawType, address _pool) private {\\n    if (antiFraudList[msg.sender]) revert ListedInAntiFraud();\\n    if (_amount == 0) revert ZeroAmount();\\n    if (_amount > balanceOf(msg.sender)) revert InsufficientAccountBalance();\\n    if (_amount < config.minWithdrawAmount) revert LessThanMinimumWithdraw();\\n    if (block.number < nextWithdrawBlock[msg.sender]) revert EarlyTransfer();\\n\\n    _resetLimits();\\n    lastOperationBlock[msg.sender] = block.number;\\n\\n    if (_withdrawType == WithdrawType.Pool) {\\n      totalWithdrawnPool += _amount;\\n      if (totalWithdrawnPool > config.withdrawalPoolLimit) {\\n        emit WithdrawalsLimitWasReached(msg.sender, _amount, _withdrawType);\\n        revert WithdrawalsPoolLimitReached();\\n      }\\n    } else {\\n      totalWithdrawnValidator += _amount;\\n      if (totalWithdrawnValidator > config.withdrawalValidatorLimit) {\\n        emit WithdrawalsLimitWasReached(msg.sender, _amount, _withdrawType);\\n        revert WithdrawalsValidatorLimitWasReached();\\n      }\\n    }\\n\\n    emit WithdrawBase(msg.sender, _amount, _withdrawType, _pool);\\n    uint256 sharesToBurn = Math.mulDiv(_amount, shares[msg.sender], balanceOf(msg.sender));\\n    _burnShares(msg.sender, sharesToBurn);\\n  }\\n\\n  /// @notice Withdraws from the pool with specific delegations and transfers the funds to the sender.\\n  /// @param _amount The amount to withdraw.\\n  /// @param _pool The address of the pool to withdraw from.\\n  function withdrawPool(uint256 _amount, address _pool) external nonReentrant nonFlashLoan whenNotPaused {\\n    if (!config.feature.WithdrawPool) revert FeatureDisabled();\\n    if (_amount > address(this).balance) revert InsufficientPoolBalance();\\n    _withdrawBase(_amount, WithdrawType.Pool, _pool);\\n    Address.sendValue(payable(msg.sender), _amount);\\n  }\\n\\n  /// @notice Withdrawals from the beacon chain.\\n  /// @param _amount The amount to withdraw.\\n  /// @param _pool The address of the pool to withdraw from.\\n  function withdrawBeacon(\\n    uint256 _amount,\\n    address _pool\\n  ) external nonReentrant nonFlashLoan whenNotPaused {\\n    if (!config.feature.WithdrawBeacon) revert FeatureDisabled();\\n    if (_amount <= address(this).balance) revert WithdrawFromPool();\\n    if (_amount + withdrawBalance > beaconBalance) revert InsufficientBeaconBalance();\\n    nextWithdrawBeaconBlock[msg.sender] = block.number + config.withdrawBeaconDelay;\\n    _withdrawBase(_amount, WithdrawType.Validator, _pool);\\n    _setWithdrawBalance(withdrawBalance + _amount);\\n\\n    withdrawals.mint(msg.sender, _amount);\\n  }\\n\\n  /// @notice Resets the daily limits for deposits and withdrawals.\\n  function _resetLimits() private {\\n    if (block.number > lastResetBlock + config.blocksPerDay) {\\n      totalDeposited = 0;\\n      totalWithdrawnPool = 0;\\n      totalWithdrawnValidator = 0;\\n      lastResetBlock = block.number;\\n    }\\n  }\\n\\n  /// @notice Get the next withdraw block for account\\n  /// @param _account the address of the account.\\n  function getWithdrawBlock(address _account) external view returns (uint256) {\\n    return nextWithdrawBlock[_account];\\n  }\\n\\n  /// @notice Get the next withdraw beacon block for account\\n  /// @param _account the address of the account.\\n  function getWithdrawBeaconBlock(address _account) external view returns (uint256) {\\n    return nextWithdrawBeaconBlock[_account];\\n  }\\n\\n  /****************\\n   ** ANTI-FRAUD **\\n   ****************/\\n\\n  /// @notice Adds an address to the anti-fraud list.\\n  /// @dev Only a user with the ANTI_FRAUD_SENTINEL_ROLE or ANTI_FRAUD_MANAGER_ROLE can add addresses.\\n  /// @param _account The address to be added to the anti-fraud list.\\n  function addToAntiFraud(address _account) external {\\n    if (!hasRole(ANTI_FRAUD_SENTINEL_ROLE, msg.sender) && !hasRole(ANTI_FRAUD_MANAGER_ROLE, msg.sender))\\n      revert NotAuthorized();\\n    if (_account == address(0)) revert ZeroAddress();\\n    antiFraudList[_account] = true;\\n    emit SetAntiFraudStatus(msg.sender, _account, true);\\n  }\\n\\n  /// @notice Removes an address from the anti-fraud list.\\n  /// @dev Only a user with the ANTI_FRAUD_MANAGER_ROLE can remove addresses.\\n  /// @param _account The address to be removed from the anti-fraud list.\\n  function removeFromAntiFraud(address _account) external {\\n    if (!hasRole(ANTI_FRAUD_MANAGER_ROLE, msg.sender)) revert NotAuthorized();\\n    if (_account == address(0)) revert ZeroAddress();\\n    if (!antiFraudList[_account]) revert NotInAntiFraudList();\\n    antiFraudList[_account] = false;\\n    emit SetAntiFraudStatus(msg.sender, _account, false);\\n  }\\n\\n  /// @notice Check if an address is listed in the anti-fraud list.\\n  /// @param _account The address to be checked.\\n  /// @return true if the address is in the anti-fraud list, false otherwise.\\n  function isListedInAntiFraud(address _account) public view returns (bool) {\\n    return antiFraudList[_account];\\n  }\\n\\n  /***********\\n   ** POOLS **\\n   ***********/\\n\\n  /// @notice Adds a permissionless pool with a specified address and listing status if feature enabled.\\n  /// @param _pool The address of the pool to add.\\n  /// @param _listed The listing status of the pool.\\n  /// @param _social The kind of pool.\\n  /// @param _index Checked if the pool is a index\\n  function addPool(\\n    address _pool,\\n    bool _listed,\\n    bool _social,\\n    bool _index\\n  ) external payable nonReentrant whenNotPaused nonFlashLoan {\\n    if (_pool == address(0)) revert ZeroAddress();\\n    if (pools[_pool]) revert PoolExists();\\n    if (!hasRole(POOL_MANAGER_ROLE, msg.sender) || msg.value > 0) {\\n      if (!config.feature.AddPool) revert FeatureDisabled();\\n      if (msg.value != fees[FeeType.Pool].value) revert InvalidValue();\\n      _processFeePool();\\n    }\\n    pools[_pool] = true;\\n    lastOperationBlock[msg.sender] = block.number;\\n    emit AddPool(_pool, _listed, _social, _index, msg.value);\\n  }\\n\\n  /// @notice Removes a pool by its address.\\n  /// @param _pool The address of the pool to remove.\\n  function removePool(address _pool) external nonFlashLoan whenNotPaused onlyRole(POOL_MANAGER_ROLE) {\\n    if (!pools[_pool]) revert PoolNotFound();\\n    pools[_pool] = false;\\n    lastOperationBlock[msg.sender] = block.number;\\n    emit RemovePool(_pool);\\n  }\\n\\n  /// @notice Updates delegations for the sender's address.\\n  /// @param _delegations The array of delegations to update.\\n  function updateDelegations(Delegation[] memory _delegations) external {\\n    uint256 totalPercentage = 0;\\n    if (shares[msg.sender] > 0) {\\n      if (_delegations.length > config.maxDelegations) revert MaxDelegations();\\n      for (uint256 i = 0; i < _delegations.length; i++) {\\n        if (!pools[_delegations[i].pool]) revert PoolNotFound();\\n        totalPercentage += _delegations[i].percentage;\\n      }\\n      if (totalPercentage != 1 ether) revert InvalidTotalPercentage();\\n    } else {\\n      if (_delegations.length != 0) revert ShouldBeZeroLength();\\n    }\\n    emit UpdateDelegations(msg.sender, _delegations);\\n  }\\n\\n  /***********************\\n   ** VALIDATORS ORACLE **\\n   ***********************/\\n\\n  /// @notice Adds a new validator oracle by its address.\\n  /// @param _account The address of the validator oracle to add.\\n  function addValidatorOracle(address _account) external onlyRole(VALIDATOR_ORACLE_MANAGER_ROLE) {\\n    if (validatorsOracleIndices[_account] != 0) revert ValidatorOracleExists();\\n\\n    validatorsOracle.push(_account);\\n    validatorsOracleIndices[_account] = validatorsOracle.length;\\n\\n    _grantRole(VALIDATOR_ORACLE_ROLE, _account);\\n    emit AddValidatorOracle(_account);\\n  }\\n\\n  /// @notice Removes a validator oracle by its address.\\n  /// @param _account The address of the validator oracle to remove.\\n  function removeValidatorOracle(address _account) external onlyRole(VALIDATOR_ORACLE_MANAGER_ROLE) {\\n    if (validatorsOracleIndices[_account] == 0) revert ValidatorOracleNotFound();\\n\\n    uint256 index = validatorsOracleIndices[_account] - 1;\\n\\n    if (index < validatorsOracle.length - 1) {\\n      address lastAddress = validatorsOracle[validatorsOracle.length - 1];\\n      validatorsOracle[index] = lastAddress;\\n      validatorsOracleIndices[lastAddress] = index + 1;\\n    }\\n\\n    validatorsOracle.pop();\\n    delete validatorsOracleIndices[_account];\\n\\n    bool isCurrentOracle = (index == currentOracleIndex);\\n\\n    if (isCurrentOracle) {\\n      currentOracleIndex = (currentOracleIndex + 1) % validatorsOracle.length;\\n    }\\n\\n    _revokeRole(VALIDATOR_ORACLE_ROLE, _account);\\n    emit RemoveValidatorOracle(_account);\\n  }\\n\\n  /// @notice Checks if an address is a validator oracle.\\n  /// @param _account The address to check.\\n  /// @return True if the address is a validator oracle, false otherwise.\\n  function isValidatorOracle(address _account) public view returns (bool) {\\n    return hasRole(VALIDATOR_ORACLE_ROLE, _account) && validatorsOracleIndices[_account] > 0;\\n  }\\n\\n  /// @notice Forces the selection of the next validator oracle.\\n  function forceNextValidatorOracle() external {\\n    if (\\n      !hasRole(VALIDATOR_ORACLE_SENTINEL_ROLE, msg.sender) &&\\n      !hasRole(VALIDATOR_ORACLE_MANAGER_ROLE, msg.sender)\\n    ) revert NotAuthorized();\\n    _nextValidatorOracle();\\n  }\\n\\n  /// @notice Internal function to update the current validator oracle.\\n  function _nextValidatorOracle() private {\\n    currentOracleIndex = (currentOracleIndex + 1) % validatorsOracle.length;\\n    emit NextValidatorOracle(currentOracleIndex, validatorsOracle[currentOracleIndex]);\\n  }\\n\\n  /****************\\n   ** VALIDATORS **\\n   ****************/\\n\\n  /// @notice Sets the beacon balance to the specified amount.\\n  /// @param _amount The amount to set as the beacon balance.\\n  /// @dev Only the router address can call this function.\\n  function setBeaconBalance(uint256 _amount) external payable nonReentrant {\\n    if (msg.sender != address(router)) revert OnlyRouter();\\n    _setBeaconBalance(_amount);\\n  }\\n\\n  /// @notice Internal function to set the beacon balance.\\n  /// @param _amount The amount to set as the beacon balance.\\n  function _setBeaconBalance(uint256 _amount) private {\\n    beaconBalance = _amount;\\n    emit SetBeaconBalance(_amount);\\n  }\\n\\n  /// @notice Sets the pending withdraw balance to the specified amount.\\n  /// @param _amount The amount to set as the pending withdraw balance.\\n  /// @dev Only the router address can call this function.\\n  function setWithdrawBalance(uint256 _amount) external payable nonReentrant {\\n    if (msg.sender != address(router)) revert OnlyRouter();\\n    _setWithdrawBalance(_amount);\\n  }\\n\\n  /// @notice Internal function to set the pending withdraw balance.\\n  /// @param _amount The amount to set as the pending withdraw balance.\\n  function _setWithdrawBalance(uint256 _amount) private {\\n    withdrawBalance = _amount;\\n    emit SetWithdrawBalance(_amount);\\n  }\\n\\n  /// @notice Initiates a transfer to anticipate a validator's withdrawal.\\n  /// @dev Only a valid validator oracle can initiate this anticipation request.\\n  /// This function also checks the balance constraints before processing.\\n  function anticipateWithdrawBeacon() external nonReentrant whenNotPaused {\\n    if (!isValidatorOracle(msg.sender)) revert OnlyValidatorOracle();\\n    if (msg.sender != validatorsOracle[currentOracleIndex]) revert NotIsCurrentValidatorOracle();\\n    if (withdrawBalance == 0) revert WithdrawZeroBalance();\\n\\n    uint256 routerBalance = address(router).balance;\\n    if (routerBalance > withdrawBalance) revert RouterAlreadyHaveBalance();\\n\\n    uint256 diffAmount = withdrawBalance - routerBalance;\\n    if (address(this).balance < diffAmount) revert NotEnoughPoolBalance();\\n\\n    _setBeaconBalance(beaconBalance + diffAmount);\\n    emit AnticipateWithdrawBeacon(msg.sender, diffAmount);\\n\\n    router.receiveWithdrawEther{ value: diffAmount }();\\n  }\\n\\n  /// @notice Creates a new validator with the given parameters.\\n  /// @param _publicKey The public key of the validator.\\n  /// @param _signature The signature of the validator.\\n  /// @param _depositDataRoot The deposit data root for the validator.\\n  /// @dev Only a valid validator oracle can call this function.\\n  function addValidator(\\n    bytes calldata _publicKey,\\n    bytes calldata _signature,\\n    bytes32 _depositDataRoot\\n  ) external nonReentrant whenNotPaused {\\n    if (!isValidatorOracle(msg.sender)) revert OnlyValidatorOracle();\\n    if (msg.sender != validatorsOracle[currentOracleIndex]) revert NotIsCurrentValidatorOracle();\\n    if (address(this).balance < config.poolSize) revert NotEnoughBalanceOnPool();\\n    if (validators[_publicKey]) revert ValidatorExists();\\n    if (address(router).balance < withdrawBalance) revert ShouldAnticipateWithdraw();\\n\\n    validators[_publicKey] = true;\\n    _nextValidatorOracle();\\n    _setBeaconBalance(beaconBalance + config.validatorSize);\\n    emit AddValidator(\\n      msg.sender,\\n      config.validatorSize,\\n      _publicKey,\\n      withdrawalCredentials,\\n      _signature,\\n      _depositDataRoot\\n    );\\n    deposit.deposit{ value: config.validatorSize }(\\n      _publicKey,\\n      withdrawalCredentials,\\n      _signature,\\n      _depositDataRoot\\n    );\\n    _processFeeValidator();\\n  }\\n\\n  /*************\\n   ** Airdrop **\\n   *************/\\n\\n  /// @notice Function to claim rewards by transferring shares, accessible only by the airdrop fee address.\\n  /// @param _account Address to transfer the claimed rewards to.\\n  /// @param _sharesAmount Amount of shares to claim as rewards.\\n  function claimAirdrop(address _account, uint256 _sharesAmount) external whenNotPaused {\\n    if (msg.sender != address(airdrop)) revert OnlyAirdrop();\\n    _transferShares(address(airdrop), _account, _sharesAmount);\\n  }\\n\\n  /*****************\\n   **    FEES     **\\n   *****************/\\n\\n  /// @notice Returns an array of fee roles.\\n  /// @return roles An array of FeeRole.\\n  function getFeesRoles() public pure returns (FeeRole[4] memory) {\\n    return [FeeRole.Airdrop, FeeRole.Operator, FeeRole.StakeTogether, FeeRole.Sender];\\n  }\\n\\n  /// @notice Sets the fee address for a given role.\\n  /// @param _role The role for which the address will be set.\\n  /// @param _address The address to set.\\n  /// @dev Only an admin can call this function.\\n  function setFeeAddress(FeeRole _role, address payable _address) external onlyRole(ADMIN_ROLE) {\\n    if (_address == address(0)) revert ZeroAddress();\\n    feesRole[_role] = _address;\\n    if (_role == FeeRole.Airdrop) {\\n      feesRole[_role] = payable(airdrop);\\n    } else {\\n      feesRole[_role] = _address;\\n    }\\n    emit SetFeeAddress(_role, _address);\\n  }\\n\\n  /// @notice Gets the fee address for a given role.\\n  /// @param _role The role for which the address will be retrieved.\\n  /// @return The address associated with the given role.\\n  function getFeeAddress(FeeRole _role) public view returns (address) {\\n    return feesRole[_role];\\n  }\\n\\n  /// @notice Sets the fee for a given fee type.\\n  /// @param _feeType The type of fee to set.\\n  /// @param _value The value of the fee.\\n  /// @param _allocations The allocations for the fee.\\n  /// @dev Only an admin can call this function.\\n  function setFee(\\n    FeeType _feeType,\\n    uint256 _value,\\n    uint256[] calldata _allocations\\n  ) external onlyRole(ADMIN_ROLE) {\\n    if (_allocations.length != 4) revert InvalidLength();\\n    uint256 sum = 0;\\n    for (uint256 i = 0; i < _allocations.length; i++) {\\n      fees[_feeType].allocations[FeeRole(i)] = _allocations[i];\\n      sum += _allocations[i];\\n    }\\n\\n    if (sum != 1 ether) revert InvalidSum();\\n\\n    fees[_feeType].value = _value;\\n\\n    emit SetFee(_feeType, _value, _allocations);\\n  }\\n\\n  /// @notice Get the fee for a given fee type.\\n  /// @param _feeType The type of fee to get.\\n  function getFee(FeeType _feeType) external view returns (uint256) {\\n    return fees[_feeType].value;\\n  }\\n\\n  /// @notice Distributes fees according to their type, amount, and the destination.\\n  /// @param _feeType The type of fee being distributed.\\n  /// @param _sharesAmount The total shares amount for the fee.\\n  /// @param _to The address to distribute the fees.\\n  /// @dev This function computes how the fees are allocated to different roles.\\n  function _distributeFees(FeeType _feeType, uint256 _sharesAmount, address _to) private {\\n    uint256[4] memory allocatedShares;\\n    FeeRole[4] memory roles = getFeesRoles();\\n\\n    uint256 feeValue = fees[_feeType].value;\\n    uint256 feeShares = Math.mulDiv(_sharesAmount, feeValue, 1 ether);\\n    uint256 totalAllocatedShares = 0;\\n\\n    for (uint256 i = 0; i < roles.length - 1; i++) {\\n      if (getFeeAddress(roles[i]) == address(0)) revert ZeroAddress();\\n      uint256 allocation = fees[_feeType].allocations[roles[i]];\\n      allocatedShares[i] = Math.mulDiv(feeShares, allocation, 1 ether);\\n      totalAllocatedShares += allocatedShares[i];\\n    }\\n\\n    allocatedShares[3] = _sharesAmount - totalAllocatedShares;\\n\\n    uint256 length = (_feeType == FeeType.Entry) ? roles.length : roles.length - 1;\\n\\n    for (uint256 i = 0; i < length; i++) {\\n      if (allocatedShares[i] > 0) {\\n        if (_feeType == FeeType.Entry && roles[i] == FeeRole.Sender) {\\n          _mintShares(_to, allocatedShares[i]);\\n        } else {\\n          _mintShares(getFeeAddress(roles[i]), allocatedShares[i]);\\n          emit MintFeeShares(getFeeAddress(roles[i]), allocatedShares[i], _feeType, roles[i]);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Processes a stake entry and distributes the associated fees.\\n  /// @param _to The address to receive the stake entry.\\n  /// @param _amount The amount staked.\\n  /// @dev Calls the distributeFees function internally.\\n  function _processFeeEntry(address _to, uint256 _amount) private {\\n    uint256 sharesAmount = Math.mulDiv(_amount, totalShares, totalSupply() - _amount);\\n    _distributeFees(FeeType.Entry, sharesAmount, _to);\\n  }\\n\\n  /// @notice Process staking rewards and distributes the rewards based on shares.\\n  /// @param _sharesAmount The amount of shares related to the staking rewards.\\n  /// @dev The caller should be the router contract. This function will also emit the ProcessStakeRewards event.\\n  function processFeeRewards(uint256 _sharesAmount) external payable nonReentrant whenNotPaused {\\n    if (msg.sender != address(router)) revert OnlyRouter();\\n    _distributeFees(FeeType.Rewards, _sharesAmount, address(0));\\n    emit ProcessStakeRewards(msg.value, _sharesAmount);\\n  }\\n\\n  /// @notice Processes the staking pool fee and distributes it accordingly.\\n  /// @dev Calculates the shares amount and then distributes the staking pool fee.\\n  function _processFeePool() private {\\n    uint256 amount = fees[FeeType.Pool].value;\\n    uint256 sharesAmount = Math.mulDiv(amount, totalShares, totalSupply() - amount);\\n    _distributeFees(FeeType.Pool, sharesAmount, address(0));\\n  }\\n\\n  /// @notice Transfers the staking validator fee to the operator role.\\n  /// @dev Transfers the associated amount to the Operator's address.\\n  function _processFeeValidator() private {\\n    emit ProcessStakeValidator(getFeeAddress(FeeRole.Operator), fees[FeeType.Validator].value);\\n    Address.sendValue(payable(getFeeAddress(FeeRole.Operator)), fees[FeeType.Validator].value);\\n  }\\n\\n  /// @notice Temp Function to Emit Non Processed Transfer Events\\n  function emitTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) external whenPaused onlyRole(ADMIN_ROLE) {\\n    emit Transfer(_from, _to, _amount);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ERC2612ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC2612InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EarlyTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeatureDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlashLoan\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAccountBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBeaconBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientPoolBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientShares\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalPercentage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LessThanMinimumDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LessThanMinimumWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListedInAntiFraud\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxDelegations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBalanceOnPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughPoolBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInAntiFraudList\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotIsCurrentValidatorOracle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAirdrop\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyValidatorOracle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RouterAlreadyHaveBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShouldAnticipateWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShouldBeZeroLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorOracleExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorOracleNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawFromPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawZeroBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalsPoolLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalsValidatorLimitWasReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroSupply\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"listed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"social\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"index\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"AddValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddValidatorOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AnticipateWithdrawBeacon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"BurnShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IStakeTogether.DepositType\",\"name\":\"depositType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"referral\",\"type\":\"bytes\"}],\"name\":\"DepositBase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositLimitWasReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum IStakeTogether.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"enum IStakeTogether.FeeRole\",\"name\":\"feeRole\",\"type\":\"uint8\"}],\"name\":\"MintFeeShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"MintShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NextValidatorOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"ProcessStakeRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProcessStakeValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"RemovePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveValidatorOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"}],\"name\":\"SetAntiFraudStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetBeaconBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blocksPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelegations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minWithdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validatorSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPoolLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalValidatorLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawBeaconDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"AddPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Deposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawBeacon\",\"type\":\"bool\"}],\"internalType\":\"struct IStakeTogether.Feature\",\"name\":\"feature\",\"type\":\"tuple\"}],\"indexed\":true,\"internalType\":\"struct IStakeTogether.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"SetConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum IStakeTogether.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"allocations\",\"type\":\"uint256[]\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum IStakeTogether.FeeRole\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SetFeeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeTogether\",\"type\":\"address\"}],\"name\":\"SetStakeTogether\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValidatorSize\",\"type\":\"uint256\"}],\"name\":\"SetValidatorSize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes\"}],\"name\":\"SetWithdrawalsCredentials\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"TransferShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IStakeTogether.Delegation[]\",\"name\":\"delegations\",\"type\":\"tuple[]\"}],\"name\":\"UpdateDelegations\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IStakeTogether.WithdrawType\",\"name\":\"withdrawType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"WithdrawBase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IStakeTogether.WithdrawType\",\"name\":\"withdrawType\",\"type\":\"uint8\"}],\"name\":\"WithdrawalsLimitWasReached\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANTI_FRAUD_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANTI_FRAUD_SENTINEL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_ORACLE_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_ORACLE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_ORACLE_SENTINEL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_listed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_social\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_index\",\"type\":\"bool\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addToAntiFraud\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_publicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_depositDataRoot\",\"type\":\"bytes32\"}],\"name\":\"addValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addValidatorOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop\",\"outputs\":[{\"internalType\":\"contract IAirdrop\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anticipateWithdrawBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beaconBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"claimAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blocksPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelegations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minWithdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validatorSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPoolLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalValidatorLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawBeaconDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"AddPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Deposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawBeacon\",\"type\":\"bool\"}],\"internalType\":\"struct IStakeTogether.Feature\",\"name\":\"feature\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentOracleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"contract IDepositContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_referral\",\"type\":\"bytes\"}],\"name\":\"depositDonation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_referral\",\"type\":\"bytes\"}],\"name\":\"depositPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emitTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceNextValidatorOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IStakeTogether.FeeType\",\"name\":\"_feeType\",\"type\":\"uint8\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IStakeTogether.FeeRole\",\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"getFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeesRoles\",\"outputs\":[{\"internalType\":\"enum IStakeTogether.FeeRole[4]\",\"name\":\"\",\"type\":\"uint8[4]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getWithdrawBeaconBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getWithdrawBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isListedInAntiFraud\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isValidatorOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastResetBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"processFeeRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeFromAntiFraud\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"removePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeValidatorOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setBeaconBalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blocksPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelegations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minWithdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validatorSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPoolLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalValidatorLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawBeaconDelay\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"AddPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Deposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"WithdrawBeacon\",\"type\":\"bool\"}],\"internalType\":\"struct IStakeTogether.Feature\",\"name\":\"feature\",\"type\":\"tuple\"}],\"internalType\":\"struct IStakeTogether.Config\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IStakeTogether.FeeType\",\"name\":\"_feeType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_allocations\",\"type\":\"uint256[]\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IStakeTogether.FeeRole\",\"name\":\"_role\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setWithdrawBalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sharesByWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawnPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawnValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeTogether.Delegation[]\",\"name\":\"_delegations\",\"type\":\"tuple[]\"}],\"name\":\"updateDelegations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"weiByShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"withdrawBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"withdrawPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalCredentials\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"contract IWithdrawals\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakeTogetherV2", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}