{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/strategy/StructuredLinkedList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @title StructuredLinkedList\\n * @author Vittorio Minacori (https://github.com/vittominacori)\\n * @dev An utility library for using sorted linked list data structures in your Solidity project.\\n * @notice Adapted from\\n * https://github.com/Layr-Labs/eigenlayer-contracts/blob/master/src/contracts/libraries/StructuredLinkedList.sol\\n */\\nlibrary StructuredLinkedList {\\n    uint256 private constant _NULL = 0;\\n    uint256 private constant _HEAD = 0;\\n\\n    bool private constant _PREV = false;\\n    bool private constant _NEXT = true;\\n\\n    struct List {\\n        uint256 size;\\n        mapping(uint256 => mapping(bool => uint256)) list;\\n    }\\n\\n    /**\\n     * @dev Checks if the list exists\\n     * @param self stored linked list from contract\\n     * @return bool true if list exists, false otherwise\\n     */\\n    function listExists(List storage self) public view returns (bool) {\\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\\n        if (self.list[_HEAD][_PREV] != _HEAD || self.list[_HEAD][_NEXT] != _HEAD) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if the node exists\\n     * @param self stored linked list from contract\\n     * @param _node a node to search for\\n     * @return bool true if node exists, false otherwise\\n     */\\n    function nodeExists(List storage self, uint256 _node) public view returns (bool) {\\n        if (self.list[_node][_PREV] == _HEAD && self.list[_node][_NEXT] == _HEAD) {\\n            if (self.list[_HEAD][_NEXT] == _node) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the list\\n     * @param self stored linked list from contract\\n     * @return uint256\\n     */\\n    // slither-disable-next-line dead-code\\n    function sizeOf(List storage self) public view returns (uint256) {\\n        return self.size;\\n    }\\n\\n    /**\\n     * @dev Gets the head of the list\\n     * @param self stored linked list from contract\\n     * @return uint256 the head of the list\\n     */\\n    function getHead(List storage self) public view returns (uint256) {\\n        return self.list[_HEAD][_NEXT];\\n    }\\n\\n    /**\\n     * @dev Gets the head of the list\\n     * @param self stored linked list from contract\\n     * @return uint256 the head of the list\\n     */\\n    function getTail(List storage self) public view returns (uint256) {\\n        return self.list[_HEAD][_PREV];\\n    }\\n\\n    /**\\n     * @dev Returns the links of a node as a tuple\\n     * @param self stored linked list from contract\\n     * @param _node id of the node to get\\n     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\\n     */\\n    // slither-disable-next-line dead-code\\n    function getNode(List storage self, uint256 _node) public view returns (bool, uint256, uint256) {\\n        if (!nodeExists(self, _node)) {\\n            return (false, 0, 0);\\n        } else {\\n            return (true, self.list[_node][_PREV], self.list[_node][_NEXT]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the link of a node `_node` in direction `_direction`.\\n     * @param self stored linked list from contract\\n     * @param _node id of the node to step from\\n     * @param _direction direction to step in\\n     * @return bool, uint256 true if node exists or false otherwise, node in _direction\\n     */\\n    // slither-disable-next-line dead-code\\n    function getAdjacent(List storage self, uint256 _node, bool _direction) public view returns (bool, uint256) {\\n        if (!nodeExists(self, _node)) {\\n            return (false, 0);\\n        } else {\\n            uint256 adjacent = self.list[_node][_direction];\\n            return (adjacent != _HEAD, adjacent);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the link of a node `_node` in direction `_NEXT`.\\n     * @param self stored linked list from contract\\n     * @param _node id of the node to step from\\n     * @return bool, uint256 true if node exists or false otherwise, next node\\n     */\\n    // slither-disable-next-line dead-code\\n    function getNextNode(List storage self, uint256 _node) public view returns (bool, uint256) {\\n        return getAdjacent(self, _node, _NEXT);\\n    }\\n\\n    /**\\n     * @dev Returns the link of a node `_node` in direction `_PREV`.\\n     * @param self stored linked list from contract\\n     * @param _node id of the node to step from\\n     * @return bool, uint256 true if node exists or false otherwise, previous node\\n     */\\n    // slither-disable-next-line dead-code\\n    function getPreviousNode(List storage self, uint256 _node) public view returns (bool, uint256) {\\n        return getAdjacent(self, _node, _PREV);\\n    }\\n\\n    /**\\n     * @dev Insert node `_new` beside existing node `_node` in direction `_NEXT`.\\n     * @param self stored linked list from contract\\n     * @param _node existing node\\n     * @param _new  new node to insert\\n     * @return bool true if success, false otherwise\\n     */\\n    // slither-disable-next-line dead-code\\n    function insertAfter(List storage self, uint256 _node, uint256 _new) public returns (bool) {\\n        return _insert(self, _node, _new, _NEXT);\\n    }\\n\\n    /**\\n     * @dev Insert node `_new` beside existing node `_node` in direction `_PREV`.\\n     * @param self stored linked list from contract\\n     * @param _node existing node\\n     * @param _new  new node to insert\\n     * @return bool true if success, false otherwise\\n     */\\n    // slither-disable-next-line dead-code\\n    function insertBefore(List storage self, uint256 _node, uint256 _new) public returns (bool) {\\n        return _insert(self, _node, _new, _PREV);\\n    }\\n\\n    /**\\n     * @dev Removes an entry from the linked list\\n     * @param self stored linked list from contract\\n     * @param _node node to remove from the list\\n     * @return uint256 the removed node\\n     */\\n    function remove(List storage self, uint256 _node) public returns (uint256) {\\n        if ((_node == _NULL) || (!nodeExists(self, _node))) {\\n            return 0;\\n        }\\n        _createLink(self, self.list[_node][_PREV], self.list[_node][_NEXT], _NEXT);\\n        delete self.list[_node][_PREV];\\n        delete self.list[_node][_NEXT];\\n\\n        self.size -= 1;\\n\\n        return _node;\\n    }\\n\\n    /**\\n     * @dev Pushes an entry to the head of the linked list\\n     * @param self stored linked list from contract\\n     * @param _node new entry to push to the head\\n     * @return bool true if success, false otherwise\\n     */\\n    function pushFront(List storage self, uint256 _node) public returns (bool) {\\n        return _push(self, _node, _NEXT);\\n    }\\n\\n    /**\\n     * @dev Pushes an entry to the tail of the linked list\\n     * @param self stored linked list from contract\\n     * @param _node new entry to push to the tail\\n     * @return bool true if success, false otherwise\\n     */\\n    function pushBack(List storage self, uint256 _node) public returns (bool) {\\n        return _push(self, _node, _PREV);\\n    }\\n\\n    /**\\n     * @dev Pops the first entry from the head of the linked list\\n     * @param self stored linked list from contract\\n     * @return uint256 the removed node\\n     */\\n    // slither-disable-next-line dead-code\\n    function popFront(List storage self) public returns (uint256) {\\n        return _pop(self, _NEXT);\\n    }\\n\\n    /**\\n     * @dev Pops the first entry from the tail of the linked list\\n     * @param self stored linked list from contract\\n     * @return uint256 the removed node\\n     */\\n    // slither-disable-next-line dead-code\\n    function popBack(List storage self) public returns (uint256) {\\n        return _pop(self, _PREV);\\n    }\\n\\n    /**\\n     * @dev Pushes an entry to the head of the linked list\\n     * @param self stored linked list from contract\\n     * @param _node new entry to push to the head\\n     * @param _direction push to the head (_NEXT) or tail (_PREV)\\n     * @return bool true if success, false otherwise\\n     */\\n    function _push(List storage self, uint256 _node, bool _direction) private returns (bool) {\\n        return _insert(self, _HEAD, _node, _direction);\\n    }\\n\\n    /**\\n     * @dev Pops the first entry from the linked list\\n     * @param self stored linked list from contract\\n     * @param _direction pop from the head (_NEXT) or the tail (_PREV)\\n     * @return uint256 the removed node\\n     */\\n    // slither-disable-next-line dead-code\\n    function _pop(List storage self, bool _direction) private returns (uint256) {\\n        uint256 adj;\\n        (, adj) = getAdjacent(self, _HEAD, _direction);\\n        return remove(self, adj);\\n    }\\n\\n    /**\\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\\n     * @param self stored linked list from contract\\n     * @param _node existing node\\n     * @param _new  new node to insert\\n     * @param _direction direction to insert node in\\n     * @return bool true if success, false otherwise\\n     */\\n    function _insert(List storage self, uint256 _node, uint256 _new, bool _direction) private returns (bool) {\\n        if (!nodeExists(self, _new) && nodeExists(self, _node)) {\\n            uint256 c = self.list[_node][_direction];\\n            _createLink(self, _node, _new, _direction);\\n            _createLink(self, _new, c, _direction);\\n\\n            self.size += 1;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\\n     * @param self stored linked list from contract\\n     * @param _node existing node\\n     * @param _link node to link to in the _direction\\n     * @param _direction direction to insert node in\\n     */\\n    function _createLink(List storage self, uint256 _node, uint256 _link, bool _direction) private {\\n        self.list[_link][!_direction] = _node;\\n        self.list[_node][_direction] = _link;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/erc4626-tests/\",\r\n      \"prb-math/=lib/prb-math/\",\r\n      \"crytic/properties/=lib/properties/\",\r\n      \"ERC4626/=lib/properties/lib/ERC4626/contracts/\",\r\n      \"properties/=lib/properties/contracts/\",\r\n      \"solmate/=lib/properties/lib/solmate/src/\",\r\n      \"usingtellor/=lib/usingtellor/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "StructuredLinkedList", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}