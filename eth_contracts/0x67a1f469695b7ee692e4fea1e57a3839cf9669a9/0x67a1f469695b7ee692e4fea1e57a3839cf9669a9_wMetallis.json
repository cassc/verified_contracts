{"SourceCode": "// SPDX-License-Identifier: UNLICENSED \r\n//CopyRight Metallis Crypta.io, ALL RIGHTS RESERVED 2021-2024\r\n//Version 2.0 2-23-24\r\npragma solidity 0.8.20;\r\n\r\n    //**************************************   Interfaces  *****************************************//\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);    \r\n    function transfer(address recipient, uint256 amount) external returns (bool success); \r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n    function allowance(address sender, address spender) external view returns (uint256 remaining);\r\n}\r\n\r\ninterface Imultisig {\r\n    function pause() external returns (bool);\r\n    function unPause() external returns (bool);\r\n    function authorizeContract(address _contract) external;\r\n    function revokeContract(address _contract) external;\r\n    function addMultisigWallet(address _wallet) external;\r\n    function removeMultisigWallet(address _wallet) external;\r\n    function initiateProposal(\r\n        string memory _proposalName, \r\n        bytes memory _proposalFunction, \r\n        address _proposalContract,\r\n        uint _requiredVotes, \r\n        uint _duration\r\n        ) external returns (uint proposalId);\r\n    function voteOnProposal(uint _proposalId, bool _vote) external;\r\n  \r\n}\r\n\r\ninterface ImetallisMain {\r\n    function purchasewMetallis(address _buyer, string memory _tokenName, uint256 _tokenAmount) external returns (bool);\r\n    function setMultisigContract(address _multisigContract) external returns (address);\r\n    function addToWhitelist(address _address) external;\r\n    function updatePurchaseTokens(string memory _tokenName, ERC20 _tokenAddress, uint _decimals, uint _weiDiff, bool _active) external;\r\n    function updatewMetallisPrice(string memory _tokenName, ERC20 _tokenAddress, uint256 _wMetallisPrice) external;\r\n    function pauseContract(bool _status) external returns (bool);\r\n    function getMultisigContract() external view returns (Imultisig, address);\r\n    function getwMetallisContract() external view returns(IwMetallis, address);\r\n    function getwMetallisPrice(string memory _tokenName) external view returns (uint256);\r\n    function isWhitelisted() external view returns (bool);\r\n    function isAddressWhitelisted(address _whitelistAddress) external  view returns (bool);\r\n    function isPurchaseTokenActive(string memory tokenName) external view returns (bool);\r\n    function contractTokenBalances(string memory _tokenName) external view returns (uint256, uint256);\r\n    function wMetallisMintedBalance() external view returns(uint256);\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external payable returns (bool success);\r\n    function transferOwnership(address newOwner) external returns (address);\r\n    function setTreasuries(string memory _treasuryName, address _treasuryAddress, uint _rate) external;\r\n\r\n}\r\n\r\ninterface IwMetallis {\r\n    // Custom functions specific to the wMetallis contract\r\n    function distributeTokens(address buyer, uint256 wMetallisAmount) external returns (bool);\r\n    function pause() external;\r\n    function unPause() external;\r\n    function pauseStatus() external view returns (bool);\r\n    function setMultisigContract(address _multisigContract) external returns(address multisig);\r\n    function contractBalances(string memory _tokenName) external view returns (uint256); \r\n    function addTokens(string memory _tokenName, ERC20 _tokenAddress, uint _decimals, bool _active) external;\r\n    function removeTokens(string memory _tokenName) external;\r\n    function isTokenActive(string memory tokenName) external view returns (bool);\r\n    function mintwMetallis(uint256 _mintAmount) external returns (string memory, uint256);\r\n    function burnwMetallis(uint256 _burnAmount) external returns (string memory, uint256);\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external payable;\r\n    function manualTokenTransfer(address tokenAddress, address to, uint256 amount) external returns(bool);\r\n    function authorizeContract(address _contract) external returns (address);\r\n    function revokeContractAuthorization(address _contract) external returns (address);\r\n    function transferOwnership(address newOwner) external;\r\n    function wMetallisBalance() external view returns (uint);\r\n    function setMetallisMainContract(address _metallisMainAddress) external  returns (address);\r\n    function getMultisigAddress() external view returns (Imultisig _multisigContract, address _multisig);\r\n}\r\n\r\n\r\n\r\ncontract wMetallis is ERC20, IwMetallis {\r\n\r\n    //************************************** State Variables *****************************************//\r\n\r\n\r\n    address internal multisigAddress;\r\n    address internal adminAddress;\r\n    address internal metallisMainAddress;\r\n    address public owner;\r\n    bool internal functionLocked;\r\n    bool public paused;\r\n    Imultisig internal multisigContract;\r\n    ImetallisMain internal metallisMainContract;\r\n    string public name = 'wMetallis';\r\n    string public symbol = 'wMTLIS';\r\n    string public logoUrl = \"https://metalliscrypta.io/symbollogo.png\";\r\n    string public _websiteUrl = \"https://metalliscrypta.io\";\r\n    uint public decimals = 18;\r\n    uint256 public totalSupply; \r\n    uint256 public maxTotalSupply;\r\n\r\n  \r\n    //**************************************    Mappings    *****************************************//\r\n\r\n\r\n    // Mappings for balances and allowances\r\n    mapping(address => uint256) private _balances; // Map user balances\r\n    mapping(address => mapping(address => uint256)) private _allowances;  // Map user allowances\r\n    mapping(address => bool) internal authorizedContracts; // Mapping of authorized contract addresses\r\n    mapping(address => uint256) internal deposits; // Mapping to keep track of all Ether deposits\r\n    mapping(string => TokenInfo) internal erc20Tokens;  // Sets ERC20 Token id of Proposal Struct and maps to proposals array\r\n    mapping(address => mapping (address => uint)) public distributedTokens; // Mapping of calling contract, buyer address, and amount distributed\r\n    mapping(address => uint) internal mints; // Log and map all token mints\r\n    mapping(address => uint) internal burns; // Log all token burns\r\n\r\n    //**************************************       Structs      *****************************************//\r\n   \r\n    struct TokenInfo {\r\n        ERC20 tokenAddress;\r\n        uint decimals;\r\n        bool active;\r\n    }\r\n\r\n    //**************************************       Events      *****************************************//\r\n\r\n\r\n    event InternalTransfer(address indexed from, address indexed to, uint256 value); //Emit on successful transfer\r\n    event Approval(address indexed owner, address indexed spender, uint256 value); //Emit on successful approval\r\n    event AuthorizationChanged(address indexed contractAddress, bool isAuthorized); //Emit on any change\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); //Emit on any change to ownership\r\n    event EtherReceived(address sender, uint256 amount); //Emit when Ether is received and by which address\r\n    event MintSuccess(uint256 mintAmount, uint256 newSupply); //Emit when new mint is made\r\n    event BurnSuccess(address sender, address zeroAddress, uint256 burnAmount); //Emit when tokens are burned\r\n    event MultisigChanged(address indexed _multisigContract); //Emit if multisig contract is changed\r\n    event TokenInfoUpdated(string tokenName, address tokenAddress, bool active); // Emit when updating token info\r\n    event TokenRemoved(string tokenName, ERC20 tokenAddress); // Emit if token is removed from the contract\r\n    \r\n    //**************************************      Modifiers      *****************************************//\r\n\r\n\r\n    // Modifier restricting function access to the owner of the contract only\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Modifier restricting access to the multisig wallet address only\r\n    modifier onlyMultisig() {\r\n        require(msg.sender == multisigAddress, \"Caller is not the multisig contract\");\r\n        _;\r\n    }\r\n\r\n    // Modifier restricting access to the multisig wallet address only\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Caller is not the multisig contract\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict function calls to authorized contracts\r\n    modifier onlyAuthorizedContracts() {\r\n        require(authorizedContracts[msg.sender], \"Caller is not authorized\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to lock a function while it is being exectued until it has finished \r\n    modifier functionLock() {\r\n        require(!functionLocked, \"Reentrant call detected\");\r\n        functionLocked = true;\r\n        _;\r\n        functionLocked = false;\r\n    }\r\n\r\n\r\n\r\n    //**************************************    Constructor     *****************************************//\r\n\r\n\r\n    constructor(\r\n        address _multisigAddress,\r\n        address _metallisMainAddress,\r\n        address _adminAddress\r\n    ) {\r\n        multisigContract = Imultisig(_multisigAddress); // Initialize instances of the contract interfaces\r\n        metallisMainContract = ImetallisMain(_metallisMainAddress); // Initialize instances of the contract interfaces\r\n        adminAddress = _adminAddress; // Define Admin Address upon deployment\r\n        paused = false; // Set initial emergency paused state to false\r\n        functionLocked = false; // Set initial function lock state to false\r\n        maxTotalSupply = 5000000 * (10 ** 18); //5M coins in wei\r\n        owner = msg.sender; // Set the owner of the contract to the deployer address\r\n        uint256 firstMintAmount = 483000 * (10 ** 18); // first mint amount\r\n        _balances[address(this)] = firstMintAmount; // Assigning first minted tokens to the contract itself\r\n        totalSupply = firstMintAmount; // Update the total supply\r\n\r\n    }\r\n\r\n    //************************************** Core ERC20 Functions *****************************************//\r\n\r\n\r\n    // Returns the account balance of another account with address `tokenOwner`.\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance) {\r\n        return _balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[msg.sender] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[msg.sender] = _balances[msg.sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        return true;\r\n    }\r\n\r\n    // Approves the `spender` to withdraw from user account multiple times, up to the `tokens` amount.\r\n    function approve(address spender, uint256 tokens) external returns (bool success) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(spender != address(0), \"Approve to the zero address\");\r\n        _allowances[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // Transfers `tokens` amount of tokens from address `from` to address `to`.\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(tokens <= _balances[from], \"Insufficient balance\");\r\n        require(tokens <= _allowances[from][msg.sender], \"Insufficient allowance\");\r\n        require(to != address(0), \"Transfer to the zero address\");\r\n        _balances[from] -= tokens;\r\n        _balances[to] += tokens;\r\n        _allowances[from][msg.sender] -= tokens;\r\n        return true;\r\n    }\r\n\r\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account.\r\n    function allowance(address sender, address spender) external view returns (uint256 remaining) {\r\n        return _allowances[sender][spender];\r\n    }\r\n\r\n    //************************************** Getter Functions *****************************************//\r\n\r\n    //Function to allow checks of authorized contracts\r\n    function isContractAuthorized(address _contract) external view returns (string memory) {\r\n        if (authorizedContracts[_contract]) {\r\n            return \"Contract is authorized\";\r\n        } else {\r\n            return \"Contract is not authorized\";\r\n        }\r\n    }\r\n\r\n    // Function to check the contract's balance of erc20 Tokens\r\n    function contractBalances(string memory _tokenName) external view onlyOwner returns (uint256) {\r\n        bool _token = erc20Tokens [_tokenName].active;\r\n        require(_token == true, \"No active token by that name\");\r\n        uint256 balance = erc20Tokens [_tokenName].tokenAddress.balanceOf(address(this));\r\n        return balance / (10**erc20Tokens[_tokenName].decimals); // Fetch the balance and truncate decimals\r\n    }\r\n\r\n    // Get wMetallis balance of contract\r\n    function wMetallisBalance() external view onlyAuthorizedContracts returns (uint){\r\n        return totalSupply;\r\n    }\r\n\r\n    function isTokenActive(string memory tokenName) external view returns (bool) {\r\n        return erc20Tokens[tokenName].active;\r\n    }\r\n\r\n    function getMultisigAddress() external view onlyAuthorizedContracts returns (Imultisig, address) {\r\n        return (multisigContract, multisigAddress);\r\n    }\r\n\r\n\r\n    //************************************** Setter Functions *****************************************//\r\n\r\n    // Function to pause the contract\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    // Function to unpause the contract\r\n    function unPause() external onlyOwner {\r\n        paused = false;\r\n    }\r\n\r\n    // Function to check the contract's paused status\r\n    function pauseStatus() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n    // Set the multisig contract address\r\n    function setMultisigContract(address _multisigAddress) external onlyOwner returns(address){\r\n        multisigContract = Imultisig(_multisigAddress); // Update Multisig Address\r\n        multisigAddress = _multisigAddress; // Set the multisigAddress variable \r\n        emit MultisigChanged(multisigAddress); // Emit the updated address\r\n        return multisigAddress; //return the updated multisig address\r\n    }\r\n    \r\n    // Set metallisMain Contract address\r\n    function setMetallisMainContract(address _metallisMainAddress) external onlyOwner returns (address){\r\n        metallisMainContract = ImetallisMain(_metallisMainAddress);\r\n        metallisMainAddress = _metallisMainAddress;\r\n        return metallisMainAddress;\r\n    }\r\n\r\n    // Set admin address\r\n    function setAdminAddress(address _newAdminAddress) external onlyAdmin returns (address){\r\n        adminAddress = _newAdminAddress;\r\n        return adminAddress;\r\n    }\r\n\r\n    // Set token addresses that the contract will accept\r\n    function addTokens(\r\n        string memory _tokenName, \r\n        ERC20 _tokenAddress, \r\n        uint _decimals, \r\n        bool _active) external onlyOwner {\r\n            erc20Tokens[_tokenName] = TokenInfo(_tokenAddress, _decimals, _active);\r\n            emit TokenInfoUpdated(_tokenName, address(_tokenAddress), _active);\r\n    }\r\n\r\n    // Remove tokens from the approved tokens array\r\n    function removeTokens(string memory _tokenName) external onlyOwner {\r\n        emit TokenRemoved(_tokenName, erc20Tokens[_tokenName].tokenAddress);\r\n        delete erc20Tokens[_tokenName];\r\n    }\r\n\r\n    // Function to authorize a contract address\r\n    function authorizeContract(address _contract) external onlyOwner returns (address) {\r\n        authorizedContracts[_contract] = true;\r\n        emit AuthorizationChanged(_contract, true);\r\n        return _contract;\r\n    }\r\n\r\n    // Function to revoke authorization of a contract address\r\n    function revokeContractAuthorization(address _contract) external onlyOwner returns (address) {\r\n        authorizedContracts[_contract] = false;\r\n        emit AuthorizationChanged(_contract, false);\r\n        return _contract;\r\n    }\r\n\r\n\r\n    //************************************** Internal Functions *****************************************//\r\n\r\n    // Custom ERC20 internal transfer function\r\n    function _transfer(address sender, address recipient, uint256 amount) private returns (bool){\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = _balances[sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        emit InternalTransfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // Function to receive Ether. msg.value is the amount of Ether sent mapped to address making deposit\r\n    receive() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // Fallback function to accept ETH sent to the contract and map deposit to sender address\r\n    fallback() external payable {\r\n        deposits[msg.sender] += msg.value;\r\n        emit EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // Function to allow the owner to mint more wMetallis tokens\r\n    // pass \"abi.encodeWithSignature(\"mintwMetallis(uint256)\", mintAmount);\" to proposal for vote\r\n    function mintwMetallis(uint256 _mintAmount) external onlyMultisig returns (string memory, uint256) {\r\n        require(!paused, \"Contract is paused\");\r\n        // Make sure that the mint cannot exceed the total supply\r\n        require(totalSupply + _mintAmount <= maxTotalSupply, \"Mint exceeds max supply\");\r\n        // Add the newly minted tokens tot he total supply\r\n        totalSupply += _mintAmount;\r\n        mints [address(this)] += _mintAmount;\r\n        emit MintSuccess(_mintAmount, totalSupply);\r\n        return (\"Mint Successful. Tokens Minted: \",_mintAmount);\r\n    }\r\n\r\n    // Function to allow the owner to burn wMetallis tokens\r\n    function burnwMetallis(uint256 _burnAmount) external onlyMultisig returns (string memory, uint256) {\r\n        require(!paused, \"Contract is paused\");\r\n        // Make sure that the burn amount cannot exceed the total supply\r\n        require(totalSupply - _burnAmount >= 0, \"Burn exceeds total supply\");\r\n        // Subtract the burned tokens from the total supply\r\n        totalSupply -= _burnAmount;\r\n        burns [address(this)] += _burnAmount;\r\n        emit BurnSuccess(msg.sender, address(0), _burnAmount);\r\n        return (\"Burn Successful. Tokens Burned: \", _burnAmount);\r\n    }\r\n\r\n    // Function to allow owner to withraw funds from the contract\r\n    function withdrawFunds(address tokenAddress, uint256 amount) external onlyAdmin functionLock payable {\r\n        require (!paused, \"Contract is currently paused\");\r\n        // Handling Ether withdrawal\r\n        if (tokenAddress == address(0)) {\r\n            require(address(this).balance >= amount, \"Insufficient ETH balance\");\r\n            (bool success, ) = msg.sender.call{value: amount}(\"\");\r\n            require(success, \"ETH transfer failed\");\r\n        } else {\r\n            // Handling ERC20 token withdrawal\r\n            require(tokenAddress != address(0), \"Invalid token address\");\r\n            uint256 balance = ERC20(tokenAddress).balanceOf(address(this));\r\n            require(balance >= amount, \"Insufficient token balance\");\r\n            require(ERC20(tokenAddress).transfer(msg.sender, amount), \"Token transfer failed\");\r\n        }\r\n    }\r\n\r\n    // Function to manually transfer ERC20 tokens from contract\r\n        function manualTokenTransfer(address tokenAddress, address to, uint256 amount) external onlyAdmin functionLock returns(bool){\r\n        require (!paused, \"Contract is currently paused\");\r\n        ERC20 tokenContract = ERC20(tokenAddress);\r\n        bool success = tokenContract.transfer(to, amount);\r\n        require(success, \"Token transfer failed\");\r\n        return success;\r\n    }\r\n\r\n    // Distribute purchased wMetallis Tokens when purchased and called by the Main Contract\r\n    function distributeTokens(address _buyer, uint256 wMetallisAmount) external onlyAuthorizedContracts functionLock returns (bool) {\r\n        require (!paused, \"Contract is currently paused\");\r\n        require(_balances[address(this)] >= wMetallisAmount, \"Insufficient wMetallis balance in contract\"); // Make sure the contract has enough minted tokens to complete the transaction\r\n        bool success =_transfer(address(this), _buyer, wMetallisAmount); // Call the internal _transfer function to send wMetalllis to buyer\r\n        require(success, \"Distribute tokens failed\"); // if transfer fails, revert and throw error\r\n        distributedTokens[msg.sender][_buyer] += wMetallisAmount; // Map the caller,buyer, and wMetallis amount transfered\r\n        return true; // Tell the main contract that the distribution was completed ok\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyAdmin {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisigAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_metallisMainAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAuthorized\",\"type\":\"bool\"}],\"name\":\"AuthorizationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zeroAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"BurnSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InternalTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"MintSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_multisigContract\",\"type\":\"address\"}],\"name\":\"MultisigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"TokenInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_websiteUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"contract ERC20\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"authorizeContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnAmount\",\"type\":\"uint256\"}],\"name\":\"burnwMetallis\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"}],\"name\":\"contractBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wMetallisAmount\",\"type\":\"uint256\"}],\"name\":\"distributeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultisigAddress\",\"outputs\":[{\"internalType\":\"contract Imultisig\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isContractAuthorized\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"}],\"name\":\"isTokenActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logoUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintwMetallis\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"}],\"name\":\"removeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"revokeContractAuthorization\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdminAddress\",\"type\":\"address\"}],\"name\":\"setAdminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metallisMainAddress\",\"type\":\"address\"}],\"name\":\"setMetallisMainContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisigAddress\",\"type\":\"address\"}],\"name\":\"setMultisigContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wMetallisBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "wMetallis", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a45570bBE3aA2B313E9c2e2b89738b7f04F9Da54000000000000000000000000a45570bBE3aA2B313E9c2e2b89738b7f04F9Da54000000000000000000000000a45570bBE3aA2B313E9c2e2b89738b7f04F9Da54", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b523f9516f39f3d1149cd2a08684c1ed5fd31ef51fbcbdba50378546e53652db"}