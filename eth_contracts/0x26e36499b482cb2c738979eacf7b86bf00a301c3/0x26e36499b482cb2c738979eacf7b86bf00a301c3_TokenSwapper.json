{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ISwapTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.26;\\n\\n/**\\n * @title A simple NFT swapper contract with no fee takers.\\n * @author The Dark Jester\\n * @notice You can use this contract for ERC721 swaps where one party can set up a deal and the other accept.\\n * @notice Any party can sweeten the deal with ETH, but that must be set up by the initiator.\\n */\\ninterface ISwapTokens {\\n  enum TokenType {\\n    NONE,\\n    ERC20, // xERC20, ERC777 really as well\\n    ERC777,\\n    ERC721,\\n    ERC1155\\n  }\\n\\n  /**\\n   * @dev Emitted when a new swap is initiated.\\n   * @param swapId The unique swapId.\\n   * @param initiator The initiator address.\\n   * @param acceptor The acceptor address.\\n   * @param swap The full swap data.\\n   */\\n  event SwapInitiated(uint256 indexed swapId, address indexed initiator, address indexed acceptor, Swap swap);\\n\\n  /**\\n   * @dev Emitted when a new swap is removed by the initiator.\\n   * @param swapId The unique swapId.\\n   * @param initiator The initiator address.\\n   */\\n  event SwapRemoved(uint256 indexed swapId, address indexed initiator);\\n\\n  /**\\n   * @dev Emitted when a a user withdraws their balance.\\n   * @param user The user address withdrawing a balance.\\n   * @param amount The amount being withdrawn.\\n   */\\n  event BalanceWithDrawn(address indexed user, uint256 amount);\\n\\n  /**\\n   * @dev Emitted when a new swap is completed by the acceptor.\\n   * @param swapId The unique swapId.\\n   * @param initiator The initiator address.\\n   * @param acceptor The acceptor address.\\n   * @param swap The full swap data.\\n   */\\n  event SwapComplete(uint256 indexed swapId, address indexed initiator, address indexed acceptor, Swap swap);\\n\\n  /**\\n   * @dev initiatorERCContract is the contract address for the initiator's NFT.\\n   * @dev acceptorERCContract is the contract address for the acceptors's NFT (may be same as initiator's).\\n   * @dev initiator is the address for the account initiating the swap.\\n   * @dev initiatorTokenId is the NFT Id for the initiator's token.\\n   * @dev initiatorTokenQuantity is the quantity of the initiator's token.\\n   * @dev acceptor is the address for the account accepting the swap.\\n   * @dev acceptorTokenId is the NFT Id for the acceptor's token.\\n   * @dev acceptorTokenQuantity is the quantity of the acceptor's token.\\n   * @dev initiatorETHPortion is the ETH sweetener offered by the intiator.\\n   * @dev acceptorETHPortion is the ETH sweetener to be provided by the acceptor.\\n   * @dev initiatorTokenType The type of token used to determine swap mechanics.\\n   * @dev acceptorTokenType The type of token used to determine swap mechanics.\\n   */\\n  struct Swap {\\n    address initiatorERCContract;\\n    address acceptorERCContract;\\n    address initiator;\\n    uint256 initiatorTokenId;\\n    uint256 initiatorTokenQuantity;\\n    address acceptor;\\n    uint256 acceptorTokenId;\\n    uint256 acceptorTokenQuantity;\\n    uint256 initiatorETHPortion;\\n    uint256 acceptorETHPortion;\\n    TokenType initiatorTokenType;\\n    TokenType acceptorTokenType;\\n  }\\n\\n  /**\\n   * @dev initiatorNeedsToOwnToken is the boolean indicating if the initiator owns the token.\\n   * @dev acceptorNeedsToOwnToken is the boolean indicating if the acceptor owns the token.\\n   * @dev initiatorTokenRequiresApproval is the boolean indicating if the initiator has approved the swap contract for the NFT.\\n   * @dev acceptorTokenRequiresApproval is the boolean indicating if the accepor has approved the swap contract for the NFT.\\n   * @dev isReadyForSwapping a bool indicating if the swap is ready.\\n   * @dev all have to be true for the swap to work.\\n   */\\n  struct SwapStatus {\\n    bool initiatorNeedsToOwnToken;\\n    bool acceptorNeedsToOwnToken;\\n    bool initiatorTokenRequiresApproval;\\n    bool acceptorTokenRequiresApproval;\\n    bool isReadyForSwapping;\\n  }\\n\\n  /**\\n   * @dev Thrown when an address is address(0).\\n   */\\n  error ZeroAddressDisallowed();\\n\\n  /**\\n   * @dev Thrown when the swap is expecting both parties to provide ETH.\\n   */\\n  error TwoWayEthPortionsDisallowed();\\n\\n  /**\\n   * @dev Thrown when the swap is returns an empty struct.\\n   */\\n  error SwapCompleteOrDoesNotExist();\\n\\n  /**\\n   * @dev Thrown when the balance of the withdrawing address is 0.\\n   */\\n  error EmptyWithdrawDisallowed();\\n\\n  /**\\n   * @dev Thrown when the swap completor is not the acceptor account.\\n   */\\n  error NotAcceptor();\\n\\n  /**\\n   * @dev Thrown when the swap remover is not the initiator account.\\n   */\\n  error NotInitiator();\\n\\n  /**\\n   * @dev Thrown when the initiator is not providing a token or a value for either initiator or acceptor.\\n   */\\n  error ValueOrTokenMissing();\\n\\n  /**\\n   * @dev Thrown when the initiator is not providing a token or a value for either initiator or acceptor.\\n   */\\n  error ZeroAddressSetForValidTokenType();\\n\\n  /**\\n   * @dev Thrown when the tokenAddress is zero address but the token or amount is set.\\n   */\\n  error TokenIdMissing();\\n\\n  /**\\n   * @dev Thrown when the tokenAddress is zero address but the token or amount is set.\\n   */\\n  error TokenQuantityMissing();\\n\\n  /**\\n   * @dev Thrown when ETH is not provided on completing the swap.\\n   * @param expectedETHPortion The expected ETH portion.\\n   */\\n  error IncorrectOrMissingAcceptorETH(uint256 expectedETHPortion);\\n\\n  /**\\n   * @dev Thrown when the destination for the ETH reverts acceptance.\\n   */\\n  error ETHSendingFailed();\\n\\n  /**\\n   * @dev Thrown when reentrancy.\\n   */\\n  error NoReentry();\\n\\n  /**\\n   * @dev Thrown when the token transfer failed.\\n   */\\n  error TokenTransferFailed(address tokenAddress, uint256);\\n\\n  /**\\n   * @dev Thrown when the initiator in the config does not match the msg.sender.\\n   * @param expected The expected initiator address.\\n   * @param actual The actual initiator address (msg.sender).\\n   */\\n  error InitiatorNotMatched(address expected, address actual);\\n\\n  /**\\n   * @dev Thrown when the initiator ETH portion does not match the msg.value.\\n   * @param expected The expected initator ETH portion.\\n   * @param actual The actual initator ETH portion (msg.value).\\n   */\\n  error InitiatorEthPortionNotMatched(uint256 expected, uint256 actual);\\n\\n  /**\\n   * @notice Initiates a swap of two NFTs.\\n   * @dev If ETH is sent, it is used as the initiator ETH portion.\\n   * @dev msg.sender is the initiator.\\n   * @param _swap The full swap details.\\n   */\\n  function initiateSwap(Swap calldata _swap) external payable;\\n\\n  /**\\n   * @notice Completes the swap.\\n   * @dev If ETH is sent, it is used as the acceptor ETH portion.\\n   * @dev msg.sender is the acceptor.\\n   * @dev The ETH portion is added to either the acceptor or the initiator balance.\\n   * @param _swapId The ID of the swap.\\n   * @param _swap The full swap data as retrieved from the initiating event.\\n   */\\n  function completeSwap(uint256 _swapId, Swap calldata _swap) external payable;\\n\\n  /**\\n   * @notice Cancels/Removes the swap if not accepted.\\n   * @dev msg.sender is the initiator.\\n   * @dev The Initiator ETH portion is added to the initiator balance if exists.\\n   * @param _swapId The ID of the swap.\\n   * @param _swap The full swap data as retrieved from the initiating event.\\n   */\\n  function removeSwap(uint256 _swapId, Swap calldata _swap) external;\\n\\n  /**\\n   * @notice Withdraws the msg.sender's balance if it exists.\\n   * @dev The ETH balance is sent to the msg.sender.\\n   */\\n  function withdraw() external;\\n\\n  /**\\n   * @notice Retrieves the isSameContractSwap in transient storage.\\n   * @return isSameContractSwap If tokens are swapped between two parties on the same contract.\\n   */\\n  function isSwappingTokensOnSameContract() external view returns (bool isSameContractSwap);\\n\\n  /**\\n   * @notice Retrieves the NFT status.\\n   * @param _swapId The ID of the swap.\\n   * @param _swap The full swap details.\\n   * @dev Unhandled error scenarios:\\n   * @dev  contract 1 does not exist.\\n   * @dev contract 2 does not exist.\\n   * @dev token 1 does not exist.\\n   * @dev token 2 does not exist.\\n   * @return swapStatus The checked ownership and permissions struct for both parties's NFTs.\\n   */\\n  function getSwapStatus(uint256 _swapId, Swap calldata _swap) external view returns (SwapStatus memory swapStatus);\\n}\\n\\n/*   \\n                                                              \\nT H E D A R K J E S T E R . E T H\\n\\n\\n                                        %%##%%%&                                \\n                           ,@@@@(     %#%%%%%%%%%&                              \\n                          ,&&&&@@@& %##%%%&%    ,#&                             \\n                          &&&&%&&&&%%#%#%%&       #                             \\n                         *&   %&& @% .% @&%       .,                            \\n                         /     & %  @#% @%&%                                    \\n                                  /....@/#&&                                    \\n                                  .../*@..%&.                                   \\n                                 ,    **&@&&                                    \\n                           *&#%%&%&&@@&&&&%&@@&@                                \\n                       %#####&&&&&&&&&/(&&&&&&&&&&&%%                            \\n                     %#######&&&&&&&#//((%&&&&&&&&&@@&&(                         \\n @@# *&*   @&       &%######%&&&&&&////((((&&&&&&&&@@&&&&                        \\n . .%&&&&%%@&*     &%########&&&&//////(((((#&&&&&&@@&@%@#                       \\n     &&&@@&@@@@@&&@&#&&%#####&&&////(((())(((&&&&&@@@@@@&                       \\n    &*&&&@&%@@@@@@@@@&&%#%###&#((((((()))))))))%&&&&&&@%%%                       \\n     &%&&&&@@@@@@@&@&&#*  ##&&#\\\\(((#(((())))))%%&&@@&&&%%@                      \\n    % %*&%.%.  .*@&@#  * .#%&&&&//(# T D J ((&&&&@@@ &&&&&&&*                   \\n       / %*              , #%&&&&&/////((((/&&&&&&@  @&&&&&&%%%##/#/  .*&&*      \\n         .,                 #&&&&&&%///(((/&&&&&&&(    /&%%%&%%%%&%&%%%%@@@@@@@@,\\n                             @%#%%%##\\\\%%&/&&@&@@*         &%%&%%%&%%%&%@@@@ #%@@\\n                            &#&&@&&&&&\\\\&/@@@@@@@@@             *%&&%&&%&&@@   #@ \\n                           ##&@&&%%%%%&&&@&@&@@&&@               %%&&%#.%  @    \\n                          ,#%&@&&&%#%%&&&&&&@@&&@@/             *% *%%( &       \\n                          .#%@@@&@%%%%&&&&&&&&&&@@.                 *%          \\n                          %#&@@&&@%%%%&&&&&&&&&&&&&.                 (          \\n                          ##&@&&&&%%%&&&&&%%&&%%&&&%                            \\n                          #%&@&&&&&%%&%&&&%%%%%%%%&%&                           \\n                         *#&&@&&&&@#@@%%&&%%%%%%%%%&%&                          \\n                         %&&@@&&&&&@@@@%%%%%%%%%%%%%%%&                         \\n                         &&&@@&&&&&@@#   %%%%%%%%%%%%%%.                        \\n                         &&&@@&&&&&&#     *%%%%%%%%%%%%%                        \\n                         .%&@@&&&&&@        %%%%%%%%%%%%%                       \\n                          &&@@&@@&&/         ,%%%%%%%%%%%&,                     \\n                           &@@@@@@&@           %%%%%%%%%%%%%                    \\n                           @@@@@@@@@#           (%%%%%%&%%%%%%                  \\n                           (&&@@@@@@@             %%%%%%&%%%%%#                 \\n                            @&&@@@@@&@             /%%%%%&%%%%%(                \\n                             &&&@@@@@@               %%%%%&&%%%%                \\n                             *&&&@@@@@@               %%%%%%&&%%&               \\n                              (&&&@@@@&@.               &%%%%%&%%%&             \\n                               #&&@@@@@@@                 &%%&%&%&&             \\n                                  @@@@@@@&@                  &&&&%%&%           \\n                                  &@@&&&&@ .                %&%&&%@%&&%         \\n                                 *&@@&&@@&&                 %%%.@&(&&@          \\n                             &&@&&&&@@@@@@(                 %(%#&&%(%,          \\n                               (#%#,                         ,,&&@&&&,  \\n                                                              \\nT H E D A R K J E S T E R . E T H\\n                \\n*/\\n\"\r\n    },\r\n    \"contracts/TokenSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.26;\\n\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC1155 } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport { ISwapTokens } from \\\"./ISwapTokens.sol\\\";\\nimport { TokenSwapperUtils } from \\\"./TokenSwapperUtils.sol\\\";\\n\\n/**\\n * @title A simple NFT swapper contract with no fee takers.\\n * @author The Dark Jester\\n * @notice You can use this contract for ERC721 swaps where one party can set up a deal and the other accept.\\n * @notice Any party can sweeten the deal with ETH, but that must be set up by the initiator.\\n */\\ncontract TokenSwapper is ISwapTokens {\\n  bytes32 private constant SAME_CONTRACT_SWAP_TRANSIENT_KEY =\\n    bytes32(uint256(keccak256(\\\"eip1967.same.contract.swap.transient.key\\\")) - 1);\\n\\n  bytes32 private constant REENTRY_TRANSIENT_KEY = bytes32(uint256(keccak256(\\\"eip1967.reentry.transient.key\\\")) - 1);\\n\\n  using TokenSwapperUtils for *;\\n\\n  address private constant ZERO_ADDRESS = address(0);\\n\\n  // user account => balance\\n  mapping(address userAddress => uint256 balance) public balances;\\n\\n  // Deployer pays for the slot vs. the first swapper. Being kind.\\n  uint256 public swapId = 1;\\n\\n  mapping(uint256 id => bytes32 hashedSwap) public swapHashes;\\n\\n  /// @dev This exists purely to drop the deployment cost by a few hundred gas.\\n  constructor() payable {}\\n\\n  /**\\n   * @notice Initiates a swap of two NFTs.\\n   * @dev If ETH is sent, it is used as the initiator ETH portion.\\n   * @dev NB: Some invariant conditions:\\n   * @dev msg.sender is validated to be the initiator, and,\\n   * This is deliberate so that nobody and do it without you knowing.\\n   * @dev msg.value must match the _swap.initiatorETHPortion to avoid sneaky exploits.\\n   * @param _swap The full swap details.\\n   */\\n  function initiateSwap(Swap memory _swap) external payable {\\n    if (_swap.acceptor == ZERO_ADDRESS) {\\n      revert ZeroAddressDisallowed();\\n    }\\n\\n    if (msg.sender != _swap.initiator) {\\n      revert InitiatorNotMatched(_swap.initiator, msg.sender);\\n    }\\n\\n    if (msg.value != _swap.initiatorETHPortion) {\\n      revert InitiatorEthPortionNotMatched(_swap.initiatorETHPortion, msg.value);\\n    }\\n\\n    if (msg.value > 0 && _swap.acceptorETHPortion > 0) {\\n      revert TwoWayEthPortionsDisallowed();\\n    }\\n\\n    if (_swap.initiatorTokenType == TokenType.NONE && _swap.acceptorTokenType == TokenType.NONE) {\\n      revert TwoWayEthPortionsDisallowed();\\n    }\\n\\n    getTokenTypeValidator(_swap.initiatorTokenType)(\\n      _swap.initiatorERCContract,\\n      _swap.initiatorETHPortion,\\n      _swap.initiatorTokenId,\\n      _swap.initiatorTokenQuantity\\n    );\\n\\n    if (_swap.initiatorTokenType == TokenType.NONE) {\\n      _swap.initiatorTokenId = 0;\\n      _swap.initiatorERCContract = ZERO_ADDRESS;\\n      _swap.initiatorTokenQuantity = 0;\\n    }\\n\\n    getTokenTypeValidator(_swap.acceptorTokenType)(\\n      _swap.acceptorERCContract,\\n      _swap.acceptorETHPortion,\\n      _swap.acceptorTokenId,\\n      _swap.acceptorTokenQuantity\\n    );\\n\\n    if (_swap.acceptorTokenType == TokenType.NONE) {\\n      _swap.acceptorTokenId = 0;\\n      _swap.acceptorERCContract = ZERO_ADDRESS;\\n      _swap.acceptorTokenQuantity = 0;\\n    }\\n\\n    unchecked {\\n      uint256 newSwapId = swapId++;\\n\\n      // _swap emitted to pass in later when querying, completing or removing\\n      emit SwapInitiated(newSwapId, msg.sender, _swap.acceptor, _swap);\\n\\n      swapHashes[newSwapId] = TokenSwapperUtils.hashTokenSwap(_swap);\\n    }\\n  }\\n\\n  /**\\n   * @notice Completes the swap.\\n   * @dev If ETH is sent, it is used as the acceptor ETH portion.\\n   * @dev msg.sender is the acceptor.\\n   * @dev The ETH portion is added to either the acceptor or the initiator balance.\\n   * @param _swapId The ID of the swap.\\n   * @param _swap The swap data to use and verify.\\n   */\\n  function completeSwap(uint256 _swapId, Swap memory _swap) external payable nonReentrant {\\n    if (swapHashes[_swapId] != TokenSwapperUtils.hashTokenSwap(_swap)) {\\n      revert SwapCompleteOrDoesNotExist();\\n    }\\n\\n    if (_swap.acceptor != msg.sender) {\\n      revert NotAcceptor();\\n    }\\n\\n    if (_swap.initiatorETHPortion > 0 && msg.value > 0) {\\n      revert TwoWayEthPortionsDisallowed();\\n    }\\n\\n    if (_swap.acceptorETHPortion != msg.value) {\\n      revert IncorrectOrMissingAcceptorETH(_swap.acceptorETHPortion);\\n    }\\n\\n    /// @dev Doing this prevents reentry.\\n    delete swapHashes[_swapId];\\n\\n    if (msg.value > 0) {\\n      unchecked {\\n        /// @dev msg.value should never overflow - nobody has that amount of ETH.\\n        balances[_swap.initiator] += msg.value;\\n      }\\n    }\\n\\n    if (_swap.initiatorETHPortion > 0) {\\n      unchecked {\\n        /// @dev This should never overflow - portion is either zero or a number way less that max uint256.\\n        balances[_swap.acceptor] += _swap.initiatorETHPortion;\\n      }\\n    }\\n\\n    emit SwapComplete(_swapId, _swap.initiator, _swap.acceptor, _swap);\\n\\n    TokenSwapperUtils.storeTransientBool(\\n      SAME_CONTRACT_SWAP_TRANSIENT_KEY,\\n      _swap.acceptorERCContract == _swap.initiatorERCContract\\n    );\\n\\n    getTokenTransfer(_swap.initiatorTokenType)(\\n      _swap.initiatorERCContract,\\n      _swap.initiatorTokenId,\\n      _swap.initiatorTokenQuantity,\\n      _swap.initiator,\\n      _swap.acceptor\\n    );\\n\\n    getTokenTransfer(_swap.acceptorTokenType)(\\n      _swap.acceptorERCContract,\\n      _swap.acceptorTokenId,\\n      _swap.acceptorTokenQuantity,\\n      _swap.acceptor,\\n      _swap.initiator\\n    );\\n\\n    TokenSwapperUtils.wipeTransientBool(SAME_CONTRACT_SWAP_TRANSIENT_KEY);\\n  }\\n\\n  /**\\n   * @notice Cancels/Removes the swap if not accepted.\\n   * @dev msg.sender is the initiator.\\n   * @dev The Initiator ETH portion is added to the initiator balance if exists.\\n   * @param _swapId The ID of the swap.\\n   */\\n  function removeSwap(uint256 _swapId, Swap memory _swap) external nonReentrant {\\n    if (swapHashes[_swapId] != TokenSwapperUtils.hashTokenSwap(_swap)) {\\n      revert SwapCompleteOrDoesNotExist();\\n    }\\n\\n    if (_swap.initiator != msg.sender) {\\n      revert NotInitiator();\\n    }\\n\\n    delete swapHashes[_swapId];\\n\\n    if (_swap.initiatorETHPortion > 0) {\\n      unchecked {\\n        // msg.value should never overflow - nobody has that amount of ETH\\n        balances[msg.sender] += _swap.initiatorETHPortion;\\n      }\\n    }\\n\\n    emit SwapRemoved(_swapId, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Withdraws the msg.sender's balance if it exists.\\n   * @dev The ETH balance is sent to the msg.sender.\\n   */\\n  function withdraw() external {\\n    uint256 callerBalance = balances[msg.sender];\\n\\n    if (callerBalance == 0) {\\n      revert EmptyWithdrawDisallowed();\\n    }\\n\\n    delete balances[msg.sender];\\n\\n    emit BalanceWithDrawn(msg.sender, callerBalance);\\n\\n    bytes4 errorSelector = ISwapTokens.ETHSendingFailed.selector;\\n    assembly {\\n      let success := call(gas(), caller(), callerBalance, 0, 0, 0, 0)\\n      if iszero(success) {\\n        let ptr := mload(0x40)\\n        mstore(ptr, errorSelector)\\n        revert(ptr, 0x4)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Retrieves the Swap status.\\n   * @param _swapId The ID of the swap.\\n   * @param _swap The swap details.\\n   * @return swapStatus The checked ownership and permissions struct for both parties's NFTs.\\n   */\\n  function getSwapStatus(uint256 _swapId, Swap memory _swap) external view returns (SwapStatus memory swapStatus) {\\n    if (swapHashes[_swapId] != TokenSwapperUtils.hashTokenSwap(_swap)) {\\n      revert SwapCompleteOrDoesNotExist();\\n    }\\n\\n    (bool initiatorNeedsToOwnToken, bool initiatorTokenRequiresApproval) = getTokenSwapStatusFunction(\\n      _swap.initiatorTokenType\\n    )(_swap.initiatorERCContract, _swap.initiatorTokenId, _swap.initiatorTokenQuantity, _swap.initiator);\\n\\n    swapStatus.initiatorNeedsToOwnToken = initiatorNeedsToOwnToken;\\n    swapStatus.initiatorTokenRequiresApproval = initiatorTokenRequiresApproval;\\n\\n    (bool acceptorNeedsToOwnToken, bool acceptorTokenRequiresApproval) = getTokenSwapStatusFunction(\\n      _swap.acceptorTokenType\\n    )(_swap.acceptorERCContract, _swap.acceptorTokenId, _swap.acceptorTokenQuantity, _swap.acceptor);\\n\\n    swapStatus.acceptorNeedsToOwnToken = acceptorNeedsToOwnToken;\\n    swapStatus.acceptorTokenRequiresApproval = acceptorTokenRequiresApproval;\\n\\n    swapStatus.isReadyForSwapping =\\n      !(swapStatus.initiatorNeedsToOwnToken) &&\\n      !(swapStatus.initiatorTokenRequiresApproval) &&\\n      !(swapStatus.acceptorNeedsToOwnToken) &&\\n      !(swapStatus.acceptorTokenRequiresApproval);\\n  }\\n\\n  function isSwappingTokensOnSameContract() external view returns (bool isSameContractSwap) {\\n    isSameContractSwap = TokenSwapperUtils.loadTransientBool(SAME_CONTRACT_SWAP_TRANSIENT_KEY);\\n  }\\n\\n  /**\\n   * @notice Returns dynamic token type validator.\\n   * @param _tokenType The token type to return.\\n   * @return The parameter validator for the token type.\\n   */\\n  function getTokenTypeValidator(\\n    TokenType _tokenType\\n  ) internal pure returns (function(address, uint256, uint256, uint256) internal pure) {\\n    if (_tokenType == TokenType.ERC721) {\\n      return validateERC721SwapParameters;\\n    }\\n\\n    if (_tokenType == TokenType.ERC20 || _tokenType == TokenType.ERC777) {\\n      return validateERC20SwapParameters;\\n    }\\n\\n    if (_tokenType == TokenType.ERC1155) {\\n      return validateERC1155SwapParameters;\\n    }\\n\\n    return validateNoTokenTypeSwapParameters;\\n  }\\n\\n  /**\\n   * @notice Validates ERC20 parameters.\\n   * @param _ercContract The ERC20 contract.\\n   * @param _tokenQuantity The token quantity.\\n   */\\n  function validateERC20SwapParameters(address _ercContract, uint256, uint256, uint256 _tokenQuantity) internal pure {\\n    // validate address exists\\n    if (_ercContract == ZERO_ADDRESS) {\\n      revert ZeroAddressSetForValidTokenType();\\n    }\\n\\n    // validate quantity > 0\\n    if (_tokenQuantity == 0) {\\n      revert TokenQuantityMissing();\\n    }\\n  }\\n\\n  /**\\n   * @notice Validates ERC721 parameters.\\n   * @param _ercContract The ERC721 contract.\\n   * @param _tokenId The tokenId.\\n   */\\n  function validateERC721SwapParameters(address _ercContract, uint256, uint256 _tokenId, uint256) internal pure {\\n    // validate address exists\\n    if (_ercContract == ZERO_ADDRESS) {\\n      revert ZeroAddressSetForValidTokenType();\\n    }\\n\\n    // validate _tokenId > 0\\n    if (_tokenId == 0) {\\n      revert TokenIdMissing();\\n    }\\n  }\\n\\n  /**\\n   * @notice Validates ERC1155 parameters.\\n   * @param _ercContract The ERC1155 contract.\\n   * @param _tokenId The tokenId.\\n   * @param _tokenQuantity The tokenId.\\n   */\\n  function validateERC1155SwapParameters(\\n    address _ercContract,\\n    uint256,\\n    uint256 _tokenId,\\n    uint256 _tokenQuantity\\n  ) internal pure {\\n    // validate address exists\\n    if (_ercContract == ZERO_ADDRESS) {\\n      revert ZeroAddressSetForValidTokenType();\\n    }\\n\\n    // validate _tokenId > 0\\n    if (_tokenId == 0) {\\n      revert TokenIdMissing();\\n    }\\n\\n    // validate quantity > 0\\n    if (_tokenQuantity == 0) {\\n      revert TokenQuantityMissing();\\n    }\\n  }\\n\\n  /**\\n   * @notice Validates token type none parameters.\\n   * @param _ethPortion The ETH portion of the side of the swap.\\n   */\\n  function validateNoTokenTypeSwapParameters(address, uint256 _ethPortion, uint256, uint256) internal pure {\\n    if (_ethPortion == 0) {\\n      revert ValueOrTokenMissing();\\n    }\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to determine a swap's status based on token type.\\n   * @param _tokenType The token type to return.\\n   * @return The swap status checking function.\\n   */\\n  function getTokenSwapStatusFunction(\\n    TokenType _tokenType\\n  ) internal pure returns (function(address, uint256, uint256, address) view returns (bool, bool)) {\\n    if (_tokenType == TokenType.ERC20 || _tokenType == TokenType.ERC777) {\\n      return erc20Status;\\n    }\\n\\n    if (_tokenType == TokenType.ERC721) {\\n      return erc721Status;\\n    }\\n\\n    if (_tokenType == TokenType.ERC1155) {\\n      return erc1155Status;\\n    }\\n\\n    return noneStatus;\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to determine a swap's status based on ERC20 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenQuantity The token quantity being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @return needsToOwnToken Does the user need to own the token.\\n   * @return tokenRequiresApproval Does the user need to grant approval.\\n   */\\n  function erc20Status(\\n    address _tokenAddress,\\n    uint256,\\n    uint256 _tokenQuantity,\\n    address _tokenOwner\\n  ) internal view returns (bool needsToOwnToken, bool tokenRequiresApproval) {\\n    IERC20 erc20Token = IERC20(_tokenAddress);\\n\\n    needsToOwnToken = erc20Token.balanceOf(_tokenOwner) < _tokenQuantity;\\n    tokenRequiresApproval = erc20Token.allowance(_tokenOwner, address(this)) < _tokenQuantity;\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to determine a swap's status based on ERC721 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenId The token Id being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @return needsToOwnToken Does the user need to own the token.\\n   * @return tokenRequiresApproval Does the user need to grant approval.\\n   */\\n  function erc721Status(\\n    address _tokenAddress,\\n    uint256 _tokenId,\\n    uint256,\\n    address _tokenOwner\\n  ) internal view returns (bool needsToOwnToken, bool tokenRequiresApproval) {\\n    IERC721 erc721Token = IERC721(_tokenAddress);\\n\\n    needsToOwnToken = erc721Token.ownerOf(_tokenId) != _tokenOwner;\\n    tokenRequiresApproval = erc721Token.getApproved(_tokenId) != address(this);\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to determine a swap's status based on ERC1155 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenId The token Id being swapped.\\n   * @param _tokenQuantity The token quantity being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @return needsToOwnToken Does the user need to own the token.\\n   * @return tokenRequiresApproval Does the user need to grant approval.\\n   */\\n  function erc1155Status(\\n    address _tokenAddress,\\n    uint256 _tokenId,\\n    uint256 _tokenQuantity,\\n    address _tokenOwner\\n  ) internal view returns (bool needsToOwnToken, bool tokenRequiresApproval) {\\n    IERC1155 erc1155Token = IERC1155(_tokenAddress);\\n\\n    needsToOwnToken = erc1155Token.balanceOf(_tokenOwner, _tokenId) < _tokenQuantity;\\n    tokenRequiresApproval = !erc1155Token.isApprovedForAll(_tokenOwner, address(this));\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to determine a swap's status based on NONE token type.\\n   * @dev default false values are expected.\\n   * @return needsToOwnToken Does the user need to own the token.\\n   * @return tokenRequiresApproval Does the user need to grant approval.\\n   */\\n  function noneStatus(\\n    address,\\n    uint256,\\n    uint256,\\n    address\\n  ) internal view returns (bool needsToOwnToken, bool tokenRequiresApproval) {}\\n\\n  /**\\n   * @notice Retrieves the function to transfer a swap's token based on token type.\\n   * @param _tokenType The token type to return.\\n   * @return Returns the function to do the transferring for the token type.\\n   */\\n  function getTokenTransfer(\\n    TokenType _tokenType\\n  ) internal pure returns (function(address, uint256, uint256, address, address)) {\\n    if (_tokenType == TokenType.ERC20 || _tokenType == TokenType.ERC777) {\\n      return erc20Transferer;\\n    }\\n\\n    if (_tokenType == TokenType.ERC721) {\\n      return erc721Transferer;\\n    }\\n\\n    if (_tokenType == TokenType.ERC1155) {\\n      return erc1155Transferer;\\n    }\\n\\n    return noneTransferer;\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to transfer a swap's token based on ERC20 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenQuantity The token quantity being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @param _recipient The token recipient.\\n   */\\n  function erc20Transferer(\\n    address _tokenAddress,\\n    uint256,\\n    uint256 _tokenQuantity,\\n    address _tokenOwner,\\n    address _recipient\\n  ) internal {\\n    if (!IERC20(_tokenAddress).transferFrom(_tokenOwner, _recipient, _tokenQuantity)) {\\n      revert TokenTransferFailed(_tokenAddress, _tokenQuantity);\\n    }\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to transfer a swap's token based on ERC721 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenId The token Id being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @param _recipient The token recipient.\\n   */\\n  function erc721Transferer(\\n    address _tokenAddress,\\n    uint256 _tokenId,\\n    uint256,\\n    address _tokenOwner,\\n    address _recipient\\n  ) internal {\\n    IERC721(_tokenAddress).safeTransferFrom(_tokenOwner, _recipient, _tokenId);\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to transfer a swap's token based on ERC721 token type.\\n   * @param _tokenAddress The token address being checked.\\n   * @param _tokenId The token Id being swapped.\\n   * @param _tokenQuantity The token quantity being swapped.\\n   * @param _tokenOwner The expected owber of the token(s).\\n   * @param _recipient The token recipient.\\n   */\\n  function erc1155Transferer(\\n    address _tokenAddress,\\n    uint256 _tokenId,\\n    uint256 _tokenQuantity,\\n    address _tokenOwner,\\n    address _recipient\\n  ) internal {\\n    IERC1155(_tokenAddress).safeTransferFrom(_tokenOwner, _recipient, _tokenId, _tokenQuantity, \\\"0x\\\");\\n  }\\n\\n  /**\\n   * @notice Retrieves the function to transfer a swap's token based on NONE token type.\\n   * @dev While this seems counterintuitive to do nothing, it is cleaner this way.\\n   */\\n  function noneTransferer(address, uint256, uint256, address, address) internal pure {}\\n\\n  modifier nonReentrant() {\\n    if (TokenSwapperUtils.loadTransientBool(REENTRY_TRANSIENT_KEY)) {\\n      revert NoReentry();\\n    }\\n\\n    TokenSwapperUtils.storeTransientBool(REENTRY_TRANSIENT_KEY, true);\\n    _;\\n    TokenSwapperUtils.wipeTransientBool(REENTRY_TRANSIENT_KEY);\\n  }\\n}\\n\\n/*   \\n                                                              \\nT H E D A R K J E S T E R . E T H\\n\\n\\n                                        %%##%%%&                                \\n                           ,@@@@(     %#%%%%%%%%%&                              \\n                          ,&&&&@@@& %##%%%&%    ,#&                             \\n                          &&&&%&&&&%%#%#%%&       #                             \\n                         *&   %&& @% .% @&%       .,                            \\n                         /     & %  @#% @%&%                                    \\n                                  /....@/#&&                                    \\n                                  .../*@..%&.                                   \\n                                 ,    **&@&&                                    \\n                           *&#%%&%&&@@&&&&%&@@&@                                \\n                       %#####&&&&&&&&&/(&&&&&&&&&&&%%                            \\n                     %#######&&&&&&&#//((%&&&&&&&&&@@&&(                         \\n @@# *&*   @&       &%######%&&&&&&////((((&&&&&&&&@@&&&&                        \\n . .%&&&&%%@&*     &%########&&&&//////(((((#&&&&&&@@&@%@#                       \\n     &&&@@&@@@@@&&@&#&&%#####&&&////(((())(((&&&&&@@@@@@&                       \\n    &*&&&@&%@@@@@@@@@&&%#%###&#((((((()))))))))%&&&&&&@%%%                       \\n     &%&&&&@@@@@@@&@&&#*  ##&&#\\\\(((#(((())))))%%&&@@&&&%%@                      \\n    % %*&%.%.  .*@&@#  * .#%&&&&//(# T D J ((&&&&@@@ &&&&&&&*                   \\n       / %*              , #%&&&&&/////((((/&&&&&&@  @&&&&&&%%%##/#/  .*&&*      \\n         .,                 #&&&&&&%///(((/&&&&&&&(    /&%%%&%%%%&%&%%%%@@@@@@@@,\\n                             @%#%%%##\\\\%%&/&&@&@@*         &%%&%%%&%%%&%@@@@ #%@@\\n                            &#&&@&&&&&\\\\&/@@@@@@@@@             *%&&%&&%&&@@   #@ \\n                           ##&@&&%%%%%&&&@&@&@@&&@               %%&&%#.%  @    \\n                          ,#%&@&&&%#%%&&&&&&@@&&@@/             *% *%%( &       \\n                          .#%@@@&@%%%%&&&&&&&&&&@@.                 *%          \\n                          %#&@@&&@%%%%&&&&&&&&&&&&&.                 (          \\n                          ##&@&&&&%%%&&&&&%%&&%%&&&%                            \\n                          #%&@&&&&&%%&%&&&%%%%%%%%&%&                           \\n                         *#&&@&&&&@#@@%%&&%%%%%%%%%&%&                          \\n                         %&&@@&&&&&@@@@%%%%%%%%%%%%%%%&                         \\n                         &&&@@&&&&&@@#   %%%%%%%%%%%%%%.                        \\n                         &&&@@&&&&&&#     *%%%%%%%%%%%%%                        \\n                         .%&@@&&&&&@        %%%%%%%%%%%%%                       \\n                          &&@@&@@&&/         ,%%%%%%%%%%%&,                     \\n                           &@@@@@@&@           %%%%%%%%%%%%%                    \\n                           @@@@@@@@@#           (%%%%%%&%%%%%%                  \\n                           (&&@@@@@@@             %%%%%%&%%%%%#                 \\n                            @&&@@@@@&@             /%%%%%&%%%%%(                \\n                             &&&@@@@@@               %%%%%&&%%%%                \\n                             *&&&@@@@@@               %%%%%%&&%%&               \\n                              (&&&@@@@&@.               &%%%%%&%%%&             \\n                               #&&@@@@@@@                 &%%&%&%&&             \\n                                  @@@@@@@&@                  &&&&%%&%           \\n                                  &@@&&&&@ .                %&%&&%@%&&%         \\n                                 *&@@&&@@&&                 %%%.@&(&&@          \\n                             &&@&&&&@@@@@@(                 %(%#&&%(%,          \\n                               (#%#,                         ,,&&@&&&,  \\n                                                              \\nT H E D A R K J E S T E R . E T H\\n                \\n*/\\n\"\r\n    },\r\n    \"contracts/TokenSwapperUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.24 <=0.8.26;\\n\\nimport { ISwapTokens } from \\\"./ISwapTokens.sol\\\";\\n/**\\n * @title A helper file for token swapping.\\n * @author The Dark Jester\\n * @notice You can use this contract for multi-token swaps.\\n */\\n\\nlibrary TokenSwapperUtils {\\n  /**\\n   * @notice Gas efficient swap hashing using inline assembly.\\n   * @dev There are 12 items in the struct, each using 32 bytes in calldata when used,\\n   * so to hash it we use 0x180 (384), or 12*32 (384) bytes.\\n   * @param _swap The full Swap struct.\\n   */\\n  function hashTokenSwap(ISwapTokens.Swap memory _swap) internal pure returns (bytes32 swapHash) {\\n    assembly {\\n      let mPtr := mload(0x40)\\n      mcopy(mPtr, _swap, 0x180)\\n      swapHash := keccak256(mPtr, 0x180)\\n    }\\n  }\\n\\n  function storeTransientBool(bytes32 _key, bool _storedBool) internal {\\n    assembly {\\n      tstore(_key, _storedBool)\\n    }\\n  }\\n\\n  function wipeTransientBool(bytes32 _key) internal {\\n    storeTransientBool(_key, false);\\n  }\\n\\n  function loadTransientBool(bytes32 _key) internal view returns (bool boolValue) {\\n    assembly {\\n      boolValue := tload(_key)\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"cancun\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETHSendingFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyWithdrawDisallowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedETHPortion\",\"type\":\"uint256\"}],\"name\":\"IncorrectOrMissingAcceptorETH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InitiatorEthPortionNotMatched\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actual\",\"type\":\"address\"}],\"name\":\"InitiatorNotMatched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAcceptor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitiator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapCompleteOrDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIdMissing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenQuantityMissing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TwoWayEthPortionsDisallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueOrTokenMissing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressDisallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressSetForValidTokenType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceWithDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"swapId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"SwapComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"swapId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"SwapInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"swapId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"SwapRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"_swap\",\"type\":\"tuple\"}],\"name\":\"completeSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"_swap\",\"type\":\"tuple\"}],\"name\":\"getSwapStatus\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"initiatorNeedsToOwnToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"acceptorNeedsToOwnToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initiatorTokenRequiresApproval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"acceptorTokenRequiresApproval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isReadyForSwapping\",\"type\":\"bool\"}],\"internalType\":\"struct ISwapTokens.SwapStatus\",\"name\":\"swapStatus\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"_swap\",\"type\":\"tuple\"}],\"name\":\"initiateSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwappingTokensOnSameContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isSameContractSwap\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initiatorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acceptorERCContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acceptor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initiatorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptorETHPortion\",\"type\":\"uint256\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"initiatorTokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum ISwapTokens.TokenType\",\"name\":\"acceptorTokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct ISwapTokens.Swap\",\"name\":\"_swap\",\"type\":\"tuple\"}],\"name\":\"removeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"swapHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashedSwap\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenSwapper", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}