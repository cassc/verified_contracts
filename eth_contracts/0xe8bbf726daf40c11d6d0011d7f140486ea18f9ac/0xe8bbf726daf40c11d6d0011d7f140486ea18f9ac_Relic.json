{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n// goerli test:\r\n// genart721: 0x5d498622B0AbCeb4A7038940f3566587bdfc0151\r\n// relic: 0x4aE89D271784421a73f7fbd6E002798cEB68d1a9\r\n\r\nabstract contract GenArt721  {\r\n  function purchaseTo(address _to, uint256 _projectId) public virtual payable returns (uint256 _tokenId);\r\n  function projectTokenInfo(uint256 _projectId) public virtual view returns (address artistAddress, uint256 pricePerTokenInWei, uint256 invocations, uint256 maxInvocations, bool active, address additionalPayee, uint256 additionalPayeePercentage);\r\n  function tokensOfOwner(address owner) external virtual view returns (uint256[] memory);\r\n}\r\n\r\ninterface IDelegationRegistry {\r\n    \r\n  /// @notice Delegation type\r\n  enum DelegationType {\r\n\t\t       NONE,\r\n\t\t       ALL,\r\n\t\t       CONTRACT,\r\n\t\t       TOKEN\r\n  }\r\n\r\n  /// @notice Info about a single delegation, used for onchain enumeration\r\n  struct DelegationInfo {\r\n    DelegationType type_;\r\n    address vault;\r\n    address delegate;\r\n    address contract_;\r\n    uint256 tokenId;\r\n  }\r\n  function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\r\n}\r\n\r\ncontract Relic {\r\n  uint256 public num = 0; \r\n  uint256 public cost = 1; // 1 wei to inscribe address\r\n  bool public is_sealed = false;\r\n  address public admin_address;\r\n  string public admin_msg;\r\n  bytes32 public squiggle_mint_tx;\r\n\r\n  address constant delegatecash_address = 0x00000000000076A84feF008CDAbe6409d2FE638B;\r\n  address constant snowfro_address = 0xf3860788D1597cecF938424bAABe976FaC87dC26; \r\n  address constant lacma_address = 0xf3860788D1597cecF938424bAABe976FaC87dC26; //TODO, change this to destination LACMA address\r\n  \r\n  GenArt721 public squiggle;\r\n  IDelegationRegistry public delegatecash;  \r\n  \r\n  mapping (address => bool) public has_inscribed;\r\n  mapping (uint256 => address) public inscriptions;\r\n  mapping (address => uint256) public num_squiggles; //number of squiggles owned at time of inscribing\r\n\r\n  modifier requireAdmin() {\r\n    require(msg.sender==admin_address, \"Requires admin privileges\");\r\n    _;\r\n  }\r\n\r\n  modifier notSealed() {\r\n    require(is_sealed == false, \"Contract has been sealed\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    admin_address = msg.sender; //TODO change this to snowfro.eth\r\n    address _squiggle_contract_address = 0x059EDD72Cd353dF5106D2B9cC5ab83a52287aC3a;\r\n    squiggle = GenArt721(_squiggle_contract_address);\r\n    delegatecash = IDelegationRegistry(delegatecash_address);    \r\n  }\r\n\r\n  receive() external payable  {\r\n    inscribeAddress();\r\n  }\r\n\r\n  function seal() public requireAdmin notSealed {\r\n    is_sealed = true;\r\n  }\r\n\r\n  //mint the last squiggle\r\n  function mint10000th() public requireAdmin notSealed {\r\n    require(msg.sender == snowfro_address,\"Must be initiated by Snowfro\");\r\n    uint256 invocations;    \r\n    (,,invocations,,,,) = squiggle.projectTokenInfo(0);\r\n    require(invocations == 9999, \"Invocations must be 9999\");\r\n    squiggle.purchaseTo(lacma_address,0);\r\n  }\r\n  \r\n  //set administrator, revoking previous\r\n  function setAdmin(address a) public requireAdmin notSealed {\r\n    admin_address = a;\r\n  }\r\n\r\n  //set the transaction hash of the final squiggle mint\r\n  function setMintTX(bytes32 t) public requireAdmin notSealed {\r\n    squiggle_mint_tx = t;\r\n  }\r\n  \r\n  // admin can add a message\r\n  function addMessage(string memory s) public requireAdmin notSealed {\r\n    admin_msg = s;\r\n  }\r\n\r\n  // read the message\r\n  function message() public view returns (string memory) {\r\n    return admin_msg;\r\n  }\r\n\r\n  function count_squiggles(address a ) public view returns (uint256) {\r\n    uint256 n = 0;\r\n    \r\n    // caculate deduped set of addresses that including msg.sender\r\n    // and any delegate.cash registered vault addresses\r\n\r\n    IDelegationRegistry.DelegationInfo[] memory dList;\r\n    dList = delegatecash.getDelegationsByDelegate(a);\r\n    address[] memory aList = new address[](dList.length + 1);\r\n    aList[0] = a;\r\n    uint alen=1;\r\n    \r\n    for (uint256 i=0;i<dList.length;i++) {\r\n      address b = dList[i].vault;\r\n      bool exists = false;\r\n      for (uint k=0;k<alen;k++) {\r\n\tif (b==aList[k]) {exists = true; break;}\r\n      }\r\n      if (exists) continue;\r\n      aList[alen] = b;\r\n      alen++;\r\n    }\r\n\r\n    //count number of squiggles owned by each vault address\r\n    for (uint i=0;i<alen;i++) {\r\n      uint256[] memory b = squiggle.tokensOfOwner(aList[i]);\r\n      n += b.length;\r\n    }\r\n    return n;\r\n  }\r\n\r\n  function vault_with_most_squiggles(address a ) public view returns (address mAddress, uint256 mCount) {\r\n    //iterate through all delegate.cash registered vaults for this address and pick the one\r\n    // with the most squiggles\r\n    mAddress = a;\r\n    uint256[] memory slist = squiggle.tokensOfOwner(a);\r\n    mCount= slist.length;\r\n\r\n    IDelegationRegistry.DelegationInfo[] memory dList;\r\n    dList = delegatecash.getDelegationsByDelegate(a);\r\n    \r\n    for (uint256 i=0;i<dList.length;i++) {\r\n      address b = dList[i].vault;\r\n      slist = squiggle.tokensOfOwner(b);\r\n      if (slist.length > mCount) {\r\n\tmCount = slist.length;\r\n\tmAddress = b;\r\n      }\r\n    }\r\n\r\n    return (mAddress,mCount);\r\n  }\r\n\r\n  function inscribeAddress() public payable notSealed {\r\n    require(msg.value >= cost,\"Must send minimum cost (will be refunded)\");\r\n    require(has_inscribed[msg.sender]==false, \"Already inscribed\");\r\n\r\n    has_inscribed[msg.sender] = true;\r\n\r\n    //inscribe with the delegated vault with most squiggles \r\n    address a;\r\n    uint n;\r\n    (a,n) = vault_with_most_squiggles(msg.sender);\r\n    \r\n    inscriptions[num] = a;\r\n\r\n    //optionally count the number of squiggles owned at the time inscription\r\n    num_squiggles[a] = n;\r\n    \r\n    num++;\r\n\r\n    //refund any amount sent\r\n    if (msg.value > 0) {\r\n      payable(msg.sender).transfer(msg.value);\r\n    }\r\n  }\r\n\r\n  function withdraw() public requireAdmin {\r\n    payable(msg.sender).transfer(address(this).balance);\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"}],\"name\":\"addMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin_msg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"count_squiggles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegatecash\",\"outputs\":[{\"internalType\":\"contract IDelegationRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"has_inscribed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inscribeAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inscriptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"is_sealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"message\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint10000th\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"num_squiggles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"t\",\"type\":\"bytes32\"}],\"name\":\"setMintTX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squiggle\",\"outputs\":[{\"internalType\":\"contract GenArt721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squiggle_mint_tx\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"vault_with_most_squiggles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Relic", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9ee7a5b8fc533cc8c8facd5493c53337ff8223911d37ffaf535b4b906be41e4a"}