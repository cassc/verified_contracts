{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// Company: Decrypted Labs\r\n/// @title QorraICO - Initial Coin Offering contract for Qorra Tokens\r\n/// @author Rabeeb Aqdas, Umar Farooq\r\n/// @notice This contract manages the different rounds of the ICO for the Qorra token\r\n/// @dev Inherits ERC20 standard token functionality from OpenZeppelin and ownership functionality.\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external;\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n}\r\n\r\ninterface IVesting {\r\n    function deposit(\r\n        address _userAddress,\r\n        uint256 _amount,\r\n        uint256 _amountToBeGiven,\r\n        uint256 _cliffTime,\r\n        address _referral\r\n    ) external;\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\n/// @dev Error for when an attempt is made to proceed to a round beyond the defined limits\r\n/// @param _round The round number that exceeded the limit\r\nerror ICO__RoundsLimitExceeded(uint256 _round);\r\n\r\n/// @dev Error for when the user try to send the invalid amount of tokens\r\n/// @param _tokenAmount The amount that is invalid\r\nerror ICO__InvalidAmount(uint256 _tokenAmount);\r\n\r\n/// @dev This error is thrown when the user pass the invalid currency address\r\n/// @param _currency The address of the currency to buy with\r\nerror ICO__InvalidCurrrency(address _currency);\r\n\r\n/// @dev Error for when an invalid price (e.g., zero) is set for a round\r\nerror ICO__InvalidPrice();\r\n\r\n/// @dev Error for when eth didn't sent to recipient\r\nerror ICO_EthTransferFailed();\r\n\r\n/// @dev Error for when an action is attempted in a round that has already been completed\r\nerror ICO__RoundCompleted();\r\n\r\n/// @dev Error for when there are not enough tokens remaining in a round for a purchase\r\nerror ICO__NotEnoughTokens();\r\n\r\n/// @dev Error for when an action is attempted in a round that has not yet started\r\nerror ICO__RoundNotStartedYet();\r\n\r\n/// @dev This error is thrown when a non-whitelisted address attempts to interact with the contract\r\nerror ICO__YouAreNotWhitelisted();\r\n\r\n/// @dev This error is thrown when an action is attempted after all ICO rounds are completed\r\nerror ICO__RoundsHasBeenCompleted();\r\n\r\n/// @dev This error is thrown when an action is attempted that requires the ICO to have ended\r\nerror ICO__ICOHasNotEndedYet();\r\n\r\ncontract QorraICO is Ownable {\r\n    /// @dev Reference to the Qorra token contract\r\n    IERC20 private immutable _helperQorra;\r\n\r\n    /// @dev Reference to the USDT token contract used for payments\r\n    IERC20 private immutable _helperUSDT;\r\n\r\n    /// @dev Reference to the vesting contract where purchased tokens are sent\r\n    IVesting private immutable _helperVesting;\r\n\r\n    /// @dev Tracks the current round of the ICO\r\n    uint256 private round;\r\n\r\n    /// @dev Tracks the current round number of month amount will be distributed\r\n    uint256[3] private ROUND_CLIFF_MONTHS = [18, 12, 9];\r\n\r\n    /// @dev An array containing the percentage values for immediate withdrawals in different rounds\r\n    uint256[3] private IMMIDIATE_WITHDRAWAL_PERCENT = [10, 25, 25];\r\n\r\n    /// @dev An array containing the token prices for each ICO round\r\n    uint256[3] private PRICES_PER_ROUND = [125000, 200000, 350000];\r\n\r\n    /// @dev The BASE for calculating the percentage\r\n    uint256 private constant BASE = 100;\r\n\r\n    /// @dev The remaining token limit for round one\r\n    uint256 private roundOneLimitRemaining;\r\n\r\n    /// @dev The remaining token limit for round two\r\n    uint256 private roundTwoLimitRemaining;\r\n\r\n    /// @dev The remaining token limit for round three\r\n    uint256 private roundThreeLimitRemaining;\r\n\r\n    /// @dev Flag to indicate if the ICO is paused or not\r\n    bool private paused;\r\n\r\n    /// @notice No of MONTHS in the contract for eact transaction vesting\r\n    uint256 private constant VESTING_MONTHS = 36;\r\n\r\n    /// @notice single month time period\r\n    uint256 private constant MONTH_TIME = 30 days;\r\n\r\n    /// @dev Used to fetch current price data from an external source\r\n    AggregatorV3Interface private priceFeed;\r\n\r\n    /// @dev This boolean is true if the ICO has ended, false otherwise\r\n    bool private _isICOEnded;\r\n\r\n    /// @dev Mapping to keep track of addresses that are excluded from fees\r\n    mapping(address => bool) private _isWhitelist;\r\n\r\n    /// @notice Emitted when the contract is paused\r\n    /// @param by The address that triggered the paused\r\n    event Paused(address indexed by);\r\n    /// @notice Emitted when the contract is unpaused\r\n    /// @param by The address that triggered the unpausing\r\n    event UnPaused(address indexed by);\r\n    /// @notice Emitted when a new round starts\r\n    /// @param by The address that started the round\r\n    /// @param round The current round number\r\n    event RoundStarted(address indexed by, uint256 round);\r\n    /// @notice Emitted when tokens are bought\r\n    /// @param by The address that bought the tokens\r\n    /// @param amount The amount of tokens bought\r\n    /// @param round The round in which the tokens were bought\r\n    event TokenBought(address indexed by, uint256 amount, uint256 round);\r\n\r\n    /// @dev Ensures the contract is not paused\r\n    modifier unPaused() {\r\n        require(paused == false, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Fallback function to handle unexpected calls and accept ETH.\r\n     */\r\n    fallback() external payable {}\r\n\r\n    /**\r\n     * @notice Receive function to accept ETH transfers.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /// @notice Creates a new QorraICO contract instance\r\n    /// @param _qorra Address of the Qorra token contract\r\n    /// @param _USDT Address of the USDT token contract\r\n    /// @param _vesting Address of the vesting contract\r\n    /// @param _owner Address of the admin/owner wallet\r\n    /// @param _roundOneLimitRemaining Token limit for round one\r\n    /// @param _roundTwoLimitRemaining Token limit for round two\r\n    /// @param _roundThreeLimitRemaining Token limit for round three\r\n    constructor(\r\n        IERC20 _qorra,\r\n        IERC20 _USDT,\r\n        IVesting _vesting,\r\n        address _owner,\r\n        uint256 _roundOneLimitRemaining,\r\n        uint256 _roundTwoLimitRemaining,\r\n        uint256 _roundThreeLimitRemaining\r\n    ) Ownable(_owner) {\r\n        _helperQorra = _qorra;\r\n        _helperUSDT = _USDT;\r\n        _helperVesting = _vesting;\r\n        roundOneLimitRemaining = _roundOneLimitRemaining;\r\n        roundTwoLimitRemaining = _roundTwoLimitRemaining;\r\n        roundThreeLimitRemaining = _roundThreeLimitRemaining;\r\n        priceFeed = AggregatorV3Interface(\r\n            0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46 // usdt => eth\r\n        );\r\n    }\r\n\r\n    /// @notice Allows a user to buy tokens during the ICO\r\n    /// @param _recipient The address receiving the tokens\r\n    /// @param _tokenAmount The amount of tokens to purchase\r\n    /// @param _payment The address of the payment token (if not ETH)\r\n    /// @param _referral The address of the referral (if any)\r\n    /// @dev This function checks the current round and various conditions before allowing a purchase and emits a TokenBought event upon successful purchase\r\n    /// @custom:modifier unPaused Ensures the contract is not paused\r\n    function buyToken(\r\n        address _recipient,\r\n        uint256 _tokenAmount,\r\n        address _payment,\r\n        address _referral\r\n    ) external payable unPaused {\r\n        if (_payment != address(0) && _payment != address(_helperUSDT))\r\n            revert ICO__InvalidCurrrency(_payment);\r\n        address _payer = _msgSender();\r\n        if (round == 0) revert ICO__RoundNotStartedYet();\r\n        if (_isICOEnded) revert ICO__RoundsHasBeenCompleted();\r\n        if (round == 1) {\r\n            if (!_isWhitelist[_recipient]) revert ICO__YouAreNotWhitelisted();\r\n            uint256 _roundOneLimitRemaining = roundOneLimitRemaining;\r\n\r\n            if (_roundOneLimitRemaining == 0) revert ICO__RoundCompleted();\r\n            if (_tokenAmount > _roundOneLimitRemaining)\r\n                revert ICO__NotEnoughTokens();\r\n            roundOneLimitRemaining = _roundOneLimitRemaining - _tokenAmount;\r\n            _buy(_recipient, _payer, _tokenAmount, _payment, _referral);\r\n        } else if (round == 2) {\r\n            uint256 _roundTwoLimitRemaining = roundTwoLimitRemaining;\r\n\r\n            if (_roundTwoLimitRemaining == 0) revert ICO__RoundCompleted();\r\n            if (_tokenAmount > _roundTwoLimitRemaining)\r\n                revert ICO__NotEnoughTokens();\r\n            roundTwoLimitRemaining = _roundTwoLimitRemaining - _tokenAmount;\r\n            _buy(_recipient, _payer, _tokenAmount, _payment, _referral);\r\n        } else {\r\n            uint256 _roundThreeLimitRemaining = roundThreeLimitRemaining;\r\n            if (_roundThreeLimitRemaining == 0) revert ICO__RoundCompleted();\r\n            if (_tokenAmount > _roundThreeLimitRemaining)\r\n                revert ICO__NotEnoughTokens();\r\n            roundThreeLimitRemaining = _roundThreeLimitRemaining - _tokenAmount;\r\n            _buy(_recipient, _payer, _tokenAmount, _payment, _referral);\r\n        }\r\n        emit TokenBought(_recipient, _tokenAmount, round);\r\n    }\r\n\r\n    /// @notice Internal function to handle token purchase logic\r\n    /// @param _recipient The address receiving the tokens\r\n    /// @param _payer The address paying for the tokens\r\n    /// @param _inputAmount The amount of payment\r\n    /// @param _payment The address of the payment token (if not ETH)\r\n    /// @param _referral The address of the referral (if any)\r\n    /// @dev This function calculates the token amount, handles payment transfer, and updates vesting schedules\r\n    function _buy(\r\n        address _recipient,\r\n        address _payer,\r\n        uint256 _inputAmount,\r\n        address _payment,\r\n        address _referral\r\n    ) private {\r\n        _inputAmount = _payment == address(0) ? msg.value : _inputAmount;\r\n        uint256 _tokenAmount = getQuote(_inputAmount, _payment);\r\n        if (_tokenAmount == 0) revert ICO__InvalidAmount(_inputAmount);\r\n        if (_payment == address(0)) {\r\n            (bool success, ) = owner().call{value: address(this).balance}(\"\");\r\n            if (!success) revert ICO_EthTransferFailed();\r\n        } else _helperUSDT.transferFrom(_payer, owner(), _inputAmount);\r\n        uint256 amountToBeSend = (_tokenAmount *\r\n            IMMIDIATE_WITHDRAWAL_PERCENT[round - 1]) / BASE;\r\n        uint256 remainingAmount = _tokenAmount - amountToBeSend;\r\n        _helperQorra.transfer(_recipient, amountToBeSend);\r\n        _helperQorra.transfer(address(_helperVesting), remainingAmount);\r\n        _helperVesting.deposit(\r\n            _recipient,\r\n            remainingAmount,\r\n            (remainingAmount / VESTING_MONTHS),\r\n            ROUND_CLIFF_MONTHS[round - 1] * MONTH_TIME,\r\n            _referral\r\n        );\r\n    }\r\n\r\n    /// @notice Gets the token amount for a given payment amount\r\n    /// @param _inputAmount The amount of payment\r\n    /// @param _payment The address of the payment token (if not ETH)\r\n    /// @return _tokenAmount The amount of tokens corresponding to the payment\r\n    /// @dev This function calculates the number of tokens based on the current round and token price\r\n    function getQuote(\r\n        uint256 _inputAmount,\r\n        address _payment\r\n    ) public view returns (uint256 _tokenAmount) {\r\n        uint256 _round = round;\r\n        if (_round > 0) {\r\n            uint256 _pricePerToken = PRICES_PER_ROUND[_round - 1];\r\n            if (_payment == address(0)) {\r\n                (, int256 _oneUsdtPriceInEth, , , ) = priceFeed\r\n                    .latestRoundData();\r\n                _inputAmount =\r\n                    (_inputAmount * 1e6) /\r\n                    uint256(_oneUsdtPriceInEth);\r\n            }\r\n            _tokenAmount = (_inputAmount * 1e18) / _pricePerToken;\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a given amount of USDT to its equivalent amount in ETH.\r\n    /// @dev Uses Chainlink's latest price feed data for USDT/ETH conversion.\r\n    /// @param _amountInUSDT The amount of USDT to be converted.\r\n    /// @return _ethAmount The equivalent amount of ETH for the given USDT amount.\r\n    function getETHAmount(\r\n        uint256 _amountInUSDT\r\n    ) public view returns (uint256 _ethAmount) {\r\n        (, int256 _oneUsdtPriceInEth, , , ) = priceFeed.latestRoundData();\r\n        _ethAmount = (_amountInUSDT * uint256(_oneUsdtPriceInEth)) / 1e6;\r\n    }\r\n\r\n    /// @notice Starts a new round of the ICO\r\n    /// @custom:modifier onlyOwner Restricts the function access to the contract owner.\r\n    function manageRounds() external onlyOwner {\r\n        uint256 _round = round;\r\n        if (_isICOEnded) revert ICO__RoundsHasBeenCompleted();\r\n        if (_round > 2) _isICOEnded = true;\r\n        else {\r\n            round = _round + 1;\r\n            emit RoundStarted(_msgSender(), (_round + 1));\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraws the tokens from the contract\r\n    /// @param _amountOfTokens The amount of token to withdraw\r\n    /// @custom:modifier onlyOwner Restricts the function access to the contract owner.\r\n    function withdrawTokens(uint256 _amountOfTokens) external onlyOwner {\r\n        if (!_isICOEnded) revert ICO__ICOHasNotEndedYet();\r\n        _helperQorra.transfer(_msgSender(), _amountOfTokens);\r\n    }\r\n\r\n    /// @notice Pauses the contract\r\n    /// @custom:modifier onlyOwner Restricts the function access to the contract owner.\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Contract is already paused\");\r\n        paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /// @notice Unpauses the contract\r\n    /// @custom:modifier onlyOwner Restricts the function access to the contract owner.\r\n    function unPauseContract() external onlyOwner {\r\n        require(paused, \"Contract is already unpaused\");\r\n        paused = false;\r\n        emit UnPaused(_msgSender());\r\n    }\r\n\r\n    /// @notice Updates the addresses as Whitelists or Non  Whitelists the tokens from the contract\r\n    /// @param _userAddresses array of user addresses to be changed.\r\n    /// @param _isWhitelistNow new access for all above addresses array.\r\n    /// @custom:modifier onlyOwner Restricts the function access to the contract owner.\r\n    function updateWhitelists(\r\n        address[] memory _userAddresses,\r\n        bool _isWhitelistNow\r\n    ) external onlyOwner {\r\n        for (uint256 i; i < _userAddresses.length; ++i) {\r\n            _isWhitelist[_userAddresses[i]] = _isWhitelistNow;\r\n        }\r\n    }\r\n\r\n    /// @dev Retrieves either give address is whitelist or not.\r\n    /// @return The boolean state as true or false.\r\n    function isUserWhitelist(address _user) external view returns (bool) {\r\n        return _isWhitelist[_user];\r\n    }\r\n\r\n    /// @notice Retrieves the remaining token limit for Round One\r\n    /// @return The number of tokens still available for purchase in Round One\r\n    function getRoundOneLimitRemaining() external view returns (uint256) {\r\n        return roundOneLimitRemaining;\r\n    }\r\n\r\n    /// @notice Retrieves the remaining token limit for Round Two\r\n    /// @return The number of tokens still available for purchase in Round Two\r\n    function getRoundTwoLimitRemaining() external view returns (uint256) {\r\n        return roundTwoLimitRemaining;\r\n    }\r\n\r\n    /// @notice Retrieves the remaining token limit for Round Three\r\n    /// @return The number of tokens still available for purchase in Round Three\r\n    function getRoundThreeLimitRemaining() external view returns (uint256) {\r\n        return roundThreeLimitRemaining;\r\n    }\r\n\r\n    /// @notice Retrieves the current round of the ICO\r\n    /// @return The current round number of the ICO\r\n    function getRound() external view returns (uint256) {\r\n        return round;\r\n    }\r\n\r\n    /// @notice Retrieves the current round's price\r\n    /// @return _price The price of current round\r\n    function getCurrentRoundPrice() external view returns (uint256 _price) {\r\n        if (round > 0) {\r\n            _price = PRICES_PER_ROUND[round - 1];\r\n        }\r\n    }\r\n\r\n    /// @notice Checks if the ICO contract is currently paused\r\n    /// @return True if the contract is paused, false otherwise\r\n    function isPaused() external view returns (bool) {\r\n        return paused;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_qorra\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_USDT\",\"type\":\"address\"},{\"internalType\":\"contract IVesting\",\"name\":\"_vesting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_roundOneLimitRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundTwoLimitRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundThreeLimitRemaining\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ICO_EthTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__ICOHasNotEndedYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"ICO__InvalidAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"ICO__InvalidCurrrency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__NotEnoughTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__RoundCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__RoundNotStartedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__RoundsHasBeenCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ICO__YouAreNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"}],\"name\":\"UnPaused\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payment\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInUSDT\",\"type\":\"uint256\"}],\"name\":\"getETHAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payment\",\"type\":\"address\"}],\"name\":\"getQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundOneLimitRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundThreeLimitRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundTwoLimitRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isUserWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manageRounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelistNow\",\"type\":\"bool\"}],\"name\":\"updateWhitelists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QorraICO", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006df8165bcd68378f0b3e24a1ee4c44256b045ce6000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c16c22944d4664fe9d199b760fdfd55de8298368000000000000000000000000638df86f6655efdbb7dcb00cb233457c71daaabe0000000000000000000000000000000000000000000422ca8b0a00a425000000000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000108b2a2c28029094000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4cd78ecd2aed9732760d61f9171797a6cd566a12720121cf26b76f7d2b4205e"}