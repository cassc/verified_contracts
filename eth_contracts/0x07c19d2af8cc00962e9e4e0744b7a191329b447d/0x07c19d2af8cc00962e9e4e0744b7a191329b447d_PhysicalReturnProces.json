{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/vaults/mixins/options/PhysicalReturnProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IHashnoteVault, IMarginEngine, IVaultShare} from \\\"../../../../interfaces/IHashnoteVault.sol\\\";\\nimport {ActionUtil} from \\\"../../../../libraries/ActionUtil.sol\\\";\\n\\nimport {ActionArgs} from \\\"../../../../config/types.sol\\\";\\n\\nimport {Balance, Collateral, DepositReceipt, Position, VaultState} from \\\"../../../../config/types.sol\\\";\\nimport \\\"../../../../config/constants.sol\\\";\\nimport \\\"../../../../config/errors.sol\\\";\\n\\nstruct ReturnDetails {\\n    uint256 totalSupply;\\n    uint256 managementFee;\\n    address feeRecipient;\\n    uint8 primaryCollateralId;\\n}\\n\\ncontract PhysicalReturnProcessor {\\n    using ActionUtil for ActionArgs[];\\n\\n    uint8 constant ACTION_COLLATERAL_REMOVE = 1;\\n    uint8 constant ACTION_SETTLE_PHYSICAL = 7;\\n\\n    function returnOnExercise(address[] calldata _depositors, uint256[] calldata _shares) external virtual {\\n        IHashnoteVault vault = IHashnoteVault(msg.sender);\\n\\n        // + exerciseWindow?\\n        if (vault.expiry(vault.vaultState().round) > block.timestamp) revert POV_OptionNotExpired();\\n\\n        IMarginEngine marginEngine = vault.marginEngine();\\n\\n        Balance[] memory collaterals = _verifyAndSettle(marginEngine);\\n\\n        ActionArgs[] memory totalActions = _createWithdraws(\\n            collaterals,\\n            _depositors,\\n            _shares,\\n            ReturnDetails(\\n                vault.share().totalSupply(msg.sender), vault.managementFee(), vault.feeRecipient(), vault.getCollaterals()[0].id\\n            )\\n        );\\n\\n        marginEngine.execute(msg.sender, totalActions);\\n    }\\n\\n    function _createWithdraws(\\n        Balance[] memory _collaterals,\\n        address[] calldata _depositors,\\n        uint256[] calldata _shares,\\n        ReturnDetails memory _details\\n    ) internal pure returns (ActionArgs[] memory totalActions) {\\n        uint256 depositorsCount = _depositors.length;\\n        uint256 i;\\n\\n        // starting in first position, because we do not return primary collateral\\n        if (_collaterals[0].collateralId == _details.primaryCollateralId) i = 1;\\n\\n        for (i; i < _collaterals.length;) {\\n            uint256 totalFees;\\n\\n            // if fees taken then include a tx for it\\n            ActionArgs[] memory actions = new ActionArgs[](_details.managementFee > 0 ? depositorsCount + 1 : depositorsCount);\\n\\n            for (uint256 x; x < depositorsCount;) {\\n                uint256 feeAmount;\\n                (actions[x], feeAmount) = _createAction(\\n                    _collaterals[i].collateralId,\\n                    _collaterals[i].amount,\\n                    _depositors[x],\\n                    _shares[x],\\n                    _details.totalSupply,\\n                    _details.managementFee\\n                );\\n\\n                totalFees += feeAmount;\\n\\n                unchecked {\\n                    ++x;\\n                }\\n            }\\n\\n            if (totalFees > 0) {\\n                actions[depositorsCount] = ActionArgs({\\n                    action: ACTION_COLLATERAL_REMOVE,\\n                    data: abi.encode(uint80(totalFees), _details.feeRecipient, _collaterals[i].collateralId)\\n                });\\n            }\\n\\n            if (totalActions.length == 0) totalActions = actions;\\n            else totalActions = totalActions.concat(actions);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _createAction(\\n        uint8 _collateralId,\\n        uint256 _collateralAmount,\\n        address _depositor,\\n        uint256 _shares,\\n        uint256 _totalSupply,\\n        uint256 _managementFee\\n    ) internal pure returns (ActionArgs memory action, uint256 feeAmount) {\\n        uint256 withdrawAmount = _collateralAmount * _shares / _totalSupply;\\n\\n        feeAmount = withdrawAmount * _managementFee / (100 * PERCENT_MULTIPLIER);\\n\\n        action = ActionArgs({\\n            action: ACTION_COLLATERAL_REMOVE,\\n            data: abi.encode(uint80(withdrawAmount - feeAmount), _depositor, _collateralId)\\n        });\\n    }\\n\\n    function _verifyAndSettle(IMarginEngine _marginEngine) internal returns (Balance[] memory collaterals) {\\n        (Position[] memory shorts,,) = _marginEngine.marginAccounts(msg.sender);\\n\\n        bool isExercised;\\n\\n        for (uint256 i; i < shorts.length;) {\\n            (,, uint80 totalPaid) = _marginEngine.tokenTracker(shorts[i].tokenId);\\n\\n            if (totalPaid > 0) {\\n                isExercised = true;\\n                break;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (!isExercised) revert POV_NotExercised();\\n\\n        // settle options if shorts are not empty\\n        if (shorts.length > 0) {\\n            ActionArgs[] memory actions = new ActionArgs[](1);\\n\\n            // _isCashSettled is false since the option is physically settled\\n            actions[0] = ActionArgs({action: ACTION_SETTLE_PHYSICAL, data: \\\"\\\"});\\n\\n            _marginEngine.execute(msg.sender, actions);\\n        }\\n\\n        (,, collaterals) = _marginEngine.marginAccounts(msg.sender);\\n\\n        if (collaterals.length == 0) revert OV_NoCollateral();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IHashnoteVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IMarginEngine} from \\\"./IMarginEngine.sol\\\";\\nimport {IVaultShare} from \\\"./IVaultShare.sol\\\";\\n\\nimport \\\"../config/types.sol\\\";\\n\\ninterface IHashnoteVault {\\n    function share() external view returns (IVaultShare);\\n\\n    function manager() external view returns (address);\\n\\n    function whitelist() external view returns (address);\\n\\n    function managementFee() external view returns (uint256);\\n\\n    function feeRecipient() external view returns (address);\\n\\n    function marginEngine() external view returns (IMarginEngine);\\n\\n    function vaultState() external view returns (VaultState memory);\\n\\n    function _depositReceipts(address subAccount) external view returns (DepositReceipt memory);\\n\\n    function deposit(uint256 amount) external;\\n\\n    function quickWithdraw(uint256 amount) external;\\n\\n    function requestWithdrawFor(address subAccount, uint256 numShares) external;\\n\\n    function collaterals(uint256 index) external view returns (Collateral memory);\\n\\n    function expiry(uint256 round) external view returns (uint256);\\n\\n    function pricePerShare(uint256 round) external view returns (uint256);\\n\\n    function getCollaterals() external view returns (Collateral[] memory);\\n\\n    function getStartingBalances(uint256 round) external view returns (uint256[] memory);\\n\\n    function getCollateralPrices(uint256 round) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"src/libraries/ActionUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/constants.sol\\\";\\nimport \\\"../config/enums.sol\\\";\\nimport \\\"../config/types.sol\\\";\\n\\n/**\\n * @title libraries to encode action arguments\\n */\\nlibrary ActionUtil {\\n    function concat(ActionArgs[] memory x, ActionArgs[] memory v) internal pure returns (ActionArgs[] memory y) {\\n        y = new ActionArgs[](x.length + v.length);\\n        uint256 z;\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[z] = x[i];\\n            unchecked {\\n                ++z;\\n                ++i;\\n            }\\n        }\\n        for (i = 0; i < v.length;) {\\n            y[z] = v[i];\\n            unchecked {\\n                ++z;\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function append(ActionArgs[] memory x, ActionArgs memory v) internal pure returns (ActionArgs[] memory y) {\\n        y = new ActionArgs[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    function append(BatchExecute[] memory x, BatchExecute memory v) internal pure returns (BatchExecute[] memory y) {\\n        y = new BatchExecute[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    // add a function prefixed with test here so forge coverage will ignore this file\\n    function testChillOnHelper() public {}\\n}\\n\"\r\n    },\r\n    \"src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Initialization parameters for the vault.\\n * @param _owner is the owner of the vault with critical permissions\\n * @param _manager is the address that is responsible for advancing the vault\\n * @param _feeRecipient is the address to receive vault performance and management fees\\n * @param _oracle is used to calculate NAV\\n * @param _whitelist is used to check address access permissions\\n * @param _managementFee is the management fee pct.\\n * @param _performanceFee is the performance fee pct.\\n * @param _pauser is where withdrawn collateral exists waiting for client to withdraw\\n * @param _collateralRatios is the array of round starting balances to set the initial collateral ratios\\n * @param _collaterals is the assets used in the vault\\n * @param _roundConfig sets the duration and expiration of options\\n * @param _vaultParams set vaultParam struct\\n */\\nstruct InitParams {\\n    address _owner;\\n    address _manager;\\n    address _feeRecipient;\\n    address _oracle;\\n    address _whitelist;\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    address _pauser;\\n    uint256[] _collateralRatios;\\n    Collateral[] _collaterals;\\n    RoundConfig _roundConfig;\\n}\\n\\nstruct Collateral {\\n    // Grappa asset Id\\n    uint8 id;\\n    // ERC20 token address for the required collateral\\n    address addr;\\n    // the amount of decimals or token\\n    uint8 decimals;\\n}\\n\\nstruct VaultState {\\n    // 32 byte slot 1\\n    // Round represents the number of periods elapsed. There's a hard limit of 4,294,967,295 rounds\\n    uint32 round;\\n    // Amount that is currently locked for selling options\\n    uint96 lockedAmount;\\n    // Amount that was locked for selling options in the previous round\\n    // used for calculating performance fee deduction\\n    uint96 lastLockedAmount;\\n    // 32 byte slot 2\\n    // Stores the total tally of how much of `asset` there is\\n    // to be used to mint vault tokens\\n    uint96 totalPending;\\n    // store the number of shares queued for withdraw this round\\n    // zero'ed out at the start of each round, pauser withdraws all queued shares.\\n    uint128 queuedWithdrawShares;\\n}\\n\\nstruct DepositReceipt {\\n    // Round represents the number of periods elapsed. There's a hard limit of 4,294,967,295 rounds\\n    uint32 round;\\n    // Deposit amount, max 79,228,162,514 or 79 Billion ETH deposit\\n    uint96 amount;\\n    // Unredeemed shares balance\\n    uint128 unredeemedShares;\\n}\\n\\nstruct RoundConfig {\\n    // the duration of the option\\n    uint32 duration;\\n    // day of the week the option should expire. 0-8, 0 is sunday, 7 is sunday, 8 is wild\\n    uint8 dayOfWeek;\\n    // hour of the day the option should expire. 0 is midnight\\n    uint8 hourOfDay;\\n}\\n\\n// Used for fee calculations at the end of a round\\nstruct VaultDetails {\\n    // Collaterals of the vault\\n    Collateral[] collaterals;\\n    // Collateral balances at the start of the round\\n    uint256[] startingBalances;\\n    // current balances\\n    uint256[] currentBalances;\\n    // Total pending primary asset\\n    uint256 totalPending;\\n}\\n\\n// Used when rolling funds into a new round\\nstruct NAVDetails {\\n    // Collaterals of the vault\\n    Collateral[] collaterals;\\n    // Collateral balances at the start of the round\\n    uint256[] startingBalances;\\n    // Current collateral balances\\n    uint256[] currentBalances;\\n    // Used to calculate NAV\\n    address oracleAddr;\\n    // Expiry of the round\\n    uint256 expiry;\\n    // Pending deposits\\n    uint256 totalPending;\\n}\\n\\n/**\\n * @dev Position struct\\n * @param tokenId option token id\\n * @param amount number option tokens\\n */\\nstruct Position {\\n    uint256 tokenId;\\n    uint64 amount;\\n}\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev ActionArgs and BatchExecute are a local definition of the structs defined in:\\n *       - https://github.com/grappafinance/core-cash/blob/master/src/config/types.sol\\n *       - https://github.com/grappafinance/core-physical/blob/master/src/config/types.sol\\n *     they are provided to avoid the need of having separate logic for interacting with the cash settled an\\n *     physically settled margin engines and consolidate them in a single interface\\n */\\n\\n/**\\n * @notice The action type for the execute function\\n * @dev    unitary representation of the ActionArgs struct from the core physical and cash engines\\n */\\nstruct ActionArgs {\\n    // action type represented as uint8 (see enum ActionType)\\n    uint8 action;\\n    // data payload for the action\\n    bytes data;\\n}\\n\\n/**\\n * @notice The batch action type for the execute function\\n * @dev    unitary representation of the BatchExecute struct from the core physical and cash engines\\n */\\nstruct BatchExecute {\\n    // address of the account to execute the batch\\n    address subAccount;\\n    // array of actions to execute\\n    ActionArgs[] actions;\\n}\\n\"\r\n    },\r\n    \"src/config/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n///@dev unit scaled used to convert amounts.\\nuint256 constant UNIT = 10 ** 6;\\n\\n// Placeholder uint value to prevent cold writes\\nuint256 constant PLACEHOLDER_UINT = 1;\\n\\n// Fees are 18-decimal places. For example: 20 * 10**18 = 20%\\nuint256 constant PERCENT_MULTIPLIER = 10 ** 18;\\n\\nuint32 constant SECONDS_PER_DAY = 86400;\\nuint32 constant DAYS_PER_YEAR = 365;\\n\"\r\n    },\r\n    \"src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// common\\nerror Unauthorized();\\nerror Overflow();\\nerror BadAddress();\\nerror NotImplemented();\\n\\n// BaseVault\\nerror BV_ActiveRound();\\nerror BV_BadCollateral();\\nerror BV_BadExpiry();\\nerror BV_BadLevRatio();\\nerror BV_ExpiryMismatch();\\nerror BV_MarginEngineMismatch();\\nerror BV_RoundClosed();\\nerror BV_BadFee();\\nerror BV_BadRoundConfig();\\nerror BV_BadPPS();\\nerror BV_BadSB();\\nerror BV_BadCP();\\nerror BV_BadRatios();\\n\\n// Registrar\\nerror REG_BadAmount();\\nerror REG_BadRound();\\nerror REG_BadNumShares();\\nerror REG_BadDepositAmount();\\nerror REG_ExceedsAvailable();\\n\\n// OptionsVault\\nerror OV_ActiveRound();\\nerror OV_BadRound();\\nerror OV_BadCollateral();\\nerror OV_BadPremium();\\nerror OV_RoundClosed();\\nerror OV_NoCollateral();\\nerror OV_OptionNotExpired();\\nerror OV_NoCollateralPending();\\n\\n// PhysicalOptionVault\\nerror POV_CannotRequestWithdraw();\\nerror POV_NotExercised();\\nerror POV_OptionNotExpired();\\nerror POV_VaultExercised();\\nerror POV_BadExerciseWindow();\\n\\n// Fee Utils\\nerror FL_NPSLow();\\n\\n// Vault Utils\\nerror VL_DifferentLengths();\\nerror VL_ExceedsSurplus();\\nerror VL_BadOwnerAddress();\\nerror VL_BadManagerAddress();\\nerror VL_BadFeeAddress();\\nerror VL_BadOracleAddress();\\nerror VL_BadPauserAddress();\\nerror VL_BadFee();\\nerror VL_BadCollateral();\\nerror VL_BadCollateralAddress();\\nerror VL_BadDuration();\\n\\n// StructureLib\\nerror SL_BadExpiryDate();\\n\\n// Vault Pauser\\nerror VP_VaultNotPermissioned();\\nerror VP_PositionPaused();\\nerror VP_Overflow();\\nerror VP_CustomerNotPermissioned();\\nerror VP_RoundOpen();\\n\\n// Vault Share\\nerror VS_SupplyExceeded();\\n\\n// Whitelist Manager\\nerror WL_BadRole();\\nerror WL_Paused();\\n\"\r\n    },\r\n    \"src/interfaces/IMarginEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IGrappa} from \\\"grappa/interfaces/IGrappa.sol\\\";\\nimport {IPomace} from \\\"pomace/interfaces/IPomace.sol\\\";\\n\\nimport {BatchExecute, ActionArgs} from \\\"../config/types.sol\\\";\\n\\nimport \\\"../config/types.sol\\\";\\n\\n/**\\n * @notice Interface for the base margin engine contract\\n */\\ninterface IMarginEngine {\\n    function optionToken() external view returns (address);\\n\\n    function marginAccounts(address)\\n        external\\n        view\\n        returns (Position[] memory shorts, Position[] memory longs, Balance[] memory collaterals);\\n\\n    function previewMinCollateral(Position[] memory shorts, Position[] memory longs) external view returns (Balance[] memory);\\n\\n    function allowedExecutionLeft(uint160 mask, address account) external view returns (uint256);\\n\\n    function batchExecute(BatchExecute[] calldata batchActions) external;\\n\\n    function execute(address account, ActionArgs[] calldata actions) external;\\n\\n    function revokeSelfAccess(address granter) external;\\n\\n    function setAccountAccess(address account, uint256 allowedExecutions) external;\\n\\n    function grappa() external view returns (IGrappa grappa);\\n\\n    function pomace() external view returns (IPomace pomace);\\n\\n    function tokenTracker(uint256 tokenId) external view returns (uint64 issued, uint80 totalDebt, uint80 totalPaid);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVaultShare.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IERC1155} from \\\"openzeppelin/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IVaultShare is IERC1155 {\\n    /**\\n     * @dev mint option token to an address. Can only be called by corresponding vault\\n     * @param _recipient    where to mint token to\\n     * @param _amount       amount to mint\\n     *\\n     */\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    /**\\n     * @dev burn option token from an address. Can only be called by corresponding vault\\n     * @param _from         account to burn from\\n     * @param _amount       amount to burn\\n     *\\n     */\\n    function burn(address _from, uint256 _amount) external;\\n\\n    /**\\n     * @dev burn option token from addresses. Can only be called by corresponding vault\\n     * @param _from        accounts to burn from\\n     * @param _amounts      amounts to burn\\n     *\\n     */\\n    function batchBurn(address[] memory _from, uint256[] memory _amounts) external;\\n\\n    /**\\n     * @dev returns total supply of a vault\\n     * @param _vault      address of the vault\\n     *\\n     */\\n    function totalSupply(address _vault) external view returns (uint256 amount);\\n\\n    /**\\n     * @dev returns vault share balance for a given holder\\n     * @param _owner      address of token holder\\n     * @param _vault      address of the vault\\n     *\\n     */\\n    function getBalanceOf(address _owner, address _vault) external view returns (uint256 amount);\\n\\n    /**\\n     * @dev exposing transfer method to vault\\n     *\\n     */\\n    function transferVaultOnly(address _from, address _to, uint256 _amount, bytes calldata _data) external;\\n\\n    /**\\n     * @dev exposing transfer method to registrar\\n     *\\n     */\\n    function transferRegistrarOnly(address _from, address _to, address _vault, uint256 _amount, bytes calldata _data) external;\\n\\n    /**\\n     * @dev helper method to pass in vault address instead of tokenId\\n     *\\n     */\\n    function transferFromWithVault(address _from, address _to, address _vault, uint256 _amount, bytes calldata _data) external;\\n}\\n\"\r\n    },\r\n    \"src/config/enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nenum AddressType {\\n    Manager,\\n    FeeRecipient,\\n    Pauser,\\n    Whitelist\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-cash/src/interfaces/IGrappa.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\n\\ninterface IGrappa {\\n    function getDetailFromProductId(uint40 _productId)\\n        external\\n        view\\n        returns (\\n            address oracle,\\n            address engine,\\n            address underlying,\\n            uint8 underlyingDecimals,\\n            address strike,\\n            uint8 strikeDecimals,\\n            address collateral,\\n            uint8 collateralDecimals\\n        );\\n\\n    function checkEngineAccess(uint256 _tokenId, address _engine) external view;\\n\\n    function checkEngineAccessAndTokenId(uint256 _tokenId, address _engine) external view;\\n\\n    function engineIds(address _engine) external view returns (uint8 id);\\n\\n    function assetIds(address _asset) external view returns (uint8 id);\\n\\n    function assets(uint8 _id) external view returns (address addr, uint8 decimals);\\n\\n    function engines(uint8 _id) external view returns (address engine);\\n\\n    function oracles(uint8 _id) external view returns (address oracle);\\n\\n    function getPayout(uint256 tokenId, uint64 amount)\\n        external\\n        view\\n        returns (address engine, address collateral, uint256 payout);\\n\\n    function getProductId(address oracle, address engine, address underlying, address strike, address collateral)\\n        external\\n        view\\n        returns (uint40 id);\\n\\n    function getTokenId(TokenType tokenType, uint40 productId, uint256 expiry, uint256 longStrike, uint256 shortStrike)\\n        external\\n        view\\n        returns (uint256 id);\\n\\n    /**\\n     * @notice burn option token and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenId  tokenId of option token to burn\\n     * @param _amount   amount to settle\\n     * @return payout amount paid out\\n     */\\n    function settleOption(address _account, uint256 _tokenId, uint256 _amount) external returns (uint256 payout);\\n\\n    /**\\n     * @notice burn array of option tokens and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenIds array of tokenIds to burn\\n     * @param _amounts   array of amounts to burn\\n     */\\n    function batchSettleOptions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts)\\n        external\\n        returns (Balance[] memory payouts);\\n\\n    function batchGetPayouts(uint256[] memory _tokenIds, uint256[] memory _amounts) external returns (Balance[] memory payouts);\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-physical/src/interfaces/IPomace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\nimport {IOracle} from \\\"./IOracle.sol\\\";\\n\\ninterface IPomace {\\n    function oracle() external view returns (IOracle oracle);\\n\\n    function checkEngineAccess(uint256 _tokenId, address _engine) external view;\\n\\n    function checkEngineAccessAndTokenId(uint256 _tokenId, address _engine) external view;\\n\\n    function engineIds(address _engine) external view returns (uint8 id);\\n\\n    function assetIds(address _asset) external view returns (uint8 id);\\n\\n    function assets(uint8 _id) external view returns (address addr, uint8 decimals);\\n\\n    function engines(uint8 _id) external view returns (address engine);\\n\\n    function isCollateralizable(uint8 _asset0, uint8 _asset1) external view returns (bool);\\n\\n    function isCollateralizable(address _asset0, address _asset1) external view returns (bool);\\n\\n    function getDebtAndPayout(uint256 tokenId, uint64 amount)\\n        external\\n        view\\n        returns (address engine, uint8 debtId, uint256 debt, uint8 payoutId, uint256 payout);\\n\\n    function batchGetDebtAndPayouts(uint256[] calldata tokenId, uint256[] calldata amount)\\n        external\\n        view\\n        returns (Balance[] memory debts, Balance[] memory payouts);\\n\\n    function getProductId(address engine, address underlying, address strike, address collateral)\\n        external\\n        view\\n        returns (uint32 id);\\n\\n    function getTokenId(TokenType tokenType, uint32 productId, uint256 expiry, uint256 strike, uint256 exerciseWindow)\\n        external\\n        view\\n        returns (uint256 id);\\n\\n    function getDetailFromProductId(uint32 _productId)\\n        external\\n        view\\n        returns (\\n            address engine,\\n            address underlying,\\n            uint8 underlyingDecimals,\\n            address strike,\\n            uint8 strikeDecimals,\\n            address collateral,\\n            uint8 collateralDecimals\\n        );\\n\\n    /**\\n     * @notice burn option token and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenId  tokenId of option token to burn\\n     * @param _amount   amount to settle\\n     * @return debt amount collected\\n     * @return payout amount paid out\\n     */\\n    function settleOption(address _account, uint256 _tokenId, uint256 _amount)\\n        external\\n        returns (Balance memory debt, Balance memory payout);\\n\\n    /**\\n     * @notice burn array of option tokens and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenIds array of tokenIds to burn\\n     * @param _amounts   array of amounts to burn\\n     */\\n    function batchSettleOptions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-cash/src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./enums.sol\\\";\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId grappa asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev struct containing assets detail for an product\\n * @param underlying    underlying address\\n * @param strike        strike address\\n * @param collateral    collateral address\\n * @param collateralDecimals collateral asset decimals\\n */\\nstruct ProductDetails {\\n    address oracle;\\n    uint8 oracleId;\\n    address engine;\\n    uint8 engineId;\\n    address underlying;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    address strike;\\n    uint8 strikeId;\\n    uint8 strikeDecimals;\\n    address collateral;\\n    uint8 collateralId;\\n    uint8 collateralDecimals;\\n}\\n\\n// todo: update doc\\nstruct ActionArgs {\\n    ActionType action;\\n    bytes data;\\n}\\n\\nstruct BatchExecute {\\n    address subAccount;\\n    ActionArgs[] actions;\\n}\\n\\n/**\\n * @dev asset detail stored per asset id\\n * @param addr address of the asset\\n * @param decimals token decimals\\n */\\nstruct AssetDetail {\\n    address addr;\\n    uint8 decimals;\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-physical/src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./enums.sol\\\";\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId pomace asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev struct containing assets detail for an product\\n * @param underlying    underlying address\\n * @param strike        strike address\\n * @param collateral    collateral address\\n * @param collateralDecimals collateral asset decimals\\n */\\nstruct ProductDetails {\\n    address engine;\\n    uint8 engineId;\\n    address underlying;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    address strike;\\n    uint8 strikeId;\\n    uint8 strikeDecimals;\\n    address collateral;\\n    uint8 collateralId;\\n    uint8 collateralDecimals;\\n}\\n\\n// todo: update doc\\nstruct ActionArgs {\\n    ActionType action;\\n    bytes data;\\n}\\n\\nstruct BatchExecute {\\n    address subAccount;\\n    ActionArgs[] actions;\\n}\\n\\n/**\\n * @dev asset detail stored per asset id\\n * @param addr address of the asset\\n * @param decimals token decimals\\n */\\nstruct AssetDetail {\\n    address addr;\\n    uint8 decimals;\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-physical/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice  get spot price of _base, denominated in _quote.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @return price with 6 decimals\\n     */\\n    function getSpotPrice(address _base, address _quote) external view returns (uint256);\\n\\n    /**\\n     * @dev get expiry price of underlying, denominated in strike asset.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @param _expiry expiry timestamp\\n     *\\n     * @return price with 6 decimals\\n     */\\n    function getPriceAtExpiry(address _base, address _quote, uint256 _expiry)\\n        external\\n        view\\n        returns (uint256 price, bool isFinalized);\\n\\n    /**\\n     * @dev return the maximum dispute period for the oracle\\n     * @dev this will only be checked during oracle registration, as a soft constraint on integrating oracles.\\n     */\\n    function maxDisputePeriod() external view returns (uint256 disputePeriod);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-cash/src/config/enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum TokenType {\\n    PUT,\\n    PUT_SPREAD,\\n    CALL,\\n    CALL_SPREAD\\n}\\n\\n/**\\n * @dev common action types on margin engines\\n */\\nenum ActionType {\\n    AddCollateral,\\n    RemoveCollateral,\\n    MintShort,\\n    BurnShort,\\n    MergeOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    SplitOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    AddLong,\\n    RemoveLong,\\n    SettleAccount,\\n    // actions that influence more than one subAccounts:\\n    // These actions are defined in \\\"OptionTransferable\\\"\\n    MintShortIntoAccount, // increase short (debt) position in one subAccount, increase long token directly to another subAccount\\n    TransferCollateral, // transfer collateral directly to another subAccount\\n    TransferLong, // transfer long directly to another subAccount\\n    TransferShort // transfer short directly to another subAccount\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-physical/src/config/enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum TokenType {\\n    PUT,\\n    CALL\\n}\\n\\n/**\\n * @dev common action types on margin engines\\n */\\nenum ActionType {\\n    AddCollateral,\\n    RemoveCollateral,\\n    MintShort,\\n    BurnShort,\\n    AddLong,\\n    RemoveLong,\\n    ExerciseToken,\\n    SettleAccount,\\n    // actions that influence more than one subAccounts:\\n    // These actions are defined in \\\"OptionTransferable\\\"\\n    MintShortIntoAccount, // increase short (debt) position in one subAccount, increase long token directly to another subAccount\\n    TransferCollateral, // transfer collateral directly to another subAccount\\n    TransferLong, // transfer long directly to another subAccount\\n    TransferShort // transfer short directly to another subAccount\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"array-lib/=lib/array-lib/src/\",\r\n      \"cm-cash-engine/=lib/cross-margin-engine/src/settled-cash/\",\r\n      \"cm-physical-engine/=lib/cross-margin-engine/src/settled-physical/\",\r\n      \"core-cash/=lib/cross-margin-engine/lib/core-cash/\",\r\n      \"core-physical/=lib/cross-margin-engine/lib/core-physical/\",\r\n      \"cross-margin-engine/=lib/cross-margin-engine/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"grappa-test/=lib/cross-margin-engine/lib/core-cash/test/\",\r\n      \"grappa/=lib/cross-margin-engine/lib/core-cash/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pomace-test/=lib/cross-margin-engine/lib/core-physical/test/\",\r\n      \"pomace/=lib/cross-margin-engine/lib/core-physical/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"OV_NoCollateral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POV_NotExercised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POV_OptionNotExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_depositors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"name\":\"returnOnExercise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PhysicalReturnProcessor", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}