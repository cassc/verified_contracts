{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/VRGDAs/src/LinearVRGDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {unsafeWadDiv} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {VRGDA} from \\\"./VRGDA.sol\\\";\\n\\n/// @title Linear Variable Rate Gradual Dutch Auction\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice VRGDA with a linear issuance curve.\\nabstract contract LinearVRGDA is VRGDA {\\n    /*//////////////////////////////////////////////////////////////\\n                           PRICING PARAMETERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev The total number of tokens to target selling every full unit of time.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable perTimeUnit;\\n\\n    /// @notice Sets pricing parameters for the VRGDA.\\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    /// @param _perTimeUnit The number of tokens to target selling in 1 full unit of time, scaled by 1e18.\\n    constructor(\\n        int256 _targetPrice,\\n        int256 _priceDecayPercent,\\n        int256 _perTimeUnit\\n    ) VRGDA(_targetPrice, _priceDecayPercent) {\\n        perTimeUnit = _perTimeUnit;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              PRICING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\\n        return unsafeWadDiv(sold, perTimeUnit);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/VRGDAs/src/VRGDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\n/// @title Variable Rate Gradual Dutch Auction\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice Sell tokens roughly according to an issuance schedule.\\nabstract contract VRGDA {\\n    /*//////////////////////////////////////////////////////////////\\n                            VRGDA PARAMETERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Target price for a token, to be scaled according to sales pace.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 public immutable targetPrice;\\n\\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable decayConstant;\\n\\n    /// @notice Sets target price and per time unit price decay for the VRGDA.\\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    constructor(int256 _targetPrice, int256 _priceDecayPercent) {\\n        targetPrice = _targetPrice;\\n\\n        decayConstant = wadLn(1e18 - _priceDecayPercent);\\n\\n        // The decay constant must be negative for VRGDAs to work.\\n        require(decayConstant < 0, \\\"NON_NEGATIVE_DECAY_CONSTANT\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              PRICING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Calculate the price of a token according to the VRGDA formula.\\n    /// @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18.\\n    /// @param sold The total number of tokens that have been sold so far.\\n    /// @return The price of a token according to VRGDA, scaled by 1e18.\\n    function getVRGDAPrice(int256 timeSinceStart, uint256 sold) public view virtual returns (uint256) {\\n        unchecked {\\n            // prettier-ignore\\n            return uint256(wadMul(targetPrice, wadExp(unsafeWadMul(decayConstant,\\n                // Theoretically calling toWadUnsafe with sold can silently overflow but under\\n                // any reasonable circumstance it will never be large enough. We use sold + 1 as\\n                // the VRGDA formula's n param represents the nth token and sold is the n-1th token.\\n                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))\\n            ))));\\n        }\\n    }\\n\\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\\n    function getTargetSaleTime(int256 sold) public view virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, sub(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0230)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Encodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n                    \\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Efficient library for creating string representations of integers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\\n            let newFreeMemoryPointer := add(mload(0x40), 160)\\n\\n            // Update the free memory pointer to avoid overriding our string.\\n            mstore(0x40, newFreeMemoryPointer)\\n\\n            // Assign str to the end of the zone of newly allocated memory.\\n            str := sub(newFreeMemoryPointer, 32)\\n\\n            // Clean the last word of memory it may not be overwritten.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                // Move the pointer 1 byte to the left.\\n                str := sub(str, 1)\\n\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n\\n                // Keep dividing temp until zero.\\n                temp := div(temp, 10)\\n\\n                 // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute and cache the final total length of the string.\\n            let length := sub(end, str)\\n\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 32)\\n\\n            // Store the string's length at the start of memory allocated for our string.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SignedWadMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\\n    assembly {\\n        // Multiply x by 1e18.\\n        r := mul(x, 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative second amounts, it assumes x is positive.\\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\\n    assembly {\\n        // Multiply x by 1e18 and then divide it by 86400.\\n        r := div(mul(x, 1000000000000000000), 86400)\\n    }\\n}\\n\\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative day amounts, it assumes x is positive.\\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\\n    assembly {\\n        // Multiply x by 86400 and then divide it by 1e18.\\n        r := div(mul(x, 86400), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\\n    assembly {\\n        // Multiply x by y and divide by 1e18.\\n        r := sdiv(mul(x, y), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero and will\\n/// not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    assembly {\\n        // Multiply x by 1e18 and divide it by y.\\n        r := sdiv(mul(x, 1000000000000000000), y)\\n    }\\n}\\n\\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\\n    assembly {\\n        // Store x * y in r for now.\\n        r := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\\n            revert(0, 0)\\n        }\\n\\n        // Scale the result down by 1e18.\\n        r := sdiv(r, 1000000000000000000)\\n    }\\n}\\n\\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    assembly {\\n        // Store x * 1e18 in r for now.\\n        r := mul(x, 1000000000000000000)\\n\\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\\n            revert(0, 0)\\n        }\\n\\n        // Divide r by y.\\n        r := sdiv(r, y)\\n    }\\n}\\n\\nfunction wadExp(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        // When the result is < 0.5 we return zero. This happens when\\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n        if (x <= -42139678854452767551) return 0;\\n\\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n        if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n        // for more intermediate precision and a binary basis. This base conversion\\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n        x = (x << 78) / 5**18;\\n\\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n        x = x - k * 54916777467707473351141471128;\\n\\n        // k is in the range [-61, 195].\\n\\n        // Evaluate using a (6, 7)-term rational approximation.\\n        // p is made monic, we'll multiply by a scale factor later.\\n        int256 y = x + 1346386616545796478920950773328;\\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n        int256 p = y + x - 94201549194550492254356042504812;\\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n        p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        int256 q = x - 2855989394907223263936484059900;\\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\\n            // No scaling is necessary because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r should be in the range (0.09, 0.25) * 2**96.\\n\\n        // We now need to multiply r by:\\n        // * the scale factor s = ~6.031367120.\\n        // * the 2**k factor from the range reduction.\\n        // * the 1e18 / 2**96 factor for base conversion.\\n        // We do this all at once, with an intermediate result in 2**213\\n        // basis, so the final right shift is always by a positive amount.\\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n    }\\n}\\n\\nfunction wadLn(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n        // We do this by multiplying by 2**96 / 10**18. But since\\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n        // and add ln(2**96 / 10**18) at the end.\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n\\n        // Reduce range of x to (1, 2) * 2**96\\n        // ln(2^k * x) = k * ln(2) + ln(x)\\n        int256 k = r - 96;\\n        x <<= uint256(159 - k);\\n        x = int256(uint256(x) >> 159);\\n\\n        // Evaluate using a (8, 8)-term rational approximation.\\n        // p is made monic, we will multiply by a scale factor later.\\n        int256 p = x + 3273285459638523848632254066296;\\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n        p = p * x - (795164235651350426258249787498 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        // q is monic by convention.\\n        int256 q = x + 5573035233440673466300451813936;\\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r is in the range (0, 0.125) * 2**96\\n\\n        // Finalization, we need to:\\n        // * multiply by the scale factor s = 5.549\u2026\\n        // * add ln(2**96 / 10**18)\\n        // * add k * ln(2)\\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n        r *= 1677202110996718588342820967067443963516166;\\n        // add ln(2) * k * 5e18 * 2**192\\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n        // base conversion: mul 2**18 / 2**192\\n        r >>= 174;\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero.\\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\\n    assembly {\\n        // Divide x by y.\\n        r := sdiv(x, y)\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {LibString} from \\\"solmate/utils/LibString.sol\\\";\\nimport {Base64} from \\\"solady/utils/Base64.sol\\\";\\n\\nlibrary Metadata {\\n    using LibString for uint256;\\n\\n    function toImageURI(string memory cid) internal pure returns (string memory) {\\n        return string.concat(\\\"ipfs://\\\", cid);\\n    }\\n\\n    function tokenJSON(uint256 tokenId, string memory imageURI) internal pure returns (string memory) {\\n        return string.concat('{\\\"image\\\":\\\"', imageURI, '\\\",\\\"name\\\":\\\"Purplecheck #', tokenId.toString(), '\\\"}');\\n    }\\n\\n    function contractJSON() internal pure returns (string memory) {\\n        return\\n        '{\\\"name\\\":\\\"Purplecheck\\\",\\\"image\\\":\\\"ipfs://bafkreibhw7wybdzmpg5tfjr6pjynalpeb3zs7c3va26prjyc6gl2bvo7y4\\\",\\\"description\\\":\\\"Your JPEGs deserve to feel special.\\\"}';\\n    }\\n\\n    function contractURI() internal pure returns (string memory) {\\n        return toDataURI(contractJSON());\\n    }\\n\\n    function tokenURI(uint256 tokenId, string memory imageURI) internal pure returns (string memory) {\\n        return toDataURI(tokenJSON(tokenId, imageURI));\\n    }\\n\\n    function toDataURI(string memory json) internal pure returns (string memory) {\\n        return string.concat(\\\"data:application/json;base64,\\\", Base64.encode(abi.encodePacked(json)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Purplecheck.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.13;\\n\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {LinearVRGDA} from \\\"VRGDAs/LinearVRGDA.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {toDaysWadUnsafe} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {Metadata} from \\\"./Metadata.sol\\\";\\n\\n/// @title Purplecheck - Your JPEGs deserve to feel special.\\n/// @notice Mint an ERC721 token associated with an IPFS content ID.\\n/// Mint price is calculated by a linear VRGDA targeting 6.9 purplechecks\\n/// per day at a price of 0.00420 ETH.\\n/// @author horsefacts <horsefacts@terminally.online>\\ncontract Purplecheck is ERC721, LinearVRGDA, Owned {\\n    /// @notice Total number of Purplecheck tokens.\\n    uint256 public totalSupply;\\n\\n    /// @notice Mint start time. Used in VRGDA price calculations.\\n    uint256 public immutable startTime = block.timestamp;\\n\\n    /// @notice tokenId => IPFS CIDv1\\n    mapping(uint256 => string) public cid;\\n\\n    constructor(address owner)\\n        ERC721(\\\"Purplecheck\\\", unicode\\\"\ud83d\udfea\ufe0f\u2705\\\")\\n        // Target rate 6.9 per day @ 0.00420 ETH\\n        LinearVRGDA(0.0042e18, 0.31e18, 6.9e18)\\n        Owned(owner)\\n    {}\\n\\n    /// @notice Get the contract URI for this contract, encoded as a data URI.\\n    /// @return Contract metadata URI.\\n    function contractURI() external pure returns (string memory) {\\n        return Metadata.contractURI();\\n    }\\n\\n    /// @notice Get the metadata URI for the given token ID, encoded as a data URI.\\n    /// @param tokenId uint256 token ID.\\n    /// @return Metadata URI.\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        return Metadata.tokenURI(tokenId, imageURI(tokenId));\\n    }\\n\\n    /// @notice Get the IPFS image URI for the given token ID.\\n    /// @param tokenId uint256 token ID.\\n    /// @return URI of given token ID.\\n    function imageURI(uint256 tokenId) public view returns (string memory) {\\n        return Metadata.toImageURI(cid[tokenId]);\\n    }\\n\\n    /// @notice Current mint price of a Purplecheck token, based on block.timestamp.\\n    /// @return uint256 mint price in wei.\\n    function price() public view returns (uint256) {\\n        return getVRGDAPrice(toDaysWadUnsafe(block.timestamp - startTime), totalSupply);\\n    }\\n\\n    /// @notice Mint a Purplecheck token.\\n    /// @param _cid IPFS CIDv1 of the associated image.\\n    /// @return tokenId uint256 token ID.\\n    function mint(string calldata _cid) external payable returns (uint256 tokenId) {\\n        unchecked {\\n            // Get current VRGDA price\\n            uint256 _price = price();\\n\\n            // Revert if caller has underpaid\\n            require(msg.value >= _price, \\\"UNDERPAID\\\");\\n\\n            // Increment total supply and store image CID\\n            cid[tokenId = ++totalSupply] = _cid;\\n\\n            // Mint token to caller\\n            _mint(msg.sender, tokenId);\\n\\n            // Refund excess payment to caller\\n            if (msg.value != _price) SafeTransferLib.safeTransferETH(msg.sender, msg.value - _price);\\n        }\\n    }\\n\\n    /// @notice Burn a Purplecheck token. Must be owner or approved.\\n    /// @param tokenId uint256 token ID.\\n    function burn(uint256 tokenId) external {\\n        address owner = _ownerOf[tokenId];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[tokenId],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n        _burn(tokenId);\\n    }\\n\\n    /// @notice Revert on attempted transfer.\\n    function transferFrom(address, address, uint256) public pure override {\\n        revert(\\\"TRANSFERS_DISABLED\\\");\\n    }\\n\\n    /// @notice Withdraw full balance to given recipient address.\\n    function withdrawBalance(address to) external onlyOwner {\\n        SafeTransferLib.safeTransferETH(to, address(this).balance);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"VRGDAs/=lib/VRGDAs/src/\",\r\n      \"ds-test/=lib/VRGDAs/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cid\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"sold\",\"type\":\"int256\"}],\"name\":\"getTargetSaleTime\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"timeSinceStart\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"}],\"name\":\"getVRGDAPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"imageURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_cid\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Purplecheck", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "00000000000000000000000079d31bfca5fda7a4f15b36763d2e44c99d811a6c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}