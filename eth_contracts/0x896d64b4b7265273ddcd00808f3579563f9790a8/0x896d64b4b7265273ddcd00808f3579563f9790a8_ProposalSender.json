{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ProposalSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"oz/access/Ownable.sol\\\";\\nimport \\\"oz/utils/ReentrancyGuard.sol\\\";\\nimport \\\"lz/lzApp/interfaces/ILayerZeroEndpoint.sol\\\";\\n\\nimport \\\"./utils/Errors.sol\\\";\\n\\n/// @title ProposalSender\\n/// @author LayerZero Labs\\n/// @notice Sends a proposal's data to remote chains for execution after the proposal passes on the main chain\\n/// @dev In Angle setting where there is one Timelock contract per chain to which this proposal sender sends payloads\\n/// the owner of this contract must be the `Governor` contract itself\\n/// @dev Full fork from:\\n/// https://github.com/LayerZero-Labs/omnichain-governance-executor/blob/main/contracts/OmnichainProposalSender.sol\\n//solhint-disable\\n/// @dev Acknowledge issue: `setTrustedRemoteAddress`, `setSendVersion` and `setConfig` are not protected by\\n/// a timelock. But any other proposal will need to be executed through a timelock because the other chains\\n/// are still dependant on their timelock contract.\\ncontract ProposalSender is Ownable, ReentrancyGuard {\\n    uint64 public lastStoredPayloadNonce;\\n\\n    /// @notice Execution hashes of failed messages\\n    /// @dev [nonce] -> [executionHash]\\n    mapping(uint64 => bytes32) public storedExecutionHashes;\\n\\n    /// @notice LayerZero endpoint for sending messages to remote chains\\n    ILayerZeroEndpoint public immutable lzEndpoint;\\n\\n    /// @notice Specifies the allowed path for sending messages\\n    /// (remote chainId => remote app address + local app address)\\n    mapping(uint16 => bytes) public trustedRemoteLookup;\\n\\n    /// @notice Emitted when a remote message receiver is set for the remote chain\\n    event SetTrustedRemoteAddress(uint16 remoteChainId, bytes remoteAddress);\\n\\n    /// @notice Emitted when a proposal execution request sent to the remote chain\\n    event ExecuteRemoteProposal(uint16 indexed remoteChainId, bytes payload);\\n\\n    /// @notice Emitted when a previously failed message successfully sent to the remote chain\\n    event ClearPayload(uint64 indexed nonce, bytes32 executionHash);\\n\\n    /// @notice Emitted when an execution hash of a failed message saved\\n    event StorePayload(\\n        uint64 indexed nonce,\\n        uint16 indexed remoteChainId,\\n        bytes payload,\\n        bytes adapterParams,\\n        uint value,\\n        bytes reason\\n    );\\n\\n    constructor(ILayerZeroEndpoint _lzEndpoint) Ownable(msg.sender) {\\n        if (address(_lzEndpoint) == address(0)) revert OmnichainProposalSenderInvalidEndpoint();\\n        lzEndpoint = _lzEndpoint;\\n    }\\n\\n    /// @notice Estimates LayerZero fees for cross-chain message delivery to the remote chain\\n    /// @dev The estimated fees are the minimum required, it's recommended to increase the fees\\n    /// amount when sending a message. The unused amount will be refunded\\n    /// @param remoteChainId The LayerZero id of a remote chain\\n    /// @param payload The payload to be sent to the remote chain. It's computed as follows:\\n    /// payload = abi.encode(targets, values, signatures, calldatas)\\n    /// @param adapterParams The params used to specify the custom amount of gas required for the execution\\n    /// on the destination\\n    /// @return nativeFee The amount of fee in the native gas token (e.g. ETH)\\n    /// @return zroFee The amount of fee in ZRO token\\n    function estimateFees(\\n        uint16 remoteChainId,\\n        bytes calldata payload,\\n        bytes calldata adapterParams\\n    ) external view returns (uint nativeFee, uint zroFee) {\\n        return lzEndpoint.estimateFees(remoteChainId, address(this), payload, false, adapterParams);\\n    }\\n\\n    /// @notice Sends a message to execute a remote proposal\\n    /// @dev Stores the hash of the execution parameters if sending fails (e.g., due to insufficient fees)\\n    /// @param remoteChainId The LayerZero id of the remote chain\\n    /// @param payload The payload to be sent to the remote chain. It's computed as follows:\\n    /// payload = abi.encode(targets, values, signatures, calldatas)\\n    /// @param adapterParams The params used to specify the custom amount of gas required for the execution\\n    /// on the destination\\n    function execute(\\n        uint16 remoteChainId,\\n        bytes calldata payload,\\n        bytes calldata adapterParams\\n    ) external payable onlyOwner {\\n        bytes memory trustedRemote = trustedRemoteLookup[remoteChainId];\\n        if (trustedRemote.length == 0) revert OmnichainProposalSenderDestinationChainNotTrustedSource();\\n\\n        try\\n            lzEndpoint.send{ value: msg.value }(\\n                remoteChainId,\\n                trustedRemote,\\n                payload,\\n                payable(tx.origin),\\n                address(0),\\n                adapterParams\\n            )\\n        {\\n            emit ExecuteRemoteProposal(remoteChainId, payload);\\n        } catch (bytes memory reason) {\\n            uint64 _lastStoredPayloadNonce = ++lastStoredPayloadNonce;\\n            bytes memory execution = abi.encode(remoteChainId, payload, adapterParams, msg.value);\\n            storedExecutionHashes[_lastStoredPayloadNonce] = keccak256(execution);\\n            emit StorePayload(_lastStoredPayloadNonce, remoteChainId, payload, adapterParams, msg.value, reason);\\n        }\\n    }\\n\\n    /// @notice Resends a previously failed message\\n    /// @dev Allows to provide more fees if needed. The extra fees will be refunded to the caller\\n    /// @param nonce The nonce to identify a failed message\\n    /// @param remoteChainId The LayerZero id of the remote chain\\n    /// @param payload The payload to be sent to the remote chain. It's computed as follows:\\n    /// payload = abi.encode(targets, values, signatures, calldatas)\\n    /// @param adapterParams The params used to specify the custom amount of gas required for the execution\\n    /// on the destination\\n    /// @param originalValue The msg.value passed when execute() function was called\\n    function retryExecute(\\n        uint64 nonce,\\n        uint16 remoteChainId,\\n        bytes calldata payload,\\n        bytes calldata adapterParams,\\n        uint originalValue\\n    ) external payable nonReentrant {\\n        bytes32 hash = storedExecutionHashes[nonce];\\n        if (hash == bytes32(0)) revert OmnichainProposalSenderNoStoredPayload();\\n\\n        bytes memory execution = abi.encode(remoteChainId, payload, adapterParams, originalValue);\\n        if (keccak256(execution) != hash) revert OmnichainProposalSenderInvalidExecParams();\\n\\n        delete storedExecutionHashes[nonce];\\n\\n        lzEndpoint.send{ value: originalValue + msg.value }(\\n            remoteChainId,\\n            trustedRemoteLookup[remoteChainId],\\n            payload,\\n            payable(msg.sender),\\n            address(0),\\n            adapterParams\\n        );\\n        emit ClearPayload(nonce, hash);\\n    }\\n\\n    /// @notice Sets the remote message receiver address\\n    /// @param remoteChainId The LayerZero id of a remote chain\\n    /// @param remoteAddress The address of the contract on the remote chain to receive messages sent by this contract\\n    function setTrustedRemoteAddress(uint16 remoteChainId, bytes calldata remoteAddress) external onlyOwner {\\n        trustedRemoteLookup[remoteChainId] = abi.encodePacked(remoteAddress, address(this));\\n        emit SetTrustedRemoteAddress(remoteChainId, remoteAddress);\\n    }\\n\\n    /// @notice Sets the configuration of the LayerZero messaging library of the specified version\\n    /// @param version Messaging library version\\n    /// @param chainId The LayerZero chainId for the pending config change\\n    /// @param configType The type of configuration. Every messaging library has its own convention\\n    /// @param config The configuration in bytes. It can encode arbitrary content\\n    function setConfig(uint16 version, uint16 chainId, uint configType, bytes calldata config) external onlyOwner {\\n        lzEndpoint.setConfig(version, chainId, configType, config);\\n    }\\n\\n    /// @notice Sets the configuration of the LayerZero messaging library of the specified version\\n    /// @param version New messaging library version\\n    function setSendVersion(uint16 version) external onlyOwner {\\n        lzEndpoint.setSendVersion(version);\\n    }\\n\\n    /// @notice Gets the configuration of the LayerZero messaging library of the specified version\\n    /// @param version Messaging library version\\n    /// @param chainId The LayerZero chainId\\n    /// @param configType Type of configuration. Every messaging library has its own convention.\\n    function getConfig(uint16 version, uint16 chainId, uint configType) external view returns (bytes memory) {\\n        return lzEndpoint.getConfig(version, chainId, address(this), configType);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint _configType\\n    ) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nerror GovernorCountingFractionalVoteWouldExceedWeight();\\nerror GovernorCountingFractionalInvalidSupportValueNotVoteType();\\nerror GovernorCountingFractionalInvalidVoteData();\\nerror GovernorCountingFractionalVoteExceedWeight();\\nerror GovernorCountingFractionalNoWeight();\\nerror GovernorCountingFractionalAllWeightCast();\\nerror InvalidTimepoint();\\nerror NotExecutor();\\nerror OmnichainGovernanceExecutorTxExecReverted();\\nerror OmnichainProposalSenderDestinationChainNotTrustedSource();\\nerror OmnichainProposalSenderInvalidEndpoint();\\nerror OmnichainProposalSenderInvalidExecParams();\\nerror OmnichainProposalSenderNoStoredPayload();\\nerror ShortCircuitNumeratorGreaterThanQuorumDenominator();\\nerror ZeroAddress();\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/lzApp/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        uint _configType,\\n        bytes calldata _config\\n    ) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"oz/=lib/openzeppelin-contracts/contracts/\",\r\n      \"oz-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"lz/=lib/solidity-examples/contracts/\",\r\n      \"stringutils/=lib/solidity-stringutils/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-examples/=lib/solidity-examples/contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"_lzEndpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OmnichainProposalSenderDestinationChainNotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OmnichainProposalSenderInvalidEndpoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OmnichainProposalSenderInvalidExecParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OmnichainProposalSenderNoStoredPayload\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionHash\",\"type\":\"bytes32\"}],\"name\":\"ClearPayload\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"ExecuteRemoteProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"remoteAddress\",\"type\":\"bytes\"}],\"name\":\"SetTrustedRemoteAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"StorePayload\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastStoredPayloadNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"originalValue\",\"type\":\"uint256\"}],\"name\":\"retryExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"remoteAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemoteAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"storedExecutionHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"trustedRemoteLookup\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ProposalSender", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd675", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}