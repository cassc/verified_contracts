{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Luando/PresaleERC.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n* @dev Contract module that helps prevent reentrant calls to a function.\\r\\n*\\r\\n* Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n* available, which can be applied to functions to make sure there are no nested\\r\\n* (reentrant) calls to them.\\r\\n*\\r\\n* Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n* `nonReentrant` may not call one another. This can be worked around by making\\r\\n* those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n* points to them.\\r\\n*\\r\\n* TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n* to protect against it, check out our blog post\\r\\n* https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n*/\\r\\nabstract contract ReentrancyGuard {\\r\\n// Booleans are more expensive than uint256 or any type that takes up a full\\r\\n// word because each write operation emits an extra SLOAD to first read the\\r\\n// slot's contents, replace the bits taken up by the boolean, and then write\\r\\n// back. This is the compiler's defense against contract upgrades and\\r\\n// pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n// The values being non-zero value makes deployment a bit more expensive,\\r\\n// but in exchange the refund on every call to nonReentrant will be lower in\\r\\n// amount. Since refunds are capped to a percentage of the total\\r\\n// transaction's gas, it is best to keep them low in cases like this one, to\\r\\n// increase the likelihood of the full refund coming into effect.\\r\\nuint256 private constant _NOT_ENTERED = 1;\\r\\nuint256 private constant _ENTERED = 2;\\r\\n\\r\\nuint256 private _status;\\r\\n\\r\\nconstructor() {\\r\\n_status = _NOT_ENTERED;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n* Calling a `nonReentrant` function from another `nonReentrant`\\r\\n* function is not supported. It is possible to prevent this from happening\\r\\n* by making the `nonReentrant` function external, and making it call a\\r\\n* `private` function that does the actual work.\\r\\n*/\\r\\nmodifier nonReentrant() {\\r\\n_nonReentrantBefore();\\r\\n_;\\r\\n_nonReentrantAfter();\\r\\n}\\r\\n\\r\\nfunction _nonReentrantBefore() private {\\r\\n// On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\nrequire(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n// Any calls to nonReentrant after this point will fail\\r\\n_status = _ENTERED;\\r\\n}\\r\\n\\r\\nfunction _nonReentrantAfter() private {\\r\\n// By storing the original value once again, a refund is triggered (see\\r\\n// https://eips.ethereum.org/EIPS/eip-2200)\\r\\n_status = _NOT_ENTERED;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n* `nonReentrant` function in the call stack.\\r\\n*/\\r\\nfunction _reentrancyGuardEntered() internal view returns (bool) {\\r\\nreturn _status == _ENTERED;\\r\\n}\\r\\n}\\r\\n\\r\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n* @dev Provides information about the current execution context, including the\\r\\n* sender of the transaction and its data. While these are generally available\\r\\n* via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n* manner, since when dealing with meta-transactions the account sending and\\r\\n* paying for execution may not be the actual sender (as far as an application\\r\\n* is concerned).\\r\\n*\\r\\n* This contract is only required for intermediate, library-like contracts.\\r\\n*/\\r\\nabstract contract Context {\\r\\nfunction _msgSender() internal view virtual returns (address) {\\r\\nreturn msg.sender;\\r\\n}\\r\\n\\r\\nfunction _msgData() internal view virtual returns (bytes calldata) {\\r\\nreturn msg.data;\\r\\n}\\r\\n}\\r\\n\\r\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n* @dev Contract module which provides a basic access control mechanism, where\\r\\n* there is an account (an owner) that can be granted exclusive access to\\r\\n* specific functions.\\r\\n*\\r\\n* By default, the owner account will be the one that deploys the contract. This\\r\\n* can later be changed with {transferOwnership}.\\r\\n*\\r\\n* This module is used through inheritance. It will make available the modifier\\r\\n* `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n* the owner.\\r\\n*/\\r\\nabstract contract Ownable is Context {\\r\\naddress private _owner;\\r\\nevent OwnershipTransferred(\\r\\naddress indexed previousOwner,\\r\\naddress indexed newOwner\\r\\n);\\r\\n\\r\\n/**\\r\\n* @dev Initializes the contract setting the deployer as the initial owner.\\r\\n*/\\r\\nconstructor() {\\r\\n_transferOwnership(_msgSender());\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Throws if called by any account other than the owner.\\r\\n*/\\r\\nmodifier onlyOwner() {\\r\\n_checkOwner();\\r\\n_;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Returns the address of the current owner.\\r\\n*/\\r\\nfunction owner() public view virtual returns (address) {\\r\\nreturn _owner;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Throws if the sender is not the owner.\\r\\n*/\\r\\nfunction _checkOwner() internal view virtual {\\r\\nrequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Leaves the contract without owner. It will not be possible to call\\r\\n* `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n*\\r\\n* NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n* thereby removing any functionality that is only available to the owner.\\r\\n*/\\r\\nfunction renounceOwnership() public virtual onlyOwner {\\r\\n_transferOwnership(address(0));\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n* Can only be called by the current owner.\\r\\n*/\\r\\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\\r\\nrequire(\\r\\nnewOwner != address(0),\\r\\n\\\"Ownable: new owner is the zero address\\\"\\r\\n);\\r\\n_transferOwnership(newOwner);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n* Internal function without access restriction.\\r\\n*/\\r\\nfunction _transferOwnership(address newOwner) internal virtual {\\r\\naddress oldOwner = _owner;\\r\\n_owner = newOwner;\\r\\nemit OwnershipTransferred(oldOwner, newOwner);\\r\\n}\\r\\n}\\r\\n\\r\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n* @dev Contract module which allows children to implement an emergency stop\\r\\n* mechanism that can be triggered by an authorized account.\\r\\n*\\r\\n* This module is used through inheritance. It will make available the\\r\\n* modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n* the functions of your contract. Note that they will not be pausable by\\r\\n* simply including this module, only once the modifiers are put in place.\\r\\n*/\\r\\nabstract contract Pausable is Context {\\r\\n/**\\r\\n* @dev Emitted when the pause is triggered by `account`.\\r\\n*/\\r\\nevent Paused(address account);\\r\\n\\r\\n/**\\r\\n* @dev Emitted when the pause is lifted by `account`.\\r\\n*/\\r\\nevent Unpaused(address account);\\r\\n\\r\\nbool private _paused;\\r\\n\\r\\n/**\\r\\n* @dev Initializes the contract in unpaused state.\\r\\n*/\\r\\nconstructor() {\\r\\n_paused = false;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Modifier to make a function callable only when the contract is not paused.\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - The contract must not be paused.\\r\\n*/\\r\\nmodifier whenNotPaused() {\\r\\n_requireNotPaused();\\r\\n_;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Modifier to make a function callable only when the contract is paused.\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - The contract must be paused.\\r\\n*/\\r\\nmodifier whenPaused() {\\r\\n_requirePaused();\\r\\n_;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Returns true if the contract is paused, and false otherwise.\\r\\n*/\\r\\nfunction paused() public view virtual returns (bool) {\\r\\nreturn _paused;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Throws if the contract is paused.\\r\\n*/\\r\\nfunction _requireNotPaused() internal view virtual {\\r\\nrequire(!paused(), \\\"Pausable: paused\\\");\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Throws if the contract is not paused.\\r\\n*/\\r\\nfunction _requirePaused() internal view virtual {\\r\\nrequire(paused(), \\\"Pausable: not paused\\\");\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Triggers stopped state.\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - The contract must not be paused.\\r\\n*/\\r\\nfunction _pause() internal virtual whenNotPaused {\\r\\n_paused = true;\\r\\nemit Paused(_msgSender());\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Returns to normal state.\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - The contract must be paused.\\r\\n*/\\r\\nfunction _unpause() internal virtual whenPaused {\\r\\n_paused = false;\\r\\nemit Unpaused(_msgSender());\\r\\n}\\r\\n}\\r\\n\\r\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/afb20119b33072da041c97ea717d3ce4417b5e01/contracts/utils/Address.sol\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n* @dev Collection of functions related to the address type\\r\\n*/\\r\\nlibrary Address {\\r\\n/**\\r\\n* @dev Returns true if `account` is a contract.\\r\\n*\\r\\n* [IMPORTANT]\\r\\n* ====\\r\\n* It is unsafe to assume that an address for which this function returns\\r\\n* false is an externally-owned account (EOA) and not a contract.\\r\\n*\\r\\n* Among others, `isContract` will return false for the following\\r\\n* types of addresses:\\r\\n*\\r\\n* - an externally-owned account\\r\\n* - a contract in construction\\r\\n* - an address where a contract will be created\\r\\n* - an address where a contract lived, but was destroyed\\r\\n* ====\\r\\n*\\r\\n* [IMPORTANT]\\r\\n* ====\\r\\n* You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n*\\r\\n* Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n* like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n* constructor.\\r\\n* ====\\r\\n*/\\r\\nfunction isContract(address account) internal view returns (bool) {\\r\\n// This method relies on extcodesize/address.code.length, which returns 0\\r\\n// for contracts in construction, since the code is only stored at the end\\r\\n// of the constructor execution.\\r\\n\\r\\nreturn account.code.length > 0;\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n* `recipient`, forwarding all available gas and reverting on errors.\\r\\n*\\r\\n* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n* of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n* imposed by `transfer`, making them unable to receive funds via\\r\\n* `transfer`. {sendValue} removes this limitation.\\r\\n*\\r\\n* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n*\\r\\n* IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n* taken to not create reentrancy vulnerabilities. Consider using\\r\\n* {ReentrancyGuard} or the\\r\\n* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n*/\\r\\nfunction sendValue(address payable recipient, uint256 amount) internal {\\r\\nrequire(\\r\\naddress(this).balance >= amount,\\r\\n\\\"Address: insufficient balance\\\"\\r\\n);\\r\\n\\r\\n(bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\nrequire(\\r\\nsuccess,\\r\\n\\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Performs a Solidity function call using a low level `call`. A\\r\\n* plain `call` is an unsafe replacement for a function call: use this\\r\\n* function instead.\\r\\n*\\r\\n* If `target` reverts with a revert reason, it is bubbled up by this\\r\\n* function (like regular Solidity function calls).\\r\\n*\\r\\n* Returns the raw returned data. To convert to the expected return value,\\r\\n* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - `target` must be a contract.\\r\\n* - calling `target` with `data` must not revert.\\r\\n*\\r\\n* _Available since v3.1._\\r\\n*/\\r\\nfunction functionCall(address target, bytes memory data)\\r\\ninternal\\r\\nreturns (bytes memory)\\r\\n{\\r\\nreturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n* `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n*\\r\\n* _Available since v3.1._\\r\\n*/\\r\\nfunction functionCall(\\r\\naddress target,\\r\\nbytes memory data,\\r\\nstring memory errorMessage\\r\\n) internal returns (bytes memory) {\\r\\nreturn functionCallWithValue(target, data, 0, errorMessage);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n* but also transferring `value` wei to `target`.\\r\\n*\\r\\n* Requirements:\\r\\n*\\r\\n* - the calling contract must have an ETH balance of at least `value`.\\r\\n* - the called Solidity function must be `payable`.\\r\\n*\\r\\n* _Available since v3.1._\\r\\n*/\\r\\nfunction functionCallWithValue(\\r\\naddress target,\\r\\nbytes memory data,\\r\\nuint256 value\\r\\n) internal returns (bytes memory) {\\r\\nreturn\\r\\nfunctionCallWithValue(\\r\\ntarget,\\r\\ndata,\\r\\nvalue,\\r\\n\\\"Address: low-level call with value failed\\\"\\r\\n);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n* with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n*\\r\\n* _Available since v3.1._\\r\\n*/\\r\\nfunction functionCallWithValue(\\r\\naddress target,\\r\\nbytes memory data,\\r\\nuint256 value,\\r\\nstring memory errorMessage\\r\\n) internal returns (bytes memory) {\\r\\nrequire(\\r\\naddress(this).balance >= value,\\r\\n\\\"Address: insufficient balance for call\\\"\\r\\n);\\r\\nrequire(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n(bool success, bytes memory returndata) = target.call{value: value}(\\r\\ndata\\r\\n);\\r\\nreturn verifyCallResult(success, returndata, errorMessage);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n* but performing a static call.\\r\\n*\\r\\n* _Available since v3.3._\\r\\n*/\\r\\nfunction functionStaticCall(address target, bytes memory data)\\r\\ninternal\\r\\nview\\r\\nreturns (bytes memory)\\r\\n{\\r\\nreturn\\r\\nfunctionStaticCall(\\r\\ntarget,\\r\\ndata,\\r\\n\\\"Address: low-level static call failed\\\"\\r\\n);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n* but performing a static call.\\r\\n*\\r\\n* _Available since v3.3._\\r\\n*/\\r\\nfunction functionStaticCall(\\r\\naddress target,\\r\\nbytes memory data,\\r\\nstring memory errorMessage\\r\\n) internal view returns (bytes memory) {\\r\\nrequire(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n(bool success, bytes memory returndata) = target.staticcall(data);\\r\\nreturn verifyCallResult(success, returndata, errorMessage);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n* but performing a delegate call.\\r\\n*\\r\\n* _Available since v3.4._\\r\\n*/\\r\\nfunction functionDelegateCall(address target, bytes memory data)\\r\\ninternal\\r\\nreturns (bytes memory)\\r\\n{\\r\\nreturn\\r\\nfunctionDelegateCall(\\r\\ntarget,\\r\\ndata,\\r\\n\\\"Address: low-level delegate call failed\\\"\\r\\n);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n* but performing a delegate call.\\r\\n*\\r\\n* _Available since v3.4._\\r\\n*/\\r\\nfunction functionDelegateCall(\\r\\naddress target,\\r\\nbytes memory data,\\r\\nstring memory errorMessage\\r\\n) internal returns (bytes memory) {\\r\\nrequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n(bool success, bytes memory returndata) = target.delegatecall(data);\\r\\nreturn verifyCallResult(success, returndata, errorMessage);\\r\\n}\\r\\n\\r\\n/**\\r\\n* @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n* revert reason using the provided one.\\r\\n*\\r\\n* _Available since v4.3._\\r\\n*/\\r\\nfunction verifyCallResult(\\r\\nbool success,\\r\\nbytes memory returndata,\\r\\nstring memory errorMessage\\r\\n) internal pure returns (bytes memory) {\\r\\nif (success) {\\r\\nreturn returndata;\\r\\n} else {\\r\\n// Look for revert reason and bubble it up if present\\r\\nif (returndata.length > 0) {\\r\\n// The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\nassembly {\\r\\nlet returndata_size := mload(returndata)\\r\\nrevert(add(32, returndata), returndata_size)\\r\\n}\\r\\n} else {\\r\\nrevert(errorMessage);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n\\r\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n*/\\r\\ninterface IERC20 {\\r\\n/**\\r\\n* @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n* another (`to`).\\r\\n*\\r\\n* Note that `value` may be zero.\\r\\n*/\\r\\nevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n/**\\r\\n* @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n* a call to {approve}. `value` is the new allowance.\\r\\n*/\\r\\nevent Approval(\\r\\naddress indexed owner,\\r\\naddress indexed spender,\\r\\nuint256 value\\r\\n);\\r\\n\\r\\n/**\\r\\n* @dev Returns the amount of tokens in existence.\\r\\n*/\\r\\nfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n/**\\r\\n* @dev Returns the amount of tokens owned by `account`.\\r\\n*/\\r\\nfunction balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n/**\\r\\n* @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n*\\r\\n* Returns a boolean value indicating whether the operation succeeded.\\r\\n*\\r\\n* Emits a {Transfer} event.\\r\\n*/\\r\\nfunction transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n/**\\r\\n* @dev Returns the remaining number of tokens that `spender` will be\\r\\n* allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n* zero by default.\\r\\n*\\r\\n* This value changes when {approve} or {transferFrom} are called.\\r\\n*/\\r\\nfunction allowance(address owner, address spender)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256);\\r\\n\\r\\n/**\\r\\n* @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n*\\r\\n* Returns a boolean value indicating whether the operation succeeded.\\r\\n*\\r\\n* IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n* that someone may use both the old and the new allowance by unfortunate\\r\\n* transaction ordering. One possible solution to mitigate this race\\r\\n* condition is to first reduce the spender's allowance to 0 and set the\\r\\n* desired value afterwards:\\r\\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n*\\r\\n* Emits an {Approval} event.\\r\\n*/\\r\\nfunction approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n/**\\r\\n* @dev Moves `amount` tokens from `from` to `to` using the\\r\\n* allowance mechanism. `amount` is then deducted from the caller's\\r\\n* allowance.\\r\\n*\\r\\n* Returns a boolean value indicating whether the operation succeeded.\\r\\n*\\r\\n* Emits a {Transfer} event.\\r\\n*/\\r\\nfunction transferFrom(\\r\\naddress from,\\r\\naddress to,\\r\\nuint256 amount\\r\\n) external returns (bool);\\r\\n}\\r\\n\\r\\n// File: presale.sol\\r\\n\\r\\n//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\nfunction factory() external pure returns (address);\\r\\n\\r\\nfunction WETH() external pure returns (address);\\r\\n\\r\\nfunction addLiquidity(\\r\\naddress tokenA,\\r\\naddress tokenB,\\r\\nuint256 amountADesired,\\r\\nuint256 amountBDesired,\\r\\nuint256 amountAMin,\\r\\nuint256 amountBMin,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n)\\r\\nexternal\\r\\nreturns (\\r\\nuint256 amountA,\\r\\nuint256 amountB,\\r\\nuint256 liquidity\\r\\n);\\r\\n\\r\\nfunction addLiquidityETH(\\r\\naddress token,\\r\\nuint256 amountTokenDesired,\\r\\nuint256 amountTokenMin,\\r\\nuint256 amountETHMin,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n)\\r\\nexternal\\r\\npayable\\r\\nreturns (\\r\\nuint256 amountToken,\\r\\nuint256 amountETH,\\r\\nuint256 liquidity\\r\\n);\\r\\n\\r\\nfunction removeLiquidity(\\r\\naddress tokenA,\\r\\naddress tokenB,\\r\\nuint256 liquidity,\\r\\nuint256 amountAMin,\\r\\nuint256 amountBMin,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\nfunction removeLiquidityETH(\\r\\naddress token,\\r\\nuint256 liquidity,\\r\\nuint256 amountTokenMin,\\r\\nuint256 amountETHMin,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\nfunction removeLiquidityWithPermit(\\r\\naddress tokenA,\\r\\naddress tokenB,\\r\\nuint256 liquidity,\\r\\nuint256 amountAMin,\\r\\nuint256 amountBMin,\\r\\naddress to,\\r\\nuint256 deadline,\\r\\nbool approveMax,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\nfunction removeLiquidityETHWithPermit(\\r\\naddress token,\\r\\nuint256 liquidity,\\r\\nuint256 amountTokenMin,\\r\\nuint256 amountETHMin,\\r\\naddress to,\\r\\nuint256 deadline,\\r\\nbool approveMax,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\nfunction swapExactTokensForTokens(\\r\\nuint256 amountIn,\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256[] memory amounts);\\r\\n\\r\\nfunction swapTokensForExactTokens(\\r\\nuint256 amountOut,\\r\\nuint256 amountInMax,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256[] memory amounts);\\r\\n\\r\\nfunction swapExactETHForTokens(\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external payable returns (uint256[] memory amounts);\\r\\n\\r\\nfunction swapTokensForExactETH(\\r\\nuint256 amountOut,\\r\\nuint256 amountInMax,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256[] memory amounts);\\r\\n\\r\\nfunction swapExactTokensForETH(\\r\\nuint256 amountIn,\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256[] memory amounts);\\r\\n\\r\\nfunction swapETHForExactTokens(\\r\\nuint256 amountOut,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external payable returns (uint256[] memory amounts);\\r\\n\\r\\nfunction quote(\\r\\nuint256 amountA,\\r\\nuint256 reserveA,\\r\\nuint256 reserveB\\r\\n) external pure returns (uint256 amountB);\\r\\n\\r\\nfunction getAmountOut(\\r\\nuint256 amountIn,\\r\\nuint256 reserveIn,\\r\\nuint256 reserveOut\\r\\n) external pure returns (uint256 amountOut);\\r\\n\\r\\nfunction getAmountIn(\\r\\nuint256 amountOut,\\r\\nuint256 reserveIn,\\r\\nuint256 reserveOut\\r\\n) external pure returns (uint256 amountIn);\\r\\n\\r\\nfunction getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256[] memory amounts);\\r\\n\\r\\nfunction getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\nevent PairCreated(\\r\\naddress indexed token0,\\r\\naddress indexed token1,\\r\\naddress pair,\\r\\nuint256\\r\\n);\\r\\n\\r\\nfunction feeTo() external view returns (address);\\r\\n\\r\\nfunction feeToSetter() external view returns (address);\\r\\n\\r\\nfunction getPair(address tokenA, address tokenB)\\r\\nexternal\\r\\nview\\r\\nreturns (address pair);\\r\\n\\r\\nfunction allPairs(uint256) external view returns (address pair);\\r\\n\\r\\nfunction allPairsLength() external view returns (uint256);\\r\\n\\r\\nfunction createPair(address tokenA, address tokenB)\\r\\nexternal\\r\\nreturns (address pair);\\r\\n\\r\\nfunction setFeeTo(address) external;\\r\\n\\r\\nfunction setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\nevent Approval(\\r\\naddress indexed owner,\\r\\naddress indexed spender,\\r\\nuint256 value\\r\\n);\\r\\nevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\nfunction name() external pure returns (string memory);\\r\\n\\r\\nfunction symbol() external pure returns (string memory);\\r\\n\\r\\nfunction decimals() external pure returns (uint8);\\r\\n\\r\\nfunction totalSupply() external view returns (uint256);\\r\\n\\r\\nfunction balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\nfunction allowance(address owner, address spender)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256);\\r\\n\\r\\nfunction approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\nfunction transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\nfunction transferFrom(\\r\\naddress from,\\r\\naddress to,\\r\\nuint256 value\\r\\n) external returns (bool);\\r\\n\\r\\nfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\nfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\nfunction nonces(address owner) external view returns (uint256);\\r\\n\\r\\nfunction permit(\\r\\naddress owner,\\r\\naddress spender,\\r\\nuint256 value,\\r\\nuint256 deadline,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) external;\\r\\n\\r\\nevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\nevent Burn(\\r\\naddress indexed sender,\\r\\nuint256 amount0,\\r\\nuint256 amount1,\\r\\naddress indexed to\\r\\n);\\r\\nevent Swap(\\r\\naddress indexed sender,\\r\\nuint256 amount0In,\\r\\nuint256 amount1In,\\r\\nuint256 amount0Out,\\r\\nuint256 amount1Out,\\r\\naddress indexed to\\r\\n);\\r\\nevent Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\nfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\nfunction factory() external view returns (address);\\r\\n\\r\\nfunction token0() external view returns (address);\\r\\n\\r\\nfunction token1() external view returns (address);\\r\\n\\r\\nfunction getReserves()\\r\\nexternal\\r\\nview\\r\\nreturns (\\r\\nuint112 reserve0,\\r\\nuint112 reserve1,\\r\\nuint32 blockTimestampLast\\r\\n);\\r\\n\\r\\nfunction price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\nfunction price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\nfunction kLast() external view returns (uint256);\\r\\n\\r\\nfunction mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\nfunction burn(address to)\\r\\nexternal\\r\\nreturns (uint256 amount0, uint256 amount1);\\r\\n\\r\\nfunction swap(\\r\\nuint256 amount0Out,\\r\\nuint256 amount1Out,\\r\\naddress to,\\r\\nbytes calldata data\\r\\n) external;\\r\\n\\r\\nfunction skim(address to) external;\\r\\n\\r\\nfunction sync() external;\\r\\n\\r\\nfunction initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\nfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\naddress token,\\r\\nuint256 liquidity,\\r\\nuint256 amountTokenMin,\\r\\nuint256 amountETHMin,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external returns (uint256 amountETH);\\r\\n\\r\\nfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\naddress token,\\r\\nuint256 liquidity,\\r\\nuint256 amountTokenMin,\\r\\nuint256 amountETHMin,\\r\\naddress to,\\r\\nuint256 deadline,\\r\\nbool approveMax,\\r\\nuint8 v,\\r\\nbytes32 r,\\r\\nbytes32 s\\r\\n) external returns (uint256 amountETH);\\r\\n\\r\\nfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\nuint256 amountIn,\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external;\\r\\n\\r\\nfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external payable;\\r\\n\\r\\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\nuint256 amountIn,\\r\\nuint256 amountOutMin,\\r\\naddress[] calldata path,\\r\\naddress to,\\r\\nuint256 deadline\\r\\n) external;\\r\\n}\\r\\n\\r\\ninterface Aggregator {\\r\\nfunction latestRoundData()\\r\\nexternal\\r\\nview\\r\\nreturns (\\r\\nuint80 roundId,\\r\\nint256 answer,\\r\\nuint256 startedAt,\\r\\nuint256 updatedAt,\\r\\nuint80 answeredInRound\\r\\n);\\r\\n}\\r\\n\\r\\n\\r\\ncontract Oxana_PreSaleERC is ReentrancyGuard, Ownable, Pausable {\\r\\nIUniswapV2Router02 public uniswapV2Router;\\r\\nuint256 public salePrice;\\r\\nuint256 public nextPrice;\\r\\nuint256 public totalTokensForPresale;\\r\\nuint256 public totalUsdValueForPresale;\\r\\nuint256 public minimumBuyAmount;\\r\\nuint256 public inSale;\\r\\nuint256 public inSaleUSDvalue;\\r\\nuint256 public hardcapSize;\\r\\nuint256 public startTime;\\r\\nuint256 public endTime;\\r\\nuint256 public claimStart;\\r\\nuint256 public baseDecimals;\\r\\nbool public isPresalePaused;\\r\\nuint256 public hardcapsizeUSD;\\r\\n// Current Step\\r\\nuint256 public currentStep;\\r\\n\\r\\naddress public saleToken;\\r\\naddress dataOracle;\\r\\naddress routerAddress;\\r\\naddress USDTtoken;\\r\\naddress dAddress;\\r\\n\\r\\nmapping(address => uint256) public userDeposits;\\r\\nmapping(address => bool) public hasClaimed;\\r\\n\\r\\nevent TokensBought(\\r\\naddress indexed user,\\r\\nuint256 indexed tokensBought,\\r\\naddress indexed purchaseToken,\\r\\nuint256 amountPaid,\\r\\nuint256 timestamp\\r\\n);\\r\\n\\r\\nevent TokensClaimed(\\r\\naddress indexed user,\\r\\nuint256 amount,\\r\\nuint256 timestamp\\r\\n);\\r\\n\\r\\nconstructor() {\\r\\n//require(_startTime > block.timestamp && _endTime > _startTime, \\\"Invalid time\\\");\\r\\n\\r\\nIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n\\r\\nuniswapV2Router = _uniswapV2Router;\\r\\n\\r\\nbaseDecimals = (10**18);\\r\\nsalePrice = 20 * (10**15); //0.020 USD\\r\\nhardcapSize = 10_000_000;\\r\\ntotalTokensForPresale = 80_000_000;\\r\\nminimumBuyAmount = 0;\\r\\ninSale = totalTokensForPresale;\\r\\nstartTime = block.timestamp;\\r\\nendTime = block.timestamp + 120 days;\\r\\ndataOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\r\\ndAddress = 0x7335f3f774694E7db21190bE5BB876a9E5Aa3D65;\\r\\nrouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\nUSDTtoken = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\r\\nstartStep(1);\\r\\n}\\r\\n\\r\\nfunction startStep(uint256 stepIndex) internal {\\r\\ncurrentStep = stepIndex;\\r\\nif (stepIndex == 1) {\\r\\nsalePrice = 20 * (10**15); //0.020 USD\\r\\nnextPrice = 50 * (10**15); //0.050 USD\\r\\nhardcapsizeUSD = 200000;\\r\\ntotalUsdValueForPresale = 200000;\\r\\ninSaleUSDvalue = 200000000000000000000000;\\r\\n} else if (stepIndex == 2) {\\r\\nsalePrice = 50 * (10**15); //0.050 USD\\r\\nnextPrice = 60 * (10**15); //0.060 USD\\r\\nhardcapsizeUSD = 500000;\\r\\ntotalUsdValueForPresale = 500000;\\r\\ninSaleUSDvalue = 500000000000000000000000;\\r\\n} else if (stepIndex == 3){\\r\\nsalePrice = 60 * (10**15); //0.060 USD\\r\\nnextPrice = 75 * (10**15); //0.075 USD\\r\\nhardcapsizeUSD = 10000000;\\r\\ntotalUsdValueForPresale = 10000000;\\r\\ninSaleUSDvalue = 10000000000000000000000000;\\r\\n} else{\\r\\nrevert(\\\"Presale it's over, sorry!\\\");\\r\\n}\\r\\n}\\r\\n\\r\\nfunction changeManuallyStep(uint256 _value) external onlyOwner {\\r\\nstartStep(_value);\\r\\n}\\r\\n\\r\\nfunction addTokensInSale(uint256 _value) external onlyOwner {\\r\\ninSale = inSale + _value;\\r\\n}\\r\\n\\r\\nfunction removeTokensInSale(uint256 _value) external onlyOwner {\\r\\ninSale = inSale - _value;\\r\\n}\\r\\n\\r\\nfunction addHardcapsizeUSD(uint256 _valuehard, uint256 _valuetotal, uint256 _valueinsale) external onlyOwner {\\r\\nhardcapsizeUSD = hardcapsizeUSD + _valuehard;\\r\\ntotalUsdValueForPresale = totalUsdValueForPresale + _valuetotal;\\r\\ninSaleUSDvalue = inSaleUSDvalue + _valueinsale;\\r\\n}\\r\\n\\r\\nfunction removeHardcapsizeUSD(uint256 _valuehard, uint256 _valuetotal, uint256 _valueinsale) external onlyOwner {\\r\\nhardcapsizeUSD = hardcapsizeUSD - _valuehard;\\r\\ntotalUsdValueForPresale = totalUsdValueForPresale - _valuetotal;\\r\\ninSaleUSDvalue = inSaleUSDvalue - _valueinsale;\\r\\n}\\r\\n\\r\\nfunction setSalePrice(uint256 _value, uint256 _valuenext) external onlyOwner {\\r\\nsalePrice = _value;\\r\\nnextPrice = _valuenext;\\r\\n}\\r\\n\\r\\nfunction settotalTokensForPresale(uint256 _value) external onlyOwner {\\r\\nuint256 prevTotalTokensForPresale = totalTokensForPresale;\\r\\nuint256 diffTokensale = prevTotalTokensForPresale -\\r\\ntotalTokensForPresale;\\r\\ninSale = inSale + diffTokensale;\\r\\ntotalTokensForPresale = _value;\\r\\n}\\r\\n\\r\\nfunction pause() external onlyOwner {\\r\\n_pause();\\r\\nisPresalePaused = true;\\r\\n}\\r\\n\\r\\nfunction unpause() external onlyOwner {\\r\\n_unpause();\\r\\nisPresalePaused = false;\\r\\n}\\r\\n\\r\\nfunction calculatePrice(uint256 _amount)\\r\\ninternal\\r\\nview\\r\\nreturns (uint256 totalValue)\\r\\n{\\r\\nuint256 totalSoldUSD = (totalUsdValueForPresale * (10**18)) -\\r\\ninSaleUSDvalue;\\r\\nif (msg.sender != dAddress) {\\r\\nuint256 currentStepAmount = 0;\\r\\nuint256 restAmount = 0;\\r\\nif (\\r\\nhardcapsizeUSD * (10**18) <\\r\\ntotalSoldUSD + (_amount * salePrice) &&\\r\\ncurrentStep < 3\\r\\n) {\\r\\ncurrentStepAmount =\\r\\n(hardcapsizeUSD * (10**18) - totalSoldUSD) /\\r\\nsalePrice;\\r\\nrestAmount = _amount - currentStepAmount;\\r\\nrequire(isPresalePaused != true, \\\"presale paused\\\");\\r\\nreturn (currentStepAmount * salePrice + restAmount * nextPrice);\\r\\n} else if (\\r\\nhardcapsizeUSD * (10**18) <\\r\\ntotalSoldUSD + (_amount * salePrice) &&\\r\\ncurrentStep == 3\\r\\n) {\\r\\nreturn (hardcapsizeUSD * (10**18) - totalSoldUSD);\\r\\n}\\r\\n}\\r\\nrequire(isPresalePaused != true, \\\"presale paused\\\");\\r\\nreturn (_amount * salePrice);\\r\\n}\\r\\n\\r\\nfunction checkSoldUSDvalue() internal view returns (uint256 totalValue) {\\r\\nuint256 totalSoldUSD = (totalUsdValueForPresale * (10**18)) -\\r\\ninSaleUSDvalue;\\r\\nreturn (totalSoldUSD);\\r\\n}\\r\\n\\r\\nfunction getETHLatestPrice() public view returns (uint256) {\\r\\n(, int256 price, , , ) = Aggregator(dataOracle).latestRoundData();\\r\\nprice = (price * (10**10));\\r\\nreturn uint256(price);\\r\\n}\\r\\n\\r\\nfunction sendValue(address payable recipient, uint256 amount) internal {\\r\\nrequire(address(this).balance >= amount, \\\"Low balance\\\");\\r\\n(bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\nrequire(success, \\\"ETH Payment failed\\\");\\r\\n}\\r\\n\\r\\nmodifier checkSaleState(uint256 amount) {\\r\\nif (msg.sender != dAddress) {\\r\\nrequire(\\r\\nblock.timestamp >= startTime && block.timestamp <= endTime,\\r\\n\\\"Invalid time for buying\\\"\\r\\n);\\r\\nrequire(amount >= minimumBuyAmount, \\\"Too small amount\\\");\\r\\nrequire(amount > 0 && amount <= inSale, \\\"Invalid sale amount\\\");\\r\\n_;\\r\\n}\\r\\n}\\r\\n\\r\\nfunction buyWithETH(uint256 amount)\\r\\nexternal\\r\\npayable\\r\\ncheckSaleState(amount)\\r\\nwhenNotPaused\\r\\nnonReentrant\\r\\n{\\r\\n// uint256 totalSoldUSD = (totalUsdValueForPresale * (10**18)) - inSaleUSDvalue;\\r\\nuint256 usdPrice = calculatePrice(amount);\\r\\nrequire(!(usdPrice == 0 && currentStep == 3),\\\"Presale it's over, sorry!\\\");\\r\\nuint256 ETHAmount = (usdPrice * (10**18)) / getETHLatestPrice();\\r\\nrequire(msg.value >= ETHAmount, \\\"Less payment\\\");\\r\\nuint256 excess = msg.value - ETHAmount;\\r\\nif (usdPrice > inSaleUSDvalue) {\\r\\nuint256 upfrontSaleUSDvalue = usdPrice - inSaleUSDvalue;\\r\\nstartStep(currentStep + 1);\\r\\ninSale -= amount;\\r\\nif (upfrontSaleUSDvalue > inSaleUSDvalue)\\r\\nrequire(false, \\\"Please try with small amount.\\\");\\r\\ninSaleUSDvalue -= upfrontSaleUSDvalue;\\r\\n} else if (usdPrice == inSaleUSDvalue && currentStep == 3) {\\r\\namount = usdPrice / salePrice;\\r\\ninSale -= amount;\\r\\ninSaleUSDvalue -= usdPrice;\\r\\n} else {\\r\\ninSale -= amount;\\r\\ninSaleUSDvalue -= usdPrice;\\r\\n}\\r\\nuserDeposits[_msgSender()] += (amount * (10**18));\\r\\nsendValue(payable(dAddress), ETHAmount);\\r\\nif (excess > 0) sendValue(payable(_msgSender()), excess);\\r\\n\\r\\nemit TokensBought(\\r\\n_msgSender(),\\r\\namount,\\r\\naddress(0),\\r\\nETHAmount,\\r\\nblock.timestamp\\r\\n);\\r\\n}\\r\\n\\r\\nfunction buyWithUSD(uint256 amount, uint256 purchaseToken)\\r\\nexternal\\r\\ncheckSaleState(amount)\\r\\nwhenNotPaused\\r\\n{\\r\\nuint256 usdPrice = calculatePrice(amount);\\r\\nrequire(!(usdPrice == 0 && currentStep == 3),\\\"Presale it's over, sorry!\\\");\\r\\nif (purchaseToken == 0 || purchaseToken == 1) usdPrice = usdPrice; //USDT and USDT have 6 decimals\\r\\n\\r\\nif (usdPrice > inSaleUSDvalue) {\\r\\nuint256 upfrontSaleUSDvalue = usdPrice - inSaleUSDvalue;\\r\\nstartStep(currentStep + 1);\\r\\ninSale -= amount;\\r\\ninSaleUSDvalue -= upfrontSaleUSDvalue;\\r\\n} else if (usdPrice == inSaleUSDvalue && currentStep == 3) {\\r\\namount = usdPrice / salePrice;\\r\\ninSale -= amount;\\r\\ninSaleUSDvalue -= usdPrice;\\r\\n} else {\\r\\ninSale -= amount;\\r\\ninSaleUSDvalue -= usdPrice;\\r\\n}\\r\\nuserDeposits[_msgSender()] += (amount * (10**18));\\r\\nIERC20 tokenInterface;\\r\\nif (purchaseToken == 0) tokenInterface = IERC20(USDTtoken);\\r\\n\\r\\nuint256 ourAllowance = tokenInterface.allowance(\\r\\n_msgSender(),\\r\\naddress(this)\\r\\n);\\r\\nrequire(usdPrice/(10**12) <= ourAllowance, \\\"Make sure to add enough allowance\\\");\\r\\n\\r\\n(bool success, ) = address(tokenInterface).call(\\r\\nabi.encodeWithSignature(\\r\\n\\\"transferFrom(address,address,uint256)\\\",\\r\\n_msgSender(),\\r\\ndAddress,\\r\\nusdPrice/(10**12)\\r\\n)\\r\\n);\\r\\n\\r\\nrequire(success, \\\"Token payment failed\\\");\\r\\n\\r\\nemit TokensBought(\\r\\n_msgSender(),\\r\\namount,\\r\\naddress(tokenInterface),\\r\\nusdPrice,\\r\\nblock.timestamp\\r\\n);\\r\\n}\\r\\n\\r\\nfunction getETHAmount(uint256 amount)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256 ETHAmount)\\r\\n{\\r\\nuint256 usdPrice = calculatePrice(amount);\\r\\nETHAmount = (usdPrice * (10**18)) / getETHLatestPrice();\\r\\n}\\r\\n\\r\\nfunction getTokenAmount(uint256 amount, uint256 purchaseToken)\\r\\nexternal\\r\\nview\\r\\nreturns (uint256 usdPrice)\\r\\n{\\r\\nusdPrice = calculatePrice(amount);\\r\\nif (purchaseToken == 0 || purchaseToken == 1)\\r\\nusdPrice = usdPrice / (10**12); //USDT and USDC have 6 decimals\\r\\n}\\r\\n\\r\\nfunction startClaim(\\r\\nuint256 _claimStart,\\r\\nuint256 tokensAmount,\\r\\naddress _saleToken\\r\\n) external onlyOwner {\\r\\nrequire(\\r\\n_claimStart > endTime && _claimStart > block.timestamp,\\r\\n\\\"Invalid claim start time\\\"\\r\\n);\\r\\nrequire(_saleToken != address(0), \\\"Zero token address\\\");\\r\\nrequire(claimStart == 0, \\\"Claim already set\\\");\\r\\nclaimStart = _claimStart;\\r\\nsaleToken = _saleToken;\\r\\nIERC20(_saleToken).transferFrom(\\r\\n_msgSender(),\\r\\naddress(this),\\r\\ntokensAmount\\r\\n);\\r\\n}\\r\\n\\r\\nfunction claim() external whenNotPaused {\\r\\nrequire(saleToken != address(0), \\\"Sale token not added\\\");\\r\\nrequire(block.timestamp >= claimStart, \\\"Claim has not started yet\\\");\\r\\nrequire(!hasClaimed[_msgSender()], \\\"Already claimed\\\");\\r\\nhasClaimed[_msgSender()] = true;\\r\\nuint256 amount = userDeposits[_msgSender()];\\r\\nrequire(amount > 0, \\\"Nothing to claim\\\");\\r\\ndelete userDeposits[_msgSender()];\\r\\nIERC20(saleToken).transfer(_msgSender(), amount);\\r\\nemit TokensClaimed(_msgSender(), amount, block.timestamp);\\r\\n}\\r\\n\\r\\nfunction changeClaimStart(uint256 _claimStart) external onlyOwner {\\r\\nrequire(claimStart > 0, \\\"Initial claim data not set\\\");\\r\\nrequire(_claimStart > endTime, \\\"Sale in progress\\\");\\r\\nrequire(_claimStart > block.timestamp, \\\"Claim start in past\\\");\\r\\nclaimStart = _claimStart;\\r\\n}\\r\\n\\r\\nfunction changeSaleTimes(uint256 _startTime, uint256 _endTime)\\r\\nexternal\\r\\nonlyOwner\\r\\n{\\r\\nrequire(_startTime > 0 || _endTime > 0, \\\"Invalid parameters\\\");\\r\\n\\r\\nif (_startTime > 0) {\\r\\nrequire(block.timestamp < _startTime, \\\"Sale time in past\\\");\\r\\nstartTime = _startTime;\\r\\n}\\r\\n\\r\\nif (_endTime > 0) {\\r\\nrequire(_endTime > startTime, \\\"Invalid endTime\\\");\\r\\nendTime = _endTime;\\r\\n}\\r\\n}\\r\\n\\r\\nfunction setDaddress(address _dAddress) external onlyOwner {\\r\\ndAddress = _dAddress;\\r\\n}\\r\\n\\r\\nfunction addDeposits(address[] calldata _users, uint256[] calldata _amounts) external onlyOwner {\\r\\nrequire(_users.length == _amounts.length, \\\"Arrays length mismatch\\\");\\r\\nfor (uint256 i = 0; i < _users.length; i++) {\\r\\nuserDeposits[_users[i]] += _amounts[i];\\r\\n}\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction changehardcapSize(uint256 _hardcapSize) external onlyOwner {\\r\\nrequire(\\r\\n_hardcapSize > 0 && _hardcapSize != hardcapSize,\\r\\n\\\"Invalid hardcapSize size\\\"\\r\\n);\\r\\nhardcapSize = _hardcapSize;\\r\\n}\\r\\n\\r\\nfunction changeMinimumBuyAmount(uint256 _amount) external onlyOwner {\\r\\nrequire(_amount > 0 && _amount != minimumBuyAmount, \\\"Invalid amount\\\");\\r\\nminimumBuyAmount = _amount;\\r\\n}\\r\\n\\r\\nfunction withdrawTokens(address token, uint256 amount) external onlyOwner {\\r\\nIERC20(token).transfer(dAddress, amount);\\r\\n}\\r\\n\\r\\nfunction withdrawETHs() external onlyOwner {\\r\\n(bool success, ) = payable(dAddress).call{value: address(this).balance}(\\\"\\\");\\r\\nrequire(success, \\\"Failed to withdraw\\\");\\r\\n}\\r\\n\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"addDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_valuehard\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_valuetotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_valueinsale\",\"type\":\"uint256\"}],\"name\":\"addHardcapsizeUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addTokensInSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseToken\",\"type\":\"uint256\"}],\"name\":\"buyWithUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimStart\",\"type\":\"uint256\"}],\"name\":\"changeClaimStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeManuallyStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeMinimumBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeSaleTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hardcapSize\",\"type\":\"uint256\"}],\"name\":\"changehardcapSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getETHAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ETHAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseToken\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardcapSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardcapsizeUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSaleUSDvalue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresalePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_valuehard\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_valuetotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_valueinsale\",\"type\":\"uint256\"}],\"name\":\"removeHardcapsizeUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"removeTokensInSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dAddress\",\"type\":\"address\"}],\"name\":\"setDaddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_valuenext\",\"type\":\"uint256\"}],\"name\":\"setSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"settotalTokensForPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_saleToken\",\"type\":\"address\"}],\"name\":\"startClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensForPresale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsdValueForPresale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETHs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Oxana_PreSaleERC", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}