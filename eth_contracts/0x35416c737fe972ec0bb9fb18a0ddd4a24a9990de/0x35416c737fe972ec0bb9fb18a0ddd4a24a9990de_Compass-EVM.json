{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title Compass-EVM\r\n@author Volume.Finance\r\n\"\"\"\r\n\r\nMAX_VALIDATORS: constant(uint256) = 320\r\nMAX_PAYLOAD: constant(uint256) = 20480\r\nMAX_BATCH: constant(uint256) = 64\r\n\r\nPOWER_THRESHOLD: constant(uint256) = 2_863_311_530 # 2/3 of 2^32, Validator powers will be normalized to sum to 2 ^ 32 in every valset update.\r\nTURNSTONE_ID: immutable(bytes32)\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\nstruct Valset:\r\n    validators: DynArray[address, MAX_VALIDATORS] # Validator addresses\r\n    powers: DynArray[uint256, MAX_VALIDATORS] # Powers of given validators, in the same order as validators array\r\n    valset_id: uint256 # nonce of this validator set\r\n\r\nstruct Signature:\r\n    v: uint256\r\n    r: uint256\r\n    s: uint256\r\n\r\nstruct Consensus:\r\n    valset: Valset # Valset data\r\n    signatures: DynArray[Signature, MAX_VALIDATORS] # signatures in the same order as validator array in valset\r\n\r\nstruct LogicCallArgs:\r\n    logic_contract_address: address # the arbitrary contract address to external call\r\n    payload: Bytes[MAX_PAYLOAD] # payloads\r\n\r\nstruct TokenSendArgs:\r\n    receiver: DynArray[address, MAX_BATCH]\r\n    amount: DynArray[uint256, MAX_BATCH]\r\n\r\nevent ValsetUpdated:\r\n    checkpoint: bytes32\r\n    valset_id: uint256\r\n\r\nevent LogicCallEvent:\r\n    logic_contract_address: address\r\n    payload: Bytes[MAX_PAYLOAD]\r\n    message_id: uint256\r\n\r\nevent SendToPalomaEvent:\r\n    token: address\r\n    sender: address\r\n    receiver: String[64]\r\n    amount: uint256\r\n\r\nevent BatchSendEvent:\r\n    token: address\r\n    message_id: uint256\r\n\r\nevent ERC20DeployedEvent:\r\n    paloma_denom: String[64]\r\n    token_contract: address\r\n    name: String[64]\r\n    symbol: String[32]\r\n    decimals: uint8\r\n\r\nlast_checkpoint: public(bytes32)\r\nlast_valset_id: public(uint256)\r\nmessage_id_used: public(HashMap[uint256, bool])\r\n\r\n# turnstone_id: unique identifier for turnstone instance\r\n# valset: initial validator set\r\n@external\r\ndef __init__(turnstone_id: bytes32, valset: Valset):\r\n    TURNSTONE_ID = turnstone_id\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in valset.validators:\r\n        cumulative_power += valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    new_checkpoint: bytes32 = keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, turnstone_id, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = valset.valset_id\r\n    log ValsetUpdated(new_checkpoint, valset.valset_id)\r\n\r\n@external\r\n@pure\r\ndef turnstone_id() -> bytes32:\r\n    return TURNSTONE_ID\r\n\r\n# utility function to verify EIP712 signature\r\n@internal\r\n@pure\r\ndef verify_signature(signer: address, hash: bytes32, sig: Signature) -> bool:\r\n    message_digest: bytes32 = keccak256(concat(convert(\"\\x19Ethereum Signed Message:\\n32\", Bytes[28]), hash))\r\n    return signer == ecrecover(message_digest, sig.v, sig.r, sig.s)\r\n\r\n# consensus: validator set and signatures\r\n# hash: what we are checking they have signed\r\n@internal\r\ndef check_validator_signatures(consensus: Consensus, hash: bytes32):\r\n    i: uint256 = 0\r\n    cumulative_power: uint256 = 0\r\n    for sig in consensus.signatures:\r\n        if sig.v != 0:\r\n            assert self.verify_signature(consensus.valset.validators[i], hash, sig), \"Invalid Signature\"\r\n            cumulative_power += consensus.valset.powers[i]\r\n            if cumulative_power >= POWER_THRESHOLD:\r\n                break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n\r\n# Make a new checkpoint from the supplied validator set\r\n# A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\r\n# instead of storing the information directly. This saves on storage and gas.\r\n# The format of the checkpoint is:\r\n# keccak256 hash of abi_encoded checkpoint(validators[], powers[], valset_id, turnstone_id)\r\n# The validator powers must be decreasing or equal. This is important for checking the signatures on the\r\n# next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\r\n@internal\r\n@view\r\ndef make_checkpoint(valset: Valset) -> bytes32:\r\n    return keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, TURNSTONE_ID, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n\r\n# This updates the valset by checking that the validators in the current valset have signed off on the\r\n# new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\r\n# generated from the new valset.\r\n# Anyone can call this function, but they must supply valid signatures of constant_powerThreshold of the current valset over\r\n# the new valset.\r\n# valset: new validator set to update with\r\n# consensus: current validator set and signatures\r\n@external\r\ndef update_valset(consensus: Consensus, new_valset: Valset):\r\n    # check if new valset_id is greater than current valset_id\r\n    assert new_valset.valset_id > consensus.valset.valset_id, \"Invalid Valset ID\"\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in new_valset.validators:\r\n        cumulative_power += new_valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i += 1\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # calculate the new checkpoint\r\n    new_checkpoint: bytes32 = self.make_checkpoint(new_valset)\r\n    # check if enough validators signed new validator set (new checkpoint)\r\n    self.check_validator_signatures(consensus, new_checkpoint)\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = new_valset.valset_id\r\n    log ValsetUpdated(new_checkpoint, new_valset.valset_id)\r\n\r\n# This makes calls to contracts that execute arbitrary logic\r\n# message_id is to prevent replay attack and every message_id can be used only once\r\n@external\r\ndef submit_logic_call(consensus: Consensus, args: LogicCallArgs, message_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert not self.message_id_used[message_id], \"Used Message_ID\"\r\n    self.message_id_used[message_id] = True\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded logic_call(args, message_id, turnstone_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(args, message_id, TURNSTONE_ID, deadline, method_id=method_id(\"logic_call((address,bytes),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    raw_call(args.logic_contract_address, args.payload)\r\n    log LogicCallEvent(args.logic_contract_address, args.payload, message_id)\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(\r\n            _from, _to, _value,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"TransferFrom failed\"\r\n\r\n@external\r\ndef send_token_to_paloma(token: address, receiver: String[64], amount: uint256):\r\n    _balance: uint256 = ERC20(token).balanceOf(self)\r\n    self._safe_transfer_from(token, msg.sender, self, amount)\r\n    _balance -= ERC20(token).balanceOf(self)\r\n    assert _balance > 0\r\n    log SendToPalomaEvent(token, msg.sender, receiver, amount)\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(\r\n            _to, _value,\r\n            method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"TransferFrom failed\"\r\n\r\n@external\r\ndef submit_batch(consensus: Consensus, token: address, args: TokenSendArgs, message_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert not self.message_id_used[message_id], \"Used Message_ID\"\r\n    length: uint256 = len(args.receiver)\r\n    assert length == len(args.amount)\r\n    self.message_id_used[message_id] = True\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded logic_call(args, message_id, turnstone_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(token, args, message_id, TURNSTONE_ID, deadline, method_id=method_id(\"batch_call(address,(address[],uint256[]),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    for i in range(MAX_BATCH):\r\n        if  i >= length:\r\n            break\r\n        self._safe_transfer(token, args.receiver[i], args.amount[i])\r\n    log BatchSendEvent(token, message_id)\r\n\r\n@external\r\ndef deploy_erc20(_paloma_denom: String[64], _name: String[64], _symbol: String[32], _decimals: uint8, _blueprint: address):\r\n    assert msg.sender == self, \"Invalid\"\r\n    erc20: address = create_from_blueprint(_blueprint, self, _name, _symbol, _decimals, code_offset=3)\r\n    log ERC20DeployedEvent(_paloma_denom, erc20, _name, _symbol, _decimals)", "ABI": "[{\"name\":\"ValsetUpdated\",\"inputs\":[{\"name\":\"checkpoint\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"valset_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LogicCallEvent\",\"inputs\":[{\"name\":\"logic_contract_address\",\"type\":\"address\",\"indexed\":false},{\"name\":\"payload\",\"type\":\"bytes\",\"indexed\":false},{\"name\":\"message_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SendToPalomaEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"receiver\",\"type\":\"string\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BatchSendEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"message_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ERC20DeployedEvent\",\"inputs\":[{\"name\":\"paloma_denom\",\"type\":\"string\",\"indexed\":false},{\"name\":\"token_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"name\",\"type\":\"string\",\"indexed\":false},{\"name\":\"symbol\",\"type\":\"string\",\"indexed\":false},{\"name\":\"decimals\",\"type\":\"uint8\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"turnstone_id\",\"type\":\"bytes32\"},{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"turnstone_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_valset\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"new_valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_logic_call\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"logic_contract_address\",\"type\":\"address\"},{\"name\":\"payload\",\"type\":\"bytes\"}]},{\"name\":\"message_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"send_token_to_paloma\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_batch\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"receiver\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"}]},{\"name\":\"message_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_erc20\",\"inputs\":[{\"name\":\"_paloma_denom\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_blueprint\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_valset_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"message_id_used\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Compass-EVM", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "313636343038340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000058000000000000000000000000000000000000000000000000000000000000018240000000000000000000000000000000000000000000000000000000000000028000000000000000000000000092604a080524eff1c875ff13a1b88cbdd41df370000000000000000000000006dc59ee4bdfa2c791229004f29b08f783491a934000000000000000000000000deea5b069208e0ee37b630a3e7672fc50e8fe24a000000000000000000000000c47b85c7577260d995be7ab65728ae33b4cd26cd000000000000000000000000ade5f5efeae72102d998f6c496ea59731a70eeb0000000000000000000000000279fc7c0ebef3328d3899fe73464347a764c5f2c000000000000000000000000aac74d38c82c367b3da7482e3aecf6dd7a512ef200000000000000000000000043e218f96a567dc26c6e65fcabf1fde26af694440000000000000000000000005a7c9fc846b18944fd2b8f8ae7255db5af7b9c040000000000000000000000001ad90db98da083e117d5f62a1673fc0f3a5930ca00000000000000000000000063f55bc560e981d53e1f5bb3643e3a96d26fc6350000000000000000000000001dd71ee9e7b1cff10ccb7e12520999c2d4fb45e50000000000000000000000004a89f96fdff3c161937cfbc3e22d2e325612aaec0000000000000000000000001f6ef2784cbb2a5011d8cf12356fb5ee3eaef372000000000000000000000000443266026738061972012e62d5ecd9d98da8b6f4000000000000000000000000443520951d766456f2ac5578f3e7e4b56a7bcf63000000000000000000000000eb13a069d119558b6653cbc8c069dafb3d6758e70000000000000000000000007c3de83d90e8d2001a7e3f38e6a7058334cb291e0000000000000000000000007b5f4b6490ebc2dd03b717d7d26edc78451a88b4000000000000000000000000377d23948d41579f2c3ca40308e3bdd53f6da7b20000000000000000000000000daabb4ff60423eb1f14cc6731394e098ad51bcb000000000000000000000000cfbbf6341cf13a39ffcaf24b86de09489116783b000000000000000000000000179206cd9080a8ee77c2256a27050112da13b2f60000000000000000000000003a188de3d16ddee783990dded1b629e95c8242d900000000000000000000000031cbc8e1bc86d1ba0f5e77afc324d785c54ae3200000000000000000000000006bf4893a5a54191cf16e6337956aa4c99c793903000000000000000000000000827d61ccf62a78a9ac192cb4b47c51df7db4b1660000000000000000000000008b6cd0884e227e7ef90fc4c8b642d723109271c3000000000000000000000000837f0c0d5b50f5463e4dafcd7bae63207e2f63800000000000000000000000009314f0e1d09e1c541c1db02b622af9ca5f1ac9fe000000000000000000000000722e2b4107d3dc5e99cbb4919a1580ae70baab74000000000000000000000000fc0f1e32e0db02cd81de8f662a51e2c285d5228d000000000000000000000000eb784b37365c302c97c9ec8cb0933ce344e6de42000000000000000000000000ee21301af1d9562b5cbedf520077ea0a9bc9d535000000000000000000000000bbefe691d2c3bbb835ce2958b453ccd05bdb27a50000000000000000000000001829a4a33cc162d3d55ed79d77574005a084142b0000000000000000000000005cb3114baf54395da6c3665616bdf59e8dcb3b8a000000000000000000000000b5117420bd1726b6bfeced63602b287ab3dba219000000000000000000000000a49f65cf05dcce7c92621ed41cba9e4e09a5d618000000000000000000000000ecaf11bb88082f06a64d5fa3076a74df792e6afe0000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000001adfb7810000000000000000000000000000000000000000000000000000000011b5e025000000000000000000000000000000000000000000000000000000000f13ec7a000000000000000000000000000000000000000000000000000000000ed4979d000000000000000000000000000000000000000000000000000000000e7e486d000000000000000000000000000000000000000000000000000000000e320cc0000000000000000000000000000000000000000000000000000000000d54f7e2000000000000000000000000000000000000000000000000000000000d24f812000000000000000000000000000000000000000000000000000000000cf34102000000000000000000000000000000000000000000000000000000000cb4b767000000000000000000000000000000000000000000000000000000000b1b97e3000000000000000000000000000000000000000000000000000000000a7b900f000000000000000000000000000000000000000000000000000000000a2280350000000000000000000000000000000000000000000000000000000008c013aa000000000000000000000000000000000000000000000000000000000857d50a0000000000000000000000000000000000000000000000000000000006dbcaf00000000000000000000000000000000000000000000000000000000006b7220200000000000000000000000000000000000000000000000000000000069bed3a00000000000000000000000000000000000000000000000000000000068a49320000000000000000000000000000000000000000000000000000000004a5860000000000000000000000000000000000000000000000000000000000004b2034000000000000000000000000000000000000000000000000000000000041ba2200000000000000000000000000000000000000000000000000000000002a740d0000000000000000000000000000000000000000000000000000000000297c6b00000000000000000000000000000000000000000000000000000000002973ee000000000000000000000000000000000000000000000000000000000029734c00000000000000000000000000000000000000000000000000000000002952f30000000000000000000000000000000000000000000000000000000000293dac000000000000000000000000000000000000000000000000000000000028ccf0000000000000000000000000000000000000000000000000000000000028bf5c0000000000000000000000000000000000000000000000000000000000288aac0000000000000000000000000000000000000000000000000000000000272473000000000000000000000000000000000000000000000000000000000026e154000000000000000000000000000000000000000000000000000000000026d089000000000000000000000000000000000000000000000000000000000026180b0000000000000000000000000000000000000000000000000000000000133c3d000000000000000000000000000000000000000000000000000000000011cc81000000000000000000000000000000000000000000000000000000000011cc81000000000000000000000000000000000000000000000000000000000011cc730000000000000000000000000000000000000000000000000000000000119ef1", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}