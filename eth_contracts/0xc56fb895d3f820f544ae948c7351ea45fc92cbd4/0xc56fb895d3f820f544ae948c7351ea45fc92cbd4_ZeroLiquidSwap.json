{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ZeroLiquidSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport { SafeERC20 } from \\\"./libraries/SafeERC20.sol\\\";\\n\\nimport { IERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IWETH9 } from \\\"./interfaces/external/IWETH9.sol\\\";\\n\\nimport { Unauthorized, IllegalState, IllegalArgument } from \\\"./base/ErrorMessages.sol\\\";\\n\\n/// @title  IZeroLiquid\\n/// @author ZeroLiquid\\ninterface IZeroLiquid {\\n    /// @notice Deposit a yield token into a user's account.\\n    ///\\n    /// @notice An approval must be set for `yieldToken` which is greater than `amount`.\\n    ///\\n    /// @notice `yieldToken` must be registered or this call will revert with a {UnsupportedToken} error.\\n    /// @notice `yieldToken` must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `yieldToken` underlying token must be enabled or this call will revert with a {TokenDisabled} error.\\n    /// @notice `recipient` must be non-zero or this call will revert with an {IllegalArgument} error.\\n    /// @notice `amount` must be greater than zero or the call will revert with an {IllegalArgument} error.\\n    ///\\n    /// @notice Emits a {Deposit} event.\\n    ///\\n    ///\\n    /// @notice **_NOTE:_** When depositing, the `ZeroLiquid` contract must have **allowance()** to spend funds on\\n    /// behalf of **msg.sender** for at least **amount** of the **yieldToken** being deposited.  This can be done via\\n    /// the standard `ERC20.approve()` method.\\n    ///\\n    /// @param yieldToken The yield-token to deposit.\\n    /// @param amount     The amount of yield tokens to deposit.\\n    /// @param recipient  The owner of the account that will receive the resulting shares.\\n    ///\\n    /// @return sharesIssued The number of shares issued to `recipient`.\\n    function deposit(address yieldToken, uint256 amount, address recipient) external returns (uint256 sharesIssued);\\n}\\n\\n/// @title  IAggregationRouterV5\\n/// @author 1inch Aggregator\\ninterface IAggregationRouterV5 {\\n    struct SwapDescription {\\n        address srcToken;\\n        address dstToken;\\n        address payable srcReceiver;\\n        address payable dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n    }\\n\\n    /// @notice Performs a swap, delegating all calls encoded in `data` to `executor`. See 1inch's tests for usage\\n    /// examples\\n    /// @dev router keeps 1 wei of every token on the contract balance for gas optimisations reasons. This affects first\\n    /// swap of every token by leaving 1 wei on the contract.\\n    /// @param executor Aggregation executor that executes calls described in `data`\\n    /// @param desc Swap description\\n    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.\\n    /// @param data Encoded calls that `caller` should execute in between of swaps\\n    function swap(\\n        address executor,\\n        SwapDescription calldata desc,\\n        bytes calldata permit,\\n        bytes calldata data\\n    )\\n        external\\n        payable;\\n}\\n\\n/// @title  ZeroLiquidSwap\\n/// @author ZeroLiquid\\n/// @notice Used incase of depositing into ZeroLiquid using unsupported yield token.\\n/// Facilities depositing into ZeroLiquid by swapping altcoins/ETH on 1inch aggregator\\n/// for supported yield tokens.\\ncontract ZeroLiquidSwap {\\n    IWETH9 public constant WETH = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    address public immutable zeroliquid;\\n    address public immutable debtToken;\\n    // 1inch AggregationRouterV5 address\\n    address public immutable swapRouter;\\n\\n    /// @notice Emits when a user swaps amount of `srcToken` specified by `srcAmount` to `dstToken` & deposits the\\n    /// `dstAmount` to `recipient`.\\n    ///\\n    /// @notice The `dstToken` will always be the supported yield token of ZeroLiquid protocol.\\n    ///\\n    /// @param sender       The address of the user which deposited funds.\\n    /// @param srcToken     The address of `srctoken` that was swapped for `dstToken`.\\n    /// @param dstToken     The address of `dstToken` token that was deposited.\\n    /// @param srcAmount    The amount of `srcToken` that were swaped.\\n    /// @param dstAmount    The amount of `dstToken` that were deposited.\\n    /// @param recipient    The address that received the deposited funds.\\n    event Deposit(\\n        address indexed sender,\\n        address indexed srcToken,\\n        address indexed dstToken,\\n        uint256 srcAmount,\\n        uint256 dstAmount,\\n        address recipient\\n    );\\n\\n    constructor(address _zeroliquid, address _debtToken, address _swapRouter) {\\n        if (_zeroliquid == address(0) || _debtToken == address(0) || _swapRouter == address(0)) {\\n            revert IllegalArgument(\\\"Invalid Contract Address\\\");\\n        }\\n\\n        zeroliquid = _zeroliquid;\\n        debtToken = _debtToken;\\n        swapRouter = _swapRouter;\\n    }\\n\\n    /// @notice Swaps altcoin or ETH to supported yield token and deposits it into zeroliquid.\\n    /// Uses 1inch AggregationRouterV5's swap() function for swapping\\n    ///\\n    /// @notice Emits Deposit event\\n    /// @notice An approval must be set for \\\"srcToken\\\" (except ETH) in swap description for amount >= desc.amount.\\n    ///\\n    /// @param recipient The owner of the account that will receive the resulting shares.\\n    /// @param executor Aggregation executor that executes calls described in `data`.\\n    /// @param desc Swap description.\\n    /// @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.\\n    /// @param data Encoded calls that `caller` should execute in between of swaps.\\n    function deposit(\\n        address recipient,\\n        address executor,\\n        IAggregationRouterV5.SwapDescription calldata desc,\\n        bytes calldata permit,\\n        bytes calldata data\\n    )\\n        external\\n        payable\\n    {\\n        uint256 receivedAmount;\\n\\n        if (desc.srcToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE && desc.amount == msg.value) {\\n            uint256 startingAmount = IERC20(desc.dstToken).balanceOf(address(this));\\n            IAggregationRouterV5(swapRouter).swap{ value: msg.value }(executor, desc, permit, data);\\n            receivedAmount = IERC20(desc.dstToken).balanceOf(address(this)) - startingAmount;\\n\\n            SafeERC20.safeApprove(desc.dstToken, zeroliquid, receivedAmount);\\n            IZeroLiquid(zeroliquid).deposit(desc.dstToken, receivedAmount, recipient);\\n        } else {\\n            SafeERC20.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\\n\\n            SafeERC20.safeApprove(desc.srcToken, swapRouter, desc.amount);\\n            uint256 startingAmount = IERC20(desc.dstToken).balanceOf(address(this));\\n            IAggregationRouterV5(swapRouter).swap{ value: 0 }(executor, desc, permit, data);\\n            receivedAmount = IERC20(desc.dstToken).balanceOf(address(this)) - startingAmount;\\n\\n            SafeERC20.safeApprove(desc.dstToken, zeroliquid, receivedAmount);\\n            IZeroLiquid(zeroliquid).deposit(desc.dstToken, receivedAmount, recipient);\\n        }\\n\\n        emit Deposit(msg.sender, desc.srcToken, desc.dstToken, desc.amount, receivedAmount, recipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4;\\n\\nimport { IERC20 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IllegalState } from \\\"../base/ErrorMessages.sol\\\";\\n\\nimport { IERC20Metadata } from \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\n/// @title  SafeERC20\\n/// @author ZeroLiquid\\nlibrary SafeERC20 {\\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\\n    ///\\n    /// @param target  The target address.\\n    /// @param success If the call to the token was a success.\\n    /// @param data    The resulting data from the call. This is error data when the call was not a\\n    ///                success. Otherwise, this is malformed data when the call was a success.\\n    error ERC20CallFailed(address target, bool success, bytes data);\\n\\n    /// @dev A safe function to get the decimals of an ERC20 token.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token The target token.\\n    ///\\n    /// @return The amount of decimals of the token.\\n    function expectDecimals(address token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));\\n\\n        if (!success || data.length < 32) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n\\n        return abi.decode(data, (uint8));\\n    }\\n\\n    /// @dev Transfers tokens to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Approves tokens for the smart contract.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token   The token to approve.\\n    /// @param spender The contract to spend the tokens.\\n    /// @param value   The amount of tokens to approve.\\n    function safeApprove(address token, address spender, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Transfer tokens from one address to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param owner     The address of the owner.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../IERC20Metadata.sol\\\";\\n\\n/// @title IWETH9\\ninterface IWETH9 is IERC20, IERC20Metadata {\\n    /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\\n    function deposit() external payable;\\n\\n    /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\\n    ///\\n    /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\\n    ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\\n    ///\\n    /// @param amount The amount of tokens to burn.\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/base/ErrorMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\n/// @notice An error used to indicate that an argument passed to a function is illegal or\\n///         inappropriate.\\n///\\n/// @param message The error message.\\nerror IllegalArgument(string message);\\n\\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\\n///\\n/// @param message The error message.\\nerror IllegalState(string message);\\n\\n/// @notice An error used to indicate that an operation is unsupported.\\n///\\n/// @param message The error message.\\nerror UnsupportedOperation(string message);\\n\\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\\n///\\n/// @param message The error message.\\nerror Unauthorized(string message);\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IERC20Metadata\\n/// @author ZeroLiquid\\ninterface IERC20Metadata {\\n    /// @notice Gets the name of the token.\\n    ///\\n    /// @return The name.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Gets the symbol of the token.\\n    ///\\n    /// @return The symbol.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Gets the number of decimals that the token has.\\n    ///\\n    /// @return The number of decimals.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zeroliquid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_debtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"srcReceiver\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"internalType\":\"struct IAggregationRouterV5.SwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroliquid\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZeroLiquidSwap", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000246e28c6b161764492e54cbf852e28a4da2d672000000000000000000000000776280f68ad33c4d49e6846507b7dbaf7811c89f0000000000000000000000001111111254eeb25477b68fb85ed929f73a960582", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}