{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"TheMostTokensEver.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC721} from \\\"./interfaces/IERC721.sol\\\";\\r\\nimport {Base64} from \\\"./solady/Base64.sol\\\";\\r\\n\\r\\ncontract TheMostTokensEver is IERC721 {\\r\\n\\r\\n    event ConsecutiveTransfer(\\r\\n        uint256 indexed fromTokenId, \\r\\n        uint256 toTokenId, \\r\\n        address indexed fromAddress, \\r\\n        address indexed toAddress);\\r\\n\\r\\n    mapping(address _owner => uint256 balance) public balanceOf;\\r\\n    mapping(uint256 tokenId => address _owner) private _ownerOf;\\r\\n    mapping(uint256 tokenId => address _approved) public getApproved;\\r\\n    mapping(address _owner => mapping(address _operator => bool _approved)) public isApprovedForAll;\\r\\n\\r\\n    address public constant DEFAULT_OWNER = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\\r\\n    address public constant owner = 0x3C5E6B4292Ed35e8973400bEF77177A9e84e8E6e;\\r\\n    string public name = \\\"The Most Tokens Ever\\\";\\r\\n    string public symbol = \\\"TMTE\\\";\\r\\n\\r\\n    uint256 public constant totalSupply = 0; //2^256 overflows to 0\\r\\n\\r\\n    constructor() {\\r\\n        balanceOf[owner] = 1;\\r\\n        _ownerOf[0] = owner;\\r\\n        emit Transfer(address(0), owner, 0);\\r\\n\\r\\n        balanceOf[DEFAULT_OWNER] = type(uint256).max;\\r\\n        emit ConsecutiveTransfer(1, type(uint256).max, address(0), DEFAULT_OWNER);\\r\\n        isApprovedForAll[DEFAULT_OWNER][address(this)] = true;\\r\\n        emit ApprovalForAll(DEFAULT_OWNER, address(this), true);\\r\\n    }\\r\\n\\r\\n    function claim(uint256 _tokenId) public payable {\\r\\n        if(_ownerOf[_tokenId] != address(0)) revert();\\r\\n        this.transferFrom(DEFAULT_OWNER, msg.sender, _tokenId);\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 _tokenId) public view returns(address _owner) {\\r\\n        _owner = _ownerOf[_tokenId];\\r\\n        if(_owner == address(0)) _owner = DEFAULT_OWNER;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 _tokenId) public pure returns (string memory _uri) {\\r\\n        string memory _tokenString = _toString(_tokenId);\\r\\n        string memory _svgString = Base64.encode(bytes(string.concat('<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" preserveAspectRatio=\\\"xMidYMin slice\\\" viewBox=\\\"0 0 728 400\\\"><path d=\\\"M0 0h728v400H0z\\\" fill=\\\"white\\\" /><defs><path id=\\\"curve\\\" d=\\\"m 363.32001,203.97319 c 3.64959,3.6496 -3.11901,6.72017 -6.06587,6.06587 -7.98584,-1.77311 -9.26961,-12.00196 -6.06587,-18.19761 5.73073,-11.08257 20.6122,-12.38089 30.32935,-6.06587 14.26032,9.26756 15.58439,29.33925 6.06586,42.4611 -12.6867,17.48936 -38.10776,18.82717 -54.59283,6.06585 -20.74479,-16.05881 -22.09029,-46.89603 -6.06585,-66.72457 19.40773,-24.01503 55.69543,-25.36517 78.85631,-6.06585 27.2943,22.74358 28.64744,64.50177 6.06585,90.98806 -26.07135,30.57946 -73.31275,31.93464 -103.1198,6.06584 -33.86866,-29.39378 -35.22529,-82.12698 -6.06584,-115.25154 32.7125,-37.16075 90.94358,-38.51845 127.38328,-6.06584 40.45497,36.02855 41.81347,99.76197 6.06583,139.51502 -39.3426,43.75082 -108.58173,45.10994 -151.64676,6.06583 -47.04792,-42.65512 -48.40753,-117.40258 -6.06582,-163.7785 45.96644,-50.346019 126.2243,-51.706017 175.91024,-6.06582 53.64492,49.27682 55.00524,135.04673 6.06582,188.04198 -52.58642,56.94449 -143.86976,58.30507 -200.17373,6.06582 C 199.9556,251.19757 198.5948,154.3997 254.13437,94.787494 313.33819,31.24235 415.65155,29.881364 478.57158,88.721685 532.16254,138.83784 545.45065,220.64134 512.35921,285.79363\\\" /></defs><text font-family=\\\"monospace\\\" font-size=\\\"20\\\" fill=\\\"black\\\"><textPath id=\\\"text\\\" xlink:href=\\\"#curve\\\">', _tokenString, '</textPath></text></svg>')));\\r\\n        _uri = string.concat(\\\"data:application/json,\\\",'{\\\"name\\\": \\\"The Most Tokens Ever - ', _tokenString, '\\\",\\\"description\\\": \\\"The most tokens ever minted on one single Ethereum contract. Ever.\\\",\\\"image_data\\\":\\\"data:image/svg+xml;base64,',_svgString,'\\\"}');\\r\\n    }\\r\\n\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata) public payable {\\r\\n        transferFrom(_from, _to, _tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable {\\r\\n        transferFrom(_from, _to, _tokenId);\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\\r\\n        if(_to == address(0)) revert();\\r\\n        _from = _validate(msg.sender, _from, _tokenId);\\r\\n\\r\\n        if(_from != _to) {\\r\\n            uint256 toBalance = balanceOf[_to];\\r\\n            if(toBalance == type(uint256).max) revert();\\r\\n            uint256 fromBalance = balanceOf[_from];\\r\\n\\r\\n            unchecked {\\r\\n                ++toBalance;\\r\\n                --fromBalance;\\r\\n            }\\r\\n\\r\\n            balanceOf[_to] = toBalance;\\r\\n            balanceOf[_from] = fromBalance;\\r\\n            _ownerOf[_tokenId] = _to;\\r\\n\\r\\n            if(getApproved[_tokenId] != address(0)) {\\r\\n                getApproved[_tokenId] = address(0);\\r\\n                emit Approval(_to, address(0), _tokenId);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(_from, _to, _tokenId);\\r\\n    }\\r\\n\\r\\n    function approve(address _approved, uint256 _tokenId) public payable {\\r\\n        require(msg.sender == _ownerOf[_tokenId]);\\r\\n        getApproved[_tokenId] = _approved;\\r\\n        emit Approval(msg.sender, _approved, _tokenId);\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address _operator, bool _approved) public payable {\\r\\n        isApprovedForAll[msg.sender][_operator] = _approved;\\r\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n    }\\r\\n\\r\\n    function withdraw() public payable {\\r\\n        (bool success, ) = payable(owner).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n\\r\\n    function _validate(address _operator, address _from, uint256 _tokenId) internal view returns (address _newFrom) {\\r\\n        address _owner = _ownerOf[_tokenId];\\r\\n        if(_owner == address(0)) _owner = DEFAULT_OWNER;\\r\\n        if(msg.sender != _owner) {\\r\\n            if(!isApprovedForAll[_owner][_operator]) {\\r\\n                if(getApproved[_tokenId] != _operator) {\\r\\n                    revert();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(_from != _owner) revert();\\r\\n        _newFrom = _owner;\\r\\n    }\\r\\n\\r\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := add(mload(0x40), 0xa0)\\r\\n            mstore(0x40, m)\\r\\n            str := sub(m, 0x20)\\r\\n            mstore(str, 0)\\r\\n            let end := str\\r\\n\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := sub(str, 1)\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Library to encode strings in Base64.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\r\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\r\\nlibrary Base64 {\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\r\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\r\\n    /// @param noPadding Whether to strip away the padding.\\r\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let dataLength := mload(data)\\r\\n\\r\\n            if dataLength {\\r\\n                // Multiply by 4/3 rounded up.\\r\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\r\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\r\\n\\r\\n                // Set `result` to point to the start of the free memory.\\r\\n                result := mload(0x40)\\r\\n\\r\\n                // Store the table into the scratch space.\\r\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\r\\n                // We will rewrite the free memory pointer at `0x40` later with\\r\\n                // the allocated size.\\r\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\r\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\r\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\r\\n\\r\\n                // Skip the first slot, which stores the length.\\r\\n                let ptr := add(result, 0x20)\\r\\n                let end := add(ptr, encodedLength)\\r\\n\\r\\n                // Run over the input, 3 bytes at a time.\\r\\n                for {} 1 {} {\\r\\n                    data := add(data, 3) // Advance 3 bytes.\\r\\n                    let input := mload(data)\\r\\n\\r\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\r\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\r\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\r\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\r\\n                    mstore8(3, mload(and(input, 0x3F)))\\r\\n                    mstore(ptr, mload(0x00))\\r\\n\\r\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\r\\n                    if iszero(lt(ptr, end)) { break }\\r\\n                }\\r\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\r\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\r\\n                let o := div(2, mod(dataLength, 3))\\r\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\r\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\r\\n                // Set `o` to zero if there is padding.\\r\\n                o := mul(iszero(iszero(noPadding)), o)\\r\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\r\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// Equivalent to `encode(data, false, false)`.\\r\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\r\\n        result = encode(data, false, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\r\\n    function encode(bytes memory data, bool fileSafe)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        result = encode(data, fileSafe, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Decodes base64 encoded `data`.\\r\\n    ///\\r\\n    /// Supports:\\r\\n    /// - RFC 4648 (both standard and file-safe mode).\\r\\n    /// - RFC 3501 (63: ',').\\r\\n    ///\\r\\n    /// Does not support:\\r\\n    /// - Line breaks.\\r\\n    ///\\r\\n    /// Note: For performance reasons,\\r\\n    /// this function will NOT revert on invalid `data` inputs.\\r\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\r\\n    /// It is the user's responsibility to ensure that the `data`\\r\\n    /// is a valid base64 encoded string.\\r\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let dataLength := mload(data)\\r\\n\\r\\n            if dataLength {\\r\\n                let decodedLength := mul(shr(2, dataLength), 3)\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // If padded.\\r\\n                    if iszero(and(dataLength, 3)) {\\r\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\r\\n                        // forgefmt: disable-next-item\\r\\n                        decodedLength := sub(\\r\\n                            decodedLength,\\r\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\r\\n                        )\\r\\n                        break\\r\\n                    }\\r\\n                    // If non-padded.\\r\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\r\\n                    break\\r\\n                }\\r\\n                result := mload(0x40)\\r\\n\\r\\n                // Write the length of the bytes.\\r\\n                mstore(result, decodedLength)\\r\\n\\r\\n                // Skip the first slot, which stores the length.\\r\\n                let ptr := add(result, 0x20)\\r\\n                let end := add(ptr, decodedLength)\\r\\n\\r\\n                // Load the table into the scratch space.\\r\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\r\\n                // `m` also doubles as the mask of the upper 6 bits.\\r\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\r\\n                mstore(0x5b, m)\\r\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\r\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // Read 4 bytes.\\r\\n                    data := add(data, 4)\\r\\n                    let input := mload(data)\\r\\n\\r\\n                    // Write 3 bytes.\\r\\n                    // forgefmt: disable-next-item\\r\\n                    mstore(ptr, or(\\r\\n                        and(m, mload(byte(28, input))),\\r\\n                        shr(6, or(\\r\\n                            and(m, mload(byte(29, input))),\\r\\n                            shr(6, or(\\r\\n                                and(m, mload(byte(30, input))),\\r\\n                                shr(6, mload(byte(31, input)))\\r\\n                            ))\\r\\n                        ))\\r\\n                    ))\\r\\n                    ptr := add(ptr, 3)\\r\\n                    if iszero(lt(ptr, end)) { break }\\r\\n                }\\r\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\r\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\r\\n                mstore(0x60, 0) // Restore the zero slot.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"interfaces/IERC721.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IERC721 {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`'s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external payable;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "TheMostTokensEver", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "50000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}