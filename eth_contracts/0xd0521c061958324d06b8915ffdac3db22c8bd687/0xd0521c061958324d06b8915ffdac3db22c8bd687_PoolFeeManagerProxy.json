{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"convex-platform/contracts/contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\n\\ninterface ICurveGauge {\\n    function deposit(uint256) external;\\n    function balanceOf(address) external view returns (uint256);\\n    function withdraw(uint256) external;\\n    function claim_rewards() external;\\n    function reward_tokens(uint256) external view returns(address);//v2\\n    function rewarded_token() external view returns(address);//v1\\n    function lp_token() external view returns(address);\\n}\\n\\ninterface ICurveVoteEscrow {\\n    function create_lock(uint256, uint256) external;\\n    function increase_amount(uint256) external;\\n    function increase_unlock_time(uint256) external;\\n    function withdraw() external;\\n    function smart_wallet_checker() external view returns (address);\\n    function commit_smart_wallet_checker(address) external;\\n    function apply_smart_wallet_checker() external;\\n}\\n\\ninterface IWalletChecker {\\n    function check(address) external view returns (bool);\\n    function approveWallet(address) external;\\n    function dao() external view returns (address);\\n}\\n\\ninterface IVoting{\\n    function vote(uint256, bool, bool) external; //voteId, support, executeIfDecided\\n    function getVote(uint256) external view returns(bool,bool,uint64,uint64,uint64,uint64,uint256,uint256,uint256,bytes memory); \\n    function vote_for_gauge_weights(address,uint256) external;\\n}\\n\\ninterface IMinter{\\n    function mint(address) external;\\n}\\n\\ninterface IStaker{\\n    function deposit(address, address) external returns (bool);\\n    function withdraw(address) external returns (uint256);\\n    function withdraw(address, address, uint256) external returns (bool);\\n    function withdrawAll(address, address) external returns (bool);\\n    function createLock(uint256, uint256) external returns(bool);\\n    function increaseAmount(uint256) external returns(bool);\\n    function increaseTime(uint256) external returns(bool);\\n    function release() external returns(bool);\\n    function claimCrv(address) external returns (uint256);\\n    function claimRewards(address) external returns(bool);\\n    function claimFees(address,address) external returns (uint256);\\n    function setStashAccess(address, bool) external returns (bool);\\n    function vote(uint256,address,bool) external returns(bool);\\n    function voteGaugeWeight(address,uint256) external returns(bool);\\n    function balanceOfPool(address) external view returns (uint256);\\n    function operator() external view returns (address);\\n    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);\\n    function setVote(bytes32 hash, bool valid) external;\\n    function migrate(address to) external;\\n}\\n\\ninterface IRewards{\\n    function stake(address, uint256) external;\\n    function stakeFor(address, uint256) external;\\n    function withdraw(address, uint256) external;\\n    function exit(address) external;\\n    function getReward(address) external;\\n    function queueNewRewards(uint256) external;\\n    function notifyRewardAmount(uint256) external;\\n    function addExtraReward(address) external;\\n    function extraRewardsLength() external view returns (uint256);\\n    function stakingToken() external view returns (address);\\n    function rewardToken() external view returns(address);\\n    function earned(address account) external view returns (uint256);\\n}\\n\\ninterface IStash{\\n    function stashRewards() external returns (bool);\\n    function processStash() external returns (bool);\\n    function claimRewards() external returns (bool);\\n    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rewardFactory) external;\\n    function setExtraReward(address) external;\\n}\\n\\ninterface IFeeDistributor {\\n    function claimToken(address user, address token) external returns (uint256);\\n    function claimTokens(address user, address[] calldata tokens) external returns (uint256[] memory);\\n    function getTokenTimeCursor(address token) external view returns (uint256);\\n}\\n\\ninterface ITokenMinter{\\n    function mint(address,uint256) external;\\n    function burn(address,uint256) external;\\n}\\n\\ninterface IDeposit{\\n    function isShutdown() external view returns(bool);\\n    function balanceOf(address _account) external view returns(uint256);\\n    function totalSupply() external view returns(uint256);\\n    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);\\n    function rewardClaimed(uint256,address,uint256) external;\\n    function withdrawTo(uint256,uint256,address) external;\\n    function claimRewards(uint256,address) external returns(bool);\\n    function rewardArbitrator() external returns(address);\\n    function setGaugeRedirect(uint256 _pid) external returns(bool);\\n    function owner() external returns(address);\\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);\\n}\\n\\ninterface ICrvDeposit{\\n    function deposit(uint256, bool) external;\\n    function lockIncentive() external view returns(uint256);\\n}\\n\\ninterface IRewardFactory{\\n    function setAccess(address,bool) external;\\n    function CreateCrvRewards(uint256,address,address) external returns(address);\\n    function CreateTokenRewards(address,address,address) external returns(address);\\n    function activeRewardCount(address) external view returns(uint256);\\n    function addActiveReward(address,uint256) external returns(bool);\\n    function removeActiveReward(address,uint256) external returns(bool);\\n}\\n\\ninterface IStashFactory{\\n    function CreateStash(uint256,address,address,uint256) external returns(address);\\n    function setImplementation(address, address, address) external;\\n}\\n\\ninterface ITokenFactory{\\n    function CreateDepositToken(address) external returns(address);\\n}\\n\\ninterface IPools{\\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);\\n    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);\\n    function shutdownPool(uint256 _pid) external returns(bool);\\n    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);\\n    function poolLength() external view returns (uint256);\\n    function gaugeMap(address) external view returns(bool);\\n    function setPoolManager(address _poolM) external;\\n    function shutdownSystem() external;\\n    function setUsedAddress(address[] memory) external;\\n}\\n\\ninterface IVestedEscrow{\\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external returns(bool);\\n}\\n\\ninterface IRewardDeposit {\\n    function addReward(address, uint256) external;\\n}\\n\\ninterface IBoosterFees {\\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external;\\n    function setTreasury(address _treasury) external;\\n    function setBridgeDelegate(address _bridgeDelegate) external;\\n    function setRewardMultiplier(address _rewardContract, uint256 multiplier) external;\\n}\\ninterface IPoolManager{\\n    function setOperator(address _operator)external;\\n    function setProtectPool(bool _protectAddPool)external;\\n    function addPool(address _gauge) external returns(bool);\\n    function shutdownPool(uint256 _pid) external returns(bool);\\n    function shutdownSystem() external;\\n}\"\r\n    },\r\n    \"convex-platform/contracts/contracts/PoolFeeManagerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./Interfaces.sol\\\";\\n\\n/**\\n * @title   PoolFeeManagerProxy\\n * @author  AuraFinance\\n * @notice  Wraps PoolManagerV4 and Booster Fee Manager capabilites\\n *           It allows to add pools and set their reward multiplier.\\n */\\ncontract PoolFeeManagerProxy {\\n    address public immutable poolManager;\\n    address public immutable booster;\\n    address public operator;\\n\\n    bool public protectAddPool;\\n\\n    /// @dev The value must be within the allowed range on Booster contract.\\n    uint256 public defaultRewardMultiplier;\\n    /// @dev Same value as Booster.REWARD_MULTIPLIER_DENOMINATOR\\n    uint256 public constant REWARD_MULTIPLIER_DENOMINATOR = 10000;\\n\\n    event DefaultRewardMultiplierUpdated(uint256 newRewardMultiplier);\\n\\n    /**\\n     * @param _poolManager      Currently PoolManagerV4\\n     * @param _booster          Booster address\\n     * @param _operator         Convex multisig\\n     */\\n    constructor(\\n        address _poolManager,\\n        address _booster,\\n        address _operator\\n    ) public {\\n        poolManager = _poolManager;\\n        booster = _booster;\\n        operator = _operator;\\n        protectAddPool = true;\\n    }\\n\\n    //-------------------------------------//\\n    //---------- PoolManagerV4 ------------//\\n    //-------------------------------------//\\n    function setPoolManagerOperator(address _operator) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        IPoolManager(poolManager).setOperator(_operator);\\n    }\\n\\n    function setOperator(address _operator) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        operator = _operator;\\n    }\\n\\n    /**\\n     * @notice set if addPool is only callable by operator\\n     */\\n    function setProtectPool(bool _protectAddPool) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        protectAddPool = _protectAddPool;\\n    }\\n\\n    /**\\n     * @notice Add a new curve pool to the system. (default stash to v3)\\n     */\\n    function addPool(address _gauge) external returns (bool) {\\n        uint256 pid = IPools(booster).poolLength();\\n        _addPool(_gauge);\\n        (, , , address crvRewards, , ) = IPools(booster).poolInfo(pid);\\n        _setRewardMultiplier(crvRewards, defaultRewardMultiplier);\\n        return true;\\n    }\\n\\n    function _addPool(address _gauge) internal returns (bool) {\\n        if (protectAddPool) {\\n            require(msg.sender == operator, \\\"!auth\\\");\\n        }\\n        //get lp token from gauge\\n        return IPoolManager(poolManager).addPool(_gauge);\\n    }\\n\\n    function shutdownPool(uint256 _pid) external returns (bool) {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n\\n        return IPoolManager(poolManager).shutdownPool(_pid);\\n    }\\n\\n    //shutdown pool management and disallow new pools. change is immutable\\n    function shutdownSystem() external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        return IPoolManager(poolManager).shutdownSystem();\\n    }\\n\\n    //----------------------------------//\\n    //---------- Fee Manager------------//\\n    //----------------------------------//\\n    function _setRewardMultiplier(\\n        address _rewardContract,\\n        uint256 multiplier\\n    ) internal {\\n        IBoosterFees(booster).setRewardMultiplier(_rewardContract, multiplier);\\n    }\\n    function setDefaultRewardMultiplier(uint256 multiplier) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        require(multiplier <= REWARD_MULTIPLIER_DENOMINATOR * 2, \\\"too high\\\");\\n\\n        defaultRewardMultiplier = multiplier;\\n        emit DefaultRewardMultiplierUpdated(multiplier);\\n    }\\n\\n    function setFees(\\n        uint256 _lockFees,\\n        uint256 _stakerFees,\\n        uint256 _callerFees,\\n        uint256 _platform\\n    ) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        IBoosterFees(booster).setFees(\\n            _lockFees,\\n            _stakerFees,\\n            _callerFees,\\n            _platform\\n        );\\n    }\\n    function setTreasury(address _treasury) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        IBoosterFees(booster).setTreasury(_treasury);\\n    }\\n    function setBridgeDelegate(address _bridgeDelegate) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        IBoosterFees(booster).setBridgeDelegate(_bridgeDelegate);\\n    }\\n    function setRewardMultiplier(\\n        address _rewardContract,\\n        uint256 _multiplier\\n    ) external {\\n        require(msg.sender == operator, \\\"!auth\\\");\\n        _setRewardMultiplier(_rewardContract, _multiplier);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_booster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRewardMultiplier\",\"type\":\"uint256\"}],\"name\":\"DefaultRewardMultiplierUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REWARD_MULTIPLIER_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"booster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protectAddPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridgeDelegate\",\"type\":\"address\"}],\"name\":\"setBridgeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"setDefaultRewardMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakerFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_callerFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_platform\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setPoolManagerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_protectAddPool\",\"type\":\"bool\"}],\"name\":\"setProtectPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"setRewardMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"shutdownPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdownSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolFeeManagerProxy", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008dd8cdb1f3d419ccdcbf4388bc05f4a7c8aebd64000000000000000000000000a57b8d98dae62b26ec3bcc4a365338157060b2340000000000000000000000005452e6abbc7bcb9e0907a3f8f24434cbaf438ba4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}