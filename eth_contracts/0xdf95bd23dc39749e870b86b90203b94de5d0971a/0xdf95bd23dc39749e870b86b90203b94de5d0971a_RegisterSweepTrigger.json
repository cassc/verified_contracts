{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/triggers/RegisterSweep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\nimport {CannotSetNullAddress} from '@floor/utils/Errors.sol';\\nimport {EpochManaged} from '@floor/utils/EpochManaged.sol';\\n\\nimport {IBaseStrategy} from '@floor-interfaces/strategies/BaseStrategy.sol';\\nimport {IStrategyFactory} from '@floor-interfaces/strategies/StrategyFactory.sol';\\nimport {IEpochEndTriggered} from '@floor-interfaces/utils/EpochEndTriggered.sol';\\nimport {INewCollectionWars} from '@floor-interfaces/voting/NewCollectionWars.sol';\\nimport {ISweepWars} from '@floor-interfaces/voting/SweepWars.sol';\\nimport {ITreasury, TreasuryEnums} from '@floor-interfaces/Treasury.sol';\\n\\n/**\\n * If the current epoch is a Collection Addition, then the floor war is ended and the\\n * winning collection is chosen. The losing collections are released to be claimed, but\\n * the winning collection remains locked for an additional epoch to allow the DAO to\\n * exercise the option(s).\\n *\\n * If the current epoch is just a gauge vote, then we look at the top voted collections\\n * and calculates the distribution of yield to each of them based on the vote amounts. This\\n * yield is then allocated to a Sweep structure that can be executed by the {Treasury}\\n * at a later date.\\n *\\n * @dev Requires `TREASURY_MANAGER` role.\\n * @dev Requires `COLLECTION_MANAGER` role.\\n */\\ncontract RegisterSweepTrigger is EpochManaged, IEpochEndTriggered {\\n    /// Holds our internal contract references\\n    INewCollectionWars public immutable newCollectionWars;\\n    ISweepWars public immutable voteContract;\\n    ITreasury public immutable treasury;\\n    IStrategyFactory public immutable strategyFactory;\\n\\n    /// Stores yield generated in the epoch for temporary held calculations\\n    mapping(address => uint) private _yield;\\n\\n    /// Temp. stores our epoch tokens that have generated yield\\n    address[] private _epochTokens;\\n\\n    /**\\n     * Define our required contracts.\\n     */\\n    constructor(address _newCollectionWars, address _strategyFactory, address _treasury, address _voteContract) {\\n        if (_newCollectionWars == address(0) || _strategyFactory == address(0) ||\\n            _treasury == address(0) || _voteContract == address(0)) {\\n            revert CannotSetNullAddress();\\n        }\\n\\n        newCollectionWars = INewCollectionWars(_newCollectionWars);\\n        strategyFactory = IStrategyFactory(_strategyFactory);\\n        treasury = ITreasury(_treasury);\\n        voteContract = ISweepWars(_voteContract);\\n    }\\n\\n    /**\\n     * When our epoch ends, we need to find the tokens yielded from each strategy, as well as\\n     * the respective amounts.\\n     */\\n    function endEpoch(uint epoch) external onlyEpochManager {\\n\\n        // Capture the amount of ETH / WETH rewards from our strategies\\n        (,, uint ethRewards) = strategyFactory.snapshot(epoch);\\n\\n        // We want the ability to set a minimum sweep amount, so that when we are first\\n        // starting out the sweeps aren't pathetic.\\n        uint minSweepAmount = treasury.minSweepAmount();\\n        if (ethRewards < minSweepAmount) {\\n            ethRewards = minSweepAmount;\\n        }\\n\\n        // If we are currently looking at a new collection addition, rather than a gauge weight\\n        // vote, then we can bypass additional logic and just end of Floor War.\\n        if (epochManager.isCollectionAdditionEpoch(epoch)) {\\n            // At this point we still need to calculate yield, but just attribute it to\\n            // the winner of the Floor War instead. This will be allocated the full yield\\n            // amount. Format the collection and amount into the array format that our\\n            // sweep registration is expecting.\\n            address[] memory tokens = new address[](1);\\n            tokens[0] = newCollectionWars.endFloorWar();\\n\\n            // Allocate the full yield rewards into the single collection\\n            uint[] memory amounts = new uint[](1);\\n            amounts[0] = ethRewards;\\n\\n            // Now that we have the results of the new collection addition we can register them\\n            // against our a pending sweep. This will need to be assigned a \\\"sweep type\\\" to show\\n            // that it is a Floor War and that we can additionally include \\\"mercenary sweep\\n            // amounts\\\" in the call.\\n            treasury.registerSweep(epoch, tokens, amounts, TreasuryEnums.SweepType.COLLECTION_ADDITION);\\n        } else {\\n            // Process the snapshot to find the floor war collection winners and the allocated amount\\n            // of the sweep.\\n            (address[] memory snapshotTokens, uint[] memory snapshotAmounts) = voteContract.snapshot(ethRewards);\\n\\n            // We can now remove yield from our collections based on the yield that they generated\\n            // in the previous epoch.\\n            unchecked {\\n                // The linked mathematical operation is guaranteed to be performed safely by surrounding\\n                // conditionals evaluated in either require checks or if-else constructs.\\n                for (uint i; i < snapshotTokens.length; ++i) {\\n                    snapshotAmounts[i] = (snapshotAmounts[i] > _yield[snapshotTokens[i]]) ? snapshotAmounts[i] - _yield[snapshotTokens[i]] : 0;\\n                }\\n            }\\n\\n            // Now that we have the results of the snapshot we can register them against our\\n            // pending sweeps.\\n            treasury.registerSweep(epoch, snapshotTokens, snapshotAmounts, TreasuryEnums.SweepType.SWEEP);\\n        }\\n\\n        // Reset our yield monitoring\\n        for (uint i; i < _epochTokens.length;) {\\n            delete _yield[_epochTokens[i]];\\n            unchecked { ++i; }\\n        }\\n\\n        delete _epochTokens;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * A collection of generic errors that can be referenced across multiple\\n * contracts. Contract-specific errors should still be stored in their\\n * individual Solidity files.\\n */\\n\\n/// If a NULL address tries to be stored which should not be accepted\\nerror CannotSetNullAddress();\\n\\n/// If the caller has entered an insufficient amount to process the action. This\\n/// will likely be a zero amount.\\nerror InsufficientAmount();\\n\\n/// If the caller enters a percentage value that is too high for the requirements\\nerror PercentageTooHigh(uint amount);\\n\\n/// If a required ETH or token `transfer` call fails\\nerror TransferFailed();\\n\\n/// If a user calls a deposit related function with a zero amount\\nerror CannotDepositZeroAmount();\\n\\n/// If a user calls a withdrawal related function with a zero amount\\nerror CannotWithdrawZeroAmount();\\n\\n/// If there are no rewards available to be claimed\\nerror NoRewardsAvailableToClaim();\\n\\n/// If the requested collection is not approved\\n/// @param collection Address of the collection requested\\nerror CollectionNotApproved(address collection);\\n\\n/// If the requested strategy implementation is not approved\\n/// @param strategyImplementation Address of the strategy implementation requested\\nerror StrategyNotApproved(address strategyImplementation);\\n\"\r\n    },\r\n    \"src/contracts/utils/EpochManaged.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\nimport {CannotSetNullAddress} from '@floor/utils/Errors.sol';\\n\\nimport {IEpochManager} from '@floor-interfaces/EpochManager.sol';\\n\\nabstract contract EpochManaged is Ownable {\\n    /// Emits when {EpochManager} is updated\\n    event EpochManagerUpdated(address epochManager);\\n\\n    /// Stores the current {EpochManager} contract\\n    IEpochManager public epochManager;\\n\\n    /**\\n     * Allows an updated {EpochManager} address to be set.\\n     */\\n    function setEpochManager(address _epochManager) external virtual onlyOwner {\\n        _setEpochManager(_epochManager);\\n    }\\n\\n    /**\\n     * Allows an updated {EpochManager} address to be set by an inheriting contract.\\n     */\\n    function _setEpochManager(address _epochManager) internal virtual {\\n        if (_epochManager == address(0)) revert CannotSetNullAddress();\\n        epochManager = IEpochManager(_epochManager);\\n        emit EpochManagerUpdated(_epochManager);\\n    }\\n\\n    /**\\n     * Gets the current epoch from our {EpochManager}.\\n     */\\n    function currentEpoch() internal view virtual returns (uint) {\\n        return epochManager.currentEpoch();\\n    }\\n\\n    /**\\n     * Checks that the contract caller is the {EpochManager}.\\n     */\\n    modifier onlyEpochManager() {\\n        require(msg.sender == address(epochManager), 'Only EpochManager can call');\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategies/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Strategies will hold the logic for interacting with external platforms to stake\\n * and harvest reward yield. Each strategy will require its own strategy implementation\\n * to allow for different immutable variables to be defined during construct.\\n *\\n * This will follow a similar approach to how NFTX offer their eligibility module\\n * logic, with a lot of the power coming from inheritence.\\n *\\n * When constructed, we want to give the {Treasury} a max uint approval of the yield\\n * and underlying tokens.\\n */\\ninterface IBaseStrategy {\\n    /// @dev When strategy receives a deposit\\n    event Deposit(address token, uint amount, address caller);\\n\\n    /// @dev When strategy is harvested\\n    event Harvest(address token, uint amount);\\n\\n    /// @dev When a staked user exits their position\\n    event Withdraw(address token, uint amount, address recipient);\\n\\n    /**\\n     * Allows the strategy to be initialised.\\n     */\\n    function initialize(bytes32 name, uint strategyId, bytes calldata initData) external;\\n\\n    /**\\n     * Name of the strategy.\\n     */\\n    function name() external view returns (bytes32);\\n\\n    /**\\n     * The numerical ID of the strategy that acts as an index for the {StrategyFactory}.\\n     */\\n    function strategyId() external view returns (uint);\\n\\n    /**\\n     * Total rewards generated by the strategy in all time. This is pure bragging rights.\\n     */\\n    function lifetimeRewards(address token) external returns (uint amount_);\\n\\n    /**\\n     * The amount of rewards claimed in the last claim call.\\n     */\\n    function lastEpochRewards(address token) external returns (uint amount_);\\n\\n    /**\\n     * Gets rewards that are available to harvest.\\n     */\\n    function available() external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Extracts all rewards from third party and moves it to a recipient. This should\\n     * only be called by a specific action.\\n     *\\n     * @dev This _should_ always be imposed to be the {Treasury} by the {StrategyFactory}.\\n     */\\n    function harvest(address /* _recipient */ ) external;\\n\\n    /**\\n     * Returns an array of tokens that the strategy supports.\\n     *\\n     * @return address[] The address of valid tokens\\n     */\\n    function validTokens() external view returns (address[] memory);\\n\\n    /**\\n     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.\\n     *\\n     * @param recipient Strategy address to be updated\\n     * @param percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)\\n     *\\n     * @return address[] Array of tokens withdrawn\\n     * @return uint[] Amounts of respective tokens withdrawn\\n     */\\n    function withdrawPercentage(address recipient, uint percentage) external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Pauses deposits from being made into the strategy. This should only be called by\\n     * a guardian or governor.\\n     *\\n     * @param _p Boolean value for if the strategy should be paused\\n     */\\n    function pause(bool _p) external;\\n\\n    /**\\n     * Gets a read of new yield since the last call. This is what can be called when\\n     * the epoch ends to determine the amount generated within the epoch.\\n     */\\n    function snapshot() external returns (address[] memory, uint[] memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategies/StrategyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Allows for strategies to be created, pairing them with a {Strategy} and an approved\\n * collection. The strategy creation script needs to be as highly optimised as possible\\n * to ensure that the gas costs are kept down.\\n *\\n * This factory will keep an index of created strategies and secondary information to ensure\\n * that external applications can display and maintain a list of available strategies.\\n *\\n * The contract can be paused to prevent the creation of new strategies.\\n */\\n\\ninterface IStrategyFactory {\\n    /// @dev Sent when a strategy is created successfully\\n    event StrategyCreated(uint indexed strategyId, address strategyAddress, address assetAddress);\\n\\n    /// @dev Sent when a snapshot is taken\\n    event StrategySnapshot(uint epoch, address[] tokens, uint[] amounts);\\n\\n    /// @dev Sent when the Treasury address is updated\\n    event TreasuryUpdated(address treasury);\\n\\n    /**\\n     * Our stored {Treasury} address.\\n     */\\n    function treasury() external view returns (address);\\n\\n    /**\\n     * Provides a list of all strategies created.\\n     *\\n     * @return Array of all strategies created by the {StrategyFactory}\\n     */\\n    function strategies() external view returns (address[] memory);\\n\\n    /**\\n     * Returns an array of all strategies that belong to a specific collection.\\n     */\\n    function collectionStrategies(address _collection) external view returns (address[] memory);\\n\\n    /**\\n     * Provides a strategy against the provided `strategyId` (index). If the index does not exist,\\n     * then address(0) will be returned.\\n     *\\n     * @param _strategyId ID of the strategy to retrieve\\n     *\\n     * @return Address of the strategy\\n     */\\n    function strategy(uint _strategyId) external view returns (address);\\n\\n    /**\\n     * Creates a strategy with an approved collection.\\n     *\\n     * @dev The strategy is not created using Clones as there are complications when allocated\\n     * roles and permissions.\\n     *\\n     * @param _name Human-readable name of the strategy\\n     * @param _strategy The strategy implemented by the strategy\\n     * @param _strategyInitData Bytes data required by the {Strategy} for initialization\\n     * @param _collection The address of the collection attached to the strategy\\n     *\\n     * @return strategyId_ ID of the newly created strategy\\n     * @return strategyAddr_ Address of the newly created strategy\\n     */\\n    function deployStrategy(bytes32 _name, address _strategy, bytes calldata _strategyInitData, address _collection)\\n        external\\n        returns (uint strategyId_, address strategyAddr_);\\n\\n    /**\\n     * Allows individual strategies to be paused, meaning that assets can no longer be deposited,\\n     * although staked assets can always be withdrawn.\\n     *\\n     * @dev Events are fired within the strategy to allow listeners to update.\\n     *\\n     * @param _strategyId Strategy ID to be paused\\n     * @param _paused If the strategy should be paused or unpaused\\n     */\\n    function pause(uint _strategyId, bool _paused) external;\\n\\n    /**\\n     * Reads the yield generated by a strategy since the last time that this function was called.\\n     *\\n     * @param _epoch The current epoch being snapshotted\\n     *\\n     * @return tokens Tokens that have been generated as yield\\n     * @return amounts The amount of yield generated for the corresponding token\\n     */\\n    function snapshot(uint _epoch) external returns (address[] memory tokens, uint[] memory amounts, uint totalAmount);\\n\\n    /**\\n     * Harvest available reward yield from the strategy. This won't affect the amount\\n     * depositted into the contract and should only harvest rewards directly into the\\n     * {Treasury}.\\n     *\\n     * @param _strategyId Strategy ID to be harvested\\n     */\\n    function harvest(uint _strategyId) external;\\n\\n    /**\\n     * Makes a call to a strategy withdraw function by passing the strategy ID and\\n     * `abi.encodeWithSelector` to build the bytes `_data` parameter. This will then\\n     * pass the data on to the strategy function and inject the treasury recipient\\n     * address within the call as the first function parameter.\\n     *\\n     * @dev It is required for the transaction to return a successful call, otherwise\\n     * the transaction will be reverted. The error response will be standardised so\\n     * debugging will require a trace, rather than just the end message.\\n     *\\n     * @param _strategyId Strategy ID to be withdrawn from\\n     * @param _data Strategy withdraw function call, using `encodeWithSelector`\\n     */\\n    function withdraw(uint _strategyId, bytes calldata _data) external;\\n\\n    /**\\n     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.\\n     *\\n     * @param _strategy Strategy address to be updated\\n     * @param _percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)\\n     */\\n    function withdrawPercentage(address _strategy, uint _percentage) external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Allows the {Treasury} contract address to be updated. All withdrawals will\\n     * be requested to be sent to this address when the `withdraw` is called.\\n     *\\n     * @dev This address is dynamically injected into the subsequent strategy\\n     * withdraw call.\\n     *\\n     * @param _treasury The new {Treasury} contract address\\n     */\\n    function setTreasury(address _treasury) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/utils/EpochEndTriggered.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IEpochEndTriggered {\\n    /**\\n     * Function that is triggered when an epoch ends.\\n     */\\n    function endEpoch(uint epoch) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/voting/NewCollectionWars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INewCollectionWars {\\n    /**\\n     * For each FloorWar that is created, this structure will be created. When\\n     * the epoch ends, the FloorWar will remain and will be updated with information\\n     * on the winning collection and the votes attributed to each collection.\\n     */\\n    struct FloorWar {\\n        uint index;\\n        uint startEpoch;\\n        address[] collections;\\n    }\\n\\n    /// Sent when a user casts a vote\\n    event VoteCast(address sender, address collection, uint userVotes, uint collectionVotes);\\n\\n    /// Sent when a collection vote is revoked\\n    event VoteRevoked(address sender, address collection, uint collectionVotes);\\n\\n    /// Sent when a collection NFT is staked to vote\\n    event NftVoteCast(address sender, uint war, address collection, uint collectionVotes, uint collectionNftVotes);\\n\\n    /// Sent when a Collection Addition War is created\\n    event CollectionAdditionWarCreated(uint epoch, address[] collections, uint[] floorPrices);\\n\\n    /// Sent when a Collection Addition War is started\\n    event CollectionAdditionWarStarted(uint warIndex);\\n\\n    /// Sent when a Collection Addition War ends\\n    event CollectionAdditionWarEnded(uint warIndex, address collection);\\n\\n    /// Sent when Collection Addition War NFTs are exercised\\n    event CollectionExercised(uint warIndex, address collection, uint value);\\n\\n    /// Sent when the {NewCollectionWarOptions} contract address is updated\\n    event NewCollectionWarOptionsUpdated(address newCollectionWarOptions);\\n\\n    /// Stores the number of votes a user has placed against a war collection\\n    function userVotes(bytes32) external view returns (uint);\\n\\n    /// Stores the floor spot price of a collection token against a war collection\\n    function collectionSpotPrice(bytes32) external view returns (uint);\\n\\n    /// Stores the total number of votes against a war collection\\n    function collectionVotes(bytes32) external view returns (uint);\\n    function collectionNftVotes(bytes32) external view returns (uint);\\n\\n    /// Stores which collection the user has cast their votes towards to allow for\\n    /// reallocation on subsequent votes if needed.\\n    function userCollectionVote(bytes32) external view returns (address);\\n\\n    /// Stores the address of the collection that won a Floor War\\n    function floorWarWinner(uint _epoch) external view returns (address);\\n\\n    /// Stores if a collection has been flagged as ERC1155\\n    function is1155(address) external returns (bool);\\n\\n    /// Stores the unlock epoch of a collection in a floor war\\n    function collectionEpochLock(bytes32) external returns (uint);\\n\\n    /**\\n     * The total voting power of a user, regardless of if they have cast votes\\n     * or not.\\n     *\\n     * @param _user User address being checked\\n     */\\n    function userVotingPower(address _user) external view returns (uint);\\n\\n    /**\\n     * The total number of votes that a user has available.\\n     *\\n     * @param _user User address being checked\\n     *\\n     * @return uint Number of votes available to the user\\n     */\\n    function userVotesAvailable(uint _war, address _user) external view returns (uint);\\n\\n    /**\\n     * Allows the user to cast 100% of their voting power against an individual\\n     * collection. If the user has already voted on the FloorWar then this will\\n     * additionally reallocate their votes.\\n     */\\n    function vote(address collection) external;\\n\\n    /**\\n     * Allows an approved contract to submit option-related votes against a collection\\n     * in the current war.\\n     *\\n     * @param sender The address of the user that staked the token\\n     * @param collection The collection to cast the vote against\\n     * @param votingPower The voting power added from the option creation\\n     */\\n    function optionVote(address sender, uint war, address collection, uint votingPower) external;\\n\\n    /**\\n     * Revokes a user's current votes in the current war.\\n     *\\n     * @dev This is used when a user unstakes their floor\\n     *\\n     * @param account The address of the account that is having their vote revoked\\n     */\\n    function revokeVotes(address account) external;\\n\\n    /**\\n     * Allow an authorised user to create a new floor war to start with a range of\\n     * collections from a specific epoch.\\n     */\\n    function createFloorWar(uint epoch, address[] calldata collections, bool[] calldata isErc1155, uint[] calldata floorPrices)\\n        external\\n        returns (uint);\\n\\n    /**\\n     * Sets a scheduled {FloorWar} to be active.\\n     *\\n     * @dev This function is called by the {EpochManager} when a new epoch starts\\n     *\\n     * @param index The index of the {FloorWar} being started\\n     */\\n    function startFloorWar(uint index) external;\\n\\n    /**\\n     * When the epoch has come to an end, this function will be called to finalise\\n     * the votes and decide which collection has won. This collection will then need\\n     * to be added to the {CollectionRegistry}.\\n     *\\n     * Any NFTs that have been staked will be timelocked for an additional epoch to\\n     * give the DAO time to exercise or reject any options.\\n     *\\n     * @dev We can't action this in one single call as we will need information about\\n     * the underlying NFTX token as well.\\n     */\\n    function endFloorWar() external returns (address highestVoteCollection);\\n\\n    /**\\n     * Allows us to update our collection floor prices if we have seen a noticable difference\\n     * since the start of the epoch. This will need to be called for this reason as the floor\\n     * price of the collection heavily determines the amount of voting power awarded when\\n     * creating an option.\\n     */\\n    function updateCollectionFloorPrice(address collection, uint floorPrice) external;\\n\\n    /**\\n     * Allows our options contract to be updated.\\n     *\\n     * @param _contract The new contract to use\\n     */\\n    function setOptionsContract(address _contract) external;\\n\\n    /**\\n     * Check if a collection is in a FloorWar.\\n     */\\n    function isCollectionInWar(bytes32 warCollection) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/voting/SweepWars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * The GWV will allow users to assign their veFloor position to a strategy, or\\n * optionally case it to a veFloor, which will use a constant value. As the\\n * strategies will be rendered as an address, the veFloor vote will take a NULL\\n * address value.\\n *\\n * At point of development this can take influence from:\\n * https://github.com/saddle-finance/saddle-contract/blob/master/contracts/tokenomics/gauges/GaugeController.vy\\n */\\ninterface ISweepWars {\\n    /// Sent when a user casts or revokes their vote\\n    event VoteCast(address sender, address collection, int amount);\\n\\n    /// Sent when a user has revoked their vote, or it is revoked on their behalf\\n    event VotesRevoked(address account, address collection, uint forVotesRevoked, uint againstVotesRevoked);\\n\\n    /// Sent when the Sample Size is updated\\n    event SampleSizeUpdated(uint size);\\n\\n    /// Sent when the {NftStaking} contract address is updated\\n    event NftStakingUpdated(address nftStaking);\\n\\n    /**\\n     * Gets the number of votes for a collection at the current epoch.\\n     */\\n    function votes(address) external view returns (int);\\n\\n    /**\\n     * The total voting power of a user, regardless of if they have cast votes\\n     * or not.\\n     */\\n    function userVotingPower(address _user) external view returns (uint);\\n\\n    /**\\n     * The total number of votes that a user has available, calculated by:\\n     *\\n     * ```\\n     * votesAvailable_ = balanceOf(_user) - SUM(userVotes.votes_)\\n     * ```\\n     */\\n    function userVotesAvailable(address _user) external view returns (uint votesAvailable_);\\n\\n    /**\\n     * Provides a list of collection addresses that can be voted on.\\n     */\\n    function voteOptions() external view returns (address[] memory collections_);\\n\\n    /**\\n     * Allows a user to cast a vote using their veFloor allocation. We don't\\n     * need to monitor transfers as veFloor can only be minted or burned, and\\n     * we check the voters balance during the `snapshot` call.\\n     *\\n     * A user can vote with a partial amount of their veFloor holdings, and when\\n     * it comes to calculating their voting power this will need to be taken into\\n     * consideration that it will be:\\n     *\\n     * ```\\n     * staked balance + (gains from staking * (total balance - staked balance)%)\\n     * ```\\n     *\\n     * The {Treasury} cannot vote with it's holdings, as it shouldn't be holding\\n     * any staked Floor.\\n     */\\n    function vote(address _collection, int _amount) external;\\n\\n    /**\\n     * Allows a user to revoke their votes from strategies. This will free up the\\n     * user's available votes that can subsequently be voted again with.\\n     */\\n    function revokeVotes(address[] memory _collection) external;\\n\\n    /**\\n     * Allows an authorised contract or wallet to revoke all user votes. This\\n     * can be called when the veFLOOR balance is reduced.\\n     */\\n    function revokeAllUserVotes(address _account) external;\\n\\n    /**\\n     * The snapshot function will need to iterate over all strategies that have\\n     * more than 0 votes against them. With that we will need to find each\\n     * strategy percentage share in relation to other strategies.\\n     *\\n     * This percentage share will instruct the {Treasury} on how much additional\\n     * FLOOR to allocate to the users staked in the strategies. These rewards will\\n     * become available in the {RewardLedger}.\\n     *\\n     * +----------------+-----------------+-------------------+-------------------+\\n     * | Voter          | veFloor         | Vote Weight       | Strategy          |\\n     * +----------------+-----------------+-------------------+-------------------+\\n     * | Alice          | 30              | 40                | 1                 |\\n     * | Bob            | 20              | 30                | 2                 |\\n     * | Carol          | 40              | 55                | 3                 |\\n     * | Dave           | 20              | 40                | 2                 |\\n     * | Emily          | 25              | 35                | 0                 |\\n     * +----------------+-----------------+-------------------+-------------------+\\n     *\\n     * With the above information, and assuming that the {Treasury} has allocated\\n     * 1000 FLOOR tokens to be additionally distributed in this snapshot, we would\\n     * have the following allocations going to the strategies.\\n     *\\n     * +----------------+-----------------+-------------------+-------------------+\\n     * | Strategy       | Votes Total     | Vote Percent      | veFloor Rewards   |\\n     * +----------------+-----------------+-------------------+-------------------+\\n     * | 0 (veFloor)    | 35              | 17.5%             | 175               |\\n     * | 1              | 40              | 20%               | 200               |\\n     * | 2              | 70              | 35%               | 350               |\\n     * | 3              | 55              | 27.5%             | 275               |\\n     * | 4              | 0               | 0%                | 0                 |\\n     * +----------------+-----------------+-------------------+-------------------+\\n     *\\n     * This would distribute the strategies allocated rewards against the staked\\n     * percentage in the strategy. Any Treasury holdings that would be given in rewards\\n     * are just deposited into the {Treasury} as FLOOR, bypassing the {RewardsLedger}.\\n     */\\n    function snapshot(uint tokens) external returns (address[] memory collections, uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IWETH} from '@floor-interfaces/tokens/WETH.sol';\\n\\n\\nlibrary TreasuryEnums {\\n    /// Different sweep types that can be specified.\\n    enum SweepType {\\n        COLLECTION_ADDITION,\\n        SWEEP\\n    }\\n\\n    /// Different approval types that can be specified.\\n    enum ApprovalType {\\n        NATIVE,\\n        ERC20,\\n        ERC721,\\n        ERC1155\\n    }\\n}\\n\\n/**\\n * @dev The Treasury will hold all assets.\\n */\\ninterface ITreasury {\\n    /// Stores data that allows the Treasury to action a sweep.\\n    struct Sweep {\\n        TreasuryEnums.SweepType sweepType;\\n        address[] collections;\\n        uint[] amounts;\\n        bool completed;\\n        string message;\\n    }\\n\\n    /// The data structure format that will be mapped against to define a token\\n    /// approval request.\\n    struct ActionApproval {\\n        TreasuryEnums.ApprovalType _type; // Token type\\n        address assetContract; // Used by 20, 721 and 1155\\n        address target; // Used by 20, 721 and 1155\\n        uint amount; // Used by native and 20 tokens\\n    }\\n\\n    /// @dev When native network token is withdrawn from the Treasury\\n    event Deposit(uint amount);\\n\\n    /// @dev When an ERC20 is depositted into the Treasury\\n    event DepositERC20(address token, uint amount);\\n\\n    /// @dev When an ERC721 is depositted into the Treasury\\n    event DepositERC721(address token, uint tokenId);\\n\\n    /// @dev When an ERC1155 is depositted into the Treasury\\n    event DepositERC1155(address token, uint tokenId, uint amount);\\n\\n    /// @dev When native network token is withdrawn from the Treasury\\n    event Withdraw(uint amount, address recipient);\\n\\n    /// @dev When an ERC20 token is withdrawn from the Treasury\\n    event WithdrawERC20(address token, uint amount, address recipient);\\n\\n    /// @dev When an ERC721 token is withdrawn from the Treasury\\n    event WithdrawERC721(address token, uint tokenId, address recipient);\\n\\n    /// @dev When an ERC1155 is withdrawn from the Treasury\\n    event WithdrawERC1155(address token, uint tokenId, uint amount, address recipient);\\n\\n    /// @dev When FLOOR is minted\\n    event FloorMinted(uint amount);\\n\\n    /// @dev When a {Treasury} action is processed\\n    event ActionProcessed(address action, bytes data);\\n\\n    /// @dev When a sweep is registered against an epoch\\n    event SweepRegistered(uint sweepEpoch, TreasuryEnums.SweepType sweepType, address[] collections, uint[] amounts);\\n\\n    /// @dev When an action is assigned to a sweep epoch\\n    event SweepAction(uint sweepEpoch);\\n\\n    /// @dev When an epoch is swept\\n    event EpochSwept(uint epochIndex);\\n\\n    /// Emitted when the {MercenarySweeper} contract address is updated\\n    event MercenarySweeperUpdated(address mercSweeper);\\n\\n    /// Emitted when the minimum sweep amount is updated\\n    event MinSweepAmountUpdated(uint minSweepAmount);\\n\\n    /// Emitted when the {VeFloorStaking} contract is updated\\n    event VeFloorStakingUpdated(address veFloorStaking);\\n\\n    /// Emitted when the {StrategyFactory} contract is updated\\n    event StrategyFactoryUpdated(address strategyFactory);\\n\\n    /**\\n     * Our stored WETH address for the {Treasury}\\n     */\\n    function weth() external returns (IWETH);\\n\\n    /**\\n     * Allow FLOOR token to be minted. This should be called from the deposit method\\n     * internally, but a public method will allow a {TreasuryManager} to bypass this\\n     * and create additional FLOOR tokens if needed.\\n     *\\n     * @dev We only want to do this on creation and for inflation. Have a think on how\\n     * we can implement this!\\n     */\\n    function mint(uint amount) external;\\n\\n    /**\\n     * Allows an ERC20 token to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC20(address token, uint amount) external;\\n\\n    /**\\n     * Allows an ERC721 token to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC721(address token, uint tokenId) external;\\n\\n    /**\\n     * Allows an ERC1155 token(s) to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC1155(address token, uint tokenId, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw native token.\\n     */\\n    function withdraw(address recipient, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw and ERC20 token from the Treasury.\\n     */\\n    function withdrawERC20(address recipient, address token, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw and ERC721 token from the Treasury.\\n     */\\n    function withdrawERC721(address recipient, address token, uint tokenId) external;\\n\\n    /**\\n     * Allows an approved user to withdraw an ERC1155 token(s) from the Treasury.\\n     */\\n    function withdrawERC1155(address recipient, address token, uint tokenId, uint amount) external;\\n\\n    /**\\n     * Actions a sweep to be used against a contract that implements {ISweeper}. This\\n     * will fulfill the sweep and we then mark the sweep as completed.\\n     */\\n    function sweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;\\n\\n    /**\\n     * Allows the DAO to resweep an already swept \\\"Sweep\\\" struct, using a contract that\\n     * implements {ISweeper}. This will fulfill the sweep again and keep the sweep marked\\n     * as completed.\\n     */\\n    function resweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;\\n\\n    /**\\n     * When an epoch ends, we have the ability to register a sweep against the {Treasury}\\n     * via an approved contract. This will store a DAO sweep that will need to be actioned\\n     * using the `sweepEpoch` function.\\n     */\\n    function registerSweep(uint epoch, address[] calldata collections, uint[] calldata amounts, TreasuryEnums.SweepType sweepType)\\n        external;\\n\\n    /**\\n     * The minimum sweep amount that can be implemented, or excluded, as desired by the DAO.\\n     */\\n    function minSweepAmount() external returns (uint);\\n\\n    /**\\n     * Allows the mercenary sweeper contract to be updated.\\n     */\\n    function setMercenarySweeper(address _mercSweeper) external;\\n\\n    /**\\n     * Allows us to set a new VeFloorStaking contract that is used when sweeping epochs.\\n     */\\n    function setVeFloorStaking(address _veFloorStaking) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/EpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Handles epoch management for all other contracts.\\n */\\ninterface IEpochManager {\\n\\n    /// Emitted when an epoch is ended\\n    event EpochEnded(uint epoch, uint timestamp);\\n\\n    /// Emitted when a new collection war is scheduled\\n    event CollectionAdditionWarScheduled(uint epoch, uint index);\\n\\n    /// Emitted when required contracts are updated\\n    event EpochManagerContractsUpdated(address newCollectionWars, address voteMarket);\\n\\n    /**\\n     * The current epoch that is running across the codebase.\\n     *\\n     * @return The current epoch\\n     */\\n    function currentEpoch() external view returns (uint);\\n\\n    /**\\n     * Stores a mapping of an epoch to a collection addition war index.\\n     *\\n     * @param _epoch Epoch to check\\n     *\\n     * @return Index of the collection addition war. Will return 0 if none found\\n     */\\n    function collectionEpochs(uint _epoch) external view returns (uint);\\n\\n    /**\\n     * Will return if the current epoch is a collection addition vote.\\n     *\\n     * @return If the current epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch() external view returns (bool);\\n\\n    /**\\n     * Will return if the specified epoch is a collection addition vote.\\n     *\\n     * @param epoch The epoch to check\\n     *\\n     * @return If the specified epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch(uint epoch) external view returns (bool);\\n\\n    /**\\n     * Allows an epoch to be scheduled to be a collection addition vote. An index will\\n     * be specified to show which collection addition will be used. The index will not\\n     * be a zero value.\\n     *\\n     * @param epoch The epoch that the Collection Addition will take place in\\n     * @param index The Collection Addition array index\\n     */\\n    function scheduleCollectionAdditionEpoch(uint epoch, uint index) external;\\n\\n    /**\\n     * Triggers an epoch to end.\\n     *\\n     * @dev More information about this function can be found in the actual contract\\n     */\\n    function endEpoch() external;\\n\\n    /**\\n     * Provides an estimated timestamp of when an epoch started, and also the earliest\\n     * that an epoch in the future could start.\\n     *\\n     * @param _epoch The epoch to find the estimated timestamp of\\n     *\\n     * @return The estimated timestamp of when the specified epoch started\\n     */\\n    function epochIterationTimestamp(uint _epoch) external returns (uint);\\n\\n    /**\\n     * The length of an epoch in seconds.\\n     *\\n     * @return The length of the epoch in seconds\\n     */\\n    function EPOCH_LENGTH() external returns (uint);\\n\\n    /**\\n     * Sets contracts that the epoch manager relies on. This doesn't have to include\\n     * all of the contracts that are {EpochManaged}, but only needs to set ones that the\\n     * {EpochManager} needs to interact with.\\n     */\\n    function setContracts(address _newCollectionWars, address _voteMarket) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IWETH is IERC20 {\\n    function allowance(address, address) external view returns (uint);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function approve(address, uint) external returns (bool);\\n\\n    function transfer(address, uint) external returns (bool);\\n\\n    function transferFrom(address, address, uint) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap-v3/=lib/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@murky/=lib/murky/src/\",\r\n      \"@solidity-math-utils/=lib/solidity-math-utils/project/contracts/\",\r\n      \"@solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"@1inch/=lib/\",\r\n      \"@charmfi/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"@sudoswap/=lib/lssvm/src/\",\r\n      \"@floor/=src/contracts/\",\r\n      \"@floor-interfaces/=src/interfaces/\",\r\n      \"@floor-scripts/=script/\",\r\n      \"@ERC721A/=lib/ERC721A/contracts/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"@nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"@manifoldxyz/=lib/lssvm2/lib/\",\r\n      \"@mocks/=lib/nftx-protocol-v3/src/mocks/\",\r\n      \"@permit2/=lib/nftx-protocol-v3/lib/permit2/src/\",\r\n      \"@prb/math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"@prb/test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"@src/=lib/nftx-protocol-v3/src/\",\r\n      \"@test/=lib/nftx-protocol-v3/test/\",\r\n      \"@uni-core/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"@uni-periphery/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/\",\r\n      \"@uniswap/lib/=lib/nftx-protocol-v3/lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/nftx-protocol-v3/lib/v2-core/\",\r\n      \"@uniswap/v3-core/contracts/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"CramBit/=lib/foundry-random/lib/CramBit/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"base64-sol/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/libraries/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"charmfi-contracts-0.8.0-support/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"clones-with-immutable-args/=lib/lssvm2/lib/clones-with-immutable-args/src/\",\r\n      \"crambit/=lib/foundry-random/lib/CramBit/src/\",\r\n      \"create2-helpers/=lib/lssvm2/lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create3-factory/=lib/lssvm2/lib/create3-factory/\",\r\n      \"foundry-huff/=lib/lssvm2/lib/foundry-huff/src/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"huffmate/=lib/lssvm2/lib/huffmate/src/\",\r\n      \"libraries-solidity/=lib/lssvm2/lib/libraries-solidity/contracts/\",\r\n      \"lssvm/=lib/lssvm/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"manifoldxyz/=lib/lssvm2/lib/royalty-registry-solidity/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-math/=lib/solidity-trigonometry/lib/prb-math/contracts/\",\r\n      \"prb-test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"royalty-registry-solidity.git/=lib/lssvm/lib/royalty-registry-solidity.git/contracts/\",\r\n      \"royalty-registry-solidity/=lib/lssvm2/lib/royalty-registry-solidity/\",\r\n      \"solidity-bytes-utils/=lib/foundry-random/lib/solidity-bytes-utils/contracts/\",\r\n      \"solidity-math-utils/=lib/solidity-math-utils/\",\r\n      \"solidity-stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"solidity-utils/=lib/solidity-utils/contracts/\",\r\n      \"solmate/=lib/lssvm2/lib/solmate/src/\",\r\n      \"src/=lib/foundry-random/src/\",\r\n      \"stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"weird-erc20/=lib/lssvm/lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCollectionWars\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_voteContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotSetNullAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"epochManager\",\"type\":\"address\"}],\"name\":\"EpochManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"endEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochManager\",\"outputs\":[{\"internalType\":\"contract IEpochManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newCollectionWars\",\"outputs\":[{\"internalType\":\"contract INewCollectionWars\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_epochManager\",\"type\":\"address\"}],\"name\":\"setEpochManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyFactory\",\"outputs\":[{\"internalType\":\"contract IStrategyFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteContract\",\"outputs\":[{\"internalType\":\"contract ISweepWars\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RegisterSweepTrigger", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000072d6c121d0cdd773da8ba75057c5f4f2ef8755a1000000000000000000000000df2e023ea56d752d0b5be79f65557987976676cc0000000000000000000000003b91f74ae890dc97bb83e7b8edd36d8296902d6800000000000000000000000009c9381417e0ecff536ec33375f1d5b2efa97d78", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}