{"SourceCode": "// File: @chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit;\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/// @notice Application contracts that intend to receive messages from\r\n/// the router should implement this interface.\r\ninterface IAny2EVMMessageReceiver {\r\n  /// @notice Called by the Router to deliver a message.\r\n  /// If this reverts, any token transfers also revert. The message\r\n  /// will move to a FAILED state and become available for manual execution.\r\n  /// @param message CCIP Message\r\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\r\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\r\n  address internal immutable i_ccipRouter;\r\n\r\n  constructor(address router) {\r\n    if (router == address(0)) revert InvalidRouter(address(0));\r\n    i_ccipRouter = router;\r\n  }\r\n\r\n  /// @notice IERC165 supports an interfaceId\r\n  /// @param interfaceId The interfaceId to check\r\n  /// @return true if the interfaceId is supported\r\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\r\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\r\n  /// This allows CCIP to check if ccipReceive is available before calling it.\r\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\r\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\r\n  /// Additionally, if the receiver address does not have code associated with\r\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\r\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\r\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n  }\r\n\r\n  /// @inheritdoc IAny2EVMMessageReceiver\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\r\n    _ccipReceive(message);\r\n  }\r\n\r\n  /// @notice Override this function in your implementation.\r\n  /// @param message Any2EVMMessage\r\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\r\n\r\n  /////////////////////////////////////////////////////////////////////\r\n  // Plumbing\r\n  /////////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Return the current router\r\n  /// @return CCIP router address\r\n  function getRouter() public view returns (address) {\r\n    return address(i_ccipRouter);\r\n  }\r\n\r\n  error InvalidRouter(address router);\r\n\r\n  /// @dev only calls from the set router are accepted.\r\n  modifier onlyRouter() {\r\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IRouterClient {\r\n  error UnsupportedDestinationChain(uint64 destChainSelector);\r\n  error InsufficientFeeTokenAmount();\r\n  error InvalidMsgValue();\r\n\r\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\r\n  /// @param chainSelector The chain to check.\r\n  /// @return supported is true if it is supported, false if not.\r\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\r\n\r\n  /// @notice Gets a list of all supported tokens which can be sent or received\r\n  /// to/from a given chain id.\r\n  /// @param chainSelector The chainSelector.\r\n  /// @return tokens The addresses of all tokens that are supported.\r\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\r\n\r\n  /// @param destinationChainSelector The destination chainSelector\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return fee returns execution fee for the message\r\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\r\n  /// @dev Reverts with appropriate reason upon invalid message.\r\n  function getFee(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage memory message\r\n  ) external view returns (uint256 fee);\r\n\r\n  /// @notice Request a message to be sent to the destination chain\r\n  /// @param destinationChainSelector The destination chain ID\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return messageId The message ID\r\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\r\n  /// the overpayment with no refund.\r\n  /// @dev Reverts with appropriate reason upon invalid message.\r\n  function ccipSend(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage calldata message\r\n  ) external payable returns (bytes32);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: simTokenV2/mainBridge.sol\r\n\r\n\r\n// Compatible with OpenZeppelin Contracts ^5.0.0\r\n\r\n// Bridge for sendig Simpson Token To Polygon and Binance Networks.\r\n// This bridge secure with CCIP\r\n\r\n// How to Work\r\n// Approve Simp Token To this bridge.\r\n// Approve Link Token To this bridge.\r\n// selcet amout You want to recevie in destination chain.\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SimpsonBridge is CCIPReceiver {\r\n\r\n    address immutable public _CCIP_Router = 0x80226fc0Ee2b096224EeAc085Bb9a8cba1146f7D;\r\n    address immutable public _Link_Token = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\r\n    address immutable public  _Simpson_Token = 0xAb534A239459EF03c9A389039463c7631075Ecaa;  // Simpson Token Address\r\n    uint64 immutable ethChainSelector = 5009297550715157269;\r\n    uint64 immutable bnbChainSelector = 11344663589394136015;\r\n    uint64 immutable polygonChainSelector = 4051577828743386545;\r\n\r\n    \r\n\r\n    event SentCCIP(\r\n        bytes32 indexed messageId // The unique ID of the CCIP message.\r\n    );\r\n\r\n\r\n    constructor()\r\n        CCIPReceiver(_CCIP_Router)\r\n    {\r\n        LinkTokenInterface(_Link_Token).approve(_CCIP_Router, type(uint256).max);\r\n    }\r\n\r\n\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory message\r\n    ) internal override {\r\n        require(message.sourceChainSelector == bnbChainSelector || message.sourceChainSelector == polygonChainSelector, \"This Chain not Supported\");\r\n        require(abi.decode(message.sender, (address)) == address(this) , \" invalid message sender\" );\r\n        \r\n\r\n        (   uint256 amount,\r\n            address to\r\n        ) = abi.decode(message.data,(uint256,address));\r\n\r\n        require(IERC20(_Simpson_Token).transfer(to, amount) , \"Transfer failed\");\r\n    }\r\n\r\n    function safeTransferToBinance(uint256 value) public payable  {\r\n        sendCCIP(bnbChainSelector,msg.sender,value);\r\n    }\r\n    function safeTransferToPolygon(uint256 value) public payable  {\r\n        sendCCIP(polygonChainSelector,msg.sender,value);\r\n    }\r\n\r\n    function transferToBinance(address recipient,uint256 value) public payable  {\r\n        sendCCIP(bnbChainSelector,recipient,value);\r\n    }\r\n    function transferToPolygon(address recipient,uint256 value) public payable  {\r\n        sendCCIP(polygonChainSelector,recipient,value);\r\n    }\r\n\r\n    function transferToBinanceFee() public view returns (uint256 Fee)  {\r\n        Fee = crossTransferFee (bnbChainSelector,  false);\r\n    }\r\n\r\n    function transferToPolygonFee() public view returns (uint256 Fee)  {\r\n        Fee = crossTransferFee (polygonChainSelector,  false);\r\n    }\r\n    \r\n\r\n\r\n\r\n    function sendCCIP(uint64 targetSelector,address to, uint256 value) internal{\r\n        require(IERC20(_Simpson_Token).transferFrom(msg.sender, address(this), value) , \"Transfer failed\");\r\n        bool payInLink = msg.value == 0;\r\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(address(this)),\r\n            data:  abi.encode(value,to),\r\n            tokenAmounts: new Client.EVMTokenAmount[](0),\r\n            extraArgs: Client._argsToBytes(\r\n                Client.EVMExtraArgsV1({gasLimit: 70_000})\r\n            ),\r\n            feeToken: payInLink ? _Link_Token : address(0)\r\n        });\r\n        uint256 ccipFee = IRouterClient(_CCIP_Router).getFee(targetSelector, message);\r\n        uint256 feeMain;\r\n        if (payInLink) {\r\n            LinkTokenInterface(_Link_Token).transferFrom(msg.sender, address(this), ccipFee);\r\n        } else {\r\n            feeMain = ccipFee;\r\n            require(msg.value >= feeMain, \"insufficient fee\");\r\n            if (msg.value > ccipFee) {\r\n                payable(msg.sender).transfer(msg.value - feeMain);\r\n            }\r\n        }\r\n        emit SentCCIP( IRouterClient(_CCIP_Router).ccipSend{value: feeMain}(\r\n            targetSelector,\r\n            message\r\n        ));\r\n    }\r\n\r\n    function crossTransferFee (uint64 targetSelector, bool payInLink) public view returns (uint256 fee){\r\n        uint256 value = 100000000000000000001;\r\n        address to = address(this);\r\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(address(this)),\r\n            data:  abi.encode(value,to),\r\n            tokenAmounts: new Client.EVMTokenAmount[](0),\r\n            extraArgs: Client._argsToBytes(\r\n                Client.EVMExtraArgsV1({gasLimit: 70_000})\r\n            ),\r\n            feeToken: payInLink ? _Link_Token : address(0)\r\n        });\r\n        fee = IRouterClient(_CCIP_Router).getFee(targetSelector, message);\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"SentCCIP\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_CCIP_Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Link_Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Simpson_Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"targetSelector\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"payInLink\",\"type\":\"bool\"}],\"name\":\"crossTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeTransferToBinance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeTransferToPolygon\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferToBinance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferToBinanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferToPolygon\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferToPolygonFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SimpsonBridge", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0c730d7061a1ab0d5ed241c7b1aef660b622c2448c047f3ee0a8965c05e08883"}