{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/amo/helpers/AMOCommon.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (amo/helpers/AMOCommon.sol)\\n\\nlibrary AMOCommon {\\n    error NotOperator();\\n    error NotOperatorOrOwner();\\n    error ZeroSwapLimit();\\n    error OnlyAMO();\\n    error AboveCappedAmount(uint256 amountIn);\\n    error InsufficientBPTAmount(uint256 amount);\\n    error InvalidBPSValue(uint256 value);\\n    error InvalidMaxAmounts(uint256 bptMaxAmount, uint256 stableMaxAmount, uint256 templeMaxAmount);\\n    error InvalidBalancerVaultRequest();\\n    error NotEnoughCooldown();\\n    error NoRebalanceUp();\\n    error NoRebalanceDown();\\n    error HighSlippage();\\n    error Paused();\\n}\"\r\n    },\r\n    \"contracts/amo/Ramos.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (amo/Ramos.sol)\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport { IRamos } from \\\"contracts/interfaces/amo/IRamos.sol\\\";\\nimport { IRamosTokenVault } from \\\"contracts/interfaces/amo/helpers/IRamosTokenVault.sol\\\";\\nimport { ITreasuryPriceIndexOracle } from \\\"contracts/interfaces/v2/ITreasuryPriceIndexOracle.sol\\\";\\nimport { IBalancerPoolHelper } from \\\"contracts/interfaces/amo/helpers/IBalancerPoolHelper.sol\\\";\\nimport { IBalancerVault } from \\\"contracts/interfaces/external/balancer/IBalancerVault.sol\\\";\\nimport { IAuraStaking } from \\\"contracts/interfaces/amo/IAuraStaking.sol\\\";\\nimport { IBalancerBptToken } from \\\"contracts/interfaces/external/balancer/IBalancerBptToken.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/common/CommonEventsAndErrors.sol\\\";\\n\\nimport { TempleElevatedAccess } from \\\"contracts/v2/access/TempleElevatedAccess.sol\\\";\\nimport { AMOCommon } from \\\"contracts/amo/helpers/AMOCommon.sol\\\";\\n\\n/* solhint-disable not-rely-on-time */\\n\\n/**\\n * @title AMO built for a 50/50 balancer pool\\n *\\n * @notice RAMOS rebalances the pool to trend towards the Treasury Price Index (TPI).\\n * In order to accomplish this:\\n *   1. When the price is BELOW the TPI it will either:\\n *      - Single side withdraw `protocolToken`\\n *      - Single side add `quoteToken`\\n *   2. When the price is ABOVE the TPI it will either:\\n *      - Single side add `protocolToken`\\n *      - Single side withdraw `quoteToken`\\n * Any idle BPTs (Balancer LP tokens) are deposited into Aura to earn yield.\\n * `protocolToken` can be sourced/disposed of by either having direct mint & burn rights or by\\n * pulling and sending tokens to an address.\\n */\\ncontract Ramos is IRamos, TempleElevatedAccess, Pausable {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IBalancerBptToken;\\n\\n    /// @notice The Balancer vault singleton\\n    IBalancerVault public immutable override balancerVault;\\n\\n    /// @notice BPT token address for this LP\\n    IBalancerBptToken public immutable override bptToken;\\n\\n    /// @notice Balancer pool helper contract\\n    IBalancerPoolHelper public override poolHelper;\\n    \\n    /// @notice AMO contract for staking into aura \\n    IAuraStaking public immutable override amoStaking;\\n\\n    /// @notice The Protocol token\\n    IERC20 public immutable override protocolToken;\\n\\n    /// @notice The Quoted token this is paired with in the LP. It may be a stable, \\n    /// or another Balancer linear token like BB-A-USD\\n    IERC20 public immutable override quoteToken;\\n\\n    /// @notice The time when the last rebalance occured\\n    uint64 public override lastRebalanceTimeSecs;\\n\\n    /// @notice The minimum amount of time which must pass since `lastRebalanceTimeSecs` before another rebalance\\n    /// can occur\\n    uint64 public override cooldownSecs;\\n\\n    /// @notice The balancer 50/50 pool ID.\\n    bytes32 public immutable override balancerPoolId;\\n\\n    /// @notice Precision for BPS calculations. 1% == 100\\n    uint256 public constant override BPS_PRECISION = 10_000;\\n\\n    /// @notice The Treasury Price Index (TPI) Oracle\\n    ITreasuryPriceIndexOracle public override tpiOracle;\\n\\n    /// @notice The vault from where to borrow and repay the Protocol & Quote Tokens\\n    IRamosTokenVault public override tokenVault;\\n\\n    /// @notice The percentage bounds (in bps) beyond which to rebalance up or down\\n    uint64 public override rebalancePercentageBoundLow;\\n    uint64 public override rebalancePercentageBoundUp;\\n\\n    /// @notice Maximum amount of tokens that can be rebalanced on each run\\n    MaxRebalanceAmounts public override maxRebalanceAmounts;\\n\\n    /// @notice A limit on how much the price can be impacted by a rebalance. \\n    /// A price change over this limit will revert. Specified in bps\\n    uint64 public override postRebalanceDelta;\\n\\n    /// @notice `protocolToken` index in balancer pool. to avoid recalculation or external calls\\n    uint64 public immutable override protocolTokenBalancerPoolIndex;\\n\\n    /// @notice The address to send proportion of rebalance as fees to\\n    address public override feeCollector;\\n\\n    // @notice The maximum rebalance fee which can be set\\n    uint256 public override immutable maxRebalanceFee;\\n\\n    /// @notice The fees (in basis points) taken on a rebalance\\n    RebalanceFees public override rebalanceFees;\\n\\n    constructor(\\n        address _initialRescuer,\\n        address _initialExecutor,\\n        address _balancerVault,\\n        address _protocolToken,\\n        address _quoteToken,\\n        address _bptToken,\\n        address _amoStaking,\\n        uint64 _protocolTokenIndexInPool,\\n        bytes32 _balancerPoolId,\\n        address _feeCollector,\\n        uint256 _maxRebalanceFee\\n    ) TempleElevatedAccess(_initialRescuer, _initialExecutor) {\\n        balancerVault = IBalancerVault(_balancerVault);\\n        protocolToken = IERC20(_protocolToken);\\n        quoteToken = IERC20(_quoteToken);\\n        bptToken = IBalancerBptToken(_bptToken);\\n        amoStaking = IAuraStaking(_amoStaking);\\n        protocolTokenBalancerPoolIndex = _protocolTokenIndexInPool;\\n        balancerPoolId = _balancerPoolId;\\n        feeCollector = _feeCollector;\\n\\n        if (_maxRebalanceFee > BPS_PRECISION) {\\n            revert AMOCommon.InvalidBPSValue(_maxRebalanceFee);\\n        }\\n        maxRebalanceFee = _maxRebalanceFee;\\n    }\\n\\n    /**\\n     * @notice Set the pool helper contract\\n     */\\n    function setPoolHelper(address _poolHelper) external onlyElevatedAccess {\\n        poolHelper = IBalancerPoolHelper(_poolHelper);\\n\\n        emit SetPoolHelper(_poolHelper);\\n    }\\n\\n    /**\\n     * @notice Set the acceptable amount of price impact allowed due to a rebalance\\n     */\\n    function setPostRebalanceDelta(uint64 deltaBps) external onlyElevatedAccess {\\n        if (deltaBps > BPS_PRECISION || deltaBps == 0) {\\n            revert AMOCommon.InvalidBPSValue(deltaBps);\\n        }\\n        postRebalanceDelta = deltaBps;\\n        emit SetPostRebalanceDelta(deltaBps);\\n    }\\n\\n    /**\\n     * @notice Set maximum amount used by bot to rebalance\\n     * @param bptMaxAmount Maximum bpt amount per rebalance\\n     * @param quoteTokenMaxAmount Maximum `quoteToken` amount per rebalance\\n     * @param protocolTokenMaxAmount Maximum protocolToken amount per rebalance\\n     */\\n    function setMaxRebalanceAmounts(uint256 bptMaxAmount, uint256 quoteTokenMaxAmount, uint256 protocolTokenMaxAmount) external onlyElevatedAccess {\\n        if (bptMaxAmount == 0 || quoteTokenMaxAmount == 0 || protocolTokenMaxAmount == 0) {\\n            revert AMOCommon.InvalidMaxAmounts(bptMaxAmount, quoteTokenMaxAmount, protocolTokenMaxAmount);\\n        }\\n        maxRebalanceAmounts.bpt = bptMaxAmount;\\n        maxRebalanceAmounts.quoteToken = quoteTokenMaxAmount;\\n        maxRebalanceAmounts.protocolToken = protocolTokenMaxAmount;\\n        emit SetMaxRebalanceAmounts(bptMaxAmount, quoteTokenMaxAmount, protocolTokenMaxAmount);\\n    }\\n\\n    /// @notice Set maximum percentage bounds (in bps) beyond which to rebalance up or down\\n    function setRebalancePercentageBounds(uint64 belowTpi, uint64 aboveTpi) external onlyElevatedAccess {\\n        if (belowTpi > BPS_PRECISION || aboveTpi > BPS_PRECISION) {\\n            revert AMOCommon.InvalidBPSValue(belowTpi);\\n        }\\n        rebalancePercentageBoundLow = belowTpi;\\n        rebalancePercentageBoundUp = aboveTpi;\\n\\n        emit SetRebalancePercentageBounds(belowTpi, aboveTpi);\\n    }\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI) Oracle\\n     */\\n    function setTpiOracle(address newTpiOracle) external override onlyElevatedAccess {\\n        emit TpiOracleSet(newTpiOracle);\\n        tpiOracle = ITreasuryPriceIndexOracle(newTpiOracle);\\n    }\\n\\n    /**\\n     * @notice Set the token vault - where to borrow and repay the Protocol & Quote Tokens\\n     */\\n    function setTokenVault(address vault) external override onlyElevatedAccess {\\n        emit TokenVaultSet(vault);\\n\\n        // Remove allowance from the old vault\\n        address previousVault = address(tokenVault);\\n        if (previousVault != address(0)) {\\n            protocolToken.safeApprove(previousVault, 0);\\n            quoteToken.safeApprove(previousVault, 0);\\n        }\\n\\n        tokenVault = IRamosTokenVault(vault);\\n\\n        // Set max allowance on the new TRV\\n        {\\n            protocolToken.safeApprove(vault, 0);\\n            protocolToken.safeIncreaseAllowance(vault, type(uint256).max);\\n            \\n            quoteToken.safeApprove(vault, 0);\\n            quoteToken.safeIncreaseAllowance(vault, type(uint256).max);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update the fee collector address - only callable by the existing feeCollector\\n     */\\n    function setFeeCollector(address _feeCollector) external {\\n        if (msg.sender != feeCollector) revert CommonEventsAndErrors.InvalidAccess();\\n        if (_feeCollector == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        feeCollector = _feeCollector;\\n        emit FeeCollectorSet(_feeCollector);\\n    }\\n\\n    /**\\n     * @notice Set the rebalance fees, in basis points\\n     * @param rebalanceJoinFeeBps The fee for when a `rebalanceUpJoin` or `rebalanceDownJoin` is performed\\n     * @param rebalanceExitFeeBps The fee for when a `rebalanceUpExit` or `rebalanceDownExit` is performed\\n     */\\n    function setRebalanceFees(uint256 rebalanceJoinFeeBps, uint256 rebalanceExitFeeBps) external override {\\n        if (msg.sender != feeCollector) revert CommonEventsAndErrors.InvalidAccess();\\n        if (rebalanceJoinFeeBps > maxRebalanceFee) revert CommonEventsAndErrors.InvalidParam();\\n        if (rebalanceExitFeeBps > maxRebalanceFee) revert CommonEventsAndErrors.InvalidParam();\\n\\n        emit RebalanceFeesSet(rebalanceJoinFeeBps, rebalanceExitFeeBps);\\n\\n        // Downcast is safe since it can't be set greater than the max.\\n        rebalanceFees = RebalanceFees(uint128(rebalanceJoinFeeBps), uint128(rebalanceExitFeeBps));\\n    }\\n\\n    /**\\n     * @notice The Treasury Price Index - the target price of the Treasury, in `quoteToken` terms.\\n     */\\n    function treasuryPriceIndex() public view override returns (uint96) {\\n        return tpiOracle.treasuryPriceIndex();\\n    }\\n\\n    /**\\n     * @notice Set cooldown time to throttle rebalances\\n     * @param _seconds Time in seconds between calls\\n     */\\n    function setCoolDown(uint64 _seconds) external onlyElevatedAccess {\\n        cooldownSecs = _seconds;\\n\\n        emit SetCooldown(_seconds);\\n    }\\n    \\n    /**\\n     * @notice Pause AMO\\n     * */\\n    function pause() external onlyElevatedAccess {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpause AMO\\n     * */\\n    function unpause() external onlyElevatedAccess {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @notice Recover any token from AMO\\n     * @param token Token to recover\\n     * @param to Recipient address\\n     * @param amount Amount to recover\\n     */\\n    function recoverToken(address token, address to, uint256 amount) external onlyElevatedAccess {\\n        IERC20(token).safeTransfer(to, amount);\\n\\n        emit RecoveredToken(token, to, amount);\\n    }\\n\\n    /**\\n     * @notice Rebalance up when `protocolToken` spot price is below TPI.\\n     * Single-side WITHDRAW `protocolToken` from balancer liquidity pool to raise price.\\n     * BPT tokens are withdrawn from Aura rewards staking contract and used for balancer\\n     * pool exit. \\n     * Ramos rebalance fees are deducted from the amount of `protocolToken` returned from the balancer pool\\n     * The remainder `protocolToken` are repaid to the `tokenVault`\\n     * @param bptAmountIn amount of BPT tokens going in balancer pool for exit\\n     * @param minProtocolTokenOut amount of `protocolToken` expected out of balancer pool\\n     */\\n    function rebalanceUpExit(\\n        uint256 bptAmountIn,\\n        uint256 minProtocolTokenOut\\n    ) external override onlyElevatedAccess whenNotPaused enoughCooldown {\\n        _validateParams(minProtocolTokenOut, bptAmountIn, maxRebalanceAmounts.bpt);\\n        lastRebalanceTimeSecs = uint64(block.timestamp);\\n\\n        // Unstake and send the BPT to the poolHelper\\n        IBalancerPoolHelper _poolHelper = poolHelper;\\n        amoStaking.withdrawAndUnwrap(bptAmountIn, false, address(_poolHelper));\\n    \\n        // protocolToken single side exit\\n        uint256 protocolTokenAmountOut = _poolHelper.exitPool(\\n            bptAmountIn, minProtocolTokenOut, rebalancePercentageBoundLow,\\n            rebalancePercentageBoundUp, postRebalanceDelta,\\n            protocolTokenBalancerPoolIndex, treasuryPriceIndex(), protocolToken\\n        );\\n\\n        // Collect the fees on the output protocol token\\n        uint256 feeAmt = protocolTokenAmountOut * rebalanceFees.rebalanceExitFeeBps / BPS_PRECISION;\\n        if (feeAmt > 0) {\\n            protocolToken.safeTransfer(feeCollector, feeAmt);\\n        }\\n\\n        // Repay the remaining protocol tokens withdrawn from the pool\\n        unchecked {\\n            protocolTokenAmountOut -= feeAmt;\\n        }\\n        emit RebalanceUpExit(bptAmountIn, protocolTokenAmountOut, feeAmt);\\n        if (protocolTokenAmountOut > 0) {\\n            tokenVault.repayProtocolToken(protocolTokenAmountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice Rebalance down when `protocolToken` spot price is above TPI.\\n     * Single-side WITHDRAW `quoteToken` from balancer liquidity pool to lower price.\\n     * BPT tokens are withdrawn from Aura rewards staking contract and used for balancer\\n     * pool exit. \\n     * Ramos rebalance fees are deducted from the amount of `quoteToken` returned from the exit\\n     * The remainder `quoteToken` are repaid via the token vault\\n     * @param bptAmountIn Amount of BPT tokens to deposit into balancer pool\\n     * @param minQuoteTokenAmountOut Minimum amount of `quoteToken` expected to receive\\n     */\\n    function rebalanceDownExit(\\n        uint256 bptAmountIn,\\n        uint256 minQuoteTokenAmountOut\\n    ) external override onlyElevatedAccess whenNotPaused enoughCooldown {\\n        _validateParams(minQuoteTokenAmountOut, bptAmountIn, maxRebalanceAmounts.bpt);\\n        lastRebalanceTimeSecs = uint64(block.timestamp);\\n\\n        // Unstake and send the BPT to the poolHelper\\n        IBalancerPoolHelper _poolHelper = poolHelper;\\n        amoStaking.withdrawAndUnwrap(bptAmountIn, false, address(_poolHelper));\\n\\n        // QuoteToken single side exit\\n        uint256 quoteTokenAmountOut = _poolHelper.exitPool(\\n            bptAmountIn, minQuoteTokenAmountOut, rebalancePercentageBoundLow, rebalancePercentageBoundUp,\\n            postRebalanceDelta, 1-protocolTokenBalancerPoolIndex, treasuryPriceIndex(), quoteToken\\n        );\\n\\n        // Collect the fees on the output quote token\\n        uint256 feeAmt = quoteTokenAmountOut * rebalanceFees.rebalanceExitFeeBps / BPS_PRECISION;\\n        if (feeAmt > 0) {\\n            quoteToken.safeTransfer(feeCollector, feeAmt);\\n        }\\n\\n        unchecked {\\n            quoteTokenAmountOut -= feeAmt;\\n        }\\n        emit RebalanceDownExit(bptAmountIn, quoteTokenAmountOut, feeAmt);\\n        if (quoteTokenAmountOut > 0) {\\n            tokenVault.repayQuoteToken(quoteTokenAmountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice Rebalance up when `protocolToken` spot price is below TPI.\\n     * Single-side ADD `quoteToken` into the balancer liquidity pool to raise price.\\n     * Returned BPT tokens are deposited and staked into Aura for rewards using the staking contract.\\n     * Ramos rebalance fees are deducted from the amount of `quoteToken` input\\n     * The remainder `quoteToken` are added into the balancer pool\\n     * @dev The `quoteToken` amount must be deposited into this contract first\\n     * @param quoteTokenAmountIn Amount of `quoteToken` to deposit into balancer pool\\n     * @param minBptOut Minimum amount of BPT tokens expected to receive\\n     */\\n    function rebalanceUpJoin(\\n        uint256 quoteTokenAmountIn,\\n        uint256 minBptOut\\n    ) external override onlyElevatedAccess whenNotPaused enoughCooldown {\\n        _validateParams(minBptOut, quoteTokenAmountIn, maxRebalanceAmounts.quoteToken);\\n        lastRebalanceTimeSecs = uint64(block.timestamp);\\n\\n        // Borrow the quote token\\n        tokenVault.borrowQuoteToken(quoteTokenAmountIn, address(this));\\n\\n        // Collect the fees from the input quote token\\n        uint256 feeAmt = quoteTokenAmountIn * rebalanceFees.rebalanceJoinFeeBps / BPS_PRECISION;\\n        if (feeAmt > 0) {\\n            quoteToken.safeTransfer(feeCollector, feeAmt);\\n        }\\n\\n        // Send the remaining quote tokens to the poolHelper\\n        uint256 joinAmountIn = quoteTokenAmountIn - feeAmt;\\n        IBalancerPoolHelper _poolHelper = poolHelper;\\n        quoteToken.safeTransfer(address(_poolHelper), joinAmountIn);\\n\\n        // quoteToken single side join\\n        uint256 bptTokensStaked = _poolHelper.joinPool(\\n            joinAmountIn, minBptOut, rebalancePercentageBoundUp, rebalancePercentageBoundLow,\\n            treasuryPriceIndex(), postRebalanceDelta, 1-protocolTokenBalancerPoolIndex, quoteToken\\n        );\\n        emit RebalanceUpJoin(quoteTokenAmountIn, bptTokensStaked, feeAmt);\\n\\n        // deposit and stake BPT\\n        if (bptTokensStaked > 0) {\\n            bptToken.safeTransfer(address(amoStaking), bptTokensStaked);\\n            amoStaking.depositAndStake(bptTokensStaked);\\n        }\\n    }\\n\\n    /**\\n     * @notice Rebalance down when `protocolToken` spot price is above TPI.\\n     * Single-side ADD `protocolToken` into the balancer liquidity pool to lower price.\\n     * Returned BPT tokens are deposited and staked into Aura for rewards using the staking contract.\\n     * Ramos rebalance fees are deducted from the amount of `protocolToken` input\\n     * The remainder `protocolToken` are added into the balancer pool\\n     * @dev The `protocolToken` are borrowed from the `tokenVault`\\n     * @param protocolTokenAmountIn Amount of `protocolToken` tokens to deposit into balancer pool\\n     * @param minBptOut Minimum amount of BPT tokens expected to receive\\n     */\\n    function rebalanceDownJoin(\\n        uint256 protocolTokenAmountIn,\\n        uint256 minBptOut\\n    ) external override onlyElevatedAccess whenNotPaused enoughCooldown {\\n        _validateParams(minBptOut, protocolTokenAmountIn, maxRebalanceAmounts.protocolToken);\\n        lastRebalanceTimeSecs = uint64(block.timestamp);\\n\\n        // Borrow the protocol token\\n        tokenVault.borrowProtocolToken(protocolTokenAmountIn, address(this));\\n\\n        // Collect the fees from the input protocol token amount\\n        uint256 feeAmt = protocolTokenAmountIn * rebalanceFees.rebalanceJoinFeeBps / BPS_PRECISION;\\n        if (feeAmt > 0) {\\n            protocolToken.safeTransfer(feeCollector, feeAmt);\\n        }\\n\\n        // Send the balance to the poolHelper\\n        uint256 joinAmountIn = protocolTokenAmountIn - feeAmt;\\n        IBalancerPoolHelper _poolHelper = poolHelper;\\n        protocolToken.safeTransfer(address(_poolHelper), joinAmountIn);\\n\\n        // protocolToken single side join\\n        uint256 bptTokensStaked = _poolHelper.joinPool(\\n            joinAmountIn, minBptOut, rebalancePercentageBoundUp,\\n            rebalancePercentageBoundLow, treasuryPriceIndex(), \\n            postRebalanceDelta, protocolTokenBalancerPoolIndex, protocolToken\\n        );\\n        emit RebalanceDownJoin(protocolTokenAmountIn, bptTokensStaked, feeAmt);\\n\\n        // deposit and stake BPT\\n        if (bptTokensStaked > 0) {\\n            bptToken.safeTransfer(address(amoStaking), bptTokensStaked);\\n            amoStaking.depositAndStake(bptTokensStaked);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add liquidity with both `protocolToken` and `quoteToken` into balancer pool. \\n     * TPI is expected to be within bounds of multisig set range.\\n     * BPT tokens are then deposited and staked in Aura.\\n     * @param request Request data for joining balancer pool. Assumes userdata of request is\\n     * encoded with EXACT_TOKENS_IN_FOR_BPT_OUT type\\n     */\\n    function addLiquidity(\\n        IBalancerVault.JoinPoolRequest memory request\\n    ) external override onlyElevatedAccess returns (\\n        uint256 quoteTokenAmount,\\n        uint256 protocolTokenAmount,\\n        uint256 bptTokensStaked\\n    ) {\\n        // validate request\\n        if (request.assets.length != request.maxAmountsIn.length || \\n            request.assets.length != 2 || \\n            request.fromInternalBalance) {\\n                revert AMOCommon.InvalidBalancerVaultRequest();\\n        }\\n\\n        (protocolTokenAmount, quoteTokenAmount) = protocolTokenBalancerPoolIndex == 0\\n            ? (request.maxAmountsIn[0], request.maxAmountsIn[1])\\n            : (request.maxAmountsIn[1], request.maxAmountsIn[0]);\\n\\n        IRamosTokenVault _tokenVault = tokenVault;\\n        _tokenVault.borrowProtocolToken(protocolTokenAmount, address(this));\\n        _tokenVault.borrowQuoteToken(quoteTokenAmount, address(this));\\n\\n        // safe allowance quoteToken and protocolToken\\n        {\\n            protocolToken.safeIncreaseAllowance(address(balancerVault), protocolTokenAmount);\\n            uint256 quoteTokenAllowance = quoteToken.allowance(address(this), address(balancerVault));\\n            if (quoteTokenAllowance < quoteTokenAmount) {\\n                quoteToken.safeApprove(address(balancerVault), 0);\\n                quoteToken.safeIncreaseAllowance(address(balancerVault), quoteTokenAmount);\\n            }\\n        }\\n\\n        // join pool\\n        {\\n            uint256 bptAmountBefore = bptToken.balanceOf(address(this));\\n            balancerVault.joinPool(balancerPoolId, address(this), address(this), request);\\n            uint256 bptAmountAfter = bptToken.balanceOf(address(this));\\n            unchecked {\\n                bptTokensStaked = bptAmountAfter - bptAmountBefore;\\n            }\\n        }\\n\\n        emit LiquidityAdded(quoteTokenAmount, protocolTokenAmount, bptTokensStaked);\\n\\n        // stake BPT\\n        if (bptTokensStaked > 0) {\\n            bptToken.safeTransfer(address(amoStaking), bptTokensStaked);\\n            amoStaking.depositAndStake(bptTokensStaked);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from balancer pool receiving both `protocolToken` and `quoteToken` from balancer pool. \\n     * TPI is expected to be within bounds of multisig set range.\\n     * Withdraw and unwrap BPT tokens from Aura staking and send to balancer pool to receive both tokens.\\n     * @param request Request for use in balancer pool exit\\n     * @param bptIn Amount of BPT tokens to send into balancer pool\\n     */\\n    function removeLiquidity(\\n        IBalancerVault.ExitPoolRequest memory request,\\n        uint256 bptIn\\n    ) external override onlyElevatedAccess returns (\\n        uint256 quoteTokenAmount, \\n        uint256 protocolTokenAmount\\n    ) {\\n        // validate request\\n        if (\\n            request.assets.length != request.minAmountsOut.length || \\n            request.assets.length != 2 || \\n            request.toInternalBalance\\n        ) {\\n            revert AMOCommon.InvalidBalancerVaultRequest();\\n        }\\n\\n        uint256 protocolTokenAmountBefore = protocolToken.balanceOf(address(this));\\n        uint256 quoteTokenAmountBefore = quoteToken.balanceOf(address(this));\\n\\n        amoStaking.withdrawAndUnwrap(bptIn, false, address(this));\\n        balancerVault.exitPool(balancerPoolId, address(this), address(this), request);\\n\\n        unchecked {\\n            protocolTokenAmount = protocolToken.balanceOf(address(this)) - protocolTokenAmountBefore;\\n            quoteTokenAmount = quoteToken.balanceOf(address(this)) - quoteTokenAmountBefore;\\n        }\\n\\n        IRamosTokenVault _tokenVault = tokenVault;\\n        if (protocolTokenAmount > 0) {\\n            _tokenVault.repayProtocolToken(protocolTokenAmount);\\n        }\\n\\n        if (quoteTokenAmount > 0) {\\n            _tokenVault.repayQuoteToken(quoteTokenAmount);\\n        }\\n\\n        emit LiquidityRemoved(quoteTokenAmount, protocolTokenAmount, bptIn);\\n    }\\n\\n    /**\\n     * @notice Allow owner to deposit and stake bpt tokens directly\\n     * @param amount Amount of Bpt tokens to depositt\\n     * @param useContractBalance If to use bpt tokens in contract\\n     */\\n    function depositAndStakeBptTokens(\\n        uint256 amount,\\n        bool useContractBalance\\n    ) external override onlyElevatedAccess {\\n        if (!useContractBalance) {\\n            bptToken.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n        bptToken.safeTransfer(address(amoStaking), amount);\\n        amoStaking.depositAndStake(amount);\\n        emit DepositAndStakeBptTokens(amount);\\n    }\\n\\n    /**\\n     * @notice The total amount of `protocolToken` and `quoteToken` that Ramos holds via it's \\n     * staked and unstaked BPT.\\n     * @dev Calculated by pulling the total balances of each token in the pool\\n     * and getting RAMOS proportion of the owned BPT's\\n     */\\n    function positions() external override view returns (\\n        uint256 bptBalance, \\n        uint256 protocolTokenBalance, \\n        uint256 quoteTokenBalance\\n    ) {\\n        // Use `bpt.getActualSupply()` instead of `bpt.totalSupply()`\\n        // https://docs.balancer.fi/reference/lp-tokens/underlying.html#overview\\n        // https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain\\n        uint256 bptTotalSupply = bptToken.getActualSupply();\\n        if (bptTotalSupply > 0) {\\n            bptBalance = amoStaking.totalBalance();\\n            (uint256 totalProtocolTokenInLp, uint256 totalQuoteTokenInLp) = poolHelper.getPairBalances();\\n            protocolTokenBalance = totalProtocolTokenInLp * bptBalance /bptTotalSupply;\\n            quoteTokenBalance = totalQuoteTokenInLp * bptBalance /bptTotalSupply;\\n        }\\n    }\\n\\n    function _validateParams(\\n        uint256 minAmountOut,\\n        uint256 amountIn,\\n        uint256 maxRebalanceAmount\\n    ) internal pure {\\n        if (minAmountOut == 0) {\\n            revert AMOCommon.ZeroSwapLimit();\\n        }\\n        if (amountIn > maxRebalanceAmount) {\\n            revert AMOCommon.AboveCappedAmount(amountIn);\\n        }\\n    }\\n\\n    modifier enoughCooldown() {\\n        if (lastRebalanceTimeSecs + cooldownSecs > block.timestamp) {\\n            revert AMOCommon.NotEnoughCooldown();\\n        }\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/CommonEventsAndErrors.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (common/CommonEventsAndErrors.sol)\\n\\n/// @notice A collection of common errors thrown within the Temple contracts\\nlibrary CommonEventsAndErrors {\\n    error InsufficientBalance(address token, uint256 required, uint256 balance);\\n    error InvalidParam();\\n    error InvalidAddress();\\n    error InvalidAccess();\\n    error InvalidAmount(address token, uint256 amount);\\n    error ExpectedNonZero();\\n    error Unimplemented();\\n    event TokenRecovered(address indexed to, address indexed token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/amo/helpers/IBalancerPoolHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/amo/helpers/IBalancerPoolHelper.sol)\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IBalancerVault } from \\\"contracts/interfaces/external/balancer/IBalancerVault.sol\\\";\\nimport { IBalancerHelpers } from \\\"contracts/interfaces/external/balancer/IBalancerHelpers.sol\\\";\\n\\ninterface IBalancerPoolHelper {\\n\\n    function balancerVault() external view returns (IBalancerVault);\\n    function balancerHelpers() external view returns (IBalancerHelpers);\\n    function bptToken() external view returns (IERC20);\\n    function protocolToken() external view returns (IERC20);\\n    function quoteToken() external view returns (IERC20);\\n    function amo() external view returns (address);\\n    \\n    function BPS_PRECISION() external view returns (uint256);\\n    function PRICE_PRECISION() external view returns (uint256);\\n\\n    // @notice protocolToken index in balancer pool\\n    function protocolTokenIndexInBalancerPool() external view returns (uint64);\\n    function balancerPoolId() external view returns (bytes32);\\n\\n    function getBalances() external view returns (uint256[] memory balances);\\n\\n    function getPairBalances() external view returns (uint256 protocolTokenBalance, uint256 quoteTokenBalance);\\n\\n    function getSpotPrice() external view returns (uint256 spotPriceScaled);\\n\\n    function isSpotPriceBelowTpi(uint256 treasuryPriceIndex) external view returns (bool);\\n\\n    function isSpotPriceBelowTpi(uint256 slippage, uint256 treasuryPriceIndex) external view returns (bool);\\n\\n    function isSpotPriceBelowTpiLowerBound(uint256 rebalancePercentageBoundLow, uint256 treasuryPriceIndex) external view returns (bool);\\n\\n    function isSpotPriceAboveTpiUpperBound(uint256 rebalancePercentageBoundUp, uint256 treasuryPriceIndex) external view returns (bool);\\n    \\n    function isSpotPriceAboveTpi(uint256 slippage, uint256 treasuryPriceIndex) external view returns (bool);\\n\\n    function isSpotPriceAboveTpi(uint256 treasuryPriceIndex) external view returns (bool);\\n\\n    // @notice will exit take price above TPI by a percentage\\n    // percentage in bps\\n    // tokensOut: expected min amounts out. for rebalance this is expected `ProtocolToken` tokens out\\n    function willExitTakePriceAboveTpiUpperBound(\\n        uint256 tokensOut,\\n        uint256 rebalancePercentageBoundUp,\\n        uint256 treasuryPriceIndex\\n    ) external view returns (bool);\\n\\n    function willQuoteTokenJoinTakePriceAboveTpiUpperBound(\\n        uint256 tokensIn,\\n        uint256 rebalancePercentageBoundUp,\\n        uint256 treasuryPriceIndex\\n    ) external view returns (bool);\\n\\n    function willQuoteTokenExitTakePriceBelowTpiLowerBound(\\n        uint256 tokensOut,\\n        uint256 rebalancePercentageBoundLow,\\n        uint256 treasuryPriceIndex\\n    ) external view returns (bool);\\n\\n    function willJoinTakePriceBelowTpiLowerBound(\\n        uint256 tokensIn,\\n        uint256 rebalancePercentageBoundLow,\\n        uint256 treasuryPriceIndex\\n    ) external view returns (bool);\\n\\n    function getSlippage(uint256 spotPriceBeforeScaled) external view returns (uint256);\\n\\n    function exitPool(\\n        uint256 bptAmountIn,\\n        uint256 minAmountOut,\\n        uint256 rebalancePercentageBoundLow,\\n        uint256 rebalancePercentageBoundUp,\\n        uint256 postRebalanceDelta,\\n        uint256 exitTokenIndex,\\n        uint256 treasuryPriceIndex,\\n        IERC20 exitPoolToken\\n    ) external returns (uint256 amountOut);\\n\\n    function joinPool(\\n        uint256 amountIn,\\n        uint256 minBptOut,\\n        uint256 rebalancePercentageBoundUp,\\n        uint256 rebalancePercentageBoundLow,\\n        uint256 treasuryPriceIndex,\\n        uint256 postRebalanceDelta,\\n        uint256 joinTokenIndex,\\n        IERC20 joinPoolToken\\n    ) external returns (uint256 bptIn);\\n\\n    /// @notice Get the quote used to add liquidity proportionally\\n    /// @dev Since this is not the view function, this should be called with `callStatic`\\n    function proportionalAddLiquidityQuote(\\n        uint256 quoteTokenAmount,\\n        uint256 slippageBps\\n    ) external returns (\\n        uint256 protocolTokenAmount,\\n        uint256 expectedBptAmount,\\n        uint256 minBptAmount,\\n        IBalancerVault.JoinPoolRequest memory requestData\\n    );\\n\\n    /// @notice Get the quote used to remove liquidity\\n    /// @dev Since this is not the view function, this should be called with `callStatic`\\n    function proportionalRemoveLiquidityQuote(\\n        uint256 bptAmount,\\n        uint256 slippageBps\\n    ) external returns (\\n        uint256 expectedProtocolTokenAmount,\\n        uint256 expectedQuoteTokenAmount,\\n        uint256 minProtocolTokenAmount,\\n        uint256 minQuoteTokenAmount,\\n        IBalancerVault.ExitPoolRequest memory requestData\\n    );\\n\\n    function applySlippage(uint256 amountIn, uint256 slippageBps) external view returns (uint256 amountOut);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/amo/helpers/IRamosTokenVault.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/amo/helpers/IRamosTokenVault.sol)\\n\\n/**\\n * @title Ramos Token Vault\\n *\\n * @notice A vault to provide protocol and quote tokens to Ramos as it rebalances or updates liquidity.\\n * These two tokens are the pair of tokens in a liquidity pool, eg:\\n *   protocolToken = TEMPLE\\n *   quoteToken = DAI\\n */\\ninterface IRamosTokenVault {\\n    /**\\n     * @notice Send `protocolToken` to recipient\\n     * @param amount The requested amount to borrow\\n     * @param recipient The recipient to send the `protocolToken` tokens to\\n     */\\n    function borrowProtocolToken(uint256 amount, address recipient) external;    \\n\\n    /**\\n     * @notice Send `quoteToken` to recipient\\n     * @param amount The requested amount to borrow\\n     * @param recipient The recipient to send the `quoteToken` tokens to\\n     */\\n    function borrowQuoteToken(uint256 amount, address recipient) external;\\n\\n    /**\\n     * @notice Pull `protocolToken` from the caller\\n     * @param amount The requested amount to repay\\n     */\\n    function repayProtocolToken(uint256 amount) external;\\n\\n    /**\\n     * @notice Pull `quoteToken` from the caller\\n     * @param amount The requested amount to repay\\n     */\\n    function repayQuoteToken(uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/amo/IAuraStaking.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/external/aura/IAuraStaking.sol)\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IAuraBooster } from \\\"contracts/interfaces/external/aura/IAuraBooster.sol\\\";\\n\\ninterface IAuraStaking {\\n    struct AuraPoolInfo {\\n        address token;\\n        address rewards;\\n        uint32 pId;\\n    }\\n\\n    struct Position {\\n        uint256 staked;\\n        uint256 earned;\\n    }\\n\\n    event SetAuraPoolInfo(uint32 indexed pId, address token, address rewards);\\n    event RecoveredToken(address token, address to, uint256 amount);\\n    event SetRewardsRecipient(address recipient);\\n    event RewardTokensSet(address[] rewardTokens);\\n\\n    function bptToken() external view returns (IERC20);\\n    function auraPoolInfo() external view returns (\\n        address token,\\n        address rewards,\\n        uint32 pId\\n    );\\n    function booster() external view returns (IAuraBooster);\\n\\n    function rewardsRecipient() external view returns (address);\\n    function rewardTokens(uint256 index) external view returns (address);\\n    \\n    function setAuraPoolInfo(uint32 _pId, address _token, address _rewards) external;\\n\\n    function setRewardsRecipient(address _recipeint) external;\\n\\n    function setRewardTokens(address[] memory _rewardTokens) external;\\n\\n    function recoverToken(address token, address to, uint256 amount) external;\\n    function isAuraShutdown() external view returns (bool);\\n\\n    function depositAndStake(uint256 amount) external;\\n\\n    function withdrawAndUnwrap(uint256 amount, bool claim, address recipient) external;\\n\\n    function withdrawAllAndUnwrap(bool claim, address recipient) external;\\n\\n    function getReward(bool claimExtras) external;\\n\\n    function stakedBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice The total balance of BPT owned by this contract - either staked in Aura \\n     * or unstaked\\n     */\\n    function totalBalance() external view returns (uint256);\\n\\n    function earned() external view returns (uint256);\\n\\n    function showPositions() external view returns (Position memory position);\\n}\"\r\n    },\r\n    \"contracts/interfaces/amo/IRamos.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/amo/IRamos.sol)\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IBalancerVault } from \\\"contracts/interfaces/external/balancer/IBalancerVault.sol\\\";\\nimport { IBalancerBptToken } from \\\"contracts/interfaces/external/balancer/IBalancerBptToken.sol\\\";\\nimport { IBalancerPoolHelper } from \\\"contracts/interfaces/amo/helpers/IBalancerPoolHelper.sol\\\";\\nimport { IAuraStaking } from \\\"contracts/interfaces/amo/IAuraStaking.sol\\\";\\nimport { ITreasuryPriceIndexOracle } from \\\"contracts/interfaces/v2/ITreasuryPriceIndexOracle.sol\\\";\\nimport { IRamosTokenVault } from \\\"contracts/interfaces/amo/helpers/IRamosTokenVault.sol\\\";\\n\\n/**\\n * @title AMO built for a 50/50 balancer pool\\n *\\n * @notice RAMOS rebalances the pool to trend towards the Treasury Price Index (TPI).\\n * In order to accomplish this:\\n *   1. When the price is BELOW the TPI it will either:\\n *      - Single side withdraw `protocolToken`\\n *      - Single side add `quoteToken`\\n *   2. When the price is ABOVE the TPI it will either:\\n *      - Single side add `protocolToken`\\n *      - Single side withdraw `quoteToken`\\n * Any idle BPTs (Balancer LP tokens) are deposited into Aura to earn yield.\\n * `protocolToken` can be sourced/disposed of by either having direct mint & burn rights or by\\n * pulling and sending tokens to an address.\\n */\\ninterface IRamos {\\n    struct MaxRebalanceAmounts {\\n        uint256 bpt;\\n        uint256 quoteToken;\\n        uint256 protocolToken;\\n    }\\n\\n    struct RebalanceFees {\\n        uint128 rebalanceJoinFeeBps;\\n        uint128 rebalanceExitFeeBps;\\n    }\\n\\n    // Admin events\\n    event RecoveredToken(address token, address to, uint256 amount);\\n    event SetPostRebalanceDelta(uint64 deltaBps);\\n    event SetCooldown(uint64 cooldownSecs);\\n    event SetRebalancePercentageBounds(uint64 belowTpi, uint64 aboveTpi);\\n    event TpiOracleSet(address indexed tpiOracle);\\n    event TokenVaultSet(address indexed vault);\\n    event SetPoolHelper(address poolHelper);\\n    event SetMaxRebalanceAmounts(uint256 bptMaxAmount, uint256 quoteTokenMaxAmount, uint256 protocolTokenMaxAmount);\\n    event RebalanceFeesSet(uint256 rebalanceJoinFeeBps, uint256 rebalanceExitFeeBps);\\n    event FeeCollectorSet(address indexed feeCollector);\\n\\n    // Rebalance events\\n    event RebalanceUpExit(uint256 bptAmountIn, uint256 protocolTokenRepaid, uint256 protocolTokenFee);\\n    event RebalanceDownExit(uint256 bptAmountIn, uint256 quoteTokenRepaid, uint256 quoteTokenFee);\\n    event RebalanceUpJoin(uint256 quoteTokenAmountIn, uint256 bptTokensStaked, uint256 quoteTokenFee);\\n    event RebalanceDownJoin(uint256 protocolTokenAmountIn, uint256 bptTokensStaked, uint256 protocolTokenFee);\\n\\n    // Add/remove liquidity events\\n    event LiquidityAdded(uint256 quoteTokenAdded, uint256 protocolTokenAdded, uint256 bptReceived);\\n    event LiquidityRemoved(uint256 quoteTokenReceived, uint256 protocolTokenReceived, uint256 bptRemoved);\\n    event DepositAndStakeBptTokens(uint256 bptAmount);\\n    \\n    /// @notice The Balancer vault singleton\\n    function balancerVault() external view returns (IBalancerVault);\\n\\n    /// @notice BPT token address for this LP\\n    function bptToken() external view returns (IBalancerBptToken);\\n\\n    /// @notice Balancer pool helper contract\\n    function poolHelper() external view returns (IBalancerPoolHelper);\\n\\n    /// @notice AMO contract for staking into aura \\n    function amoStaking() external view returns (IAuraStaking);\\n  \\n    /// @notice The Protocol token  \\n    function protocolToken() external view returns (IERC20);\\n\\n    /// @notice The quoteToken this is paired with in the LP. It may be a stable, \\n    /// or another Balancer linear token like BB-A-USD\\n    function quoteToken() external view returns (IERC20);\\n\\n    /// @notice The time when the last rebalance occured\\n    function lastRebalanceTimeSecs() external view returns (uint64);\\n\\n    /// @notice The minimum amount of time which must pass since `lastRebalanceTimeSecs` before another rebalance\\n    /// can occur\\n    function cooldownSecs() external view returns (uint64);\\n\\n    /// @notice The balancer 50/50 pool ID.\\n    function balancerPoolId() external view returns (bytes32);\\n\\n    /// @notice Precision for BPS calculations. 1% == 100\\n    // solhint-disable-next-line func-name-mixedcase\\n    function BPS_PRECISION() external view returns (uint256);\\n\\n    /// @notice The percentage bounds (in bps) beyond which to rebalance up or down\\n    function rebalancePercentageBoundLow() external view returns (uint64);\\n    function rebalancePercentageBoundUp() external view returns (uint64);\\n\\n    /// @notice Maximum amount of tokens that can be rebalanced on each run\\n    function maxRebalanceAmounts() external view returns (\\n        uint256 bpt,\\n        uint256 quoteToken,\\n        uint256 protocolToken\\n    );\\n\\n    /// @notice A limit on how much the price can be impacted by a rebalance. \\n    /// A price change over this limit will revert. Specified in bps\\n    function postRebalanceDelta() external view returns (uint64);\\n\\n    /// @notice protocolToken index in balancer pool. to avoid recalculation or external calls\\n    function protocolTokenBalancerPoolIndex() external view returns (uint64);\\n\\n    /**\\n     * @notice The address to send proportion of rebalance as fees to\\n     */\\n    function feeCollector() external view returns (address);\\n\\n    /**\\n     * @notice The maximum rebalance fee which can be set\\n     */\\n    function maxRebalanceFee() external view returns (uint256);\\n\\n    /**\\n     * @notice The fees (in basis points) taken on a rebalance\\n     */\\n    function rebalanceFees() external view returns (\\n        uint128 rebalanceJoinFeeBps, \\n        uint128 rebalanceExitFeeBps\\n    );\\n\\n    /**\\n     * @notice Set the rebalance fees, in basis points\\n     * @param rebalanceJoinFeeBps The fee for when a `rebalanceUpJoin` or `rebalanceDownJoin` is performed\\n     * @param rebalanceExitFeeBps The fee for when a `rebalanceUpExit` or `rebalanceDownExit` is performed\\n     */\\n    function setRebalanceFees(uint256 rebalanceJoinFeeBps, uint256 rebalanceExitFeeBps) external;\\n\\n    /**\\n     * @notice The Treasury Price Index (TPI) Oracle\\n     */\\n    function tpiOracle() external view returns (ITreasuryPriceIndexOracle);\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI) Oracle\\n     */\\n    function setTpiOracle(address tpiOracleAddress) external;\\n\\n    /**\\n     * @notice The vault from where to borrow and repay the Protocol Token\\n     */\\n    function tokenVault() external view returns (IRamosTokenVault);\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI) Oracle\\n     */\\n    function setTokenVault(address vault) external;\\n\\n    /**\\n     * @notice The Treasury Price Index - the target price of the Treasury, in `quoteTokenToken` terms.\\n     */\\n    function treasuryPriceIndex() external view returns (uint96);\\n\\n    /**\\n     * @notice Rebalance up when `protocolToken` spot price is below TPI.\\n     * Single-side WITHDRAW `protocolToken` from balancer liquidity pool to raise price.\\n     * BPT tokens are withdrawn from Aura rewards staking contract and used for balancer\\n     * pool exit. \\n     * Ramos rebalance fees are deducted from the amount of `protocolToken` returned from the exit\\n     * The remainder `protocolToken` are repaid to the `TokenVault`\\n     * @param bptAmountIn amount of BPT tokens going in balancer pool for exit\\n     * @param minProtocolTokenOut amount of `protocolToken` expected out of balancer pool\\n     */\\n    function rebalanceUpExit(\\n        uint256 bptAmountIn,\\n        uint256 minProtocolTokenOut\\n    ) external;\\n\\n    /**\\n     * @notice Rebalance down when `protocolToken` spot price is above TPI.\\n     * Single-side WITHDRAW `quoteToken` from balancer liquidity pool to lower price.\\n     * BPT tokens are withdrawn from Aura rewards staking contract and used for balancer\\n     * pool exit. \\n     * Ramos rebalance fees are deducted from the amount of `quoteToken` returned from the exit\\n     * The remainder `quoteToken` are repaid via the token vault\\n     * @param bptAmountIn Amount of BPT tokens to deposit into balancer pool\\n     * @param minQuoteTokenAmountOut Minimum amount of `quoteToken` expected to receive\\n     */\\n    function rebalanceDownExit(\\n        uint256 bptAmountIn,\\n        uint256 minQuoteTokenAmountOut\\n    ) external;\\n\\n    /**\\n     * @notice Rebalance up when `protocolToken` spot price is below TPI.\\n     * Single-side ADD `quoteToken` into the balancer liquidity pool to raise price.\\n     * Returned BPT tokens are deposited and staked into Aura for rewards using the staking contract.\\n     * Ramos rebalance fees are deducted from the amount of `quoteToken` input\\n     * The remainder `quoteToken` are added into the balancer pool\\n     * @dev The `quoteToken` amount must be deposited into this contract first\\n     * @param quoteTokenAmountIn Amount of `quoteToken` to deposit into balancer pool\\n     * @param minBptOut Minimum amount of BPT tokens expected to receive\\n     */\\n    function rebalanceUpJoin(\\n        uint256 quoteTokenAmountIn,\\n        uint256 minBptOut\\n    ) external;\\n\\n    /**\\n     * @notice Rebalance down when `protocolToken` spot price is above TPI.\\n     * Single-side ADD `protocolToken` into the balancer liquidity pool to lower price.\\n     * Returned BPT tokens are deposited and staked into Aura for rewards using the staking contract.\\n     * Ramos rebalance fees are deducted from the amount of `protocolToken` input\\n     * The remainder `protocolToken` are added into the balancer pool\\n     * @dev The `protocolToken` are borrowed from the `TokenVault`\\n     * @param protocolTokenAmountIn Amount of `protocolToken` tokens to deposit into balancer pool\\n     * @param minBptOut Minimum amount of BPT tokens expected to receive\\n     */\\n    function rebalanceDownJoin(\\n        uint256 protocolTokenAmountIn,\\n        uint256 minBptOut\\n    ) external;\\n\\n    /**\\n     * @notice Add liquidity with both `protocolToken` and `quoteToken` into balancer pool. \\n     * TPI is expected to be within bounds of multisig set range.\\n     * BPT tokens are then deposited and staked in Aura.\\n     * @param request Request data for joining balancer pool. Assumes userdata of request is\\n     * encoded with EXACT_TOKENS_IN_FOR_BPT_OUT type\\n     */\\n    function addLiquidity(\\n        IBalancerVault.JoinPoolRequest memory request\\n    ) external returns (\\n        uint256 quoteTokenAmount,\\n        uint256 protocolTokenAmount,\\n        uint256 bptTokensStaked\\n    );\\n    \\n    /**\\n     * @notice Remove liquidity from balancer pool receiving both `protocolToken` and `quoteToken` from balancer pool. \\n     * TPI is expected to be within bounds of multisig set range.\\n     * Withdraw and unwrap BPT tokens from Aura staking and send to balancer pool to receive both tokens.\\n     * @param request Request for use in balancer pool exit\\n     * @param bptIn Amount of BPT tokens to send into balancer pool\\n     */\\n    function removeLiquidity(\\n        IBalancerVault.ExitPoolRequest memory request, \\n        uint256 bptIn\\n    ) external returns (\\n        uint256 quoteTokenAmount,\\n        uint256 protocolTokenAmount\\n    );\\n\\n    /**\\n     * @notice Allow owner to deposit and stake bpt tokens directly\\n     * @param amount Amount of Bpt tokens to depositt\\n     * @param useContractBalance If to use bpt tokens in contract\\n     */\\n    function depositAndStakeBptTokens(\\n        uint256 amount,\\n        bool useContractBalance\\n    ) external;\\n\\n    /**\\n     * @notice The total amount of `protocolToken` and `quoteToken` that Ramos holds via it's \\n     * staked and unstaked BPT.\\n     * @dev Calculated by pulling the total balances of each token in the pool\\n     * and getting RAMOS proportion of the owned BPT's\\n     */\\n    function positions() external view returns (\\n        uint256 bptBalance, \\n        uint256 protoclTokenBalance, \\n        uint256 quoteTokenBalance\\n    );\\n}\"\r\n    },\r\n    \"contracts/interfaces/external/aura/IAuraBooster.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/external/aura/IAuraBooster.sol)\\n\\ninterface IAuraBooster {\\n\\n    struct PoolInfo {\\n        address lptoken;\\n        address token;\\n        address gauge;\\n        address crvRewards;\\n        address stash;\\n        bool shutdown;\\n    }\\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory);\\n    function isShutdown() external view returns (bool);\\n\\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool);\\n    function depositAll(uint256 _pid, bool _stake) external returns(bool);\\n    function earmarkRewards(uint256 _pid) external returns(bool);\\n    function claimRewards(uint256 _pid, address _gauge) external returns(bool);\\n    function earmarkFees(address _feeToken) external returns(bool);\\n    function minter() external view returns (address);\\n\\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\\n}\"\r\n    },\r\n    \"contracts/interfaces/external/balancer/IBalancerBptToken.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/external/balancer/IBalancerBptToken.sol)\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBalancerBptToken is IERC20 {\\n    function getActualSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/balancer/IBalancerHelpers.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/external/balancer/IBalancerHelpers.sol)\\n\\nimport { IBalancerVault } from \\\"contracts/interfaces/external/balancer/IBalancerVault.sol\\\";\\n\\ninterface IBalancerHelpers {\\n    function queryJoin(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        IBalancerVault.JoinPoolRequest memory request\\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn);\\n\\n    function queryExit(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        IBalancerVault.ExitPoolRequest memory request\\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut);\\n}\"\r\n    },\r\n    \"contracts/interfaces/external/balancer/IBalancerVault.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/external/balancer/IBalancerVault.sol)\\n\\ninterface IBalancerVault {\\n\\n  struct JoinPoolRequest {\\n    address[] assets;\\n    uint256[] maxAmountsIn;\\n    bytes userData;\\n    bool fromInternalBalance;\\n  }\\n\\n  struct ExitPoolRequest {\\n    address[] assets;\\n    uint256[] minAmountsOut;\\n    bytes userData;\\n    bool toInternalBalance;\\n  }\\n\\n  struct BatchSwapStep {\\n    bytes32 poolId;\\n    uint256 assetInIndex;\\n    uint256 assetOutIndex;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  struct FundManagement {\\n    address sender;\\n    bool fromInternalBalance;\\n    address payable recipient;\\n    bool toInternalBalance;\\n  }\\n\\n  enum JoinKind { \\n    INIT, \\n    EXACT_TOKENS_IN_FOR_BPT_OUT, \\n    TOKEN_IN_FOR_EXACT_BPT_OUT, \\n    ALL_TOKENS_IN_FOR_EXACT_BPT_OUT \\n  }\\n\\n  enum SwapKind {\\n    GIVEN_IN,\\n    GIVEN_OUT\\n  }\\n\\n  function batchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] memory swaps,\\n    address[] memory assets,\\n    FundManagement memory funds,\\n    int256[] memory limits,\\n    uint256 deadline\\n  ) external returns (int256[] memory assetDeltas);\\n\\n  function joinPool(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    JoinPoolRequest memory request\\n  ) external payable;\\n\\n  function exitPool( \\n    bytes32 poolId, \\n    address sender, \\n    address recipient, \\n    ExitPoolRequest memory request \\n  ) external;\\n\\n  function getPoolTokens(\\n    bytes32 poolId\\n  ) external view\\n    returns (\\n      address[] memory tokens,\\n      uint256[] memory balances,\\n      uint256 lastChangeBlock\\n  );\\n}\"\r\n    },\r\n    \"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/access/ITempleElevatedAccess.sol)\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\ninterface ITempleElevatedAccess {\\n    event ExplicitAccessSet(address indexed account, bytes4 indexed fnSelector, bool indexed value);\\n    event RescueModeSet(bool indexed value);\\n\\n    event NewRescuerProposed(address indexed oldRescuer, address indexed oldProposedRescuer, address indexed newProposedRescuer);\\n    event NewRescuerAccepted(address indexed oldRescuer, address indexed newRescuer);\\n\\n    event NewExecutorProposed(address indexed oldExecutor, address indexed oldProposedExecutor, address indexed newProposedExecutor);\\n    event NewExecutorAccepted(address indexed oldExecutor, address indexed newExecutor);\\n\\n    struct ExplicitAccess {\\n        bytes4 fnSelector;\\n        bool allowed;\\n    }\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute emergency operations.\\n     */ \\n    function rescuer() external returns (address);\\n\\n    /**\\n     * @notice A set of addresses which are approved to execute normal operations on behalf of the DAO.\\n     */ \\n    function executor() external returns (address);\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    function explicitFunctionAccess(address contractAddr, bytes4 functionSelector) external returns (bool);\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    function inRescueMode() external returns (bool);\\n    \\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers or executors are allowed to set.\\n     */\\n    function setRescueMode(bool value) external;\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external;\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or resucer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external;\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external;\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v2/ITreasuryPriceIndexOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (interfaces/v2/ITreasuryPriceIndexOracle.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\n\\n/**\\n * @title Treasury Price Index Oracle\\n * @notice The custom oracle (not dependant on external markets/AMMs/dependencies) to give the\\n * Treasury Price Index, representing the target Treasury Value per token.\\n * This rate is updated manually with elevated permissions. The new TPI doesn't take effect until after a cooldown.\\n */\\ninterface ITreasuryPriceIndexOracle is ITempleElevatedAccess {\\n    event TreasuryPriceIndexSet(uint96 oldTpi, uint96 newTpi);\\n    event TpiCooldownSet(uint32 cooldownSecs);\\n    event MaxTreasuryPriceIndexDeltaSet(uint256 maxDelta);\\n\\n    error BreachedMaxTpiDelta(uint96 oldTpi, uint96 newTpi, uint256 maxDelta);\\n\\n    /**\\n     * @notice The current Treasury Price Index (TPI) value\\n     * @dev If the TPI has just been updated, the old TPI will be used until `cooldownSecs` has elapsed\\n     */\\n    function treasuryPriceIndex() external view returns (uint96);\\n\\n    /**\\n     * @notice The maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev Used as a bound to avoid unintended/fat fingering when updating TPI\\n     */\\n    function maxTreasuryPriceIndexDelta() external view returns (uint256);\\n\\n    /**\\n     * @notice The current internal TPI data along with when it was last reset, and the prior value\\n     */\\n    function tpiData() external view returns (\\n        uint96 currentTpi,\\n        uint96 previousTpi,\\n        uint32 lastUpdatedAt,\\n        uint32 cooldownSecs\\n    );\\n\\n    /**\\n     * @notice Set the Treasury Price Index (TPI)\\n     */\\n    function setTreasuryPriceIndex(uint96 value) external;\\n\\n    /**\\n     * @notice Set the number of seconds to elapse before a new TPI will take effect.\\n     */\\n    function setTpiCooldown(uint32 cooldownSecs) external;\\n\\n    /**\\n     * @notice Set the maximum allowed TPI change on any single `setTreasuryPriceIndex()`, in absolute terms.\\n     * @dev 18 decimal places, 0.20e18 == $0.20\\n     */\\n    function setMaxTreasuryPriceIndexDelta(uint256 maxDelta) external;\\n\\n    /**\\n     * @notice The decimal precision of Temple Price Index (TPI)\\n     * @dev 18 decimals, so 1.02e18 == $1.02\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function TPI_DECIMALS() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/v2/access/TempleElevatedAccess.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Temple (v2/access/TempleElevatedAccess.sol)\\n\\nimport { ITempleElevatedAccess } from \\\"contracts/interfaces/v2/access/ITempleElevatedAccess.sol\\\";\\nimport { CommonEventsAndErrors } from \\\"contracts/common/CommonEventsAndErrors.sol\\\";\\n\\n/**\\n * @notice Inherit to add Executor and Rescuer roles for DAO elevated access.\\n */ \\nabstract contract TempleElevatedAccess is ITempleElevatedAccess {\\n    /**\\n     * @notice The address which is approved to execute emergency operations.\\n     */ \\n    address public override rescuer;\\n\\n    /**\\n     * @notice The address which is approved to execute normal operations on behalf of the DAO.\\n     */ \\n    address public override executor;\\n\\n    /**\\n     * @notice Explicit approval for an address to execute a function.\\n     * allowedCaller => function selector => true/false\\n     */\\n    mapping(address => mapping(bytes4 => bool)) public override explicitFunctionAccess;\\n\\n    /**\\n     * @notice Under normal circumstances, rescuers don't have access to admin/operational functions.\\n     * However when rescue mode is enabled (by rescuers or executors), they claim the access rights.\\n     */\\n    bool public override inRescueMode;\\n\\n    /// @dev Track proposed rescuer/executor\\n    address private _proposedNewRescuer;\\n    address private _proposedNewExecutor;\\n\\n    constructor(address initialRescuer, address initialExecutor) {\\n        if (initialRescuer == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        if (initialExecutor == initialRescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        rescuer = initialRescuer;\\n        executor = initialExecutor;\\n    }\\n\\n    /**\\n     * @notice Set the contract into or out of rescue mode.\\n     * Only the rescuers are allowed to set.\\n     */\\n    function setRescueMode(bool value) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        emit RescueModeSet(value);\\n        inRescueMode = value;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Rescuer.\\n     * Can only be called by the current rescuer.\\n     */\\n    function proposeNewRescuer(address account) external override {\\n        if (msg.sender != rescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewRescuerProposed(msg.sender, _proposedNewRescuer, account);\\n        _proposedNewRescuer = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Rescuer.\\n     * Can only be called by the proposed rescuer\\n     */\\n    function acceptRescuer() external override {\\n        if (msg.sender != _proposedNewRescuer) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == executor) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewRescuerAccepted(rescuer, msg.sender);\\n        rescuer = msg.sender;\\n        delete _proposedNewRescuer;\\n    }\\n\\n    /**\\n     * @notice Proposes a new Executor.\\n     * Can only be called by the current executor or rescuer (if in resuce mode)\\n     */\\n    function proposeNewExecutor(address account) external override onlyElevatedAccess {\\n        if (account == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        emit NewExecutorProposed(executor, _proposedNewExecutor, account);\\n        _proposedNewExecutor = account;\\n    }\\n\\n    /**\\n     * @notice Caller accepts the role as new Executor.\\n     * Can only be called by the proposed executor\\n     */\\n    function acceptExecutor() external override {\\n        if (msg.sender != _proposedNewExecutor) revert CommonEventsAndErrors.InvalidAccess();\\n        if (msg.sender == rescuer) revert CommonEventsAndErrors.InvalidAddress();\\n\\n        emit NewExecutorAccepted(executor, msg.sender);\\n        executor = msg.sender;\\n        delete _proposedNewExecutor;\\n    }\\n\\n    /**\\n     * @notice Grant `allowedCaller` the rights to call the function selectors in the access list.\\n     * @dev fnSelector == bytes4(keccak256(\\\"fn(argType1,argType2,...)\\\"))\\n     */\\n    function setExplicitAccess(address allowedCaller, ExplicitAccess[] calldata access) external override onlyElevatedAccess {\\n        if (allowedCaller == address(0)) revert CommonEventsAndErrors.InvalidAddress();\\n        uint256 _length = access.length;\\n        ExplicitAccess memory _access;\\n        for (uint256 i; i < _length; ++i) {\\n            _access = access[i];\\n            emit ExplicitAccessSet(allowedCaller, _access.fnSelector, _access.allowed);\\n            explicitFunctionAccess[allowedCaller][_access.fnSelector] = _access.allowed;\\n        }\\n    }\\n\\n    function isElevatedAccess(address caller, bytes4 fnSelector) internal view returns (bool) {\\n        if (inRescueMode) {\\n            // If we're in rescue mode, then only the rescuers can call\\n            return caller == rescuer;\\n        } else if (caller == executor || explicitFunctionAccess[caller][fnSelector]) {\\n            // If we're not in rescue mode, the executor can call all functions\\n            // or the caller has been given explicit access on this function\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Under normal operations, only the executors are allowed to call.\\n     * If 'rescue mode' has been enabled, then only the rescuers are allowed to call.\\n     * @dev Important: Only for use when called from an *external* contract. \\n     * If a function with this modifier is called internally then the `msg.sig` \\n     * will still refer to the top level externally called function.\\n     */\\n    modifier onlyElevatedAccess() {\\n        if (!isElevatedAccess(msg.sender, msg.sig)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only the executors or rescuers can call.\\n     */\\n    modifier onlyInRescueMode() {\\n        if (!(inRescueMode && msg.sender == rescuer)) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n\\n    modifier notInRescueMode() {\\n        if (inRescueMode) revert CommonEventsAndErrors.InvalidAccess();\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialRescuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialExecutor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_balancerVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bptToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_amoStaking\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_protocolTokenIndexInPool\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_balancerPoolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxRebalanceFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"AboveCappedAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidBPSValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBalancerVaultRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bptMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"templeMaxAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidMaxAmounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughCooldown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroSwapLimit\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptAmount\",\"type\":\"uint256\"}],\"name\":\"DepositAndStakeBptTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"ExplicitAccessSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptReceived\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptRemoved\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedExecutor\",\"type\":\"address\"}],\"name\":\"NewExecutorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProposedRescuer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposedRescuer\",\"type\":\"address\"}],\"name\":\"NewRescuerProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceDownExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptTokensStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceDownJoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebalanceJoinFeeBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebalanceExitFeeBps\",\"type\":\"uint256\"}],\"name\":\"RebalanceFeesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceUpExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptTokensStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceUpJoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoveredToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"RescueModeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"cooldownSecs\",\"type\":\"uint64\"}],\"name\":\"SetCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptMaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteTokenMaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolTokenMaxAmount\",\"type\":\"uint256\"}],\"name\":\"SetMaxRebalanceAmounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolHelper\",\"type\":\"address\"}],\"name\":\"SetPoolHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"deltaBps\",\"type\":\"uint64\"}],\"name\":\"SetPostRebalanceDelta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"belowTpi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"aboveTpi\",\"type\":\"uint64\"}],\"name\":\"SetRebalancePercentageBounds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"TokenVaultSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tpiOracle\",\"type\":\"address\"}],\"name\":\"TpiOracleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BPS_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IBalancerVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptTokensStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amoStaking\",\"outputs\":[{\"internalType\":\"contract IAuraStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerPoolId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerVault\",\"outputs\":[{\"internalType\":\"contract IBalancerVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bptToken\",\"outputs\":[{\"internalType\":\"contract IBalancerBptToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownSecs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useContractBalance\",\"type\":\"bool\"}],\"name\":\"depositAndStakeBptTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"explicitFunctionAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRescueMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebalanceTimeSecs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRebalanceAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bpt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRebalanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHelper\",\"outputs\":[{\"internalType\":\"contract IBalancerPoolHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteTokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postRebalanceDelta\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeNewRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolTokenBalancerPoolIndex\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteTokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"rebalanceDownExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"protocolTokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBptOut\",\"type\":\"uint256\"}],\"name\":\"rebalanceDownJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceFees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"rebalanceJoinFeeBps\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rebalanceExitFeeBps\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalancePercentageBoundLow\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalancePercentageBoundUp\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minProtocolTokenOut\",\"type\":\"uint256\"}],\"name\":\"rebalanceUpExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteTokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBptOut\",\"type\":\"uint256\"}],\"name\":\"rebalanceUpJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IBalancerVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"bptIn\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_seconds\",\"type\":\"uint64\"}],\"name\":\"setCoolDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allowedCaller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"internalType\":\"struct ITempleElevatedAccess.ExplicitAccess[]\",\"name\":\"access\",\"type\":\"tuple[]\"}],\"name\":\"setExplicitAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bptMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteTokenMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolTokenMaxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxRebalanceAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolHelper\",\"type\":\"address\"}],\"name\":\"setPoolHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"deltaBps\",\"type\":\"uint64\"}],\"name\":\"setPostRebalanceDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebalanceJoinFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebalanceExitFeeBps\",\"type\":\"uint256\"}],\"name\":\"setRebalanceFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"belowTpi\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"aboveTpi\",\"type\":\"uint64\"}],\"name\":\"setRebalancePercentageBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setRescueMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setTokenVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTpiOracle\",\"type\":\"address\"}],\"name\":\"setTpiOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenVault\",\"outputs\":[{\"internalType\":\"contract IRamosTokenVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tpiOracle\",\"outputs\":[{\"internalType\":\"contract ITreasuryPriceIndexOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryPriceIndex\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Ramos", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000009f90430179d9b67341bfa50559bc7b8e35629f1b000000000000000000000000b1e8ab0a81aadf632a653e46caeda1593d71d143000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c8000000000000000000000000470ebf5f030ed85fc1ed4c2d36b9dd02e77cf1b70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000008bd4a1e74a27182d23b98c10fd21d4fbb0ed4ba0000000000000000000000000940b35488bb153b703b7c9ab3fe2c03ce48d665000000000000000000000000000000000000000000000000000000000000000008bd4a1e74a27182d23b98c10fd21d4fbb0ed4ba00002000000000000000004ed0000000000000000000000004d6175d58c5aceef30f546c0d5a557effa53a9500000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}