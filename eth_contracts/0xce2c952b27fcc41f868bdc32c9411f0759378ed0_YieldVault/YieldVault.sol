/**
 *Submitted for verification at Etherscan.io on 2023-07-05
*/

//SPDX-License-Identifier: UNLICENSED
/*                              
                    CHAINTOOLS 2023. DEFI REIMAGINED

                                                               2023

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀            2021           ⣰⣾⣿⣶⡄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2019⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠹⣿V4⡄⡷⠀⠀⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⢀⠀⠀⠀⠀⠀⠀⠀⠀ ⣤⣾⣿⣷⣦⡀⠀⠀⠀⠀   ⣿⣿⡏⠁⠀⠀⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⢀⣴⣿⣿⣿⣷⡀⠀⠀⠀⠀ ⢀⣿⣿⣿⣿⣿⠄⠀⠀⠀  ⣰⣿⣿⣧⠀⠀⠀⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⢀⣴⣾⣿⣿⣿⣿⣿⣿⡄⠀⠀ ⢀⣴⣿⣿⣿⠟⠛⠋⠀⠀⠀ ⢸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⢀⣴⣿⣿⣿⣿⣿⠟⠉⠉⠉⠁⢀⣴⣿⣿V3⣿⣿⠀⠀⠀⠀⠀  ⣾⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⣾⣿⣿⣿⣿⣿⠛⠀⠀⠀⠀⠀ ⣾⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀ ⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀   
⠀⠀⠀        2017⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿V2⣿⣿⡿⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀ ⢹⣿ ⣿⣿⣿⣿⠙⢿⣆⠀⠀⠀   
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣴⣦⣤⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠈⢻⣿⣿⣿⣿⠛⠿⠿⠶⠶⣶⠀  ⣿ ⢸⣿⣿⣿⣿⣆⠹⠇⠀⠀   
⠀⠀⠀⠀⠀⠀⢀⣠⣴⣿⣿⣿⣿⣷⡆⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⡇⠉⠛⢿⣷⡄⠀⠀⠀⢸⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀  ⠹⠇⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀   
⠀⠀⠀⠀⣠⣴⣿⣿V1⣿⣿⣿⡏⠛⠃⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣇⠀⠀⠘⠋⠁⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀  ⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀   
⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀ ⠸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀  ⠀⣿⣿⡟⢿⣿⣿⠀⠀⠀⠀   
⠀⢸⣿⣿⣿⣿⣿⠛⠉⠙⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀ ⢈⣿⣿⡟⢹⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⡿⠈⣿⣿⡟⠀⠀⠀⠀⠀  ⢸⣿⣿⠀⢸⣿⣿⠀⠀⠀⠀   
⠀⠀⠹⣿⣿⣿⣿⣷⡀⠀⠻⣿⣿⣿⣿⣶⣄⠀⠀⠀⢰⣿⣿⡟⠁⣾⣿⣿⠀⠀⠀⠀⠀⠀⢀⣶⣿⠟⠋⠀⢼⣿⣿⠃⠀⠀⠀⠀⠀  ⣿⣿⠁⠀⢹⣿⣿⠀⠀⠀⠀   
⠀⢀⣴⣿⡿⠋⢹⣿⡇⠀⠀⠈⠙⣿⣇⠙⣿⣷⠀⠀⢸⣿⡟⠀⠀⢻⣿⡏⠀⠀⠀⠀⠀⢀⣼⡿⠁⠀⠀⠀⠘⣿⣿⠀⠀⠀⠀⠀   ⢨⣿⡇⠀⠀⠀⣿⣿⠀⠀⠀⠀   
⣴⣿⡟⠉⠀⠀⣾⣿⡇⠀⠀⠀⠀⢈⣿⡄⠀⠉⠀⠀⣼⣿⡆⠀⠀⢸⣿⣷⠀⠀⠀⠀⢴⣿⣿⠀⠀⠀⠀⠀⠀⣿⣯⡀⠀⠀⠀⠀    ⢸⣿⣇⠀⠀⠀⢺⣿⡄⠀⠀⠀   
⠈⠻⠷⠄⠀⠀⣿⣿⣷⣤⣠⠀⠀⠈⠽⠷⠀⠀⠀⠸⠟⠛⠛⠒⠶⠸⣿⣿⣷⣦⣤⣄⠈⠻⠷⠄⠀⠀⠀⠾⠿⠿⣿⣶⣤⠀    ⠘⠛⠛⠛⠒⠀⠸⠿⠿⠦ 


Telegram: https://t.me/ChaintoolsOfficial
Website: https://www.chaintools.ai/
Whitepaper: https://chaintools-whitepaper.gitbook.io/
Twitter: https://twitter.com/ChaintoolsTech
dApp: https://www.chaintools.wtf/
*/

pragma solidity ^0.8.20;

// import "forge-std/console.sol";
interface ChainTools {
function swapBack() external;
function getUpperRef(address) external view returns(address);
function flashReward() external;
function getYieldBooster() external view returns (address yb);
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

interface IERC20Metadata is IERC20 {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IUniswapV2Router02 {
    function getAmountsOut(uint256 amountIn, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );
}

interface IV2Pair {
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function token0() external view returns (address);

    function burn(address to)
        external
        returns (uint256 amount0, uint256 amount1);
}

interface IV3Pool {
    function liquidity() external view returns (uint128 Liq);

    struct Info {
        uint128 liquidity;
        uint256 feeGrowthInside0LastX128;
        uint256 feeGrowthInside1LastX128;
        uint128 tokensOwed0;
        uint128 tokensOwed1;
    }

    function initialize(uint160 sqrtPriceX96) external;

    function positions(bytes32 key)
        external
        view
        returns (IV3Pool.Info memory liqInfo);

    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes memory data
    ) external returns (int256 amount0, int256 amount1);

    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function slot0()
        external
        view
        returns (
            uint160,
            int24,
            uint16,
            uint16,
            uint16,
            uint8,
            bool
        );

    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes memory data
    ) external;

    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);
}

interface IWETH {
    function withdraw(uint256 wad) external;

    function approve(address who, uint256 wad) external returns (bool);

    function deposit() external payable;

    function transfer(address dst, uint256 wad) external returns (bool);

    function balanceOf(address _owner) external view returns (uint256);
}

interface IQuoterV2 {
    function quoteExactInputSingle(
        address tokenIn,
        address tokenOut,
        uint24 fee,
        uint256 amountIn,
        uint160 sqrtPriceLimitX96
    ) external returns (uint256 amountOut);
}

interface IV3Factory {
    function getPool(
        address token0,
        address token1,
        uint24 poolFee
    ) external view returns (address);

    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address);
}

interface INonfungiblePositionManager {
    function ownerOf(uint256 tokenId) external view returns (address owner);

    function setApprovalForAll(address operator, bool approved) external;

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    function increaseLiquidity(
        INonfungiblePositionManager.IncreaseLiquidityParams calldata params
    )
        external
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    function tokenOfOwnerByIndex(address owner, uint256 index)
        external
        view
        returns (uint256 tokenId);

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) external;

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function factory() external view returns (address);

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    function mint(MintParams calldata mp)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    function collect(CollectParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    function decreaseLiquidity(DecreaseLiquidityParams calldata dl)
        external
        returns (uint256 amount0, uint256 amount1);

    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );
}

interface IRouterV3 {
    function factory() external view returns (address);

    function WETH9() external view returns (address);

    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    function exactOutputSingle(ExactOutputSingleParams calldata params)
        external
        returns (uint256 amountIn);

    function exactInputSingle(ExactInputSingleParams calldata params)
        external
        payable
        returns (uint256 amountOut);
}
contract YieldVault {
    struct Pending {
        uint128 amount0;
        uint128 amount1;
    }

    INonfungiblePositionManager internal immutable positionManager;

    address internal immutable quoter;
    address internal immutable CTLS;
    address internal immutable WETH;
    address internal immutable multiSig;
    address internal immutable v3Router;
    address internal immutable uniswapV3Pool;
    address public keeper;
    uint256 internal minCompAmtETH = 2e17;

    mapping(uint256 => Pending) internal balances;
    mapping(address => uint128) internal refBalances;

    error Auth();
    error Max0();
    error Max1();

    event referralPaid(
        address indexed from,
        address indexed to,
        uint256 amount
    );
    event Compounded(uint256 indexed tokenId, uint256 c0, uint256 c1);
    event ShiftedPosition(
        uint256 indexed tokenIdOld,
        uint256 indexed tokenIdNew,
        uint256 flag,
        uint256 t0,
        uint256 t1
    );
    event BoughtBack(uint256 indexed flag, uint256 a0, uint256 a1);
    event limitOrderCreated(
        address indexed who,
        uint256 tokenId,
        uint256 flag,
        uint256 amount0Or1,
        bool isWETH
    );

    constructor(
        address _CTLS,
        address _keeper,
        address _uniPool,
        address _dev
    ) {
        positionManager = INonfungiblePositionManager(
            0xC36442b4a4522E871399CD717aBDD847Ab11FE88
        );
        CTLS = _CTLS;
        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
        WETH = IRouterV3(v3Router).WETH9();
        IERC20(WETH).approve(address(positionManager), type(uint256).max);

        quoter = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;
        keeper = _keeper;
        multiSig = _dev;
        IERC20(WETH).approve(address(v3Router), type(uint256).max);

        uniswapV3Pool = _uniPool;
    }

    //CallStatic
    function filterReady(
        uint256[] calldata tokenIds,
        uint256 minAmount0,
        uint256 minAmount1
    )
        external
        returns (
            uint256[] memory readyToComp,
            uint256[] memory amt0,
            uint256[] memory amt1,
            uint256 gasSpent,
            uint256 txCostInETH
        )
    {
        if (msg.sender != keeper) revert Auth();
        unchecked {
            try ChainTools(payable(CTLS)).swapBack() {} catch {}
            try ChainTools(payable(CTLS)).flashReward() {} catch {}

            uint256 startGas = gasleft();
            uint256 tokenIdsL = tokenIds.length;
            readyToComp = new uint256[](tokenIdsL);
            amt0 = new uint256[](tokenIdsL);
            amt1 = new uint256[](tokenIdsL);
            for (uint256 i; i < tokenIdsL; ) {
                uint256 tokenId = tokenIds[i];
                address tokenOwner = positionManager.ownerOf(tokenId);
                if (tokenId != 0) {
                    try
                        positionManager.collect(
                            INonfungiblePositionManager.CollectParams({
                                tokenId: tokenId,
                                recipient: address(this),
                                amount0Max: type(uint128).max,
                                amount1Max: type(uint128).max
                            })
                        )
                    returns (uint256 claimed0, uint256 claimed1) {
                        Pending memory pen = balances[tokenId];
                        refBalances[
                            ChainTools(payable(CTLS)).getUpperRef(tokenOwner)
                        ] = uint128(claimed0 / 100);
                        balances[1].amount0 += uint128(claimed0 / 20);
                        balances[1].amount1 += uint128(claimed1 / 25);
                        claimed0 -= (claimed0 / 20) + (claimed0 / 100);
                        claimed1 -= claimed1 / 25;

                        //Add Pending Earned Referral Rewards into Personal Pending Rewards
                        pen.amount0 +=
                            uint128(claimed0) +
                            refBalances[tokenOwner];
                        pen.amount1 += uint128(claimed1);

                        //Reset pending referal
                        refBalances[tokenOwner] = 0;
                        if (claimed0 > minAmount0 && claimed1 > minAmount1) {
                            readyToComp[i] = tokenId;
                            amt0[i] = claimed0;
                            amt1[i] = claimed1;
                        }

                        balances[tokenId] = pen;
                    } catch {}
                }

                ++i;
            }

            gasSpent = startGas - gasleft();
            txCostInETH = tx.gasprice * gasSpent;
        }
    }

    function unite(uint256[] calldata tokenIds)
        external
        returns (
            uint256[] memory reverting,
            uint256 pFee0,
            uint256 pFee1
        )
    {
        if (msg.sender != keeper) revert Auth();
        unchecked {
            try ChainTools(payable(CTLS)).swapBack() {} catch {}
            try ChainTools(payable(CTLS)).flashReward() {} catch {}

            uint256 tokenIdsL = tokenIds.length;
            reverting = new uint256[](tokenIds.length);
            for (uint256 i; i < tokenIdsL; ) {
                uint256 tokenId = tokenIds[i];
                address tokenOwner = positionManager.ownerOf(tokenId);
                try
                    positionManager.collect(
                        INonfungiblePositionManager.CollectParams({
                            tokenId: tokenId,
                            recipient: address(this),
                            amount0Max: type(uint128).max,
                            amount1Max: type(uint128).max
                        })
                    )
                returns (uint256 claimed0, uint256 claimed1) {
                    Pending memory pen = balances[tokenId];

                    //Compound Tax + Token Tax (10% TOTAL) [5% in WETH] [5% in TOKENS]
                    //9% protocol, 1% ref
                    pFee0 = claimed0 / 20;
                    pFee1 = claimed1 / 25;
                    uint256 rFee0 = claimed0 / 100;

                    claimed0 -= (pFee0 + rFee0);
                    claimed1 -= pFee1;

                    balances[1].amount0 += uint128(pFee0);
                    balances[1].amount1 += uint128(pFee1);

                    //Determine Referal
                    refBalances[
                        ChainTools(payable(CTLS)).getUpperRef(tokenOwner)
                    ] = uint128(rFee0);

                    //Add Pending Earned Referral Rewards into Personal Pending Rewards
                    pen.amount0 += uint128(claimed0) + refBalances[tokenOwner];
                    pen.amount1 += uint128(claimed1);

                    //Reset pending referal
                    refBalances[tokenOwner] = 0;

                    if (claimed0 != 0 && claimed1 != 0) {
                        try this.increaseLiq(tokenId, pen) {} catch {
                            //CallStatic catch reverting -> exclude from call
                            //If revert during real call, update balances to sync referral rewards
                            balances[tokenId] = pen;
                            reverting[i] = tokenId;
                        }
                    } else {
                        reverting[i] = tokenId;
                        balances[tokenId] = pen;
                    }
                } catch {
                    reverting[i] = tokenId;
                }

                ++i;
            }
        }
    }

    function increaseLiq(uint256 tokenId, Pending memory pen)
        external
        returns (uint256 collected0, uint256 collected1)
    {
        if (msg.sender != address(this)) revert Auth();
        (, collected0, collected1) = positionManager.increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: tokenId,
                amount0Desired: pen.amount0,
                amount1Desired: pen.amount1,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            })
        );
        if (
            collected0 > pen.amount0 &&
            collected0 > IERC20(WETH).balanceOf(address(this))
        ) revert Max0();
        if (
            collected1 > pen.amount1 &&
            collected1 > IERC20(CTLS).balanceOf(address(this))
        ) revert Max1();
        balances[tokenId].amount0 = (pen.amount0 - uint128(collected0));
        balances[tokenId].amount1 = (pen.amount1 - uint128(collected1));
        emit Compounded(tokenId, collected0, collected1);
    }

    function withdraw_yield(
        uint256 tokenId,
        uint128 amount0,
        uint128 amount1
    ) public {
        address tokenOwner = positionManager.ownerOf(tokenId);
        if (tokenId == 1) tokenOwner = multiSig;
        if (tokenOwner != msg.sender) revert Auth();
        unchecked {
            if (amount0 == 0 && amount1 == 0) {
                amount0 = balances[tokenId].amount0;
                amount1 = balances[tokenId].amount1;
                balances[tokenId].amount0 = 0;
                balances[tokenId].amount1 = 0;
                IERC20(WETH).transfer(tokenOwner, amount0);
                IERC20(CTLS).transfer(tokenOwner, amount1);
            } else if (amount0 != 0 && amount1 != 0) {
                if (amount0 > balances[tokenId].amount0) revert Max0();
                if (amount1 > balances[tokenId].amount1) revert Max1();
                balances[tokenId].amount0 -= amount0;
                balances[tokenId].amount1 -= amount1;

                IERC20(WETH).transfer(tokenOwner, amount0);
                IERC20(CTLS).transfer(tokenOwner, amount1);
            } else if (amount0 == 0 && amount1 != 0) {
                if (amount1 > balances[tokenId].amount1) revert Max1();
                balances[tokenId].amount1 -= amount1;
                IERC20(CTLS).transfer(tokenOwner, amount1);
            } else if (amount0 != 0 && amount1 == 0) {
                if (amount0 > balances[tokenId].amount0) revert Max0();
                balances[tokenId].amount0 -= amount0;
                IERC20(WETH).transfer(tokenOwner, amount0);
            }
        }
    }

    function withdraw_yield_many(
        uint256[] calldata tokenIds,
        uint128[] calldata amt0,
        uint128[] calldata amt1
    ) external {
        unchecked {
            uint256 size = tokenIds.length;
            require(size == amt0.length && size == amt1.length, "L");
            for (uint256 i; i < size; ) {
                withdraw_yield(tokenIds[i], amt0[i], amt1[i]);

                ++i;
            }
        }
    }

    function withdraw_referral_rewards(uint128 amount0) external {
        unchecked {
            if (amount0 == 0) {
                amount0 = refBalances[msg.sender];
                refBalances[msg.sender] = 0;
                IERC20(WETH).transfer(msg.sender, amount0);
            } else if (amount0 != 0) {
                if (amount0 > refBalances[msg.sender]) revert Max0();
                refBalances[msg.sender] -= amount0;
                IERC20(WETH).transfer(msg.sender, amount0);
            }
        }
    }

    //PROTOCOL LP/FEES
    function buyback(
        uint256 flag,
        uint128 internalWETHAmt,
        uint128 internalTokenAmt,
        address to,
        uint256 id
    ) external returns (uint256 t0, uint256 t1) {
        if (tx.origin != keeper && msg.sender != multiSig) revert Auth();

        (t0, t1) = positionManager.collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: id,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        unchecked {
            balances[1].amount0 += uint128(t0);
            balances[1].amount1 += uint128(t1);
        }

        if (
            balances[1].amount0 >= internalWETHAmt &&
            balances[1].amount1 >= internalTokenAmt
        ) {
            unchecked {
                balances[1].amount0 -= internalWETHAmt;
                balances[1].amount1 -= internalTokenAmt;
            }

            if (flag == 0) {
                try ChainTools(payable(CTLS)).flashReward() {} catch {} //lp reward only
            } else if (flag == 1) {
                //buyback only
                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(
                    IRouterV3.ExactInputSingleParams({
                        tokenIn: WETH,
                        tokenOut: CTLS,
                        fee: 10000,
                        recipient: to,
                        deadline: block.timestamp,
                        amountIn: internalWETHAmt,
                        amountOutMinimum: 0,
                        sqrtPriceLimitX96: 0
                    })
                );
                emit BoughtBack(flag, internalWETHAmt, gotTokens);
            } else if (flag == 2) {
                //buyback+lp reward
                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(
                    IRouterV3.ExactInputSingleParams({
                        tokenIn: WETH,
                        tokenOut: CTLS,
                        fee: 10000,
                        recipient: ChainTools(payable(CTLS)).getYieldBooster(),
                        deadline: block.timestamp,
                        amountIn: (internalWETHAmt - (internalWETHAmt / 2)),
                        amountOutMinimum: 0,
                        sqrtPriceLimitX96: 0
                    })
                );
                emit BoughtBack(flag, internalWETHAmt, gotTokens);
                try ChainTools(payable(CTLS)).flashReward() {} catch {}
            } else if (flag == 3) {
                //buyback + swapback + send rewards
                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(
                    IRouterV3.ExactInputSingleParams({
                        tokenIn: WETH,
                        tokenOut: CTLS,
                        fee: 10000,
                        recipient: to,
                        deadline: block.timestamp,
                        amountIn: internalWETHAmt,
                        amountOutMinimum: 0,
                        sqrtPriceLimitX96: 0
                    })
                );
                emit BoughtBack(flag, internalWETHAmt, gotTokens);
                try ChainTools(payable(CTLS)).swapBack() {} catch {}
                try ChainTools(payable(CTLS)).flashReward() {} catch {}
            }
        } else {
            revert Max0();
        }
    }

    function _collectLPRewards(uint256 tokenId)
        internal
        returns (uint128 c0, uint128 c1)
    {
        (uint256 c0u, uint256 c1u) = positionManager.collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );

        c0 = uint128(c0u);
        c1 = uint128(c1u);
    }

    function _decreasePosition(uint256 tokenId, uint128 liquidity)
        internal
        returns (uint128 a0, uint128 a1)
    {
        positionManager.decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: tokenId,
                liquidity: liquidity,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            })
        );

        (a0, a1) = _collectLPRewards(tokenId);
    }

    function shiftPosition(
        uint256 tokenId,
        uint256 flag,
        uint256 min0Out,
        uint256 min1Out
    )
        external
        returns (
            uint256 newTokenId,
            uint256 min0,
            uint256 min1
        )
    {
        address tokenOwner = positionManager.ownerOf(tokenId);
        if (msg.sender != tokenOwner) revert Auth();
        (, , uint128 liq) = this.getPosition(tokenId);
        (uint128 WETHRemoved, uint128 tokensRemoved) = _decreasePosition(
            tokenId,
            liq
        );

        if (WETHRemoved > 1e6 && tokensRemoved >= 10e18) {
            //Token Tax (3% TOTAL) [1.5% in WETH] [1.5% in TOKENS]
            unchecked {
                liq = WETHRemoved / 100; //ref

                //protocol
                balances[1].amount0 += liq;
                balances[1].amount1 += tokensRemoved / 100;

                WETHRemoved -= liq * 2; //ref+protocol
                tokensRemoved -= tokensRemoved / 100;
            }

            {
                address upper = ChainTools(payable(CTLS)).getUpperRef(
                    tokenOwner
                );
                upper == address(0)
                    ? balances[1].amount0 += liq
                    : refBalances[upper] += liq;
                emit referralPaid(
                    tokenOwner,
                    upper == address(0) ? multiSig : upper,
                    liq
                );
            }

            (newTokenId, min0, min1) = _mintPosition(
                WETHRemoved,
                tokensRemoved,
                flag,
                msg.sender,
                false,
                min0Out,
                min1Out
            );

            if (min0 > WETHRemoved) revert Max0();
            if (min1 > tokensRemoved) revert Max1();
            balances[newTokenId].amount0 += uint128(WETHRemoved - min0);
            balances[newTokenId].amount1 += uint128(tokensRemoved - min1);

            emit ShiftedPosition(tokenId, newTokenId, flag, min0, min1);
        } else {
            revert("no_limit_orders");
        }
    }

    function createLimitOrderPosition(
        uint128 amount0Or1,
        uint256 flag,
        bool isToken0,
        uint256 min0Or1Out
    )
        external
        returns (
            uint256 newTokenId,
            uint256 min0,
            uint256 min1
        )
    {
        isToken0
            ? IERC20(WETH).transferFrom(msg.sender, address(this), amount0Or1)
            : IERC20(CTLS).transferFrom(msg.sender, address(this), amount0Or1);
        unchecked {
            uint128 pFee = amount0Or1 / 25;
            uint128 rFee0 = amount0Or1 / 100;
            amount0Or1 -= (pFee + rFee0);

            isToken0
                ? balances[1].amount0 += pFee
                : balances[1].amount1 += pFee;

            address upper = ChainTools(payable(CTLS)).getUpperRef(msg.sender);
            //Determine Referal
            upper == address(0)
                ? balances[1].amount0 += rFee0
                : refBalances[upper] += rFee0;
            emit referralPaid(
                msg.sender,
                upper == address(0) ? multiSig : upper,
                rFee0
            );
        }

        (newTokenId, min0, min1) = _mintPosition(
            isToken0 ? amount0Or1 : 0,
            isToken0 ? 0 : amount0Or1,
            flag,
            msg.sender,
            true,
            isToken0 ? min0Or1Out : 0,
            isToken0 ? 0 : min0Or1Out
        );
        if (isToken0) {
            _sendRefunds(amount0Or1 - min0, 0);
        } else {
            _sendRefunds(0, amount0Or1 - min1);
        }
        emit limitOrderCreated(
            msg.sender,
            newTokenId,
            flag,
            isToken0 ? min0 : min1,
            isToken0
        );
    }

    function _sendRefunds(uint256 amount0, uint256 amount1) internal {
        if (amount0 != 0) IERC20(WETH).transfer(msg.sender, amount0);
        if (amount1 >= 1e15) IERC20(CTLS).transfer(msg.sender, amount1);
    }

    function createNomralPosition(
        uint128 amount0,
        uint128 amount1,
        uint256 flag,
        uint256 min0,
        uint256 min1
    )
        external
        returns (
            uint256 tokenId,
            uint256 amt0Consumed,
            uint256 amt1Consumed
        )
    {
        IERC20(WETH).transferFrom(msg.sender, address(this), amount0);
        IERC20(CTLS).transferFrom(msg.sender, address(this), amount1);
        {
            uint128 pFee0 = amount0 / 50;
            uint128 pFee1 = amount1 / 50;
            uint128 rFee0 = amount0 / 100;
            balances[1].amount0 += pFee0;
            balances[1].amount1 += pFee1;

            amount0 -= (pFee0 + rFee0);
            amount1 -= pFee1;
            //Referral Tax [0.5%]
            address upper = ChainTools(payable(CTLS)).getUpperRef(msg.sender);
            upper == address(0)
                ? balances[1].amount0 += rFee0
                : refBalances[upper] += rFee0;
            emit referralPaid(
                msg.sender,
                upper == address(0) ? multiSig : upper,
                rFee0
            );

            (tokenId, amt0Consumed, amt1Consumed) = _mintPosition(
                amount0,
                amount1,
                flag,
                msg.sender,
                false,
                min0,
                min1
            );

            IERC20(WETH).transfer(msg.sender, amount0 - amt0Consumed);
            IERC20(CTLS).transfer(msg.sender, amount1 - amt1Consumed);
        }
    }

    function _mintPosition(
        uint256 amt0Desired,
        uint256 amt1Desired,
        uint256 flag,
        address to,
        bool isLimit,
        uint256 min0,
        uint256 min1
    )
        internal
        returns (
            uint256 tokenId,
            uint256 amt0Consumed,
            uint256 amt1Consumed
        )
    {
        int24 tick = this.getCurrentTick();
        int24 tickDist = this.getTickDistance(flag);

        if (!isLimit) {
            (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(
                INonfungiblePositionManager.MintParams({
                    token0: WETH,
                    token1: CTLS,
                    fee: 10000,
                    tickLower: tick - tickDist < int24(-887000)
                        ? int24(-887000)
                        : tick - tickDist,
                    tickUpper: tick + tickDist > int24(887000)
                        ? int24(887000)
                        : tick + tickDist,
                    amount0Desired: amt0Desired,
                    amount1Desired: amt1Desired,
                    amount0Min: min0,
                    amount1Min: min1,
                    recipient: to,
                    deadline: block.timestamp
                })
            );
        } else {
            (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(
                INonfungiblePositionManager.MintParams({
                    token0: WETH,
                    token1: CTLS,
                    fee: 10000,
                    tickLower: amt0Desired == 0 ? tick - tickDist : tick,
                    tickUpper: amt0Desired == 0 ? tick : tick + tickDist,
                    amount0Desired: amt0Desired,
                    amount1Desired: amt1Desired,
                    amount0Min: min0,
                    amount1Min: min1,
                    recipient: to,
                    deadline: block.timestamp
                })
            );
        }
    }

    //GETTERS
    function balanceOf(uint256 tokenId)
        external
        view
        returns (uint128 balance0, uint128 balance1)
    {
        balance0 = balances[tokenId].amount0;
        balance1 = balances[tokenId].amount1;
    }

    function balanceOfReferal(address who)
        external
        view
        returns (uint128 amount0)
    {
        return refBalances[who];
    }

    function balanceOfMany(uint256[] calldata tokenIds)
        external
        view
        returns (
            uint128 balance0Total,
            uint128 balance1Total,
            uint256[] memory returnTokenIds,
            uint128[] memory balances0,
            uint128[] memory balances1
        )
    {
        uint256 size = tokenIds.length;
        balances0 = new uint128[](size);
        balances1 = new uint128[](size);

        unchecked {
            for (uint256 i; i < size; ++i) {
                uint256 tokenId = tokenIds[i];
                uint128 bal0 = balances[tokenId].amount0;
                uint128 bal1 = balances[tokenId].amount1;

                balance0Total += bal0;
                balance1Total += bal1;

                balances0[i] = bal0;
                balances1[i] = bal1;
            }
        }

        returnTokenIds = tokenIds;
    }

    function findPoolFee(address token0, address token1)
        public
        view
        returns (uint24 poolFee)
    {
        address factory = IRouterV3(v3Router).factory();
        uint128 highestLiq;
        try IV3Factory(factory).getPool(token0, token1, 100) returns (
            address pool100
        ) {
            if (pool100 != address(0)) {
                try IV3Pool(pool100).liquidity() returns (uint128 liq) {
                    if (liq > highestLiq) {
                        poolFee = 100;
                        highestLiq = liq;
                    }
                } catch {}
            }
        } catch {}
        try IV3Factory(factory).getPool(token0, token1, 500) returns (
            address pool500
        ) {
            if (pool500 != address(0)) {
                try IV3Pool(pool500).liquidity() returns (uint128 liq) {
                    if (liq > highestLiq) {
                        poolFee = 500;
                        highestLiq = liq;
                    }
                } catch {}
            }
        } catch {}
        try IV3Factory(factory).getPool(token0, token1, 3000) returns (
            address pool3000
        ) {
            if (pool3000 != address(0)) {
                try IV3Pool(pool3000).liquidity() returns (uint128 liq) {
                    if (liq > highestLiq) {
                        poolFee = 3000;
                        highestLiq = liq;
                    }
                } catch {}
            }
        } catch {}

        try IV3Factory(factory).getPool(token0, token1, 10000) returns (
            address pool10000
        ) {
            if (pool10000 != address(0)) {
                try IV3Pool(pool10000).liquidity() returns (uint128 liq) {
                    if (liq > highestLiq) {
                        poolFee = 10000;
                        highestLiq = liq;
                    }
                } catch {}
            }
        } catch {}
    }

    function getPosition(uint256 tokenId)
        external
        view
        returns (
            address token0,
            address token1,
            uint128 liquidity
        )
    {
        (, , token0, token1, , , , liquidity, , , , ) = positionManager
            .positions(tokenId);
    }

    function getDeviation(uint256 amountIn, uint256 startTickDeviation)
        external
        pure
        returns (uint256 adjusted)
    {
        adjusted = (amountIn * (10000 + startTickDeviation)) / 20000;
    }

    function getStartTickDeviation(int24 currentTick)
        external
        pure
        returns (uint256 perc)
    {
        int24 startTickDeviation;

        if (currentTick > -106400) {
            startTickDeviation = currentTick + -106400;
        } else {
            startTickDeviation = -106400 + currentTick;
        }
        if (startTickDeviation < 0) {
            startTickDeviation = -startTickDeviation;
        }
        perc = (uint256(int256(startTickDeviation)) * 75) / 107400;
    }

    function getCurrentTick() external view returns (int24 cTick) {
        (, cTick, , , , , ) = IV3Pool(uniswapV3Pool).slot0();
        cTick = (cTick / 200) * 200;
    }

    function getTickDistance(uint256 flag)
        external
        pure
        returns (int24 tickDistance)
    {
        if (flag == 0) {
            //default
            tickDistance = 30000;
        } else if (flag == 1) {
            tickDistance = 20000;
        } else if (flag == 2) {
            tickDistance = 10000;
        } else if (flag == 3) {
            tickDistance = 5000;
        } else if (flag == 4) {
            tickDistance = 2000;
        } else {
            revert("invalid_flag");
        }
    }

    function findApprovalToken(address pool)
        external
        view
        returns (address token)
    {
        return
            this.findApprovalToken(
                IV3Pool(pool).token0(),
                IV3Pool(pool).token1()
            );
    }

    function findApprovalToken(address token0, address token1)
        external
        view
        returns (address token)
    {
        require(token0 == WETH || token1 == WETH, "Not WETH Pair");
        token = token0 == WETH ? token1 : token0;
        if (token == CTLS || token == WETH) {
            token = address(0);
        }
    }
}