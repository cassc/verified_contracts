{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cowProtocol/interfaces/GPv2EIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.12;\\n\\nlibrary GPv2EIP1271 {\\n    /// @dev Value returned by a call to `isValidSignature` if the signature\\n    /// was verified successfully. The value is defined in EIP-1271 as:\\n    /// bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\n}\\n\\n/// @title EIP1271 Interface\\n/// @dev Standardized interface for an implementation of smart contract\\n/// signatures as described in EIP-1271. The code that follows is identical to\\n/// the code in the standard with the exception of formatting and syntax\\n/// changes to adapt the code to our Solidity version.\\ninterface EIP1271Verifier {\\n    /// @dev Should return whether the signature provided is valid for the\\n    /// provided data\\n    /// @param _hash      Hash of the data to be signed\\n    /// @param _signature Signature byte array associated with _data\\n    ///\\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\\n    /// solc > 0.5)\\n    /// MUST allow external calls\\n    ///\\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\\n        external\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/cowProtocol/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Added `name`, `symbol` and `decimals` function declarations\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals the token uses.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/cowProtocol/libraries/GPv2Order.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Order Library\\n/// @author Gnosis Developers\\nlibrary GPv2Order {\\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\\n    /// all order parameters that are signed for submitting to GP.\\n    struct Data {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"address receiver,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"bytes32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable,\\\" +\\n    ///         \\\"string sellTokenBalance,\\\" +\\n    ///         \\\"string buyTokenBalance\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant TYPE_HASH =\\n        hex\\\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\\\";\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\\n    /// computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"erc20\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_ERC20 =\\n        hex\\\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault external\\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\\n    /// order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"external\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_EXTERNAL =\\n        hex\\\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\\n    /// balances for computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"internal\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_INTERNAL =\\n        hex\\\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\\\";\\n\\n    /// @dev Marker address used to indicate that the receiver of the trade\\n    /// proceeds should the owner of the order.\\n    ///\\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\\n    /// to be the most common case.\\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 internal constant UID_LENGTH = 56;\\n\\n    /// @dev Returns the actual receiver for an order. This function checks\\n    /// whether or not the [`receiver`] field uses the marker value to indicate\\n    /// it is the same as the order owner.\\n    ///\\n    /// @return receiver The actual receiver of trade proceeds.\\n    function actualReceiver(Data memory order, address owner)\\n        internal\\n        pure\\n        returns (address receiver)\\n    {\\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\\n            receiver = owner;\\n        } else {\\n            receiver = order.receiver;\\n        }\\n    }\\n\\n    /// @dev Return the EIP-712 signing hash for the specified order.\\n    ///\\n    /// @param order The order to compute the EIP-712 signing hash for.\\n    /// @param domainSeparator The EIP-712 domain separator to use.\\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\\n    function hash(Data memory order, bytes32 domainSeparator)\\n        internal\\n        pure\\n        returns (bytes32 orderDigest)\\n    {\\n        bytes32 structHash;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n        // in the EIP proposal, noting that the order struct has 12 fields, and\\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, TYPE_HASH)\\n            structHash := keccak256(dataStart, 416)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\\n        // hash using scratch memory past the free memory pointer. The signing\\n        // hash is computed from `\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash`.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n    }\\n\\n    /// @dev Packs order UID parameters into the specified memory location. The\\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\\n    /// it allows re-using the memory for packing the order UID.\\n    ///\\n    /// This function reverts if the order UID buffer is not the correct size.\\n    ///\\n    /// @param orderUid The buffer pack the order UID parameters into.\\n    /// @param orderDigest The EIP-712 struct digest derived from the order\\n    /// parameters.\\n    /// @param owner The address of the user who owns this order.\\n    /// @param validTo The epoch time at which the order will stop being valid.\\n    function packOrderUidParams(\\n        bytes memory orderUid,\\n        bytes32 orderDigest,\\n        address owner,\\n        uint32 validTo\\n    ) internal pure {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: uid buffer overflow\\\");\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // Additionally, since Solidity `bytes memory` are length prefixed,\\n        // 32 needs to be added to all the offsets.\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(add(orderUid, 56), validTo)\\n            mstore(add(orderUid, 52), owner)\\n            mstore(add(orderUid, 32), orderDigest)\\n        }\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(bytes calldata orderUid)\\n        internal\\n        pure\\n        returns (\\n            bytes32 orderDigest,\\n            address owner,\\n            uint32 validTo\\n        )\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"GPv2: invalid uid\\\");\\n\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cowProtocol/libraries/GPv2Trade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../mixins/GPv2Signing.sol\\\";\\nimport \\\"./GPv2Order.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Trade Library.\\n/// @author Gnosis Developers\\nlibrary GPv2Trade {\\n    using GPv2Order for GPv2Order.Data;\\n    using GPv2Order for bytes;\\n\\n    /// @dev A struct representing a trade to be executed as part a batch\\n    /// settlement.\\n    struct Data {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @dev Extracts the order data and signing scheme for the specified trade.\\n    ///\\n    /// @param trade The trade.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param order The memory location to extract the order data to.\\n    function extractOrder(\\n        Data calldata trade,\\n        IERC20[] calldata tokens,\\n        GPv2Order.Data memory order\\n    ) internal pure returns (GPv2Signing.Scheme signingScheme) {\\n        order.sellToken = tokens[trade.sellTokenIndex];\\n        order.buyToken = tokens[trade.buyTokenIndex];\\n        order.receiver = trade.receiver;\\n        order.sellAmount = trade.sellAmount;\\n        order.buyAmount = trade.buyAmount;\\n        order.validTo = trade.validTo;\\n        order.appData = trade.appData;\\n        order.feeAmount = trade.feeAmount;\\n        (\\n            order.kind,\\n            order.partiallyFillable,\\n            order.sellTokenBalance,\\n            order.buyTokenBalance,\\n            signingScheme\\n        ) = extractFlags(trade.flags);\\n    }\\n\\n    /// @dev Decodes trade flags.\\n    ///\\n    /// Trade flags are used to tightly encode information on how to decode\\n    /// an order. Examples that directly affect the structure of an order are\\n    /// the kind of order (either a sell or a buy order) as well as whether the\\n    /// order is partially fillable or if it is a \\\"fill-or-kill\\\" order. It also\\n    /// encodes the signature scheme used to validate the order. As the most\\n    /// likely values are fill-or-kill sell orders by an externally owned\\n    /// account, the flags are chosen such that `0x00` represents this kind of\\n    /// order. The flags byte uses the following format:\\n    ///\\n    /// ```\\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\n    /// ----+----------+-------+---+-------+---+---+\\n    ///     | reserved | *   * | * | *   * | * | * |\\n    ///                  |   |   |   |   |   |   |\\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\\n    ///                  |   |   |   |   |   |         and 1 for a buy order\\n    ///                  |   |   |   |   |   |\\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\\n    ///                  |   |   |   |   |\\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\\n    ///                  |   |   |                     0x: ERC20 token balance\\n    ///                  |   |   |                     10: external Balancer Vault balance\\n    ///                  |   |   |                     11: internal Balancer Vault balance\\n    ///                  |   |   |\\n    ///                  |   |   +-------------------- use buy token balance bit\\n    ///                  |   |                         0: ERC20 token balance\\n    ///                  |   |                         1: internal Balancer Vault balance\\n    ///                  |   |\\n    ///                  +---+------------------------ signature scheme bits:\\n    ///                                                00: EIP-712\\n    ///                                                01: eth_sign\\n    ///                                                10: EIP-1271\\n    ///                                                11: pre_sign\\n    /// ```\\n    function extractFlags(uint256 flags)\\n        internal\\n        pure\\n        returns (\\n            bytes32 kind,\\n            bool partiallyFillable,\\n            bytes32 sellTokenBalance,\\n            bytes32 buyTokenBalance,\\n            GPv2Signing.Scheme signingScheme\\n        )\\n    {\\n        if (flags & 0x01 == 0) {\\n            kind = GPv2Order.KIND_SELL;\\n        } else {\\n            kind = GPv2Order.KIND_BUY;\\n        }\\n        partiallyFillable = flags & 0x02 != 0;\\n        if (flags & 0x08 == 0) {\\n            sellTokenBalance = GPv2Order.BALANCE_ERC20;\\n        } else if (flags & 0x04 == 0) {\\n            sellTokenBalance = GPv2Order.BALANCE_EXTERNAL;\\n        } else {\\n            sellTokenBalance = GPv2Order.BALANCE_INTERNAL;\\n        }\\n        if (flags & 0x10 == 0) {\\n            buyTokenBalance = GPv2Order.BALANCE_ERC20;\\n        } else {\\n            buyTokenBalance = GPv2Order.BALANCE_INTERNAL;\\n        }\\n\\n        // NOTE: Take advantage of the fact that Solidity will revert if the\\n        // following expression does not produce a valid enum value. This means\\n        // we check here that the leading reserved bits must be 0.\\n        signingScheme = GPv2Signing.Scheme(flags >> 5);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cowProtocol/mixins/GPv2Signing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/GPv2EIP1271.sol\\\";\\nimport \\\"../libraries/GPv2Order.sol\\\";\\nimport \\\"../libraries/GPv2Trade.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Signing Library.\\n/// @author Gnosis Developers\\nabstract contract GPv2Signing {\\n    using GPv2Order for GPv2Order.Data;\\n    using GPv2Order for bytes;\\n\\n    /// @dev Recovered trade data containing the extracted order and the\\n    /// recovered owner address.\\n    struct RecoveredOrder {\\n        GPv2Order.Data data;\\n        bytes uid;\\n        address owner;\\n        address receiver;\\n    }\\n\\n    /// @dev Signing scheme used for recovery.\\n    enum Scheme {\\n        Eip712,\\n        EthSign,\\n        Eip1271,\\n        PreSign\\n    }\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 private constant DOMAIN_NAME = keccak256(\\\"Gnosis Protocol\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 private constant DOMAIN_VERSION = keccak256(\\\"v2\\\");\\n\\n    /// @dev Marker value indicating an order is pre-signed.\\n    uint256 private constant PRE_SIGNED =\\n        uint256(keccak256(\\\"GPv2Signing.Scheme.PreSign\\\"));\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// GPv2 contracts.\\n    bytes32 public immutable domainSeparator;\\n\\n    /// @dev Storage indicating whether or not an order has been signed by a\\n    /// particular address.\\n    mapping(bytes => uint256) public preSignature;\\n\\n    /// @dev Event that is emitted when an account either pre-signs an order or\\n    /// revokes an existing pre-signature.\\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\\n\\n    constructor() {\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Sets a presignature for the specified order UID.\\n    ///\\n    /// @param orderUid The unique identifier of the order to pre-sign.\\n    /// @param signed True to set the order as tradable with pre-sign, false to\\n    /// false to unset it.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"GPv2: cannot presign order\\\");\\n        if (signed) {\\n            preSignature[orderUid] = PRE_SIGNED;\\n        } else {\\n            preSignature[orderUid] = 0;\\n        }\\n        emit PreSignature(owner, orderUid, signed);\\n    }\\n\\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\\n    /// packing the unique identifier.\\n    ///\\n    /// @return recoveredOrder The empty recovered order data.\\n    function allocateRecoveredOrder()\\n        internal\\n        pure\\n        returns (RecoveredOrder memory recoveredOrder)\\n    {\\n        recoveredOrder.uid = new bytes(GPv2Order.UID_LENGTH);\\n    }\\n\\n    /// @dev Extracts order data and recovers the signer from the specified\\n    /// trade.\\n    ///\\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param trade The trade data to recover the order data from.\\n    function recoverOrderFromTrade(\\n        RecoveredOrder memory recoveredOrder,\\n        IERC20[] calldata tokens,\\n        GPv2Trade.Data calldata trade\\n    ) internal view {\\n        GPv2Order.Data memory order = recoveredOrder.data;\\n\\n        Scheme signingScheme = GPv2Trade.extractOrder(trade, tokens, order);\\n        (bytes32 orderDigest, address owner) = recoverOrderSigner(\\n            order,\\n            signingScheme,\\n            trade.signature\\n        );\\n\\n        recoveredOrder.uid.packOrderUidParams(\\n            orderDigest,\\n            owner,\\n            order.validTo\\n        );\\n        recoveredOrder.owner = owner;\\n        recoveredOrder.receiver = order.actualReceiver(owner);\\n    }\\n\\n    /// @dev The length of any signature from an externally owned account.\\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\\n\\n    /// @dev Recovers an order's signer from the specified order and signature.\\n    ///\\n    /// @param order The order to recover a signature for.\\n    /// @param signingScheme The signing scheme.\\n    /// @param signature The signature bytes.\\n    /// @return orderDigest The computed order hash.\\n    /// @return owner The recovered address from the specified signature.\\n    function recoverOrderSigner(\\n        GPv2Order.Data memory order,\\n        Scheme signingScheme,\\n        bytes calldata signature\\n    ) internal view returns (bytes32 orderDigest, address owner) {\\n        orderDigest = order.hash(domainSeparator);\\n        if (signingScheme == Scheme.Eip712) {\\n            owner = recoverEip712Signer(orderDigest, signature);\\n        } else if (signingScheme == Scheme.EthSign) {\\n            owner = recoverEthsignSigner(orderDigest, signature);\\n        } else if (signingScheme == Scheme.Eip1271) {\\n            owner = recoverEip1271Signer(orderDigest, signature);\\n        } else {\\n            // signingScheme == Scheme.PreSign\\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\\n        }\\n    }\\n\\n    /// @dev Perform an ECDSA recover for the specified message and calldata\\n    /// signature.\\n    ///\\n    /// The signature is encoded by tighyly packing the following struct:\\n    /// ```\\n    /// struct EncodedSignature {\\n    ///     bytes32 r;\\n    ///     bytes32 s;\\n    ///     uint8 v;\\n    /// }\\n    /// ```\\n    ///\\n    /// @param message The signed message.\\n    /// @param encodedSignature The encoded signature.\\n    function ecdsaRecover(bytes32 message, bytes calldata encodedSignature)\\n        internal\\n        pure\\n        returns (address signer)\\n    {\\n        require(\\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\\n            \\\"GPv2: malformed ecdsa signature\\\"\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // NOTE: Use assembly to efficiently decode signature data.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // r = uint256(encodedSignature[0:32])\\n            r := calldataload(encodedSignature.offset)\\n            // s = uint256(encodedSignature[32:64])\\n            s := calldataload(add(encodedSignature.offset, 32))\\n            // v = uint8(encodedSignature[64])\\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\\n        }\\n\\n        signer = ecrecover(message, v, r, s);\\n        require(signer != address(0), \\\"GPv2: invalid ecdsa signature\\\");\\n    }\\n\\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\\n    /// signature.\\n    ///\\n    /// EIP-712 signs typed data. The specifications are described in the\\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\\n    ///\\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\\n    /// in the corresponding decoding function [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEip712Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        owner = ecdsaRecover(orderDigest, encodedSignature);\\n    }\\n\\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\\n    /// RPC call.\\n    ///\\n    /// The specifications are described in the Ethereum documentation\\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\\n    ///\\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\\n    /// described in the corresponding decoding function\\n    /// [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEthsignSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        // The signed message is encoded as:\\n        // `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" || length || data`, where\\n        // the length is a constant (32 bytes) and the data is defined as:\\n        // `orderDigest`.\\n        bytes32 ethsignDigest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", orderDigest)\\n        );\\n\\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\\n    }\\n\\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\\n    /// returns the address of the signer.\\n    ///\\n    /// The encoded signature tightly packs the following struct:\\n    ///\\n    /// ```\\n    /// struct EncodedEip1271Signature {\\n    ///     address owner;\\n    ///     bytes signature;\\n    /// }\\n    /// ```\\n    ///\\n    /// This function enforces that the encoded data stores enough bytes to\\n    /// cover the full length of the decoded signature.\\n    ///\\n    /// @param encodedSignature The encoded EIP-1271 signature.\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the signer.\\n    function recoverEip1271Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal view returns (address owner) {\\n        // NOTE: Use assembly to read the verifier address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        // NOTE: Configure prettier to ignore the following line as it causes\\n        // a panic in the Solidity plugin.\\n        // prettier-ignore\\n        bytes calldata signature = encodedSignature[20:];\\n\\n        require(\\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\\n                GPv2EIP1271.MAGICVALUE,\\n            \\\"GPv2: invalid eip1271 signature\\\"\\n        );\\n    }\\n\\n    /// @dev Verifies the order has been pre-signed. The signature is the\\n    /// address of the signer of the order.\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\\n    /// @param validTo The order expiry timestamp.\\n    /// @return owner The address of the signer.\\n    function recoverPreSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature,\\n        uint32 validTo\\n    ) internal view returns (address owner) {\\n        require(encodedSignature.length == 20, \\\"GPv2: malformed presignature\\\");\\n        // NOTE: Use assembly to read the owner address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\\n\\n        require(\\n            preSignature[orderUid] == PRE_SIGNED,\\n            \\\"GPv2: order not presigned\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CowswapOrderSigner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// contract taken from https://gist.github.com/Arachnid/6950b3367258b5d5033f6e1c411086e8\\n// cowswap contracts taken from https://github.com/cowprotocol/contracts/releases/tag/v1.3.2\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./cowProtocol/libraries/GPv2Order.sol\\\";\\nimport \\\"./cowProtocol/mixins/GPv2Signing.sol\\\";\\nimport \\\"./cowProtocol/interfaces/IERC20.sol\\\";\\n\\ncontract CowswapOrderSigner {\\n    using GPv2Order for GPv2Order.Data;\\n\\n    GPv2Signing public immutable signing;\\n    bytes32 immutable domainSeparator;\\n    address immutable deployedAt;\\n\\n    constructor(GPv2Signing _signing) { \\n        signing = _signing;\\n        domainSeparator = _signing.domainSeparator();\\n        deployedAt = address(this);\\n    }\\n\\n    // write an internal function that creates the order digest\\n    function packOrder(\\n        IERC20 sellToken,\\n        IERC20 buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint32 validTo,\\n        uint256 feeAmount,\\n        bytes32 kind,\\n        bool partiallyFillable,\\n        bytes32 sellTokenBalance,\\n        bytes32 buyTokenBalance\\n    ) internal view returns (bytes memory) {\\n        GPv2Order.Data memory order;\\n        order.sellToken = sellToken;\\n        order.buyToken = buyToken;\\n        order.receiver = address(this);\\n        order.sellAmount = sellAmount;\\n        order.buyAmount = buyAmount;\\n        order.validTo = validTo;\\n        order.appData = bytes32(uint256(uint160(deployedAt)));\\n        order.feeAmount = feeAmount;\\n        order.kind = kind;\\n        order.partiallyFillable = partiallyFillable;\\n        order.sellTokenBalance = sellTokenBalance;\\n        order.buyTokenBalance = buyTokenBalance;\\n\\n        bytes32 orderDigest = order.hash(domainSeparator);\\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\\n        GPv2Order.packOrderUidParams(\\n            orderUid,\\n            orderDigest,\\n            address(this),\\n            validTo);\\n\\n        return orderUid;\\n    }\\n\\n    function signOrder(\\n        IERC20 sellToken,\\n        IERC20 buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint32 validTo, // unix timestamp\\n        uint32 validDuration, // seconds\\n        uint256 feeAmount,\\n        uint256 feeAmountBP,\\n        bytes32 kind,\\n        bool partiallyFillable,\\n        bytes32 sellTokenBalance,\\n        bytes32 buyTokenBalance\\n    ) external {\\n        require(address(this) != deployedAt, \\\"DELEGATECALL only\\\");\\n        require(block.timestamp + validDuration > validTo, \\\"Dishonest valid duration\\\");\\n        require(feeAmount <= (sellAmount * feeAmountBP) / 10000 + 1, \\\"Fee too high\\\");\\n\\n        bytes memory orderUid = packOrder(sellToken, buyToken, sellAmount, buyAmount, validTo, feeAmount, kind, partiallyFillable, sellTokenBalance, buyTokenBalance);\\n        signing.setPreSignature(orderUid, true);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract GPv2Signing\",\"name\":\"_signing\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validTo\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"validDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmountBP\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"kind\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}],\"name\":\"signOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signing\",\"outputs\":[{\"internalType\":\"contract GPv2Signing\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CowswapOrderSigner", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009008d19f58aabd9ed0d60971565aa8510560ab41", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}