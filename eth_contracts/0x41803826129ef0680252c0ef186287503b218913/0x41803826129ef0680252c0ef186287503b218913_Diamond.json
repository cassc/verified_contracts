{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-04-07\r\n*/\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet)\r\n        external\r\n        view\r\n        returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector)\r\n        external\r\n        view\r\n        returns (address facetAddress_);\r\n}\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {\r\n        Add,\r\n        Replace,\r\n        Remove\r\n    }\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION =\r\n        keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    struct DiamondStorage {\r\n        // maps function selector to the facet address and\r\n        // the position of the selector in the facetFunctionSelectors.selectors array\r\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n        // maps facet addresses to function selectors\r\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n        // facet addresses\r\n        address[] facetAddresses;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage()\r\n        internal\r\n        pure\r\n        returns (DiamondStorage storage ds)\r\n    {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(\r\n            msg.sender == diamondStorage().contractOwner,\r\n            \"LibDiamond: Must be contract owner\"\r\n        );\r\n    }\r\n\r\n    event DiamondCut(\r\n        IDiamondCut.FacetCut[] _diamondCut,\r\n        address _init,\r\n        bytes _calldata\r\n    );\r\n\r\n    // Internal function version of diamondCut\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        for (\r\n            uint256 facetIndex;\r\n            facetIndex < _diamondCut.length;\r\n            facetIndex++\r\n        ) {\r\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\r\n            if (action == IDiamondCut.FacetCutAction.Add) {\r\n                addFunctions(\r\n                    _diamondCut[facetIndex].facetAddress,\r\n                    _diamondCut[facetIndex].functionSelectors\r\n                );\r\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\r\n                replaceFunctions(\r\n                    _diamondCut[facetIndex].facetAddress,\r\n                    _diamondCut[facetIndex].functionSelectors\r\n                );\r\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\r\n                removeFunctions(\r\n                    _diamondCut[facetIndex].facetAddress,\r\n                    _diamondCut[facetIndex].functionSelectors\r\n                );\r\n            } else {\r\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n            }\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addFunctions(\r\n        address _facetAddress,\r\n        bytes4[] memory _functionSelectors\r\n    ) internal {\r\n        require(\r\n            _functionSelectors.length > 0,\r\n            \"LibDiamondCut: No selectors in facet to cut\"\r\n        );\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(\r\n            _facetAddress != address(0),\r\n            \"LibDiamondCut: Add facet can't be address(0)\"\r\n        );\r\n        uint96 selectorPosition = uint96(\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\r\n        );\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            addFacet(ds, _facetAddress);\r\n        }\r\n        for (\r\n            uint256 selectorIndex;\r\n            selectorIndex < _functionSelectors.length;\r\n            selectorIndex++\r\n        ) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds\r\n                .selectorToFacetAndPosition[selector]\r\n                .facetAddress;\r\n            require(\r\n                oldFacetAddress == address(0),\r\n                \"LibDiamondCut: Can't add function that already exists\"\r\n            );\r\n            addFunction(ds, selector, selectorPosition, _facetAddress);\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function replaceFunctions(\r\n        address _facetAddress,\r\n        bytes4[] memory _functionSelectors\r\n    ) internal {\r\n        require(\r\n            _functionSelectors.length > 0,\r\n            \"LibDiamondCut: No selectors in facet to cut\"\r\n        );\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(\r\n            _facetAddress != address(0),\r\n            \"LibDiamondCut: Add facet can't be address(0)\"\r\n        );\r\n        uint96 selectorPosition = uint96(\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\r\n        );\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            addFacet(ds, _facetAddress);\r\n        }\r\n        for (\r\n            uint256 selectorIndex;\r\n            selectorIndex < _functionSelectors.length;\r\n            selectorIndex++\r\n        ) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds\r\n                .selectorToFacetAndPosition[selector]\r\n                .facetAddress;\r\n            require(\r\n                oldFacetAddress != _facetAddress,\r\n                \"LibDiamondCut: Can't replace function with same function\"\r\n            );\r\n            removeFunction(ds, oldFacetAddress, selector);\r\n            addFunction(ds, selector, selectorPosition, _facetAddress);\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function removeFunctions(\r\n        address _facetAddress,\r\n        bytes4[] memory _functionSelectors\r\n    ) internal {\r\n        require(\r\n            _functionSelectors.length > 0,\r\n            \"LibDiamondCut: No selectors in facet to cut\"\r\n        );\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // if function does not exist then do nothing and return\r\n        require(\r\n            _facetAddress == address(0),\r\n            \"LibDiamondCut: Remove facet address must be address(0)\"\r\n        );\r\n        for (\r\n            uint256 selectorIndex;\r\n            selectorIndex < _functionSelectors.length;\r\n            selectorIndex++\r\n        ) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds\r\n                .selectorToFacetAndPosition[selector]\r\n                .facetAddress;\r\n            removeFunction(ds, oldFacetAddress, selector);\r\n        }\r\n    }\r\n\r\n    function addFacet(DiamondStorage storage ds, address _facetAddress)\r\n        internal\r\n    {\r\n        enforceHasContractCode(\r\n            _facetAddress,\r\n            \"LibDiamondCut: New facet has no code\"\r\n        );\r\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\r\n            .facetAddresses\r\n            .length;\r\n        ds.facetAddresses.push(_facetAddress);\r\n    }\r\n\r\n    function addFunction(\r\n        DiamondStorage storage ds,\r\n        bytes4 _selector,\r\n        uint96 _selectorPosition,\r\n        address _facetAddress\r\n    ) internal {\r\n        ds\r\n            .selectorToFacetAndPosition[_selector]\r\n            .functionSelectorPosition = _selectorPosition;\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\r\n            _selector\r\n        );\r\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\r\n    }\r\n\r\n    function removeFunction(\r\n        DiamondStorage storage ds,\r\n        address _facetAddress,\r\n        bytes4 _selector\r\n    ) internal {\r\n        require(\r\n            _facetAddress != address(0),\r\n            \"LibDiamondCut: Can't remove function that doesn't exist\"\r\n        );\r\n        // an immutable function is a function defined directly in a diamond\r\n        require(\r\n            _facetAddress != address(this),\r\n            \"LibDiamondCut: Can't remove immutable function\"\r\n        );\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = ds\r\n            .selectorToFacetAndPosition[_selector]\r\n            .functionSelectorPosition;\r\n        uint256 lastSelectorPosition = ds\r\n            .facetFunctionSelectors[_facetAddress]\r\n            .functionSelectors\r\n            .length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = ds\r\n                .facetFunctionSelectors[_facetAddress]\r\n                .functionSelectors[lastSelectorPosition];\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\r\n                selectorPosition\r\n            ] = lastSelector;\r\n            ds\r\n                .selectorToFacetAndPosition[lastSelector]\r\n                .functionSelectorPosition = uint96(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\r\n        delete ds.selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = ds\r\n                .facetFunctionSelectors[_facetAddress]\r\n                .facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = ds.facetAddresses[\r\n                    lastFacetAddressPosition\r\n                ];\r\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                ds\r\n                    .facetFunctionSelectors[lastFacetAddress]\r\n                    .facetAddressPosition = facetAddressPosition;\r\n            }\r\n            ds.facetAddresses.pop();\r\n            delete ds\r\n                .facetFunctionSelectors[_facetAddress]\r\n                .facetAddressPosition;\r\n        }\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata)\r\n        internal\r\n    {\r\n        if (_init == address(0)) {\r\n            require(\r\n                _calldata.length == 0,\r\n                \"LibDiamondCut: _init is address(0) but_calldata is not empty\"\r\n            );\r\n        } else {\r\n            require(\r\n                _calldata.length > 0,\r\n                \"LibDiamondCut: _calldata is empty but _init is not address(0)\"\r\n            );\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(\r\n                    _init,\r\n                    \"LibDiamondCut: _init address has no code\"\r\n                );\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(\r\n        address _contract,\r\n        string memory _errorMessage\r\n    ) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\ncontract OwnershipFacet is IERC173 {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external view override returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}\r\n\r\ncontract Test1Facet {\r\n    event TestEvent(address something);\r\n\r\n    function test1Func1() external {}\r\n\r\n    function test1Func2() external {}\r\n\r\n    function test1Func3() external {}\r\n\r\n    function test1Func4() external {}\r\n\r\n    function test1Func5() external {}\r\n\r\n    function test1Func6() external {}\r\n\r\n    function test1Func7() external {}\r\n\r\n    function test1Func8() external {}\r\n\r\n    function test1Func9() external {}\r\n\r\n    function test1Func10() external {}\r\n\r\n    function test1Func11() external {}\r\n\r\n    function test1Func12() external {}\r\n\r\n    function test1Func13() external {}\r\n\r\n    function test1Func14() external {}\r\n\r\n    function test1Func15() external {}\r\n\r\n    function test1Func16() external {}\r\n\r\n    function test1Func17() external {}\r\n\r\n    function test1Func18() external {}\r\n\r\n    function test1Func19() external {}\r\n\r\n    function test1Func20() external {}\r\n\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {}\r\n}\r\n\r\ncontract Test2Facet {\r\n    function test2Func1() external {}\r\n\r\n    function test2Func2() external {}\r\n\r\n    function test2Func3() external {}\r\n\r\n    function test2Func4() external {}\r\n\r\n    function test2Func5() external {}\r\n\r\n    function test2Func6() external {}\r\n\r\n    function test2Func7() external {}\r\n\r\n    function test2Func8() external {}\r\n\r\n    function test2Func9() external {}\r\n\r\n    function test2Func10() external {}\r\n\r\n    function test2Func11() external {}\r\n\r\n    function test2Func12() external {}\r\n\r\n    function test2Func13() external {}\r\n\r\n    function test2Func14() external {}\r\n\r\n    function test2Func15() external {}\r\n\r\n    function test2Func16() external {}\r\n\r\n    function test2Func17() external {}\r\n\r\n    function test2Func18() external {}\r\n\r\n    function test2Func19() external {}\r\n\r\n    function test2Func20() external {}\r\n}\r\n\r\ncontract Facet3 {\r\n    struct FacetData {\r\n        string name;\r\n    }\r\n\r\n    function facetData()\r\n        internal\r\n        pure\r\n        returns (FacetData storage facetDataStruct)\r\n    {\r\n        bytes32 storagePosition = keccak256(\"diamond.storage.Facet3\");\r\n        assembly {\r\n            facetDataStruct.slot := storagePosition\r\n        }\r\n    }\r\n\r\n    function setName(string memory _name) external {\r\n        FacetData storage facetDataStruct = facetData();\r\n        facetDataStruct.name = _name;\r\n    }\r\n\r\n    function getName() external view returns (string memory) {\r\n        return facetData().name;\r\n    }\r\n}\r\n\r\ncontract Facet3v2 {\r\n    struct FacetData {\r\n        string name;\r\n        uint256 age;\r\n    }\r\n\r\n    function facetData()\r\n        internal\r\n        pure\r\n        returns (FacetData storage facetDataStruct)\r\n    {\r\n        bytes32 storagePosition = keccak256(\"diamond.storage.Facet3\");\r\n        assembly {\r\n            facetDataStruct.slot := storagePosition\r\n        }\r\n    }\r\n\r\n    function setName(string memory _name) external {\r\n        FacetData storage facetDataStruct = facetData();\r\n        facetDataStruct.name = _name;\r\n    }\r\n\r\n    function getName() external view returns (string memory) {\r\n        return facetData().name;\r\n    }\r\n\r\n    // new functions\r\n    function setAge(uint256 _age) external {\r\n        FacetData storage facetDataStruct = facetData();\r\n        facetDataStruct.age = _age;\r\n    }\r\n\r\n    function getAge() external view returns (uint256) {\r\n        return facetData().age;\r\n    }\r\n}\r\n\r\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\r\n// The EIP-2535 Diamond standard requires these functions.\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view override returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numFacets = ds.facetAddresses.length;\r\n        facets_ = new Facet[](numFacets);\r\n        for (uint256 i; i < numFacets; i++) {\r\n            address facetAddress_ = ds.facetAddresses[i];\r\n            facets_[i].facetAddress = facetAddress_;\r\n            facets_[i].functionSelectors = ds\r\n                .facetFunctionSelectors[facetAddress_]\r\n                .functionSelectors;\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors provided by a facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet)\r\n        external\r\n        view\r\n        override\r\n        returns (bytes4[] memory facetFunctionSelectors_)\r\n    {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetFunctionSelectors_ = ds\r\n            .facetFunctionSelectors[_facet]\r\n            .functionSelectors;\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory facetAddresses_)\r\n    {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = ds.facetAddresses;\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector)\r\n        external\r\n        view\r\n        override\r\n        returns (address facetAddress_)\r\n    {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = ds\r\n            .selectorToFacetAndPosition[_functionSelector]\r\n            .facetAddress;\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\r\n    }\r\n}\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Diamond {\r\n    constructor(\r\n        address _contractOwner,\r\n        address _diamondCutFacet,\r\n        address _diamondLoupeFacet\r\n    ) payable {\r\n        LibDiamond.setContractOwner(_contractOwner);\r\n\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        // ...\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](2);\r\n        bytes4[] memory diamondCutSelectors = new bytes4[](1);\r\n        diamondCutSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondCutFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n            functionSelectors: diamondCutSelectors\r\n        });\r\n        bytes4[] memory loupeSelectors = new bytes4[](5);\r\n        loupeSelectors[0] = IDiamondLoupe.facets.selector;\r\n        loupeSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\r\n        loupeSelectors[2] = IDiamondLoupe.facetAddresses.selector;\r\n        loupeSelectors[3] = IDiamondLoupe.facetAddress.selector;\r\n        loupeSelectors[4] = IERC165.supportsInterface.selector;\r\n        cut[1] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondLoupeFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n            functionSelectors: loupeSelectors\r\n        });\r\n        LibDiamond.diamondCut(cut, address(0), \"\");\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n           LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        // get diamond storage\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        // get facet from function selector\r\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        assembly {\r\n            // copy function selector and any arguments\r\n            calldatacopy(0, 0, calldatasize())\r\n            // execute function call using the facet\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            // get any return value\r\n            returndatacopy(0, 0, returndatasize())\r\n            // return any return value or error back to the caller\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n       \r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondLoupeFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ba6ac239340fcde64b0f35416d3147fb761ed35d000000000000000000000000c7ab831d4225657b71735ea9c81d494076397991000000000000000000000000f0154984214fb079b54cab080a64cbd823732b5d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://572dc5cffee3a0c1e7901ac2920f69b7cf11ff14cd9a56862936898d469441c0"}