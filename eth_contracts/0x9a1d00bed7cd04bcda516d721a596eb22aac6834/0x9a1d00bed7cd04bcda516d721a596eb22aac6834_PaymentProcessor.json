{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PaymentProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./interfaces/IPaymentProcessorConfiguration.sol\\\";\\nimport \\\"./interfaces/IPaymentProcessorEvents.sol\\\";\\nimport \\\"./interfaces/IModuleDefaultPaymentMethods.sol\\\";\\nimport \\\"./storage/PaymentProcessorStorageAccess.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\n\\n/*\\n                                                     @@@@@@@@@@@@@@             \\n                                                    @@@@@@@@@@@@@@@@@@(         \\n                                                   @@@@@@@@@@@@@@@@@@@@@        \\n                                                  @@@@@@@@@@@@@@@@@@@@@@@@      \\n                                                           #@@@@@@@@@@@@@@      \\n                                                               @@@@@@@@@@@@     \\n                            @@@@@@@@@@@@@@*                    @@@@@@@@@@@@     \\n                           @@@@@@@@@@@@@@@     @               @@@@@@@@@@@@     \\n                          @@@@@@@@@@@@@@@     @                @@@@@@@@@@@      \\n                         @@@@@@@@@@@@@@@     @@               @@@@@@@@@@@@      \\n                        @@@@@@@@@@@@@@@     #@@             @@@@@@@@@@@@/       \\n                        @@@@@@@@@@@@@@.     @@@@@@@@@@@@@@@@@@@@@@@@@@@         \\n                       @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@            \\n                      @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@             \\n                     @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@           \\n                    @@@@@@@@@@@@@@@     @@@@@&%%%%%%%%&&@@@@@@@@@@@@@@          \\n                    @@@@@@@@@@@@@@      @@@@@               @@@@@@@@@@@         \\n                   @@@@@@@@@@@@@@@     @@@@@                 @@@@@@@@@@@        \\n                  @@@@@@@@@@@@@@@     @@@@@@                 @@@@@@@@@@@        \\n                 @@@@@@@@@@@@@@@     @@@@@@@                 @@@@@@@@@@@        \\n                @@@@@@@@@@@@@@@     @@@@@@@                 @@@@@@@@@@@&        \\n                @@@@@@@@@@@@@@     *@@@@@@@               (@@@@@@@@@@@@         \\n               @@@@@@@@@@@@@@@     @@@@@@@@             @@@@@@@@@@@@@@          \\n              @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           \\n             @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@            \\n            @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              \\n           .@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 \\n           @@@@@@@@@@@@@@%     @@@@@@@@@@@@@@@@@@@@@@@@(                        \\n          @@@@@@@@@@@@@@@                                                       \\n         @@@@@@@@@@@@@@@                                                        \\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         \\n       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                          \\n       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&                                          \\n      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                           \\n \\n* @title Payment Processor\\n* @custom:version 2.0.0\\n* @author Limit Break, Inc.\\n*/ \\n\\ncontract PaymentProcessor is EIP712, PaymentProcessorStorageAccess, IPaymentProcessorEvents {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev The Payment Settings module implements of all payment configuration-related functionality.\\n    address private immutable _modulePaymentSettings;\\n\\n    /// @dev The On-Chain Cancellation module implements of all on-chain cancellation-related functionality.\\n    address private immutable _moduleOnChainCancellation;\\n\\n    /// @dev The Trades module implements all trade-related functionality.\\n    address private immutable _moduleTrades;\\n\\n    /// @dev The Trades module implements all advanced trade-related functionality.\\n    address private immutable _moduleTradesAdvanced;\\n\\n    constructor(address configurationContract) EIP712(\\\"PaymentProcessor\\\", \\\"2\\\") {\\n        (\\n            address defaultContractOwner_,\\n            PaymentProcessorModules memory paymentProcessorModules\\n        ) = IPaymentProcessorConfiguration(configurationContract).getPaymentProcessorDeploymentParams();\\n        \\n        \\n        if (defaultContractOwner_ == address(0) ||\\n            paymentProcessorModules.modulePaymentSettings == address(0) ||\\n            paymentProcessorModules.moduleOnChainCancellation == address(0) ||\\n            paymentProcessorModules.moduleTrades == address(0) ||\\n            paymentProcessorModules.moduleTradesAdvanced == address(0)) {\\n            revert PaymentProcessor__InvalidConstructorArguments();\\n        }\\n\\n        _modulePaymentSettings = paymentProcessorModules.modulePaymentSettings;\\n        _moduleOnChainCancellation = paymentProcessorModules.moduleOnChainCancellation;\\n        _moduleTrades = paymentProcessorModules.moduleTrades;\\n        _moduleTradesAdvanced = paymentProcessorModules.moduleTradesAdvanced;\\n\\n        unchecked {\\n            uint32 paymentMethodWhitelistId = appStorage().lastPaymentMethodWhitelistId++;\\n            appStorage().paymentMethodWhitelistOwners[paymentMethodWhitelistId] = defaultContractOwner_;\\n            emit CreatedPaymentMethodWhitelist(paymentMethodWhitelistId, defaultContractOwner_, \\\"Default Payment Methods\\\");\\n        }\\n    }\\n\\n    /**************************************************************/\\n    /*                         MODIFIERS                          */\\n    /**************************************************************/\\n\\n    /**\\n     * @dev Function modifier that generates a delegatecall to `module` with `selector` as the calldata\\n     * @dev This delegatecall is for functions that do not have parameters. The only calldata added is\\n     * @dev the extra calldata from a trusted forwarder, when present.\\n     * \\n     * @param module The contract address being called in the delegatecall.\\n     * @param selector The 4 byte function selector for the function to call in `module`.\\n     */\\n    modifier delegateCallNoData(address module, bytes4 selector) {\\n        assembly {\\n            // This protocol is designed to work both via direct calls and calls from a trusted forwarder that\\n            // preserves the original msg.sender by appending an extra 20 bytes to the calldata.  \\n            // The following code supports both cases.  The magic number of 68 is:\\n            // 4 bytes for the selector\\n            let ptr := mload(0x40)\\n            mstore(ptr, selector)\\n            mstore(0x40, add(ptr, calldatasize()))\\n            calldatacopy(add(ptr, 0x04), 0x04, sub(calldatasize(), 0x04))\\n            let result := delegatecall(gas(), module, ptr, add(sub(calldatasize(), 4), 4), 0, 0)\\n            if iszero(result) {\\n                // Call has failed, retrieve the error message and revert\\n                let size := returndatasize()\\n                returndatacopy(0, 0, size)\\n                revert(0, size)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function modifier that generates a delegatecall to `module` with `selector` and `data` as the \\n     * @dev calldata. This delegatecall is for functions that have parameters but **DO NOT** take domain\\n     * @dev separator as a parameter. Additional calldata from a trusted forwarder is appended to the end, when present.\\n     * \\n     * @param module The contract address being called in the delegatecall.\\n     * @param selector The 4 byte function selector for the function to call in `module`.\\n     * @param data The calldata to send to the `module`.\\n     */\\n    modifier delegateCall(address module, bytes4 selector, bytes calldata data) {\\n        assembly {\\n            // This protocol is designed to work both via direct calls and calls from a trusted forwarder that\\n            // preserves the original msg.sender by appending an extra 20 bytes to the calldata.  \\n            // The following code supports both cases.  The magic number of 68 is:\\n            // 4 bytes for the selector\\n            // 32 bytes calldata offset to the data parameter\\n            // 32 bytes for the length of the data parameter\\n            let lengthWithAppendedCalldata := sub(calldatasize(), 68)\\n\\n            let ptr := mload(0x40)\\n            mstore(ptr, selector)\\n            calldatacopy(add(ptr,0x04), data.offset, lengthWithAppendedCalldata)\\n            mstore(0x40, add(ptr,add(0x04, lengthWithAppendedCalldata)))\\n\\n            let result := delegatecall(gas(), module, ptr, add(lengthWithAppendedCalldata, 4), 0, 0)\\n            if iszero(result) {\\n                // Call has failed, retrieve the error message and revert\\n                let size := returndatasize()\\n                returndatacopy(0, 0, size)\\n                revert(0, size)\\n            }\\n        }        \\n        _;\\n    }\\n\\n    /**\\n     * @dev Function modifier that generates a delegatecall to `module` with `selector` and `data` as the \\n     * @dev calldata. This delegatecall is for functions that have parameters **AND** take domain\\n     * @dev separator as the first parameter. Any domain separator that has been included in `data`\\n     * @dev will be replaced with the Payment Processor domain separator.  Additional calldata from a \\n     * @dev trusted forwarder is appended to the end, when present.\\n     * \\n     * @param module The contract address being called in the delegatecall.\\n     * @param selector The 4 byte function selector for the function to call in `module`.\\n     * @param data The calldata to send to the `module`.\\n     */\\n    modifier delegateCallReplaceDomainSeparator(address module, bytes4 selector, bytes calldata data) {\\n        bytes32 domainSeparator = _domainSeparatorV4();\\n        assembly {\\n            // This protocol is designed to work both via direct calls and calls from a trusted forwarder that\\n            // preserves the original msg.sender by appending an extra 20 bytes to the calldata.  \\n            // The following code supports both cases.  The magic number of 68 is:\\n            // 4 bytes for the selector\\n            // 32 bytes calldata offset to the data parameter\\n            // 32 bytes for the length of the data parameter\\n            let lengthWithAppendedCalldata := sub(calldatasize(), 68)\\n\\n            let ptr := mload(0x40)\\n            mstore(ptr, selector)\\n            calldatacopy(add(ptr,0x04), data.offset, lengthWithAppendedCalldata)\\n            mstore(0x40, add(ptr,add(0x04, lengthWithAppendedCalldata)))\\n            mstore(add(ptr, 0x04), domainSeparator)\\n        \\n            let result := delegatecall(gas(), module, ptr, add(lengthWithAppendedCalldata, 4), 0, 0)\\n            if iszero(result) {\\n                // Call has failed, retrieve the error message and revert\\n                let size := returndatasize()\\n                returndatacopy(0, 0, size)\\n                revert(0, size)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /**************************************************************/\\n    /*                    READ ONLY ACCESSORS                     */\\n    /**************************************************************/\\n\\n    /**\\n     * @notice Returns the EIP-712 domain separator for this contract.\\n     */\\n    function getDomainSeparator() public view returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @notice Returns the user-specific master nonce that allows order makers to efficiently cancel all listings or offers\\n     *         they made previously. The master nonce for a user only changes when they explicitly request to revoke all\\n     *         existing listings and offers.\\n     *\\n     * @dev    When prompting makers to sign a listing or offer, marketplaces must query the current master nonce of\\n     *         the user and include it in the listing/offer signature data.\\n     */\\n    function masterNonces(address account) public view returns (uint256) {\\n        return appStorage().masterNonces[account];\\n    }\\n\\n    /**\\n     * @notice Returns true if the nonce for the given account has been used or cancelled. In comparison to a master nonce for\\n     *         a user, this nonce value is specific to a single order and may only be used or cancelled a single time.\\n     *\\n     * @dev    When prompting makers to sign a listing or offer, marketplaces must generate a unique nonce value that\\n     *         has not been previously used for filled, unfilled or cancelled orders. User nonces are unique to each\\n     *         user but common to that user across all marketplaces that utilize Payment Processor and do not reset\\n     *         when the master nonce is incremented. Nonces are stored in a BitMap for gas efficiency so it is recommended\\n     *         to utilize sequential numbers that do not overlap with other marketplaces.\\n     */\\n    function isNonceUsed(address account, uint256 nonce) public view returns (bool isUsed) {\\n        // The following code is equivalent to, but saves gas:\\n        //\\n        // uint256 slot = nonce / 256;\\n        // uint256 offset = nonce % 256;\\n        // uint256 slotValue = appStorage().invalidatedSignatures[account][slot];\\n        // isUsed = ((slotValue >> offset) & ONE) == ONE;\\n\\n        isUsed = ((appStorage().invalidatedSignatures[account][uint248(nonce >> 8)] >> uint8(nonce)) & ONE) == ONE;\\n    }\\n\\n    /**\\n     * @notice Returns the state and remaining fillable quantity of an order digest given the maker address.\\n     */\\n    function remainingFillableQuantity(\\n        address account, \\n        bytes32 orderDigest\\n    ) external view returns (PartiallyFillableOrderStatus memory) {\\n        return appStorage().partiallyFillableOrderStatuses[account][orderDigest];\\n    }\\n\\n    /**\\n     * @notice Returns the payment settings for a given collection.\\n     *\\n     * @notice paymentSettings: The payment setting type for a given collection \\n     *         (DefaultPaymentMethodWhitelist|AllowAnyPaymentMethod|CustomPaymentMethodWhitelist|PricingConstraints)\\n     * @notice paymentMethodWhitelistId: The payment method whitelist id for a given collection.  \\n     *         Applicable only when paymentSettings is CustomPaymentMethodWhitelist\\n     * @notice constrainedPricingPaymentMethod: The payment method that min/max priced collections are priced in.\\n     *         Applicable only when paymentSettings is PricingConstraints.\\n     * @notice royaltyBackfillNumerator: The royalty backfill percentage for a given collection.  Used only as a\\n     *         fallback when a collection does not implement EIP-2981.\\n     * @notice royaltyBountyNumerator: The royalty bounty percentage for a given collection.  When set, this percentage\\n     *         is applied to the creator's royalty amount and paid to the maker marketplace as a bounty.\\n     * @notice isRoyaltyBountyExclusive: When true, only the designated marketplace is eligible for royalty bounty.\\n     * @notice blockTradesFromUntrustedChannels: When true, only transactions from channels that the collection \\n     *         authorizes will be allowed to execute.\\n     */\\n    function collectionPaymentSettings(address tokenAddress) external view returns (CollectionPaymentSettings memory) {\\n        return appStorage().collectionPaymentSettings[tokenAddress];\\n    }\\n\\n    /**\\n     * @notice Returns the optional creator-defined royalty bounty settings for a given collection.\\n     * \\n     * @return royaltyBountyNumerator  The royalty bounty percentage for a given collection.  When set, this percentage\\n     *         is applied to the creator's royalty amount and paid to the maker marketplace as a bounty.\\n     * @return exclusiveBountyReceiver When non-zero, only the designated marketplace is eligible for royalty bounty.\\n     */\\n    function collectionBountySettings(\\n        address tokenAddress\\n    ) external view returns (uint16 royaltyBountyNumerator, address exclusiveBountyReceiver) {\\n        CollectionPaymentSettings memory collectionPaymentSettings = \\n            appStorage().collectionPaymentSettings[tokenAddress];\\n\\n        return (\\n            collectionPaymentSettings.royaltyBountyNumerator, \\n            collectionPaymentSettings.isRoyaltyBountyExclusive ? \\n                appStorage().collectionExclusiveBountyReceivers[tokenAddress] : \\n                address(0));\\n    }\\n\\n    /**\\n     * @notice Returns the optional creator-defined royalty backfill settings for a given collection.\\n     *         This is useful for legacy collection lacking EIP-2981 support, as the collection owner can instruct\\n     *         PaymentProcessor to backfill missing on-chain royalties.\\n     * \\n     * @return royaltyBackfillNumerator  The creator royalty percentage for a given collection.  \\n     *         When set, this percentage is applied to the item sale price and paid to the creator if the attempt\\n     *         to query EIP-2981 royalties fails.\\n     * @return royaltyBackfillReceiver When non-zero, this is the destination address for backfilled creator royalties.\\n     */\\n    function collectionRoyaltyBackfillSettings(\\n        address tokenAddress\\n    ) external view returns (uint16 royaltyBackfillNumerator, address royaltyBackfillReceiver) {\\n        CollectionPaymentSettings memory collectionPaymentSettings = \\n            appStorage().collectionPaymentSettings[tokenAddress];\\n\\n        return (\\n            collectionPaymentSettings.royaltyBackfillNumerator, \\n            collectionPaymentSettings.royaltyBackfillNumerator > 0 ?\\n                appStorage().collectionRoyaltyBackfillReceivers[tokenAddress] : \\n                address(0));\\n    }\\n\\n    /**\\n     * @notice Returns the address of the account that owns the specified payment method whitelist id.\\n     */\\n    function paymentMethodWhitelistOwners(uint32 paymentMethodWhitelistId) external view returns (address) {\\n        return appStorage().paymentMethodWhitelistOwners[paymentMethodWhitelistId];\\n    }\\n\\n    /**\\n     * @notice Returns true if the specified payment method is whitelisted for the specified payment method whitelist.\\n     */\\n    function isPaymentMethodWhitelisted(uint32 paymentMethodWhitelistId, address paymentMethod) external view returns (bool) {\\n        return appStorage().collectionPaymentMethodWhitelists[paymentMethodWhitelistId].contains(paymentMethod);\\n    }\\n\\n    /**\\n     * @notice Returns the pricing bounds floor price for a given collection and token id, when applicable.\\n     *\\n     * @dev    The pricing bounds floor price is only enforced when the collection payment settings are set to\\n     *         the PricingContraints type.\\n     */\\n    function getFloorPrice(address tokenAddress, uint256 tokenId) external view returns (uint256) {\\n        PricingBounds memory tokenLevelPricingBounds = appStorage().tokenPricingBounds[tokenAddress][tokenId];\\n        if (tokenLevelPricingBounds.isSet) {\\n            return tokenLevelPricingBounds.floorPrice;\\n        } else {\\n            PricingBounds memory collectionLevelPricingBounds = appStorage().collectionPricingBounds[tokenAddress];\\n            if (collectionLevelPricingBounds.isSet) {\\n                return collectionLevelPricingBounds.floorPrice;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the pricing bounds ceiling price for a given collection and token id, when applicable.\\n     *\\n     * @dev    The pricing bounds ceiling price is only enforced when the collection payment settings are set to\\n     *         the PricingConstraints type.\\n     */\\n    function getCeilingPrice(address tokenAddress, uint256 tokenId) external view returns (uint256) {\\n        PricingBounds memory tokenLevelPricingBounds = appStorage().tokenPricingBounds[tokenAddress][tokenId];\\n        if (tokenLevelPricingBounds.isSet) {\\n            return tokenLevelPricingBounds.ceilingPrice;\\n        } else {\\n            PricingBounds memory collectionLevelPricingBounds = appStorage().collectionPricingBounds[tokenAddress];\\n            if (collectionLevelPricingBounds.isSet) {\\n                return collectionLevelPricingBounds.ceilingPrice;\\n            }\\n        }\\n\\n        return type(uint256).max;\\n    }\\n\\n    /**\\n     * @notice Returns the last created payment method whitelist id.\\n     */\\n    function lastPaymentMethodWhitelistId() external view returns (uint32) {\\n        return appStorage().lastPaymentMethodWhitelistId;\\n    }\\n\\n    /**\\n     * @notice Returns the set of payment methods for a given payment method whitelist.\\n     */\\n    function getWhitelistedPaymentMethods(uint32 paymentMethodWhitelistId) external view returns (address[] memory) {\\n        return appStorage().collectionPaymentMethodWhitelists[paymentMethodWhitelistId].values();\\n    }\\n\\n    /**\\n     * @notice Returns the set of trusted channels for a given collection.\\n     */\\n    function getTrustedChannels(address tokenAddress) external view returns (address[] memory) {\\n        return appStorage().collectionTrustedChannels[tokenAddress].values();\\n    }\\n\\n    /**\\n     * @notice Returns the set of banned accounts for a given collection.\\n     */\\n    function getBannedAccounts(address tokenAddress) external view returns (address[] memory) {\\n        return appStorage().collectionBannedAccounts[tokenAddress].values();\\n    }\\n\\n    /**************************************************************/\\n    /*           PAYMENT SETTINGS MANAGEMENT OPERATIONS           */\\n    /**************************************************************/\\n\\n    /**\\n     * @notice Returns true if the specified payment method is on the deploy-time default payment method whitelist\\n     *         or post-deploy default payment method whitelist (id 0).\\n     */\\n    function isDefaultPaymentMethod(address paymentMethod) external view returns (bool) {\\n        address[] memory defaultPaymentMethods = \\n            IModuleDefaultPaymentMethods(_modulePaymentSettings).getDefaultPaymentMethods();\\n\\n        for (uint256 i = 0; i < defaultPaymentMethods.length;) {\\n            if (paymentMethod == defaultPaymentMethods[i]) {\\n                return true;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return appStorage().collectionPaymentMethodWhitelists[DEFAULT_PAYMENT_METHOD_WHITELIST_ID].contains(paymentMethod);\\n    }\\n\\n    /**\\n     * @notice Returns an array of the immutable default payment methods specified at deploy time.  \\n     *         However, if any post-deployment default payment methods have been added, they are\\n     *         not returned here because using an enumerable payment method whitelist would make trades\\n     *         less gas efficient.  For post-deployment default payment methods, exchanges should index\\n     *         the `PaymentMethodAddedToWhitelist` and `PaymentMethodRemovedFromWhitelist` events.\\n     */\\n    function getDefaultPaymentMethods() external view returns (address[] memory) {\\n        return IModuleDefaultPaymentMethods(_modulePaymentSettings).getDefaultPaymentMethods();\\n    }\\n\\n    /**\\n     * @notice Allows any user to create a new custom payment method whitelist.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The payment method whitelist id tracker has been incremented by `1`.\\n     * @dev    2. The caller has been assigned as the owner of the payment method whitelist.\\n     * @dev    3. A `CreatedPaymentMethodWhitelist` event has been emitted.\\n     *\\n     * @param  data  Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *               `createPaymentMethodWhitelist(string calldata whitelistName)`\\n     * @return paymentMethodWhitelistId  The id of the newly created payment method whitelist.\\n     */\\n    function createPaymentMethodWhitelist(bytes calldata data) external returns (uint32 paymentMethodWhitelistId) {\\n        address module = _modulePaymentSettings;\\n        assembly {\\n            // This protocol is designed to work both via direct calls and calls from a trusted forwarder that\\n            // preserves the original msg.sender by appending an extra 20 bytes to the calldata.  \\n            // The following code supports both cases.  The magic number of 68 is:\\n            // 4 bytes for the selector\\n            // 32 bytes calldata offset to the data parameter\\n            // 32 bytes for the length of the data parameter\\n            let lengthWithAppendedCalldata := sub(calldatasize(), 68)\\n\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"f83116c9\\\")\\n            calldatacopy(add(ptr, 0x04), data.offset, lengthWithAppendedCalldata)\\n            mstore(0x40, add(ptr, add(0x04, lengthWithAppendedCalldata)))\\n\\n            let result := delegatecall(gas(), module, ptr, add(lengthWithAppendedCalldata, 4), 0x00, 0x20)\\n\\n            switch result case 0 {\\n                let size := returndatasize()\\n                returndatacopy(0, 0, size)\\n                revert(0, size)\\n            } default {\\n                return (0x00, 0x20)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ownership of a payment method whitelist list to a new owner.\\n     *\\n     * @dev Throws when the new owner is the zero address.\\n     * @dev Throws when the caller does not own the specified list.\\n     *\\n     * @dev <h4>Postconditions:</h4>\\n     *      1. The payment method whitelist list ownership is transferred to the new owner.\\n     *      2. A `ReassignedPaymentMethodWhitelistOwnership` event is emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `reassignOwnershipOfPaymentMethodWhitelist(uint32 id, address newOwner)`\\n     */\\n    function reassignOwnershipOfPaymentMethodWhitelist(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_REASSIGN_OWNERSHIP_OF_PAYMENT_METHOD_WHITELIST, data) {}\\n\\n    /**\\n     * @notice Renounce the ownership of a payment method whitelist, rendering the list immutable.\\n     *\\n     * @dev Throws when the caller does not own the specified list.\\n     *\\n     * @dev <h4>Postconditions:</h4>\\n     *      1. The ownership of the specified payment method whitelist is renounced.\\n     *      2. A `ReassignedPaymentMethodWhitelistOwnership` event is emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `renounceOwnershipOfPaymentMethodWhitelist(uint32 id)`\\n     */\\n    function renounceOwnershipOfPaymentMethodWhitelist(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_RENOUNCE_OWNERSHIP_OF_PAYMENT_METHOD_WHITELIST, data) {}\\n\\n    /**\\n     * @notice Allows custom payment method whitelist owners to approve a new coin for use as a payment currency.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified payment method whitelist.\\n     * @dev    Throws when the specified coin is already whitelisted under the specified whitelist id.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `paymentMethod` has been approved in `paymentMethodWhitelist` mapping.\\n     * @dev    2. A `PaymentMethodAddedToWhitelist` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `whitelistPaymentMethod(uint32 paymentMethodWhitelistId, address paymentMethod)`\\n     */\\n    function whitelistPaymentMethod(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_WHITELIST_PAYMENT_METHOD, data) {}\\n\\n    /**\\n     * @notice Allows custom payment method whitelist owners to remove a coin from the list of approved payment currencies.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified payment method whitelist.\\n     * @dev    Throws when the specified coin is not currently whitelisted under the specified whitelist id.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `paymentMethod` has been removed from the `paymentMethodWhitelist` mapping.\\n     * @dev    2. A `PaymentMethodRemovedFromWhitelist` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `unwhitelistPaymentMethod(uint32 paymentMethodWhitelistId, address paymentMethod)`\\n     */\\n    function unwhitelistPaymentMethod(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_UNWHITELIST_PAYMENT_METHOD, data) {}\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify the payment settings for their collections.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the royalty backfill numerator is greater than 10,000.\\n     * @dev    Throws when the royalty bounty numerator is greater than 10,000.\\n     * @dev    Throws when the specified payment method whitelist id does not exist.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The `PaymentSettings` type for the collection has been set.\\n     * @dev    2. The `paymentMethodWhitelistId` for the collection has been set, if applicable.\\n     * @dev    3. The `constrainedPricingPaymentMethod` for the collection has been set, if applicable.\\n     * @dev    4. The `royaltyBackfillNumerator` for the collection has been set.\\n     * @dev    5. The `royaltyBackfillReceiver` for the collection has been set.\\n     * @dev    6. The `royaltyBountyNumerator` for the collection has been set.\\n     * @dev    7. The `exclusiveBountyReceiver` for the collection has been set.\\n     * @dev    8. The `blockTradesFromUntrustedChannels` for the collection has been set.\\n     * @dev    9. An `UpdatedCollectionPaymentSettings` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `setCollectionPaymentSettings(\\n                        address tokenAddress, \\n                        PaymentSettings paymentSettings,\\n                        uint32 paymentMethodWhitelistId,\\n                        address constrainedPricingPaymentMethod,\\n                        uint16 royaltyBackfillNumerator,\\n                        address royaltyBackfillReceiver,\\n                        uint16 royaltyBountyNumerator,\\n                        address exclusiveBountyReceiver,\\n                        bool blockTradesFromUntrustedChannels)`\\n     */\\n    function setCollectionPaymentSettings(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_SET_COLLECTION_PAYMENT_SETTINGS, data) {}\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify their own bounded price at the collection level.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the specified floor price is greater than the ceiling price.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The collection-level pricing bounds for the specified tokenAddress has been set.\\n     * @dev    2. An `UpdatedCollectionLevelPricingBoundaries` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `setCollectionPricingBounds(address tokenAddress, PricingBounds calldata pricingBounds)`\\n     */\\n    function setCollectionPricingBounds(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_SET_COLLECTION_PRICING_BOUNDS, data) {}\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify their own bounded price at the individual token level.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the lengths of the tokenIds and pricingBounds array don't match.\\n     * @dev    Throws when the tokenIds or pricingBounds array length is zero. \\n     * @dev    Throws when the any of the specified floor prices is greater than the ceiling price for that token id.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The token-level pricing bounds for the specified tokenAddress and token ids has been set.\\n     * @dev    2. An `UpdatedTokenLevelPricingBoundaries` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `setTokenPricingBounds(\\n                        address tokenAddress, \\n                        uint256[] calldata tokenIds, \\n                        PricingBounds[] calldata pricingBounds)`\\n     */\\n    function setTokenPricingBounds(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_SET_TOKEN_PRICING_BOUNDS, data) {}\\n\\n    /**\\n     * @notice Allows trusted channels to be added to a collection.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the specified address is not a trusted forwarder.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `channel` has been approved for trusted forwarding of trades on a collection.\\n     * @dev    2. A `TrustedChannelAddedForCollection` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `addTrustedChannelForCollection(\\n     *                  address tokenAddress, \\n     *                  address channel)`\\n     */\\n    function addTrustedChannelForCollection(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_ADD_TRUSTED_CHANNEL_FOR_COLLECTION, data) {}\\n\\n    /**\\n     * @notice Allows trusted channels to be removed from a collection.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `channel` has been dis-approved for trusted forwarding of trades on a collection.\\n     * @dev    2. A `TrustedChannelRemovedForCollection` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `removeTrustedChannelForCollection(\\n     *                  address tokenAddress, \\n     *                  address channel)`\\n     */\\n    function removeTrustedChannelForCollection(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_REMOVE_TRUSTED_CHANNEL_FOR_COLLECTION, data) {}\\n\\n    /**\\n     * @notice Allows creator to ban accounts from a collection.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `account` has been banned from trading on a collection.\\n     * @dev    2. A `BannedAccountAddedForCollection` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `addBannedAccountForCollection(\\n     *                  address tokenAddress, \\n     *                  address account)`\\n     */\\n    function addBannedAccountForCollection(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_ADD_BANNED_ACCOUNT_FOR_COLLECTION, data) {}\\n\\n    /**\\n     * @notice Allows creator to un-ban accounts from a collection.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `account` ban has been lifted for trades on a collection.\\n     * @dev    2. A `BannedAccountRemovedForCollection` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `removeBannedAccountForCollection(\\n     *                  address tokenAddress, \\n     *                  address account)`\\n     */\\n    function removeBannedAccountForCollection(bytes calldata data) external \\n    delegateCall(_modulePaymentSettings, SELECTOR_REMOVE_BANNED_ACCOUNT_FOR_COLLECTION, data) {}\\n\\n    /**************************************************************/\\n    /*              ON-CHAIN CANCELLATION OPERATIONS              */\\n    /**************************************************************/\\n\\n    /**\\n     * @notice Allows a cosigner to destroy itself, never to be used again.  This is a fail-safe in case of a failure\\n     *         to secure the co-signer private key in a Web2 co-signing service.  In case of suspected cosigner key\\n     *         compromise, or when a co-signer key is rotated, the cosigner MUST destroy itself to prevent past listings \\n     *         that were cancelled off-chain from being used by a malicious actor.\\n     *\\n     * @dev    Throws when the cosigner did not sign an authorization to self-destruct.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The cosigner can never be used to co-sign orders again.\\n     * @dev    2. A `DestroyedCosigner` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `destroyCosigner(address cosigner, SignatureECDSA signature)`\\n     */\\n    function destroyCosigner(bytes calldata data) external\\n    delegateCall(_moduleOnChainCancellation, SELECTOR_DESTROY_COSIGNER, data) {}\\n\\n    /**\\n     * @notice Allows a maker to revoke/cancel all prior signatures of their listings and offers.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The maker's master nonce has been incremented by `1` in contract storage, rendering all signed\\n     *            approvals using the prior nonce unusable.\\n     * @dev    2. A `MasterNonceInvalidated` event has been emitted.\\n     */\\n    function revokeMasterNonce() external \\n    delegateCallNoData(_moduleOnChainCancellation, SELECTOR_REVOKE_MASTER_NONCE) {}\\n\\n    /**\\n     * @notice Allows a maker to revoke/cancel a single, previously signed listing or offer by specifying the\\n     *         nonce of the listing or offer.\\n     *\\n     * @dev    Throws when the maker has already revoked the nonce.\\n     * @dev    Throws when the nonce was already used by the maker to successfully buy or sell an NFT.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The specified `nonce` for the `_msgSender()` has been revoked and can\\n     *            no longer be used to execute a sale or purchase.\\n     * @dev    2. A `NonceInvalidated` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `revokeSingleNonce(uint256 nonce)`\\n     */\\n    function revokeSingleNonce(bytes calldata data) external \\n    delegateCall(_moduleOnChainCancellation, SELECTOR_REVOKE_SINGLE_NONCE, data) {}\\n\\n    /**\\n     * @notice Allows a maker to revoke/cancel a partially fillable order by specifying the order digest hash.\\n     *\\n     * @dev    Throws when the maker has already revoked the order digest.\\n     * @dev    Throws when the order digest was already used by the maker and has been fully filled.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The specified `orderDigest` for the `_msgSender()` has been revoked and can\\n     *            no longer be used to execute a sale or purchase.\\n     * @dev    2. An `OrderDigestInvalidated` event has been emitted.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `revokeOrderDigest(bytes32 orderDigest)`\\n     */\\n    function revokeOrderDigest(bytes calldata data) external \\n    delegateCall(_moduleOnChainCancellation, SELECTOR_REVOKE_ORDER_DIGEST, data) {}\\n\\n    /**************************************************************/\\n    /*                      TAKER OPERATIONS                      */\\n    /**************************************************************/\\n\\n    /**\\n     * @notice Executes a buy listing transaction for a single order item.\\n     *\\n     * @dev    Throws when the maker's nonce has already been used or has been cancelled.\\n     * @dev    Throws when the order has expired.\\n     * @dev    Throws when the combined marketplace and royalty fee exceeds 100%.\\n     * @dev    Throws when the taker fee on top exceeds 100% of the item sale price.\\n     * @dev    Throws when the maker's master nonce does not match the order details.\\n     * @dev    Throws when the order does not comply with the collection payment settings.\\n     * @dev    Throws when the maker's signature is invalid.\\n     * @dev    Throws when the order is a cosigned order and the cosignature is invalid.\\n     * @dev    Throws when the transaction originates from an untrusted channel if untrusted channels are blocked.\\n     * @dev    Throws when the maker or taker is a banned account for the collection.\\n     * @dev    Throws when the taker does not have or did not send sufficient funds to complete the purchase.\\n     * @dev    Throws when the token transfer fails for any reason such as lack of approvals or token no longer owned by maker.\\n     * @dev    Throws when the maker has revoked the order digest on a ERC1155_PARTIAL_FILL order.\\n     * @dev    Throws when the order is an ERC1155_PARTIAL_FILL order and the item price is not evenly divisible by the amount.\\n     * @dev    Throws when the order is an ERC1155_PARTIAL_FILL order and the remaining fillable quantity is less than the requested minimum fill amount.\\n     * @dev    Any unused native token payment will be returned to the taker as wrapped native token.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. Payment amounts and fees are sent to their respective recipients.\\n     * @dev    2. Purchased tokens are sent to the beneficiary.\\n     * @dev    3. Maker's nonce is marked as used for ERC721_FILL_OR_KILL and ERC1155_FILL_OR_KILL orders.\\n     * @dev    4. Maker's partially fillable order state is updated for ERC1155_PARTIAL_FILL orders.\\n     * @dev    5. An `BuyListingERC721` event has been emitted for a ERC721 purchase.\\n     * @dev    6. An `BuyListingERC1155` event has been emitted for a ERC1155 purchase.\\n     * @dev    7. A `NonceInvalidated` event has been emitted for a ERC721_FILL_OR_KILL or ERC1155_FILL_OR_KILL order.\\n     * @dev    8. A `OrderDigestInvalidated` event has been emitted for a ERC1155_PARTIAL_FILL order, if fully filled.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `function buyListing(\\n     *                  bytes32 domainSeparator, \\n     *                  Order memory saleDetails, \\n     *                  SignatureECDSA memory sellerSignature,\\n     *                  Cosignature memory cosignature,\\n     *                  FeeOnTop memory feeOnTop)`\\n     */\\n    function buyListing(bytes calldata data) external payable \\n    delegateCallReplaceDomainSeparator(_moduleTrades, SELECTOR_BUY_LISTING, data) {}\\n\\n    /**\\n     * @notice Executes an offer accept transaction for a single order item.\\n     *\\n     * @dev    Throws when the maker's nonce has already been used or has been cancelled.\\n     * @dev    Throws when the order has expired.\\n     * @dev    Throws when the combined marketplace and royalty fee exceeds 100%.\\n     * @dev    Throws when the taker fee on top exceeds 100% of the item sale price.\\n     * @dev    Throws when the maker's master nonce does not match the order details.\\n     * @dev    Throws when the order does not comply with the collection payment settings.\\n     * @dev    Throws when the maker's signature is invalid.\\n     * @dev    Throws when the order is a cosigned order and the cosignature is invalid.\\n     * @dev    Throws when the transaction originates from an untrusted channel if untrusted channels are blocked.\\n     * @dev    Throws when the maker or taker is a banned account for the collection.\\n     * @dev    Throws when the maker does not have sufficient funds to complete the purchase.\\n     * @dev    Throws when the token transfer fails for any reason such as lack of approvals or token not owned by the taker.\\n     * @dev    Throws when the token the offer is being accepted for does not match the conditions set by the maker.\\n     * @dev    Throws when the maker has revoked the order digest on a ERC1155_PARTIAL_FILL order.\\n     * @dev    Throws when the order is an ERC1155_PARTIAL_FILL order and the item price is not evenly divisible by the amount.\\n     * @dev    Throws when the order is an ERC1155_PARTIAL_FILL order and the remaining fillable quantity is less than the requested minimum fill amount.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. Payment amounts and fees are sent to their respective recipients.\\n     * @dev    2. Purchased tokens are sent to the beneficiary.\\n     * @dev    3. Maker's nonce is marked as used for ERC721_FILL_OR_KILL and ERC1155_FILL_OR_KILL orders.\\n     * @dev    4. Maker's partially fillable order state is updated for ERC1155_PARTIAL_FILL orders.\\n     * @dev    5. An `AcceptOfferERC721` event has been emitted for a ERC721 sale.\\n     * @dev    6. An `AcceptOfferERC1155` event has been emitted for a ERC1155 sale.\\n     * @dev    7. A `NonceInvalidated` event has been emitted for a ERC721_FILL_OR_KILL or ERC1155_FILL_OR_KILL order.\\n     * @dev    8. A `OrderDigestInvalidated` event has been emitted for a ERC1155_PARTIAL_FILL order, if fully filled.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `function acceptOffer(\\n     *                  bytes32 domainSeparator, \\n     *                  bool isCollectionLevelOffer, \\n     *                  Order memory saleDetails, \\n     *                  SignatureECDSA memory buyerSignature,\\n     *                  TokenSetProof memory tokenSetProof,\\n     *                  Cosignature memory cosignature,\\n     *                  FeeOnTop memory feeOnTop)`\\n     */\\n    function acceptOffer(bytes calldata data) external payable \\n    delegateCallReplaceDomainSeparator(_moduleTrades, SELECTOR_ACCEPT_OFFER, data) {}\\n\\n    /**\\n     * @notice Executes a buy listing transaction for multiple order items.\\n     *\\n     * @dev    Throws when a maker's nonce has already been used or has been cancelled.\\n     * @dev    Throws when any order has expired.\\n     * @dev    Throws when any combined marketplace and royalty fee exceeds 100%.\\n     * @dev    Throws when any taker fee on top exceeds 100% of the item sale price.\\n     * @dev    Throws when a maker's master nonce does not match the order details.\\n     * @dev    Throws when an order does not comply with the collection payment settings.\\n     * @dev    Throws when a maker's signature is invalid.\\n     * @dev    Throws when an order is a cosigned order and the cosignature is invalid.\\n     * @dev    Throws when the transaction originates from an untrusted channel if untrusted channels are blocked.\\n     * @dev    Throws when any maker or taker is a banned account for the collection.\\n     * @dev    Throws when the taker does not have or did not send sufficient funds to complete the purchase.\\n     * @dev    Throws when a maker has revoked the order digest on a ERC1155_PARTIAL_FILL order.\\n     * @dev    Throws when an order is an ERC1155_PARTIAL_FILL order and the item price is not evenly divisible by the amount.\\n     * @dev    Throws when an order is an ERC1155_PARTIAL_FILL order and the remaining fillable quantity is less than the requested minimum fill amount.\\n     * @dev    Will NOT throw when a token fails to transfer but also will not disperse payments for failed items.\\n     * @dev    Any unused native token payment will be returned to the taker as wrapped native token.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. Payment amounts and fees are sent to their respective recipients.\\n     * @dev    2. Purchased tokens are sent to the beneficiary.\\n     * @dev    3. Makers nonces are marked as used for ERC721_FILL_OR_KILL and ERC1155_FILL_OR_KILL orders.\\n     * @dev    4. Makers partially fillable order states are updated for ERC1155_PARTIAL_FILL orders.\\n     * @dev    5. `BuyListingERC721` events have been emitted for each ERC721 purchase.\\n     * @dev    6. `BuyListingERC1155` events have been emitted for each ERC1155 purchase.\\n     * @dev    7. A `NonceInvalidated` event has been emitted for each ERC721_FILL_OR_KILL or ERC1155_FILL_OR_KILL order.\\n     * @dev    8. A `OrderDigestInvalidated` event has been emitted for each ERC1155_PARTIAL_FILL order, if fully filled.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `function bulkBuyListings(\\n     *                  bytes32 domainSeparator, \\n     *                  Order[] calldata saleDetailsArray,\\n     *                  SignatureECDSA[] calldata sellerSignatures,\\n     *                  Cosignature[] calldata cosignatures,\\n     *                  FeeOnTop[] calldata feesOnTop)`\\n     */\\n    function bulkBuyListings(bytes calldata data) external payable \\n    delegateCallReplaceDomainSeparator(_moduleTrades, SELECTOR_BULK_BUY_LISTINGS, data) {}\\n\\n    /**\\n     * @notice Executes an accept offer transaction for multiple order items.\\n     *\\n     * @dev    Throws when a maker's nonce has already been used or has been cancelled.\\n     * @dev    Throws when any order has expired.\\n     * @dev    Throws when any combined marketplace and royalty fee exceeds 100%.\\n     * @dev    Throws when any taker fee on top exceeds 100% of the item sale price.\\n     * @dev    Throws when a maker's master nonce does not match the order details.\\n     * @dev    Throws when an order does not comply with the collection payment settings.\\n     * @dev    Throws when a maker's signature is invalid.\\n     * @dev    Throws when an order is a cosigned order and the cosignature is invalid.\\n     * @dev    Throws when the transaction originates from an untrusted channel if untrusted channels are blocked.\\n     * @dev    Throws when any maker or taker is a banned account for the collection.\\n     * @dev    Throws when a maker does not have sufficient funds to complete the purchase.\\n     * @dev    Throws when the token an offer is being accepted for does not match the conditions set by the maker.\\n     * @dev    Throws when a maker has revoked the order digest on a ERC1155_PARTIAL_FILL order.\\n     * @dev    Throws when an order is an ERC1155_PARTIAL_FILL order and the item price is not evenly divisible by the amount.\\n     * @dev    Throws when an order is an ERC1155_PARTIAL_FILL order and the remaining fillable quantity is less than the requested minimum fill amount.\\n     * @dev    Will NOT throw when a token fails to transfer but also will not disperse payments for failed items.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. Payment amounts and fees are sent to their respective recipients.\\n     * @dev    2. Purchased tokens are sent to the beneficiary.\\n     * @dev    3. Makers nonces are marked as used for ERC721_FILL_OR_KILL and ERC1155_FILL_OR_KILL orders.\\n     * @dev    4. Makers partially fillable order states are updated for ERC1155_PARTIAL_FILL orders.\\n     * @dev    5. `AcceptOfferERC721` events have been emitted for each ERC721 sale.\\n     * @dev    6. `AcceptOfferERC1155` events have been emitted for each ERC1155 sale.\\n     * @dev    7. A `NonceInvalidated` event has been emitted for each ERC721_FILL_OR_KILL or ERC1155_FILL_OR_KILL order.\\n     * @dev    8. A `OrderDigestInvalidated` event has been emitted for each ERC1155_PARTIAL_FILL order, if fully filled.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `function bulkAcceptOffers(\\n     *                  bytes32 domainSeparator, \\n     *                  BulkAcceptOffersParams memory params)`\\n     */\\n    function bulkAcceptOffers(bytes calldata data) external payable \\n    delegateCallReplaceDomainSeparator(_moduleTrades, SELECTOR_BULK_ACCEPT_OFFERS, data) {}\\n\\n    /**\\n     * @notice Executes a sweep transaction for buying multiple items from the same collection.\\n     *\\n     * @dev    Throws when the sweep order protocol is ERC1155_PARTIAL_FILL (unsupported).\\n     * @dev    Throws when a maker's nonce has already been used or has been cancelled.\\n     * @dev    Throws when any order has expired.\\n     * @dev    Throws when any combined marketplace and royalty fee exceeds 100%.\\n     * @dev    Throws when the taker fee on top exceeds 100% of the combined item sale prices.\\n     * @dev    Throws when a maker's master nonce does not match the order details.\\n     * @dev    Throws when an order does not comply with the collection payment settings.\\n     * @dev    Throws when a maker's signature is invalid.\\n     * @dev    Throws when an order is a cosigned order and the cosignature is invalid.\\n     * @dev    Throws when the transaction originates from an untrusted channel if untrusted channels are blocked.\\n     * @dev    Throws when any maker or taker is a banned account for the collection.\\n     * @dev    Throws when the taker does not have or did not send sufficient funds to complete the purchase.\\n     * @dev    Will NOT throw when a token fails to transfer but also will not disperse payments for failed items.\\n     * @dev    Any unused native token payment will be returned to the taker as wrapped native token.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. Payment amounts and fees are sent to their respective recipients.\\n     * @dev    2. Purchased tokens are sent to the beneficiary.\\n     * @dev    3. Makers nonces are marked as used for ERC721_FILL_OR_KILL and ERC1155_FILL_OR_KILL orders.\\n     * @dev    4. Makers partially fillable order states are updated for ERC1155_PARTIAL_FILL orders.\\n     * @dev    5. `BuyListingERC721` events have been emitted for each ERC721 purchase.\\n     * @dev    6. `BuyListingERC1155` events have been emitted for each ERC1155 purchase.\\n     * @dev    7. A `NonceInvalidated` event has been emitted for each ERC721_FILL_OR_KILL or ERC1155_FILL_OR_KILL order.\\n     *\\n     * @param  data Calldata encoded with PaymentProcessorEncoder.  Matches calldata for:\\n     *              `function sweepCollection(\\n     *                  bytes32 domainSeparator, \\n     *                  FeeOnTop memory feeOnTop,\\n     *                  SweepOrder memory sweepOrder,\\n     *                  SweepItem[] calldata items,\\n     *                  SignatureECDSA[] calldata signedSellOrders,\\n     *                  Cosignature[] memory cosignatures)`\\n     */\\n    function sweepCollection(bytes calldata data) external payable \\n    delegateCallReplaceDomainSeparator(_moduleTradesAdvanced, SELECTOR_SWEEP_COLLECTION, data) {}\\n}\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\n// keccack256(\\\"Cosignature(uint8 v,bytes32 r,bytes32 s,uint256 expiration,address taker)\\\")\\nbytes32 constant COSIGNATURE_HASH = 0x347b7818601b168f6faadc037723496e9130b057c1ffef2ec4128311e19142f2;\\n\\n// keccack256(\\\"CollectionOfferApproval(uint8 protocol,address cosigner,address buyer,address beneficiary,address marketplace,address fallbackRoyaltyRecipient,address paymentMethod,address tokenAddress,uint256 amount,uint256 itemPrice,uint256 expiration,uint256 marketplaceFeeNumerator,uint256 nonce,uint256 masterNonce)\\\")\\nbytes32 constant COLLECTION_OFFER_APPROVAL_HASH = 0x8fe9498e93fe26b30ebf76fac07bd4705201c8609227362697082288e3b4af9c;\\n\\n// keccack256(\\\"ItemOfferApproval(uint8 protocol,address cosigner,address buyer,address beneficiary,address marketplace,address fallbackRoyaltyRecipient,address paymentMethod,address tokenAddress,uint256 tokenId,uint256 amount,uint256 itemPrice,uint256 expiration,uint256 marketplaceFeeNumerator,uint256 nonce,uint256 masterNonce)\\\")\\nbytes32 constant ITEM_OFFER_APPROVAL_HASH = 0xce2e9706d63e89ddf7ee16ce0508a1c3c9bd1904c582db2e647e6f4690a0bf6b;\\n\\n//   keccack256(\\\"TokenSetOfferApproval(uint8 protocol,address cosigner,address buyer,address beneficiary,address marketplace,address fallbackRoyaltyRecipient,address paymentMethod,address tokenAddress,uint256 amount,uint256 itemPrice,uint256 expiration,uint256 marketplaceFeeNumerator,uint256 nonce,uint256 masterNonce,bytes32 tokenSetMerkleRoot)\\\")\\nbytes32 constant TOKEN_SET_OFFER_APPROVAL_HASH = 0x244905ade6b0e455d12fb539a4b17d7f675db14797d514168d09814a09c70e70;\\n\\n// keccack256(\\\"SaleApproval(uint8 protocol,address cosigner,address seller,address marketplace,address fallbackRoyaltyRecipient,address paymentMethod,address tokenAddress,uint256 tokenId,uint256 amount,uint256 itemPrice,uint256 expiration,uint256 marketplaceFeeNumerator,uint256 maxRoyaltyFeeNumerator,uint256 nonce,uint256 masterNonce)\\\")\\nbytes32 constant SALE_APPROVAL_HASH = 0x938786a8256d04dc45d6d5b997005aa07c0c9e3e4925d0d6c33128d240096ebc;\\n\\n// The denominator used when calculating the marketplace fee.\\n// 0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\nuint256 constant FEE_DENOMINATOR = 100_00;\\n\\n// Default Payment Method Whitelist Id\\nuint32 constant DEFAULT_PAYMENT_METHOD_WHITELIST_ID = 0;\\n\\n// Convenience to avoid magic number in bitmask get/set logic.\\nuint256 constant ZERO = uint256(0);\\nuint256 constant ONE = uint256(1);\\n\\n// The default admin role for NFT collections using Access Control.\\nbytes32 constant DEFAULT_ACCESS_CONTROL_ADMIN_ROLE = 0x00;\\n\\n/// @dev The plain text message to sign for cosigner self-destruct signature verification\\nstring constant COSIGNER_SELF_DESTRUCT_MESSAGE_TO_SIGN = \\\"COSIGNER_SELF_DESTRUCT\\\";\\n\\n/**************************************************************/\\n/*                   PRECOMPUTED SELECTORS                    */\\n/**************************************************************/\\n\\nbytes4 constant SELECTOR_REASSIGN_OWNERSHIP_OF_PAYMENT_METHOD_WHITELIST= hex\\\"a1e6917e\\\";\\nbytes4 constant SELECTOR_RENOUNCE_OWNERSHIP_OF_PAYMENT_METHOD_WHITELIST= hex\\\"0886702e\\\";\\nbytes4 constant SELECTOR_WHITELIST_PAYMENT_METHOD = hex\\\"bb39ce91\\\";\\nbytes4 constant SELECTOR_UNWHITELIST_PAYMENT_METHOD = hex\\\"e9d4c14e\\\";\\nbytes4 constant SELECTOR_SET_COLLECTION_PAYMENT_SETTINGS = hex\\\"fc5d8393\\\";\\nbytes4 constant SELECTOR_SET_COLLECTION_PRICING_BOUNDS = hex\\\"7141ae10\\\";\\nbytes4 constant SELECTOR_SET_TOKEN_PRICING_BOUNDS = hex\\\"22146d70\\\";\\nbytes4 constant SELECTOR_ADD_TRUSTED_CHANNEL_FOR_COLLECTION = hex\\\"ab559c14\\\";\\nbytes4 constant SELECTOR_REMOVE_TRUSTED_CHANNEL_FOR_COLLECTION = hex\\\"282e89f8\\\";\\nbytes4 constant SELECTOR_ADD_BANNED_ACCOUNT_FOR_COLLECTION = hex\\\"e21dde50\\\";\\nbytes4 constant SELECTOR_REMOVE_BANNED_ACCOUNT_FOR_COLLECTION = hex\\\"adf14a76\\\";\\n\\nbytes4 constant SELECTOR_DESTROY_COSIGNER = hex\\\"2aebdefe\\\";\\nbytes4 constant SELECTOR_REVOKE_MASTER_NONCE = hex\\\"226d4adb\\\";\\nbytes4 constant SELECTOR_REVOKE_SINGLE_NONCE = hex\\\"b6d7dc33\\\";\\nbytes4 constant SELECTOR_REVOKE_ORDER_DIGEST = hex\\\"96ae0380\\\";\\n\\nbytes4 constant SELECTOR_BUY_LISTING = hex\\\"a9272951\\\";\\nbytes4 constant SELECTOR_ACCEPT_OFFER = hex\\\"e35bb9b7\\\";\\nbytes4 constant SELECTOR_BULK_BUY_LISTINGS = hex\\\"27add047\\\";\\nbytes4 constant SELECTOR_BULK_ACCEPT_OFFERS = hex\\\"b3cdebdb\\\";\\nbytes4 constant SELECTOR_SWEEP_COLLECTION = hex\\\"206576f6\\\";\\n\\n/**************************************************************/\\n/*                   EXPECTED BASE msg.data LENGTHS           */\\n/**************************************************************/\\n\\nuint256 constant PROOF_ELEMENT_SIZE = 32;\\n\\n// | 4        | 32              | 512         | 96              | 192         | 64       | = 900 bytes\\n// | selector | domainSeparator | saleDetails | sellerSignature | cosignature | feeOnTop |\\nuint256 constant BASE_MSG_LENGTH_BUY_LISTING = 900;\\n\\n// | 4        | 32              | 32                     | 512         |  96             | 32 + (96 + (32 * proof.length)) | 192         | 64       | = 1060 bytes + (32 * proof.length)\\n// | selector | domainSeparator | isCollectionLevelOffer | saleDetails |  buyerSignature | tokenSetProof                   | cosignature | feeOnTop |\\nuint256 constant BASE_MSG_LENGTH_ACCEPT_OFFER = 1060;\\n\\n// | 4        | 32              | 64              | 512 * length      | 64              | 96 * length      | 64              | 192 * length | 64              | 64 * length | = 292 bytes + (864 * saleDetailsArray.length)\\n// | selector | domainSeparator | length + offset | saleDetailsArray  | length + offset | sellerSignatures | length + offset | cosignatures | length + offset | feesOnTop   |\\nuint256 constant BASE_MSG_LENGTH_BULK_BUY_LISTINGS = 292;\\nuint256 constant BASE_MSG_LENGTH_BULK_BUY_LISTINGS_PER_ITEM = 864;\\n\\n// | 4        | 32              | 32           | 64              | 32 * length                 | 64              | 512 * length      | 64              | 96 * length          | 64              | 32 + (96 + (32 * proof.length)) | 64              | 192 * length | 64              | 64 * length | = 452 bytes + (1024 * saleDetailsArray.length) + (32 * proof.length [for each element])\\n// | selector | domainSeparator | struct info? | length + offset | isCollectionLevelOfferArray | length + offset | saleDetailsArray  | length + offset | buyerSignaturesArray | length + offset | tokenSetProof                   | length + offset | cosignatures | length + offset | feesOnTop   |\\nuint256 constant BASE_MSG_LENGTH_BULK_ACCEPT_OFFERS = 452;\\nuint256 constant BASE_MSG_LENGTH_BULK_ACCEPT_OFFERS_PER_ITEM = 1024;\\n\\n// | 4        | 32              | 64       | 128        | 64              | 320 * length | 64              | 96 * length      | 64              | 192 * length | = 420 bytes + (608 * items.length)\\n// | selector | domainSeparator | feeOnTop | sweepOrder | length + offset | items        | length + offset | signedSellOrders | length + offset | cosignatures |\\nuint256 constant BASE_MSG_LENGTH_SWEEP_COLLECTION = 420;\\nuint256 constant BASE_MSG_LENGTH_SWEEP_COLLECTION_PER_ITEM = 608;\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\n/// @dev Thrown when an order is an ERC721 order and the amount is not one.\\nerror PaymentProcessor__AmountForERC721SalesMustEqualOne();\\n\\n/// @dev Thrown when an order is an ERC1155 order and the amount is zero.\\nerror PaymentProcessor__AmountForERC1155SalesGreaterThanZero();\\n\\n/// @dev Thrown when an offer is being accepted and the payment method is the chain native token.\\nerror PaymentProcessor__BadPaymentMethod();\\n\\n/// @dev Thrown when adding or removing a payment method from a whitelist that the caller does not own.\\nerror PaymentProcessor__CallerDoesNotOwnPaymentMethodWhitelist();\\n\\n/**\\n * @dev Thrown when modifying collection payment settings, pricing bounds, or trusted channels on a collection\\n * @dev that the caller is not the owner of or a member of the default admin role for.\\n */\\nerror PaymentProcessor__CallerMustHaveElevatedPermissionsForSpecifiedNFT();\\n\\n/// @dev Thrown when setting a collection or token pricing constraint with a floor price greater than ceiling price.\\nerror PaymentProcessor__CeilingPriceMustBeGreaterThanFloorPrice();\\n\\n/// @dev Thrown when adding a trusted channel that is not a trusted forwarder deployed by the trusted forwarder factory.\\nerror PaymentProcessor__ChannelIsNotTrustedForwarder();\\n\\n/// @dev Thrown when removing a payment method from a whitelist when that payment method is not on the whitelist.\\nerror PaymentProcessor__CoinIsNotApproved();\\n\\n/// @dev Thrown when the current block time is greater than the expiration time for the cosignature.\\nerror PaymentProcessor__CosignatureHasExpired();\\n\\n/// @dev Thrown when the cosigner has self destructed.\\nerror PaymentProcessor__CosignerHasSelfDestructed();\\n\\n/// @dev Thrown when a token failed to transfer to the beneficiary and partial fills are disabled.\\nerror PaymentProcessor__DispensingTokenWasUnsuccessful();\\n\\n/// @dev Thrown when a maker is a contract and the contract does not return the correct EIP1271 response to validate the signature.\\nerror PaymentProcessor__EIP1271SignatureInvalid();\\n\\n/// @dev Thrown when a native token transfer call fails to transfer the tokens.\\nerror PaymentProcessor__FailedToTransferProceeds();\\n\\n/// @dev Thrown when the additional fee on top exceeds the item price.\\nerror PaymentProcessor__FeeOnTopCannotBeGreaterThanItemPrice();\\n\\n/// @dev Thrown when the supplied root hash, token and proof do not match.\\nerror PaymentProcessor__IncorrectTokenSetMerkleProof();\\n\\n/// @dev Thrown when an input array has zero items in a location where it must have items.\\nerror PaymentProcessor__InputArrayLengthCannotBeZero();\\n\\n/// @dev Thrown when multiple input arrays have different lengths but are required to be the same length.\\nerror PaymentProcessor__InputArrayLengthMismatch();\\n\\n/// @dev Thrown when Payment Processor or a module is being deployed with invalid constructor arguments.\\nerror PaymentProcessor__InvalidConstructorArguments();\\n\\n/// @dev Thrown when the maker or taker is a banned account on the collection being traded.\\nerror PaymentProcessor__MakerOrTakerIsBannedAccount();\\n\\n/// @dev Thrown when the combined marketplace and royalty fees will exceed the item price.\\nerror PaymentProcessor__MarketplaceAndRoyaltyFeesWillExceedSalePrice();\\n\\n/// @dev Thrown when the recovered address from a cosignature does not match the order cosigner.\\nerror PaymentProcessor__NotAuthorizedByCosigner();\\n\\n/// @dev Thrown when the ERC2981 or backfilled royalties exceed the maximum fee specified by the order maker.\\nerror PaymentProcessor__OnchainRoyaltiesExceedMaximumApprovedRoyaltyFee();\\n\\n/// @dev Thrown when the current block timestamp is greater than the order expiration time.\\nerror PaymentProcessor__OrderHasExpired();\\n\\n/// @dev Thrown when attempting to fill a partially fillable order that has already been filled or cancelled.\\nerror PaymentProcessor__OrderIsEitherCancelledOrFilled();\\n\\n/// @dev Thrown when attempting to execute a sweep order for partially fillable orders.\\nerror PaymentProcessor__OrderProtocolERC1155FillPartialUnsupportedInSweeps();\\n\\n/// @dev Thrown when attempting to partially fill an order where the item price is not equally divisible by the amount of tokens.\\nerror PaymentProcessor__PartialFillsNotSupportedForNonDivisibleItems();\\n\\n/// @dev Thrown when attempting to execute an order with a payment method that is not allowed by the collection payment settings.\\nerror PaymentProcessor__PaymentCoinIsNotAnApprovedPaymentMethod();\\n\\n/// @dev Thrown when adding a payment method to a whitelist when that payment method is already on the list.\\nerror PaymentProcessor__PaymentMethodIsAlreadyApproved();\\n\\n/// @dev Thrown when setting collection payment settings with a whitelist id that does not exist.\\nerror PaymentProcessor__PaymentMethodWhitelistDoesNotExist();\\n\\n/// @dev Thrown when attempting to transfer ownership of a payment method whitelist to the zero address.\\nerror PaymentProcessor__PaymentMethodWhitelistOwnershipCannotBeTransferredToZeroAddress();\\n\\n/// @dev Thrown when distributing payments and fees in native token and the amount remaining is less than the amount to distribute.\\nerror PaymentProcessor__RanOutOfNativeFunds();\\n\\n/// @dev Thrown when attempting to set a royalty backfill numerator that would result in royalties greater than 100%.\\nerror PaymentProcessor__RoyaltyBackfillNumeratorCannotExceedFeeDenominator();\\n\\n/// @dev Thrown when attempting to set a royalty bounty numerator that would result in royalty bounties greater than 100%.\\nerror PaymentProcessor__RoyaltyBountyNumeratorCannotExceedFeeDenominator();\\n\\n/// @dev Thrown when a collection is set to pricing constraints and the item price exceeds the defined maximum price.\\nerror PaymentProcessor__SalePriceAboveMaximumCeiling();\\n\\n/// @dev Thrown when a collection is set to pricing constraints and the item price is below the defined minimum price.\\nerror PaymentProcessor__SalePriceBelowMinimumFloor();\\n\\n/// @dev Thrown when a maker's nonce has already been used for an executed order or cancelled by the maker.\\nerror PaymentProcessor__SignatureAlreadyUsedOrRevoked();\\n\\n/**\\n * @dev Thrown when a collection is set to block untrusted channels and the order execution originates from a channel \\n * @dev that is not in the collection's trusted channel list.\\n */ \\nerror PaymentProcessor__TradeOriginatedFromUntrustedChannel();\\n\\n/// @dev Thrown when a trading of a specific collection has been paused by the collection owner or admin.\\nerror PaymentProcessor__TradingIsPausedForCollection();\\n\\n/**\\n * @dev Thrown when attempting to fill a partially fillable order and the amount available to fill \\n * @dev is less than the specified minimum to fill.\\n */\\nerror PaymentProcessor__UnableToFillMinimumRequestedQuantity();\\n\\n/// @dev Thrown when the recovered signer for an order does not match the order maker.\\nerror PaymentProcessor__UnauthorizedOrder();\\n\\n/// @dev Thrown when the taker on a cosigned order does not match the taker on the cosignature.\\nerror PaymentProcessor__UnauthorizedTaker();\\n\\n/// @dev Thrown when the Payment Processor or a module is being deployed with uninitialized configuration values.\\nerror PaymentProcessor__UninitializedConfiguration();\"\r\n    },\r\n    \"src/interfaces/IPaymentProcessorConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\nimport \\\"../DataTypes.sol\\\";\\n\\n/** \\n* @title PaymentProcessor\\n* @custom:version 2.0.0\\n* @author Limit Break, Inc.\\n*/ \\ninterface IPaymentProcessorConfiguration {\\n\\n    /**\\n     * @notice Returns the ERC2771 context setup params for payment processor modules.\\n     */\\n    function getPaymentProcessorModuleERC2771ContextParams() \\n        external \\n        view \\n        returns (\\n            address /*trustedForwarderFactory*/\\n        );\\n\\n    /**\\n     * @notice Returns the setup params for payment processor modules.\\n     */\\n    function getPaymentProcessorModuleDeploymentParams() \\n        external \\n        view \\n        returns (\\n            uint32, /*defaultPushPaymentGasLimit*/\\n            address, /*wrappedNativeCoin*/\\n            DefaultPaymentMethods memory /*defaultPaymentMethods*/\\n        );\\n\\n    /**\\n     * @notice Returns the setup params for payment processor.\\n     */\\n    function getPaymentProcessorDeploymentParams()\\n        external\\n        view\\n        returns (\\n            address, /*defaultContractOwner*/\\n            PaymentProcessorModules memory /*paymentProcessorModules*/\\n        );\\n}\"\r\n    },\r\n    \"src/interfaces/IPaymentProcessorEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\nimport \\\"../DataTypes.sol\\\";\\n\\n/** \\n* @title Payment Processor\\n* @custom:version 2.0.0\\n* @author Limit Break, Inc.\\n*/ \\ninterface IPaymentProcessorEvents {\\n    /// @notice Emitted when an account is banned from trading a collection\\n    event BannedAccountAddedForCollection(\\n        address indexed tokenAddress, \\n        address indexed account);\\n\\n    /// @notice Emitted when an account ban has been lifted on a collection\\n    event BannedAccountRemovedForCollection(\\n        address indexed tokenAddress, \\n        address indexed account);\\n\\n    /// @notice Emitted when an ERC721 listing is purchased.\\n    event BuyListingERC721(\\n        address indexed buyer,\\n        address indexed seller,\\n        address indexed tokenAddress,\\n        address beneficiary,\\n        address paymentCoin,\\n        uint256 tokenId,\\n        uint256 salePrice);\\n\\n    /// @notice Emitted when an ERC1155 listing is purchased.\\n    event BuyListingERC1155(\\n        address indexed buyer,\\n        address indexed seller,\\n        address indexed tokenAddress,\\n        address beneficiary,\\n        address paymentCoin,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 salePrice);\\n\\n    /// @notice Emitted when an ERC721 offer is accepted.\\n    event AcceptOfferERC721(\\n        address indexed seller,\\n        address indexed buyer,\\n        address indexed tokenAddress,\\n        address beneficiary,\\n        address paymentCoin,\\n        uint256 tokenId,\\n        uint256 salePrice);\\n\\n    /// @notice Emitted when an ERC1155 offer is accepted.\\n    event AcceptOfferERC1155(\\n        address indexed seller,\\n        address indexed buyer,\\n        address indexed tokenAddress,\\n        address beneficiary,\\n        address paymentCoin,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 salePrice);\\n\\n    /// @notice Emitted when a new payment method whitelist is created.\\n    event CreatedPaymentMethodWhitelist(\\n        uint32 indexed paymentMethodWhitelistId, \\n        address indexed whitelistOwner,\\n        string whitelistName);\\n\\n    /// @notice Emitted when a cosigner destroys itself.\\n    event DestroyedCosigner(address indexed cosigner);\\n\\n    /// @notice Emitted when a user revokes all of their existing listings or offers that share the master nonce.\\n    event MasterNonceInvalidated(address indexed account, uint256 nonce);\\n\\n    /// @notice Emitted when a user revokes a single listing or offer nonce for a specific marketplace.\\n    event NonceInvalidated(\\n        uint256 indexed nonce, \\n        address indexed account, \\n        bool wasCancellation);\\n\\n    /// @notice Emitted when a user revokes a single listing or offer nonce for a specific marketplace.\\n    event OrderDigestInvalidated(\\n        bytes32 indexed orderDigest, \\n        address indexed account, \\n        bool wasCancellation);\\n\\n    /// @notice Emitted when a coin is added to the approved coins mapping for a security policy\\n    event PaymentMethodAddedToWhitelist(\\n        uint32 indexed paymentMethodWhitelistId, \\n        address indexed paymentMethod);\\n\\n    /// @notice Emitted when a coin is removed from the approved coins mapping for a security policy\\n    event PaymentMethodRemovedFromWhitelist(\\n        uint32 indexed paymentMethodWhitelistId, \\n        address indexed paymentMethod);\\n\\n    /// @notice Emitted when a payment method whitelist is reassigned to a new owner\\n    event ReassignedPaymentMethodWhitelistOwnership(uint32 indexed id, address indexed newOwner);\\n\\n    /// @notice Emitted when a trusted channel is added for a collection\\n    event TrustedChannelAddedForCollection(\\n        address indexed tokenAddress, \\n        address indexed channel);\\n\\n    /// @notice Emitted when a trusted channel is removed for a collection\\n    event TrustedChannelRemovedForCollection(\\n        address indexed tokenAddress, \\n        address indexed channel);\\n\\n    /// @notice Emitted whenever pricing bounds change at a collection level for price-constrained collections.\\n    event UpdatedCollectionLevelPricingBoundaries(\\n        address indexed tokenAddress, \\n        uint256 floorPrice, \\n        uint256 ceilingPrice);\\n\\n    /// @notice Emitted whenever the supported ERC-20 payment is set for price-constrained collections.\\n    event UpdatedCollectionPaymentSettings(\\n        address indexed tokenAddress, \\n        PaymentSettings paymentSettings, \\n        uint32 indexed paymentMethodWhitelistId, \\n        address indexed constrainedPricingPaymentMethod,\\n        uint16 royaltyBackfillNumerator,\\n        address royaltyBackfillReceiver,\\n        uint16 royaltyBountyNumerator,\\n        address exclusiveBountyReceiver,\\n        bool blockTradesFromUntrustedChannels,\\n        bool blockBannedAccounts);\\n\\n    /// @notice Emitted whenever pricing bounds change at a token level for price-constrained collections.\\n    event UpdatedTokenLevelPricingBoundaries(\\n        address indexed tokenAddress, \\n        uint256 indexed tokenId, \\n        uint256 floorPrice, \\n        uint256 ceilingPrice);\\n}\"\r\n    },\r\n    \"src/interfaces/IModuleDefaultPaymentMethods.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\n/** \\n* @title Payment Processor\\n* @custom:version 2.0.0\\n* @author Limit Break, Inc.\\n*/ \\ninterface IModuleDefaultPaymentMethods {\\n\\n    /**\\n     * @notice Returns the list of default payment methods that Payment Processor supports.\\n     */\\n    function getDefaultPaymentMethods() external view returns (address[] memory);\\n}\"\r\n    },\r\n    \"src/storage/PaymentProcessorStorageAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\nimport \\\"../DataTypes.sol\\\";\\n\\n/** \\n* @title Payment Processor\\n* @custom:version 2.0.0\\n* @author Limit Break, Inc.\\n*/ \\ncontract PaymentProcessorStorageAccess {\\n\\n    /// @dev The base storage slot for Payment Processor contract storage items.\\n    bytes32 constant DIAMOND_STORAGE_PAYMENT_PROCESSOR = \\n        keccak256(\\\"diamond.storage.payment.processor\\\");\\n\\n    /**\\n     * @dev Returns a storage object that follows the Diamond standard storage pattern for\\n     * @dev contract storage across multiple module contracts.\\n     */\\n    function appStorage() internal pure returns (PaymentProcessorStorage storage diamondStorage) {\\n        bytes32 slot = DIAMOND_STORAGE_PAYMENT_PROCESSOR;\\n        assembly {\\n            diamondStorage.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-712 is Final as of 2022-08-11. This file is deprecated.\\n\\nimport \\\"./EIP712.sol\\\";\\n\"\r\n    },\r\n    \"src/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Used internally to indicate which side of the order the taker is on.\\n */\\nenum Sides { \\n    // 0: Taker is on buy side of order.\\n    Buy, \\n\\n    // 1: Taker is on sell side of order.\\n    Sell \\n}\\n\\n/**\\n * @dev Defines condition to apply to order execution.\\n */\\nenum OrderProtocols { \\n    // 0: ERC721 order that must execute in full or not at all.\\n    ERC721_FILL_OR_KILL,\\n\\n    // 1: ERC1155 order that must execute in full or not at all.\\n    ERC1155_FILL_OR_KILL,\\n\\n    // 2: ERC1155 order that may be partially executed.\\n    ERC1155_FILL_PARTIAL\\n}\\n\\n/**\\n * @dev Defines the rules applied to a collection for payments.\\n */\\nenum PaymentSettings { \\n    // 0: Utilize Payment Processor default whitelist.\\n    DefaultPaymentMethodWhitelist,\\n\\n    // 1: Allow any payment method.\\n    AllowAnyPaymentMethod,\\n\\n    // 2: Use a custom payment method whitelist.\\n    CustomPaymentMethodWhitelist,\\n\\n    // 3: Single payment method with floor and ceiling limits.\\n    PricingConstraints,\\n\\n    // 4: Pauses trading for the collection.\\n    Paused\\n}\\n\\n/**\\n * @dev This struct is used internally for the deployment of the Payment Processor contract and \\n * @dev module deployments to define the default payment method whitelist.\\n */\\nstruct DefaultPaymentMethods {\\n    address defaultPaymentMethod1;\\n    address defaultPaymentMethod2;\\n    address defaultPaymentMethod3;\\n    address defaultPaymentMethod4;\\n}\\n\\n/**\\n * @dev This struct is used internally for the deployment of the Payment Processor contract to define the\\n * @dev module addresses to be used for the contract.\\n */\\nstruct PaymentProcessorModules {\\n    address modulePaymentSettings;\\n    address moduleOnChainCancellation;\\n    address moduleTrades;\\n    address moduleTradesAdvanced;\\n}\\n\\n/**\\n * @dev This struct defines the payment settings parameters for a collection.\\n *\\n * @dev **paymentSettings**: The general rule definition for payment methods allowed.\\n * @dev **paymentMethodWhitelistId**: The list id to be used when paymentSettings is set to CustomPaymentMethodWhitelist.\\n * @dev **constraintedPricingPaymentMethod**: The payment method to be used when paymentSettings is set to PricingConstraints.\\n * @dev **royaltyBackfillNumerator**: The royalty fee to apply to the collection when ERC2981 is not supported.\\n * @dev **royaltyBountyNumerator**: The percentage of royalties the creator will grant to a marketplace for order fulfillment.\\n * @dev **isRoyaltyBountyExclusive**: If true, royalty bounties will only be paid if the order marketplace is the set exclusive marketplace.\\n * @dev **blockTradesFromUntrustedChannels**: If true, trades that originate from untrusted channels will not be executed.\\n * @dev **blockBannedAccounts**: If true, banned accounts can be neither maker or taker for trades on a per-collection basis.\\n */\\nstruct CollectionPaymentSettings {\\n    PaymentSettings paymentSettings;\\n    uint32 paymentMethodWhitelistId;\\n    address constrainedPricingPaymentMethod;\\n    uint16 royaltyBackfillNumerator;\\n    uint16 royaltyBountyNumerator;\\n    bool isRoyaltyBountyExclusive;\\n    bool blockTradesFromUntrustedChannels;\\n    bool blockBannedAccounts;\\n}\\n\\n/**\\n * @dev The `v`, `r`, and `s` components of an ECDSA signature.  For more information\\n *      [refer to this article](https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7).\\n */\\nstruct SignatureECDSA {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\n/**\\n * @dev This struct defines order execution parameters.\\n * \\n * @dev **protocol**: The order protocol to apply to the order.\\n * @dev **maker**: The user that created and signed the order to be executed by a taker.\\n * @dev **beneficiary**: The account that will receive the tokens.\\n * @dev **marketplace**: The fee receiver of the marketplace that the order was created on.\\n * @dev **fallbackRoyaltyRecipient**: The address that will receive royalties if ERC2981 \\n * @dev is not supported by the collection and the creator has not defined backfilled royalties with Payment Processor.\\n * @dev **paymentMethod**: The payment method for the order.\\n * @dev **tokenAddress**: The address of the token collection the order is for.\\n * @dev **tokenId**: The token id that the order is for.\\n * @dev **amount**: The quantity of token the order is for.\\n * @dev **itemPrice**: The price for the order in base units for the payment method.\\n * @dev **nonce**: The maker's nonce for the order.\\n * @dev **expiration**: The time, in seconds since the Unix epoch, that the order will expire.\\n * @dev **marketplaceFeeNumerator**: The percentage fee that will be sent to the marketplace.\\n * @dev **maxRoyaltyFeeNumerator**: The maximum royalty the maker is willing to accept. This will be used\\n * @dev as the royalty amount when ERC2981 is not supported by the collection.\\n * @dev **requestedFillAmount**: The amount of tokens for an ERC1155 partial fill order that the taker wants to fill.\\n * @dev **minimumFillAmount**: The minimum amount of tokens for an ERC1155 partial fill order that the taker will accept.\\n */\\nstruct Order {\\n    OrderProtocols protocol;\\n    address maker;\\n    address beneficiary;\\n    address marketplace;\\n    address fallbackRoyaltyRecipient;\\n    address paymentMethod;\\n    address tokenAddress;\\n    uint256 tokenId;\\n    uint248 amount;\\n    uint256 itemPrice;\\n    uint256 nonce;\\n    uint256 expiration;\\n    uint256 marketplaceFeeNumerator;\\n    uint256 maxRoyaltyFeeNumerator;\\n    uint248 requestedFillAmount;\\n    uint248 minimumFillAmount;\\n}\\n\\n/**\\n * @dev This struct defines the cosignature for verifying an order that is a cosigned order.\\n *\\n * @dev **signer**: The address that signed the cosigned order. This must match the cosigner that is part of the order signature.\\n * @dev **taker**: The address of the order taker.\\n * @dev **expiration**: The time, in seconds since the Unix epoch, that the cosignature will expire.\\n * @dev The `v`, `r`, and `s` components of an ECDSA signature.  For more information\\n *      [refer to this article](https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7).\\n */\\nstruct Cosignature {\\n    address signer;\\n    address taker;\\n    uint256 expiration;\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\n/**\\n * @dev This struct defines an additional fee on top of an order, paid by taker.\\n *\\n * @dev **recipient**: The recipient of the additional fee.\\n * @dev **amount**: The amount of the additional fee, in base units of the payment token.\\n */\\nstruct FeeOnTop {\\n    address recipient;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev This struct defines the root hash and proof data for accepting an offer that is for a subset\\n * @dev of items in a collection. The root hash must match the root hash specified as part of the \\n * @dev maker's order signature.\\n * \\n * @dev **rootHash**: The merkletree root hash for the items that may be used to fulfill the offer order.\\n * @dev **proof**: The merkle proofs for the item being supplied to fulfill the offer order.\\n */\\nstruct TokenSetProof {\\n    bytes32 rootHash;\\n    bytes32[] proof;\\n}\\n\\n/**\\n * @dev Current state of a partially fillable order.\\n */\\nenum PartiallyFillableOrderState { \\n    // 0: Order is open and may continue to be filled.\\n    Open, \\n\\n    // 1: Order has been completely filled.\\n    Filled, \\n\\n    // 2: Order has been cancelled.\\n    Cancelled\\n}\\n\\n/**\\n * @dev This struct defines the current status of a partially fillable order.\\n * \\n * @dev **state**: The current state of the order as defined by the PartiallyFillableOrderState enum.\\n * @dev **remainingFillableQuantity**: The remaining quantity that may be filled for the order.\\n */\\nstruct PartiallyFillableOrderStatus {\\n    PartiallyFillableOrderState state;\\n    uint248 remainingFillableQuantity;\\n}\\n\\n/**\\n * @dev This struct defines the royalty backfill and bounty information. Its data for an\\n * @dev order execution is constructed internally based on the collection settings and\\n * @dev order execution details.\\n * \\n * @dev **backfillNumerator**: The percentage of the order amount to pay as royalties\\n * @dev for a collection that does not support ERC2981.\\n * @dev **backfillReceiver**: The recipient of backfill royalties.\\n * @dev **bountyNumerator**: The percentage of royalties to share with the marketplace for order fulfillment.\\n * @dev **exclusiveMarketplace**: If non-zero, the address of the exclusive marketplace for royalty bounties.\\n */\\nstruct RoyaltyBackfillAndBounty {\\n    uint16 backfillNumerator;\\n    address backfillReceiver;\\n    uint16 bountyNumerator;\\n    address exclusiveMarketplace;\\n}\\n\\n/**\\n * @dev This struct defines order information that is common to all items in a sweep order.\\n * \\n * @dev **protocol**: The order protocol to apply to the order.\\n * @dev **tokenAddress**: The address of the token collection the order is for.\\n * @dev **paymentMethod**: The payment method for the order.\\n * @dev **beneficiary**: The account that will receive the tokens.\\n */\\nstruct SweepOrder {\\n    OrderProtocols protocol;\\n    address tokenAddress;\\n    address paymentMethod;\\n    address beneficiary;\\n}\\n\\n/**\\n * @dev This struct defines order information that is unique to each item of a sweep order.\\n * @dev Combined with the SweepOrder header information to make an Order to execute.\\n * \\n * @dev **maker**: The user that created and signed the order to be executed by a taker.\\n * @dev **marketplace**: The marketplace that the order was created on.\\n * @dev **fallbackRoyaltyRecipient**: The address that will receive royalties if ERC2981 \\n * @dev is not supported by the collection and the creator has not defined royalties with Payment Processor.\\n * @dev **tokenId**: The token id that the order is for.\\n * @dev **amount**: The quantity of token the order is for.\\n * @dev **itemPrice**: The price for the order in base units for the payment method.\\n * @dev **nonce**: The maker's nonce for the order.\\n * @dev **expiration**: The time, in seconds since the Unix epoch, that the order will expire.\\n * @dev **marketplaceFeeNumerator**: The percentage fee that will be sent to the marketplace.\\n * @dev **maxRoyaltyFeeNumerator**: The maximum royalty the maker is willing to accept. This will be used\\n * @dev as the royalty amount when ERC2981 is not supported by the collection.\\n */\\nstruct SweepItem {\\n    address maker;\\n    address marketplace;\\n    address fallbackRoyaltyRecipient;\\n    uint256 tokenId;\\n    uint248 amount;\\n    uint256 itemPrice;\\n    uint256 nonce;\\n    uint256 expiration;\\n    uint256 marketplaceFeeNumerator;\\n    uint256 maxRoyaltyFeeNumerator;\\n}\\n\\n/**\\n * @dev This struct is used to define pricing constraints for a collection or individual token.\\n *\\n * @dev **isSet**: When true, this indicates that pricing constraints are set for the collection or token.\\n * @dev **floorPrice**: The minimum price for a token or collection.  This is only enforced when \\n * @dev `enforcePricingConstraints` is `true`.\\n * @dev **ceilingPrice**: The maximum price for a token or collection.  This is only enforced when\\n * @dev `enforcePricingConstraints` is `true`.\\n */\\nstruct PricingBounds {\\n    bool isSet;\\n    uint120 floorPrice;\\n    uint120 ceilingPrice;\\n}\\n\\n/**\\n * @dev This struct defines the parameters for a bulk offer acceptance transaction.\\n * \\n * \\n * @dev **isCollectionLevelOfferArray**: An array of flags to indicate if an offer is for any token in the collection.\\n * @dev **saleDetailsArray**: An array of order execution details.\\n * @dev **buyerSignaturesArray**: An array of maker signatures authorizing the order executions.\\n * @dev **tokenSetProofsArray**: An array of root hashes and merkle proofs for offers that are a subset of tokens in a collection.\\n * @dev **cosignaturesArray**: An array of additional cosignatures for cosigned orders, as applicable.\\n * @dev **feesOnTopArray**: An array of additional fees to add on top of the orders, paid by taker.\\n */\\nstruct BulkAcceptOffersParams {\\n    bool[] isCollectionLevelOfferArray;\\n    Order[] saleDetailsArray;\\n    SignatureECDSA[] buyerSignaturesArray;\\n    TokenSetProof[] tokenSetProofsArray;\\n    Cosignature[] cosignaturesArray;\\n    FeeOnTop[] feesOnTopArray;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct SplitProceeds {\\n    address royaltyRecipient;\\n    uint256 royaltyProceeds;\\n    uint256 marketplaceProceeds;\\n    uint256 sellerProceeds;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct PayoutsAccumulator {\\n    address lastSeller;\\n    address lastMarketplace;\\n    address lastRoyaltyRecipient;\\n    uint256 accumulatedSellerProceeds;\\n    uint256 accumulatedMarketplaceProceeds;\\n    uint256 accumulatedRoyaltyProceeds;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct SweepCollectionComputeAndDistributeProceedsParams {\\n    IERC20 paymentCoin;\\n    FulfillOrderFunctionPointers fnPointers;\\n    FeeOnTop feeOnTop;\\n    RoyaltyBackfillAndBounty royaltyBackfillAndBounty;\\n    Order[] saleDetailsBatch;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\n struct FulfillOrderFunctionPointers {\\n    function(address,address,IERC20,uint256,uint256) funcPayout;\\n    function(address,address,address,uint256,uint256) returns (bool) funcDispenseToken;\\n    function(TradeContext memory, Order memory) funcEmitOrderExecutionEvent;\\n }\\n\\n /** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\n struct TradeContext {\\n    bytes32 domainSeparator;\\n    address channel;\\n    address taker;\\n    bool disablePartialFill;\\n }\\n\\n/**\\n * @dev This struct defines contract-level storage to be used across all Payment Processor modules.\\n * @dev Follows the Diamond storage pattern.\\n */\\nstruct PaymentProcessorStorage {\\n    /// @dev Tracks the most recently created payment method whitelist id\\n    uint32 lastPaymentMethodWhitelistId;\\n\\n    /**\\n     * @notice User-specific master nonce that allows buyers and sellers to efficiently cancel all listings or offers\\n     *         they made previously. The master nonce for a user only changes when they explicitly request to revoke all\\n     *         existing listings and offers.\\n     *\\n     * @dev    When prompting sellers to sign a listing or offer, marketplaces must query the current master nonce of\\n     *         the user and include it in the listing/offer signature data.\\n     */\\n    mapping(address => uint256) masterNonces;\\n\\n    /**\\n     * @dev The mapping key is the keccak256 hash of marketplace address and user address.\\n     *\\n     * @dev ```keccak256(abi.encodePacked(marketplace, user))```\\n     *\\n     * @dev The mapping value is another nested mapping of \\\"slot\\\" (key) to a bitmap (value) containing boolean flags\\n     *      indicating whether or not a nonce has been used or invalidated.\\n     *\\n     * @dev Marketplaces MUST track their own nonce by user, incrementing it for every signed listing or offer the user\\n     *      creates.  Listings and purchases may be executed out of order, and they may never be executed if orders\\n     *      are not matched prior to expriation.\\n     *\\n     * @dev The slot and the bit offset within the mapped value are computed as:\\n     *\\n     * @dev ```slot = nonce / 256;```\\n     * @dev ```offset = nonce % 256;```\\n     */\\n    mapping(address => mapping(uint256 => uint256)) invalidatedSignatures;\\n    \\n    /// @dev Mapping of token contract addresses to the collection payment settings.\\n    mapping (address => CollectionPaymentSettings) collectionPaymentSettings;\\n\\n    /// @dev Mapping of payment method whitelist id to the owner address for the list.\\n    mapping (uint32 => address) paymentMethodWhitelistOwners;\\n\\n    /// @dev Mapping of payment method whitelist id to a defined list of allowed payment methods.\\n    mapping (uint32 => EnumerableSet.AddressSet) collectionPaymentMethodWhitelists;\\n\\n    /// @dev Mapping of token contract addresses to the collection-level pricing boundaries (floor and ceiling price).\\n    mapping (address => PricingBounds) collectionPricingBounds;\\n\\n    /// @dev Mapping of token contract addresses to the token-level pricing boundaries (floor and ceiling price).\\n    mapping (address => mapping (uint256 => PricingBounds)) tokenPricingBounds;\\n\\n    /// @dev Mapping of token contract addresses to the defined royalty backfill receiver addresses.\\n    mapping (address => address) collectionRoyaltyBackfillReceivers;\\n\\n    /// @dev Mapping of token contract addresses to the defined exclusive bounty receivers.\\n    mapping (address => address) collectionExclusiveBountyReceivers;\\n\\n    /// @dev Mapping of maker addresses to a mapping of order digests to the status of the partially fillable order for that digest.\\n    mapping (address => mapping(bytes32 => PartiallyFillableOrderStatus)) partiallyFillableOrderStatuses;\\n\\n    /// @dev Mapping of token contract addresses to the defined list of trusted channels for the token contract.\\n    mapping (address => EnumerableSet.AddressSet) collectionTrustedChannels;\\n\\n    /// @dev Mapping of token contract addresses to the defined list of banned accounts for the token contract.\\n    mapping (address => EnumerableSet.AddressSet) collectionBannedAccounts;\\n\\n    /// @dev A mapping of all co-signers that have self-destructed and can never be used as cosigners again.\\n    mapping (address => bool) destroyedCosigners;\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../ShortStrings.sol\\\";\\nimport \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * _Available since v3.4._\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {EIP-5267}.\\n     *\\n     * _Available since v4.9._\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _name.toStringWithFallback(_nameFallback),\\n            _version.toStringWithFallback(_versionFallback),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(_FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"@limitbreak/trusted-forwarder/=lib/TrustedForwarder/src/\",\r\n      \"TrustedForwarder/=lib/TrustedForwarder/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 30000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"configurationContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__InvalidConstructorArguments\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"AcceptOfferERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"AcceptOfferERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BannedAccountAddedForCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BannedAccountRemovedForCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"BuyListingERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"BuyListingERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"whitelistName\",\"type\":\"string\"}],\"name\":\"CreatedPaymentMethodWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cosigner\",\"type\":\"address\"}],\"name\":\"DestroyedCosigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"MasterNonceInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasCancellation\",\"type\":\"bool\"}],\"name\":\"NonceInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderDigest\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasCancellation\",\"type\":\"bool\"}],\"name\":\"OrderDigestInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentMethod\",\"type\":\"address\"}],\"name\":\"PaymentMethodAddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentMethod\",\"type\":\"address\"}],\"name\":\"PaymentMethodRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ReassignedPaymentMethodWhitelistOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"TrustedChannelAddedForCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"TrustedChannelRemovedForCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatedCollectionLevelPricingBoundaries\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum PaymentSettings\",\"name\":\"paymentSettings\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"constrainedPricingPaymentMethod\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"royaltyBackfillNumerator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyBackfillReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"royaltyBountyNumerator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exclusiveBountyReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"blockTradesFromUntrustedChannels\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"blockBannedAccounts\",\"type\":\"bool\"}],\"name\":\"UpdatedCollectionPaymentSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatedTokenLevelPricingBoundaries\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"acceptOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addBannedAccountForCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addTrustedChannelForCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bulkAcceptOffers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bulkBuyListings\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"buyListing\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"collectionBountySettings\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"royaltyBountyNumerator\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"exclusiveBountyReceiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"collectionPaymentSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"enum PaymentSettings\",\"name\":\"paymentSettings\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"constrainedPricingPaymentMethod\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBackfillNumerator\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBountyNumerator\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isRoyaltyBountyExclusive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"blockTradesFromUntrustedChannels\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"blockBannedAccounts\",\"type\":\"bool\"}],\"internalType\":\"struct CollectionPaymentSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"collectionRoyaltyBackfillSettings\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"royaltyBackfillNumerator\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"royaltyBackfillReceiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createPaymentMethodWhitelist\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"destroyCosigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getBannedAccounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCeilingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultPaymentMethods\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFloorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTrustedChannels\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"}],\"name\":\"getWhitelistedPaymentMethods\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentMethod\",\"type\":\"address\"}],\"name\":\"isDefaultPaymentMethod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isNonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"paymentMethod\",\"type\":\"address\"}],\"name\":\"isPaymentMethodWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPaymentMethodWhitelistId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"masterNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentMethodWhitelistId\",\"type\":\"uint32\"}],\"name\":\"paymentMethodWhitelistOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"reassignOwnershipOfPaymentMethodWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderDigest\",\"type\":\"bytes32\"}],\"name\":\"remainingFillableQuantity\",\"outputs\":[{\"components\":[{\"internalType\":\"enum PartiallyFillableOrderState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint248\",\"name\":\"remainingFillableQuantity\",\"type\":\"uint248\"}],\"internalType\":\"struct PartiallyFillableOrderStatus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"removeBannedAccountForCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"removeTrustedChannelForCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"renounceOwnershipOfPaymentMethodWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeMasterNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"revokeOrderDigest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"revokeSingleNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setCollectionPaymentSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setCollectionPricingBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setTokenPricingBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sweepCollection\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unwhitelistPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"whitelistPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PaymentProcessor", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "30000", "ConstructorArguments": "0000000000000000000000009a1d00bc981da5cea8300a999c0d15e2f7f03008", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x9a1d00fcc838601680c731640a070e56fa605c81", "SwarmSource": ""}