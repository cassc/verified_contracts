{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Interface for Chainlink Aggregator V3\\ninterface AggregatorV3Interface {\\n    /// @notice Returns the number of decimals used by the price feed\\n    /// @return The number of decimals\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns a description of the price feed\\n    /// @return The description of the price feed\\n    function description() external view returns (string memory);\\n\\n    /// @notice Returns the version number of the price feed\\n    /// @return The version number\\n    function version() external view returns (uint256);\\n\\n    /// @notice Returns the latest answer from the price feed\\n    /// @return The latest answer\\n    function latestAnswer() external view returns (int256);\\n\\n    /// @notice Returns the data for the latest round of the price feed\\n    /// @return roundId The ID of the latest round\\n    /// @return answer The latest answer\\n    /// @return startedAt The timestamp when the latest round started\\n    /// @return updatedAt The timestamp when the latest round was last updated\\n    /// @return answeredInRound The ID of the round when the latest answer was computed\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/// @notice Interface for the ERC20 token contract\\ninterface IERC20 is IERC20Upgradeable {\\n    /// @notice Returns the number of decimals used by the token\\n    /// @return The number of decimals\\n    function decimals() external view returns (uint8);\\n\\n    /// dev Returns the name of the Wrapped Ether token.\\n    /// return A string representing the token name.\\n    function name() external view returns (string memory);\\n\\n    /// dev Returns the symbol of the Wrapped Ether token.\\n    /// return A string representing the token symbol.\\n    function symbol() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/IQuoter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(\\n        bytes memory path,\\n        uint256 amountIn\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(\\n        bytes memory path,\\n        uint256 amountOut\\n    ) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/IUniswapRouterV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Interface for the Uniswap V3 Router contract\\ninterface IUniswapRouterV3 {\\n    /// @notice Parameters for single-token exact input swaps\\n    struct ExactInputSingleParams {\\n        address tokenIn; // The address of the input token\\n        address tokenOut; // The address of the output token\\n        uint24 fee; // The fee level of the pool\\n        address recipient; // The address to receive the output tokens\\n        uint256 amountIn; // The exact amount of input tokens to swap\\n        uint256 amountOutMinimum; // The minimum acceptable amount of output tokens to receive\\n        uint160 sqrtPriceLimitX96; // The square root of the price limit in the Uniswap pool\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    /// @notice Parameters for multi-hop exact input swaps\\n    struct ExactInputParams {\\n        bytes path; // The path of tokens to swap\\n        address recipient; // The address to receive the output tokens\\n        uint256 amountIn; // The exact amount of input tokens to swap\\n        uint256 amountOutMinimum; // The minimum acceptable amount of output tokens to receive\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(\\n        ExactInputParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn; // The address of the input token\\n        address tokenOut; // The address of the output token\\n        uint24 fee; // The fee level of the pool\\n        address recipient; // The address to receive the input tokens\\n        uint256 amountOut; // The exact amount of output tokens to receive\\n        uint256 amountInMaximum; // The maximum acceptable amount of input tokens to swap\\n        uint160 sqrtPriceLimitX96; // The square root of the price limit in the Uniswap pool\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path; // The path of tokens to swap (reversed)\\n        address recipient; // The address to receive the input tokens\\n        uint256 amountOut; // The exact amount of output tokens to receive\\n        uint256 amountInMaximum; // The maximum acceptable amount of input tokens to swap\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/common/IUniswapRouterV3WithDeadline.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @notice Interface for the Uniswap V3 Router contract with deadline support\\ninterface IUniswapRouterV3WithDeadline {\\n    /// @notice Parameters for single-token exact input swaps\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn; // The address of the input token\\n        address tokenOut; // The address of the output token\\n        uint24 fee; // The fee level of the pool\\n        address recipient; // The address to receive the output tokens\\n        uint256 deadline; // The deadline for the swap\\n        uint256 amountIn; // The exact amount of input tokens to swap\\n        uint256 amountOutMinimum; // The minimum acceptable amount of output tokens to receive\\n        uint160 sqrtPriceLimitX96; // The square root of the price limit in the Uniswap pool\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path; // The path of tokens to swap\\n        address recipient; // The address to receive the output tokens\\n        uint256 deadline; // The deadline for the swap\\n        uint256 amountIn; // The exact amount of input tokens to swap\\n        uint256 amountOutMinimum; // The minimum acceptable amount of output tokens to receive\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(\\n        ExactInputParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn; // The address of the input token\\n        address tokenOut; // The address of the output token\\n        uint24 fee; // The fee level of the pool\\n        address recipient; // The address to receive the input tokens\\n        uint256 deadline; // The deadline for the swap\\n        uint256 amountOut; // The exact amount of output tokens to receive\\n        uint256 amountInMaximum; // The maximum acceptable amount of input tokens to swap\\n        uint160 sqrtPriceLimitX96; // The square root of the price limit in the Uniswap pool\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path; // The path of tokens to swap (reversed)\\n        address recipient; // The address to receive the input tokens\\n        uint256 deadline; // The deadline for the swap\\n        uint256 amountOut; // The exact amount of output tokens to receive\\n        uint256 amountInMaximum; // The maximum acceptable amount of input tokens to swap\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/convex/IConvex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Interface for the Convex Booster contract\\ninterface IConvexBoosterL1 {\\n    /// @notice Deposits funds into the booster\\n    /// @param pid The pool ID\\n    /// @param amount The amount to deposit\\n    /// @param stake Flag indicating whether to stake the deposited funds\\n    /// @return True if the deposit was successful\\n    function deposit(uint256 pid, uint256 amount, bool stake) external returns (bool);\\n\\n    /// @notice Returns the address of the CVX token\\n    function minter() external view returns (address);\\n\\n    /// @notice Earmarks rewards for the specified pool\\n    /// @param _pid The pool ID\\n    function earmarkRewards(uint256 _pid) external;\\n\\n    /// @notice Retrieves information about a pool\\n    /// @param pid The pool ID\\n    /// @return lptoken The LP token address\\n    /// @return token The token address\\n    /// @return gauge The gauge address\\n    /// @return crvRewards The CRV rewards address\\n    /// @return stash The stash address\\n    /// @return shutdown Flag indicating if the pool is shutdown\\n    function poolInfo(\\n        uint256 pid\\n    )\\n        external\\n        view\\n        returns (\\n            address lptoken,\\n            address token,\\n            address gauge,\\n            address crvRewards,\\n            address stash,\\n            bool shutdown\\n        );\\n}\\n\\n/// @notice Interface for the Convex Booster L2 contract\\ninterface IConvexBoosterL2 {\\n    /// @notice Deposits funds into the L2 booster\\n    /// @param _pid The pool ID\\n    /// @param _amount The amount to deposit\\n    /// @return True if the deposit was successful\\n    function deposit(uint256 _pid, uint256 _amount) external returns (bool);\\n\\n    /// @notice Deposits all available funds into the L2 booster\\n    /// @param _pid The pool ID\\n    /// @return True if the deposit was successful\\n    function depositAll(uint256 _pid) external returns (bool);\\n\\n    /// @notice Retrieves information about a pool\\n    /// @param pid The pool ID\\n    /// @return lptoken The LP token address\\n    /// @return gauge The gauge address\\n    /// @return rewards The rewards address\\n    /// @return shutdown Flag indicating if the pool is shutdown\\n    /// @return factory The curve factory address used to create the pool\\n    function poolInfo(\\n        uint256 pid\\n    )\\n        external\\n        view\\n        returns (\\n            address lptoken, //the curve lp token\\n            address gauge, //the curve gauge\\n            address rewards, //the main reward/staking contract\\n            bool shutdown, //is this pool shutdown?\\n            address factory //a reference to the curve factory used to create this pool (needed for minting crv)\\n        );\\n}\\n\\ninterface IConvexRewardPoolL1 {\\n    /// @notice Retrieves the balance of the specified account\\n    /// @param account The account address\\n    /// @return The account balance\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the claimable rewards for the specified account\\n    /// @param _account The account address\\n    /// @return the amount representing the claimable rewards\\n    function earned(address _account) external view returns (uint256);\\n\\n    /// @dev Calculates the reward in CVX based on the reward of CRV\\n    /// @dev Used for mock purposes only\\n    /// @param _crvAmount The amount of CRV amount.\\n    /// @return returns the amount of cvx rewards to get\\n    function getCVXAmount(uint256 _crvAmount) external view returns (uint256);\\n\\n    /// @notice Retrieves the period finish timestamp\\n    /// @return The period finish timestamp\\n    function periodFinish() external view returns (uint256);\\n\\n    /// @notice Claims the available rewards for the caller\\n    function getReward() external;\\n\\n    /// @notice Gets the address of the reward token\\n    function rewardToken() external view returns (address);\\n\\n    /// @notice Withdraws and unwraps the specified amount of tokens\\n    /// @param _amount The amount to withdraw and unwrap\\n    /// @param claim Flag indicating whether to claim rewards\\n    function withdrawAndUnwrap(uint256 _amount, bool claim) external;\\n\\n    /// @notice Withdraws all funds and unwraps the tokens\\n    /// @param claim Flag indicating whether to claim rewards\\n    function withdrawAllAndUnwrap(bool claim) external;\\n}\\n\\n/// @notice Interface for the Convex Reward Pool L2 contract\\ninterface IConvexRewardPoolL2 {\\n    /// @notice Struct containing information about an earned reward\\n    struct EarnedData {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Retrieves the balance of the specified account\\n    /// @param account The account address\\n    /// @return The account balance\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the claimable rewards for the specified account\\n    /// @param _account The account address\\n    /// @return claimable An array of EarnedData representing the claimable rewards\\n    function earned(address _account) external returns (EarnedData[] memory claimable);\\n\\n    /// @notice Retrieves the period finish timestamp\\n    /// @return The period finish timestamp\\n    function periodFinish() external view returns (uint256);\\n\\n    /// @notice Claims the available rewards for the specified account\\n    /// @param _account The account address\\n    function getReward(address _account) external;\\n\\n    /// @notice Withdraws the specified amount of tokens\\n    /// @param _amount The amount to withdraw\\n    /// @param _claim Flag indicating whether to claim rewards\\n    function withdraw(uint256 _amount, bool _claim) external;\\n\\n    /// @notice Withdraws all funds\\n    /// @param claim Flag indicating whether to claim rewards\\n    function withdrawAll(bool claim) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/ICurveSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Interface for the CurveSwap contract\\ninterface ICurveSwap {\\n    /// @notice Retrieves the fee applied by the CurveSwap contract\\n    /// @return The fee amount\\n    function fee() external view returns (uint256);\\n\\n    /// @notice Retrieves the balance of a token at a specific index within the CurveSwap contract\\n    /// @param index The index of the token\\n    /// @return The balance of the token\\n    function balances(uint256 index) external view returns (uint256);\\n\\n    /// @notice Retrieves the total supply of LP (Liquidity Provider) tokens in the CurveSwap contract\\n    /// @return The total supply of LP tokens\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Retrieves the admin fee applied by the CurveSwap contract\\n    /// @return The admin fee amount\\n    function admin_fee() external view returns (uint256);\\n\\n    /// @notice Calculates the amount of LP tokens to mint or burn for a given token input or output amounts\\n    /// @param amounts The token input or output amounts\\n    /// @param is_deposit Boolean indicating if it's a deposit or withdrawal operation\\n    /// @return The calculated amount of LP tokens\\n    function calc_token_amount(\\n        uint256[2] memory amounts,\\n        bool is_deposit\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculates the amount of LP tokens to mint or burn for a given token input or output amounts\\n    /// @param amounts The token input or output amounts\\n    /// @param is_deposit Boolean indicating if it's a deposit or withdrawal operation\\n    /// @return The calculated amount of LP tokens\\n    function calc_token_amount(\\n        uint256[3] memory amounts,\\n        bool is_deposit\\n    ) external view returns (uint256);\\n\\n    /// @notice Removes liquidity from the CurveSwap contract\\n    /// @param _burn_amount The amount of LP tokens to burn\\n    /// @param _min_amounts The minimum acceptable token amounts to receive\\n    /// @return The actual amounts received after removing liquidity\\n    function remove_liquidity(\\n        uint256 _burn_amount,\\n        uint256[2] memory _min_amounts\\n    ) external returns (uint256[2] memory);\\n\\n    /// @notice Removes liquidity from the CurveSwap contract for a single token\\n    /// @param token_amount The amount of the token to remove\\n    /// @param i The index of the token in the pool\\n    /// @param min_amount The minimum acceptable token amount to receive\\n    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;\\n\\n    /// @notice Removes liquidity from the CurveSwap contract for a single token\\n    /// @param token_amount The amount of the token to remove\\n    /// @param i The index of the token in the pool\\n    /// @param min_amount The minimum acceptable token amount to receive\\n    function remove_liquidity_one_coin(\\n        uint256 token_amount,\\n        uint256 i,\\n        uint256 min_amount\\n    ) external;\\n\\n    /// @notice Calculates the amount of tokens to receive when withdrawing a single token from the CurveSwap contract\\n    /// @param tokenAmount The LP amount to withdraw\\n    /// @param i The index of the token in the pool\\n    /// @return The calculated amount of tokens to receive\\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\\n\\n    /// @notice Calculates the amount of tokens to receive when withdrawing a single token from the CurveSwap contract\\n    /// @param tokenAmount The LP amount to withdraw\\n    /// @param i The index of the token in the pool\\n    /// @return The calculated amount of tokens to receive\\n    function calc_withdraw_one_coin(uint256 tokenAmount, uint256 i) external view returns (uint256);\\n\\n    /// @notice Retrieves the address of a token in the CurveSwap pool by its index\\n    /// @param arg0 The index of the token in the pool\\n    /// @return The address of the token\\n    function coins(uint256 arg0) external view returns (address);\\n\\n    /// @notice Retrieves the virtual price of the CurveSwap pool\\n    /// @return The virtual price\\n    function get_virtual_price() external view returns (uint256);\\n\\n    /// @notice Adds liquidity to the CurveSwap contract\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract with an option to use underlying tokens\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    /// @param _use_underlying Boolean indicating whether to use underlying tokens\\n    function add_liquidity(\\n        uint256[2] memory amounts,\\n        uint256 min_mint_amount,\\n        bool _use_underlying\\n    ) external;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract for a specific pool\\n    /// @param _pool The address of the pool to add liquidity to\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(\\n        address _pool,\\n        uint256[2] memory amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract with an option to use underlying tokens\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    /// @param _use_underlying Boolean indicating whether to use underlying tokens\\n    function add_liquidity(\\n        uint256[3] memory amounts,\\n        uint256 min_mint_amount,\\n        bool _use_underlying\\n    ) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract for a specific pool\\n    /// @param _pool The address of the pool to add liquidity to\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(\\n        address _pool,\\n        uint256[3] memory amounts,\\n        uint256 min_mint_amount\\n    ) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract for a specific pool\\n    /// @param _pool The address of the pool to add liquidity to\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(\\n        address _pool,\\n        uint256[4] memory amounts,\\n        uint256 min_mint_amount\\n    ) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(uint256[5] memory amounts, uint256 min_mint_amount) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract for a specific pool\\n    /// @param _pool The address of the pool to add liquidity to\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(\\n        address _pool,\\n        uint256[5] memory amounts,\\n        uint256 min_mint_amount\\n    ) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(uint256[6] memory amounts, uint256 min_mint_amount) external payable;\\n\\n    /// @notice Adds liquidity to the CurveSwap contract for a specific pool\\n    /// @param _pool The address of the pool to add liquidity to\\n    /// @param amounts The amounts of tokens to add as liquidity\\n    /// @param min_mint_amount The minimum acceptable amount of LP tokens to mint\\n    function add_liquidity(\\n        address _pool,\\n        uint256[6] memory amounts,\\n        uint256 min_mint_amount\\n    ) external payable;\\n\\n    /// @notice Exchanges tokens on the CurveSwap contract\\n    /// @param i The index of the input token in the pool\\n    /// @param j The index of the output token in the pool\\n    /// @param dx The amount of the input token to exchange\\n    /// @param min_dy The minimum acceptable amount of the output token to receive\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/ICVX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { IERC20 } from \\\"../common/IERC20.sol\\\";\\n\\n/// @notice Interface for the Convex Booster contract\\ninterface ICVXL1 is IERC20 {\\n    function maxSupply() external view returns (uint256);\\n\\n    function operator() external view returns (address);\\n\\n    function reductionPerCliff() external view returns (uint256);\\n\\n    function totalCliffs() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/IGaugeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Interface for the Gauge Factory\\ninterface IGaugeFactory {\\n    /// @notice Mints a gauge token\\n    /// @param _gauge The address of the gauge to be minted\\n    function mint(address _gauge) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dollet/IAdminStructure.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @dev Interface for managing the super admin role.\\ninterface ISuperAdmin {\\n    /// @notice Returns the address of the super admin.\\n    /// @return The address of the super admin.\\n    function superAdmin() external view returns (address);\\n\\n    /// @notice Returns the address of the potential super admin.\\n    /// @return The address of the potential super admin.\\n    function potentialSuperAdmin() external view returns (address);\\n\\n    /// @notice Transfers the super admin role to a potential super admin address using pull-over-push pattern.\\n    /// @param _potentialSuperAdmin An address of a potential super admin.\\n    function transferSuperAdmin(address _potentialSuperAdmin) external;\\n\\n    /// @notice Accepts the super admin role by a potential super admin.\\n    function acceptSuperAdmin() external;\\n\\n    /// @notice Checks if the caller is a valid super admin.\\n    /// @param caller The address to check.\\n    function isValidSuperAdmin(address caller) external view;\\n}\\n\\n/// @dev Interface for managing admin roles.\\ninterface IAdminStructure is ISuperAdmin {\\n    /// @dev Emitted when an admin is added.\\n    /// @param admin The address of the added admin.\\n    event AddedAdmin(address admin);\\n\\n    /// @dev Emitted when an admin is removed.\\n    /// @param admin The address of the removed admin.\\n    event RemovedAdmin(address admin);\\n\\n    /// @notice Checks if the caller is a valid admin.\\n    /// @param caller The address to check.\\n    function isValidAdmin(address caller) external view;\\n\\n    /// @notice Checks if an account is an admin.\\n    /// @param account The address to check.\\n    /// @return A boolean indicating if the account is an admin.\\n    function isAdmin(address account) external view returns (bool);\\n\\n    /// @notice Adds multiple addresses as admins.\\n    /// @param _admins The addresses to add as admins.\\n    function addAdmins(address[] calldata _admins) external;\\n\\n    /// @notice Removes multiple addresses from admins.\\n    /// @param _admins The addresses to remove from admins.\\n    function removeAdmins(address[] calldata _admins) external;\\n\\n    /// @notice Returns all the admin addresses.\\n    /// @return An array of admin addresses.\\n    function getAllAdmins() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dollet/IStrategyCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Interface for the Strategy Calculations contract\\n/// @dev This interface provides functions for performing various calculations related to the strategy.\\ninterface IStrategyCalculations {\\n    /// @return The address of the Admin Structure contract\\n    function adminStructure() external view returns (address);\\n\\n    /// @return The address of the Strategy contract\\n    function strategy() external view returns (address);\\n\\n    /// @return The address of the Quoter contract\\n    function quoter() external view returns (address);\\n\\n    /// @dev Constant for representing 100 (100%)\\n    /// @return The value of 100\\n    function ONE_HUNDRED() external pure returns (uint256);\\n\\n    /// @notice Calculates the minimum amount of tokens to receive from Curve for a specific token and maximum amount\\n    /// @param _token The address of the token to withdraw\\n    /// @param _maxAmount The maximum amount of tokens to withdraw\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The minimum amount of tokens to receive from Curve\\n    function calculateCurveMinWithdrawal(\\n        address _token,\\n        uint256 _maxAmount,\\n        uint256 _slippage\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculates the amount of LP tokens to get on curve deposit\\n    /// @param _token The token to estimate the deposit\\n    /// @param _amount The amount of tokens to deposit\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The amount of LP tokens to get\\n    function calculateCurveDeposit(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256);\\n\\n    /// @notice Estimates the amount of tokens to swap from one token to another\\n    /// @param _from The address of the token to swap from\\n    /// @param _to The address of the token to swap to\\n    /// @param _amount The amount of tokens to swap\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return estimate The estimated amount of tokens to receive after the swap\\n    function estimateSwap(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external returns (uint256 estimate);\\n\\n    /// @notice Estimates the deposit details for a specific token and amount\\n    /// @param _token The address of the token to deposit\\n    /// @param _amount The amount of tokens to deposit\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return amountWant The minimum amount of tokens to get on the curve deposit\\n    function estimateDeposit(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 amountWant);\\n\\n    /// @notice Estimates the withdrawal details for a specific user, token, maximum amount, and slippage\\n    /// @param _user The address of the user\\n    /// @param _token The address of the token to withdraw\\n    /// @param _maxAmount The maximum amount of tokens to withdraw\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return minCurveOutput The minimum amount of tokens to get from the curve withdrawal\\n    /// @return withdrawable The minimum amount of tokens to get after the withdrawal\\n    function estimateWithdrawal(\\n        address _user,\\n        address _token,\\n        uint256 _maxAmount,\\n        uint256 _slippage\\n    ) external view returns (uint256 minCurveOutput, uint256 withdrawable);\\n\\n    /// @notice Retrieves information about the pending rewards to harvest from the convex pool\\n    /// @return rewardAmounts rewards the amount representing the pending rewards\\n    /// @return rewardTokens addresses of the reward tokens\\n    /// @return enoughRewards list indicating if the reward token is enough to harvest\\n    /// @return atLeastOne indicates if there is at least one reward to harvest\\n    function getPendingToHarvestView()\\n        external\\n        view\\n        returns (\\n            uint256[] memory rewardAmounts,\\n            address[] memory rewardTokens,\\n            bool[] memory enoughRewards,\\n            bool atLeastOne\\n        );\\n\\n    /// @notice Retrieves information about the pending rewards to harvest from the convex pool\\n    /// @return rewardAmounts rewards the amount representing the pending rewards\\n    /// @return rewardTokens addresses of the reward tokens\\n    /// @return enoughRewards list indicating if the reward token is enough to harvest\\n    /// @return atLeastOne indicates if there is at least one reward to harvest\\n    function getPendingToHarvest()\\n        external\\n        returns (\\n            uint256[] memory rewardAmounts,\\n            address[] memory rewardTokens,\\n            bool[] memory enoughRewards,\\n            bool atLeastOne\\n        );\\n\\n    /// @notice Estimates the rewards details for a specific user, token, amount, and slippage\\n    /// @param _user The address of the user\\n    /// @param _token The address of the token to calculate rewards for\\n    /// @param _amount The amount of tokens\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return minCurveOutput The minimum amount of tokens to get from the curve withdrawal\\n    /// @return claimable The minimum amount of tokens to get after the claim of rewards\\n    function estimateRewards(\\n        address _user,\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 minCurveOutput, uint256 claimable);\\n\\n    /// @notice Estimates the total claimable rewards for all users using a specific token and slippage\\n    /// @param _token The address of the token to calculate rewards for\\n    /// @param _amount The amount of tokens\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return claimable The total claimable amount of tokens\\n    function estimateAllUsersRewards(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 claimable);\\n\\n    /// @dev Returns the amount of tokens deposited by a specific user in the indicated token\\n    /// @param _user The address of the user.\\n    /// @param _token The address of the token.\\n    /// @return The amount of tokens deposited by the user.\\n    function userDeposit(address _user, address _token) external view returns (uint256);\\n\\n    /// @dev Returns the total amount of tokens deposited in the strategy in the indicated token\\n    /// @param _token The address of the token.\\n    /// @return The total amount of tokens deposited.\\n    function totalDeposits(address _token) external view returns (uint256);\\n\\n    /// @notice Retrieves the minimum amount of tokens to swap from a specific fromToken to toToken\\n    /// @param _fromToken The address of the token to swap from\\n    /// @param _toToken The address of the token to swap to\\n    /// @return The minimum amount of tokens to swap\\n    function getAutomaticSwapMin(address _fromToken, address _toToken) external returns (uint256);\\n\\n    /// @notice Retrieves the minimum amount of LP tokens to obtained from a curve deposit\\n    /// @param _depositAmount The amount to deposit\\n    /// @return The minimum amount of LP tokens to obtained from the deposit on curve\\n    function getAutomaticCurveMinLp(uint256 _depositAmount) external returns (uint256);\\n\\n    /// @notice Retrieves the balance of a specific token held by the Strategy\\n    /// @param _token The address of the token\\n    /// @return The token balance\\n    function _getTokenBalance(address _token) external view returns (uint256);\\n\\n    /// @notice Retrieves the minimum value between a specific amount and a slippage percentage\\n    /// @param _amount The amount\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The minimum value\\n    function _getMinimum(uint256 _amount, uint256 _slippage) external pure returns (uint256);\\n\\n    /// @notice Estimates the want balance after a harvest\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return Returns the new want amount\\n    function estimateWantAfterHarvest(uint256 _slippage) external returns (uint256);\\n}\\n\\ninterface IStrategyCalculationsTwocrypto is IStrategyCalculations {\\n    /// @notice Formats the array input for curve\\n    /// @param _depositToken The address of the deposit token\\n    /// @param _amount The amount to deposit\\n    /// @return amounts An array of token amounts to use in curve\\n    function getCurveAmounts(\\n        address _depositToken,\\n        uint256 _amount\\n    ) external view returns (uint256[2] memory amounts);\\n}\\n\\ninterface IStrategyCalculationsTricryptoL1 is IStrategyCalculations {\\n    /// @notice Formats the array input for curve\\n    /// @param _depositToken The address of the deposit token\\n    /// @param _amount The amount to deposit\\n    /// @return amounts An array of token amounts to use in curve\\n    function getCurveAmounts(\\n        address _depositToken,\\n        uint256 _amount\\n    ) external view returns (uint256[3] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dollet/IStrategyConvex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\nimport { IStrategyCalculations } from \\\"./IStrategyCalculations.sol\\\";\\n\\n/// @notice Interface for the Convex Strategy contract\\ninterface IStrategyConvex {\\n    /// @dev Struct representing a pool token\\n    struct PoolToken {\\n        bool isAllowed; /// Flag indicating if the token is allowed\\n        uint8 index; /// Index of the token\\n    }\\n\\n    /// @dev Struct representing an oracle\\n    struct Oracle {\\n        address token; /// Token address\\n        address oracle; /// Oracle address\\n    }\\n\\n    /// @dev Struct representing default slippages\\n    struct DefaultSlippages {\\n        uint256 curve; /// Default slippage for Curve swaps\\n        uint256 uniswap; /// Default slippage for Uniswap swaps\\n    }\\n\\n    /// @dev Struct representing reward information\\n    struct RewardInfo {\\n        address[] tokens; /// Array of reward tokens\\n        uint256[] minAmount; /// Array of minimum reward amounts\\n    }\\n\\n    /// @dev Enum representing fee types\\n    enum FeeType {\\n        MANAGEMENT, /// Management fee\\n        PERFORMANCE /// Performance fee\\n    }\\n\\n    /// @dev Event emitted when stucked tokens have been withdrawn\\n    /// @param caller Address of the caller of the transaction\\n    /// @param token Address of the token withdrawn\\n    /// @param amount Withdrawn amount\\n    event WithdrawStuckTokens(address caller, address token, uint256 amount);\\n\\n    /// @dev Event emitted when a harvest is executed\\n    /// @param harvester The address of the harvester\\n    /// @param amount The amount harvested\\n    /// @param wantBal The balance of the want token after the harvest\\n    event Harvested(address indexed harvester, uint256 amount, uint256 wantBal);\\n\\n    /// @dev Event emitted when a deposit is made\\n    /// @param user The address of the user\\n    /// @param token The address of the token deposited\\n    /// @param wantBal The balance of the want token generated with the deposit\\n    event Deposit(address user, address token, uint256 wantBal);\\n\\n    /// @dev Event emitted when a withdrawal is made\\n    /// @param user The address of the user\\n    /// @param token The address of the token being withdrawn\\n    /// @param amount The amount withdrawn\\n    /// @param wantBal The balance of the want token after the withdrawal\\n    event Withdraw(address user, address token, uint256 amount, uint256 wantBal);\\n\\n    /// @dev Event emitted when rewards are claimed\\n    /// @param user The address of the user\\n    /// @param token The address of the reward token\\n    /// @param amount The amount of rewards claimed\\n    /// @param wantBal The balance of the want token after claiming rewards\\n    event ClaimedRewards(address user, address token, uint256 amount, uint256 wantBal);\\n\\n    /// @dev Event emitted when fees are charged\\n    /// @param feeType The type of fee (Management or Performance)\\n    /// @param amount The amount of fees charged\\n    /// @param feeRecipient The address of the fee recipient\\n    event ChargedFees(FeeType indexed feeType, uint256 amount, address feeRecipient);\\n\\n    /// @dev Event emitted when allowed tokens are edited\\n    /// @param token The address of the token\\n    /// @param status The new status (true or false)\\n    event EditedAllowedTokens(address token, bool status);\\n\\n    /// @dev Event emitted when the pause status is changed\\n    /// @param status The new pause status (true or false)\\n    event PauseStatusChanged(bool status);\\n\\n    /// @dev Event emitted when a swap path is set\\n    /// @param from The address of the token to swap from\\n    /// @param to The address of the token to swap to\\n    /// @param path The swap path\\n    event SetPath(address from, address to, bytes path);\\n\\n    /// @dev Event emitted when a swap route is set\\n    /// @param from The address of the token to swap from\\n    /// @param to The address of the token to swap to\\n    /// @param route The swap route\\n    event SetRoute(address from, address to, address[] route);\\n\\n    /// @dev Event emitted when an oracle is set\\n    /// @param token The address of the token\\n    /// @param oracle The address of the oracle\\n    event SetOracle(address token, address oracle);\\n\\n    /// @dev Event emitted when the slippage value is set\\n    /// @param oldValue The old slippage value\\n    /// @param newValue The new slippage value\\n    /// @param kind The kind of slippage (Curve or Uniswap)\\n    event SetSlippage(uint256 oldValue, uint256 newValue, string kind);\\n\\n    /// @dev Event emitted when the minimum amount to harvest is changed\\n    /// @param token The address of the token\\n    /// @param minimum The new minimum amount to harvest\\n    event MinimumToHarvestChanged(address token, uint256 minimum);\\n\\n    /// @dev Event emitted when a reward token is added\\n    /// @param token The address of the reward token\\n    /// @param minimum The minimum amount of the reward token\\n    event AddedRewardToken(address token, uint256 minimum);\\n\\n    /// @dev Event emitted when a panic is executed\\n    event PanicExecuted();\\n}\\n\\n/// @notice Extended interface for the Convex Strategy contract\\ninterface IStrategyConvexExtended is IStrategyConvex {\\n    /// @dev Returns the address of the pool contract\\n    /// @return The address of the pool contract\\n    function pool() external view returns (address);\\n\\n    /// @dev Returns how many tokens the pool accepts\\n    /// @return The number of tokens the pool accepts\\n    function POOL_SIZE() external view returns (uint256);\\n\\n    /// @dev Returns the address of the calculations contract\\n    /// @return The address of the calculations contract\\n    function calculations() external view returns (IStrategyCalculations);\\n\\n    /// @dev Returns the address of the admin structure contract\\n    /// @return The address of the admin structure contract\\n    function adminStructure() external view returns (address);\\n\\n    /// @dev Minimum amount to execute reinvestment in harvest\\n    function minimumToHarvest(address _token) external view returns (uint256);\\n\\n    /// @dev Executes the harvest operation, it is also the function compound, reinvests rewards\\n    function harvest() external;\\n\\n    /// @dev Executes the harvest operation on deposits, it is also the function compound, reinvests rewards\\n    function harvestOnDeposit() external;\\n\\n    /// @dev Handles the case where tokens get stuck in the Strategy. Allows the admin to send the tokens to the\\n    ///      SuperAdmin\\n    /// @param _token The address of the stuck token\\n    function inCaseTokensGetStuck(address _token) external;\\n\\n    /// @dev Executes a panic operation, withdraws all the rewards from convex\\n    function panic() external;\\n\\n    /// @dev Pauses the strategy, pauses deposits\\n    function pause() external;\\n\\n    /// @dev Unpauses the strategy\\n    function unpause() external;\\n\\n    /// @dev Withdraws tokens from the strategy\\n    /// @param _user The address of the user\\n    /// @param _amount The amount of tokens to withdraw\\n    /// @param _token The address of the token to withdraw\\n    /// @param _minCurveOutput The minimum LP output from Curve\\n    /// @param _useEth Indicates whether to withdraw ETH or not\\n    function withdraw(\\n        address _user,\\n        uint256 _amount,\\n        address _token,\\n        uint256 _minCurveOutput,\\n        bool _useEth\\n    ) external;\\n\\n    /// @dev Claims rewards for the user\\n    /// @param _user The address of the user\\n    /// @param _token The address of the reward token\\n    /// @param _amount The amount of rewards to claim\\n    /// @param _minCurveOutput The minimum LP token output from Curve swap\\n    /// @param _useEth Indicates whether to withdraw ETH or not\\n    function claimRewards(\\n        address _user,\\n        address _token,\\n        uint256 _amount,\\n        uint256 _minCurveOutput,\\n        bool _useEth\\n    ) external;\\n\\n    /// @dev Returns the address of the reward pool contract\\n    /// @return The address of the reward pool contract\\n    function rewardPool() external view returns (address);\\n\\n    /// @dev Returns the address of the deposit token\\n    /// @return The address of the deposit token\\n    function depositToken() external view returns (address);\\n\\n    /// @dev Checks if a token is allowed for deposit\\n    /// @param token The address of the token\\n    /// @return isAllowed True if the token is allowed, false otherwise\\n    /// @return index The index of the token\\n    function allowedDepositTokens(address token) external view returns (bool, uint8);\\n\\n    /// @dev Returns the swap path for a token pair\\n    /// @param _from The address of the token to swap from\\n    /// @param _to The address of the token to swap to\\n    /// @return The swap path\\n    function paths(address _from, address _to) external view returns (bytes memory);\\n\\n    /// @dev Returns the want deposit amount of a user in the deposit token\\n    /// @param _user The address of the user\\n    /// @return The deposit amount for the user\\n    function userWantDeposit(address _user) external view returns (uint256);\\n\\n    /// @dev Returns the total want deposits in the strategy\\n    /// @return The total deposits in the strategy\\n    function totalWantDeposits() external view returns (uint256);\\n\\n    /// @dev Returns the oracle address for a token\\n    /// @param _token The address of the token\\n    /// @return The oracle address\\n    function oracle(address _token) external view returns (address);\\n\\n    /// @dev Returns the default slippage for Curve swaps used in harvest\\n    /// @return The default slippage for Curve swaps\\n    function defaultSlippageCurve() external view returns (uint256);\\n\\n    /// @dev Returns the default slippage for Uniswap swaps used in harvest\\n    /// @return The default slippage for Uniswap swaps\\n    function defaultSlippageUniswap() external view returns (uint256);\\n\\n    /// @dev Returns the want token\\n    /// @return The want token\\n    function want() external view returns (IERC20Upgradeable);\\n\\n    /// @dev Returns the balance of the strategy held in the strategy\\n    /// @return The balance of the strategy\\n    function balanceOf() external view returns (uint256);\\n\\n    /// @dev Returns the balance of the want token held in the strategy\\n    /// @return The balance of the want token\\n    function balanceOfWant() external view returns (uint256);\\n\\n    /// @dev Returns the balance of want in the strategy\\n    /// @return The balance of the pool\\n    function balanceOfPool() external view returns (uint256);\\n\\n    /// @dev Returns the pause status of the strategy\\n    /// @return True if the strategy is paused, false otherwise\\n    function paused() external view returns (bool);\\n\\n    /// @dev Returns the address of the weth token\\n    /// @return The address of the weth router\\n    function weth() external view returns (address);\\n\\n    /// @dev Returns the address of the Uniswap router\\n    /// @return The address of the Uniswap router\\n    function unirouter() external view returns (address);\\n\\n    /// @dev Returns the address of the vault contract\\n    /// @return The address of the vault contract\\n    function vault() external view returns (address);\\n\\n    /// @dev Returns the address of Convex booster\\n    /// @return The address of the Convex booster\\n    function booster() external view returns (address);\\n\\n    /// @dev Returns the address of Uniswap V2 router\\n    /// @return The address of Uniswap V2 router\\n    function unirouterV2() external view returns (address);\\n\\n    /// @dev Returns the address of Uniswap V3 router\\n    /// @return The address of Uniswap V3 router\\n    function unirouterV3() external view returns (address);\\n\\n    /// @dev Returns the performance fee\\n    /// @return The performance fee\\n    function performanceFee() external view returns (uint256);\\n\\n    /// @dev Returns the management fee\\n    /// @return The management fee\\n    function managementFee() external view returns (uint256);\\n\\n    /// @dev Returns the performance fee recipient\\n    /// @return The performance fee recipient\\n    function performanceFeeRecipient() external view returns (address);\\n\\n    /// @dev Returns the management fee recipient\\n    /// @return The management fee recipient\\n    function managementFeeRecipient() external view returns (address);\\n\\n    /// @dev Returns the fee cap\\n    /// @return The fee cap\\n    function FEE_CAP() external view returns (uint256);\\n\\n    /// @dev Returns the constant value of 100\\n    /// @return The constant value of 100\\n    function ONE_HUNDRED() external view returns (uint256);\\n\\n    /// @dev Sets the performance fee\\n    /// @param _fee The new performance fee\\n    function setPerformanceFee(uint256 _fee) external;\\n\\n    /// @dev Sets the management fee\\n    /// @param _fee The new management fee\\n    function setManagementFee(uint256 _fee) external;\\n\\n    /// @dev Sets the performance fee recipient\\n    /// @param recipient The new performance fee recipient\\n    function setPerformanceFeeRecipient(address recipient) external;\\n\\n    /// @dev Sets the management fee recipient\\n    /// @param recipient The new management fee recipient\\n    function setManagementFeeRecipient(address recipient) external;\\n\\n    /// @dev Sets the vault contract\\n    /// @param _vault The address of the vault contract\\n    function setVault(address _vault) external;\\n\\n    /// @dev Sets the Uniswap V2 router address\\n    /// @param _unirouterV2 The address of the Uniswap V2 router\\n    function setUnirouterV2(address _unirouterV2) external;\\n\\n    /// @dev Sets the Uniswap V3 router address\\n    /// @param _unirouterV3 The address of the Uniswap V3 router\\n    function setUnirouterV3(address _unirouterV3) external;\\n\\n    /// @notice Retrieves information about the pending rewards to harvest from the convex pool\\n    /// @return _rewardAmounts rewards the amount representing the pending rewards\\n    /// @return _rewardTokens addresses of the reward tokens\\n    /// @return _enoughRewards list indicating if the reward token is enough to harvest\\n    /// @return _atLeastOne indicates if there is at least one reward to harvest\\n    function getPendingToHarvest()\\n        external\\n        returns (\\n            uint256[] memory _rewardAmounts,\\n            address[] memory _rewardTokens,\\n            bool[] memory _enoughRewards,\\n            bool _atLeastOne\\n        );\\n\\n    // List of the reward tokens\\n    function getRewardTokens() external view returns (address[] memory);\\n}\\n\\n/// @title IStrategyConvexNonPayable\\n/// @notice Extended interface for the Convex Strategy contract\\ninterface IStrategyConvexNonPayable is IStrategyConvexExtended {\\n    /// @dev Deposits tokens into the strategy\\n    /// @param _token The address of the token to deposit\\n    /// @param _amount Amount of tokens to deposit\\n    /// @param _user The address of the user\\n    /// @param _minWant The minimum amount of want tokens to get from curve\\n    function deposit(address _token, uint256 _amount, address _user, uint256 _minWant) external;\\n}\\n\\n/// @title IStrategyConvexPayable\\n/// @notice Extended interface for the Convex Strategy contract\\ninterface IStrategyConvexPayable is IStrategyConvexExtended {\\n    /// @dev Deposits tokens into the strategy\\n    /// @param _token The address of the token to deposit\\n    /// @param _amount Amount of tokens to deposit\\n    /// @param _user The address of the user\\n    /// @param _minWant The minimum amount of want tokens to get from curve\\n    function deposit(\\n        address _token,\\n        uint256 _amount,\\n        address _user,\\n        uint256 _minWant\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/strategies/curve/StrategyCalculationsTricryptoL1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { IStrategyConvexExtended as IStrategyConvex } from \\\"../../interfaces/dollet/IStrategyConvex.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { AggregatorV3Interface } from \\\"../../interfaces/chainlink/AggregatorV3Interface.sol\\\";\\nimport { IAdminStructure } from \\\"../../interfaces/dollet/IAdminStructure.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { IConvexRewardPoolL1 } from \\\"../../interfaces/convex/IConvex.sol\\\";\\nimport { IGaugeFactory } from \\\"../../interfaces/curve/IGaugeFactory.sol\\\";\\nimport { ICurveSwap } from \\\"../../interfaces/curve/ICurveSwap.sol\\\";\\nimport { IQuoter } from \\\"../../interfaces/common/IQuoter.sol\\\";\\nimport { UniV3Actions } from \\\"../../utils/UniV3Actions.sol\\\";\\nimport { IERC20 } from \\\"../../interfaces/common/IERC20.sol\\\";\\nimport { ICVXL1 } from \\\"../../interfaces/curve/ICVX.sol\\\";\\n\\n/// @title StrategyCalculationsTricryptoL1 contract for calculating strategy-related values\\ncontract StrategyCalculationsTricryptoL1 is Initializable {\\n    using SafeCast for int256;\\n\\n    /// @notice Address of the admin structure contract\\n    IAdminStructure public adminStructure;\\n    /// @notice Address of the strategy contract\\n    IStrategyConvex public strategy;\\n    /// @notice Address of the quoter contract\\n    IQuoter public quoter;\\n\\n    /// @notice Constant for representing 100 (100%)\\n    uint256 public constant ONE_HUNDRED = 100 ether;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @dev Initializes the StrategyCalculationsTricryptoL1 contract\\n    /// @param _strategy The address of the StrategyConvex contract\\n    /// @param _quoter The address of the Quoter contract\\n    /// @param _adminStructure The address of the AdminStructure contract\\n    function initialize(\\n        IStrategyConvex _strategy,\\n        IQuoter _quoter,\\n        IAdminStructure _adminStructure\\n    ) public initializer {\\n        require(address(_strategy) != address(0), \\\"ZeroStrategy\\\");\\n        require(address(_quoter) != address(0), \\\"ZeroQuoter\\\");\\n        require(address(_adminStructure) != address(0), \\\"ZeroAdminStructure\\\");\\n        strategy = _strategy;\\n        quoter = _quoter;\\n        adminStructure = _adminStructure;\\n    }\\n\\n    /// @dev Sets the Quoter contract address\\n    /// @param _quoter The address of the Quoter contract\\n    function setQuoter(IQuoter _quoter) external {\\n        adminStructure.isValidSuperAdmin(msg.sender);\\n        require(address(_quoter) != address(0), \\\"ZeroQuoter\\\");\\n        quoter = _quoter;\\n    }\\n\\n    /// @dev Sets the StrategyConvex contract address\\n    /// @param _strategy The address of the StrategyConvex contract\\n    function setStrategy(IStrategyConvex _strategy) external {\\n        adminStructure.isValidSuperAdmin(msg.sender);\\n        require(address(_strategy) != address(0), \\\"ZeroStrategy\\\");\\n        strategy = _strategy;\\n    }\\n\\n    /// @notice Estimates the deposit details for a specific token and amount\\n    /// @param _token The address of the token to deposit\\n    /// @param _amount The amount of tokens to deposit\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return amountWant The minimum amount of LP tokens to get from curve deposit\\n    function estimateDeposit(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 amountWant) {\\n        (bool isAllowed, ) = strategy.allowedDepositTokens(_token);\\n        require(isAllowed, \\\"TokenNotAllowed\\\");\\n        amountWant = calculateCurveDeposit(_token, _amount, _slippage);\\n    }\\n\\n    /// @notice Estimates the withdrawal details for a specific user, token, maximum amount, and slippage\\n    /// @param _user The address of the user\\n    /// @param _token The address of the token to withdraw\\n    /// @param _maxAmount The maximum amount of tokens to withdraw\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return minCurveOutput The minimum amount of tokens to get from the curve withdrawal\\n    /// @return withdrawable The minimum amount of tokens to get after the withdrawal\\n    function estimateWithdrawal(\\n        address _user,\\n        address _token,\\n        uint256 _maxAmount,\\n        uint256 _slippage\\n    ) external view returns (uint256 minCurveOutput, uint256 withdrawable) {\\n        (bool isAllowed, ) = strategy.allowedDepositTokens(_token);\\n        require(isAllowed, \\\"TokenNotAllowed\\\");\\n        uint256 maxClaim = calculateCurveMinWithdrawal(_token, _maxAmount, _slippage);\\n        minCurveOutput = maxClaim;\\n        uint256 _userDeposit = strategy.userWantDeposit(_user);\\n        uint256 _rewards = 0;\\n        if (_userDeposit < _maxAmount) {\\n            uint256 rewardsPercentage = ((_maxAmount - _userDeposit) * 1e18) / _maxAmount;\\n            _rewards = (maxClaim * rewardsPercentage) / 1e18;\\n        }\\n        uint256 _performanceFee = strategy.performanceFee();\\n        uint256 performancefeeAmount = (_rewards * _performanceFee) / ONE_HUNDRED;\\n        uint256 depositMinusRewards = maxClaim - _rewards;\\n        uint256 _managementFee = strategy.managementFee();\\n        uint256 managementfeeAmount = (depositMinusRewards * _managementFee) / ONE_HUNDRED;\\n        withdrawable = maxClaim - managementfeeAmount - performancefeeAmount;\\n    }\\n\\n    /// @notice Estimates the rewards details for a specific user, token, amount, and slippage\\n    /// @param _user The address of the user\\n    /// @param _token The address of the token to calculate rewards for\\n    /// @param _amount The amount of tokens\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return minCurveOutput The minimum amount of tokens to get from the curve withdrawal\\n    /// @return claimable The minimum amount of tokens to get after the claim of rewards\\n    function estimateRewards(\\n        address _user,\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 minCurveOutput, uint256 claimable) {\\n        return _estimateRewards(_token, _amount, _slippage, strategy.userWantDeposit(_user));\\n    }\\n\\n    /// @notice Estimates the total claimable rewards for all users using a specific token and slippage\\n    /// @param _token The address of the token to calculate rewards for\\n    /// @param _amount The amount of tokens\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return claimable The total claimable amount of tokens\\n    function estimateAllUsersRewards(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) external view returns (uint256 claimable) {\\n        (, claimable) = _estimateRewards(_token, _amount, _slippage, strategy.totalWantDeposits());\\n    }\\n\\n    /// @notice Estimates the want balance after a harvest\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return Returns the new want amount\\n    function estimateWantAfterHarvest(uint256 _slippage) external returns (uint256) {\\n        uint256 wantBalance = strategy.balanceOf();\\n        (\\n            uint256[] memory rewardAmounts,\\n            address[] memory rewardTokens,\\n            bool[] memory enoughRewards,\\n            bool atLeastOne\\n        ) = getPendingToHarvestView();\\n        if (!atLeastOne) return wantBalance;\\n        address depositToken = strategy.depositToken();\\n        uint256 totalInDeposit;\\n        for (uint256 i = 0; i < rewardAmounts.length; i++) {\\n            totalInDeposit += enoughRewards[i]\\n                ? estimateSwap(rewardTokens[i], depositToken, rewardAmounts[i], _slippage)\\n                : 0;\\n        }\\n        uint256 extraWant = calculateCurveDeposit(depositToken, totalInDeposit, _slippage);\\n        return wantBalance + extraWant;\\n    }\\n\\n    /// @notice Retrieves information about the pending rewards to harvest from the convex pool\\n    /// @return rewardAmounts rewards the amount representing the pending rewards\\n    /// @return rewardTokens addresses of the reward tokens\\n    /// @return enoughRewards list indicating if the reward token is enough to harvest\\n    /// @return atLeastOne indicates if there is at least one reward to harvest\\n    function getPendingToHarvestView()\\n        public\\n        view\\n        returns (\\n            uint256[] memory rewardAmounts,\\n            address[] memory rewardTokens,\\n            bool[] memory enoughRewards,\\n            bool atLeastOne\\n        )\\n    {\\n        rewardTokens = strategy.getRewardTokens();\\n        rewardAmounts = new uint256[](rewardTokens.length);\\n        enoughRewards = new bool[](rewardTokens.length);\\n        rewardAmounts[0] = IConvexRewardPoolL1(strategy.rewardPool()).earned(address(strategy)); // CRV\\n        rewardAmounts[1] = estimateCVXRewards(rewardAmounts[0]); // CVX\\n        for (uint256 i; i < rewardAmounts.length; i++) {\\n            rewardAmounts[i] += _getTokenBalance(rewardTokens[i]); // Adding exsting balance\\n            enoughRewards[i] = rewardAmounts[i] >= strategy.minimumToHarvest(rewardTokens[i]);\\n            if (enoughRewards[i]) atLeastOne = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Estimates the amoung of CVX rewards that the strategy can receive\\n     * @dev The amount of CVX is determined by the amount of CVX\\n     * @param _crvAmount The amount of crv rewards\\n     * @return The amount of cvx rewards tokens available to be claimed\\n     */\\n    function estimateCVXRewards(uint256 _crvAmount) public view virtual returns (uint256) {\\n        ICVXL1 cvx = ICVXL1(strategy.getRewardTokens()[1]);\\n        uint256 supply = cvx.totalSupply();\\n        uint256 maxSupply = cvx.maxSupply();\\n        uint256 totalCliffs = cvx.totalCliffs();\\n        uint256 reductionPerCliff = cvx.reductionPerCliff();\\n        uint256 cliff = supply / reductionPerCliff;\\n        if (cliff < totalCliffs) {\\n            uint256 reduction = totalCliffs - cliff;\\n            uint256 cvxAmount = (_crvAmount * reduction) / totalCliffs;\\n            uint256 amtTillMax = maxSupply - supply;\\n            if (cvxAmount > amtTillMax) cvxAmount = amtTillMax;\\n            return cvxAmount;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens deposited by a specific user in the indicated token\\n     * @param _user The address of the user.\\n     * @param _token The address of the token.\\n     * @return The amount of tokens deposited by the user.\\n     */\\n    function userDeposit(address _user, address _token) external view returns (uint256) {\\n        (bool isAllowed, ) = strategy.allowedDepositTokens(_token);\\n        require(isAllowed, \\\"TokenNotAllowed\\\");\\n        uint256 userWant = strategy.userWantDeposit(_user);\\n        if (userWant == 0) return 0;\\n        return calculateCurveMinWithdrawal(_token, userWant, 0);\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens deposited in the strategy in the indicated token\\n     * @param _token The address of the token.\\n     * @return The total amount of tokens deposited.\\n     */\\n    function totalDeposits(address _token) external view returns (uint256) {\\n        (bool isAllowed, ) = strategy.allowedDepositTokens(_token);\\n        require(isAllowed, \\\"TokenNotAllowed\\\");\\n        uint256 totalWant = strategy.totalWantDeposits();\\n        if (totalWant == 0) return 0;\\n        return calculateCurveMinWithdrawal(_token, totalWant, 0);\\n    }\\n\\n    /// @notice Retrieves the minimum amount of tokens to swap from a specific fromToken to toToken\\n    /// @param _fromToken The address of the token to swap from\\n    /// @param _toToken The address of the token to swap to\\n    /// @return The minimum amount of tokens to swap\\n    function getAutomaticSwapMin(\\n        address _fromToken,\\n        address _toToken\\n    ) external view returns (uint256) {\\n        AggregatorV3Interface _oracleFrom = AggregatorV3Interface(strategy.oracle(_fromToken));\\n        AggregatorV3Interface _oracleTo = AggregatorV3Interface(strategy.oracle(_toToken));\\n        uint256 fromTokenPrice = (_oracleFrom.latestAnswer().toUint256() * 1e18) /\\n            (10 ** _oracleFrom.decimals());\\n        uint256 toTokenPrice = (_oracleTo.latestAnswer().toUint256() * 1e18) /\\n            (10 ** _oracleTo.decimals());\\n        uint256 minAmount = (fromTokenPrice * _getTokenBalance(_fromToken)) /\\n            toTokenPrice /\\n            (10 ** (18 - IERC20(_toToken).decimals()));\\n        return (minAmount * (ONE_HUNDRED - strategy.defaultSlippageUniswap())) / ONE_HUNDRED;\\n    }\\n\\n    function getAutomaticCurveMinLp(\\n        uint256 _depositAmount\\n    ) external view virtual returns (uint256) {\\n        (uint256 curveLPInUsd, uint256 oneDepositTokenInUsd) = getTokenPricesInUsd();\\n        uint256 depositUsdPrice = (_depositAmount * oneDepositTokenInUsd) /\\n            (10 ** IERC20(strategy.depositToken()).decimals());\\n        uint256 depositInUsdWithSlippage = (depositUsdPrice *\\n            (ONE_HUNDRED - strategy.defaultSlippageCurve())) / ONE_HUNDRED;\\n        return (depositInUsdWithSlippage * 1e18) / curveLPInUsd;\\n    }\\n\\n    function getTokenPricesInUsd()\\n        internal\\n        view\\n        returns (uint256 curveLPInUsd, uint256 oneDepositTokenInUsd)\\n    {\\n        uint256 poolSize = strategy.POOL_SIZE();\\n        address pool = strategy.pool();\\n        address _depositToken = strategy.depositToken();\\n        uint256 totalInUsd;\\n        for (uint256 i; i < poolSize; i++) {\\n            address coin = ICurveSwap(pool).coins(i);\\n            AggregatorV3Interface _oracle = AggregatorV3Interface(strategy.oracle(coin));\\n            uint256 oneTokenPrice = (_oracle.latestAnswer().toUint256() * 1e18) /\\n                (10 ** _oracle.decimals());\\n            uint256 current = (ICurveSwap(pool).balances(i) * oneTokenPrice) /\\n                (10 ** IERC20(coin).decimals());\\n            if (coin == _depositToken) oneDepositTokenInUsd = oneTokenPrice;\\n            totalInUsd += current;\\n        }\\n        curveLPInUsd = (totalInUsd * 1e18) / ICurveSwap(pool).totalSupply();\\n    }\\n\\n    /// @notice Estimates the amount of tokens to swap from one token to another\\n    /// @param _from The address of the token to swap from\\n    /// @param _to The address of the token to swap to\\n    /// @param _amount The amount of tokens to swap\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return estimate The estimated amount of tokens to receive after the swap\\n    function estimateSwap(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) public returns (uint256 estimate) {\\n        if (_from == _to) return _amount;\\n        uint256 amountOut = quoter.quoteExactInput(strategy.paths(_from, _to), _amount);\\n        return _getMinimum(amountOut, _slippage);\\n    }\\n\\n    /// @notice Calculates the minimum amount of tokens to receive from Curve for a specific token and maximum amount\\n    /// @param _token The address of the token to withdraw\\n    /// @param _amount The maximum amount of tokens to withdraw\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The minimum amount of tokens to receive from Curve\\n    function calculateCurveMinWithdrawal(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) public view returns (uint256) {\\n        (, uint8 index) = strategy.allowedDepositTokens(_token);\\n        uint256 amount = ICurveSwap(strategy.pool()).calc_withdraw_one_coin(_amount, index);\\n        return _getMinimum(amount, _slippage);\\n    }\\n\\n    /// @notice Calculates the amount of LP tokens to get on curve deposit\\n    /// @param _amount The amount of tokens to deposit\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The amount of LP tokens to get\\n    function calculateCurveDeposit(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage\\n    ) public view returns (uint256) {\\n        uint256[3] memory amounts = getCurveAmounts(_token, _amount);\\n        uint256 calcAmount = ICurveSwap(strategy.pool()).calc_token_amount(amounts, true);\\n        return _getMinimum(calcAmount, _slippage);\\n    }\\n\\n    /// @notice Formats the array input for curve\\n    /// @param _depositToken The address of the deposit token\\n    /// @param _amount The amount to deposit\\n    /// @return amounts An array of token amounts to use in curve\\n    function getCurveAmounts(\\n        address _depositToken,\\n        uint256 _amount\\n    ) public view returns (uint256[3] memory amounts) {\\n        (, uint8 index) = strategy.allowedDepositTokens(_depositToken);\\n        amounts[index] = _amount;\\n    }\\n\\n    /// @dev Estimates the rewards for a specific token and amount, taking into account slippage and deposit amount.\\n    /// @param _token The address of the token for which rewards are being estimated\\n    /// @param _amount The amount of tokens being considered\\n    /// @param _slippage The slippage percentage to consider\\n    /// @param _depositAmount The total deposit amount in the strategy\\n    /// @return minCurveOutput The minimum output from the Curve pool\\n    /// @return claimable The claimable rewards for the specified token and amount\\n    function _estimateRewards(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _slippage,\\n        uint256 _depositAmount\\n    ) private view returns (uint256 minCurveOutput, uint256 claimable) {\\n        (bool isAllowed, ) = strategy.allowedDepositTokens(_token);\\n        require(isAllowed, \\\"TokenNotAllowed\\\");\\n        if (\\n            _depositAmount == 0 ||\\n            _amount == 0 ||\\n            strategy.balanceOf() == 0 ||\\n            _depositAmount >= _amount\\n        ) return (0, 0);\\n\\n        uint256 rewards = _amount - _depositAmount;\\n        minCurveOutput = calculateCurveMinWithdrawal(_token, rewards, _slippage);\\n        uint256 _performanceFee = strategy.performanceFee();\\n        uint256 performancefeeAmount = (minCurveOutput * _performanceFee) / ONE_HUNDRED;\\n        claimable = minCurveOutput - performancefeeAmount;\\n    }\\n\\n    /// @notice Retrieves the balance of a specific token held by the Strategy\\n    /// @param _token The address of the token\\n    /// @return The token balance\\n    function _getTokenBalance(address _token) private view returns (uint256) {\\n        return IERC20(_token).balanceOf(address(strategy));\\n    }\\n\\n    /// @notice Retrieves the minimum value between a specific amount and a slippage percentage\\n    /// @param _amount The amount\\n    /// @param _slippage The allowed slippage percentage\\n    /// @return The minimum value\\n    function _getMinimum(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\\n        return _amount - ((_amount * _slippage) / ONE_HUNDRED);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/UniV3Actions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { IUniswapRouterV3WithDeadline } from \\\"../interfaces/common/IUniswapRouterV3WithDeadline.sol\\\";\\nimport { IUniswapRouterV3 } from \\\"../interfaces/common/IUniswapRouterV3.sol\\\";\\n\\n/// @title Library to interact with uniswap v3\\n/// @dev Library for Uniswap V3 actions.\\nlibrary UniV3Actions {\\n    /// @dev Performs a Uniswap V3 swap with a deadline.\\n    /// @param _router The address of the Uniswap V3 router.\\n    /// @param _path The path of tokens for the swap.\\n    /// @param _amount The input amount for the swap.\\n    /// @param _amountOutMinimum The minimum amount of output tokens expected from the swap.\\n    /// @return amountOut The amount of output tokens received from the swap.\\n    function swapV3WithDeadline(\\n        address _router,\\n        bytes memory _path,\\n        uint256 _amount,\\n        uint256 _amountOutMinimum\\n    ) internal returns (uint256 amountOut) {\\n        IUniswapRouterV3WithDeadline.ExactInputParams\\n            memory swapParams = IUniswapRouterV3WithDeadline.ExactInputParams({\\n                path: _path,\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: _amount,\\n                amountOutMinimum: _amountOutMinimum\\n            });\\n        return IUniswapRouterV3WithDeadline(_router).exactInput(swapParams);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminStructure\",\"outputs\":[{\"internalType\":\"contract IAdminStructure\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"calculateCurveDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"calculateCurveMinWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateAllUsersRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_crvAmount\",\"type\":\"uint256\"}],\"name\":\"estimateCVXRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWant\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minCurveOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"estimate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateWantAfterHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"estimateWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minCurveOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"getAutomaticCurveMinLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"getAutomaticSwapMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getCurveAmounts\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingToHarvestView\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"enoughRewards\",\"type\":\"bool[]\"},{\"internalType\":\"bool\",\"name\":\"atLeastOne\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStrategyConvexExtended\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"contract IQuoter\",\"name\":\"_quoter\",\"type\":\"address\"},{\"internalType\":\"contract IAdminStructure\",\"name\":\"_adminStructure\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoter\",\"outputs\":[{\"internalType\":\"contract IQuoter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IQuoter\",\"name\":\"_quoter\",\"type\":\"address\"}],\"name\":\"setQuoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStrategyConvexExtended\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IStrategyConvexExtended\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"userDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StrategyCalculationsTricryptoL1", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}