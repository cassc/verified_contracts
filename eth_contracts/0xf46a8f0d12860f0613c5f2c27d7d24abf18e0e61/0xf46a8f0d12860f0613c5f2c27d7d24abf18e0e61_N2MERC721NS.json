{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Common.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport {IERC20} from \\\"openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IN2MCrossFactory} from \\\"./interfaces/IN2MCrossFactory.sol\\\";\\nimport {N2MCommonStorage, IN2MCommonStorage, DynamicNFT} from \\\"./Storage.sol\\\";\\nimport {DynamicPrice} from \\\"./interfaces/DynamicPrice.sol\\\";\\nimport {IN2MCommon, IERC4907, IERC5192, IERC7496} from \\\"./interfaces/IN2MCommon.sol\\\";\\n\\n/// Utils\\nimport {LibString} from \\\"solady/utils/LibString.sol\\\";\\nimport {ECDSA} from \\\"solady/utils/ECDSA.sol\\\";\\nimport {MerkleProofLib} from \\\"solady/utils/MerkleProofLib.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @title NFTs2Me.com Smart Contracts\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\nabstract contract Common is IN2MCommon, N2MCommonStorage {\\n    constructor(address payable factoryAddress_, uint256 protocolFee_) N2MCommonStorage(factoryAddress_, protocolFee_) {\\n        /// Disable initilization\\n        _currentPhase = SalePhase.CLOSED;\\n    }\\n\\n    modifier initializer() {\\n        uint256 packedData;\\n        assembly {\\n            packedData := sload(_availableCollectionSize.slot)\\n        }        \\n        if (packedData > 0) {\\n            _revert(InvalidInitialization.selector);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (msg.sender != FACTORY) {\\n            if (owner() != msg.sender) {\\n                revert OwnableUnauthorizedAccount(msg.sender);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the address of the current collection owner.\\n    function owner() public view override returns (address collectionOwner) {\\n        return IN2MCrossFactory(FACTORY).ownerOf(uint256(uint160(address(this))));\\n    }\\n\\n    function transferOwnership(address to) external payable override onlyOwner {\\n        IN2MCrossFactory(FACTORY).transferCollectionOwnership(to);\\n    }\\n\\n    function ownershipTransferred(address from, address to) external payable {\\n        if (msg.sender != FACTORY) revert();\\n        emit OwnershipTransferred(from, to);\\n    }\\n\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        /// On the first call to nonReentrant, _status will be 0 or NOT_ENTERED\\n        if (_reentrancyStatus == REENTRANCY_ENTERED) {\\n            _revert(ReentrancyGuard.selector);\\n        }\\n\\n        /// Any calls to nonReentrant after this point will fail\\n        _reentrancyStatus = REENTRANCY_ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        /// By storing the original value once again, a refund is triggered (see\\n        /// https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual;\\n\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address);\\n\\n    function _requireTokenOwned(uint256 tokenId) internal view virtual;\\n\\n    function _setSoulbound(uint256 tokenId) internal {\\n        _soulbound[tokenId] = true;\\n        emit Locked(tokenId);\\n    }\\n\\n    function locked(uint256 tokenId) external view override returns (bool) {\\n        _requireTokenOwned(tokenId);\\n        return (_soulbound[tokenId] || _soulboundCollection);\\n    }\\n\\n    /// @notice Returns the current total supply.\\n    /// @return Current total supply.\\n    function totalSupply() public virtual view returns (uint256) {\\n        return _actualSoldTokens() - uint256(_burnedTokens);\\n    }\\n\\n    /// @notice Returns the amount of burned tokens.\\n    /// @return Burned tokens.\\n    function burnedTokens() external view returns (uint256) {\\n        return uint256(_burnedTokens);\\n    }\\n\\n    function collectionSize() external view override returns (uint256 size) {\\n        size = _actualCollectionSize();\\n        if (size == type(uint32).max) {\\n            return 0;\\n        } else {\\n            return size - _burnedTokens;\\n        }\\n    }\\n\\n    function _actualCollectionSize() internal view returns (uint256) {\\n        return uint256(_availableCollectionSize) + uint256(_reservedTokens);\\n    }\\n\\n    /// @notice Max amount of NFTs to be hold per address.\\n    /// @return Max per address allowed.\\n    function maxPerAddress() external view override returns (uint256) {\\n        return _maxPerAddress;\\n    }\\n\\n    /**\\n     * @dev For more efficient reverts.\\n     */\\n    function _revert(bytes4 errorSelector) internal pure {\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n\\n    function _getIPFSURI(bytes32 CIDHash) internal view returns (string memory) {\\n        return IN2MCrossFactory(FACTORY).getIPFSURI(CIDHash);\\n    }\\n\\n    function mintingType() external virtual view returns (MintingType) {\\n        return _mintingType;        \\n    }\\n\\n    function _reduceCollectionSize(uint32 newAvailableCollectionSize) internal {\\n        if (newAvailableCollectionSize == 0 || newAvailableCollectionSize >= _availableCollectionSize || newAvailableCollectionSize < _actualSoldTokens()) _revert(InvadlidCollectionSize.selector);\\n        _availableCollectionSize = newAvailableCollectionSize;\\n    }\\n\\n    function reserveTokens(uint16 amount) external payable override onlyOwner {\\n        if ((uint256(amount) + _actualSoldTokens()) > uint256(_availableCollectionSize)) _revert(InvalidAmount.selector);\\n        if ((uint256(amount) + _reservedTokens) > type(uint16).max) _revert(InvalidAmount.selector);\\n        _reservedTokens += amount;\\n        _availableCollectionSize -= amount;\\n    }\\n\\n    function unreserveTokens(uint16 amount) external payable override onlyOwner {\\n        if (amount > _reservedTokens) _revert(InvalidAmount.selector);\\n        _reservedTokens -= amount;\\n        _availableCollectionSize += amount;\\n    }\\n\\n    function reservedTokens() external view override returns (uint256) {\\n        return _reservedTokens;\\n    }\\n\\n    function _actualSoldTokens() internal view virtual returns (uint32);\\n\\n    function _nextTokenId() internal view virtual returns (uint32);\\n\\n    function merkleRoot() external view override returns (bytes32) {\\n        return _merkleRoot;\\n    }\\n\\n    function setMerkleRoot(bytes32 merkleRoot_) external payable override onlyOwner {\\n        _merkleRoot = merkleRoot_;\\n    }\\n\\n    function allowListed(address _wallet, bytes32[] calldata _proof)\\n      public\\n      view\\n      override\\n      returns (bool)\\n    {\\n      return\\n          MerkleProofLib.verify(\\n              _proof,\\n              _merkleRoot,\\n              keccak256(abi.encodePacked(_wallet))\\n          );\\n    }\\n\\n    function mintFee(uint256 amount) external view override returns (uint256) {\\n        return _creatorMintFee(amount);\\n    }\\n\\n    function protocolFee() public view override returns (uint256) {\\n        if (_feesRemoved) return 0;\\n        return PROTOCOL_FEE;\\n    }\\n\\n    function _protocolFee() internal view returns (uint256) {\\n        return PROTOCOL_FEE;\\n    }\\n\\n    function _creatorMintFee() internal view returns (uint256) {\\n        if (!_hasDynamicPrice) {\\n            return _mintPrice;\\n        }\\n        return DynamicPrice(address(this)).mintPrice(msg.sender, 1);\\n\\n    }\\n\\n    function _creatorMintFee(uint256 amount) internal view returns (uint256) {\\n        if (!_hasDynamicPrice) {\\n            return _mintPrice * amount;\\n        }\\n        return DynamicPrice(address(this)).mintPrice(msg.sender, amount);\\n\\n    }\\n\\n    function changeMintFee(uint256 newMintPrice, bool isDynamic) external payable override onlyOwner {\\n        _mintPrice = newMintPrice;\\n        if (isDynamic != _hasDynamicPrice) _hasDynamicPrice = isDynamic;\\n    }\\n\\n    function _requirePaymentWithAffiliates(uint256 amount, address affiliate) internal {\\n        uint256 currentUserDiscount;\\n        uint256 currentAffiliatePercentage;\\n        if (_affiliatesInfo[affiliate].enabled) {\\n            currentUserDiscount = _affiliatesInfo[affiliate].userDiscount;\\n            currentAffiliatePercentage = _affiliatesInfo[affiliate].affiliatePercentage;\\n        } else {\\n            currentUserDiscount = _affiliatesInfo[address(0)].userDiscount;\\n            currentAffiliatePercentage = _affiliatesInfo[address(0)].affiliatePercentage;\\n        }\\n\\n        uint256 discountTotalMintPrice = ((100_00 - currentUserDiscount) * _creatorMintFee(amount)) / 100_00;\\n        _requireFeesPayment(discountTotalMintPrice, _protocolFee()*amount);\\n        if (affiliate != address(0)) {\\n            uint256 affiliateAmount = (currentAffiliatePercentage * discountTotalMintPrice) / 100_00;\\n            _pendingTotalAffiliatesBalance += affiliateAmount;\\n            pendingAffiliateBalance[affiliate] += affiliateAmount;\\n            emit AffiliateSell(affiliate);\\n        }\\n    }\\n\\n    function removeProtocolFee(bytes calldata signature, uint256 fee, address feeReceiver) external payable override {\\n        address signer = ECDSA.recoverCalldata(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(\\n                    abi.encodePacked(\\n                        this.removeProtocolFee.selector,                       \\n                        fee,                                                 \\n                        feeReceiver,                                         \\n                        address(this),                                         \\n                        block.chainid                                          \\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n\\n        if (signer != N2M_SIGNER) _revert(SignatureMismatch.selector);\\n        _feesRemoved = true;\\n\\n        if (fee > 0) {\\n            if (msg.value < fee) _revert(InvalidAmount.selector);\\n\\n            bool success;\\n            assembly {\\n                success := call(gas(), feeReceiver, fee, 0, 0, 0, 0)\\n            }\\n            if (success == false) revert();\\n        }\\n    }\\n\\n    function _requireFee(uint256 amount) internal {\\n        _requireFeesPayment(_creatorMintFee(amount), _protocolFee()*amount);\\n    }\\n\\n    function _requireFeesPayment(uint256 creatorMintFee, uint256 n2mFee) internal {\\n        uint256 pendingMsgValue = msg.value;\\n\\n        if (creatorMintFee > 0) {\\n            if (_isERC20Payment == false) {\\n                if (pendingMsgValue < creatorMintFee) revert InvalidMintFee();\\n                pendingMsgValue -= creatorMintFee;\\n            } else {\\n                SafeTransferLib.safeTransferFrom(\\n                    _erc20PaymentAddress,\\n                    msg.sender,\\n                    address(this),\\n                    creatorMintFee\\n                );\\n            }\\n        }\\n\\n        if (_feesRemoved == false) {\\n            if (pendingMsgValue < n2mFee) revert InvalidMintFee();\\n\\n            bool success;\\n            assembly {\\n                success := call(gas(), PROTOCOL_FEE_RECIPIENT, pendingMsgValue, 0, 0, 0, 0)\\n            }\\n            if (success == false) revert InvalidMintFee();\\n        }\\n    }\\n\\n    function changeERC20PaymentAddress(address newErc20PaymentAddress) external payable override onlyOwner {\\n        if (_pendingTotalAffiliatesBalance > 0) _revert(PendingAffiliatesBalance.selector);\\n        _erc20PaymentAddress = newErc20PaymentAddress;\\n        _isERC20Payment = (newErc20PaymentAddress != address(0));\\n    }\\n\\n    function _erc20Transfer(address erc20Address, address to, uint256 amount) internal {\\n        IERC20(erc20Address).transfer(to, amount);\\n    }\\n\\n    function withdrawERC20(address erc20Address)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        onlyOwner\\n    {\\n        uint256 availableBalance = SafeTransferLib.balanceOf(erc20Address, address(this));\\n        if (availableBalance == 0) return;\\n        if (_erc20PaymentAddress == erc20Address) {\\n\\n            if (_pendingTotalAffiliatesBalance >= availableBalance) return;\\n            unchecked {\\n                availableBalance -= _pendingTotalAffiliatesBalance;\\n            }\\n        }\\n\\n        uint256 withdrawn;\\n\\n        uint256 amountToSend;\\n        uint256 revenuePercentageTotal;\\n        uint256 revenueAddressesLength = _revenueInfo.length;\\n        for (uint256 i; i < revenueAddressesLength; i++) {\\n            uint256 iPercentage = _revenueInfo[i].percentage;\\n            revenuePercentageTotal += iPercentage;\\n            amountToSend = ((availableBalance * iPercentage) / 100_00);\\n            try IERC20(erc20Address).transfer(_revenueInfo[i].to, amountToSend) {\\n                withdrawn += amountToSend;\\n            } catch {\\n\\n            }\\n        }\\n\\n        _erc20Transfer(erc20Address, owner(), (availableBalance - withdrawn));\\n        withdrawnERC20Amount[erc20Address] += availableBalance;\\n    }\\n\\n    function withdraw() external payable override nonReentrant onlyOwner {\\n        uint256 availableBalance = address(this).balance;\\n        if (_erc20PaymentAddress == address(0)) {\\n\\n            if (_pendingTotalAffiliatesBalance >= availableBalance) return;\\n            unchecked {\\n                availableBalance -= _pendingTotalAffiliatesBalance;\\n            }\\n        }\\n\\n        uint256 withdrawn;\\n        bool success;\\n\\n        uint256 amountToSend;\\n        uint256 revenuePercentageTotal;\\n        uint256 revenueAddressesLength = _revenueInfo.length;\\n        for (uint256 i; i < revenueAddressesLength; i++) {\\n            uint256 iPercentage = _revenueInfo[i].percentage;\\n            revenuePercentageTotal += iPercentage;\\n            amountToSend = ((availableBalance * iPercentage) / 100_00);\\n            if (_revenueInfo[i].to != address(0)) {\\n                address revenueReceiver = _revenueInfo[i].to;\\n                assembly {\\n                    success := call(gas(), revenueReceiver, amountToSend, 0, 0, 0, 0)\\n                }\\n                if (success) {\\n                    withdrawn += amountToSend;\\n                }\\n            }\\n        }\\n\\n        address contractOwner = owner();\\n        amountToSend = (availableBalance - withdrawn);\\n        assembly {\\n            success := call(gas(), contractOwner, amountToSend, 0, 0, 0, 0)\\n        }\\n        if (success) {\\n            _withdrawnAmount += availableBalance;\\n        } else {\\n            _withdrawnAmount += withdrawn; \\n        }\\n    }\\n\\n    function affiliateWithdraw(address affiliate) external payable override nonReentrant {\\n\\n        if (affiliate != msg.sender && PROTOCOL_FEE_RECIPIENT != msg.sender) revert OwnableUnauthorizedAccount(msg.sender);\\n\\n        uint256 pending = pendingAffiliateBalance[affiliate];\\n\\n        delete(pendingAffiliateBalance[affiliate]);\\n        if (pending > _pendingTotalAffiliatesBalance) pending = _pendingTotalAffiliatesBalance;\\n        unchecked {\\n            _pendingTotalAffiliatesBalance -= pending;\\n        }\\n\\n        /// More gas efficient because _isERC20Payment is not hot and is packed.\\n        if (_erc20PaymentAddress == address(0)) { \\n            assembly {\\n                pop(call(gas(), affiliate, pending, 0, 0, 0, 0))\\n            }\\n        } else {\\n            _erc20Transfer(_erc20PaymentAddress, affiliate, pending);\\n        }\\n    }\\n\\n    function setAffiliatesPercentageAndDiscount(\\n        uint16 userDiscount,\\n        uint16 affiliatePercentage,\\n        address affiliateAddress\\n    ) external override onlyOwner {\\n        AffiliateInformation storage currentAffiliateInfo = _affiliatesInfo[affiliateAddress];\\n        if ((userDiscount > 100_00) || (affiliatePercentage > 100_00)) {\\n            _revert(InvalidPercentageOrDiscountValues.selector);\\n        }\\n        if ((userDiscount < currentAffiliateInfo.userDiscount) || (affiliatePercentage < currentAffiliateInfo.affiliatePercentage)) {\\n            _revert(CantLowerCurrentPercentages.selector);\\n        }\\n        currentAffiliateInfo.enabled = true;\\n        currentAffiliateInfo.userDiscount = userDiscount;\\n        currentAffiliateInfo.affiliatePercentage = affiliatePercentage;\\n    }\\n\\n    function affiliatesInfo(address affiliate) external view returns (bool enabled, uint16 affiliatePercentage, uint16 userDiscount) {\\n        return (_affiliatesInfo[affiliate].enabled, _affiliatesInfo[affiliate].affiliatePercentage, _affiliatesInfo[affiliate].userDiscount);\\n    }    \\n\\n    function ownerMaxRevenue() external view returns (uint256 maxRevenue) {\\n        unchecked {\\n            for (uint256 i; i<_revenueInfo.length; i++) {\\n                maxRevenue += _revenueInfo[i].percentage;\\n            }\\n            return (100_00 - maxRevenue);\\n        }\\n    }    \\n\\n    function withdrawnAmount() external view returns (uint256) {\\n        return _withdrawnAmount;\\n    }\\n\\n    function pendingTotalAffiliatesBalance() external view returns (uint256) {\\n        return _pendingTotalAffiliatesBalance;\\n    }\\n\\n    function erc20PaymentAddress() external view returns (address) {\\n        return _erc20PaymentAddress;\\n    }\\n\\n    function whitelistOperators(address[] calldata operators) external payable override onlyOwner {\\n        for (uint256 i = 0; i < operators.length; i++) {\\n            whitelistedOperators[operators[i]] = true;\\n        }\\n        _operatorFilterStatus = OperatorFilterStatus.ENABLED_ONLY_WHITELISTED;\\n    }\\n\\n    function disableOperatorFilterRegistry() external payable onlyOwner {\\n        _operatorFilterStatus = OperatorFilterStatus.DISABLED;\\n    }\\n\\n    function isOperatorFilterRegistryEnabled() external view returns (bool) {\\n        return (_operatorFilterStatus == OperatorFilterStatus.ENABLED_ONLY_WHITELISTED);\\n    }\\n\\n    modifier onlyAllowedOperatorApproval(address operator) {\\n        _isOperatorAllowed(operator);\\n        _;\\n    }\\n\\n    function _isOperatorAllowed(address operator) internal view {\\n        if (_operatorFilterStatus == OperatorFilterStatus.ENABLED_ONLY_WHITELISTED) {\\n            if (whitelistedOperators[operator] == false) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n\\n    }\\n\\n    /// @notice Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n    /// @param salePrice The sale price\\n    /// @return receiver the receiver of the royalties.\\n    /// @return royaltyAmount the amount of the royalties for the given input.\\n    function royaltyInfo(\\n        uint256, \\n        uint256 salePrice\\n    ) external view virtual returns (address receiver, uint256 royaltyAmount) {\\n\\n        return (address(this), uint256((salePrice * royaltyFee()) / 100_00));\\n    }\\n\\n    function royaltyFee() public view returns (uint256) {\\n        return _royaltyFee;        \\n    }\\n\\n    function changeRoyaltyFee(uint16 newFee) external payable onlyOwner {\\n        _royaltyFee = newFee;\\n    }\\n\\n    function contractURI() public view returns (string memory) {\\n\\n        if (_contractURIMetadataCIDHash != 0) {\\n            return _getIPFSURI(_contractURIMetadataCIDHash);\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"https://metadata.nfts2me.com/api/contractURI/\\\",\\n                    LibString.toString(block.chainid),\\n                    \\\"/\\\",\\n                    LibString.toString(uint256(uint160(address(this)))),\\n                    \\\"/\\\"\\n                )\\n            );\\n    }\\n\\n    function setContractURI(bytes32 newContractURIMetadataCIDHash) external payable override onlyOwner {\\n        _contractURIMetadataCIDHash = newContractURIMetadataCIDHash;\\n        emit ContractURIUpdated();\\n    }\\n\\n    function isMetadataFixed() public view virtual override returns (bool);\\n\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory);\\n\\n    function setBaseURI(string memory baseURIString, bytes32 baseURICIDHash, bool isPlaceholder, bool freezeMetadata) external payable override onlyOwner {\\n        if (isMetadataFixed()) _revert(MetadataAlreadyFixed.selector);\\n        if (freezeMetadata) {\\n            if (isPlaceholder) _revert(PlacerholderCantFreezeMetadata.selector);\\n            _isMetadataEditable = false;\\n        }\\n        if (bytes(baseURIString).length == 0 && baseURICIDHash == 0) _revert(NewBaseURICantBeEmpty.selector);\\n        _hasPlaceholder = isPlaceholder;\\n        _baseURICIDHash = baseURICIDHash;\\n        _baseURIString = baseURIString;\\n\\n        emit BatchMetadataUpdate(1, type(uint256).max);\\n    }\\n\\n    function _checkPhase() internal {\\n        /// Phases\\n        if (_currentPhase != SalePhase.PUBLIC) {\\n\\n            if (_currentPhase == SalePhase.END_DATE) {\\n                if (block.timestamp > _endDateTimestamp) {\\n                    revert SaleFinished();\\n                }\\n            } else if (_currentPhase == SalePhase.DROP_DATE) {\\n                if (block.timestamp < _dropDateTimestamp) {\\n                    revert WaitUntilDropDate();\\n                }\\n                _currentPhase = SalePhase.PUBLIC;\\n                delete(_dropDateTimestamp); /// Safe gas freeing storage\\n            } else if (_currentPhase == SalePhase.DROP_AND_END_DATE) {\\n                if (block.timestamp < _dropDateTimestamp) {\\n                    revert WaitUntilDropDate();\\n                }\\n                if (block.timestamp > _endDateTimestamp) {\\n                    revert SaleFinished();\\n                }\\n                _currentPhase = SalePhase.END_DATE;\\n                delete(_dropDateTimestamp); /// Safe gas freeing storage\\n            } else {\\n                revert PublicSaleNotOpen();\\n            }\\n        }\\n    }\\n\\n    function setPhase(SalePhase newPhase) external payable override onlyOwner {\\n        if (newPhase > SalePhase.PRESALE) _revert(InvalidPhaseWithoutDate.selector);\\n        delete(_dropDateTimestamp);\\n        delete(_endDateTimestamp);\\n        _currentPhase = newPhase;\\n    }\\n\\n    function setDropAndEndDate(uint256 dropDateTimestamp, uint256 endDateTimestamp) external payable override onlyOwner {\\n        if (dropDateTimestamp == 0) {\\n            _currentPhase = SalePhase.END_DATE;\\n        } else if (endDateTimestamp == 0) {\\n            _currentPhase = SalePhase.DROP_DATE;\\n        } else {\\n            _currentPhase = SalePhase.DROP_AND_END_DATE;\\n        }\\n\\n        _dropDateTimestamp = dropDateTimestamp;\\n        _endDateTimestamp = endDateTimestamp;\\n    }\\n\\n    function saleDates() external view returns (uint256 dropDateTimestamp, uint256 endDateTimestamp) {\\n        return (_dropDateTimestamp, _endDateTimestamp);        \\n    }\\n\\n    function setMaxPerAddress(uint16 newMaxPerAddress) external payable override onlyOwner {\\n        _maxPerAddress = newMaxPerAddress;\\n    }\\n\\n    function currentPhase() external view override returns (SalePhase) {\\n        return _currentPhase;        \\n    }\\n\\n    function isOpen() external view returns (bool) {\\n        if (_currentPhase == SalePhase.PUBLIC) return true;\\n        if (_currentPhase == SalePhase.END_DATE) {\\n            return (block.timestamp <= _endDateTimestamp);\\n        }\\n        if (_currentPhase == SalePhase.DROP_AND_END_DATE) {\\n            if (block.timestamp >= _dropDateTimestamp) {\\n                return (block.timestamp <= _endDateTimestamp);\\n            }\\n        }\\n        if (_currentPhase == SalePhase.DROP_DATE) {\\n            return (block.timestamp >= _dropDateTimestamp);\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Set the URI for the trait metadata.\\n     * @param uri The new URI to set.\\n     */\\n    function setTraitMetadataURI(string calldata uri) external payable override onlyOwner {\\n\\n        _traitMetadataURI = uri;\\n\\n        emit TraitMetadataURIUpdated();\\n    }    \\n\\n    /**\\n     * @notice Get the URI for the trait metadata\\n     */\\n    function getTraitMetadataURI() external view override virtual returns (string memory labelsURI) {\\n\\n        return _traitMetadataURI;\\n    }\\n\\n    /**\\n     * @notice Set the Dynamic Traits permissions.\\n     * @param ownerCanUpdateTraitKeys The keys of the traits that a given token owner can update.\\n     * @param onlyOnceTraitKeys The keys of the traits that can be updated only once.\\n     */\\n    function setTraitsPermissions(bytes32[] calldata ownerCanUpdateTraitKeys, bytes32[] calldata onlyOnceTraitKeys) external payable override onlyOwner {\\n        for (uint256 i; i < ownerCanUpdateTraitKeys.length; i++) {\\n            _traitPermissions[ownerCanUpdateTraitKeys[i]].ownerCanUpdateValue = true;\\n        }\\n        for (uint256 i; i < onlyOnceTraitKeys.length; i++) {\\n            _traitPermissions[onlyOnceTraitKeys[i]].onlyOnce = true;\\n        }\\n    }\\n\\n    function _setTrait(uint256 tokenId, bytes32 traitKey, bytes32 value) private {\\n        bytes32 existingValue = _traits[tokenId][traitKey];\\n\\n        if (_traitPermissions[traitKey].onlyOnce==true) {\\n            if (existingValue > 0) {\\n                _revert(OnlyOnceTrait.selector);\\n            }\\n            emit ImmutableTrait(traitKey, tokenId, value);\\n        }\\n\\n        /// Set the new trait value.\\n        _traits[tokenId][traitKey] = value;\\n    }\\n\\n    /**\\n     * @notice Set the value of a trait for a given token ID.\\n     * @param tokenId The token ID to set the trait value for\\n     * @param traitKey The trait key to set the value of\\n     * @param value The new trait value to set\\n     */\\n    function setTrait(uint256 tokenId, bytes32 traitKey, bytes32 value) external override {\\n        address tokenOwner = _ownerOf(tokenId);\\n        if (tokenOwner == msg.sender) {\\n            /// Minted token called by the owner\\n            if (_traitPermissions[traitKey].ownerCanUpdateValue==false) revert NonEditableTraitByTokenOwner();\\n            _setTrait(tokenId, traitKey, value);\\n            /// Emit the event noting the update.\\n            emit TraitUpdated(traitKey, tokenId, value);\\n        } else if (tokenOwner == address(0)) {\\n            /// check onlyOwner\\n            _checkOwner();\\n            _setTrait(tokenId, traitKey, value);\\n            if (tokenId == 0) {\\n                /// Only for Range, individual not minted don't emit event.\\n                emit TraitUpdatedRangeUniformValue(traitKey, 1, _actualCollectionSize(), value);\\n            }\\n        } else {\\n            revert OwnableUnauthorizedAccount(msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the value of a trait for a given token ID.\\n     * @param tokenId The token ID to get the trait value for\\n     * @param traitKey The trait key to get the value of\\n     */\\n    function getTraitValue(uint256 tokenId, bytes32 traitKey)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes32 traitValue)\\n    {\\n        /// Revert if the token doesn't exist.\\n        _requireTokenOwned(tokenId);\\n\\n        traitValue = _traits[tokenId][traitKey];\\n        if (traitValue == 0) {\\n            /// If the trait value is 0, check if there is a common value for all tokens for this trait.\\n            traitValue = _traits[0][traitKey];\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the values of traits for a given token ID.\\n     * @param tokenId The token ID to get the trait values for\\n     * @param traitKeys The trait keys to get the values of\\n     */\\n    function getTraitValues(uint256 tokenId, bytes32[] calldata traitKeys)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes32[] memory traitValues)\\n    {\\n        /// Set the length of the traitValues return array.\\n        uint256 length = traitKeys.length;\\n        traitValues = new bytes32[](length);\\n\\n        /// Assign each trait value to the corresopnding key.\\n        for (uint256 i; i < length; i++) {\\n            bytes32 traitKey = traitKeys[i];\\n            traitValues[i] = getTraitValue(tokenId, traitKey);\\n        }        \\n    }\\n\\n    /**\\n     * @dev Sets the `user` and `expires` for `tokenId`.\\n     * The zero address indicates there is no user.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function setUser(\\n        uint256 tokenId,\\n        address user,\\n        uint64 expires\\n    ) public virtual override {\\n        /// Require the caller to be either the token owner or an approved operator.\\n        address tokenOwner = _ownerOf(tokenId);\\n        _checkAuthorized(tokenOwner, msg.sender, tokenId);\\n\\n        _packedUserInfo[tokenId] = (uint256(expires) << _BITPOS_RENTAL_EXPIRES) | uint256(uint160(user));\\n\\n        emit UpdateUser(tokenId, user, expires);\\n    }\\n\\n    /**\\n     * @dev Returns the user address for `tokenId`.\\n     * The zero address indicates that there is no user or if the user is expired.\\n     */\\n    function userOf(uint256 tokenId) public view virtual override returns (address) {\\n        uint256 packed = _packedUserInfo[tokenId];\\n        assembly {\\n            /// Branchless `packed *= (block.timestamp <= expires ? 1 : 0)`.\\n            /// If the `block.timestamp == expires`, the `lt` clause will be true\\n            /// if there is a non-zero user address in the lower 160 bits of `packed`.\\n            packed := mul(\\n                packed,\\n                /// `block.timestamp <= expires ? 1 : 0`.\\n                lt(shl(_BITPOS_RENTAL_EXPIRES, timestamp()), packed)\\n            )\\n        }\\n        return address(uint160(packed));\\n    }\\n\\n    /**\\n     * @dev Returns the user's expires of `tokenId`.\\n     */\\n    function userExpires(uint256 tokenId) public view virtual override returns (uint256) {\\n        return _packedUserInfo[tokenId] >> _BITPOS_RENTAL_EXPIRES;\\n    }\\n\\n    fallback() external payable\\n    {\\n        address dynamicNFTAddress;\\n        if (msg.sender == address(this) || bytes4(msg.data) == 0xc20768ab) {\\n\\n            dynamicNFTAddress = address(uint160(_mintPrice));\\n        } else if (_isDynamicNFT) {\\n            dynamicNFTAddress = address(_dynamicNFT);\\n        }\\n\\n        assembly {\\n            /// Copy msg.data. We take full control of memory in this inline assembly\\n            /// block because it will not return to Solidity code. We overwrite the\\n            /// Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            /// Call the implementation.\\n            /// out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(\\n                gas(),\\n                dynamicNFTAddress,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n\\n            /// Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            /// delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}    \\n\\n}\"\r\n    },\r\n    \"contracts/important/README.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\n/// @title NFTs2Me.com Smart Contracts README\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\ninterface Readme {\\n    function n2mVersion() external pure returns (uint256);\\n }\\n\"\r\n    },\r\n    \"contracts/interfaces/DynamicNFT.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\ninterface DynamicNFT {\\n    function dynamicTokenURI(uint256 tokenId) external view returns (string memory);\\n    function tokenUpdate(address from, address to, uint256 tokenId) external payable;\\n    function tokenBulkUpdate(address from, address to, uint256 startTokenId, uint256 quantity) external payable;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/DynamicPrice.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\ninterface DynamicPrice {\\n    function initMintPrice(bytes calldata initData) external payable;\\n    function mintPrice(address minter, uint256 amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC4907.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity ^0.8.25;\\n\\ninterface IERC4907 {\\n    /// Logged when the user of a token assigns a new user or updates expires\\n    /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed\\n    /// The zero address for user indicates that there is no user address\\n    event UpdateUser(uint256 indexed tokenId, address indexed user, uint64 expires);\\n\\n    /// @notice set the user and expires of a NFT\\n    /// @dev The zero address indicates there is no user\\n    /// Throws if `tokenId` is not valid NFT\\n    /// @param user  The new user of the NFT\\n    /// @param expires  UNIX timestamp, The new user could use the NFT before expires\\n    function setUser(uint256 tokenId, address user, uint64 expires) external ;\\n\\n    /// @notice Get the user address of an NFT\\n    /// @dev The zero address indicates that there is no user or the user is expired\\n    /// @param tokenId The NFT to get the user address for\\n    /// @return The user address for this NFT\\n    function userOf(uint256 tokenId) external view returns(address);\\n\\n    /// @notice Get the user expires of an NFT\\n    /// @dev The zero value indicates that there is no user\\n    /// @param tokenId The NFT to get the user expires for\\n    /// @return The user expires for this NFT\\n    function userExpires(uint256 tokenId) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC5192.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity ^0.8.25;\\n\\ninterface IERC5192 {\\n  /// @notice Emitted when the locking status is changed to locked.\\n  /// @dev If a token is minted and the status is locked, this event should be emitted.\\n  /// @param tokenId The identifier for a token.\\n  event Locked(uint256 tokenId);\\n\\n  /// @notice Emitted when the locking status is changed to unlocked.\\n  /// @dev If a token is minted and the status is unlocked, this event should be emitted.\\n  /// @param tokenId The identifier for a token.\\n  event Unlocked(uint256 tokenId);\\n\\n  /// @notice Returns the locking status of an Soulbound Token\\n  /// @dev SBTs assigned to zero address are considered invalid, and queries\\n  /// about them do throw.\\n  /// @param tokenId The identifier for an SBT.\\n  function locked(uint256 tokenId) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC7496.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.25;\\n\\ninterface IERC7496 {\\n    /// Events\\n    event TraitUpdated(bytes32 indexed traitKey, uint256 tokenId, bytes32 traitValue);\\n    event TraitUpdatedRange(bytes32 indexed traitKey, uint256 fromTokenId, uint256 toTokenId);\\n    event TraitUpdatedRangeUniformValue(\\n        bytes32 indexed traitKey, uint256 fromTokenId, uint256 toTokenId, bytes32 traitValue\\n    );\\n    event TraitUpdatedList(bytes32 indexed traitKey, uint256[] tokenIds);\\n    event TraitUpdatedListUniformValue(bytes32 indexed traitKey, uint256[] tokenIds, bytes32 traitValue);\\n    event TraitMetadataURIUpdated();\\n\\n    /// Getters\\n    function getTraitValue(uint256 tokenId, bytes32 traitKey) external view returns (bytes32 traitValue);\\n    function getTraitValues(uint256 tokenId, bytes32[] calldata traitKeys)\\n        external\\n        view\\n        returns (bytes32[] memory traitValues);\\n    function getTraitMetadataURI() external view returns (string memory uri);\\n\\n    /// Setters\\n    function setTrait(uint256 tokenId, bytes32 traitKey, bytes32 traitValue) external;\\n\\n    /// Errors\\n    error TraitValueUnchanged();\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC7572.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.25;\\n\\ninterface IERC7572 {\\n  function contractURI() external view returns (string memory);\\n\\n  event ContractURIUpdated();\\n}\"\r\n    },\r\n    \"contracts/interfaces/IN2MCommon.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport {IERC2981} from \\\"openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport {IERC4907} from \\\"./IERC4907.sol\\\";\\nimport {IERC5192} from \\\"./IERC5192.sol\\\";\\nimport {IERC7496} from \\\"./IERC7496.sol\\\";\\nimport {IERC7572} from \\\"./IERC7572.sol\\\";\\nimport {IN2MCommonStorage} from \\\"./IN2MCommonStorage.sol\\\";\\n\\ninterface IN2MCommon is IN2MCommonStorage, IERC2981, IERC4907, IERC5192, IERC7496, IERC7572 {\\n    /// @notice This event is emitted when a token is minted using an affiliate\\n    /// @param affiliate The affiliate address\\n    event AffiliateSell(address indexed affiliate);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\\n\\n    event ImmutableTrait(bytes32 indexed traitKey, uint256 indexed tokenId, bytes32 value);\\n\\n    /// @notice Error thrown when input variable differ in length\\n    error InvalidInputSizesDontMatch();\\n\\n    /// @notice Error thrown when trying to mint a token with a given invalid id\\n    error InvalidTokenId();\\n\\n    /// @notice Error thrown when the input amount is not valid\\n    error InvalidAmount();\\n\\n    /// @notice Error thrown when trying to mint a sold out collection or the amount to mint exceeds the remaining supply\\n    error CollectionSoldOut();\\n\\n    /// @notice Error thrown when trying to presale/whitelist mint and the collection current phase is `closed`\\n    error PresaleNotOpen();\\n\\n    /// @notice Error thrown when trying to mint and the collection current phase is not `open`\\n    error PublicSaleNotOpen();\\n\\n    /// @notice Error thrown when trying to mint but the sale has already finished\\n    error SaleFinished();\\n\\n    /// @notice Error thrown when trying to mint more than the allowance to mint\\n    error NotEnoughAmountToMint();\\n\\n    /// @notice Error thrown when the sent amount is not valid\\n    error InvalidMintFee();\\n\\n    /// @notice Invalid input. Total supply must be greater than zero\\n    error InvadlidCollectionSize();\\n\\n    /// @notice Can't transfer a Soulbound Token (SBT)\\n    error NonTransferrableSoulboundNFT();\\n\\n    /// @notice The input revenue percentages are not valid\\n    error InvalidRevenuePercentage();\\n\\n    /// @notice The amount of revenue addresses is too high\\n    error InvalidRevenueAddresses();\\n\\n    /// @notice Can't mint until specified drop date\\n    error WaitUntilDropDate();\\n\\n    /// @notice Trying to use mintPresale method in a collection with a minting type that doesn't support whitelist\\n    error PresaleInvalidMintingType();\\n\\n    /// @notice Metadata is already fixed. Can't change metadata once fixed\\n    error MetadataAlreadyFixed();\\n\\n    /// @notice Invalid collection minting type for the current minting function\\n    error InvalidMintingType();\\n\\n    /// @notice The address exceeded the max per address amount\\n    error MaxPerAddressExceeded();\\n\\n    /// @notice The given signature doesn't match the input values\\n    error SignatureMismatch();\\n\\n    /// @notice The given signature is not valid\\n    error InvalidSignature();\\n\\n    /// @notice Reentrancy Guard protection\\n    error ReentrancyGuard();\\n\\n    /// @notice New BaseURI can't be empty\\n    error NewBaseURICantBeEmpty();    \\n\\n    /// @notice Invalid percentage or discount values\\n    error InvalidPercentageOrDiscountValues();\\n\\n    /// @notice Can't lower current percentages\\n    error CantLowerCurrentPercentages();\\n\\n    /// @notice Invalid phase can't be set without giving a date, use the proper functions\\n    error InvalidPhaseWithoutDate();\\n\\n    /// @notice Payment address can't be changed if there is pending affiliate balance to withdraw.\\n    error PendingAffiliatesBalance();\\n\\n    /// @notice Operator not allowed\\n    error OperatorNotAllowed(address operator);\\n\\n    /// @notice Error indicating that the minter is not allowlisted\\n    error NotAllowlisted();\\n\\n    /// @notice The initialization has already been done\\n    error InvalidInitialization();\\n\\n    /// @notice Error indicating that the trait is not editable more than once\\n    error OnlyOnceTrait();\\n\\n    /// @notice Trait is not editable by the token owner\\n    error NonEditableTraitByTokenOwner();\\n\\n    /// @notice Error indicating that the caller is not the owner of the contract or an authorized account\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /// @notice Error indicating that the metadata cannot be frozen when setting a placeholder\\n    error PlacerholderCantFreezeMetadata();\\n\\n    /// @notice The caller must own the token or be an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @notice The token does not exist.\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /// @notice Cannot query the balance for the zero address.\\n    error BalanceQueryForZeroAddress();\\n\\n    /// @notice Cannot mint to the zero address.\\n    error MintToZeroAddress();\\n\\n    /// @notice The quantity of tokens minted must be more than zero.\\n    error MintZeroQuantity();\\n\\n    /// @notice The token does not exist.\\n    error OwnerQueryForNonexistentToken();\\n\\n    /// @notice The caller must own the token or be an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @notice The token must be owned by `from`.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @notice Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @notice Cannot transfer to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @notice The caller must own the token or be an approved operator.\\n    error TransferFromFailed();\\n\\n    /// @notice Initializer for the contract\\n    function initialize008joDSK\\n    (\\n        string calldata name,\\n        string calldata symbol,\\n        uint256 mintPrice,\\n        bytes32 baseURIorPlaceholderCIDHash,\\n        bytes32 packedData,\\n        bytes calldata extraCollectionInformation\\n    ) external payable;\\n\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    /// @return the collection symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.\\n    /// @param toWihtExtra To address packed with extra information.\\n    /// @param customFee Zero is fee is different from `mintingPrice`.\\n    /// @param signature Valid `signature` for the presale/whitelist.\\n    function mintWhitelist(\\n        bytes32 toWihtExtra,\\n        uint256 customFee,\\n        bytes calldata signature,\\n        uint256[] calldata tokenIds) payable external;\\n\\n    /// @notice returns the merkle root of the current whitelist\\n    function merkleRoot() external view returns (bytes32);\\n\\n    /// @notice sets the merkle root for the current whitelist\\n    function setMerkleRoot(bytes32 merkleRoot_) external payable;\\n\\n    /// @notice returns 'true' if the given address is allowlisted\\n    function allowListed(address _wallet, bytes32[] calldata _proof) external view returns (bool);\\n\\n    /// @notice mint `amount` of NFTs if the msg.sender is allowlisted\\n    function mintAllowlist(uint256 amount, bytes32[] calldata _proof) external payable;\\n\\n    /// @notice Returns the minting fee of `amount` NFT.\\n    /// @return Mint price for `amount` NFTs in native coin or ERC-20.\\n    function mintFee(uint256 amount) external view returns (uint256);\\n\\n    /// @notice Returns the platform fee of one NFT.\\n    /// @return Platform for one NFT in native coin.\\n    function protocolFee() external view returns (uint256);\\n\\n    /// @notice Returns the current total supply.\\n    /// @return Current total supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of burned tokens.\\n    /// @return Burned tokens.\\n    function burnedTokens() external view returns (uint256);\\n\\n    /// @notice Max amount of NFTs to be hold per address.\\n    /// @return Max per address allowed.\\n    function maxPerAddress() external view returns (uint256);\\n\\n    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.\\n    function isMetadataFixed() external view returns (bool);\\n\\n    function setBaseURI(string memory baseURIString, bytes32 baseURICIDHash, bool isPlaceholder, bool freezeMetadata) external payable;\\n    function changeMintFee(uint256 newMintFee, bool isDynamic) external payable;\\n    function contractURI() external view returns (string calldata);\\n    function setContractURI(bytes32 newContractURIMetadataCIDHash) external payable;\\n    function setAffiliatesPercentageAndDiscount(uint16 userDiscount, uint16 affiliatePercentage, address affiliateAddress) external;\\n    function affiliateWithdraw(address affiliate) external payable;\\n    function withdrawERC20(address erc20Address) external payable;\\n    function withdraw() external payable;\\n    function setPhase(SalePhase newPhase) external payable;\\n    function setDropAndEndDate(uint256 dropDateTimestamp, uint256 endDateTimestamp) external payable;\\n    function setMaxPerAddress(uint16 newMaxPerAddress) external payable;\\n    function isOperatorFilterRegistryEnabled() external view returns (bool);\\n    function whitelistOperators(address[] calldata operators) external payable;\\n    function disableOperatorFilterRegistry() external payable;\\n    function reserveTokens(uint16 amount) external payable;\\n    function unreserveTokens(uint16 amount) external payable;\\n    function reservedTokens() external view returns (uint256);\\n    function collectionSize() external view returns (uint256);\\n    function affiliatesInfo(address affiliate) external view returns (bool enabled, uint16 affiliatePercentage, uint16 userDiscount);\\n    function changeRoyaltyFee(uint16 newFee) external payable;\\n    function royaltyFee() external view returns (uint256);\\n    function changeERC20PaymentAddress(address newErc20PaymentAddress) external payable;\\n    function currentPhase() external view returns (SalePhase);\\n    function mintingType() external view returns (MintingType);\\n    function saleDates() external view returns (uint256 dropDateTimestamp, uint256 endDateTimestamp);\\n    function isOpen() external view returns (bool);\\n    function ownershipTransferred(address from, address to) external payable;\\n    function ownerMaxRevenue() external view returns (uint256);\\n    function removeProtocolFee(bytes calldata signature, uint256 fee, address feeReceiver) external payable;\\n    function setTraitsPermissions(bytes32[] calldata ownerCanUpdateTraitKeys, bytes32[] calldata notOnlyOnceTraitKeys) external payable;\\n    function setTraitMetadataURI(string calldata uri) external payable;\\n    function withdrawnAmount() external view returns (uint256);\\n    function pendingTotalAffiliatesBalance() external view returns (uint256);\\n    function erc20PaymentAddress() external view returns (address);\\n    function owner() external view returns (address collectionOwner);\\n    function transferOwnership(address to) external payable;\\n    function reduceCollectionSize(uint32 newCollectionSize) external payable;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IN2MCommonStorage.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport \\\"../important/README.sol\\\";\\n\\ninterface IN2MCommonStorage is Readme {\\n    struct RevenueAddress {\\n        address to;\\n        uint16 percentage;\\n    }\\n\\n    struct AffiliateInformation {\\n        bool enabled;\\n        uint16 affiliatePercentage;\\n        uint16 userDiscount;\\n    }\\n\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    enum SalePhase { \\n        PUBLIC,\\n        CLOSED,\\n        PRESALE,\\n        DROP_DATE,\\n        DROP_AND_END_DATE,\\n        END_DATE\\n    }\\n\\n    enum MintingType { \\n        SEQUENTIAL, \\n        RANDOM,\\n        SPECIFY, \\n        CUSTOM_URI,\\n        SEQUENTIAL_EDITIONS\\n    }\\n\\n    enum OperatorFilterStatus { \\n        DISABLED, \\n        ENABLED_ONLY_WHITELISTED\\n    }\\n\\n    function withdrawnERC20Amount(address erc20) external view returns (uint256);\\n    function pendingAffiliateBalance(address affiliate) external view returns (uint256);\\n    function whitelistedOperators(address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IN2MCrossFactory.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\ninterface IN2MCrossFactory {\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n    function getIPFSURI(bytes32 cidHash) external pure returns (string memory);\\n    function transferCollectionOwnership(address to) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IN2MNonSequential.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport \\\"./IN2MCommon.sol\\\";\\n\\ninterface IN2MNonSequential is IN2MCommon {\\n    /// @notice One step on-chain random minting. Mints `amount` NFTs to `to` address. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// Note: it is not real on-chain random minting, as the result may be influenced by miners or other techniques, so not real 100% random.\\n    /// @param to The address of the NFTs receiver\\n    /// @param amount The number of NFTs to mint    \\n    function mintRandomTo(address to, uint256 amount) external payable;    \\n\\n    /// @notice One step on-chain random minting. Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// Note: it is not real on-chain random minting, as the result may be influenced by miners or other techniques, so not real 100% random.\\n    /// @param to The address of the NFTs receiver\\n    /// @param amount The number of NFTs to mint    \\n    /// @param affiliate The affiliate address\\n    function mintRandomTo(address to, uint256 amount, address affiliate) external payable;\\n\\n    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @param to The address of the NFTs receiver\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    function mintSpecifyTo(address to, uint256[] calldata tokenIds) external payable; \\n\\n    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @param to The address of the NFTs receiver\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    /// @param affiliate The affiliate address\\n    function mintSpecifyTo(address to, uint256[] calldata tokenIds, address affiliate) external payable; \\n\\n    /// @notice Mints one NFT to `to` address. Requires `minting type` to be `customURI`.\\n    /// @param to The address of the NFTs receiver\\n    /// @param customURICIDHash The CID of the given token.\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function mintCustomURITo(address to, bytes32 customURICIDHash, bool soulbound) external payable;\\n\\n    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with random tokenIds. Requires `minting type` to be `random`.\\n    /// @param to The addresses of the NFTs receivers\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function airdropRandom(address[] calldata to, bool soulbound) external payable;\\n\\n    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with specified tokenIds. Requires `minting type` to be `specify`.\\n    /// @param to The addresses of the NFTs receivers\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function airdropSpecify(address[] calldata to, uint256[] calldata tokenIds, bool soulbound) external payable;\\n\\n    function airdropCustomURI(address[] calldata to, bytes32[] calldata customURICIDHash, bool soulbound) external payable;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/N2MERC721NS/N2MERC721NS.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport {ERC721} from \\\"openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport {IERC7496, IERC5192, Common, IN2MCommon, DynamicNFT, NSMinting} from \\\"./NSMinting.sol\\\";\\nimport {IERC165, IERC2981} from \\\"openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport {Address} from \\\"openzeppelin/contracts/utils/Address.sol\\\";\\nimport {LibString} from \\\"solady/utils/LibString.sol\\\";\\nimport {Base64} from \\\"solady/utils/Base64.sol\\\";\\nimport {IERC4907} from \\\"../interfaces/IN2MCommon.sol\\\";\\n\\n/// @title NFTs2Me.com Smart Contracts for ERC-721.\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\ncontract N2MERC721NS is NSMinting, ERC721 {\\n    constructor(address payable factoryAddress, uint256 protocolFee) Common(factoryAddress, protocolFee) ERC721(\\\"\\\",\\\"\\\") payable {}\\n\\n    function _requireTokenOwned(uint256 tokenId) internal view virtual override {\\n        _requireOwned(tokenId);\\n    }\\n\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view override(ERC721, Common) {\\n        super._checkAuthorized(owner, spender, tokenId);\\n    }\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override(ERC721, Common)\\n        returns (string memory)\\n    {\\n        _requireTokenOwned(tokenId);\\n\\n        if (_isDynamicNFT) {\\n            return DynamicNFT(address(this)).dynamicTokenURI(tokenId);\\n        }\\n        if (_mintingType == MintingType.CUSTOM_URI) {\\n            return _getIPFSURI(_customURICIDHashes[tokenId]);\\n        }\\n\\n        string memory stringTokenId = LibString.toString(tokenId);\\n        string memory baseURI;\\n        if (_baseURICIDHash != 0) {\\n            baseURI = _getIPFSURI(_baseURICIDHash);\\n        } else {\\n            baseURI = _baseURIString;\\n        }\\n\\n        if (_hasPlaceholder) {\\n            return string(\\n                abi.encodePacked(\\n                    'data:application/json;base64,',\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"Unrevealed Token #',\\n                            stringTokenId,\\n                            '\\\",\\\"image\\\":\\\"',\\n                            baseURI,\\n                            '\\\"}'\\n                        )\\n                    )\\n                )\\n            );                \\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    baseURI,\\n                    \\\"/\\\",\\n                    stringTokenId,\\n                    \\\".json\\\"\\n                )\\n            );\\n    }\\n\\n    function _ownerOf(uint256 tokenId)\\n        internal\\n        view\\n        override(ERC721, Common)\\n        returns (address)\\n    {\\n        return ERC721._ownerOf(tokenId);\\n    }\\n\\n    function __mint(address to, uint256 tokenId)\\n        internal\\n        override\\n    {\\n        _mint(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name()\\n        public\\n        view\\n        override(ERC721, IN2MCommon)\\n        returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    function _update(\\n        address to, \\n        uint256 tokenId, \\n        address auth\\n    ) internal virtual override(ERC721) returns (address previousOwner) {\\n        previousOwner = ERC721._update(to, tokenId, auth);\\n\\n        if (\\n            previousOwner != address(0) &&\\n            (_soulbound[tokenId] || _soulboundCollection)\\n        ) revert NonTransferrableSoulboundNFT();\\n\\n        if (to == address(0)) {\\n            /// Burn\\n            unchecked {\\n                ++_burnedTokens;\\n            }\\n        } else {\\n            /// Mint or regular transfer\\n            /// Check MaxPerAddress\\n            if (_maxPerAddress != 0) {\\n                if (balanceOf(to) > _maxPerAddress) revert MaxPerAddressExceeded();\\n            }\\n        }\\n\\n        if (_isDynamicNFT) {\\n            Address.functionDelegateCall(address(_dynamicNFT), abi.encodeWithSelector(DynamicNFT.tokenUpdate.selector, previousOwner, to, tokenId));\\n        }\\n    }\\n\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceId` and `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        override(ERC721, IERC165)\\n        returns (bool)\\n    {\\n        if (interfaceId == IERC165_INTERFACE_ID) return true;         \\n        if (interfaceId == IERC173_INTERFACE_ID) return true;         \\n        if (interfaceId == IERC721_INTERFACE_ID) return true;         \\n        if (interfaceId == IERC721METADATA_INTERFACE_ID) return true; \\n        if (interfaceId == IERC2981_INTERFACE_ID) return true;        \\n        if (interfaceId == IERC4907_INTERFACE_ID) return true;        \\n        if (interfaceId == IERC7496_INTERFACE_ID) return true;        \\n        return (interfaceId == IERC5192_INTERFACE_ID);                \\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol()\\n        public\\n        view\\n        virtual\\n        override(IN2MCommon, ERC721)\\n        returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    function burn(uint256 tokenId) external payable {\\n        _update(address(0), tokenId, msg.sender);\\n    }\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param operator Address to add to the set of authorized operators\\n    /// @param approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address operator, bool approved) public override(ERC721) onlyAllowedOperatorApproval(operator) {\\n        ERC721.setApprovalForAll(operator, approved);\\n    }\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param operator The new approved NFT controller\\n    /// @param tokenId The NFT to approve\\n    function approve(address operator, uint256 tokenId) public override(ERC721) onlyAllowedOperatorApproval(operator) {\\n        ERC721.approve(operator, tokenId);\\n    }\\n\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view override(ERC721) returns (bool) {\\n        _isOperatorAllowed(spender);\\n        return ERC721._isAuthorized(owner, spender, tokenId);\\n    }\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param owner The address that owns the NFTs\\n    /// @param operator The address that acts on behalf of the owner\\n    /// @return True if `operator` is an approved operator for `owner`, false otherwise\\n    function isApprovedForAll(address owner, address operator)\\n    public\\n    view\\n    virtual\\n    override(ERC721)\\n    returns (bool)\\n    {\\n\\n        if (operator == OPENSEA_CONDUIT && _operatorFilterStatus == OperatorFilterStatus.DISABLED) return true;\\n        if (operator == N2M_CONDUIT) return true;\\n\\n        return ERC721.isApprovedForAll(owner, operator);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/N2MERC721NS/NSMinting.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport {IERC7496, IERC5192, ECDSA, Common, N2MCommonStorage, IN2MCommon, DynamicNFT, DynamicPrice} from \\\"../Common.sol\\\";\\nimport {IN2MCrossFactory} from \\\"../interfaces/IN2MCrossFactory.sol\\\";\\nimport {IN2MNonSequential} from \\\"../interfaces/IN2MNonSequential.sol\\\";\\n\\n/// @title NFTs2Me.com Smart Contracts\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\nabstract contract NSMinting is Common, IN2MNonSequential {\\n    function initialize008joDSK(\\n        string calldata name_,\\n        string calldata symbol_,\\n        uint256 mintPrice_,\\n        bytes32 baseURICIDHash,\\n        bytes32 packedData,\\n        bytes calldata extraCollectionInformation\\n    ) public payable override initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        if (mintPrice_ > 0) _mintPrice = mintPrice_;\\n\\n        _availableCollectionSize = uint32(uint256(packedData) >> _BITPOS_INIT_COLLECTION_SIZE);\\n\\n        _royaltyFee = uint16(uint256(packedData) >> _BITPOS_INIT_ROYALTY_FEE);\\n\\n        _mintingType = MintingType(uint8(uint256(packedData) >> _BITPOS_INIT_MINTING_TYPE));\\n\\n        if (baseURICIDHash != bytes32(0)) _baseURICIDHash = baseURICIDHash;\\n        uint256 extraCollectionInformationLength = extraCollectionInformation.length;\\n        if (extraCollectionInformationLength > 0) {\\n\\n            uint8 bitmap = uint8(uint256(packedData) >> _BITPOS_INIT_BITMAP);\\n\\n            bool isSoulbound = (bitmap & BIT1MASK) != 0;\\n            bool hasPlaceholder = (bitmap & BIT2MASK) != 0;\\n            bool hasDynamicPrice = (bitmap & BIT3MASK) != 0;\\n            bool hasEditableMetadata = bitmap & BIT4MASK != 0;\\n            uint16 reservedTokens_ = uint16(uint256(packedData) >> _BITPOS_INIT_RESERVED_TOKENS);\\n\\n            if (isSoulbound) {\\n                _soulboundCollection = true;\\n            }\\n\\n            if (hasPlaceholder) {\\n                _hasPlaceholder = true;\\n                _isMetadataEditable = true;\\n            }\\n\\n            if (hasEditableMetadata) {\\n                _isMetadataEditable = true;\\n            }\\n\\n            if (hasDynamicPrice) {\\n                _hasDynamicPrice = true;\\n            }\\n\\n            if (reservedTokens_ > 0) {\\n\\n                _reservedTokens = reservedTokens_;\\n                if (_actualCollectionSize() > type(uint32).max) _revert(InvadlidCollectionSize.selector);\\n            }\\n\\n            if (extraCollectionInformationLength > 1) {\\n\\n                bool hasStrings = bitmap & BIT5MASK != 0;\\n                bool hasDynamicNFTAddress = bitmap & BIT6MASK != 0;\\n                bool hasERC20PaymentAddress = bitmap & BIT7MASK != 0;\\n                bytes32[] memory bArray;\\n\\n                if (hasStrings) {\\n\\n                    string memory baseURIString_;\\n                    string memory collectionDescription_;\\n                    (bArray, baseURIString_, collectionDescription_) = abi.decode(extraCollectionInformation, (bytes32[], string, string));\\n                    if (bytes(baseURIString_).length > 0) _baseURIString = baseURIString_;\\n                    if (bytes(collectionDescription_).length > 0) _collectionDescription = collectionDescription_;\\n                } else {\\n                    (bArray) = abi.decode(extraCollectionInformation, (bytes32[]));\\n                }\\n\\n                uint256 index;\\n                SalePhase initPhase = SalePhase(uint8(uint256(packedData >> _BITPOS_INIT_PHASE)));\\n                if (initPhase > SalePhase.PUBLIC) {\\n                    _currentPhase = initPhase;\\n\\n                    if (initPhase > SalePhase.PRESALE) {\\n                        _dropDateTimestamp = uint256(bArray[index++]);\\n                        _endDateTimestamp = uint256(bArray[index++]);\\n                    }\\n                }\\n\\n                if (hasDynamicNFTAddress) {\\n                    _isDynamicNFT = true;\\n                    _dynamicNFT = DynamicNFT(address(uint160(uint256(bArray[index++]))));\\n                }\\n\\n                if (hasERC20PaymentAddress) {\\n                    _isERC20Payment = true;\\n                    _erc20PaymentAddress = address(uint160(uint256(bArray[index++])));\\n                }\\n\\n                uint256 revenuePercentageTotal;\\n                uint256 bArrayLength = bArray.length;\\n                uint256 amountOfRevenueAddresses = bArrayLength - index;\\n                if (amountOfRevenueAddresses > MAX_REVENUE_ADDRESSES_LENGTH) revert InvalidRevenueAddresses();\\n                for (; index < bArrayLength; index++) {\\n                    uint256 revenueInfo = uint256(bArray[index]);\\n                    uint16 percentage = uint16(revenueInfo >> 160);\\n                    revenuePercentageTotal += percentage;\\n                    _revenueInfo.push(RevenueAddress(address(uint160(revenueInfo)), percentage));\\n                }\\n                if (revenuePercentageTotal > 100_00) revert InvalidRevenuePercentage();\\n            }\\n        }\\n\\n        emit OwnershipTransferred(address(0), address(uint160(uint256(packedData))));\\n    }\\n\\n    /// @notice One tx random minting. Mints `amount` NFTs tickets to `to` address. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @param to The address of the NFTs receiver\\n    /// @param amount The number of NFTs to mint \\n    function mintRandomTo(address to, uint256 amount) external payable override {\\n        _requireFee(amount);\\n        _mintOneStepRandomWithChecks(to, amount);\\n    }\\n\\n    /// @notice One tx random minting. Mints `amount` NFTs tickets to `to` address with a given `affiliate`. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @dev Not real random to be able to mint in one tx.\\n    /// @param to The address of the NFTs receiver\\n    /// @param amount The number of NFTs to mint    \\n    /// @param affiliate The affiliate address\\n    function mintRandomTo(address to, uint256 amount, address affiliate) external payable override {\\n        _requirePaymentWithAffiliates(amount, affiliate);\\n        _mintOneStepRandomWithChecks(to, amount);\\n    }\\n\\n    /// @dev Not real random to be able to mint in one tx. Not all EVMs support prevrandao.\\n    function _pseudoRandomSeed() private view returns (uint256 seed) {\\n        /// No issues with overflow as we are looking for a pseudo-random seed, not exact math.\\n        unchecked {\\n            return block.prevrandao + block.timestamp + uint256(blockhash(block.number - 1)) + _currentIndex;\\n        }\\n    }\\n\\n    function _mintOneStepRandomWithChecks(address to, uint256 amount) private {\\n        _checkPhase();\\n        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();\\n        if (uint256(_currentIndex) + amount > uint256(_availableCollectionSize)) revert CollectionSoldOut();\\n\\n        unchecked {\\n            _currentIndex += uint32(amount);\\n        }\\n\\n        /// Note: not real random to be able to mint in one tx.\\n        _mintRandom(to, amount, _pseudoRandomSeed(), false);\\n    }\\n\\n    function _mintRandom(address to, uint256 amount, uint256 seed, bool soulbound) private {\\n        while (amount > 0) {\\n            uint256 tokenId = _randomTokenId(seed, amount);\\n            __mint(to, tokenId);\\n            if (soulbound) _setSoulbound(tokenId);\\n            unchecked {\\n                --amount;\\n            }\\n        }\\n    }\\n\\n    function _randomTokenId(uint256 seed, uint256 extraModifier) private view returns (uint256 tokenId) {\\n\\n        tokenId = (uint256(keccak256(abi.encodePacked(seed, extraModifier))) % _availableCollectionSize) + 1;\\n\\n        while (_ownerOf(tokenId) != address(0)) {\\n            tokenId = (tokenId % _availableCollectionSize) + 1;\\n        }\\n    }\\n\\n    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @param to The address of the NFTs receiver\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    function mintSpecifyTo(address to, uint256[] calldata tokenIds)\\n        external\\n        payable\\n        override\\n    {\\n        _requireFee(tokenIds.length);\\n        _mintSpecifyWithChecks(to, tokenIds);\\n    }\\n\\n    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).\\n    /// @param to The address of the NFTs receiver\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    /// @param affiliate The affiliate address\\n    function mintSpecifyTo(address to, uint256[] calldata tokenIds, address affiliate) \\n        external\\n        payable\\n        override\\n    {\\n        _requirePaymentWithAffiliates(tokenIds.length, affiliate);\\n        _mintSpecifyWithChecks(to, tokenIds);\\n    }\\n\\n    function _mintSpecifyWithChecks(address to, uint256[] calldata tokenIds)\\n        private\\n    {\\n        _checkPhase();\\n        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();\\n\\n        if (_currentIndex + (tokenIds.length) > _availableCollectionSize) revert CollectionSoldOut();\\n\\n        _mintSpecify(to, tokenIds);\\n    }\\n\\n    function _mintSpecify(address to, uint256[] calldata tokenIds, bool soulbound) private {\\n        _mintSpecify(to, tokenIds);\\n        if (soulbound) {\\n            for (uint256 i; i < tokenIds.length; i++) {\\n                _setSoulbound(tokenIds[i]);\\n            }\\n        }\\n    }\\n\\n    function _mintSpecify(address to, uint256[] calldata tokenIds) internal virtual\\n    {\\n\\n        uint256 inputLength = tokenIds.length;\\n        _currentIndex += uint32(inputLength);\\n        for (uint256 i; i < inputLength; i++) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            if (tokenId == 0 || tokenId > _availableCollectionSize) revert InvalidTokenId();\\n            __mint(to, tokenId);\\n        }\\n    }\\n\\n    /// @notice Mints one NFT to `to` address. Requires `minting type` to be `customURI`.\\n    /// @param to The address of the NFTs receiver\\n    /// @param customURICIDHash The CID of the given token.\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function mintCustomURITo(address to, bytes32 customURICIDHash, bool soulbound)\\n        external\\n        payable\\n        override\\n    {\\n        _requireFeesPayment(_creatorMintFee(), _protocolFee());\\n        _checkPhase();\\n        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();\\n        _mintCustomURIInternal(to, customURICIDHash, soulbound);\\n    }\\n\\n    function _mintCustomURIInternal(address to, bytes32 customURICIDHash, bool soulbound) private {\\n        unchecked {\\n            if ((++_currentIndex) > _availableCollectionSize) revert CollectionSoldOut();\\n        }\\n        __mint(to, _currentIndex);\\n\\n        if (soulbound) _setSoulbound(_currentIndex);\\n        _customURICIDHashes[_currentIndex] = customURICIDHash;\\n    }\\n\\n    /// @notice Airdrop mints one NFT to `to` addresses. Requires `minting type` to be `customURI`.\\n    /// @param to The address of the NFTs receiver\\n    /// @param customURICIDHash The CIDs of the given token.\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function airdropCustomURI(address[] calldata to, bytes32[] calldata customURICIDHash, bool soulbound)\\n        external\\n        payable\\n        onlyOwner\\n        override\\n    {\\n        if (to.length != customURICIDHash.length) revert InvalidInputSizesDontMatch();\\n        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();\\n        for (uint256 i; i < to.length; i++) {\\n            _mintCustomURIInternal(to[i], customURICIDHash[i], soulbound);\\n        }\\n    }\\n\\n    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with random tokenIds. Requires `minting type` to be `random`.\\n    /// @param to The addresses of the NFTs receivers\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function airdropRandom(address[] calldata to, bool soulbound)\\n        external\\n        payable\\n        override\\n        onlyOwner\\n    {\\n        uint256 toLength = to.length;\\n        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();\\n\\n        if ((_currentIndex + toLength) > _availableCollectionSize) revert CollectionSoldOut();\\n\\n        unchecked {\\n            _currentIndex += uint32(toLength);\\n        }\\n\\n        uint256 seed = _pseudoRandomSeed();\\n        for (uint256 i; i < toLength; i++) {\\n            uint256 newTokenId = _randomTokenId(seed, i);\\n            __mint(to[i], newTokenId);\\n            if (soulbound) _setSoulbound(newTokenId);\\n        }\\n    }\\n\\n    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with specified tokenIds. Requires `minting type` to be `specify`.\\n    /// @param to The addresses of the NFTs receivers\\n    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.\\n    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.\\n    function airdropSpecify(\\n        address[] calldata to,\\n        uint256[] calldata tokenIds,\\n        bool soulbound\\n    ) external payable override onlyOwner {\\n        uint256 toLength = to.length;\\n        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();\\n\\n        if (_currentIndex + (tokenIds.length) > _availableCollectionSize) revert CollectionSoldOut();\\n        if (toLength != tokenIds.length) revert InvalidInputSizesDontMatch();\\n\\n        unchecked {\\n            _currentIndex += uint32(toLength);\\n        }\\n\\n        for (uint256 i; i < toLength; i++) {\\n\\n            if (tokenIds[i] == 0 || tokenIds[i] > _availableCollectionSize) revert InvalidTokenId();\\n            __mint(to[i], tokenIds[i]);\\n            if (soulbound) _setSoulbound(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.\\n    /// @param toWihtExtra To address packed with extra information.\\n    /// @param customFee Zero is fee is different from `mintingPrice`.\\n    /// @param signature Valid `signature` for the presale/whitelist.\\n    function mintWhitelist(\\n        bytes32 toWihtExtra,\\n        uint256 customFee,\\n        bytes calldata signature,\\n        uint256[] calldata tokenIds\\n    ) external payable override {\\n\\n        uint16 amount = uint16(uint256(toWihtExtra));\\n\\n        toWihtExtra = bytes32(toWihtExtra >> _BITPOS_PRESALE_ADDRESS);\\n        address to = address(uint160(uint256(toWihtExtra)));\\n        bool freeMinting = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_FREE_MINTING) != 0;\\n        bool soulbound = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_SOULBOUND) != 0;\\n        uint16 maxAmount = (uint16(uint256(toWihtExtra) >> _BITPOS_PRESALE_MAX_AMOUNT));\\n\\n        if (amount == 0) _revert(InvalidAmount.selector);\\n\\n        _usedAmountSignature[signature] += amount;\\n        if (_usedAmountSignature[signature] > maxAmount) revert NotEnoughAmountToMint();\\n\\n        if (_currentIndex + amount > _availableCollectionSize) revert CollectionSoldOut();\\n\\n        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();\\n\\n        address signer = ECDSA.recoverCalldata(\\n            ECDSA.toEthSignedMessageHash(\\n                keccak256(\\n                    abi.encodePacked(\\n                        this.mintWhitelist.selector,                           \\n                        address(this),                                         \\n                        block.chainid,                                         \\n                        toWihtExtra,\\n                        customFee\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n\\n        if (signer != N2M_SIGNER && signer != owner()) _revert(SignatureMismatch.selector);\\n\\n        if (freeMinting) {\\n\\n            customFee = 0;\\n        } else if (customFee == 0) {\\n            customFee = _creatorMintFee(amount);\\n        } else {\\n            customFee *= amount;\\n        }\\n        _requireFeesPayment(customFee, _protocolFee()*amount);\\n\\n        if (_mintingType == MintingType.RANDOM) {\\n            _currentIndex += uint32(amount);\\n            _mintRandom(to, amount, uint256(keccak256(signature)), soulbound);\\n        } else {\\n\\n            if (tokenIds.length != amount) revert InvalidInputSizesDontMatch();\\n            if (_mintingType == MintingType.CUSTOM_URI) {\\n                for (uint256 i; i<amount; i++) {\\n                    _mintCustomURIInternal(to, bytes32(tokenIds[i]), soulbound);\\n                }\\n            } else if (_mintingType == MintingType.SPECIFY) {\\n                _mintSpecify(to, tokenIds, soulbound);\\n            } else {\\n\\n                revert PresaleInvalidMintingType();\\n            }\\n        }\\n    }\\n\\n    function mintAllowlist(uint256 amount, bytes32[] calldata proof) external payable override {\\n\\n        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();\\n        if (_mintingType != MintingType.RANDOM) revert PresaleInvalidMintingType();\\n        if (!allowListed(msg.sender, proof)) revert NotAllowlisted();\\n        _requireFee(amount);\\n\\n        _currentIndex += uint32(amount);\\n        if (_actualSoldTokens() > _availableCollectionSize) revert CollectionSoldOut();\\n\\n        _mintRandom(msg.sender, amount, uint256(proof[0]), false);\\n    }\\n\\n    function reduceCollectionSize(uint32 newCollectionSize) external payable override onlyOwner {\\n        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();\\n        _reduceCollectionSize(newCollectionSize);\\n    }\\n\\n    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.\\n    function isMetadataFixed() public view override(Common, IN2MCommon) returns (bool) {\\n        return (_isMetadataEditable == false || _mintingType == MintingType.CUSTOM_URI);\\n    }\\n\\n    function mintingType() external view override(Common, IN2MCommon) returns (MintingType) {\\n        return _mintingType;\\n    }\\n\\n    function _actualSoldTokens() internal view override returns (uint32) {\\n        return _currentIndex;\\n    }\\n\\n    function _nextTokenId() internal view override returns (uint32) {\\n        return _actualSoldTokens() + 1;\\n    }\\n\\n    function __mint(address to, uint256 tokenId) internal virtual;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/N2MVersion.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\nimport \\\"./important/README.sol\\\";\\n\\n/// @title NFTs2Me.com Smart Contracts Version\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\nabstract contract N2MVersion is Readme {\\n    /// @notice Current version of the nfts2me.com contracts.\\n    function n2mVersion() virtual external pure returns (uint256) {\\n        return 2030;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Storage.sol\": {\r\n      \"content\": \"/** ---------------------------------------------------------------------------- //\\n *                                                                               //\\n *                Smart contract generated by https://nfts2me.com                //\\n *                                                                               //\\n *                                      .::.                                     //\\n *                                    ......                                     //\\n *                                ....        ::.                                //\\n *                             .:..           :: ...                             //\\n *                         ..:.               ::     ...                         //\\n *                       ::.      ..:--       ::.       ...                      //\\n *                      .:    ..:::::-==:     :::::..     :                      //\\n *                      .:    :::::::-====:   ::::::::    :                      //\\n *                      .:    :::::::-======. ::::::::    :                      //\\n *                      .:    :::::::-=======-::::::::    :                      //\\n *                      .:    :::::::-========-:::::::    :                      //\\n *                      .:    ::::::::========-:::::::    :                      //\\n *                      .:    :::::::. .======-:::::::    :                      //\\n *                      .:    :::::::.   :====-:::::::    :                      //\\n *                      .:     .:::::.     -==-:::::.     :                      //\\n *                       .:.       .:.      .--:..      ...                      //\\n *                          .:.     :.               ...                         //\\n *                             .... :.           ....                            //\\n *                                 .:.        .:.                                //\\n *                                      .::::.                                   //\\n *                                      :--.                                     //\\n *                                                                               //\\n *                                                                               //\\n *   NFTs2Me. Make an NFT Collection.                                            //\\n *   With ZERO Coding Skills.                                                    //\\n *                                                                               //\\n *   NFTs2Me is not associated or affiliated with this project.                  //\\n *   NFTs2Me is not liable for any bugs or issues associated with this contract. //\\n *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //\\n *   More info at: https://docs.nfts2me.com/                                     //\\n * ----------------------------------------------------------------------------- */\\n\\n/// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.25;\\n\\n/// Utils\\nimport {IN2MCommonStorage} from \\\"./interfaces/IN2MCommonStorage.sol\\\";\\nimport {DynamicNFT} from './interfaces/DynamicNFT.sol';\\nimport {N2MVersion} from \\\"./N2MVersion.sol\\\";\\n\\n/// @title NFTs2Me.com Smart Contracts\\n/// @author The NFTs2Me Team\\n/// @notice Read our terms of service\\n/// @custom:security-contact security@nfts2me.com\\n/// @custom:terms-of-service https://nfts2me.com/terms-of-service/\\n/// @custom:website https://nfts2me.com/\\nabstract contract N2MCommonStorage is IN2MCommonStorage, N2MVersion {\\n    /// CONSTANTS\\n    uint8 internal constant BIT1MASK = 0x01;\\n    uint8 internal constant BIT2MASK = 0x02;\\n    uint8 internal constant BIT3MASK = 0x04;\\n    uint8 internal constant BIT4MASK = 0x08;\\n    uint8 internal constant BIT5MASK = 0x10;\\n    uint8 internal constant BIT6MASK = 0x20;\\n    uint8 internal constant BIT7MASK = 0x40;\\n\\n    bytes4 internal constant IERC165_INTERFACE_ID = 0x01ffc9a7;\\n    bytes4 internal constant IERC173_INTERFACE_ID = 0x7f5828d0;\\n    bytes4 internal constant IERC721_INTERFACE_ID = 0x80ac58cd;\\n    bytes4 internal constant IERC721METADATA_INTERFACE_ID = 0x5b5e139f;\\n    bytes4 internal constant IERC2981_INTERFACE_ID = 0x2a55205a;\\n    bytes4 internal constant IERC4907_INTERFACE_ID = 0xad092b5c;\\n    bytes4 internal constant IERC5192_INTERFACE_ID = 0xb45a3c0e;\\n    bytes4 internal constant IERC7496_INTERFACE_ID = 0xaf332f3e;\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    uint256 internal constant MAX_REVENUE_ADDRESSES_LENGTH = 25;\\n\\n    uint256 internal constant _BITPOS_INIT_COLLECTION_SIZE = 160;\\n    uint256 internal constant _BITPOS_INIT_ROYALTY_FEE = 192;\\n    uint256 internal constant _BITPOS_INIT_MINTING_TYPE = 208;\\n    uint256 internal constant _BITPOS_INIT_PHASE = 216;\\n    uint256 internal constant _BITPOS_INIT_BITMAP = 224;\\n    uint256 internal constant _BITPOS_INIT_RESERVED_TOKENS = 232;\\n\\n    uint256 internal constant _BITPOS_PRESALE_ADDRESS = 16;\\n    uint256 internal constant _BITPOS_PRESALE_FREE_MINTING = 160;\\n    uint256 internal constant _BITPOS_PRESALE_SOULBOUND = 168;\\n    uint256 internal constant _BITPOS_PRESALE_MAX_AMOUNT = 176;\\n\\n    uint256 internal constant _BITPOS_RENTAL_EXPIRES = 160;\\n\\n    address internal constant PROTOCOL_FEE_RECIPIENT = 0x6db16927DbC38AA39F0Ee2cB545e15EFd813FB99;\\n\\n    address internal constant OPENSEA_CONDUIT = 0x1E0049783F008A0085193E00003D00cd54003c71;\\n    address internal constant N2M_CONDUIT = 0x88899DC0B84C6E726840e00DFb94ABc6248825eC;\\n    address internal constant N2M_SIGNER = 0x00000000156D54b85de04c897356026a5ff2cBc9;\\n\\n    /// IMMUTABLE    \\n    address payable internal immutable FACTORY;\\n    uint256 internal immutable PROTOCOL_FEE;\\n\\n    uint16 internal _royaltyFee;\\n    uint32 internal _availableCollectionSize;\\n    bool internal _isEditions;\\n    uint32 internal _currentIndex;\\n    uint16 internal _maxPerAddress;                                                                 \\n    SalePhase internal _currentPhase;\\n    MintingType internal _mintingType;                                                              \\n    bool internal _isERC20Payment;\\n    bool internal _feesRemoved;\\n    bool internal _isDynamicNFT;\\n    bool internal _hasDynamicPrice;\\n    bool internal _soulboundCollection;\\n    OperatorFilterStatus internal _operatorFilterStatus;\\n    uint32 internal _burnedTokens;\\n    uint16 internal _reservedTokens;\\n    bool internal _hasPlaceholder;                                                                  \\n    bool internal _isMetadataEditable;                                                              \\n    uint24 internal _extraPacked;\\n\\n    uint256 _extra1;\\n    uint256 _extra2;\\n    uint256 _extra3;\\n    uint256 _extra4;\\n    uint256 _extra5;\\n    uint256 _extra6;\\n    uint256 _extra7;\\n    uint256 _extra8;\\n    uint256 _extra9;\\n\\n    DynamicNFT _dynamicNFT;\\n\\n    string internal _name;\\n    string internal _symbol;\\n    string internal _collectionDescription;\\n    string internal _baseURIString;\\n    bytes32 internal _baseURICIDHash;\\n    bytes32 internal _contractURIMetadataCIDHash;\\n    bytes32 internal _merkleRoot;\\n\\n    mapping(address => uint256) public pendingAffiliateBalance;\\n    uint256 internal _pendingTotalAffiliatesBalance;\\n\\n    RevenueAddress[] internal _revenueInfo;\\n    mapping(address => AffiliateInformation) internal _affiliatesInfo;\\n\\n    uint256 internal _mintPrice;\\n    uint256 internal _reentrancyStatus;\\n    uint256 internal _dropDateTimestamp;\\n    uint256 internal _endDateTimestamp; \\n\\n    mapping(address => uint256) public withdrawnERC20Amount;\\n    address internal _erc20PaymentAddress;\\n    uint256 internal _withdrawnAmount;\\n\\n    mapping(bytes => uint256) internal _usedAmountSignature;\\n    mapping(uint256 => bool) internal _soulbound;\\n    mapping(uint256 => bytes32) internal _customURICIDHashes;\\n\\n    mapping(address => bool) public whitelistedOperators;\\n\\n    /// ERC-7496: NFT Dynamic Traits - EIPs\\n    struct TraitPermission {\\n        bool ownerCanUpdateValue;\\n        bool onlyOnce;\\n    }\\n    mapping(bytes32 => TraitPermission) internal _traitPermissions;\\n    mapping(uint256 tokenId => mapping(bytes32 traitKey => bytes32 traitValue)) internal _traits;\\n    /// @dev An offchain string URI that points to a JSON file containing trait metadata.\\n    string internal _traitMetadataURI;\\n\\n    /// ERC-4907: Rental NFT, an Extension of EIP-721\\n    /// Mapping from token ID to user info.\\n    ///\\n    /// Bits Layout:\\n    /// - [0..159]   `user`\\n    /// - [160..223] `expires`\\n    mapping(uint256 => uint256) internal _packedUserInfo;\\n\\n    mapping(uint256 => uint256) internal _packedOwnerships;\\n\\n    mapping(address => uint256) internal _balanceOfData;\\n\\n    mapping(uint256 => TokenApprovalRef) internal _tokenApprovals;\\n\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    constructor(address payable factoryAddress_, uint256 protocolFee_) {\\n        FACTORY = factoryAddress_;\\n        PROTOCOL_FEE = protocolFee_;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"./IERC721Receiver.sol\\\";\\nimport {IERC721Metadata} from \\\"./extensions/IERC721Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {Strings} from \\\"../../utils/Strings.sol\\\";\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {IERC721Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\\n    mapping(uint256 tokenId => address) private _tokenApprovals;\\n\\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721InvalidOwner(address(0));\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _requireOwned(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        _approve(to, tokenId, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        _requireOwned(tokenId);\\n\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        address previousOwner = _update(to, tokenId, _msgSender());\\n        if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        transferFrom(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     *\\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\\n     */\\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\\n     * particular (ignoring whether it is owned by `owner`).\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            spender != address(0) &&\\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\\n     * the `spender` for the specific `tokenId`.\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\\n        if (!_isAuthorized(owner, spender, tokenId)) {\\n            if (owner == address(0)) {\\n                revert ERC721NonexistentToken(tokenId);\\n            } else {\\n                revert ERC721InsufficientApproval(spender, tokenId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\\n     *\\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\\n     * remain consistent with one another.\\n     */\\n    function _increaseBalance(address account, uint128 value) internal virtual {\\n        unchecked {\\n            _balances[account] += value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\\n        address from = _ownerOf(tokenId);\\n\\n        // Perform (optional) operator check\\n        if (auth != address(0)) {\\n            _checkAuthorized(from, auth, tokenId);\\n        }\\n\\n        // Execute the update\\n        if (from != address(0)) {\\n            // Clear approval. No need to re-authorize or emit the Approval event\\n            _approve(address(0), tokenId, address(0), false);\\n\\n            unchecked {\\n                _balances[from] -= 1;\\n            }\\n        }\\n\\n        if (to != address(0)) {\\n            unchecked {\\n                _balances[to] += 1;\\n            }\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return from;\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner != address(0)) {\\n            revert ERC721InvalidSender(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        _checkOnERC721Received(address(0), to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        address previousOwner = _update(address(0), tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        } else if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - `to` cannot be the zero address.\\n     * - `from` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\\n        _safeTransfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth) internal {\\n        _approve(to, tokenId, auth, true);\\n    }\\n\\n    /**\\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\\n     * emitted in the context of transfers.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\\n        // Avoid reading the owner unless necessary\\n        if (emitEvent || auth != address(0)) {\\n            address owner = _requireOwned(tokenId);\\n\\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\\n                revert ERC721InvalidApprover(auth);\\n            }\\n\\n            if (emitEvent) {\\n                emit Approval(owner, to, tokenId);\\n            }\\n        }\\n\\n        _tokenApprovals[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Requirements:\\n     * - operator can't be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC721InvalidOperator(operator);\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\\n     * Returns the owner.\\n     *\\n     * Overrides to ownership logic should be done to {_ownerOf}.\\n     */\\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    revert ERC721InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                let dataEnd := add(add(0x20, data), dataLength)\\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\\n\\n                // Run over the input, 3 bytes at a time.\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\n                    mstore8(3, mload(and(input, 0x3F)))\\n                    mstore(ptr, mload(0x00))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\n                let o := div(2, mod(dataLength, 3))\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\n                // Set `o` to zero if there is padding.\\n                o := mul(iszero(iszero(noPadding)), o)\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                for {} 1 {} {\\n                    // If padded.\\n                    if iszero(and(dataLength, 3)) {\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\n                        // forgefmt: disable-next-item\\n                        decodedLength := sub(\\n                            decodedLength,\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\n                        )\\n                        break\\n                    }\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                    break\\n                }\\n                result := mload(0x40)\\n\\n                // Write the length of the bytes.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, decodedLength)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    // forgefmt: disable-next-item\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n                    ptr := add(ptr, 3)\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\n                mstore(0x60, 0) // Restore the zero slot.\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\n///   This is for more safety by default.\\n///   Use the `tryRecover` variants if you need to get the zero address back\\n///   upon recovery failure instead.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(proof) {\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\n                let offset := add(proof, 0x20)\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(offset, shl(5, mload(proof)))\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), mload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The memory offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is not pointing to the scratch space).\\n    function verifyMultiProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        bool[] memory flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cache the lengths of the arrays.\\n            let leavesLength := mload(leaves)\\n            let proofLength := mload(proof)\\n            let flagsLength := mload(flags)\\n\\n            // Advance the pointers of the arrays to point to the data.\\n            leaves := add(0x20, leaves)\\n            proof := add(0x20, proof)\\n            flags := add(0x20, flags)\\n\\n            // If the number of flags is correct.\\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flagsLength) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof, shl(5, proofLength))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                leavesLength := shl(5, leavesLength)\\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\\n                }\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, leavesLength)\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(mload(flags)) {\\n                        // Loads the next proof.\\n                        b := mload(proof)\\n                        proof := add(proof, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag.\\n                    flags := add(flags, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    ///\\n    /// Note:\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\n    ///   will always return false.\\n    /// - Any non-zero word in the `flags` array is treated as true.\\n    /// - The calldata offset of `proof` must be non-zero\\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\\n    function verifyMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leaves,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the number of flags is correct.\\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flags.length) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    // forgefmt: disable-next-item\\n                    isValid := eq(\\n                        calldataload(\\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\\n                        ),\\n                        root\\n                    )\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := add(proof.offset, shl(5, proof.length))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flags.length := add(hashesBack, shl(5, flags.length))\\n\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\n                // as they are pass-by-value (this trick may not always save gas).\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(calldataload(flags.offset)) {\\n                        // Loads the next proof.\\n                        b := calldataload(proof.offset)\\n                        proof.offset := add(proof.offset, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag offset.\\n                    flags.offset := add(flags.offset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required.\\n                        eq(proofEnd, proof.offset)\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            proof.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leaves.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bool array.\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            flags.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"cancun\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 151\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"factoryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantLowerCurrentPercentages\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionSoldOut\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvadlidCollectionSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInputSizesDontMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMintingType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPercentageOrDiscountValues\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPhaseWithoutDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRevenueAddresses\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRevenuePercentage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxPerAddressExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadataAlreadyFixed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewBaseURICantBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonEditableTraitByTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonTransferrableSoulboundNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowlisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughAmountToMint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOnceTrait\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingAffiliatesBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlacerholderCantFreezeMetadata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PresaleInvalidMintingType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PresaleNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PublicSaleNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleFinished\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TraitValueUnchanged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WaitUntilDropDate\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"AffiliateSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"ImmutableTrait\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TraitMetadataURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"traitValue\",\"type\":\"bytes32\"}],\"name\":\"TraitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"TraitUpdatedList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"traitValue\",\"type\":\"bytes32\"}],\"name\":\"TraitUpdatedListUniformValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"}],\"name\":\"TraitUpdatedRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"traitValue\",\"type\":\"bytes32\"}],\"name\":\"TraitUpdatedRangeUniformValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"name\":\"UpdateUser\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"affiliateWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"affiliatesInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"affiliatePercentage\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"userDiscount\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"customURICIDHash\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"soulbound\",\"type\":\"bool\"}],\"name\":\"airdropCustomURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"soulbound\",\"type\":\"bool\"}],\"name\":\"airdropRandom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"soulbound\",\"type\":\"bool\"}],\"name\":\"airdropSpecify\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"allowListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newErc20PaymentAddress\",\"type\":\"address\"}],\"name\":\"changeERC20PaymentAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDynamic\",\"type\":\"bool\"}],\"name\":\"changeMintFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newFee\",\"type\":\"uint16\"}],\"name\":\"changeRoyaltyFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"internalType\":\"enum IN2MCommonStorage.SalePhase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableOperatorFilterRegistry\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20PaymentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTraitMetadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"labelsURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"}],\"name\":\"getTraitValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"traitValue\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"traitKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getTraitValues\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"traitValues\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice_\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"baseURICIDHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedData\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"extraCollectionInformation\",\"type\":\"bytes\"}],\"name\":\"initialize008joDSK\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMetadataFixed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOperatorFilterRegistryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mintAllowlist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"customURICIDHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"soulbound\",\"type\":\"bool\"}],\"name\":\"mintCustomURITo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintRandomTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"mintRandomTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"mintSpecifyTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"mintSpecifyTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"toWihtExtra\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"customFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"mintWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingType\",\"outputs\":[{\"internalType\":\"enum IN2MCommonStorage.MintingType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"n2mVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"collectionOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerMaxRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingAffiliateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTotalAffiliatesBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newCollectionSize\",\"type\":\"uint32\"}],\"name\":\"reduceCollectionSize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"removeProtocolFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"reserveTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleDates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dropDateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDateTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"userDiscount\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"affiliatePercentage\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"}],\"name\":\"setAffiliatesPercentageAndDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURIString\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"baseURICIDHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPlaceholder\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"freezeMetadata\",\"type\":\"bool\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newContractURIMetadataCIDHash\",\"type\":\"bytes32\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropDateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDateTimestamp\",\"type\":\"uint256\"}],\"name\":\"setDropAndEndDate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newMaxPerAddress\",\"type\":\"uint16\"}],\"name\":\"setMaxPerAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IN2MCommonStorage.SalePhase\",\"name\":\"newPhase\",\"type\":\"uint8\"}],\"name\":\"setPhase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"traitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"setTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTraitMetadataURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ownerCanUpdateTraitKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"onlyOnceTraitKeys\",\"type\":\"bytes32[]\"}],\"name\":\"setTraitsPermissions\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"name\":\"setUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"unreserveTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"userExpires\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"userOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"whitelistOperators\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedOperators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawnERC20Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "N2MERC721NS", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "151", "ConstructorArguments": "00000000000000000000000000000000001594c61dd8a6804da9ab58ed2483ce0000000000000000000000000000000000000000000000000001c6bf52634000", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}