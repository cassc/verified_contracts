{"SourceCode": "// Sources flattened with hardhat v2.17.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT AND UNLICENSED\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // extraArgs will evolve to support new features\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\r\n    bool strict; // See strict sequencing details below.\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouterClient {\r\n  error UnsupportedDestinationChain(uint64 destChainSelector);\r\n  error InsufficientFeeTokenAmount();\r\n  error InvalidMsgValue();\r\n\r\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\r\n  /// @param chainSelector The chain to check.\r\n  /// @return supported is true if it is supported, false if not.\r\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\r\n\r\n  /// @notice Gets a list of all supported tokens which can be sent or received\r\n  /// to/from a given chain id.\r\n  /// @param chainSelector The chainSelector.\r\n  /// @return tokens The addresses of all tokens that are supported.\r\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\r\n\r\n  /// @param destinationChainSelector The destination chainSelector\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return fee returns guaranteed execution fee for the specified message\r\n  /// delivery to destination chain\r\n  /// @dev returns 0 fee on invalid message.\r\n  function getFee(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage memory message\r\n  ) external view returns (uint256 fee);\r\n\r\n  /// @notice Request a message to be sent to the destination chain\r\n  /// @param destinationChainSelector The destination chain ID\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return messageId The message ID\r\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\r\n  /// the overpayment with no refund.\r\n  function ccipSend(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage calldata message\r\n  ) external payable returns (bytes32);\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/interfaces/OwnableInterface.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface OwnableInterface {\r\n  function owner() external returns (address);\r\n\r\n  function transferOwnership(address recipient) external;\r\n\r\n  function acceptOwnership() external;\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ConfirmedOwnerWithProposal.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(address indexed from, address indexed to);\r\n  event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n  constructor(address newOwner, address pendingOwner) {\r\n    require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n    s_owner = newOwner;\r\n    if (pendingOwner != address(0)) {\r\n      _transferOwnership(pendingOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address to) public override onlyOwner {\r\n    _transferOwnership(to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner() public view override returns (address) {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice validate, transfer ownership, and emit relevant events\r\n   */\r\n  function _transferOwnership(address to) private {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice validate access\r\n   */\r\n  function _validateOwnership() internal view {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _validateOwnership();\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ConfirmedOwner.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// @title The OwnerIsCreator contract\r\n/// @notice A contract with helpers for basic contract ownership.\r\ncontract OwnerIsCreator is ConfirmedOwner {\r\n  constructor() ConfirmedOwner(msg.sender) {}\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol@v0.6.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface AutomationCompatibleInterface {\r\n  /**\r\n   * @notice method that is simulated by the keepers to see if any work actually\r\n   * needs to be performed. This method does does not actually need to be\r\n   * executable, and since it is only ever simulated it can consume lots of gas.\r\n   * @dev To ensure that it is never called, you may want to add the\r\n   * cannotExecute modifier from KeeperBase to your implementation of this\r\n   * method.\r\n   * @param checkData specified in the upkeep registration so it is always the\r\n   * same for a registered upkeep. This can easily be broken down into specific\r\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\r\n   * same contract and easily differentiated by the contract.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with, if\r\n   * upkeep is needed. If you would like to encode data to decode later, try\r\n   * `abi.encode`.\r\n   */\r\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n\r\n  /**\r\n   * @notice method that is actually executed by the keepers, via the registry.\r\n   * The data returned by the checkUpkeep simulation will be passed into\r\n   * this method to actually be executed.\r\n   * @dev The input to this method should not be trusted, and the caller of the\r\n   * method should not even be restricted to any single registry. Anyone should\r\n   * be able call it, and the input should be validated, there is no guarantee\r\n   * that the data passed in is the performData returned from checkUpkeep. This\r\n   * could happen due to malicious keepers, racing keepers, or simply a state\r\n   * change while the performUpkeep transaction is waiting for confirmation.\r\n   * Always validate the data passed in.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation. If it is encoded, it can easily be decoded into other types by\r\n   * calling `abi.decode`. This data should not be trusted, and should be\r\n   * validated against the contract's current state.\r\n   */\r\n  function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol@v0.6.1\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool success);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/structs/EnumerableSet.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```solidity\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ccip/interface/IRateSender.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IRateSender {\r\n    error InitCompleted();\r\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\r\n    error TransferNotAllow();\r\n    error SelectorExist();\r\n    error SelectorNotExist();\r\n    event MessageSent(\r\n        bytes32 indexed messageId,\r\n        uint64 indexed destinationChainSelector,\r\n        address indexed sender,\r\n        address receiver,\r\n        bytes data,\r\n        address feeToken,\r\n        uint256 fees\r\n    );\r\n\r\n    function addRETHRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external;\r\n\r\n    function removeRETHRateInfo(uint64 _selector) external;\r\n\r\n    function updateRETHRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external;\r\n\r\n    function addRMATICRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external;\r\n\r\n    function removeRMATICRateInfo(uint64 _selector) external;\r\n\r\n    function updateRMATICRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external;\r\n\r\n    function withdrawLink(address _to) external;\r\n}\r\n\r\n\r\n// File contracts/ccip/interface/IRETHRate.sol\r\n\r\n// Original license: SPDX_License_Identifier: UNLICENSED\r\npragma solidity ^0.8.19;\r\n\r\ninterface IRETHRate {\r\n    function getExchangeRate() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/ccip/interface/IRMAITCRate.sol\r\n\r\n// Original license: SPDX_License_Identifier: UNLICENSED\r\npragma solidity ^0.8.19;\r\n\r\ninterface IRMAITCRate {\r\n    function getRate() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/ccip/Types.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nstruct RateInfo {\r\n    address receiver;\r\n    address destination;\r\n}\r\n\r\nstruct RateMsg {\r\n    address destination;\r\n    uint256 rate;\r\n}\r\n\r\n\r\n// File contracts/ccip/RateSender.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title - A contract for sending rate data across chains.\r\ncontract RateSender is\r\n    AutomationCompatibleInterface,\r\n    OwnerIsCreator,\r\n    IRateSender\r\n{\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    address public ccipRegister;\r\n\r\n    IRouterClient public router;\r\n\r\n    LinkTokenInterface public linkToken;\r\n\r\n    EnumerableSet.UintSet private rethChainSelectors;\r\n    EnumerableSet.UintSet private rmaticChainSelectors;\r\n\r\n    mapping(uint => RateInfo) public rethRateInfoOf;\r\n\r\n    mapping(uint => RateInfo) public rmaticRateInfoOf;\r\n\r\n    IRETHRate public reth;\r\n    uint256 public rethLatestRate;\r\n\r\n    IRMAITCRate public rmatic;\r\n    uint256 public rmaticLatestRate;\r\n\r\n    modifier onlyCCIPRegister() {\r\n        if (ccipRegister != msg.sender) {\r\n            revert TransferNotAllow();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _router,\r\n        address _link,\r\n        address _ccipRegister,\r\n        address _rethSource,\r\n        address _rmaticSource\r\n    ) {\r\n        router = IRouterClient(_router);\r\n        linkToken = LinkTokenInterface(_link);\r\n        ccipRegister = _ccipRegister;\r\n        reth = IRETHRate(_rethSource);\r\n        rmatic = IRMAITCRate(_rmaticSource);\r\n    }\r\n\r\n    function addRETHRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external onlyOwner {\r\n        if (!rethChainSelectors.add(_selector)) revert SelectorExist();\r\n        rethRateInfoOf[_selector] = RateInfo({\r\n            receiver: _receiver,\r\n            destination: _rateProvider\r\n        });\r\n    }\r\n\r\n    function removeRETHRateInfo(uint64 _selector) external onlyOwner {\r\n        if (!rethChainSelectors.remove(_selector)) revert SelectorNotExist();\r\n        delete rethRateInfoOf[_selector];\r\n    }\r\n\r\n    function updateRETHRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external onlyOwner {\r\n        if (!rethChainSelectors.contains(_selector)) revert SelectorNotExist();\r\n        rethRateInfoOf[_selector] = RateInfo({\r\n            receiver: _receiver,\r\n            destination: _rateProvider\r\n        });\r\n    }\r\n\r\n    function addRMATICRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external onlyOwner {\r\n        if (!rmaticChainSelectors.add(_selector)) revert SelectorExist();\r\n        rmaticRateInfoOf[_selector] = RateInfo({\r\n            receiver: _receiver,\r\n            destination: _rateProvider\r\n        });\r\n    }\r\n\r\n    function removeRMATICRateInfo(uint64 _selector) external onlyOwner {\r\n        if (!rmaticChainSelectors.remove(_selector)) revert SelectorNotExist();\r\n        delete rmaticRateInfoOf[_selector];\r\n    }\r\n\r\n    function updateRMATICRateInfo(\r\n        address _receiver,\r\n        address _rateProvider,\r\n        uint64 _selector\r\n    ) external onlyOwner {\r\n        if (!rmaticChainSelectors.contains(_selector))\r\n            revert SelectorNotExist();\r\n        rmaticRateInfoOf[_selector] = RateInfo({\r\n            receiver: _receiver,\r\n            destination: _rateProvider\r\n        });\r\n    }\r\n\r\n    function withdrawLink(address _to) external onlyOwner {\r\n        uint256 balance = linkToken.balanceOf(address(this));\r\n\r\n        if (balance == 0) revert NotEnoughBalance(0, 0);\r\n\r\n        linkToken.transfer(_to, balance);\r\n    }\r\n\r\n    /// @notice Sends data to receiver on the destination chain.\r\n    /// @param destinationChainSelector The identifier (aka selector) for the destination blockchain.\r\n    /// @param receiver The address of the recipient on the destination blockchain.\r\n    /// @param data The bytes data to be sent.\r\n    function sendMessage(\r\n        uint64 destinationChainSelector,\r\n        address receiver,\r\n        bytes memory data\r\n    ) internal {\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\r\n            data: data, // ABI-encoded\r\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\r\n            extraArgs: Client._argsToBytes(\r\n                // Additional arguments, setting gas limit and non-strict sequencing mode\r\n                Client.EVMExtraArgsV1({gasLimit: 600_000, strict: false})\r\n            ),\r\n            // Set the feeToken  address, indicating LINK will be used for fees\r\n            feeToken: address(linkToken)\r\n        });\r\n\r\n        // Get the fee required to send the message\r\n        uint256 fees = router.getFee(destinationChainSelector, evm2AnyMessage);\r\n\r\n        if (fees > linkToken.balanceOf(address(this)))\r\n            revert NotEnoughBalance(linkToken.balanceOf(address(this)), fees);\r\n\r\n        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\r\n        linkToken.approve(address(router), fees);\r\n\r\n        // Send the message through the router and store the returned message ID\r\n        bytes32 messageId = router.ccipSend(\r\n            destinationChainSelector,\r\n            evm2AnyMessage\r\n        );\r\n\r\n        // Emit an event with message details\r\n        emit MessageSent(\r\n            messageId,\r\n            destinationChainSelector,\r\n            msg.sender,\r\n            receiver,\r\n            data,\r\n            address(linkToken),\r\n            fees\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the exchange rates for RETH or RMATIC have changed.\r\n     * @return upkeepNeeded indicates if an update is required, performData is an ABI-encoded integer representing the task type.\r\n     */\r\n    function checkUpkeep(\r\n        bytes calldata\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (bool upkeepNeeded, bytes memory performData)\r\n    {\r\n        uint taskType = 0;\r\n        uint256 newRate = reth.getExchangeRate();\r\n        if (rethLatestRate != newRate) {\r\n            taskType = 1;\r\n        }\r\n        newRate = rmatic.getRate();\r\n        if (rmaticLatestRate != newRate) {\r\n            taskType += 2;\r\n        }\r\n        if (taskType > 0) {\r\n            return (true, abi.encode(taskType));\r\n        }\r\n        return (false, bytes(\"\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the Chainlink Automation Network to update RETH and/or RMATIC rates.\r\n     * @param performData The ABI-encoded integer representing the type of task to perform.\r\n     */\r\n    function performUpkeep(\r\n        bytes calldata performData\r\n    ) external override onlyCCIPRegister {\r\n        uint taskType = abi.decode(performData, (uint));\r\n        if (taskType == 1) {\r\n            sendRETHRate();\r\n        } else if (taskType == 2) {\r\n            sendMATICRate();\r\n        } else if (taskType == 3) {\r\n            sendRETHRate();\r\n            sendMATICRate();\r\n        }\r\n    }\r\n\r\n    function sendRETHRate() internal {\r\n        rethLatestRate = reth.getExchangeRate();\r\n        for (uint256 i = 0; i < rethChainSelectors.length(); i++) {\r\n            uint256 selector = rethChainSelectors.at(i);\r\n            RateInfo memory rethRateInfo = rethRateInfoOf[selector];\r\n\r\n            RateMsg memory rateMsg = RateMsg({\r\n                destination: rethRateInfo.destination,\r\n                rate: rethLatestRate\r\n            });\r\n\r\n            sendMessage(\r\n                uint64(selector),\r\n                rethRateInfo.receiver,\r\n                abi.encode(rateMsg)\r\n            );\r\n        }\r\n    }\r\n\r\n    function sendMATICRate() internal {\r\n        rmaticLatestRate = rmatic.getRate();\r\n        for (uint256 i = 0; i < rmaticChainSelectors.length(); i++) {\r\n            uint256 selector = rmaticChainSelectors.at(i);\r\n            RateInfo memory rmaticRateInfo = rmaticRateInfoOf[selector];\r\n\r\n            RateMsg memory rateMsg = RateMsg({\r\n                destination: rmaticRateInfo.destination,\r\n                rate: rmaticLatestRate\r\n            });\r\n\r\n            sendMessage(\r\n                uint64(selector),\r\n                rmaticRateInfo.receiver,\r\n                abi.encode(rateMsg)\r\n            );\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ccipRegister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rethSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rmaticSource\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InitCompleted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calculatedFees\",\"type\":\"uint256\"}],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SelectorExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SelectorNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotAllow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateProvider\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"addRETHRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateProvider\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"addRMATICRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccipRegister\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToken\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"removeRETHRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"removeRMATICRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reth\",\"outputs\":[{\"internalType\":\"contract IRETHRate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rethLatestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rethRateInfoOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rmatic\",\"outputs\":[{\"internalType\":\"contract IRMAITCRate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rmaticLatestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rmaticRateInfoOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouterClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateProvider\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"updateRETHRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateProvider\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_selector\",\"type\":\"uint64\"}],\"name\":\"updateRMATICRateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RateSender", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e561d5e02207fb5eb32cca20a699e0d8919a1476000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000002777053d6764996e594c3e88af1d58d5363a2e60000000000000000000000009559aaa82d9649c7a7b220e7c461d2e74c9a35930000000000000000000000003aee3e96c9e340cbe0fffc5224db9e97949f3899", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5e936959cd0decfae405703594fcd56b1464fcfb63c70aca69831a614efea82a"}