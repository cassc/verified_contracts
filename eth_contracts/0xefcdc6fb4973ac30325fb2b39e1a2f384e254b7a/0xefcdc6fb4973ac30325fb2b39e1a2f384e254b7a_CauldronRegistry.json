{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/CauldronRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport {OperatableV2} from \\\"mixins/OperatableV2.sol\\\";\\n\\nstruct CauldronInfo {\\n    address cauldron;\\n    uint8 version;\\n    bool deprecated;\\n}\\n\\ncontract CauldronRegistry is OperatableV2 {\\n    event LogCauldronRegistered(address indexed cauldron, uint8 version, bool deprecated);\\n    event LogCauldronRemoved(address indexed cauldron);\\n    event LogCauldronDeprecated(address indexed cauldron, bool deprecated);\\n\\n    error ErrAlreadyRegistered(address cauldron_);\\n    error ErrNotRegistered(address cauldron_);\\n    error ErrEmptyRegistry();\\n    error ErrTooManyCauldrons();\\n    error ErrInvalidCauldron(address cauldron_);\\n\\n    CauldronInfo[] public cauldrons;\\n    mapping(address => uint256) internal cauldronIndicies;\\n\\n    constructor(address owner_) OperatableV2(owner_) {}\\n\\n    ///////////////////////////////////////////////////////////////////////////////////\\n    // VIEWS\\n    ///////////////////////////////////////////////////////////////////////////////////\\n\\n    function length() public view returns (uint256) {\\n        return cauldrons.length;\\n    }\\n\\n    function get(address cauldron_) public view returns (CauldronInfo memory) {\\n        uint256 cauldronIndex = cauldronIndicies[cauldron_];\\n        if (!registered(cauldron_)) {\\n            revert ErrNotRegistered(cauldron_);\\n        }\\n\\n        return cauldrons[cauldronIndex];\\n    }\\n\\n    function registered(address cauldron_) public view returns (bool) {\\n        return cauldronIndicies[cauldron_] != 0 || (cauldrons.length != 0 && cauldrons[0].cauldron == cauldron_);\\n    }\\n\\n    function get(uint256 index_) public view returns (CauldronInfo memory) {\\n        if (index_ >= cauldrons.length) {\\n            revert ErrNotRegistered(address(0));\\n        }\\n\\n        return cauldrons[index_];\\n    }\\n\\n    function isDeprecated(address cauldron_) public view returns (bool) {\\n        return get(cauldron_).deprecated;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////\\n    // OPERATORS\\n    ///////////////////////////////////////////////////////////////////////////////////\\n\\n    function add(CauldronInfo[] calldata items_) external onlyOperators {\\n        for (uint256 i = 0; i < items_.length; ++i) {\\n            CauldronInfo memory item = items_[i];\\n\\n            if (item.cauldron == address(0)) {\\n                revert ErrInvalidCauldron(item.cauldron);\\n            }\\n\\n            if (registered(item.cauldron)) {\\n                revert ErrAlreadyRegistered(item.cauldron);\\n            }\\n\\n            uint256 cauldronIndex = cauldrons.length;\\n            cauldrons.push(item);\\n            cauldronIndicies[item.cauldron] = cauldronIndex;\\n\\n            emit LogCauldronRegistered(item.cauldron, item.version, item.deprecated);\\n        }\\n    }\\n\\n    function setDeprecated(address cauldron_, bool deprecated_) external onlyOperators {\\n        if (!registered(cauldron_)) {\\n            revert ErrNotRegistered(cauldron_);\\n        }\\n\\n        cauldrons[cauldronIndicies[cauldron_]].deprecated = deprecated_;\\n        emit LogCauldronDeprecated(cauldron_, deprecated_);\\n    }\\n\\n    function remove(address[] calldata cauldrons_) external onlyOperators {\\n        if (cauldrons.length == 0) {\\n            revert ErrEmptyRegistry();\\n        }\\n\\n        if (cauldrons.length < cauldrons_.length) {\\n            revert ErrTooManyCauldrons();\\n        }\\n\\n        for (uint256 i = 0; i < cauldrons_.length; ++i) {\\n            address cauldron = cauldrons_[i];\\n\\n            if (address(cauldron) == address(0)) {\\n                revert ErrInvalidCauldron(cauldron);\\n            }\\n\\n            uint256 cauldronIndex = cauldronIndicies[cauldron];\\n            if (cauldronIndex == 0 && cauldrons[0].cauldron != cauldron) {\\n                revert ErrNotRegistered(cauldron);\\n            }\\n\\n            uint256 lastIndex = cauldrons.length - 1;\\n            if (cauldronIndex == lastIndex) {\\n                cauldrons.pop();\\n                delete cauldronIndicies[cauldron];\\n                emit LogCauldronRemoved(cauldron);\\n            } else {\\n                cauldronIndicies[cauldrons[lastIndex].cauldron] = cauldronIndex;\\n                cauldrons[cauldronIndex] = cauldrons[lastIndex];\\n                cauldrons.pop();\\n                delete cauldronIndicies[cauldron];\\n                emit LogCauldronRemoved(cauldron);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mixins/OperatableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\n\\n/// @title OperatableV2\\n/// @notice OperatableV2 is a contract that allows operator management.\\n/// The difference with OperatableV1 apart from using solmate `Owned` vs `BoringOwnable` is that\\n/// the constructor is taking in the owner except of using msg.sender.\\n/// This allows ensuring that the owner is right one.\\n/// For example, when deploying from a CREATE2 factory, the msg.sender would the factory address\\n/// which is usually not what we want.\\ncontract OperatableV2 is Owned {\\n    event OperatorChanged(address indexed, bool);\\n    error NotAllowedOperator();\\n\\n    mapping(address => bool) public operators;\\n\\n    constructor(address _owner) Owned(_owner) {}\\n\\n    modifier onlyOperators() {\\n        if (!operators[msg.sender] && msg.sender != owner) {\\n            revert NotAllowedOperator();\\n        }\\n        _;\\n    }\\n\\n    function setOperator(address operator, bool status) external onlyOwner {\\n        operators[operator] = status;\\n        emit OperatorChanged(operator, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"utils/=utils/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"staking/=src/staking/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mixins/=src/mixins/\",\r\n      \"lenses/=src/lenses/\",\r\n      \"surl/=lib/surl/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-deploy/=lib/forge-deploy/contracts/\",\r\n      \"ExcessivelySafeCall/=lib/ExcessivelySafeCall/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"fuzzlib/=lib/fuzzlib/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"ErrAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrEmptyRegistry\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"ErrInvalidCauldron\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"ErrNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrTooManyCauldrons\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedOperator\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"name\":\"LogCauldronDeprecated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"name\":\"LogCauldronRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"}],\"name\":\"LogCauldronRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"internalType\":\"struct CauldronInfo[]\",\"name\":\"items_\",\"type\":\"tuple[]\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cauldrons\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"internalType\":\"struct CauldronInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"get\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"deprecated\",\"type\":\"bool\"}],\"internalType\":\"struct CauldronInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"isDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cauldrons_\",\"type\":\"address[]\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cauldron_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"deprecated_\",\"type\":\"bool\"}],\"name\":\"setDeprecated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CauldronRegistry", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "000000000000000000000000fb3485c2e209a5cfbdc1447674256578f1a80ee3", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}