{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/PaymentLogicFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { LibAppStorage, Modifiers, CustomErrors } from \\\"contracts/libraries/LibAppStorage.sol\\\";\\nimport { LibPaymentLogic } from \\\"contracts/libraries/LibPaymentLogic.sol\\\";\\n\\n/**\\n * @title PaymentLogicFacet\\n * @author Robert Gordon Palmer\\n * @dev A contract for managing payment logic and settings.\\n */\\ncontract PaymentLogicFacet is Modifiers, CustomErrors {\\n\\n    /**\\n     * @dev Set the treasury wallet address.\\n     * @param _treasuryWallet The address of the treasury wallet.\\n     */\\n    function setTreasuryWallet(address _treasuryWallet) external onlyAdminOrOwner(msg.sender){\\n        LibPaymentLogic._setTreasuryWallet(_treasuryWallet);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibAppStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\nimport { LibMeta } from \\\"contracts/libraries/LibMeta.sol\\\";\\n\\n/**\\n * @title Tier\\n * @dev This struct defines the data structure for a tier in a sale.\\n */\\nstruct Tier {\\n    uint256 tierNumber; // Tier number\\n    uint256 start; // Start timestamp of the tier\\n    uint256 end; // End timestamp of the tier\\n    bytes32 merkleRoot; // Merkle root for the tier\\n    uint256 limitPerWallet; // Limit the wallet can purcahse for the tier\\n    uint256[] availableIds; // Array of available IDs for the tier\\n    bool isPublic; // Flag indicating if the tier is public\\n}\\n\\n/**\\n * @title Partner\\n * @dev This struct defines the data structure for a partner.\\n */\\nstruct Partner {\\n    address partnerAddress; // The partners address; Funds will be sent to this address.\\n    uint256 sharePercentage;// The partners share of each sale; Paid each time a user mints.\\n}\\n\\n/**\\n * @title Sale\\n * @dev This struct defines the data structure for a sale.\\n */\\nstruct Sale {\\n    Tier[] tiers; // Array of tiers in the sale\\n    PaymentTokenMaxSupply[] paymentTokensMaxSupplies; // Array of payment tokens and their maximum accepted supplies\\n    address collectionAddress; // Address of the collection\\n    uint256 collectionERCType; // ERC type of the collection\\n    Partner[] partners; // Partners for the sale\\n}\\n\\n/**\\n * @title PaymentTokenMaxSupply\\n * @dev This struct defines the data structure for a payment token and its maximum supply.\\n */\\nstruct PaymentTokenMaxSupply {\\n    address paymentToken;// Address of the payment token\\n    uint256 maxAcceptedAmount;// Maximum accepted amount for the payment token\\n    uint256 totalSpent;// Total spent amount for the payment token\\n}\\n\\n/**\\n * @title AppStorage\\n * @dev This struct defines the data structure for storing the state of the application.\\n * @dev Always add new members needed to the end of this struct when upgrading or adding a facet.\\n */\\nstruct AppStorage {\\n\\n    bool initialized; // Flag indicating if the contract has been initialized\\n\\n    address owner; // Address of the contract owner\\n    address multisig; // Address of the multisig wallet\\n    address treasuryWallet; // Address of the treasury wallet\\n\\n    bool paused; // Flag indicating if the contract is paused\\n\\n    // SaleID => Sale struct containing all Tier strcut info\\n    mapping(uint256 => Sale) saleId;\\n\\n    // Mapping of address to admin status\\n    mapping(address => bool) isAdmin;\\n\\n    uint256[] emptyArr; // Empty array - used for assigning `availableIds` to a 721 tier\\n\\n    uint256 totalSales; // Total number of sales\\n\\n    // User Address => saleId => total minted amount\\n    mapping(address => mapping(uint256 => uint256)) userMintedAmount;\\n\\n    // Payment token address => SaleId => price\\n    mapping(address => mapping(uint256 => uint256)) acceptedTokenPrice;\\n\\n    mapping(uint256 saleId => mapping(address paymentToken => mapping(uint256 tokenId => uint256 price))) tokenIdPrice;\\n\\n    // Mapping of address to collection sale ID\\n    mapping(address => uint256) collectionSaleId;\\n\\n    // The address for Warm wallet delegation contract\\n    address warmWalletContractAddress;\\n\\n    address permit2ContractAddress;\\n}\\n\\nlibrary LibAppStorage {\\n\\n  function diamondStorage() \\n    internal \\n    pure \\n    returns (AppStorage storage ds) \\n  {    \\n    assembly {\\n      ds.slot := 0\\n    }\\n  }\\n}\\n\\n/**\\n * @title Modifiers\\n * @dev This contract contains modifiers used in the facets.\\n */\\ncontract Modifiers {\\n    AppStorage internal s;\\n\\n    /**\\n     * @dev Modifier to restrict access to only the admin or owner.\\n     * @param _address The address to check.\\n     * Requirements:\\n     * - The caller must be an admin or owner.\\n     */\\n    modifier onlyAdminOrOwner(address _address) {\\n        //AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(\\n            s.isAdmin[_address] || _address == s.owner,\\n            \\\"This address is not allowed\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to restrict access to only the multisig wallet.\\n     * @param _address The address to check.\\n     * Requirements:\\n     * - The caller must be the multisig wallet.\\n     */\\n    modifier onlyMultiSig(address _address) {\\n        //AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(_address == s.multisig, \\\"Not Multisig wallet\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to restrict access when the contract is not paused.\\n     * Requirements:\\n     * - The contract must not be paused.\\n     */\\n    modifier onlyUnpaused() {\\n        //AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(!s.paused, \\\"Sale Stopped Currently\\\");\\n        _;\\n    }\\n}\\n\\ncontract CustomErrors {\\n    error TotalSupplyGreaterThanMaxSupply();\\n    error TierNumberIncorrect();\\n    error ArrayLengthsDiffer();\\n    error TierLengthTooShort();\\n    error ClaimPeriodTooShort();\\n    error PartnerAlreadyExists();\\n    error PartnerNotFound();\\n    error InvalidPartnerWallet();\\n    error InvalidPartnerSharePct();\\n    error PartnerActive();\\n    error PartnerDeactivated();\\n    error InvalidProof();\\n    error TierPeriodHasntStarted();\\n    error TierPeriodHasEnded();\\n    error CurrentlyNotClaimPeriod();\\n    error MintLimitReached();\\n    error MaxSupplyReached();\\n    error AlreadyInitialized();\\n    error MsgSenderIsNotOwner();\\n    error IncorrectAddress();\\n    error BaseURINotSet();\\n    error TokenNotAcceptedAsPayment();\\n    error InsufficientBalance();\\n    error TokenIsSoulbound();\\n    error NoConfirmedIds();\\n    error ERCTypeIncorrect();\\n    error IncorrectHotWallet();\\n    error WarmLinkExpired();\\n    error DesiredIdNotAllowed();\\n    error PriceCannotBeZero();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibPaymentLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { LibAppStorage, AppStorage, CustomErrors, Sale, Tier } from \\\"../libraries/LibAppStorage.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/IAllowanceTransfer.sol\\\";\\n\\n/**\\n * @title LibPaymentLogic\\n * @author Robert Gordon Palmer\\n * @dev Library for handling payment logic in the contract. \\n*/ \\nlibrary LibPaymentLogic {\\n\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n    * @dev Mint fee check for ERC721 tokens.\\n    * @param _user The address of the user.\\n    * @param _amount The amount of tokens being minted.\\n    * @param _paymentToken The address of the payment token.\\n    * @param _saleId The ID of the sale.\\n    */\\n    function _mintFeeCheck721(address _user, uint256 _amount, address _paymentToken, uint256 _saleId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 payment;\\n        uint256 _partnerLength = s.saleId[_saleId].partners.length;\\n        uint256 _paymentTokenIndex;\\n\\n        for(uint256 i = 0; i < s.saleId[_saleId].paymentTokensMaxSupplies.length; i++){\\n            if(s.saleId[_saleId].paymentTokensMaxSupplies[i].paymentToken == _paymentToken){\\n                _paymentTokenIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (s.treasuryWallet != address(0)) {\\n            if (address(_paymentToken) == address(0)) {\\n\\n                // Calculate the payment amount based on the mint fee and the amount of tokens being minted\\n               payment = s.acceptedTokenPrice[_paymentToken][_saleId] * _amount;\\n\\n               // Check if the user has sent enough Ether for the payment\\n               if(msg.value < payment) revert CustomErrors.InsufficientBalance();\\n\\n               if(msg.value > payment){\\n                    uint256 unusedPayment = msg.value - payment;\\n                    (bool sent, bytes memory data) = payable(msg.sender).call{value: unusedPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n               uint256 _treasuryPayment = payment;\\n\\n               if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n               //Trasfer partner percentage to each partner\\n               for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    (bool sent, bytes memory data) = s.saleId[_saleId].partners[j].partnerAddress.call{value: _partnerPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n                // Transfer Ether to the treasury wallet\\n               (bool sent, bytes memory data) = s.treasuryWallet.call{value: _treasuryPayment}(\\\"\\\");\\n                require(sent, \\\"Failed to send Ether\\\");\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n\\n            } else {\\n\\n                // Calculate the payment amount based on the accepted token price and the amount of tokens being minted\\n                payment = s.acceptedTokenPrice[_paymentToken][_saleId] * _amount;\\n\\n                if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n                // Check if the payment token is accepted and if the user has enough balance\\n                if(s.acceptedTokenPrice[_paymentToken][_saleId] == 0) revert CustomErrors.TokenNotAcceptedAsPayment();\\n                if(IERC20(_paymentToken).balanceOf(_user) < payment) revert CustomErrors.InsufficientBalance();\\n                uint256 _treasuryPayment = payment;\\n\\n                //Trasfer partner percentage to each partner\\n                for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    IERC20(_paymentToken).safeTransferFrom(msg.sender, s.saleId[_saleId].partners[j].partnerAddress, _partnerPayment);\\n               }\\n\\n                // Transfer the payment tokens from the user to the treasury wallet\\n                IERC20(_paymentToken).safeTransferFrom(msg.sender, s.treasuryWallet, _treasuryPayment);\\n                \\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Mint fee check for ERC1155 tokens.\\n    * @param _user The address of the user.\\n    * @param _amounts The amounts of tokens being minted.\\n    * @param _tokenIds The IDs of the tokens being minted.\\n    * @param _paymentToken The address of the payment token.\\n    * @param _saleId The ID of the sale.\\n    */\\n    function _mintFeeCheck1155(\\n        address _user, \\n        uint256[] memory _amounts, \\n        uint256[] memory _tokenIds, \\n        address _paymentToken, \\n        uint256 _saleId\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 payment;\\n        uint256 _length = _tokenIds.length;\\n        uint256 _partnerLength = s.saleId[_saleId].partners.length;\\n        uint256 _paymentTokenIndex;\\n\\n        for(uint256 i = 0; i < s.saleId[_saleId].paymentTokensMaxSupplies.length; i++){\\n            if(s.saleId[_saleId].paymentTokensMaxSupplies[i].paymentToken == _paymentToken){\\n                _paymentTokenIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (s.treasuryWallet != address(0)) {\\n            if (address(_paymentToken) == address(0)) {\\n\\n                // Calculate the total payment amount for all the tokens being minted\\n                for(uint256 i = 0; i < _length; i++){\\n                    payment += (s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] * _amounts[i]);\\n                }\\n\\n                // Check if the user has sent enough Ether for the payment\\n               if(msg.value < payment) revert CustomErrors.InsufficientBalance();\\n               uint256 _treasuryPayment = payment;\\n\\n               if(msg.value > payment){\\n                    uint256 unusedPayment = msg.value - payment;\\n                    (bool sent, bytes memory data) = payable(msg.sender).call{value: unusedPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n               if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n               //Trasfer partner percentage to each partner\\n               for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    (bool sent, bytes memory data) = s.saleId[_saleId].partners[j].partnerAddress.call{value: _partnerPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n                // Transfer the remaining Ether to the treasury wallet\\n               (bool sent, bytes memory data) = s.treasuryWallet.call{value: _treasuryPayment}(\\\"\\\");\\n                require(sent, \\\"Failed to send Ether\\\");\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n\\n            } else {\\n\\n                // Calculate the total payment amount for all the tokens being minted\\n                for(uint256 i = 0; i < _length; i++){\\n\\n                    // Check if the payment token is accepted for each token ID\\n                    if(s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] == 0\\n                    ) revert CustomErrors.TokenNotAcceptedAsPayment();\\n                    \\n                    payment += (s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] * _amounts[i]);\\n                }\\n\\n                if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n                // Check if the user has enough balance of the payment token\\n                if(IERC20(_paymentToken).balanceOf(_user) < payment) revert CustomErrors.InsufficientBalance();\\n                uint256 _treasuryPayment = payment;\\n\\n                //Trasfer partner percentage to each partner\\n                for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    IERC20(_paymentToken).safeTransferFrom(msg.sender, s.saleId[_saleId].partners[j].partnerAddress, _partnerPayment);\\n               }\\n\\n                // Transfer the payment tokens from the user to the treasury wallet\\n                IERC20(_paymentToken).safeTransferFrom(msg.sender, s.treasuryWallet, _treasuryPayment);\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n            }\\n        }\\n    }\\n\\n    function _permit2MintFeeCheck1155(\\n        address _user, \\n        uint256[] memory _amounts, \\n        uint256[] memory _tokenIds, \\n        address _paymentToken, \\n        uint256 _saleId\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        IAllowanceTransfer permit2 = IAllowanceTransfer(s.permit2ContractAddress);\\n\\n        uint256 payment;\\n        uint256 _length = _tokenIds.length;\\n        uint256 _partnerLength = s.saleId[_saleId].partners.length;\\n        uint256 _paymentTokenIndex;\\n\\n        for(uint256 i = 0; i < s.saleId[_saleId].paymentTokensMaxSupplies.length; i++){\\n            if(s.saleId[_saleId].paymentTokensMaxSupplies[i].paymentToken == _paymentToken){\\n                _paymentTokenIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (s.treasuryWallet != address(0)) {\\n            if (address(_paymentToken) == address(0)) {\\n\\n                // Calculate the total payment amount for all the tokens being minted\\n                for(uint256 i = 0; i < _length; i++){\\n                    payment += (s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] * _amounts[i]);\\n                }\\n\\n                // Check if the user has sent enough Ether for the payment\\n               if(msg.value < payment) revert CustomErrors.InsufficientBalance();\\n               uint256 _treasuryPayment = payment;\\n\\n               if(msg.value > payment){\\n                    uint256 unusedPayment = msg.value - payment;\\n                    (bool sent, bytes memory data) = payable(msg.sender).call{value: unusedPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n               if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n               //Trasfer partner percentage to each partner\\n               for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    (bool sent, bytes memory data) = s.saleId[_saleId].partners[j].partnerAddress.call{value: _partnerPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n                // Transfer the remaining Ether to the treasury wallet\\n               (bool sent, bytes memory data) = s.treasuryWallet.call{value: _treasuryPayment}(\\\"\\\");\\n                require(sent, \\\"Failed to send Ether\\\");\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n\\n            } else {\\n\\n                // Calculate the total payment amount for all the tokens being minted\\n                for(uint256 i = 0; i < _length; i++){\\n\\n                    // Check if the payment token is accepted for each token ID\\n                    if(s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] == 0\\n                    ) revert CustomErrors.TokenNotAcceptedAsPayment();\\n                    \\n                    payment += (s.tokenIdPrice[_saleId][_paymentToken][_tokenIds[i]] * _amounts[i]);\\n                }\\n\\n                if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n                uint256 _treasuryPayment = payment;\\n\\n                //Trasfer partner percentage to each partner\\n                for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    //permit2.transferFrom(msg.sender, s.saleId[_saleId].partners[j].partnerAddress, _partnerPayment, _paymentToken);\\n               }\\n\\n                // Transfer the payment tokens from the user to the treasury wallet\\n                //permit2.transferFrom(msg.sender, s.treasuryWallet, _treasuryPayment, _paymentToken);\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n            }\\n        }\\n    }\\n\\n    function _permit2MintFeeCheck721(address _user, uint256 _amount, address _paymentToken, uint256 _saleId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        IAllowanceTransfer permit2 = IAllowanceTransfer(s.permit2ContractAddress);\\n\\n        uint256 payment;\\n        uint256 _partnerLength = s.saleId[_saleId].partners.length;\\n        uint256 _paymentTokenIndex;\\n\\n        for(uint256 i = 0; i < s.saleId[_saleId].paymentTokensMaxSupplies.length; i++){\\n            if(s.saleId[_saleId].paymentTokensMaxSupplies[i].paymentToken == _paymentToken){\\n                _paymentTokenIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (s.treasuryWallet != address(0)) {\\n            if (address(_paymentToken) == address(0)) {\\n\\n                // Calculate the payment amount based on the mint fee and the amount of tokens being minted\\n               payment = s.acceptedTokenPrice[_paymentToken][_saleId] * _amount;\\n\\n               // Check if the user has sent enough Ether for the payment\\n               if(msg.value < payment) revert CustomErrors.InsufficientBalance();\\n\\n               if(msg.value > payment){\\n                    uint256 unusedPayment = msg.value - payment;\\n                    (bool sent, bytes memory data) = payable(msg.sender).call{value: unusedPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n               uint256 _treasuryPayment = payment;\\n\\n               if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n               //Trasfer partner percentage to each partner\\n               for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    (bool sent, bytes memory data) = s.saleId[_saleId].partners[j].partnerAddress.call{value: _partnerPayment}(\\\"\\\");\\n                    require(sent, \\\"Failed to send Ether\\\");\\n               }\\n\\n                // Transfer Ether to the treasury wallet\\n               (bool sent, bytes memory data) = s.treasuryWallet.call{value: _treasuryPayment}(\\\"\\\");\\n                require(sent, \\\"Failed to send Ether\\\");\\n\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n\\n            } else {\\n\\n                // Calculate the payment amount based on the accepted token price and the amount of tokens being minted\\n                payment = s.acceptedTokenPrice[_paymentToken][_saleId] * _amount;\\n\\n                if(\\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent + payment \\n                > s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].maxAcceptedAmount\\n                ) revert CustomErrors.MaxSupplyReached();\\n\\n                // Check if the payment token is accepted and if the user has enough balance\\n                if(s.acceptedTokenPrice[_paymentToken][_saleId] == 0) revert CustomErrors.TokenNotAcceptedAsPayment();\\n                \\n                uint256 _treasuryPayment = payment;\\n\\n                //Trasfer partner percentage to each partner\\n                for(uint256 j = 0; j < _partnerLength; j++){\\n                    uint256 _partnerPayment = ((payment * s.saleId[_saleId].partners[j].sharePercentage) / 100);\\n                    _treasuryPayment -= _partnerPayment;\\n\\n                    //permit2.transferFrom(msg.sender, s.saleId[_saleId].partners[j].partnerAddress, _partnerPayment, _paymentToken);\\n               }\\n\\n                // Transfer the payment tokens from the user to the treasury wallet\\n                //permit2.transferFrom(msg.sender, s.treasuryWallet, _treasuryPayment, _paymentToken);\\n                \\n                s.saleId[_saleId].paymentTokensMaxSupplies[_paymentTokenIndex].totalSpent += payment;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Sets the treasury wallet address.\\n    * @param _treasuryWallet The address of the treasury wallet.\\n    */\\n    function _setTreasuryWallet(address _treasuryWallet) internal{\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.treasuryWallet = _treasuryWallet;\\n    }\\n\\n    function _setPermit2Wallet(address _permit2Address) internal{\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.permit2ContractAddress = _permit2Address;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nlibrary LibMeta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"));\\n\\n    function domainSeparator(string memory name, string memory version) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), getChainID(), address(this))\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllowanceTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IEIP712} from \\\"contracts/interfaces/IEIP712.sol\\\";\\n\\n/// @title AllowanceTransfer\\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface IAllowanceTransfer is IEIP712 {\\n    /// @notice Thrown when an allowance on a token has expired.\\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\\n    error AllowanceExpired(uint256 deadline);\\n\\n    /// @notice Thrown when an allowance on a token has been depleted.\\n    /// @param amount The maximum amount allowed\\n    error InsufficientAllowance(uint256 amount);\\n\\n    /// @notice Thrown when too many nonces are invalidated.\\n    error ExcessiveInvalidation();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\\n    event NonceInvalidation(\\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\\n    );\\n\\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\\n    event Approval(\\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\\n    );\\n\\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\\n    event Permit(\\n        address indexed owner,\\n        address indexed token,\\n        address indexed spender,\\n        uint160 amount,\\n        uint48 expiration,\\n        uint48 nonce\\n    );\\n\\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\\n    event Lockdown(address indexed owner, address token, address spender);\\n\\n    /// @notice The permit data for a token\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice The permit message signed for a single token allowance\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The permit message signed for multiple token allowances\\n    struct PermitBatch {\\n        // the permit data for multiple token allowances\\n        PermitDetails[] details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The saved permissions\\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice A token spender pair.\\n    struct TokenSpenderPair {\\n        // the token the spender is approved\\n        address token;\\n        // the spender address\\n        address spender;\\n    }\\n\\n    /// @notice Details for a token transfer.\\n    struct AllowanceTransferDetails {\\n        // the owner of the token\\n        address from;\\n        // the recipient of the token\\n        address to;\\n        // the amount of the token\\n        uint160 amount;\\n        // the token to be transferred\\n        address token;\\n    }\\n\\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\\n    function allowance(address user, address token, address spender)\\n        external\\n        view\\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\\n\\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\\n    /// @param token The token to approve\\n    /// @param spender The spender address to approve\\n    /// @param amount The approved amount of the token\\n    /// @param expiration The timestamp at which the approval is no longer valid\\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n\\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\\n\\n    /// @notice Transfer approved tokens from one address to another\\n    /// @param from The address to transfer from\\n    /// @param to The address of the recipient\\n    /// @param amount The amount of the token to transfer\\n    /// @param token The token address to transfer\\n    /// @dev Requires the from address to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(address from, address to, uint160 amount, address token) external;\\n\\n    /// @notice Transfer approved tokens in a batch\\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\\n    /// @dev Requires the from addresses to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\\n\\n    /// @notice Enables performing a \\\"lockdown\\\" of the sender's Permit2 identity\\n    /// by batch revoking approvals\\n    /// @param approvals Array of approvals to revoke.\\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\\n\\n    /// @notice Invalidate nonces for a given (token, spender) pair\\n    /// @param token The token to invalidate nonces for\\n    /// @param spender The spender to invalidate nonces for\\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEIP712 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArrayLengthsDiffer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseURINotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimPeriodTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CurrentlyNotClaimPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DesiredIdNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERCTypeIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectHotWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPartnerSharePct\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPartnerWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MsgSenderIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoConfirmedIds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartnerActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartnerAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartnerDeactivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartnerNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TierLengthTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TierNumberIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TierPeriodHasEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TierPeriodHasntStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIsSoulbound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotAcceptedAsPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyGreaterThanMaxSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WarmLinkExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"setTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PaymentLogicFacet", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}