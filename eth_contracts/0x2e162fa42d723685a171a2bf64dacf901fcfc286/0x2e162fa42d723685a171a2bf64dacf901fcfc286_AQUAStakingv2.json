{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() private view {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() external onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() private view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\ncontract AQUAStakingv2 is Ownable, ReentrancyGuard {\r\n    struct PoolInfo {\r\n        uint256 lockupDuration;\r\n        uint256 returnPer;\r\n    }\r\n    struct OrderInfo {\r\n        address beneficiary;\r\n        uint256 amount;\r\n        uint256 lockupDuration;\r\n        uint256 returnPer;\r\n        uint256 starttime;\r\n        uint256 endtime;\r\n        uint256 claimedReward;\r\n        bool claimed;\r\n    }\r\n    uint256 private constant _1Year =  365 days ; \r\n    uint256 private constant _days365 = 365 days; \r\n    IERC20 public AQUA;\r\n    IERC20 public sAQUA;\r\n\r\n    bool private started = true;\r\n    uint256 private latestOrderId = 0;\r\n    uint256 public totalStakers;\r\n    uint256 public totalStaked;\r\n    uint256 public currentStaked;\r\n\r\n    mapping(uint256 => PoolInfo) public pooldata;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => uint256) public totalRewardEarn;\r\n    mapping(uint256 => OrderInfo) public orders;\r\n    mapping(address => uint256[]) private orderIds;\r\n    mapping(address => mapping(uint256 => bool)) public hasStaked;\r\n    mapping(uint256 => uint256) public stakeOnPool;\r\n    mapping(uint256 => uint256) public rewardOnPool;\r\n    mapping(uint256 => uint256) public stakersPlan;\r\n\r\n    event Deposit(\r\n        address indexed user,\r\n        uint256 indexed lockupDuration,\r\n        uint256 amount,\r\n        uint256 returnPer\r\n    );\r\n    event Withdraw(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 reward,\r\n        uint256 total\r\n    );\r\n    event WithdrawAll(address indexed user, uint256 amount);\r\n    event RewardClaimed(address indexed user, uint256 reward);\r\n\r\n    constructor(\r\n        address _aquaAddress,\r\n        address _saquaAddress,\r\n        uint256 _apy\r\n    ) {\r\n        AQUA = IERC20(_aquaAddress);\r\n        sAQUA = IERC20(_saquaAddress);\r\n        pooldata[1].lockupDuration = _1Year;\r\n        pooldata[1].returnPer = _apy;\r\n    }\r\n\r\n    function stake(uint256 _amount, uint256 _lockupDuration) external {\r\n        PoolInfo storage pool = pooldata[_lockupDuration];\r\n        require(\r\n            pool.lockupDuration > 0,\r\n            \"AQUAStaking: asked pool does not exist\"\r\n        );\r\n        require(started, \"AQUAStaking: staking not yet started\");\r\n        require(_amount > 0, \"AQUAStaking: stake amount must be non zero\");\r\n        require(\r\n            AQUA.transferFrom(_msgSender(), address(this), _amount),\r\n            \"AQUAStaking: AQUA transferFrom via deposit not succeeded\"\r\n        );\r\n\r\n        orders[++latestOrderId] = OrderInfo(\r\n            _msgSender(),\r\n            _amount,\r\n            pool.lockupDuration,\r\n            pool.returnPer,\r\n            block.timestamp,\r\n            block.timestamp + pool.lockupDuration,\r\n            0,\r\n            false\r\n        );\r\n\r\n        if (!hasStaked[msg.sender][_lockupDuration]) {\r\n            stakersPlan[_lockupDuration] = stakersPlan[_lockupDuration] + 1;\r\n            totalStakers = totalStakers + 1;\r\n        }\r\n\r\n        //updating staking status\r\n\r\n        hasStaked[msg.sender][_lockupDuration] = true;\r\n        stakeOnPool[_lockupDuration] = stakeOnPool[_lockupDuration] + _amount;\r\n        totalStaked = totalStaked + _amount;\r\n        currentStaked = currentStaked + _amount;\r\n        balanceOf[_msgSender()] += _amount;\r\n        orderIds[_msgSender()].push(latestOrderId);\r\n        emit Deposit(\r\n            _msgSender(),\r\n            pool.lockupDuration,\r\n            _amount,\r\n            pool.returnPer\r\n        );\r\n    }\r\n\r\n    function unStake(uint256 orderId) external nonReentrant {\r\n        require(\r\n            orderId <= latestOrderId,\r\n            \"AQUAStaking: INVALID orderId, orderId greater than latestOrderId\"\r\n        );\r\n\r\n        OrderInfo storage orderInfo = orders[orderId];\r\n        require(\r\n            _msgSender() == orderInfo.beneficiary,\r\n            \"AQUAStaking: caller is not the beneficiary\"\r\n        );\r\n        require(!orderInfo.claimed, \"AQUAStaking: order already unstaked\");\r\n        uint256 total = orderInfo.amount ;\r\n        balanceOf[_msgSender()] -= orderInfo.amount;\r\n        currentStaked = currentStaked - orderInfo.amount ;\r\n        orderInfo.claimed = true;\r\n\r\n        require(\r\n            AQUA.transfer(address(_msgSender()), total),\r\n            \"AQUAStaking: AQUA transfer via withdraw not succeeded\"\r\n        );\r\n        emit Withdraw(_msgSender(), orderInfo.amount, total, total);\r\n    }\r\n\r\n    function claimRewards(uint256 orderId) external nonReentrant {\r\n        require(\r\n            orderId <= latestOrderId,\r\n            \"AQUAStaking: INVALID orderId, orderId greater than latestOrderId\"\r\n        );\r\n\r\n        OrderInfo storage orderInfo = orders[orderId];\r\n        require(\r\n            _msgSender() == orderInfo.beneficiary,\r\n            \"AQUAStaking: caller is not the beneficiary\"\r\n        );\r\n\r\n        uint256 claimAvailable = pendingRewards(orderId);\r\n        totalRewardEarn[_msgSender()] += claimAvailable;\r\n\r\n        orderInfo.claimedReward += claimAvailable;\r\n\r\n        require(\r\n            sAQUA.transfer(address(_msgSender()), claimAvailable),\r\n            \"AQUAStaking: sAQUA transfer via claim rewards not succeeded\"\r\n        );\r\n        rewardOnPool[orderInfo.lockupDuration] =\r\n            rewardOnPool[orderInfo.lockupDuration] +\r\n            claimAvailable;\r\n        emit RewardClaimed(address(_msgSender()), claimAvailable);\r\n    }\r\n\r\n    function pendingRewards(uint256 orderId) public view returns (uint256) {\r\n        require(\r\n            orderId <= latestOrderId,\r\n            \"AQUAStaking: INVALID orderId, orderId greater than latestOrderId\"\r\n        );\r\n\r\n        OrderInfo storage orderInfo = orders[orderId];\r\n        if (!orderInfo.claimed) {\r\n            if (block.timestamp >= orderInfo.endtime) {\r\n                uint256 APY = (orderInfo.amount * orderInfo.returnPer) / 100;\r\n                uint256 reward = (APY * orderInfo.lockupDuration) / _days365;\r\n                uint256 claimAvailable = reward - orderInfo.claimedReward;\r\n                return claimAvailable;\r\n            } else {\r\n                uint256 stakeTime = block.timestamp - orderInfo.starttime;\r\n                uint256 APY = (orderInfo.amount * orderInfo.returnPer) / 100;\r\n                uint256 reward = (APY * stakeTime) / _days365;\r\n                uint256 claimAvailableNow = reward - orderInfo.claimedReward;\r\n                return claimAvailableNow;\r\n            }\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function setPlansApy(uint256 plan1Apy) external onlyOwner {\r\n        pooldata[1].returnPer = plan1Apy;\r\n    }\r\n\r\n    function toggleStaking(bool _start) external onlyOwner returns (bool) {\r\n        started = _start;\r\n        return true;\r\n    }\r\n\r\n    function investorOrderIds(address investor)\r\n        external\r\n        view\r\n        returns (uint256[] memory ids)\r\n    {\r\n        uint256[] memory arr = orderIds[investor];\r\n        return arr;\r\n    }\r\n\r\n    function withdrawERC20(address _token) external onlyOwner {\r\n        IERC20 withdraw_token = IERC20(_token);\r\n        uint256 balance = withdraw_token.balanceOf(address(this));\r\n        uint256 withdrawToken = balance - currentStaked ;\r\n        require(\r\n            withdraw_token.transfer(msg.sender, withdrawToken),\r\n            \"withdraw_token transfer failed\"\r\n        );\r\n    }\r\n\r\n\r\n   function withdrawAllTokens() external nonReentrant {\r\n    uint256[] storage userOrderIds = orderIds[_msgSender()];\r\n    uint256 totalStakedAmount;\r\n\r\n    for (uint256 i = 0; i < userOrderIds.length; i++) {\r\n        uint256 orderId = userOrderIds[i];\r\n        OrderInfo storage orderInfo = orders[orderId];\r\n\r\n        // Ensure order is not already unstaked\r\n        require(!orderInfo.claimed, \"AQUAStaking: order already unstaked\");\r\n\r\n       \r\n        \r\n        totalStakedAmount += orderInfo.amount;\r\n\r\n        // Mark order as claimed\r\n        orderInfo.claimed = true;\r\n\r\n        // Emit event for tokens withdrawn\r\n        emit Withdraw(_msgSender(), orderInfo.amount, orderInfo.amount, orderInfo.amount);\r\n    }\r\n\r\n    // Transfer total staked amount back to user\r\n      \r\n    require(\r\n        AQUA.transfer(_msgSender(), totalStakedAmount),\r\n        \"AQUAStaking: AQUA transfer via withdraw not succeeded\"\r\n    );\r\n\r\n    currentStaked = currentStaked - totalStakedAmount;\r\n    balanceOf[_msgSender()] -= totalStakedAmount;\r\n\r\n    // Emit event for successful withdrawal\r\n    emit WithdrawAll(_msgSender(), totalStakedAmount);\r\n}\r\n\r\n  function claimAllRemainingRewards() external nonReentrant {\r\n    uint256[] storage userOrderIds = orderIds[_msgSender()];\r\n    uint256 totalRewards;\r\n\r\n    for (uint256 i = 0; i < userOrderIds.length; i++) {\r\n        uint256 orderId = userOrderIds[i];\r\n        OrderInfo storage orderInfo = orders[orderId];\r\n\r\n        // Ensure order is not already claimed\r\n        require(!orderInfo.claimed, \"AQUAStaking: order already claimed\");\r\n\r\n        // Calculate and accumulate remaining rewards\r\n        uint256 claimAvailable = pendingRewards(orderId);\r\n        totalRewards += claimAvailable;\r\n        orderInfo.claimedReward += claimAvailable;\r\n        rewardOnPool[orderInfo.lockupDuration] += claimAvailable;\r\n\r\n        // Emit event for reward claimed\r\n        emit RewardClaimed(_msgSender(), claimAvailable);\r\n    }\r\n\r\n    // Transfer total rewards to user\r\n    require(\r\n        sAQUA.transfer(_msgSender(), totalRewards),\r\n        \"AQUAStaking: sAQUA transfer via claim rewards not succeeded\"\r\n    );\r\n\r\n    // Emit event for successful reward claim\r\n    emit RewardClaimed(_msgSender(), totalRewards);\r\n}\r\n\r\nfunction viewTotalPendingRewards(address user) external view returns (uint256) {\r\n    uint256[] storage userOrderIds = orderIds[user];\r\n    uint256 totalPendingRewards;\r\n\r\n    for (uint256 i = 0; i < userOrderIds.length; i++) {\r\n        uint256 orderId = userOrderIds[i];\r\n        totalPendingRewards += pendingRewards(orderId);\r\n    }\r\n\r\n    return totalPendingRewards;\r\n}\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aquaAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_saquaAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnPer\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAll\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AQUA\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllRemainingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"investorOrderIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnPer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pooldata\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnPer\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardOnPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sAQUA\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"plan1Apy\",\"type\":\"uint256\"}],\"name\":\"setPlansApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockupDuration\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeOnPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakersPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_start\",\"type\":\"bool\"}],\"name\":\"toggleStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewardEarn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewTotalPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AQUAStakingv2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000012f9a180198d91f854f3ca23caf8be1c83ef3b760000000000000000000000004ea095f97d6eb0a8d57a5e9443fd97d63cecef730000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5cd2782d8f99482d0415753c9f6c7bd9a622ab22dc3a0b01b0648689741f29f3"}