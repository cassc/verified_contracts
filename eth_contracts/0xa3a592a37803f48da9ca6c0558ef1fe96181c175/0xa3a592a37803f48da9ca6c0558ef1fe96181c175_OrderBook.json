{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal onlyInitializing {\\n    }\\n\\n    function __Multicall_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interpreter/deploy/DeployerDiscoverableMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"sol.metadata/IMetaV1.sol\\\";\\nimport \\\"sol.metadata/LibMeta.sol\\\";\\nimport \\\"./LibDeployerDiscoverable.sol\\\";\\n\\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV1\\n/// @notice Checks metadata against a known hash, emits it then touches the\\n/// deployer (deploy an empty expression). This allows indexers to discover the\\n/// metadata of the `DeployerDiscoverableMetaV1` contract by indexing the\\n/// deployer. In this way the deployer acts as a pseudo-registry by virtue of it\\n/// being a natural hub for interactions.\\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\\n    constructor(\\n        bytes32 metaHash_,\\n        DeployerDiscoverableMetaV1ConstructionConfig memory config_\\n    ) {\\n        LibMeta.checkMetaHashed(metaHash_, config_.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config_.meta);\\n        LibDeployerDiscoverable.touchDeployer(config_.deployer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interpreter/deploy/LibDeployerDiscoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.17;\\n\\nimport \\\"rain.interface.interpreter/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployer(address deployer_) internal {\\n        IExpressionDeployerV1(deployer_).deployExpression(\\n            new bytes[](0),\\n            new uint256[](0),\\n            new uint256[](0)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/LibFixedPointMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"rain.math.fixedpoint/FixedPointDecimalConstants.sol\\\";\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n///\\n/// Overflows SATURATE rather than error, e.g. scaling max uint256 up will result\\n/// in max uint256. The max uint256 as decimal is roughly 1e77 so scaling values\\n/// comparable to 1e18 is unlikely to ever saturate in practise. For a typical\\n/// use case involving tokens, the entire supply of a token rescaled up a full\\n/// 18 decimals would still put it \\\"only\\\" in the region of ~1e40 which has a full\\n/// 30 orders of magnitude buffer before running into saturation issues. However,\\n/// there's no theoretical reason that a token or any other use case couldn't use\\n/// large numbers or extremely precise decimals that would push this library to\\n/// saturation point, so it MUST be treated with caution around the edge cases.\\n///\\n/// One case where values could come near the saturation/overflow point is phantom\\n/// overflow. This is where an overflow happens during the internal logic of some\\n/// operation like \\\"fixed point multiplication\\\" even though the final result fits\\n/// within uint256. The fixed point multiplication and division functions are\\n/// thin wrappers around Open Zeppelin's `mulDiv` function, that handles phantom\\n/// overflow, reducing the problems of rescaling overflow/saturation to the input\\n/// and output range rather than to the internal implementation details. For this\\n/// library that gives an additional full 18 orders of magnitude for safe fixed\\n/// point multiplication operations.\\n///\\n/// Scaling down ANY fixed point decimal also reduces the precision which can\\n/// lead to  dust or in the worst case trapped funds if subsequent subtraction\\n/// overflows a rounded-down number. Consider using saturating subtraction for\\n/// safety against previously downscaled values, and whether trapped dust is a\\n/// significant issue. If you need to retain full/arbitrary precision in the case\\n/// of downscaling DO NOT use this library.\\n///\\n/// All rescaling and/or division operations in this library require the rounding\\n/// flag from Open Zeppelin math. This allows and forces the caller to specify\\n/// where dust sits due to rounding. For example the caller could round up when\\n/// taking tokens from `msg.sender` and round down when returning them, ensuring\\n/// that any dust in the round trip accumulates in the contract rather than\\n/// opening an exploit or reverting and trapping all funds. This is exactly how\\n/// the ERC4626 vault spec handles dust and is a good reference point in general.\\n/// Typically the contract holding tokens and non-interactive participants should\\n/// be favoured by rounding calculations rather than active participants. This is\\n/// because we assume that an active participant, e.g. `msg.sender`, knowns\\n/// something we don't and is carefully crafting an attack, so we are most\\n/// conservative and suspicious of their inputs and actions.\\nlibrary LibFixedPointMath {\\n    using Math for uint256;\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @param rounding_ Rounding direction as per Open Zeppelin Math.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FIXED_POINT_ONE, rounding_);\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @param rounding_ Rounding direction as per Open Zeppelin Math.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FIXED_POINT_ONE, b_, rounding_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/orderbook/LibOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"rain.interface.orderbook/IOrderBookV2.sol\\\";\\n\\n/// @title LibOrder\\n/// @notice Consistent handling of `Order` for where it matters w.r.t.\\n/// determinism and security.\\nlibrary LibOrder {\\n    /// Hashes `Order` in a secure and deterministic way. Uses abi.encode rather\\n    /// than abi.encodePacked to guard against potential collisions where many\\n    /// inputs encode to the same output bytes.\\n    /// @param order_ The order to hash.\\n    /// @return The hash of `order_` as a `uint256` rather than `bytes32`.\\n    function hash(Order memory order_) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(order_)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/orderbook/LibOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"rain.interface.interpreter/IInterpreterStoreV1.sol\\\";\\nimport \\\"rain.interface.orderbook/IOrderBookV2.sol\\\";\\nimport \\\"../math/LibFixedPointMath.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\n/// All information resulting from an order calculation that allows for vault IO\\n/// to be calculated and applied, then the handle IO entrypoint to be dispatched.\\n/// @param outputMax The UNSCALED maximum output calculated by the order\\n/// expression. WILL BE RESCALED ACCORDING TO TOKEN DECIMALS to an 18 fixed\\n/// point decimal number for the purpose of calculating actual vault movements.\\n/// The output max is CAPPED AT THE OUTPUT VAULT BALANCE OF THE ORDER OWNER.\\n/// The order is guaranteed that the total output of this single clearance cannot\\n/// exceed this (subject to rescaling). It is up to the order expression to track\\n/// values over time if the output max is to impose a global limit across many\\n/// transactions and counterparties.\\n/// @param IORatio The UNSCALED order ratio as input/output from the perspective\\n/// of the order. As each counterparty's input is the other's output, the IORatio\\n/// calculated by each order is inverse of its counterparty. IORatio is SCALED\\n/// ACCORDING TO TOKEN DECIMALS to allow 18 decimal fixed point math over the\\n/// vault balances. I.e. `1e18` returned from the expression is ALWAYS \\\"one\\\" as\\n/// ECONOMIC EQUIVALENCE between two tokens, but this will be rescaled according\\n/// to the decimals of the token. For example, if DAI and USDT have a ratio of\\n/// `1e18` then in reality `1e12` DAI will move in the vault for every `1` USDT\\n/// that moves, because DAI has `1e18` decimals per $1 peg and USDT has `1e6`\\n/// decimals per $1 peg. THE ORDER DEFINES THE DECIMALS for each token, NOT the\\n/// token itself, because the token MAY NOT report its decimals as per it being\\n/// optional in the ERC20 specification.\\n/// @param context The entire 2D context array, initialized from the context\\n/// passed into the order calculations and then populated with the order\\n/// calculations and vault IO before being passed back to handle IO entrypoint.\\n/// @param namespace The `StateNamespace` to be passed to the store for calculate\\n/// IO state changes.\\n/// @param kvs KVs returned from calculate order entrypoint to pass to the store\\n/// before calling handle IO entrypoint.\\nstruct OrderIOCalculation {\\n    uint256 outputMax;\\n    //solhint-disable-next-line var-name-mixedcase\\n    uint256 IORatio;\\n    uint256[][] context;\\n    StateNamespace namespace;\\n    uint256[] kvs;\\n}\\n\\nlibrary LibOrderBook {\\n    using LibFixedPointMath for uint256;\\n    using Math for uint256;\\n\\n    /// Calculates the clear state change given both order calculations for order\\n    /// alice and order bob. The input of each is their output multiplied by\\n    /// their IO ratio and the output of each is the smaller of their maximum\\n    /// output and the counterparty IO * max output.\\n    /// @param aliceOrderIOCalculation_ Order calculation A.\\n    /// @param bobOrderIOCalculation_ Order calculation B.\\n    /// @return The clear state change with absolute inputs and outputs for A and\\n    /// B.\\n    function _clearStateChange(\\n        OrderIOCalculation memory aliceOrderIOCalculation_,\\n        OrderIOCalculation memory bobOrderIOCalculation_\\n    ) internal pure returns (ClearStateChange memory) {\\n        ClearStateChange memory clearStateChange_;\\n        {\\n            clearStateChange_.aliceOutput = aliceOrderIOCalculation_\\n                .outputMax\\n                .min(\\n                    // B's input is A's output.\\n                    // A cannot output more than their max.\\n                    // B wants input of their IO ratio * their output.\\n                    // Always round IO calculations up.\\n                    bobOrderIOCalculation_.outputMax.fixedPointMul(\\n                        bobOrderIOCalculation_.IORatio,\\n                        Math.Rounding.Up\\n                    )\\n                );\\n            clearStateChange_.bobOutput = bobOrderIOCalculation_.outputMax.min(\\n                // A's input is B's output.\\n                // B cannot output more than their max.\\n                // A wants input of their IO ratio * their output.\\n                // Always round IO calculations up.\\n                aliceOrderIOCalculation_.outputMax.fixedPointMul(\\n                    aliceOrderIOCalculation_.IORatio,\\n                    Math.Rounding.Up\\n                )\\n            );\\n\\n            // A's input is A's output * their IO ratio.\\n            // Always round IO calculations up.\\n            clearStateChange_.aliceInput = clearStateChange_\\n                .aliceOutput\\n                .fixedPointMul(\\n                    aliceOrderIOCalculation_.IORatio,\\n                    Math.Rounding.Up\\n                );\\n            // B's input is B's output * their IO ratio.\\n            // Always round IO calculations up.\\n            clearStateChange_.bobInput = clearStateChange_\\n                .bobOutput\\n                .fixedPointMul(\\n                    bobOrderIOCalculation_.IORatio,\\n                    Math.Rounding.Up\\n                );\\n        }\\n        return clearStateChange_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/orderbook/OrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"rain.interface.orderbook/IOrderBookV2.sol\\\";\\nimport \\\"./LibOrder.sol\\\";\\nimport \\\"../math/LibFixedPointMath.sol\\\";\\nimport \\\"rain.math.fixedpoint/FixedPointDecimalScale.sol\\\";\\nimport \\\"./OrderBookFlashLender.sol\\\";\\nimport \\\"rain.interface.interpreter/LibEncodedDispatch.sol\\\";\\nimport \\\"rain.interface.interpreter/LibContext.sol\\\";\\nimport \\\"../interpreter/deploy/DeployerDiscoverableMetaV1.sol\\\";\\nimport \\\"./LibOrderBook.sol\\\";\\n\\nimport {MulticallUpgradeable as Multicall} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/// Thrown when the `msg.sender` modifying an order is not its owner.\\n/// @param sender `msg.sender` attempting to modify the order.\\n/// @param owner The owner of the order.\\nerror NotOrderOwner(address sender, address owner);\\n\\n/// Thrown when the input and output tokens don't match, in either direction.\\n/// @param aliceToken The input or output of one order.\\n/// @param bobToken The input or output of the other order that doesn't match a.\\nerror TokenMismatch(address aliceToken, address bobToken);\\n\\n/// Thrown when the minimum input is not met.\\n/// @param minimumInput The minimum input required.\\n/// @param input The input that was achieved.\\nerror MinimumInput(uint256 minimumInput, uint256 input);\\n\\n/// Thrown when two orders have the same owner during clear.\\n/// @param owner The owner of both orders.\\nerror SameOwner(address owner);\\n\\n/// @dev Hash of the caller contract metadata for construction.\\nbytes32 constant CALLER_META_HASH = bytes32(\\n    0x56ffc3fc82109c33f1e1544157a70144fc15e7c6e9ae9c65a636fd165b1bc51c\\n);\\n\\n/// @dev Value that signifies that an order is live in the internal mapping.\\n/// Anything nonzero is equally useful.\\nuint256 constant LIVE_ORDER = 1;\\n\\n/// @dev Value that signifies that an order is dead in the internal mapping.\\nuint256 constant DEAD_ORDER = 0;\\n\\n/// @dev Entrypoint to a calculate the amount and ratio of an order.\\nSourceIndex constant CALCULATE_ORDER_ENTRYPOINT = SourceIndex.wrap(0);\\n/// @dev Entrypoint to handle the final internal vault movements resulting from\\n/// matching multiple calculated orders.\\nSourceIndex constant HANDLE_IO_ENTRYPOINT = SourceIndex.wrap(1);\\n\\n/// @dev Minimum outputs for calculate order are the amount and ratio.\\nuint256 constant CALCULATE_ORDER_MIN_OUTPUTS = 2;\\n/// @dev Maximum outputs for calculate order are the amount and ratio.\\nuint16 constant CALCULATE_ORDER_MAX_OUTPUTS = 2;\\n\\n/// @dev Handle IO has no outputs as it only responds to vault movements.\\nuint256 constant HANDLE_IO_MIN_OUTPUTS = 0;\\n/// @dev Handle IO has no outputs as it only response to vault movements.\\nuint16 constant HANDLE_IO_MAX_OUTPUTS = 0;\\n\\n/// @dev Orderbook context is actually fairly complex. The calling context column\\n/// is populated before calculate order, but the remaining columns are only\\n/// available to handle IO as they depend on the full evaluation of calculuate\\n/// order, and cross referencing against the same from the counterparty, as well\\n/// as accounting limits such as current vault balances, etc.\\n/// The token address and decimals for vault inputs and outputs IS available to\\n/// the calculate order entrypoint, but not the final vault balances/diff.\\nuint256 constant CALLING_CONTEXT_COLUMNS = 4;\\n/// @dev Base context from LibContext.\\nuint256 constant CONTEXT_BASE_COLUMN = 0;\\n\\n/// @dev Contextual data available to both calculate order and handle IO. The\\n/// order hash, order owner and order counterparty. IMPORTANT NOTE that the\\n/// typical base context of an order with the caller will often be an unrelated\\n/// clearer of the order rather than the owner or counterparty.\\nuint256 constant CONTEXT_CALLING_CONTEXT_COLUMN = 1;\\n/// @dev Calculations column contains the DECIMAL RESCALED calculations but\\n/// otherwise provided as-is according to calculate order entrypoint\\nuint256 constant CONTEXT_CALCULATIONS_COLUMN = 2;\\n/// @dev Vault inputs are the literal token amounts and vault balances before and\\n/// after for the input token from the perspective of the order. MAY be\\n/// significantly different to the calculated amount due to insufficient vault\\n/// balances from either the owner or counterparty, etc.\\nuint256 constant CONTEXT_VAULT_INPUTS_COLUMN = 3;\\n/// @dev Vault outputs are the same as vault inputs but for the output token from\\n/// the perspective of the order.\\nuint256 constant CONTEXT_VAULT_OUTPUTS_COLUMN = 4;\\n\\n/// @dev Row of the token address for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_TOKEN = 0;\\n/// @dev Row of the token decimals for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_TOKEN_DECIMALS = 1;\\n/// @dev Row of the vault ID for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_VAULT_ID = 2;\\n/// @dev Row of the vault balance before the order was cleared for vault inputs\\n/// and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_BALANCE_BEFORE = 3;\\n/// @dev Row of the vault balance difference after the order was cleared for\\n/// vault inputs and outputs columns. The diff is ALWAYS POSITIVE as it is a\\n/// `uint256` so it must be added to input balances and subtraced from output\\n/// balances.\\nuint256 constant CONTEXT_VAULT_IO_BALANCE_DIFF = 4;\\n/// @dev Length of a vault IO column.\\nuint256 constant CONTEXT_VAULT_IO_ROWS = 5;\\n\\n/// @title OrderBook\\n/// See `IOrderBookV1` for more documentation.\\ncontract OrderBook is\\n    IOrderBookV2,\\n    ReentrancyGuard,\\n    Multicall,\\n    OrderBookFlashLender,\\n    DeployerDiscoverableMetaV1\\n{\\n    using LibUint256Array for uint256[];\\n    using SafeERC20 for IERC20;\\n    using Math for uint256;\\n    using LibFixedPointMath for uint256;\\n    using FixedPointDecimalScale for uint256;\\n    using LibOrder for Order;\\n    using LibUint256Array for uint256;\\n\\n    /// All hashes of all active orders. There's nothing interesting in the value\\n    /// it's just nonzero if the order is live. The key is the hash of the order.\\n    /// Removing an order sets the value back to zero so it is identical to the\\n    /// order never existing and gives a gas refund on removal.\\n    /// The order hash includes its owner so there's no need to build a multi\\n    /// level mapping, each order hash MUST uniquely identify the order globally.\\n    /// order hash => order is live\\n    mapping(uint256 => uint256) internal orders;\\n\\n    /// @inheritdoc IOrderBookV2\\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\\n        public vaultBalance;\\n\\n    /// Initializes the orderbook upon construction for compatibility with\\n    /// Open Zeppelin upgradeable contracts. Orderbook itself does NOT support\\n    /// factory deployments as each order is a unique expression deployment\\n    /// rather than needing to wrap up expressions with proxies.\\n    constructor(\\n        DeployerDiscoverableMetaV1ConstructionConfig memory config_\\n    ) initializer DeployerDiscoverableMetaV1(CALLER_META_HASH, config_) {\\n        __ReentrancyGuard_init();\\n        __Multicall_init();\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function deposit(DepositConfig calldata config_) external nonReentrant {\\n        // It is safest with vault deposits to move tokens in to the Orderbook\\n        // before updating internal vault balances although we have a reentrancy\\n        // guard in place anyway.\\n        emit Deposit(msg.sender, config_);\\n        IERC20(config_.token).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            config_.amount\\n        );\\n        vaultBalance[msg.sender][config_.token][config_.vaultId] += config_\\n            .amount;\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function withdraw(WithdrawConfig calldata config_) external nonReentrant {\\n        uint256 vaultBalance_ = vaultBalance[msg.sender][config_.token][\\n            config_.vaultId\\n        ];\\n        uint256 withdrawAmount_ = config_.amount.min(vaultBalance_);\\n        // The overflow check here is redundant with .min above, so technically\\n        // this is overly conservative but we REALLY don't want withdrawals to\\n        // exceed vault balances.\\n        vaultBalance[msg.sender][config_.token][config_.vaultId] =\\n            vaultBalance_ -\\n            withdrawAmount_;\\n        emit Withdraw(msg.sender, config_, withdrawAmount_);\\n        _decreaseFlashDebtThenSendToken(\\n            config_.token,\\n            msg.sender,\\n            withdrawAmount_\\n        );\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function addOrder(OrderConfig calldata config_) external nonReentrant {\\n        (\\n            IInterpreterV1 interpreter_,\\n            IInterpreterStoreV1 store_,\\n            address expression_\\n        ) = config_.evaluableConfig.deployer.deployExpression(\\n                config_.evaluableConfig.sources,\\n                config_.evaluableConfig.constants,\\n                LibUint256Array.arrayFrom(\\n                    CALCULATE_ORDER_MIN_OUTPUTS,\\n                    HANDLE_IO_MIN_OUTPUTS\\n                )\\n            );\\n        Order memory order_ = Order(\\n            msg.sender,\\n            config_\\n                .evaluableConfig\\n                .sources[SourceIndex.unwrap(HANDLE_IO_ENTRYPOINT)]\\n                .length > 0,\\n            Evaluable(interpreter_, store_, expression_),\\n            config_.validInputs,\\n            config_.validOutputs\\n        );\\n        uint256 orderHash_ = order_.hash();\\n\\n        orders[orderHash_] = LIVE_ORDER;\\n        emit AddOrder(\\n            msg.sender,\\n            config_.evaluableConfig.deployer,\\n            order_,\\n            orderHash_\\n        );\\n\\n        if (config_.meta.length > 0) {\\n            LibMeta.checkMetaUnhashed(config_.meta);\\n            emit MetaV1(msg.sender, orderHash_, config_.meta);\\n        }\\n    }\\n\\n    function _calculateOrderDispatch(\\n        address expression_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            LibEncodedDispatch.encode(\\n                expression_,\\n                CALCULATE_ORDER_ENTRYPOINT,\\n                CALCULATE_ORDER_MAX_OUTPUTS\\n            );\\n    }\\n\\n    function _handleIODispatch(\\n        address expression_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            LibEncodedDispatch.encode(\\n                expression_,\\n                HANDLE_IO_ENTRYPOINT,\\n                HANDLE_IO_MAX_OUTPUTS\\n            );\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function removeOrder(Order calldata order_) external nonReentrant {\\n        if (msg.sender != order_.owner) {\\n            revert NotOrderOwner(msg.sender, order_.owner);\\n        }\\n        uint256 orderHash_ = order_.hash();\\n        delete (orders[orderHash_]);\\n        emit RemoveOrder(msg.sender, order_, orderHash_);\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function takeOrders(\\n        TakeOrdersConfig calldata takeOrders_\\n    )\\n        external\\n        nonReentrant\\n        returns (uint256 totalInput_, uint256 totalOutput_)\\n    {\\n        uint256 i_ = 0;\\n        TakeOrderConfig memory takeOrder_;\\n        Order memory order_;\\n        uint256 remainingInput_ = takeOrders_.maximumInput;\\n        while (i_ < takeOrders_.orders.length && remainingInput_ > 0) {\\n            takeOrder_ = takeOrders_.orders[i_];\\n            order_ = takeOrder_.order;\\n            uint256 orderHash_ = order_.hash();\\n            if (orders[orderHash_] == DEAD_ORDER) {\\n                emit OrderNotFound(msg.sender, order_.owner, orderHash_);\\n            } else {\\n                if (\\n                    order_.validInputs[takeOrder_.inputIOIndex].token !=\\n                    takeOrders_.output\\n                ) {\\n                    revert TokenMismatch(\\n                        order_.validInputs[takeOrder_.inputIOIndex].token,\\n                        takeOrders_.output\\n                    );\\n                }\\n                if (\\n                    order_.validOutputs[takeOrder_.outputIOIndex].token !=\\n                    takeOrders_.input\\n                ) {\\n                    revert TokenMismatch(\\n                        order_.validOutputs[takeOrder_.outputIOIndex].token,\\n                        takeOrders_.input\\n                    );\\n                }\\n\\n                OrderIOCalculation\\n                    memory orderIOCalculation_ = _calculateOrderIO(\\n                        order_,\\n                        takeOrder_.inputIOIndex,\\n                        takeOrder_.outputIOIndex,\\n                        msg.sender,\\n                        takeOrder_.signedContext\\n                    );\\n\\n                // Skip orders that are too expensive rather than revert as we have\\n                // no way of knowing if a specific order becomes too expensive\\n                // between submitting to mempool and execution, but other orders may\\n                // be valid so we want to take advantage of those if possible.\\n                if (orderIOCalculation_.IORatio > takeOrders_.maximumIORatio) {\\n                    emit OrderExceedsMaxRatio(\\n                        msg.sender,\\n                        order_.owner,\\n                        orderHash_\\n                    );\\n                } else if (orderIOCalculation_.outputMax == 0) {\\n                    emit OrderZeroAmount(msg.sender, order_.owner, orderHash_);\\n                } else {\\n                    // Don't exceed the maximum total input.\\n                    uint256 input_ = remainingInput_.min(\\n                        orderIOCalculation_.outputMax\\n                    );\\n                    // Always round IO calculations up.\\n                    uint256 output_ = input_.fixedPointMul(\\n                        orderIOCalculation_.IORatio,\\n                        Math.Rounding.Up\\n                    );\\n\\n                    remainingInput_ -= input_;\\n                    totalOutput_ += output_;\\n\\n                    _recordVaultIO(\\n                        order_,\\n                        output_,\\n                        input_,\\n                        orderIOCalculation_\\n                    );\\n                    emit TakeOrder(msg.sender, takeOrder_, input_, output_);\\n                }\\n            }\\n\\n            unchecked {\\n                i_++;\\n            }\\n        }\\n        totalInput_ = takeOrders_.maximumInput - remainingInput_;\\n\\n        if (totalInput_ < takeOrders_.minimumInput) {\\n            revert MinimumInput(takeOrders_.minimumInput, totalInput_);\\n        }\\n\\n        // We already updated vault balances before we took tokens from\\n        // `msg.sender` which is usually NOT the correct order of operations for\\n        // depositing to a vault. We rely on reentrancy guards to make this safe.\\n        IERC20(takeOrders_.output).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            totalOutput_\\n        );\\n        // Prioritise paying down any active flash loans before sending any\\n        // tokens to `msg.sender`.\\n        _decreaseFlashDebtThenSendToken(\\n            takeOrders_.input,\\n            msg.sender,\\n            totalInput_\\n        );\\n    }\\n\\n    /// @inheritdoc IOrderBookV2\\n    function clear(\\n        Order memory alice_,\\n        Order memory bob_,\\n        ClearConfig calldata clearConfig_,\\n        SignedContextV1[] memory aliceSignedContext_,\\n        SignedContextV1[] memory bobSignedContext_\\n    ) external nonReentrant {\\n        {\\n            if (alice_.owner == bob_.owner) {\\n                revert SameOwner(alice_.owner);\\n            }\\n            if (\\n                alice_.validOutputs[clearConfig_.aliceOutputIOIndex].token !=\\n                bob_.validInputs[clearConfig_.bobInputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    alice_.validOutputs[clearConfig_.aliceOutputIOIndex].token,\\n                    bob_.validInputs[clearConfig_.bobInputIOIndex].token\\n                );\\n            }\\n\\n            if (\\n                bob_.validOutputs[clearConfig_.bobOutputIOIndex].token !=\\n                alice_.validInputs[clearConfig_.aliceInputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    alice_.validInputs[clearConfig_.aliceInputIOIndex].token,\\n                    bob_.validOutputs[clearConfig_.bobOutputIOIndex].token\\n                );\\n            }\\n\\n            // If either order is dead the clear is a no-op other than emitting\\n            // `OrderNotFound`. Returning rather than erroring makes it easier to\\n            // bulk clear using `Multicall`.\\n            if (orders[alice_.hash()] == DEAD_ORDER) {\\n                emit OrderNotFound(msg.sender, alice_.owner, alice_.hash());\\n                return;\\n            }\\n            if (orders[bob_.hash()] == DEAD_ORDER) {\\n                emit OrderNotFound(msg.sender, bob_.owner, bob_.hash());\\n                return;\\n            }\\n\\n            // Emit the Clear event before `eval`.\\n            emit Clear(msg.sender, alice_, bob_, clearConfig_);\\n        }\\n        OrderIOCalculation memory aliceOrderIOCalculation_ = _calculateOrderIO(\\n            alice_,\\n            clearConfig_.aliceInputIOIndex,\\n            clearConfig_.aliceOutputIOIndex,\\n            bob_.owner,\\n            bobSignedContext_\\n        );\\n        OrderIOCalculation memory bobOrderIOCalculation_ = _calculateOrderIO(\\n            bob_,\\n            clearConfig_.bobInputIOIndex,\\n            clearConfig_.bobOutputIOIndex,\\n            alice_.owner,\\n            aliceSignedContext_\\n        );\\n        ClearStateChange memory clearStateChange_ = LibOrderBook\\n            ._clearStateChange(\\n                aliceOrderIOCalculation_,\\n                bobOrderIOCalculation_\\n            );\\n\\n        _recordVaultIO(\\n            alice_,\\n            clearStateChange_.aliceInput,\\n            clearStateChange_.aliceOutput,\\n            aliceOrderIOCalculation_\\n        );\\n        _recordVaultIO(\\n            bob_,\\n            clearStateChange_.bobInput,\\n            clearStateChange_.bobOutput,\\n            bobOrderIOCalculation_\\n        );\\n\\n        {\\n            // At least one of these will overflow due to negative bounties if\\n            // there is a spread between the orders.\\n            uint256 aliceBounty_ = clearStateChange_.aliceOutput -\\n                clearStateChange_.bobInput;\\n            uint256 bobBounty_ = clearStateChange_.bobOutput -\\n                clearStateChange_.aliceInput;\\n            if (aliceBounty_ > 0) {\\n                vaultBalance[msg.sender][\\n                    alice_.validOutputs[clearConfig_.aliceOutputIOIndex].token\\n                ][clearConfig_.aliceBountyVaultId] += aliceBounty_;\\n            }\\n            if (bobBounty_ > 0) {\\n                vaultBalance[msg.sender][\\n                    bob_.validOutputs[clearConfig_.bobOutputIOIndex].token\\n                ][clearConfig_.bobBountyVaultId] += bobBounty_;\\n            }\\n        }\\n\\n        emit AfterClear(msg.sender, clearStateChange_);\\n    }\\n\\n    /// Main entrypoint into an order calculates the amount and IO ratio. Both\\n    /// are always treated as 18 decimal fixed point values and then rescaled\\n    /// according to the order's definition of each token's actual fixed point\\n    /// decimals.\\n    /// @param order_ The order to evaluate.\\n    /// @param inputIOIndex_ The index of the input token being calculated for.\\n    /// @param outputIOIndex_ The index of the output token being calculated for.\\n    /// @param counterparty_ The counterparty of the order as it is currently\\n    /// being cleared against.\\n    /// @param signedContext_ Any signed context provided by the clearer/taker\\n    /// that the order may need for its calculations.\\n    function _calculateOrderIO(\\n        Order memory order_,\\n        uint256 inputIOIndex_,\\n        uint256 outputIOIndex_,\\n        address counterparty_,\\n        SignedContextV1[] memory signedContext_\\n    ) internal view virtual returns (OrderIOCalculation memory) {\\n        unchecked {\\n            uint256 orderHash_ = order_.hash();\\n\\n            uint256[][] memory context_;\\n            {\\n                uint256[][] memory callingContext_ = new uint256[][](\\n                    CALLING_CONTEXT_COLUMNS\\n                );\\n                callingContext_[\\n                    CONTEXT_CALLING_CONTEXT_COLUMN - 1\\n                ] = LibUint256Array.arrayFrom(\\n                    orderHash_,\\n                    uint256(uint160(order_.owner)),\\n                    uint256(uint160(counterparty_))\\n                );\\n\\n                callingContext_[\\n                    CONTEXT_VAULT_INPUTS_COLUMN - 1\\n                ] = LibUint256Array.arrayFrom(\\n                    uint256(uint160(order_.validInputs[inputIOIndex_].token)),\\n                    order_.validInputs[inputIOIndex_].decimals,\\n                    order_.validInputs[inputIOIndex_].vaultId,\\n                    vaultBalance[order_.owner][\\n                        order_.validInputs[inputIOIndex_].token\\n                    ][order_.validInputs[inputIOIndex_].vaultId],\\n                    // Don't know the balance diff yet!\\n                    0\\n                );\\n\\n                callingContext_[\\n                    CONTEXT_VAULT_OUTPUTS_COLUMN - 1\\n                ] = LibUint256Array.arrayFrom(\\n                    uint256(uint160(order_.validOutputs[outputIOIndex_].token)),\\n                    order_.validOutputs[outputIOIndex_].decimals,\\n                    order_.validOutputs[outputIOIndex_].vaultId,\\n                    vaultBalance[order_.owner][\\n                        order_.validOutputs[outputIOIndex_].token\\n                    ][order_.validOutputs[outputIOIndex_].vaultId],\\n                    // Don't know the balance diff yet!\\n                    0\\n                );\\n                context_ = LibContext.build(callingContext_, signedContext_);\\n            }\\n\\n            // The state changes produced here are handled in _recordVaultIO so\\n            // that local storage writes happen before writes on the interpreter.\\n            StateNamespace namespace_ = StateNamespace.wrap(\\n                uint256(uint160(order_.owner))\\n            );\\n            (uint256[] memory stack_, uint256[] memory kvs_) = order_\\n                .evaluable\\n                .interpreter\\n                .eval(\\n                    order_.evaluable.store,\\n                    namespace_,\\n                    _calculateOrderDispatch(order_.evaluable.expression),\\n                    context_\\n                );\\n\\n            uint256 orderOutputMax_ = stack_[stack_.length - 2];\\n            uint256 orderIORatio_ = stack_[stack_.length - 1];\\n\\n            // Rescale order output max from 18 FP to whatever decimals the\\n            // output token is using.\\n            // Always round order output down.\\n            orderOutputMax_ = orderOutputMax_.scaleN(\\n                order_.validOutputs[outputIOIndex_].decimals,\\n                // Saturate the order max output because if we were willing to\\n                // give more than this on a scale up, we should be comfortable\\n                // giving less.\\n                // Round DOWN to be conservative and give away less if there's\\n                // any loss of precision during scale down.\\n                FLAG_SATURATE\\n            );\\n            // Rescale the ratio from 18 FP according to the difference in\\n            // decimals between input and output.\\n            // Always round IO ratio up.\\n            orderIORatio_ = orderIORatio_.scaleRatio(\\n                order_.validOutputs[outputIOIndex_].decimals,\\n                order_.validInputs[inputIOIndex_].decimals,\\n                // DO NOT saturate ratios because this would reduce the effective\\n                // IO ratio, which would mean that saturating would make the deal\\n                // worse for the order. Instead we overflow, and round up to get\\n                // the best possible deal.\\n                FLAG_ROUND_UP\\n            );\\n\\n            // The order owner can't send more than the smaller of their vault\\n            // balance or their per-order limit.\\n            orderOutputMax_ = orderOutputMax_.min(\\n                vaultBalance[order_.owner][\\n                    order_.validOutputs[outputIOIndex_].token\\n                ][order_.validOutputs[outputIOIndex_].vaultId]\\n            );\\n\\n            // Populate the context with the output max rescaled and vault capped\\n            // and the rescaled ratio.\\n            context_[CONTEXT_CALCULATIONS_COLUMN] = LibUint256Array.arrayFrom(\\n                orderOutputMax_,\\n                orderIORatio_\\n            );\\n\\n            return\\n                OrderIOCalculation(\\n                    orderOutputMax_,\\n                    orderIORatio_,\\n                    context_,\\n                    namespace_,\\n                    kvs_\\n                );\\n        }\\n    }\\n\\n    /// Given an order, final input and output amounts and the IO calculation\\n    /// verbatim from `_calculateOrderIO`, dispatch the handle IO entrypoint if\\n    /// it exists and update the order owner's vault balances.\\n    /// @param order_ The order that is being cleared.\\n    /// @param input_ The exact token input amount to move into the owner's\\n    /// vault.\\n    /// @param output_ The exact token output amount to move out of the owner's\\n    /// vault.\\n    /// @param orderIOCalculation_ The verbatim order IO calculation returned by\\n    /// `_calculateOrderIO`.\\n    function _recordVaultIO(\\n        Order memory order_,\\n        uint256 input_,\\n        uint256 output_,\\n        OrderIOCalculation memory orderIOCalculation_\\n    ) internal virtual {\\n        orderIOCalculation_.context[CONTEXT_VAULT_INPUTS_COLUMN][\\n            CONTEXT_VAULT_IO_BALANCE_DIFF\\n        ] = input_;\\n        orderIOCalculation_.context[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n            CONTEXT_VAULT_IO_BALANCE_DIFF\\n        ] = output_;\\n\\n        if (input_ > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID OVERFLOW.\\n            vaultBalance[order_.owner][\\n                address(\\n                    uint160(\\n                        orderIOCalculation_.context[\\n                            CONTEXT_VAULT_INPUTS_COLUMN\\n                        ][CONTEXT_VAULT_IO_TOKEN]\\n                    )\\n                )\\n            ][\\n                orderIOCalculation_.context[CONTEXT_VAULT_INPUTS_COLUMN][\\n                    CONTEXT_VAULT_IO_VAULT_ID\\n                ]\\n            ] += input_;\\n        }\\n        if (output_ > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID UNDERFLOW.\\n            vaultBalance[order_.owner][\\n                address(\\n                    uint160(\\n                        orderIOCalculation_.context[\\n                            CONTEXT_VAULT_OUTPUTS_COLUMN\\n                        ][CONTEXT_VAULT_IO_TOKEN]\\n                    )\\n                )\\n            ][\\n                orderIOCalculation_.context[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                    CONTEXT_VAULT_IO_VAULT_ID\\n                ]\\n            ] -= output_;\\n        }\\n\\n        // Emit the context only once in its fully populated form rather than two\\n        // nearly identical emissions of a partial and full context.\\n        emit Context(msg.sender, orderIOCalculation_.context);\\n\\n        // Apply state changes to the interpreter store after the vault balances\\n        // are updated, but before we call handle IO. We want handle IO to see\\n        // a consistent view on sets from calculate IO.\\n        if (orderIOCalculation_.kvs.length > 0) {\\n            order_.evaluable.store.set(\\n                orderIOCalculation_.namespace,\\n                orderIOCalculation_.kvs\\n            );\\n        }\\n\\n        // Only dispatch handle IO entrypoint if it is defined, otherwise it is\\n        // a waste of gas to hit the interpreter a second time.\\n        if (order_.handleIO) {\\n            // The handle IO eval is run under the same namespace as the\\n            // calculate order entrypoint.\\n            (, uint256[] memory handleIOKVs_) = order_\\n                .evaluable\\n                .interpreter\\n                .eval(\\n                    order_.evaluable.store,\\n                    orderIOCalculation_.namespace,\\n                    _handleIODispatch(order_.evaluable.expression),\\n                    orderIOCalculation_.context\\n                );\\n            // Apply state changes to the interpreter store from the handle IO\\n            // entrypoint.\\n            if (handleIOKVs_.length > 0) {\\n                order_.evaluable.store.set(\\n                    orderIOCalculation_.namespace,\\n                    handleIOKVs_\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/orderbook/OrderBookFlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"rain.interface.orderbook/ierc3156/IERC3156FlashBorrower.sol\\\";\\nimport \\\"rain.interface.orderbook/ierc3156/IERC3156FlashLender.sol\\\";\\n\\n/// Thrown when `flashLoan` token is zero address.\\nerror ZeroToken();\\n\\n/// Thrown when `flashLoadn` receiver is zero address.\\nerror ZeroReceiver();\\n\\n/// Thrown when the `onFlashLoan` callback returns anything other than\\n/// ON_FLASH_LOAN_CALLBACK_SUCCESS.\\n/// @param result The value that was returned by `onFlashLoan`.\\nerror FlashLenderCallbackFailed(bytes32 result);\\n\\n/// Thrown when more than one debt is attempted simultaneously.\\n/// @param receiver The receiver of the active debt.\\n/// @param token The token of the active debt.\\n/// @param amount The amount of the active debt.\\nerror ActiveDebt(address receiver, address token, uint256 amount);\\n\\n/// @dev Flash fee is always 0 for orderbook as there's no entity to take\\n/// revenue for `Orderbook` and its more important anyway that flashloans happen\\n/// to connect external liquidity to live orders via arbitrage.\\nuint256 constant FLASH_FEE = 0;\\n\\n/// @title OrderBookFlashLender\\n/// @notice Implements `IERC3156FlashLender` for `OrderBook`. Based on the\\n/// reference implementation by Alberto Cuesta Ca\u00f1ada found at\\n/// https://eips.ethereum.org/EIPS/eip-3156\\n/// Several features found in the reference implementation are simplified or\\n/// hardcoded for `Orderbook`.\\ncontract OrderBookFlashLender is IERC3156FlashLender {\\n    using SafeERC20 for IERC20;\\n    using Math for uint256;\\n\\n    IERC3156FlashBorrower private _receiver = IERC3156FlashBorrower(address(0));\\n    address private _token = address(0);\\n    uint256 private _amount = 0;\\n\\n    function _isActiveDebt() internal view returns (bool) {\\n        return (address(_receiver) != address(0) ||\\n            _token != address(0) ||\\n            _amount != 0);\\n    }\\n\\n    function _checkActiveDebt() internal view {\\n        if (_isActiveDebt()) {\\n            revert ActiveDebt(address(_receiver), _token, _amount);\\n        }\\n    }\\n\\n    /// Whenever `Orderbook` sends tokens to any address it MUST first attempt\\n    /// to decrease any outstanding flash loans for that address. Consider the\\n    /// case that Alice deposits 100 TKN and she is the only depositor of TKN\\n    /// then flash borrows 100 TKN. If she attempts to withdraw 100 TKN during\\n    /// her `onFlashLoan` callback then `Orderbook`:\\n    ///\\n    /// - has 0 TKN balance to process the withdrawal\\n    /// - MUST process the withdrawal as Alice has the right to withdraw her\\n    /// balance at any time\\n    /// - Has the 100 TKN debt active under Alice\\n    ///\\n    /// In this case `Orderbook` can simply forgive Alice's 100 TKN debt instead\\n    /// of actually transferring any tokens. The withdrawal can decrease her\\n    /// vault balance by 100 TKN decoupled from needing to know whether a\\n    /// tranfer or forgiveness happened.\\n    ///\\n    /// The same logic applies to withdrawals as sending tokens during\\n    /// `takeOrders` as the reason for sending tokens is irrelevant, all that\\n    /// matters is that `Orderbook` prioritises debt repayments over external\\n    /// transfers.\\n    ///\\n    /// If there is an active debt that only partially eclipses the withdrawal\\n    /// then the debt will be fully repaid and the remainder transferred as a\\n    /// real token transfer.\\n    ///\\n    /// Note that Alice can still contrive a situation that causes `Orderbook`\\n    /// to attempt to send tokens that it does not have. If Alice can write a\\n    /// smart contract to trigger withdrawals she can flash loan 100% of the\\n    /// TKN supply in `Orderbook` and trigger her contract to attempt a\\n    /// withdrawal. For any normal ERC20 token this will fail and revert as the\\n    /// `Orderbook` cannot send tokens it does not have under any circumstances,\\n    /// but the scenario is worth being aware of for more exotic token\\n    /// behaviours that may not be supported.\\n    ///\\n    /// @param token_ The token being sent or for the debt being paid.\\n    /// @param receiver_ The receiver of the token or holder of the debt.\\n    /// @param sendAmount_ The amount to send or repay.\\n    function _decreaseFlashDebtThenSendToken(\\n        address token_,\\n        address receiver_,\\n        uint256 sendAmount_\\n    ) internal {\\n        // If this token transfer matches the active debt then prioritise\\n        // reducing debt over sending tokens.\\n        if (token_ == _token && receiver_ == address(_receiver)) {\\n            uint256 debtReduction_ = sendAmount_.min(_amount);\\n            sendAmount_ -= debtReduction_;\\n\\n            // Even if this completely zeros the amount the debt is considered\\n            // active until the `flashLoan` also clears the token and recipient.\\n            _amount -= debtReduction_;\\n        }\\n\\n        if (sendAmount_ > 0) {\\n            IERC20(token_).safeTransfer(receiver_, sendAmount_);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver_,\\n        address token_,\\n        uint256 amount_,\\n        bytes calldata data_\\n    ) external override returns (bool) {\\n        // This prevents reentrancy, loans can be taken sequentially within a\\n        // transaction but not simultanously.\\n        _checkActiveDebt();\\n\\n        // Set the active debt before transferring tokens to prevent reeentrancy.\\n        // The active debt is set beyond the scope of `flashLoan` to facilitate\\n        // early repayment via. `_decreaseFlashDebtThenSendToken`.\\n        {\\n            if (token_ == address(0)) {\\n                revert ZeroToken();\\n            }\\n            if (address(receiver_) == address(0)) {\\n                revert ZeroReceiver();\\n            }\\n            _token = token_;\\n            _receiver = receiver_;\\n            _amount = amount_;\\n            if (amount_ > 0) {\\n                IERC20(token_).safeTransfer(address(receiver_), amount_);\\n            }\\n        }\\n\\n        bytes32 result_ = receiver_.onFlashLoan(\\n            // initiator\\n            msg.sender,\\n            // token\\n            token_,\\n            // amount\\n            amount_,\\n            // fee\\n            0,\\n            // data\\n            data_\\n        );\\n        if (result_ != ON_FLASH_LOAN_CALLBACK_SUCCESS) {\\n            revert FlashLenderCallbackFailed(result_);\\n        }\\n\\n        // Pull tokens before releasing the active debt to prevent a new loan\\n        // from being taken reentrantly during the repayment of the current loan.\\n        {\\n            // Sync local `amount_` with global `_amount` in case an early\\n            // repayment was made during the loan term via.\\n            // `_decreaseFlashDebtThenSendToken`.\\n            amount_ = _amount;\\n            if (amount_ > 0) {\\n                IERC20(_token).safeTransferFrom(\\n                    address(_receiver),\\n                    address(this),\\n                    amount_\\n                );\\n                _amount = 0;\\n            }\\n\\n            // Both of these are required to fully clear the active debt and\\n            // allow new debts.\\n            _receiver = IERC3156FlashBorrower(address(0));\\n            _token = address(0);\\n        }\\n\\n        // Guard against some bad code path that allowed an active debt to remain\\n        // at this point. Should be impossible.\\n        _checkActiveDebt();\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashFee(\\n        address,\\n        uint256\\n    ) external pure override returns (uint256) {\\n        return FLASH_FEE;\\n    }\\n\\n    /// There's no limit to the size of a flash loan from `Orderbook` other than\\n    /// the current tokens deposited in `Orderbook`. If there is an active debt\\n    /// then loans are disabled so the max becomes `0` until after repayment.\\n    /// @inheritdoc IERC3156FlashLender\\n    function maxFlashLoan(\\n        address token_\\n    ) external view override returns (uint256) {\\n        return _isActiveDebt() ? 0 : IERC20(token_).balanceOf(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../Address.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length == 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/lib/rain.lib.hash/src/LibHashNoAlloc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nbytes32 constant HASH_NIL = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n/// @title LibHashNoAlloc\\n/// @notice When producing hashes of just about anything that isn't already bytes\\n/// the common suggestions look something like `keccak256(abi.encode(...))` or\\n/// `keccak256(abi.encodePacked(...))` with the main differentiation being\\n/// whether dynamic data types are being hashed. If they are then there is a hash\\n/// collision risk in the packed case as `\\\"abc\\\" + \\\"def\\\"` and `\\\"ab\\\" + \\\"cdef\\\"` will\\n/// pack and therefore hash to the same values, the suggested fix commonly being\\n/// to use abi.encode, which includes the lengths disambiguating dynamic data.\\n/// Something like `3\\\"abc\\\" + 3\\\"def\\\"` with the length prefixes won't collide with\\n/// `2\\\"ab\\\" + 4\\\"cdef\\\"` but note that ABI provides neither a strong guarantee to\\n/// be collision resitant on inputs (as far as I know, it's a coincidence that\\n/// this works), nor an efficient solution.\\n///\\n/// - Abi encoding is a complex algorithm that is easily 1k+ gas for simple\\n///   structs with just one or two dynamic typed fields.\\n/// - Abi encoding requires allocating and copying all the data plus a header to\\n///   a new region of memory, which gives it non-linearly increasing costs due to\\n///   memory expansion.\\n/// - Abi encoding can't easily be reproduced offchain without specialised tools,\\n///   it's not simply a matter of length prefixing some byte string and hashing\\n///   with keccak256, the heads and tails all need to be produced recursively\\n///   https://docs.soliditylang.org/en/develop/abi-spec.html#formal-specification-of-the-encoding\\n///\\n/// Consider that `hash(hash(\\\"abc\\\") + hash(\\\"def\\\"))` won't collide with\\n/// `hash(hash(\\\"ab\\\") + hash(\\\"cdef\\\"))`. It should be easier to convince ourselves\\n/// this is true for all possible pairs of byte strings than it is to convince\\n/// ourselves that the ABI serialization is never ambigious. Inductively we can\\n/// scale this to all possible data structures that are ordered compositions of\\n/// byte strings. Even better, the native behaviour of `keccak256` in the EVM\\n/// requires no additional allocation of memory. Worst case scenario is that we\\n/// want to hash several hashes together like `hash(hash0, hash1, ...)`, in which\\n/// case we can write the words after the free memory pointer, hash them, but\\n/// leave the pointer. This way we pay for memory expansion but can re-use that\\n/// region of memory for subsequent logic, which may effectively make the\\n/// expansion free as we would have needed to pay for it anyway. Given that hash\\n/// checks often occur early in real world logic due to\\n/// checks-effects-interactions, this is not an unreasonable assumption to call\\n/// this kind of expansion \\\"no alloc\\\".\\n///\\n/// One problem is that the gas saving for trivial abi encoding,\\n/// e.g. ~1-3 uint256 values, can be lost by the overhead of jumps and stack\\n/// manipulation due to function calls.\\n///\\n/// ```\\n/// struct Foo {\\n///   uint256 a;\\n///   address b;\\n///   uint32 c;\\n/// }\\n/// ```\\n/// The simplest way to hash `Foo` is to just hash it (crazy, i know!).\\n///\\n/// ```\\n/// assembly (\\\"memory-safe\\\") {\\n///   hash_ := keccak256(foo_, 0x60)\\n/// }\\n/// ```\\n/// Every struct field is 0x20 bytes in memory so 3 fields = 0x60 bytes to hash\\n/// always, with the exception of dynamic types. This costs about 70 gas vs.\\n/// about 350 gas for an abi encoding based approach.\\nlibrary LibHashNoAlloc {\\n    function hashBytes(bytes memory data_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(data_, 0x20), mload(data_))\\n        }\\n    }\\n\\n    function hashWords(bytes32[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function hashWords(uint256[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function combineHashes(bytes32 a_, bytes32 b_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, a_)\\n            mstore(0x20, b_)\\n            hash_ := keccak256(0, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IExpressionDeployerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IInterpreterCallerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Typed embodiment of some context data with associated signer and signature.\\n/// The signature MUST be over the packed encoded bytes of the context array,\\n/// i.e. the context array concatenated as bytes without the length prefix, then\\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\\n///\\n/// The calling contract (likely with the help of `LibContext`) is responsible\\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\\n/// expression is also responsible for:\\n///\\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\\n/// - Tracking and enforcing uniqueness of signed data if relevant\\n/// - Checking and enforcing expiry times if present and relevant in the context\\n/// - Many other potential constraints that expressions may want to enforce\\n///\\n/// EIP-1271 smart contract signatures are supported in addition to EOA\\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\\n/// return `false` when it previously returned `true`.\\n///\\n/// @param signer The account that produced the signature for `context`. The\\n/// calling contract MUST authenticate that the signer produced the signature.\\n/// @param context The signed data in a format that can be merged into a\\n/// 2-dimensional context matrix as-is.\\n/// @param signature The cryptographic signature for `context`. The calling\\n/// contract MUST authenticate that the signature is valid for the `signer` and\\n/// `context`.\\nstruct SignedContextV1 {\\n    // The ordering of these fields is important and used in assembly offset\\n    // calculations and hashing.\\n    address signer;\\n    uint256[] context;\\n    bytes signature;\\n}\\n\\nuint256 constant SIGNED_CONTEXT_SIGNER_OFFSET = 0;\\nuint256 constant SIGNED_CONTEXT_CONTEXT_OFFSET = 0x20;\\nuint256 constant SIGNED_CONTEXT_SIGNATURE_OFFSET = 0x40;\\n\\n/// @title IInterpreterCallerV2\\n/// @notice A contract that calls an `IInterpreterV1` via. `eval`. There are near\\n/// zero requirements on a caller other than:\\n///\\n/// - Emit some meta about itself upon construction so humans know what the\\n///   contract does\\n/// - Provide the context, which can be built in a standard way by `LibContext`\\n/// - Handle the stack array returned from `eval`\\n/// - OPTIONALLY emit the `Context` event\\n/// - OPTIONALLY set state on the `IInterpreterStoreV1` returned from eval.\\ninterface IInterpreterCallerV2 {\\n    /// Calling contracts SHOULD emit `Context` before calling `eval` if they\\n    /// are able. Notably `eval` MAY be called within a static call which means\\n    /// that events cannot be emitted, in which case this does not apply. It MAY\\n    /// NOT be useful to emit this multiple times for several eval calls if they\\n    /// all share a common context, in which case a single emit is sufficient.\\n    /// @param sender `msg.sender` building the context.\\n    /// @param context The context that was built.\\n    event Context(address sender, uint256[][] context);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/LibContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"sol.lib.memory/LibUint256Array.sol\\\";\\nimport \\\"rain.lib.hash/LibHashNoAlloc.sol\\\";\\n\\nimport {SignatureChecker} from \\\"openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {ECDSA} from \\\"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"./IInterpreterCallerV2.sol\\\";\\n\\n/// Thrown when the ith signature from a list of signed contexts is invalid.\\nerror InvalidSignature(uint256 i);\\n\\n/// @title LibContext\\n/// @notice Conventions for working with context as a calling contract. All of\\n/// this functionality is OPTIONAL but probably useful for the majority of use\\n/// cases. By building and authenticating onchain, caller provided and signed\\n/// contexts all in a standard way the overall usability of context is greatly\\n/// improved for expression authors and readers. Any calling contract that can\\n/// match the context expectations of an existing expression is one large step\\n/// closer to compatibility and portability, inheriting network effects of what\\n/// has already been authored elsewhere.\\nlibrary LibContext {\\n    using LibUint256Array for uint256[];\\n\\n    /// The base context is the `msg.sender` and address of the calling contract.\\n    /// As the interpreter itself is called via an external interface and may be\\n    /// statically calling itself, it MAY NOT have any ability to inspect either\\n    /// of these values. Even if this were not the case the calling contract\\n    /// cannot assume the existence of some opcode(s) in the interpreter that\\n    /// inspect the caller, so providing these two values as context is\\n    /// sufficient to decouple the calling contract from the interpreter. It is\\n    /// STRONGLY RECOMMENDED that even if the calling contract has \\\"no context\\\"\\n    /// that it still provides this base to every `eval`.\\n    ///\\n    /// Calling contracts DO NOT need to call this directly. It is built and\\n    /// merged automatically into the standard context built by `build`.\\n    ///\\n    /// @return The `msg.sender` and address of the calling contract using this\\n    /// library, as a context-compatible array.\\n    function base() internal view returns (uint256[] memory) {\\n        return LibUint256Array.arrayFrom(uint256(uint160(msg.sender)), uint256(uint160(address(this))));\\n    }\\n\\n    function hash(SignedContextV1 memory signedContext_) internal pure returns (bytes32 hash_) {\\n        uint256 signerOffset_ = SIGNED_CONTEXT_SIGNER_OFFSET;\\n        uint256 contextOffset_ = SIGNED_CONTEXT_CONTEXT_OFFSET;\\n        uint256 signatureOffset_ = SIGNED_CONTEXT_SIGNATURE_OFFSET;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, keccak256(add(signedContext_, signerOffset_), 0x20))\\n\\n            let context_ := mload(add(signedContext_, contextOffset_))\\n            mstore(0x20, keccak256(add(context_, 0x20), mul(mload(context_), 0x20)))\\n\\n            mstore(0, keccak256(0, 0x40))\\n\\n            let signature_ := mload(add(signedContext_, signatureOffset_))\\n            mstore(0x20, keccak256(add(signature_, 0x20), mload(signature_)))\\n\\n            hash_ := keccak256(0, 0x40)\\n        }\\n    }\\n\\n    /// Standard hashing process over a list of signed contexts. Situationally\\n    /// useful if the calling contract wants to record that it has seen a set of\\n    /// signed data then later compare it against some input (e.g. to ensure that\\n    /// many calls of some function all share the same input values). Note that\\n    /// unlike the internals of `build`, this hashes over the signer and the\\n    /// signature, to ensure that some data cannot be re-signed and used under\\n    /// a different provenance later.\\n    /// @param signedContexts_ The list of signed contexts to hash over.\\n    /// @return hash_ The hash of the signed contexts.\\n    function hash(SignedContextV1[] memory signedContexts_) internal pure returns (bytes32 hash_) {\\n        uint256 cursor_;\\n        uint256 end_;\\n        bytes32 hashNil_ = HASH_NIL;\\n        assembly (\\\"memory-safe\\\") {\\n            cursor_ := add(signedContexts_, 0x20)\\n            end_ := add(cursor_, mul(mload(signedContexts_), 0x20))\\n            mstore(0, hashNil_)\\n        }\\n\\n        SignedContextV1 memory signedContext_;\\n        bytes32 mem0_;\\n        while (cursor_ < end_) {\\n            assembly (\\\"memory-safe\\\") {\\n                signedContext_ := mload(cursor_)\\n                // Subhash will write to 0 for its own hashing so keep a copy\\n                // before it gets overwritten.\\n                mem0_ := mload(0)\\n            }\\n            bytes32 subHash_ = hash(signedContext_);\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(0, mem0_)\\n                mstore(0x20, subHash_)\\n                mstore(0, keccak256(0, 0x40))\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := mload(0)\\n        }\\n    }\\n\\n    /// Builds a standard 2-dimensional context array from base, calling and\\n    /// signed contexts. Note that \\\"columns\\\" of a context array refer to each\\n    /// `uint256[]` and each item within a `uint256[]` is a \\\"row\\\".\\n    ///\\n    /// @param baseContext_ Anything the calling contract can provide which MAY\\n    /// include input from the `msg.sender` of the calling contract. The default\\n    /// base context from `LibContext.base()` DOES NOT need to be provided by the\\n    /// caller, this matrix MAY be empty and will be simply merged into the final\\n    /// context. The base context matrix MUST contain a consistent number of\\n    /// columns from the calling contract so that the expression can always\\n    /// predict how many unsigned columns there will be when it runs.\\n    /// @param signedContexts_ Signed contexts are provided by the `msg.sender`\\n    /// but signed by a third party. The expression (author) defines _who_ may\\n    /// sign and the calling contract authenticates the signature over the\\n    /// signed data. Technically `build` handles all the authentication inline\\n    /// for the calling contract so if some context builds it can be treated as\\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\\n    /// Note two things about the structure of the final built context re: signed\\n    /// contexts:\\n    /// - The first column is a list of the signers in order of what they signed\\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\\n    ///   expressions DO NOT know exactly how many columns there are.\\n    /// The expression is responsible for defining e.g. a domain separator in a\\n    /// position that would force signed context to be provided in the \\\"correct\\\"\\n    /// order, rather than relying on the `msg.sender` to honestly present data\\n    /// in any particular structure/order.\\n    function build(uint256[][] memory baseContext_, SignedContextV1[] memory signedContexts_)\\n        internal\\n        view\\n        returns (uint256[][] memory)\\n    {\\n        unchecked {\\n            uint256[] memory signers_ = new uint256[](signedContexts_.length);\\n\\n            // - LibContext.base() + whatever we are provided.\\n            // - signed contexts + signers if they exist else nothing.\\n            uint256 contextLength_ =\\n                1 + baseContext_.length + (signedContexts_.length > 0 ? signedContexts_.length + 1 : 0);\\n\\n            uint256[][] memory context_ = new uint256[][](contextLength_);\\n            uint256 offset_ = 0;\\n            context_[offset_] = LibContext.base();\\n\\n            for (uint256 i_ = 0; i_ < baseContext_.length; i_++) {\\n                offset_++;\\n                context_[offset_] = baseContext_[i_];\\n            }\\n\\n            if (signedContexts_.length > 0) {\\n                offset_++;\\n                context_[offset_] = signers_;\\n\\n                for (uint256 i_ = 0; i_ < signedContexts_.length; i_++) {\\n                    if (\\n                        // Unlike `LibContext.hash` we can only hash over\\n                        // the context as it's impossible for a signature\\n                        // to sign itself.\\n                        // Note the use of encodePacked here over a\\n                        // single array, not including the length. This\\n                        // would be a security issue if multiple dynamic\\n                        // length values were hashed over together as\\n                        // then many possible inputs could collide with\\n                        // a single encoded output.\\n                        !SignatureChecker.isValidSignatureNow(\\n                            signedContexts_[i_].signer,\\n                            ECDSA.toEthSignedMessageHash(LibHashNoAlloc.hashWords(signedContexts_[i_].context)),\\n                            signedContexts_[i_].signature\\n                        )\\n                    ) {\\n                        revert InvalidSignature(i_);\\n                    }\\n\\n                    signers_[i_] = uint256(uint160(signedContexts_[i_].signer));\\n                    offset_++;\\n                    context_[offset_] = signedContexts_[i_].context;\\n                }\\n            }\\n\\n            return context_;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/LibEncodedDispatch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title LibEncodedDispatch\\n/// @notice Establishes and implements a convention for encoding an interpreter\\n/// dispatch. Handles encoding of several things required for efficient dispatch.\\nlibrary LibEncodedDispatch {\\n    /// Builds an `EncodedDispatch` from its constituent parts.\\n    /// @param expression_ The onchain address of the expression to run.\\n    /// @param sourceIndex_ The index of the source to run within the expression\\n    /// as an entrypoint.\\n    /// @param maxOutputs_ The maximum outputs the caller can meaningfully use.\\n    /// If the interpreter returns a larger stack than this it is merely wasting\\n    /// gas across the external call boundary.\\n    /// @return The encoded dispatch.\\n    function encode(address expression_, SourceIndex sourceIndex_, uint16 maxOutputs_)\\n        internal\\n        pure\\n        returns (EncodedDispatch)\\n    {\\n        return EncodedDispatch.wrap(\\n            (uint256(uint160(expression_)) << 32) | (uint256(SourceIndex.unwrap(sourceIndex_)) << 16) | maxOutputs_\\n        );\\n    }\\n\\n    /// Decodes an `EncodedDispatch` to its constituent parts.\\n    /// @param dispatch_ The `EncodedDispatch` to decode.\\n    /// @return The expression, source index, and max outputs as per `encode`.\\n    function decode(EncodedDispatch dispatch_) internal pure returns (address, SourceIndex, uint16) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap(uint16(EncodedDispatch.unwrap(dispatch_) >> 16)),\\n            uint16(EncodedDispatch.unwrap(dispatch_))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/LibEvaluable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// Standard struct that can be embedded in ABIs in a consistent format for\\n/// tooling to read/write. MAY be useful to bundle up the data required to call\\n/// `IExpressionDeployerV1` but is NOT mandatory.\\n/// @param deployer Will deploy the expression from sources and constants.\\n/// @param sources Will be deployed to an expression address for use in\\n/// `Evaluable`.\\n/// @param constants Will be available to the expression at runtime.\\nstruct EvaluableConfig {\\n    IExpressionDeployerV1 deployer;\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// Struct over the return of `IExpressionDeployerV1.deployExpression`\\n/// which MAY be more convenient to work with than raw addresses.\\n/// @param interpreter Will evaluate the expression.\\n/// @param store Will store state changes due to evaluation of the expression.\\n/// @param expression Will be evaluated by the interpreter.\\nstruct Evaluable {\\n    IInterpreterV1 interpreter;\\n    IInterpreterStoreV1 store;\\n    address expression;\\n}\\n\\n/// @title LibEvaluable\\n/// @notice Common logic to provide consistent implementations of common tasks\\n/// that could be arbitrarily/ambiguously implemented, but work much better if\\n/// consistently implemented.\\nlibrary LibEvaluable {\\n    /// Hashes an `Evaluable`, ostensibly so that only the hash need be stored,\\n    /// thus only storing a single `uint256` instead of 3x `uint160`.\\n    /// @param evaluable_ The evaluable to hash.\\n    /// @return hash_ Standard hash of the evaluable.\\n    function hash(Evaluable memory evaluable_) internal pure returns (bytes32 hash_) {\\n        // `Evaluable` does NOT contain any dynamic types so it is safe to encode\\n        // packed for hashing, and is preferable due to the smaller/simpler\\n        // in-memory structure. It also makes it easier to replicate the logic\\n        // offchain as a simple concatenation of bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(evaluable_, 0x60)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.orderbook/src/ierc3156/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\n/// @dev The ERC3156 spec mandates this hash be returned by `onFlashLoan` if it\\n/// succeeds.\\nbytes32 constant ON_FLASH_LOAN_CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data)\\n        external\\n        returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.orderbook/src/ierc3156/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.orderbook/src/IOrderBookV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ierc3156/IERC3156FlashLender.sol\\\";\\nimport \\\"rain.interface.interpreter/LibEvaluable.sol\\\";\\nimport \\\"rain.interface.interpreter/IInterpreterCallerV2.sol\\\";\\n\\n/// Configuration for a deposit. All deposits are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to deposit.\\n/// @param vaultId The vault ID for the token to deposit.\\n/// @param amount The amount of the token to deposit.\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a withdrawal. All withdrawals are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to withdraw.\\n/// @param vaultId The vault ID for the token to withdraw.\\n/// @param amount The amount of the token to withdraw.\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a single input or output on an `Order`.\\n/// @param token The token to either send from the owner as an output or receive\\n/// from the counterparty to the owner as an input. The tokens are not moved\\n/// during an order, only internal vault balances are updated, until a separate\\n/// withdraw step.\\n/// @param decimals The decimals to use for internal scaling calculations for\\n/// `token`. This is provided directly in IO to save gas on external lookups and\\n/// to respect the ERC20 spec that mandates NOT assuming or using the `decimals`\\n/// method for onchain calculations. Ostensibly the decimals exists so that all\\n/// calculate order entrypoints can treat amounts and ratios as 18 decimal fixed\\n/// point values. Order max amounts MUST be rounded down and IO ratios rounded up\\n/// to compensate for any loss of precision during decimal rescaling.\\n/// @param vaultId The vault ID that tokens will move into if this is an input\\n/// or move out from if this is an output.\\nstruct IO {\\n    address token;\\n    uint8 decimals;\\n    uint256 vaultId;\\n}\\n\\n/// Config the order owner may provide to define their order. The `msg.sender`\\n/// that adds an order cannot modify the owner nor bypass the integrity check of\\n/// the expression deployer that they specify. However they MAY specify a\\n/// deployer with a corrupt integrity check, so counterparties and clearers MUST\\n/// check the DISpair of the order and avoid untrusted pairings.\\n/// @param validInputs As per `validInputs` on the `Order`.\\n/// @param validOutputs As per `validOutputs` on the `Order`.\\n/// @param evaluableConfig Standard `EvaluableConfig` used to produce the\\n/// `Evaluable` on the order.\\n/// @param meta Arbitrary bytes that will NOT be used in the order evaluation\\n/// but MUST be emitted as a Rain `MetaV1` when the order is placed so can be\\n/// used by offchain processes.\\nstruct OrderConfig {\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    EvaluableConfig evaluableConfig;\\n    bytes meta;\\n}\\n\\n/// Defines a fully deployed order ready to evaluate by Orderbook.\\n/// @param owner The owner of the order is the `msg.sender` that added the order.\\n/// @param handleIO true if there is a \\\"handle IO\\\" entrypoint to run. If false\\n/// the order book MAY skip calling the interpreter to save gas.\\n/// @param evaluable Standard `Evaluable` with entrypoints for both\\n/// \\\"calculate order\\\" and \\\"handle IO\\\". The latter MAY be empty bytes, in which\\n/// case it will be skipped at runtime to save gas.\\n/// @param validInputs A list of input tokens that are economically equivalent\\n/// for the purpose of processing this order. Inputs are relative to the order\\n/// so these tokens will be sent to the owners vault.\\n/// @param validOutputs A list of output tokens that are economically equivalent\\n/// for the purpose of processing this order. Outputs are relative to the order\\n/// so these tokens will be sent from the owners vault.\\nstruct Order {\\n    address owner;\\n    bool handleIO;\\n    Evaluable evaluable;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n}\\n\\n/// Config for a list of orders to take sequentially as part of a `takeOrders`\\n/// call.\\n/// @param output Output token from the perspective of the order taker.\\n/// @param input Input token from the perspective of the order taker.\\n/// @param minimumInput Minimum input from the perspective of the order taker.\\n/// @param maximumInput Maximum input from the perspective of the order taker.\\n/// @param maximumIORatio Maximum IO ratio as calculated by the order being\\n/// taken. The input is from the perspective of the order so higher ratio means\\n/// worse deal for the order taker.\\n/// @param orders Ordered list of orders that will be taken until the limit is\\n/// hit. Takers are expected to prioritise orders that appear to be offering\\n/// better deals i.e. lower IO ratios. This prioritisation and sorting MUST\\n/// happen offchain, e.g. via. some simulator.\\nstruct TakeOrdersConfig {\\n    address output;\\n    address input;\\n    uint256 minimumInput;\\n    uint256 maximumInput;\\n    uint256 maximumIORatio;\\n    TakeOrderConfig[] orders;\\n}\\n\\n/// Config for an individual take order from the overall list of orders in a\\n/// call to `takeOrders`.\\n/// @param order The order being taken this iteration.\\n/// @param inputIOIndex The index of the input token in `order` to match with the\\n/// take order output.\\n/// @param outputIOIndex The index of the output token in `order` to match with\\n/// the take order input.\\n/// @param signedContext Optional additional signed context relevant to the\\n/// taken order.\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n    SignedContextV1[] signedContext;\\n}\\n\\n/// Additional config to a `clear` that allows two orders to be fully matched to\\n/// a specific token moment. Also defines the bounty for the clearer.\\n/// @param aliceInputIOIndex The index of the input token in order A.\\n/// @param aliceOutputIOIndex The index of the output token in order A.\\n/// @param bobInputIOIndex The index of the input token in order B.\\n/// @param bobOutputIOIndex The index of the output token in order B.\\n/// @param aliceBountyVaultId The vault ID that the bounty from order A should\\n/// move to for the clearer.\\n/// @param bobBountyVaultId The vault ID that the bounty from order B should move\\n/// to for the clearer.\\nstruct ClearConfig {\\n    uint256 aliceInputIOIndex;\\n    uint256 aliceOutputIOIndex;\\n    uint256 bobInputIOIndex;\\n    uint256 bobOutputIOIndex;\\n    uint256 aliceBountyVaultId;\\n    uint256 bobBountyVaultId;\\n}\\n\\n/// Summary of the vault state changes due to clearing an order. NOT the state\\n/// changes sent to the interpreter store, these are the LOCAL CHANGES in vault\\n/// balances. Note that the difference in inputs/outputs overall between the\\n/// counterparties is the bounty paid to the entity that cleared the order.\\n/// @param aliceOutput Amount of counterparty A's output token that moved out of\\n/// their vault.\\n/// @param bobOutput Amount of counterparty B's output token that moved out of\\n/// their vault.\\n/// @param aliceInput Amount of counterparty A's input token that moved into\\n/// their vault.\\n/// @param bobInput Amount of counterparty B's input token that moved into their\\n/// vault.\\nstruct ClearStateChange {\\n    uint256 aliceOutput;\\n    uint256 bobOutput;\\n    uint256 aliceInput;\\n    uint256 bobInput;\\n}\\n\\n/// @title IOrderBookV2\\n/// @notice An orderbook that deploys _strategies_ represented as interpreter\\n/// expressions rather than individual orders. The order book contract itself\\n/// behaves similarly to an `ERC4626` vault but with much more fine grained\\n/// control over how tokens are allocated and moved internally by their owners,\\n/// and without any concept of \\\"shares\\\". Token owners MAY deposit and withdraw\\n/// their tokens under arbitrary vault IDs on a per-token basis, then define\\n/// orders that specify how tokens move between vaults according to an expression.\\n/// The expression returns a maximum amount and a token input/output ratio from\\n/// the perpective of the order. When two expressions intersect, as in their\\n/// ratios are the inverse of each other, then tokens can move between vaults.\\n///\\n/// For example, consider order A with input TKNA and output TKNB with a constant\\n/// ratio of 100:1. This order in isolation has no ability to move tokens. If\\n/// an order B appears with input TKNB and output TKNA and a ratio of 1:100 then\\n/// this is a perfect match with order A. In this case 100 TKNA will move from\\n/// order B to order A and 1 TKNB will move from order A to order B.\\n///\\n/// IO ratios are always specified as input:output and are 18 decimal fixed point\\n/// values. The maximum amount that can be moved in the current clearance is also\\n/// set by the order expression as an 18 decimal fixed point value.\\n///\\n/// Typically orders will not clear when their match is exactly 1:1 as the\\n/// clearer needs to pay gas to process the match. Each order will get exactly\\n/// the ratio it calculates when it does clear so if there is _overlap_ in the\\n/// ratios then the clearer keeps the difference. In our above example, consider\\n/// order B asking a ratio of 1:110 instead of 1:100. In this case 100 TKNA will\\n/// move from order B to order A and 10 TKNA will move to the clearer's vault and\\n/// 1 TKNB will move from order A to order B. In the case of fixed prices this is\\n/// not very interesting as order B could more simply take order A directly for\\n/// cheaper rather than involving a third party. Indeed, Orderbook supports a\\n/// direct \\\"take orders\\\" method that works similar to a \\\"market buy\\\". In the case\\n/// of dynamic expression based ratios, it allows both order A and order B to\\n/// clear non-interactively according to their strategy, trading off active\\n/// management, dealing with front-running, MEV, etc. for zero-gas and\\n/// exact-ratio clearance.\\n///\\n/// The general invariant for clearing and take orders is:\\n///\\n/// ```\\n/// ratioA = InputA / OutputA\\n/// ratioB = InputB / OutputB\\n/// ratioA * ratioB = ( InputA * InputB ) / ( OutputA * OutputB )\\n/// OutputA >= InputB\\n/// OutputB >= InputA\\n///\\n/// \u2234 ratioA * ratioB <= 1\\n/// ```\\n///\\n/// Orderbook is `IERC3156FlashLender` compliant with a 0 fee flash loan\\n/// implementation to allow external liquidity from other onchain DEXes to match\\n/// against orderbook expressions. All deposited tokens across all vaults are\\n/// available for flashloan, the flashloan MAY BE REPAID BY CALLING TAKE ORDER\\n/// such that Orderbook's liability to its vaults is decreased by an incoming\\n/// trade from the flashloan borrower. See `ZeroExOrderBookFlashBorrower` for\\n/// an example of how this works in practise.\\n///\\n/// Orderbook supports many to many input/output token relationship, for example\\n/// some order can specify an array of stables it would be willing to accept in\\n/// return for some ETH. This removes the need for a combinatorial explosion of\\n/// order strategies between like assets but introduces the issue of token\\n/// decimal handling. End users understand that \\\"one\\\" USDT is roughly equal to\\n/// \\\"one\\\" DAI, but onchain this is incorrect by _12 orders of magnitude_. This\\n/// is because \\\"one\\\" DAI is `1e18` tokens and \\\"one\\\" USDT is `1e6` tokens. The\\n/// orderbook is allowing orders to deploy expressions that define _economic\\n/// equivalence_ but this doesn't map 1:1 with numeric equivalence in a many to\\n/// many setup behind token decimal convensions. The solution is to require that\\n/// end users who place orders provide the decimals of each token they include\\n/// in their valid IO lists, and to calculate all amounts and ratios in their\\n/// expressions _as though they were 18 decimal fixed point values_. Orderbook\\n/// will then automatically rescale the expression values before applying the\\n/// final vault movements. If an order provides the \\\"wrong\\\" decimal values for\\n/// some token then it will simply calculate its own ratios and amounts\\n/// incorrectly which will either lead to no matching orders or a very bad trade\\n/// for the order owner. There is no way that misrepresenting decimals can attack\\n/// some other order by a counterparty. Orderbook DOES NOT read decimals from\\n/// tokens onchain because A. this would be gas for an external call to a cold\\n/// token contract and B. the ERC20 standard specifically states NOT to read\\n/// decimals from the interface onchain.\\n///\\n/// Token amounts and ratios returned by calculate order MUST be 18 decimal fixed\\n/// point values. Token amounts input to handle IO MUST be the exact absolute\\n/// values that move between the vaults, i.e. NOT rescaled to 18 decimals. The\\n/// author of the handle IO expression MUST use the token decimals and amounts to\\n/// rescale themselves if they want that logic, notably the expression author\\n/// will need to specify the desired rounding behaviour in the rescaling process.\\n///\\n/// When two orders clear there are NO TOKEN MOVEMENTS, only internal vault\\n/// balances are updated from the input and output vaults. Typically this results\\n/// in less gas per clear than calling external token transfers and also avoids\\n/// issues with reentrancy, allowances, external balances etc. This also means\\n/// that REBASING TOKENS AND TOKENS WITH DYNAMIC BALANCE ARE NOT SUPPORTED.\\n/// Orderbook ONLY WORKS IF TOKEN BALANCES ARE 1:1 WITH ADDITION/SUBTRACTION PER\\n/// VAULT MOVEMENT.\\n///\\n/// Dust due to rounding errors always favours the order. Output max is rounded\\n/// down and IO ratios are rounded up. Input and output amounts are always\\n/// converted to absolute values before applying to vault balances such that\\n/// orderbook always retains fully collateralised inventory of underlying token\\n/// balances to support withdrawals, with the caveat that dynamic token balanes\\n/// are not supported.\\n///\\n/// When an order clears it is NOT removed. Orders remain active until the owner\\n/// deactivates them. This is gas efficient as order owners MAY deposit more\\n/// tokens in a vault with an order against it many times and the order strategy\\n/// will continue to be clearable according to its expression. As vault IDs are\\n/// `uint256` values there are effectively infinite possible vaults for any token\\n/// so there is no limit to how many active orders any address can have at one\\n/// time. This also allows orders to be daisy chained arbitrarily where output\\n/// vaults for some order are the input vaults for some other order.\\n///\\n/// Expression storage is namespaced by order owner, so gets and sets are unique\\n/// to each onchain address. Order owners MUST TAKE CARE not to override their\\n/// storage sets globally across all their orders, which they can do most simply\\n/// by hashing the order hash into their get/set keys inside the expression. This\\n/// gives maximum flexibility for shared state across orders without allowing\\n/// order owners to attack and overwrite values stored by orders placed by their\\n/// counterparty.\\n///\\n/// Note that each order specifies its own interpreter and deployer so the\\n/// owner is responsible for not corrupting their own calculations with bad\\n/// interpreters. This also means the Orderbook MUST assume the interpreter, and\\n/// notably the interpreter's store, is malicious and guard against reentrancy\\n/// etc.\\n///\\n/// As Orderbook supports any expression that can run on any `IInterpreterV1` and\\n/// counterparties are available to the order, order strategies are free to\\n/// implement KYC/membership, tracking, distributions, stock, buybacks, etc. etc.\\ninterface IOrderBookV2 is IERC3156FlashLender, IInterpreterCallerV2 {\\n    /// Some tokens have been deposited to a vault.\\n    /// @param sender `msg.sender` depositing tokens. Delegated deposits are NOT\\n    /// supported.\\n    /// @param config All config sent to the `deposit` call.\\n    event Deposit(address sender, DepositConfig config);\\n\\n    /// Some tokens have been withdrawn from a vault.\\n    /// @param sender `msg.sender` withdrawing tokens. Delegated withdrawals are\\n    /// NOT supported.\\n    /// @param config All config sent to the `withdraw` call.\\n    /// @param amount The amount of tokens withdrawn, can be less than the\\n    /// config amount if the vault does not have the funds available to cover\\n    /// the config amount. For example an active order might move tokens before\\n    /// the withdraw completes.\\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\\n\\n    /// An order has been added to the orderbook. The order is permanently and\\n    /// always active according to its expression until/unless it is removed.\\n    /// @param sender `msg.sender` adding the order and is owner of the order.\\n    /// @param expressionDeployer The expression deployer that ran the integrity\\n    /// check for this order. This is NOT included in the `Order` itself but is\\n    /// important for offchain processes to ignore untrusted deployers before\\n    /// interacting with them.\\n    /// @param order The newly added order. MUST be handed back as-is when\\n    /// clearing orders and contains derived information in addition to the order\\n    /// config that was provided by the order owner.\\n    /// @param orderHash The hash of the order as it is recorded onchain. Only\\n    /// the hash is stored in Orderbook storage to avoid paying gas to store the\\n    /// entire order.\\n    event AddOrder(address sender, IExpressionDeployerV1 expressionDeployer, Order order, uint256 orderHash);\\n\\n    /// An order has been removed from the orderbook. This effectively\\n    /// deactivates it. Orders can be added again after removal.\\n    /// @param sender `msg.sender` removing the order and is owner of the order.\\n    /// @param order The removed order.\\n    /// @param orderHash The hash of the removed order.\\n    event RemoveOrder(address sender, Order order, uint256 orderHash);\\n\\n    /// Some order has been taken by `msg.sender`. This is the same as them\\n    /// placing inverse orders then immediately clearing them all, but costs less\\n    /// gas and is more convenient and reliable. Analogous to a market buy\\n    /// against the specified orders. Each order that is matched within a the\\n    /// `takeOrders` loop emits its own individual event.\\n    /// @param sender `msg.sender` taking the orders.\\n    /// @param config All config defining the orders to attempt to take.\\n    /// @param input The input amount from the perspective of sender.\\n    /// @param output The output amount from the perspective of sender.\\n    event TakeOrder(address sender, TakeOrderConfig config, uint256 input, uint256 output);\\n\\n    /// Emitted when attempting to match an order that either never existed or\\n    /// was removed. An event rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that wasn't found.\\n    /// @param owner Owner of the order that was not found.\\n    /// @param orderHash Hash of the order that was not found.\\n    event OrderNotFound(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a zero amount. An event rather than an\\n    /// error so that we allow attempting many orders in a loop and NOT rollback\\n    /// on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had a 0 amount.\\n    /// @param owner Owner of the order that evaluated to a 0 amount.\\n    /// @param orderHash Hash of the order that evaluated to a 0 amount.\\n    event OrderZeroAmount(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a ratio exceeding the counterparty's\\n    /// maximum limit. An error rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had an excess ratio.\\n    /// @param owner Owner of the order that had an excess ratio.\\n    /// @param orderHash Hash of the order that had an excess ratio.\\n    event OrderExceedsMaxRatio(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted before two orders clear. Covers both orders and includes all the\\n    /// state before anything is calculated.\\n    /// @param sender `msg.sender` clearing both orders.\\n    /// @param alice One of the orders.\\n    /// @param bob The other order.\\n    /// @param clearConfig Additional config required to process the clearance.\\n    event Clear(address sender, Order alice, Order bob, ClearConfig clearConfig);\\n\\n    /// Emitted after two orders clear. Includes all final state changes in the\\n    /// vault balances, including the clearer's vaults.\\n    /// @param sender `msg.sender` clearing the order.\\n    /// @param clearStateChange The final vault state changes from the clearance.\\n    event AfterClear(address sender, ClearStateChange clearStateChange);\\n\\n    /// Get the current balance of a vault for a given owner, token and vault ID.\\n    /// @param owner The owner of the vault.\\n    /// @param token The token the vault is for.\\n    /// @param id The vault ID to read.\\n    /// @return balance The current balance of the vault.\\n    function vaultBalance(address owner, address token, uint256 id) external view returns (uint256 balance);\\n\\n    /// `msg.sender` deposits tokens according to config. The config specifies\\n    /// the vault to deposit tokens under. Delegated depositing is NOT supported.\\n    /// Depositing DOES NOT mint shares (unlike ERC4626) so the overall vaulted\\n    /// experience is much simpler as there is always a 1:1 relationship between\\n    /// deposited assets and vault balances globally and individually. This\\n    /// mitigates rounding/dust issues, speculative behaviour on derived assets,\\n    /// possible regulatory issues re: whether a vault share is a security, code\\n    /// bloat on the vault, complex mint/deposit/withdraw/redeem 4-way logic,\\n    /// the need for preview functions, etc. etc.\\n    /// At the same time, allowing vault IDs to be specified by the depositor\\n    /// allows much more granular and direct control over token movements within\\n    /// Orderbook than either ERC4626 vault shares or mere contract-level ERC20\\n    /// allowances can facilitate.\\n    /// @param config All config for the deposit.\\n    function deposit(DepositConfig calldata config) external;\\n\\n    /// Allows the sender to withdraw any tokens from their own vaults. If the\\n    /// withrawer has an active flash loan debt denominated in the same token\\n    /// being withdrawn then Orderbook will merely reduce the debt and NOT send\\n    /// the amount of tokens repaid to the flashloan debt.\\n    /// @param config All config required to withdraw. Notably if the amount\\n    /// is less than the current vault balance then the vault will be cleared\\n    /// to 0 rather than the withdraw transaction reverting.\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    /// Given an order config, deploys the expression and builds the full `Order`\\n    /// for the config, then records it as an active order. Delegated adding an\\n    /// order is NOT supported. The `msg.sender` that adds an order is ALWAYS\\n    /// the owner and all resulting vault movements are their own.\\n    /// @param config All config required to build an `Order`.\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    /// Order owner can remove their own orders. Delegated order removal is NOT\\n    /// supported and will revert. Removing an order multiple times or removing\\n    /// an order that never existed are valid, the event will be emitted and the\\n    /// transaction will complete with that order hash definitely, redundantly\\n    /// not live.\\n    /// @param order The `Order` data exactly as it was added.\\n    function removeOrder(Order calldata order) external;\\n\\n    /// Allows `msg.sender` to attempt to fill a list of orders in sequence\\n    /// without needing to place their own order and clear them. This works like\\n    /// a market buy but against a specific set of orders. Every order will\\n    /// looped over and calculated individually then filled maximally until the\\n    /// request input is reached for the `msg.sender`. The `msg.sender` is\\n    /// responsible for selecting the best orders at the time according to their\\n    /// criteria and MAY specify a maximum IO ratio to guard against an order\\n    /// spiking the ratio beyond what the `msg.sender` expected and is\\n    /// comfortable with. As orders may be removed and calculate their ratios\\n    /// dynamically, all issues fulfilling an order other than misconfiguration\\n    /// by the `msg.sender` are no-ops and DO NOT revert the transaction. This\\n    /// allows the `msg.sender` to optimistically provide a list of orders that\\n    /// they aren't sure will completely fill at a good price, and fallback to\\n    /// more reliable orders further down their list. Misconfiguration such as\\n    /// token mismatches are errors that revert as this is known and static at\\n    /// all times to the `msg.sender` so MUST be provided correctly. `msg.sender`\\n    /// MAY specify a minimum input that MUST be reached across all orders in the\\n    /// list, otherwise the transaction will revert, this MAY be set to zero.\\n    ///\\n    /// Exactly like withdraw, if there is an active flash loan for `msg.sender`\\n    /// they will have their outstanding loan reduced by the final input amount\\n    /// preferentially before sending any tokens. Notably this allows arb bots\\n    /// implemented as flash loan borrowers to connect orders against external\\n    /// liquidity directly by paying back the loan with a `takeOrders` call and\\n    /// outputting the result of the external trade.\\n    ///\\n    /// Rounding errors always favour the order never the `msg.sender`.\\n    ///\\n    /// @param config The constraints and list of orders to take, orders are\\n    /// processed sequentially in order as provided, there is NO ATTEMPT onchain\\n    /// to predict/filter/sort these orders other than evaluating them as\\n    /// provided. Inputs and outputs are from the perspective of `msg.sender`\\n    /// except for values specified by the orders themselves which are the from\\n    /// the perspective of that order.\\n    /// @return totalInput Total tokens sent to `msg.sender`, taken from order\\n    /// vaults processed.\\n    /// @return totalOutput Total tokens taken from `msg.sender` and distributed\\n    /// between vaults.\\n    function takeOrders(TakeOrdersConfig calldata config) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    /// Allows `msg.sender` to match two live orders placed earlier by\\n    /// non-interactive parties and claim a bounty in the process. The clearer is\\n    /// free to select any two live orders on the order book for matching and as\\n    /// long as they have compatible tokens, ratios and amounts, the orders will\\n    /// clear. Clearing the orders DOES NOT remove them from the orderbook, they\\n    /// remain live until explicitly removed by their owner. Even if the input\\n    /// vault balances are completely emptied, the orders remain live until\\n    /// removed. This allows order owners to deploy a strategy over a long period\\n    /// of time and periodically top up the input vaults. Clearing two orders\\n    /// from the same owner is disallowed.\\n    ///\\n    /// Any mismatch in the ratios between the two orders will cause either more\\n    /// inputs than there are available outputs (transaction will revert) or less\\n    /// inputs than there are available outputs. In the latter case the excess\\n    /// outputs are given to the `msg.sender` of clear, to the vaults they\\n    /// specify in the clear config. This not only incentivises \\\"automatic\\\" clear\\n    /// calls for both alice and bob, but incentivises _prioritising greater\\n    /// ratio differences_ with a larger bounty. The second point is important\\n    /// because it implicitly prioritises orders that are further from the\\n    /// current market price, thus putting constant increasing pressure on the\\n    /// entire system the further it drifts from the norm, no matter how esoteric\\n    /// the individual order expressions and sizings might be.\\n    ///\\n    /// All else equal there are several factors that would impact how reliably\\n    /// some order clears relative to the wider market, such as:\\n    ///\\n    /// - Bounties are effectively percentages of cleared amounts so larger\\n    ///   orders have larger bounties and cover gas costs more easily\\n    /// - High gas on the network means that orders are harder to clear\\n    ///   profitably so the negative spread of the ratios will need to be larger\\n    /// - Complex and stateful expressions cost more gas to evalulate so the\\n    ///   negative spread will need to be larger\\n    /// - Erratic behavior of the order owner could reduce the willingness of\\n    ///   third parties to interact if it could result in wasted gas due to\\n    ///   orders suddently being removed before clearance etc.\\n    /// - Dynamic and highly volatile words used in the expression could be\\n    ///   ignored or low priority by clearers who want to be sure that they can\\n    ///   accurately predict the ratios that they include in their clearance\\n    /// - Geopolitical issues such as sanctions and regulatory restrictions could\\n    ///   cause issues for certain owners and clearers\\n    ///\\n    /// @param alice Some order to clear.\\n    /// @param bob Another order to clear.\\n    /// @param clearConfig Additional configuration for the clearance such as\\n    /// how to handle the bounty payment for the `msg.sender`.\\n    /// @param aliceSignedContext Optional signed context that is relevant to A.\\n    /// @param bobSignedContext Optional signed context that is relevant to B.\\n    function clear(\\n        Order memory alice,\\n        Order memory bob,\\n        ClearConfig calldata clearConfig,\\n        SignedContextV1[] memory aliceSignedContext,\\n        SignedContextV1[] memory bobSignedContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/rain.math.fixedpoint/src/FixedPointDecimalConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FIXED_POINT_DECIMALS = 18;\\n\\n/// @dev Value of \\\"one\\\" for fixed point math.\\nuint256 constant FIXED_POINT_ONE = 1e18;\\n\\n/// @dev Calculations MUST round up.\\nuint256 constant FLAG_ROUND_UP = 1;\\n\\n/// @dev Calculations MUST saturate NOT overflow.\\nuint256 constant FLAG_SATURATE = 1 << 1;\\n\\n/// @dev Flags MUST NOT exceed this value.\\nuint256 constant FLAG_MAX_INT = FLAG_SATURATE | FLAG_ROUND_UP;\\n\\n/// @dev Can't represent this many OOMs of decimals in `uint256`.\\nuint256 constant OVERFLOW_RESCALE_OOMS = 78;\\n\"\r\n    },\r\n    \"lib/rain.math.fixedpoint/src/FixedPointDecimalScale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./FixedPointDecimalConstants.sol\\\";\\n\\n/// @title FixedPointDecimalScale\\n/// @notice Tools to scale unsigned values to/from 18 decimal fixed point\\n/// representation.\\n///\\n/// Overflows error and underflows are rounded up or down explicitly.\\n///\\n/// The max uint256 as decimal is roughly 1e77 so scaling values comparable to\\n/// 1e18 is unlikely to ever overflow in most contexts. For a typical use case\\n/// involving tokens, the entire supply of a token rescaled up a full 18 decimals\\n/// would still put it \\\"only\\\" in the region of ~1e40 which has a full 30 orders\\n/// of magnitude buffer before running into saturation issues. However, there's\\n/// no theoretical reason that a token or any other use case couldn't use large\\n/// numbers or extremely precise decimals that would push this library to\\n/// overflow point, so it MUST be treated with caution around the edge cases.\\n///\\n/// Scaling down ANY fixed point decimal also reduces the precision which can\\n/// lead to  dust or in the worst case trapped funds if subsequent subtraction\\n/// overflows a rounded-down number. Consider using saturating subtraction for\\n/// safety against previously downscaled values, and whether trapped dust is a\\n/// significant issue. If you need to retain full/arbitrary precision in the case\\n/// of downscaling DO NOT use this library.\\n///\\n/// All rescaling and/or division operations in this library require a rounding\\n/// flag. This allows and forces the caller to specify where dust sits due to\\n/// rounding. For example the caller could round up when taking tokens from\\n/// `msg.sender` and round down when returning them, ensuring that any dust in\\n/// the round trip accumulates in the contract rather than opening an exploit or\\n/// reverting and trapping all funds. This is exactly how the ERC4626 vault spec\\n/// handles dust and is a good reference point in general. Typically the contract\\n/// holding tokens and non-interactive participants should be favoured by\\n/// rounding calculations rather than active participants. This is because we\\n/// assume that an active participant, e.g. `msg.sender`, knowns something we\\n/// don't and is carefully crafting an attack, so we are most conservative and\\n/// suspicious of their inputs and actions.\\nlibrary FixedPointDecimalScale {\\n    /// Scales `a_` up by a specified number of decimals.\\n    /// @param a_ The number to scale up.\\n    /// @param scaleUpBy_ Number of orders of magnitude to scale `b_` up by.\\n    /// Errors if overflows.\\n    /// @return b_ `a_` scaled up by `scaleUpBy_`.\\n    function scaleUp(uint256 a_, uint256 scaleUpBy_) internal pure returns (uint256 b_) {\\n        // Checked power is expensive so don't do that.\\n        unchecked {\\n            b_ = 10 ** scaleUpBy_;\\n        }\\n        b_ = a_ * b_;\\n\\n        // We know exactly when 10 ** X overflows so replay the checked version\\n        // to get the standard Solidity overflow behaviour. The branching logic\\n        // here is still ~230 gas cheaper than unconditionally running the\\n        // overflow checks. We're optimising for standardisation rather than gas\\n        // in the unhappy revert case.\\n        if (scaleUpBy_ >= OVERFLOW_RESCALE_OOMS) {\\n            b_ = a_ == 0 ? 0 : 10 ** scaleUpBy_;\\n        }\\n    }\\n\\n    /// Identical to `scaleUp` but saturates instead of reverting on overflow.\\n    /// @param a_ As per `scaleUp`.\\n    /// @param scaleUpBy_ As per `scaleUp`.\\n    /// @return c_ As per `scaleUp` but saturates as `type(uint256).max` on\\n    /// overflow.\\n    function scaleUpSaturating(uint256 a_, uint256 scaleUpBy_) internal pure returns (uint256 c_) {\\n        unchecked {\\n            if (scaleUpBy_ >= OVERFLOW_RESCALE_OOMS) {\\n                c_ = a_ == 0 ? 0 : type(uint256).max;\\n            } else {\\n                // Adapted from saturatingMath.\\n                // Inlining everything here saves ~250-300+ gas relative to slow.\\n                uint256 b_ = 10 ** scaleUpBy_;\\n                c_ = a_ * b_;\\n                // Checking b_ here allows us to skip an \\\"is zero\\\" check because even\\n                // 10 ** 0 = 1, so we have a positive lower bound on b_.\\n                c_ = c_ / b_ == a_ ? c_ : type(uint256).max;\\n            }\\n        }\\n    }\\n\\n    /// Scales `a_` down by a specified number of decimals, rounding in the\\n    /// specified direction. Used internally by several other functions in this\\n    /// lib.\\n    /// @param a_ The number to scale down.\\n    /// @param scaleDownBy_ Number of orders of magnitude to scale `a_` down by.\\n    /// Overflows if greater than 77.\\n    /// @return c_ `a_` scaled down by `scaleDownBy_` and rounded.\\n    function scaleDown(uint256 a_, uint256 scaleDownBy_) internal pure returns (uint256) {\\n        unchecked {\\n            return scaleDownBy_ >= OVERFLOW_RESCALE_OOMS ? 0 : a_ / (10 ** scaleDownBy_);\\n        }\\n    }\\n\\n    function scaleDownRoundUp(uint256 a_, uint256 scaleDownBy_) internal pure returns (uint256 c_) {\\n        unchecked {\\n            if (scaleDownBy_ >= OVERFLOW_RESCALE_OOMS) {\\n                c_ = a_ == 0 ? 0 : 1;\\n            } else {\\n                uint256 b_ = 10 ** scaleDownBy_;\\n                c_ = a_ / b_;\\n\\n                // Intentionally doing a divide before multiply here to detect\\n                // the need to round up.\\n                //slither-disable-next-line divide-before-multiply\\n                if (a_ != c_ * b_) {\\n                    c_ += 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Scale a fixed point decimal of some scale factor to 18 decimals.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param decimals_ The number of fixed decimals of `a_`.\\n    /// @param flags_ Controls rounding and saturation.\\n    /// @return `a_` scaled to 18 decimals.\\n    function scale18(uint256 a_, uint256 decimals_, uint256 flags_) internal pure returns (uint256) {\\n        unchecked {\\n            if (FIXED_POINT_DECIMALS > decimals_) {\\n                uint256 scaleUpBy_ = FIXED_POINT_DECIMALS - decimals_;\\n                if (flags_ & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a_, scaleUpBy_);\\n                } else {\\n                    return scaleUp(a_, scaleUpBy_);\\n                }\\n            } else if (decimals_ > FIXED_POINT_DECIMALS) {\\n                uint256 scaleDownBy_ = decimals_ - FIXED_POINT_DECIMALS;\\n                if (flags_ & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a_, scaleDownBy_);\\n                } else {\\n                    return scaleDown(a_, scaleDownBy_);\\n                }\\n            } else {\\n                return a_;\\n            }\\n        }\\n    }\\n\\n    /// Scale an 18 decimal fixed point value to some other scale.\\n    /// Exactly the inverse behaviour of `scale18`. Where `scale18` would scale\\n    /// up, `scaleN` scales down, and vice versa.\\n    /// @param a_ An 18 decimal fixed point number.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @param flags_ Controls rounding and saturation.\\n    /// @return `a_` rescaled from 18 to `targetDecimals_`.\\n    function scaleN(uint256 a_, uint256 targetDecimals_, uint256 flags_) internal pure returns (uint256) {\\n        unchecked {\\n            if (FIXED_POINT_DECIMALS > targetDecimals_) {\\n                uint256 scaleDownBy_ = FIXED_POINT_DECIMALS - targetDecimals_;\\n                if (flags_ & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a_, scaleDownBy_);\\n                } else {\\n                    return scaleDown(a_, scaleDownBy_);\\n                }\\n            } else if (targetDecimals_ > FIXED_POINT_DECIMALS) {\\n                uint256 scaleUpBy_ = targetDecimals_ - FIXED_POINT_DECIMALS;\\n                if (flags_ & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a_, scaleUpBy_);\\n                } else {\\n                    return scaleUp(a_, scaleUpBy_);\\n                }\\n            } else {\\n                return a_;\\n            }\\n        }\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by. This is a SIGNED int8\\n    /// which means it can be negative, and also means that sign extension MUST\\n    /// be considered if changing it to another type.\\n    /// @param flags_ Controls rounding and saturating.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(uint256 a_, int8 scaleBy_, uint256 flags_) internal pure returns (uint256) {\\n        unchecked {\\n            if (scaleBy_ > 0) {\\n                if (flags_ & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a_, uint8(scaleBy_));\\n                } else {\\n                    return scaleUp(a_, uint8(scaleBy_));\\n                }\\n            } else if (scaleBy_ < 0) {\\n                // We know that scaleBy_ is negative here, so we can convert it\\n                // to an absolute value with bitwise NOT + 1.\\n                // This is slightly less gas than multiplying by negative 1 and\\n                // casting it, and handles the case of -128 without overflow.\\n                uint8 scaleDownBy_ = uint8(~scaleBy_) + 1;\\n                if (flags_ & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a_, scaleDownBy_);\\n                } else {\\n                    return scaleDown(a_, scaleDownBy_);\\n                }\\n            } else {\\n                return a_;\\n            }\\n        }\\n    }\\n\\n    /// Scale an 18 decimal fixed point ratio of a_:b_ according to the decimals\\n    /// of a and b that each MAY NOT be 18.\\n    /// i.e. a subsequent call to `a_.fixedPointMul(ratio_)` would yield the\\n    /// value that it would have as though `a_` and `b_` were both 18 decimals\\n    /// and we hadn't rescaled the ratio.\\n    ///\\n    /// This is similar to `scaleBy` that calcualates the OOMs to scale by as\\n    /// `bDecimals_ - aDecimals_`.\\n    ///\\n    /// @param ratio_ The ratio to be scaled.\\n    /// @param aDecimals_ The decimals of the ratio numerator.\\n    /// @param bDecimals_ The decimals of the ratio denominator.\\n    /// @param flags_ Controls rounding and saturating.\\n    function scaleRatio(uint256 ratio_, uint8 aDecimals_, uint8 bDecimals_, uint256 flags_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            if (bDecimals_ > aDecimals_) {\\n                uint8 scaleUpBy_ = bDecimals_ - aDecimals_;\\n                if (flags_ & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(ratio_, scaleUpBy_);\\n                }\\n                else {\\n                    return scaleUp(ratio_, scaleUpBy_);\\n                }\\n            }\\n            else if (aDecimals_ > bDecimals_) {\\n                uint8 scaleDownBy_ = aDecimals_ - bDecimals_;\\n                if (flags_ & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(ratio_, scaleDownBy_);\\n                }\\n                else {\\n                    return scaleDown(ratio_, scaleDownBy_);\\n                }\\n            }\\n            else {\\n                return ratio_;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibMemCpy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\nlibrary LibMemCpy {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param source The starting pointer to read from.\\n    /// @param target The starting pointer to write to.\\n    /// @param length The number of bytes to read/write.\\n    function unsafeCopyBytesTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {} iszero(lt(length, 0x20)) {\\n                length := sub(length, 0x20)\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n\\n            if iszero(iszero(length)) {\\n                //slither-disable-next-line incorrect-shift\\n                let mask_ := shr(mul(length, 8), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                // preserve existing bytes\\n                mstore(\\n                    target,\\n                    or(\\n                        // input\\n                        and(mload(source), not(mask_)),\\n                        and(mload(target), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /// Copies `length` `uint256` values starting from `source` to `target`\\n    /// with NO attempt to check that this is safe to do so. The caller MUST\\n    /// ensure that there exists allocated memory at `target` in which it is\\n    /// safe and appropriate to copy `length * 32` bytes to. Anything that was\\n    /// already written to memory at `[target:target+(length * 32 bytes)]`\\n    /// will be overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param source The starting position in memory that data will be copied\\n    /// from.\\n    /// @param target The starting position in memory that data will be copied\\n    /// to.\\n    /// @param length The number of 32 byte (i.e. `uint256`) words that will\\n    /// be copied.\\n    function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for { let end_ := add(source, mul(0x20, length)) } lt(source, end_) {\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// A pointer to a location in memory. This is a `uint256` to save gas on low\\n/// level operations on the evm stack. These same low level operations typically\\n/// WILL NOT check for overflow or underflow, so all pointer logic MUST ensure\\n/// that reads, writes and movements are not out of bounds.\\ntype Pointer is uint256;\\n\\n/// @title LibPointer\\n/// Ergonomic wrappers around common pointer movements, reading and writing. As\\n/// wrappers on such low level operations often introduce too much jump gas\\n/// overhead, these functions MAY find themselves used in reference\\n/// implementations that more optimised code can be fuzzed against. MAY also be\\n/// situationally useful on cooler performance paths.\\nlibrary LibPointer {\\n    /// Cast a `Pointer` to `bytes` without modification or any safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `bytes`.\\n    /// @param pointer The pointer to cast to `bytes`.\\n    /// @return data The cast `bytes`.\\n    function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data) {\\n        assembly (\\\"memory-safe\\\") {\\n            data := pointer\\n        }\\n    }\\n\\n    /// Increase some pointer by a number of bytes.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// Note that moving a pointer by some bytes offset is likely to unalign it\\n    /// with the 32 byte increments of the Solidity allocator.\\n    ///\\n    /// @param pointer The pointer to increase by `length`.\\n    /// @param length The number of bytes to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, length)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase by a single word.\\n    /// @return The increased pointer.\\n    function unsafeAddWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase.\\n    /// @param words The number of words to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease by a single word.\\n    /// @return The decreased pointer.\\n    function unsafeSubWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease.\\n    /// @param words The number of words to decrease the pointer by.\\n    /// @return The decreased pointer.\\n    function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Read the word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can read outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to read the word at.\\n    /// @return word The word read from the pointer.\\n    function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word) {\\n        assembly (\\\"memory-safe\\\") {\\n            word := mload(pointer)\\n        }\\n    }\\n\\n    /// Write a word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can write outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to write the word at.\\n    /// @param word The word to write.\\n    function unsafeWriteWord(Pointer pointer, uint256 word) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(pointer, word)\\n        }\\n    }\\n\\n    /// Get the pointer to the end of all allocated memory.\\n    /// As per Solidity docs, there is no guarantee that the region of memory\\n    /// beyond this pointer is zeroed out, as assembly MAY write beyond allocated\\n    /// memory for temporary use if the scratch space is insufficient.\\n    /// @return pointer The pointer to the end of all allocated memory.\\n    function allocatedMemoryPointer() internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := mload(0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibUint256Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibMemCpy.sol\\\";\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Pointer to the start (length prefix) of a `uint256[]`.\\n    /// @param array The array to get the start pointer of.\\n    /// @return pointer The pointer to the start of `array`.\\n    function startPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := array\\n        }\\n    }\\n\\n    /// Pointer to the data of a `uint256[]` NOT the length prefix.\\n    /// @param array The array to get the data pointer of.\\n    /// @return pointer The pointer to the data of `array`.\\n    function dataPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, 0x20)\\n        }\\n    }\\n\\n    /// Pointer to the end of the allocated memory of an array.\\n    /// @param array The array to get the end pointer of.\\n    /// @return pointer The pointer to the end of `array`.\\n    function endPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, add(0x20, mul(0x20, mload(array))))\\n        }\\n    }\\n\\n    /// Cast a `Pointer` to `uint256[]` without modification or safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `uint256[]`.\\n    /// @param pointer The pointer to cast to `uint256[]`.\\n    /// @return array The cast `uint256[]`.\\n    function unsafeAsUint256Array(Pointer pointer) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := pointer\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a A single integer to build an array around.\\n    /// @return array The newly allocated array including `a` as a single item.\\n    function arrayFrom(uint256 a) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 1)\\n            mstore(add(array, 0x20), a)\\n            mstore(0x40, add(array, 0x40))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @return array The newly allocated array including `a` and `b` as the only\\n    /// items.\\n    function arrayFrom(uint256 a, uint256 b) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 2)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(0x40, add(array, 0x60))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b` and `c` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 3)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(0x40, add(array, 0x80))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c` and `d` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 4)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(0x40, add(array, 0xA0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d` and\\n    /// `e` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 5)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(0x40, add(array, 0xC0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @param f The sixth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d`, `e`\\n    /// and `f` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 6)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(add(array, 0xC0), f)\\n            mstore(0x40, add(array, 0xE0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The head of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 1)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x40)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first item of the new array.\\n    /// @param b The second item of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256 b, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 2)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n            mstore(add(outputCursor, 0x40), b)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x60)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array The array to truncate.\\n    /// @param newLength The new length of the array after truncation.\\n    function truncate(uint256[] memory array, uint256 newLength) internal pure {\\n        if (newLength > array.length) {\\n            revert OutOfBoundsTruncate(array.length, newLength);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating only an additional\\n    /// `extend_.length` words onto `base_` and copying only `extend_` if\\n    /// possible. If `base_` is large this MAY be significantly more efficient\\n    /// than allocating `base_.length + extend_.length` for an entirely new array\\n    /// and copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    ///\\n    /// The efficient version of extension is only possible if the free memory\\n    /// pointer sits at the end of the base array at the moment of extension. If\\n    /// there is allocated memory after the end of base then extension will\\n    /// require copying both the base and extend arays to a new region of memory.\\n    /// The caller is responsible for optimising code paths to avoid additional\\n    /// allocations.\\n    ///\\n    /// This function is UNSAFE because the base array IS MUTATED DIRECTLY by\\n    /// some code paths AND THE FINAL RETURN ARRAY MAY POINT TO THE SAME REGION\\n    /// OF MEMORY. It is NOT POSSIBLE to reliably see this behaviour from the\\n    /// caller in all cases as the Solidity compiler optimisations may switch the\\n    /// caller between the allocating and non-allocating logic due to subtle\\n    /// optimisation reasons. To use this function safely THE CALLER MUST NOT USE\\n    /// THE BASE ARRAY AND MUST USE THE RETURNED ARRAY ONLY. It is safe to use\\n    /// the extend array after calling this function as it is never mutated, it\\n    /// is only copied from.\\n    ///\\n    /// @param b The base integer array that will be extended by `e`.\\n    /// @param e The extend integer array that extends `b`.\\n    /// @return extended The extended array of `b` extended by `e`.\\n    function unsafeExtend(uint256[] memory b, uint256[] memory e) internal pure returns (uint256[] memory extended) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Slither doesn't recognise assembly function names as mixed case\\n            // even if they are.\\n            // https://github.com/crytic/slither/issues/1815\\n            //slither-disable-next-line naming-convention\\n            function extendInline(base, extend) -> baseAfter {\\n                let outputCursor := mload(0x40)\\n                let baseLength := mload(base)\\n                let baseEnd := add(base, add(0x20, mul(baseLength, 0x20)))\\n\\n                // If base is NOT the last thing in allocated memory, allocate,\\n                // copy and recurse.\\n                switch eq(outputCursor, baseEnd)\\n                case 0 {\\n                    let newBase := outputCursor\\n                    let newBaseEnd := add(newBase, sub(baseEnd, base))\\n                    mstore(0x40, newBaseEnd)\\n                    for { let inputCursor := base } lt(outputCursor, newBaseEnd) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := extendInline(newBase, extend)\\n                }\\n                case 1 {\\n                    let totalLength_ := add(baseLength, mload(extend))\\n                    let outputEnd_ := add(base, add(0x20, mul(totalLength_, 0x20)))\\n                    mstore(base, totalLength_)\\n                    mstore(0x40, outputEnd_)\\n                    for { let inputCursor := add(extend, 0x20) } lt(outputCursor, outputEnd_) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := base\\n                }\\n            }\\n\\n            extended := extendInline(b, e)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.metadata/src/IMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\"\r\n    },\r\n    \"lib/sol.metadata/src/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"rain.cooldown/=lib/rain.cooldown/src/\",\r\n      \"rain.interface.factory/=lib/rain.interface.factory/src/\",\r\n      \"rain.interface.flow/=lib/rain.interface.flow/src/\",\r\n      \"rain.interface.interpreter/=lib/rain.interface.interpreter/src/\",\r\n      \"rain.interface.orderbook/=lib/rain.interface.orderbook/src/\",\r\n      \"rain.interface.sale/=lib/rain.interface.sale/src/\",\r\n      \"rain.lib.hash/=lib/rain.interface.interpreter/lib/rain.lib.hash/src/\",\r\n      \"rain.lib.typecast/=lib/rain.lib.typecast/src/\",\r\n      \"rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\r\n      \"rain.math.saturating/=lib/rain.math.saturating/src/\",\r\n      \"sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\r\n      \"sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\r\n      \"sol.lib.memory/=lib/sol.lib.memory/src/\",\r\n      \"sol.metadata/=lib/sol.metadata/src/\"\r\n    ],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct DeployerDiscoverableMetaV1ConstructionConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ActiveDebt\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"name\":\"FlashLenderCallbackFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"MinimumInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOrderOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SameOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aliceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bobToken\",\"type\":\"address\"}],\"name\":\"TokenMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IExpressionDeployerV1\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"AddOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearStateChange\",\"name\":\"clearStateChange\",\"type\":\"tuple\"}],\"name\":\"AfterClear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"alice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"bob\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobBountyVaultId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig\",\"type\":\"tuple\"}],\"name\":\"Clear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[][]\",\"name\":\"context\",\"type\":\"uint256[][]\"}],\"name\":\"Context\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct DepositConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderExceedsMaxRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderZeroAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"RemoveOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"signedContext\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct TakeOrderConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"name\":\"TakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct WithdrawConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IExpressionDeployerV1\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct EvaluableConfig\",\"name\":\"evaluableConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct OrderConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"alice_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"bob_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobBountyVaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"aliceSignedContext_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"bobSignedContext_\",\"type\":\"tuple[]\"}],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order_\",\"type\":\"tuple\"}],\"name\":\"removeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumIORatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"signedContext\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrderConfig[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrdersConfig\",\"name\":\"takeOrders_\",\"type\":\"tuple\"}],\"name\":\"takeOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInput_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct WithdrawConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrderBook", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000db2e78cbbe7ffb38908acbdf5273b6c6c8b82f0e00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000001aa1ff0a89c674ee7874a4005910f6789cc55adb72db46127df7574cf945498a922c2771a55c9bad22256697655b4c49b2b3deaccb1a0243724a20c06000d1dc54def783f68bf64bf674f7cc0020a95b6c272f1249cca5bba7fbf4e91efcfa48a9c7b95e98c7cfd5e371999a520d8ae2ea718f7ed7137bda7ed43c498d4be8e77eae0a7a32c11355cd75a552b3cc8ab553ae2a756566d638559a65699cc92b932aed94c58712bfe0af321fe891b3458e61ba9ae327ac92634c6aaf6d5aeb4cd67707ea626ee4b3e2cd9222c70e49a56ce54c36551333d7d7d8ccd985cd7499ad555528ac343c3bfee6d9d367ea5ad759a52675a556b69aab459de04f511a35b5b951b352e35f2aab16d8f41afbcc8b1516b932904d63a0ceb222d1ac449e62ee353eb12e399eacd5043bce8d2d55b1ca21708f47d15e05f6d4f99ad64eccb252c554edb93956747bd08ad6f753d4abfe5bb25fe16c1567a7a55ef985bd2c754e46d0e5c4c200e5da6b363a71aac895564b53eef34835d1ce420e4cceb12ceb29c69493724b93d8e9baad2629054b562b8329bc2e544f12ccb2f9cc1bb439323993e63b0ebaaa4bb2965ae80f76512f945e14752eca68d904265bd6d5218c827f74e6b650d3b2589098243b84aa2ca48095aa70e207ea27d2a15a151d8761e33b8cef895b7933f19a7264b482cdaf69142d68340ebd202ff356f16a27506b87ea074afd2b573f14e4a67ab1cc4c8fced05932bf78625f9c895552172f4efbaca9d70ddf07f25cf3bc4ae74161c872f4e4c9f323b2a0757e3128605d91d1805ccda1510e7b4f6c662bf6651650043e50a3291d85cc1b28bd5c1a8d63ed0a33d810a6ef8fa111e13984f0862031ac13f799c2a438c10ac6e215bdaed8d50f4c34ec497379d595cd32918ecf31080591839168dfa3608f1d83fbcde0c101d97c346e9fa2ce569a1085fdd506108156cfbd72ac17061e7d073f4fec02a831b51f307059c047709a596d3c826c382607021dffc4c48866af49eab20462a9248365350297ad93b9423953f958f722b702008261addbc4109fba582f6dc2a8e10392cd92177e3fb59233216f9673c0e6f0c1a4c20c9c1aedc342d26048901b933ab2e152afd54ccbc7b24820158fe3350ed490dd9f65e6fd66d024ac4ac3c4312c19244b6a3822e09425c14f69812f221c6c6039384b36ca7bc2ca4c2fdf07d3f993f37ed5487965cc52e449ed748ad9b02afb545103ce26e41337c5195cd95d110475bdf7e809f67495d16974e78f74d2add118d0d261cf79b47d98478fbc21b4c090778ad2e28062e4d1e1c3906b4135e32a56d7454993a2ce52c95848714b3a327d65e276a92d0d1fe4147095cc8d461c6f64d4eb22bb161b62cf1202e8b25a937029dca7a7c6318fbb7ab92c4a827ebfacda6bf6727b6a6190d452899d55515ec5a4cb1942ed2d7479454152aff7b6744fd7201b3669070dd214cc215ed3235fa344bb7248f30df608943587269e9817f93e9b4b73ce80f69d642501e489c81a905f6a7e544c819e9265163ad733b340a4f710b33aa3c78c7938cbbcda2feb3cc74f3df56af8a6a74c951cb07dff6dca627fc6c19e4a04ed8b5b46b4f0610ec56706a91d4800fbebd2520ae013a2817c1858a1655c78c2739e7a797949ff78d9befa1e6604d0f5d5a11a33e4f5e3c3417838880f07ad995f35a3be088b7c15267c89295fc415bf8ad3bfa405c2cf7f8debc71f07f14796e37ffff9efd6767ff91ef1e1f5e089d1bbe0eb9723b0b2af8fbe7df643a6ddfca5214273090f875bb3857cd27ca2a6065145635456900f1338d061498e246f2357c111080b5399fda5b629254c8945767fd0ae39d89d3a19fec330340aa4ea9926f068f1d716b738507d44b5e762f0ce400393b2709407b2c88e283f5d6b78ff24337cb42c2f89cb1ca3f9caec6e305467c31ffba3133578ab8efb2f5f8e4effa62efa2f866a7c76323c43e841320eac6830600eacd2f000f0ddb0394c8944531a0e20e4240e739891fd1fce6e1a66d5883129cab25811a93a87752fff095f1e7e88f49e4f64e0875cb242ccf918972980992d126649e4c3ae4b0e3f273ebf034516447ed9ecf9bacbfe84109646388f9bdb658f770cdbb96211108e727420acf8a8cb12a90ee28055c1f08e6063c50889444e881cf86ac294db066ecacbf3b2c38bbf7bf6551a426fc94c9449456972c789cd7555206a33f28dac60b8c2a62252abc209bc31b38864ed40111c971a96aa89b44efcead6b95a982d2b1e4802e039258191a18106b5231c60924f94d1e3ec5e919b3df5fafce4824ebd2cead91c70677ea10a097acae393fea8c7fb06970fc985bca264248797bc3f7a1ad006a22cf42cb7559d9af7de1c96d44934c46856e5a03d3247df5dc64880605d99f0fcd96524a8b15a0b31cf91cae8eb4b90c2978a1d4aef4b48ae55de1bb080829305a21aec8908c37bd68ff5224a92ef11535d322962d4c8eb8529bb53e8f475d70b7140f5924a469ba71b87813dafa181800069014a5e33dc5816baa495b9b480a4269ed76a0eca95e9240239f8170a582941fcda2ed620b2251e51402419acdf942f90daa6c48033eb2a5f4652c60b9c8cd147e8ab1c83e75b7181b63ddf3353246f91dd56e62e9a0c37686298b90d13395d570570d3b356ac8f0fa25c2b93cb0ab0eb94680aaa926ccd7138e72a5b7bd064b24428be51c7788b49a8ecad9080677b5150bf740cdf684166a72ca7a7458da108295159c75282aa046fb7181098b09a5bae74b084b19c31326294b079ee7345cb6d191a98a74d688c806c51b6ca01aee5d975841f6311942fe22f0beb623384168d8e41f0a6ab4a27571ef4247349bb63cd685473db44385b734227e3e1b93a1d5fe048204f5c4f705f42358041886a14721ec03d5e12938940ef33299db3d0b9a4c8428cc49e0b997270c04a23933f7da218a93448a52fd2c44df02bd510241e47ceb6845c9f63cb29478e08ca792416fcdeee42f8a4e8a09c7b3a5617e317c353f56afc66f86a787a71dec3fc6c1d3b32a1e1a333e26392a8eb65cafd9bd6dea17cf4192914fe4d8156498a70927001f1545491c5886007a960391a4d471a2de83d1474d04d4903763f2a20f575615327c9c0d7ec2592078d4cc052192859e65eb35854833928e334afb5303aa0e6d970d03f673a41763957fdd393f0f1a7d1c5dfd5c9dbd3feabd1b11af45ff64f8f87aa7f36e493397ffde38fe3b38be149dbadc6a72fdfaa9fc6672fced5e8076f693ff19c6712e0f2b2fd9393d1c5687c7a78fe7a7071d63fa6cfea47509937fdd72f2fe2f1f0a19ed4e05b69cd55155258ce6cdc806b9079a4c89fc23a75e9dabd1fe19c54b9fbd487d40847a2c8269b767b05e171bd3c1086da3edd889a4d5381e1be148a872294c1dedc0864c5a657357cad49767e65100e22986a5a931b218a0893500958c75d062419500be6309cebc30ed2b8f3cb63434fa3622f10c7de13a791b2eada68dfc608a5556b0deff7545bfa754cda8457445e7663e650d67930e16688f708a6488420be68820d6d262744584785133de058c7af8b8648509c9829e0c0522f2556b33bda9d5cd87ac0e27c2d86964a20c819283b8de7746e174602ab81df50ee09a01362d95c3c6ee2cb7866ea9d42911245bbadd977ada62a19f0b206ac3cfd16fcc67b46034450cf84ead3e64873a8179050b1126de389baa0ebda1f8d2b9aee09b24386e299b830536bd6cbdbd9431fff92a6241de709ea732bf2387024b2401b0f7ce9dc702c289d6aebe08073e97087beb1e5cc475274a0afc9b0dee4b18bba734c93a6d8ad860d1770f06e94d6aca3c6312d81f05ca4b45ca047a69819cf639835334ce728e3f8c8a461ebf397b78177cae844afcf2fa4823a265c2257a7d60b82baf4f48b7b00220c6f31cb8a09437bab9af39d7b365bcf3302264c64f0949aaf703b4f30a0c31c45526036a20ffd42b927741da0d521750aafcc9a1cda052ad8ed9e538858aa3d425b729a990fd6d77a6c65ba27482591067963cbd05f2d748875300ba199f009c63f986355da06d9c820ade370c25dd3e612a3cb3770b4a74515486fd3460c2d5917b956fb728776168e6f4aeff41e3124a52ea9c917ca666e7e8293d5cbca5b56ae52229f633ecb7840ccabb58fdb95104d2b99b18ba02aab17a6611c3257e835f60628ac371fee793bf5485e9016c058518bafce6a223b018f9af42df919e60284ec6aa8e5ed72a7e93e9775ce9737787c391a3512bc39bae4ed5aa761cd66d3c1b728f9447adbb5290d9e424206bad040512fde1e1f2ecc6202f371d94dbcee8a5b5d29ca8ed24eb8e6412cc002c9155595eb094638df05a33ffe8e30b3dad155604c80f2bb431a4ff8ea705e554bf7fcf07086b3ab2707a8ab0fe9b60d741f4b17197fd90fdf64b2741869d99ff155a95ff96feba61258c0e6e5e1fca47557b9fd305e57a629753573b3123b352318df9a0ddb9b76367ec3d5991fdd6b8f6809c025dc68c7982087dcfa7940ebc564e32326d404be01d114c67494d72d017ce561bdaf1d74375bea6a4e9bfdfcf4db770732e1e727efc8fe083c2abff0ed719cf05bef3e8a4baeb843f3f1ae419f4c752fc2c7ea7ed4d6dd7f7a17dda15543dfed135d67db348921c8a5403d2e400f66bbadd26fdfab760bca362d273a839a80fb29495573169b6a5b32c1a4d8fe203d8b508c84f108ac7ac11d8c65b1e4e2380de4b629973d80487fc578ce27abd06c4112aeb13ad8c3dd2b43345c6ea5d684f9d41829a4f34ffc5789112adf3f933debd6a60c729cdd4a235743dc1cf7f84acb3898b329dcdae9896f7f5786ba22725b5d4b71cdbcca53743c09377a5d06df0b1555682904a6d5f1473a1099e703af292a9c1a9d6f83f1865515e58735b759c4c04c5336da2241a443ba1e7bb03f3f7dd79de1ec0c74ef581c0053abb2369d01e423a66c064ca1e8c60879762cc7df8983cd58e8c4c3403bd311a6e3eaf474c3310fb647c7b432d9b998cca3abab0f18f464fb39dc615be25d5277243f669b6c6dd7919fe32b3442e017c3713f24724c4e556ca56f6bd5d52c26cc7d398a7def7abba7914651dfad01bf6dcfb955d128a43af6aadcad74880cff6646b344b0c60314f633eeaff2d1b6ca1bbfbceb7cdf30c88dbe7adc45ca9bddd6070af5db535de96ec8f355e566cc134644706cbfbf44b542af4dd75bb79b5dde3d7a45ad99fee90555e5437133b27d25ed29be3a8db154b47aa9ad0601b99614c3c5b432fca60386d5395fbbd02b4ffe7abefdc24de7e6b8a1edc5867cb784adcf40fb37dab51bc1479f2a82c7d1c2773b34d76c9df78ceee3c0fb372ffe19623438c86d71724b90fa737bb08e3cefa3a2f381ca1eb7fceac15ab69df241cab627de5fdba79f0f8b62a57b0b10b5eb614fec28cab8d9489a9f0c8f47affa2fd5d9f0fcb8ff7278d2ada0f97a90827b65811dfece855ea9dab71beffaddcc61ee08fc5b94e846fdd34f1bf5456c14dfed41cdd87099c51de0e66a4c385e42afd6715ba4c3d1ee1944bcc7fe8df27c0eb808ddf0bb2d1046dea4fffd74b4c5fe2dfbfd1119fc4d8b97df1c356f3aecdd373533cb1df9c0fc5b77aa1b6dfe7011405738536a6d850a4ddaa232bffd16abdbfd1a2b75bc27f402d72ce74bb29cee1fc3db70d556f110ee2bc39d0922bc8eddf40d1179777f7f7963c6ee358d9bdd87ca8beedf64cc6ef47efda9a2b77536dd22ec6e27bebe69ea5ddedb5254de96fe23d9f7b6c221e87e8fc6f70dd86d956fdff5d326f8b6cea39387e979d3f89daad9f47765f08f50c7c7a04789bb550be33d3688a6b19dc550b1e7da47dc8bcd1affdae003cce137dbbf4db8b669befe2ca6b1b9bca6760f6a175ecceedc396d2d4439f9210e1fcc70bb206d437cf359f3d5ae466ac7169d61316371174cbb6e338a285d6c19b6dfacbb3b23dd990a6e94b39b0bbef9b4b9a0a3c50393c1aeb9f7f314cfd7fea474d091fba1f960e7e4dfa1f51f9f11bce4f74f09774cd8addd1f9914bc809f272bb40ffaf7a5056f913f2b2f6c5827bcbffca0c4d07e63616ba5fb67860d4bdc2eca47a58647bb9ec45ba747e1dbbb47bf3dfa3f1a99c5fc011bffc21bbf86cc199b02706170706c69636174696f6e2f6a736f6e03676465666c617465a40059094f789ced5ddf6fdb36107ecf5f11f4392fedd062e85b9b369881a601d2ae031604032d3189565932242a3f36ec7f1f45dbb228de519444c98e730186a511c5fb481ec9ef8ec7d3d5d1f1f1bff2bfe3e35751b22c44feeafdf195faf7e6efea59902e9669c213edb95e665d87e059c2e2ef4f4b2e4bbe626198f13c7f75a2174bd8423d0ef9324e9f78d67c2e1aafd79efe77e22e7dfe24382a7bc105c3e4ae5eac4bad7ebfdebe62c8cb455604e2f8d3ba559fa23c48ef79c6e6313f97d27ebc3e4d935599284de4ef37d16d0d41852c504ffeaa3fda0013c532e61b602b506b40523813fcbc106c1ec591782a4b2769b2644fa5f8755d553dc106489a95b5a94e755083f6e1ad1a91f18047f7dad062c35a0d693f4922fdc9134f620af987376fdf4162d8222d1201c9d9bc040ecbe6f50f72d0eff9273e17cdb1e059366c1494b6fef2061e85bc8841d09b97aca0cf6296df7de149c8b35316c77316fc3c6351cc43ef6db0747cd4bbcf67c93d8ba3f05b749b305164c62c1813f5224aa245b19895b5b93460987246ae62c07e3a37b1faeb23cbcccd95668dbf42a40f899b18b077bea6e22293382f6ab5789ebc10e82269ec50f0ee8462be6451b2da75a61cd2615dfd4dfe7f9c6eb640964b44c0bf7bdc442cb2e6e9dc5912d843eaedf3285f3011dc4db993f0c7250f040f7f933b82cb7ee2d04f16692c10058b5d65813df57bb2815cce825a55aeddd5acf04f9ea5973aab1952555d0fecf530c9e39e24fb28abba6171ce4f5c4636e48f729fd6dee8aaad03d7675704928c8a4c8ef8f1ecf3e3b2ac56b2e30d87ae56afa63236caf50439925dd35c056db034680ea2e7691a6372ef5812c67c7681da35e5bb8e72d1ae31cb8238b7a33a2b9fc801138de134e047db8250314b071a8d1902f29bb48ab81d695e16990823ac6b1a9ced7ce88349fbf7f5895dfdd636ee67c9ac8b9a656942c20a80a6acd1379e95d1a10f9b66a401d8e39096acfc571b989007d1422e9b363cab4a3ca1d1ed0a03cf3d9366e42c6c8353b3342a407db46b7671758d299632e966abadcfa65ab206522e100c29975db92e0ad155bbaadf75f7a02b035a235366266855351fc0fec0412ccce25d50e23132eee6fd0ac37ae3b67cf75e4ebbc3e0bb7da9243c4174eb74a59198420293a30ba16c01204dd65d8a57ed6f7ad1a66d7e67e97e5683d39833c94599e0a792d7df724863034b198733836a7ade48044a1e4d50b2f5ba6ff264eb91ad47b61e0c87e83802856c3dfd392917d97a1bc2dbcbd6238283ca2582430487080eed417bb90711c1c1e1907221509e2fc199a7f349e98db3837176312b1bb9433fe76ab0768a63e3efdc35883de80a35241fcba8dfa71fe0ac9eae377aa3f03397956bd812b00e3feee0803e74df73e763b8ab6b6d5dafdf0d10fcd116eaabdeb477b656c72176f7489630447c7c59c22d6b004c2ba65a089b571f5a65fb59763ef1659a47a2eda64ccf35675dfb1e4c8326c9dd8e3acf1a7630cc69b1eb0f9188e426f60f705fe370e6ba970887bc98ffcd83fe17355c21a0d1fe0362fd9120ff9738c23e2e268ca562c383689445f5f931e03ccccfd9e32513514ac3fe3286fd6b2acee4264c0bf90b19eff286c8873aed3ac411a7032b542e1d585990d281151d5841b01de1d0990202850eacf4e7a45c7460f5fe006e5f5cf2457acfe902464b39b3ac237e73c800066a6bcee6a7cf140718a9860561a51a9c263375c562ed4af81db00dee6c556b9a9db16a2d443a1c6ce850e03883d5d0632c760adcb80e6b10adccd619a7f1b76b40153b325d1da6ad10ca7815b60995dcb1cf31b2a2356624b5c0c88b06d04260348c2089f1811026341a469cd418100162a3400ed15a80e434e0612c5a8307701d058d94969476474a0bb3730d1fa6b57dac852627d7003579b98962a4f3f068e70152e908d15113f0e23cba9d8e1857f1303644663c8d01695b8f0fb60ea424d500e58d64852024233fa982d3678295b91179b88e08faf11ab7cdf37ac1e98df3efece7ca801d1e0c32969dee9c8371344741f39a7e372f41d5c5e423a0c0b0fd0e0cfb23127761c61ef6773118982d78d340a7a9e823713779e14d3c2fd90b4f473c381c522e04ca88473c236a9773fa51a331c8e70bb4c6f8f4f497acdf6ecee4699105b081211ab5f853bd560b2b172cb1fb0c701bab8f02564e63831f68c8b8bd98174fc28e3e41e1642a75fdc244c56d1ac9dcd2f574ae253aeef4318a9b22515fc41883d750e8d8b1f643a163143a46a163266c473844fd10286457e8cf49b99e875dd1995481ce9ef2a2b8039b9ace21493c86780cf118e231181cda6a1028c463f4e7a45c2f88c7ccd3f9b42c865233516aa65e280e3835133865dd1330ed951902c67b790e8cc0d75238b6cb7ee6e0cdb78fc5717972f0dbe2b6f459a295c4b5a396348af4e385e8875cbdba6bc7510d81be001de079100576b9caeea29c8e79bdfa9e4f867a62af5da863877846a8913d3e3a6c894583243845a1dd949f7f3fe31ce8c9690101e3b504bee7ee63a46ad12097a7bfbc7efbeeacec848f6996a50fb0d594adbf090caaabdfcf47abe5c8979cd6e84550905330b37d1fdc4e54261828c421eb99d2cd2f294b7a2967c3876dd5ccbacfba552d77b68cb8ab06d89d0bf67836a847479eeef7113782617df4a81953a56927aa9c6d84682137ef286071dc4f3d7154722865d5796760cf9581d149169d64d149169d646170e8b00181422759fa7352ae177492a5ae86f7f51f6466baa403726919b74435a00319558bece615599fa25b3c5a8b288916c562875f929626d69e20b8a8a78e1e8aa1eb923f7166122c1597d6e491329320a9b9347c96f45c1a44284557577cad5d8fbf0bb6af5bda2e55859b7d52157718a0f207ec041f8db1a7f2d25a644be735755bec734383dd9ae2ab1376f0efd7886a77b4874ce86d0551fba8c2bbc3c9d3618c6cd99554c10955cb966d4903dd927149c38d665df2891acfc0a4e1b66761326023999814701fb301c9cad4806c4b27a64146923329b83419bac2a6c9b0a793014f53a661b6cd06e36f005657bbd40009a52e33914de434b0a433d330619e837150d9529cf98235b12d82a63fd3da33629a44ecb2be86124f89a6c144afec0f058aa548d340dad2a46930c154690ae29009de9636cdc08aa54ed3b0facc9cd8489886fbe9d452349a87ae8291e3d13ea22ad3d763b7adc1f7d9b548058b15b5f2150dd1266cb5753949d3fa629f8211c68f84d9e3a829c5993eb29825c15e464ef90aa5a090cb671472e99a31afef0afcd04858e7f5c0e4e8fae87ffaef01b7011bffe5ffb4a3ff2cde02706170706c69636174696f6e2f6a736f6e03676465666c61746500000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}