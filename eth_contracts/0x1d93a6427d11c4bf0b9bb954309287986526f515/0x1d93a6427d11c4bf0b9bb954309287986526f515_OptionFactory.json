{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/option/OptionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../interfaces/IOptionFactory.sol\\\";\\nimport \\\"../interfaces/IStakingPools.sol\\\";\\nimport \\\"../interfaces/IDOBStakingPool.sol\\\";\\nimport \\\"../interfaces/IContractGenerator.sol\\\";\\nimport \\\"../interfaces/IOption.sol\\\";\\n\\n/**\\n * @title OptionFactory\\n * @author DeOrderBook\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\n * @notice The OptionFactory contract is the primary control center for creating and managing options and staking pools within the ecosystem. It provides functionalities to set and update various fee ratios, to extend the staking pool end block, to update option funds, and to manage the lifecycle of options.\\n * @dev This contract is designated as 'Ownable', meaning it has an owner address, and guards against unauthorized access by checking the 'onlyOwner' modifier. It interfaces with the IOptionFactory, IDOBStakingPool, and IStakingPools contracts to perform various tasks related to option and staking pool management.\\n */\\ncontract OptionFactory is OwnableUpgradeable, IOptionFactory {\\n    using SafeMathUpgradeable for uint256;\\n\\n    /**\\n     * @notice The time taken (in seconds) for a block to be mined.\\n     * @dev This value is public.\\n     */\\n    uint8 public blockTime;\\n\\n    /**\\n     * @notice The staking reward given per block.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    uint256 public stakingRewardPerBlock;\\n\\n    /**\\n     * @notice The address of the staking pools contract.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    address public stakingPools;\\n\\n    /**\\n     * @notice The address of the DOB Staking Pool contract.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    address public DOBStakingPool;\\n\\n    /**\\n     * @notice The address of the bHODL token contract.\\n     * @dev This value is public.\\n     */\\n    address public bHODL;\\n\\n    /**\\n     * @notice The address of the uHODL token contract.\\n     * @dev This value is public.\\n     */\\n    address public uHODL;\\n\\n    /**\\n     * @notice The address of the distributions contract.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    address public override distributions;\\n\\n    /**\\n     * @notice The address of the ContractGenerator contract.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    address public ContractGenerator;\\n\\n    /**\\n     * @notice The address of the fund contract.\\n     * @dev This value is public and can be updated by the contract owner.\\n     */\\n    address public fund;\\n\\n    /**\\n     * @notice The ID of the last option that was created.\\n     * @dev This value is private and incremented every time a new option is created.\\n     */\\n    uint256 private lastOptionId;\\n\\n    /**\\n     * @notice The address of the clone bullet contract.\\n     * @dev This value is private and updated every time a new bullet is cloned.\\n     */\\n    address private cloneBullet;\\n\\n    /**\\n     * @notice The address of the clone sniper contract.\\n     * @dev This value is private and updated every time a new sniper is cloned.\\n     */\\n    address private cloneSniper;\\n\\n    /**\\n     * @notice The ID of the clone option contract.\\n     * @dev This value is private and updated every time a new option is cloned.\\n     */\\n    uint256 private cloneOptionId;\\n\\n    /**\\n     * @notice A structure for storing the addresses of the option, sniper, and bullet contracts.\\n     * @dev The structure is private and used when a new option is created.\\n     */\\n    struct BlankOption {\\n        address option;\\n        address sniper;\\n        address bullet;\\n    }\\n    BlankOption[] private blankOptions;\\n\\n    /**\\n     * @notice The count of blank options in the factory.\\n     * @dev This public variable is used to keep track of the number of blank options currently stored in the contract.\\n     *      It's specifically meant to facilitate easy retrieval of the length of the `blankOptions` array.\\n     */\\n    uint256 public blankOptionCount;\\n\\n    /**\\n     * @notice A mapping of option ID to option contract address.\\n     * @dev This mapping is private and updated every time a new option is created.\\n     */\\n    mapping(uint256 => address) private allOptions;\\n\\n    /**\\n     * @notice A mapping of operator address to their whitelisted status.\\n     * @dev This mapping is public and can be updated by the contract owner.\\n     */\\n    mapping(address => bool) public operatorWhitelist;\\n\\n    /**\\n     * @notice Event emitted when a new option is created.\\n     * @dev Contains details about the option, including its ID, contract addresses, strike price, timestamps, and type.\\n     */\\n    event OptionCreated(\\n        uint256 optionID,\\n        address indexed option,\\n        address indexed bullet,\\n        address indexed sniper,\\n        uint256 strikePrice,\\n        uint256 startTimestamp,\\n        uint256 exerciseTimestamp,\\n        uint256 optionType\\n    );\\n\\n    /**\\n     * @notice Event emitted when the staking reward per block is updated.\\n     * @dev Contains the old and new reward values.\\n     */\\n    event StakingRewardPerBlockChanged(uint256 oldReward, uint256 newReward);\\n\\n    /**\\n     * @notice Event emitted when the staking pool address is updated.\\n     * @dev Contains the old and new staking pool addresses.\\n     */\\n    event StakingPoolChanged(address oldStakingPool, address newStakingPool);\\n\\n    /**\\n     * @notice Event emitted when the DOB Staking Pool address is updated.\\n     * @dev Contains the old and new DOB Staking Pool addresses.\\n     */\\n    event DOBStakingChanged(address oldDOBStaking, address newDOBStaking);\\n\\n    /**\\n     * @notice Event emitted when the distributions address is updated.\\n     * @dev Contains the old and new distributions addresses.\\n     */\\n    event DistribuionsChanged(address oldDDistribuions, address newDistribuions);\\n\\n    /**\\n     * @notice Event emitted when the block time is updated.\\n     * @dev Contains the old and new block time values.\\n     */\\n    event BlockTimeChanged(uint8 oldBlockTime, uint8 newBlocktime);\\n\\n    /**\\n     * @notice Event emitted when an operator's whitelist status is updated.\\n     * @dev Contains the operator's address and their new whitelist status.\\n     */\\n    event WhitelistChanged(address operator, bool isWhitelisted);\\n\\n    /**\\n     * @notice Modifier that requires the caller to be whitelisted.\\n     * @dev This modifier is used to restrict certain functions to whitelisted operators.\\n     */\\n    modifier onlyWhitelist(address _operator) {\\n        require(operatorWhitelist[_operator], \\\"OptionFactory: Only whitelist\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the OptionFactory contract.\\n     * @dev This is a public function with the initializer modifier, which ensures that it can only be called once, when the contract is first created.\\n     * - The function first initializes the contract ownership by calling the __Ownable_init function.\\n     * - It then verifies that the provided bHODL and uHODL addresses are not the zero address.\\n     * - The function sets the bHODL and uHODL addresses, and the block time, and the staking reward per block.\\n     * @param _bHodlAddress The address of the bHODL token.\\n     * @param _uHodlAddress The address of the uHODL token.\\n     * @custom:error \\\"OptionFactory: zero address\\\" Error thrown if either the bHODL or uHODL address is the zero address.\\n     */\\n    function __OptionFactory_init(address _bHodlAddress, address _uHodlAddress) public initializer {\\n        __Ownable_init();\\n        require(_bHodlAddress != address(0), \\\"OptionFactory: zero address\\\");\\n        require(_uHodlAddress != address(0), \\\"OptionFactory: zero address\\\");\\n\\n        bHODL = _bHodlAddress;\\n        uHODL = _uHodlAddress;\\n        blockTime = 12;\\n        stakingRewardPerBlock = 1.38 * 1e18; // 1.38 DOB per block\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to adjust the block time.\\n     * @dev Sets the block time. Must be called by the contract owner.\\n     * @param _blockTime The block time needed by the system.\\n     */\\n    function setBlockTime(uint8 _blockTime) external onlyOwner {\\n        require(_blockTime > 0, \\\"OptionFactory: zero blockTime\\\");\\n        uint8 oldBlockTime = blockTime;\\n        blockTime = _blockTime;\\n        emit BlockTimeChanged(oldBlockTime, blockTime);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the address of the staking pools.\\n     * @dev Sets the staking pools address. Must be called by the contract owner.\\n     * @param _stakingPools The address of the new staking pools.\\n     */\\n    function setStakingPools(address _stakingPools) external onlyOwner {\\n        require(_stakingPools != address(0), \\\"OptionFactory: zero address\\\");\\n        address oldStakingPools = stakingPools;\\n        stakingPools = _stakingPools;\\n        emit StakingPoolChanged(oldStakingPools, stakingPools);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the address of the DOB staking pool.\\n     * @dev Sets the DOB staking pool address. Must be called by the contract owner.\\n     * @param _DOBstaking The address of the new DOB staking pool.\\n     */\\n    function setDOBStakingPool(address _DOBstaking) external onlyOwner {\\n        require(_DOBstaking != address(0), \\\"OptionFactory: zero address\\\");\\n        address oldDOBStaking = DOBStakingPool;\\n        DOBStakingPool = _DOBstaking;\\n        emit DOBStakingChanged(oldDOBStaking, DOBStakingPool);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to manage the list of authorized operators.\\n     * @dev Adds or removes an operator from the whitelist. Must be called by the contract owner.\\n     * @param _operator The address of the operator.\\n     * @param _isWhitelisted A boolean indicating whether the operator is whitelisted.\\n     */\\n    function setWhitelist(address _operator, bool _isWhitelisted) public onlyOwner {\\n        require(_operator != address(0), \\\"Market: Zero address\\\");\\n        operatorWhitelist[_operator] = _isWhitelisted;\\n        emit WhitelistChanged(_operator, _isWhitelisted);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the address of the distributions contract.\\n     * @dev Sets the distributions address. Must be called by the contract owner.\\n     * @param _distributions The address of the new distributions contract.\\n     */\\n    function setDistributions(address _distributions) external onlyOwner {\\n        require(_distributions != address(0), \\\"OptionFactory: zero address\\\");\\n        address oldistributions = distributions;\\n        distributions = _distributions;\\n        emit DistribuionsChanged(oldistributions, _distributions);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the staking reward per block.\\n     * @dev Sets the reward per block for staking. Must be called by the contract owner.\\n     * @param _reward The new staking reward per block.\\n     */\\n    function setStakingRewardPerBlock(uint256 _reward) external onlyOwner {\\n        uint256 oldReward = stakingRewardPerBlock;\\n        stakingRewardPerBlock = _reward;\\n        emit StakingRewardPerBlockChanged(oldReward, stakingRewardPerBlock);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the address of the contract generator.\\n     * @dev Sets the contract generator address. Must be called by the contract owner.\\n     * @param _ContractGenerator The address of the new contract generator.\\n     */\\n    function setContractGenerator(address _ContractGenerator) external onlyOwner {\\n        require(_ContractGenerator != address(0), \\\"OptionFactory: zero address\\\");\\n        ContractGenerator = _ContractGenerator;\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the address of the fund.\\n     * @dev Sets the fund address. Must be called by the contract owner.\\n     * @param _fund The address of the new fund.\\n     */\\n    function setFund(address _fund) external onlyOwner {\\n        require(_fund != address(0), \\\"OptionFactory: zero address\\\");\\n        fund = _fund;\\n    }\\n\\n    /**\\n     * @notice Fetches the last option id created\\n     * @dev Returns the last option id. Does not require ownership or specific permissions to call.\\n     * @return lastOptionId The ID of the last created option.\\n     */\\n    function getLastOptionId() external view override returns (uint256) {\\n        return lastOptionId;\\n    }\\n\\n    /**\\n     * @notice Fetches the contract address of a particular option by ID\\n     * @dev Returns the address of the specified option. Does not require ownership or specific permissions to call.\\n     * @param _optionID The ID of the option.\\n     * @return address The address of the option.\\n     */\\n    function getOptionByID(uint256 _optionID) external view override returns (address) {\\n        return allOptions[_optionID];\\n    }\\n\\n    /**\\n     * @notice Fetches the address of the staking pools.\\n     * @dev Returns the address of the staking pools. Does not require ownership or specific permissions to call.\\n     * @return stakingPools The address of the staking pools.\\n     */\\n    function getStakingPools() external view override returns (address) {\\n        return stakingPools;\\n    }\\n\\n    /**\\n     * @notice Creates a new option contract with specified parameters. Returns the ID of the newly created option.\\n     * @dev Must be called by an operator from the whitelist. Initializes the option contract, creates tokens,\\n     *      sets up option details, and creates a pool in the staking contract. Also adds the option to DOBStakingPool.\\n     * @param _strikePrice The strike price of the new option.\\n     * @param _startTimestamp The start timestamp of the new option.\\n     * @param _exerciseTimestamp The exercise timestamp of the new option.\\n     * @param _optionType The type of the new option (0 for call, 1 for put).\\n     * @return optionID The ID of the newly created option.\\n     */\\n    function createOption(\\n        uint256 _strikePrice,\\n        uint256 _startTimestamp,\\n        uint256 _exerciseTimestamp,\\n        uint8 _optionType\\n    ) external override onlyWhitelist(msg.sender) returns (uint256 optionID) {\\n        require(_strikePrice > 0, \\\"OptionFactory: zero strike price\\\");\\n        require(_startTimestamp > block.timestamp, \\\"OptionFactory: Illegal start time\\\");\\n        require(_exerciseTimestamp > _startTimestamp, \\\"OptionFactory: Illegal exercise time\\\");\\n        require(_optionType <= 1, \\\"OptionFactory: Illegal type\\\");\\n\\n        address option;\\n        address bullet;\\n        address sniper;\\n\\n        optionID = ++lastOptionId;\\n\\n        option = IContractGenerator(ContractGenerator).createOptionContract(\\n            _strikePrice,\\n            _exerciseTimestamp,\\n            _optionType,\\n            address(this)\\n        );\\n        IOption(option).initialize(_strikePrice, _exerciseTimestamp, _optionType);\\n        (bullet, sniper) = IContractGenerator(ContractGenerator).createToken(optionID, option);\\n        cloneBullet = bullet;\\n        cloneSniper = sniper;\\n        cloneOptionId = optionID;\\n        allOptions[optionID] = option;\\n\\n        {\\n            uint256 startTimestamp = _startTimestamp;\\n            uint256 startBlock = startTimestamp.sub(block.timestamp).div(uint256(blockTime)).add(block.number);\\n            IOption(option).setup(optionID, startBlock, uHODL, bHODL, fund, bullet, sniper);\\n\\n            uint256 exerciseTimestamp = _exerciseTimestamp;\\n            uint256 endBlock = exerciseTimestamp.sub(block.timestamp).div(uint256(blockTime)).add(block.number);\\n            IStakingPools(stakingPools).createPool(sniper, option, startBlock, endBlock, stakingRewardPerBlock);\\n        }\\n        {\\n            IDOBStakingPool(DOBStakingPool).addOption(option, bullet, sniper);\\n        }\\n        {\\n            uint256 strikePrice = _strikePrice;\\n            uint256 startTimestamp = _startTimestamp;\\n            uint256 exerciseTimestamp = _exerciseTimestamp;\\n            uint8 optionTpye = _optionType;\\n            emit OptionCreated(optionID, option, bullet, sniper, strikePrice, startTimestamp, exerciseTimestamp, optionTpye);\\n        }\\n    }\\n\\n    /**\\n     * @notice Clones an existing option a certain number of times.\\n     * @dev Clones an existing option and creates tokens for the clones. Must be called by an operator from the whitelist.\\n     * @param _num The number of clones to create.\\n     */\\n    function cloneOption(uint8 _num) external onlyWhitelist(msg.sender) {\\n        require(_num <= 24, \\\"OptionFactory: number must less than 24\\\");\\n        address bullet;\\n        address sniper;\\n        address clone_option = allOptions[cloneOptionId];\\n        for (uint8 i = 0; i < _num; i++) {\\n            address option = IContractGenerator(ContractGenerator).cloneOptionPool(clone_option, address(this));\\n            (bullet, sniper) = IContractGenerator(ContractGenerator).cloneToken(option, cloneBullet, cloneSniper);\\n\\n            blankOptions.push(BlankOption({option: option, bullet: bullet, sniper: sniper}));\\n        }\\n        blankOptionCount = blankOptions.length;\\n    }\\n\\n    /**\\n     * @notice Activates a set of options with specified parameters.\\n     * @dev Activates options by initializing them, setting them up, and adding them to DOBStakingPool.\\n     *      Also creates a pool in the staking contract for each option. Must be called by an operator from the whitelist.\\n     * @param _strikePrices The strike prices of the options to be activated.\\n     * @param _startTimestamps The start timestamps of the options to be activated.\\n     * @param _exerciseTimestamps The exercise timestamps of the options to be activated.\\n     * @param _optionTypes The types of the options to be activated.\\n     */\\n    function activateOption(\\n        uint256[] memory _strikePrices,\\n        uint256[] memory _startTimestamps,\\n        uint256[] memory _exerciseTimestamps,\\n        uint8[] memory _optionTypes\\n    ) external onlyWhitelist(msg.sender) {\\n        require(_strikePrices.length == _startTimestamps.length, \\\"OptionFactory: List length not equal\\\");\\n        require(_startTimestamps.length == _exerciseTimestamps.length, \\\"OptionFactory: List length not equal\\\");\\n        require(_exerciseTimestamps.length == _optionTypes.length, \\\"OptionFactory: List Length not equal\\\");\\n        require(_strikePrices.length <= blankOptions.length, \\\"OptionFactory: Insufficient blank Option\\\");\\n\\n        uint256 arrayLength = _strikePrices.length;\\n        uint256 optionID;\\n        uint256 blankOptionsLen = blankOptions.length;\\n\\n        for (uint8 i = 0; i < arrayLength; i++) {\\n            uint256 strikePrice = _strikePrices[i];\\n            uint256 startTimestamp = _startTimestamps[i];\\n            uint256 exerciseTimestamp = _exerciseTimestamps[i];\\n            uint8 optionType = _optionTypes[i];\\n\\n            require(strikePrice > 0, \\\"OptionFactory: zero strike price\\\");\\n            require(startTimestamp > block.timestamp, \\\"OptionFactory: Illegal start time\\\");\\n            require(exerciseTimestamp > startTimestamp, \\\"OptionFactory: Illegal exercise time\\\");\\n            require(optionType <= 1, \\\"OptionFactory: Illegal type\\\");\\n\\n            BlankOption memory blankOption = blankOptions[blankOptionsLen - i - 1];\\n            optionID = ++lastOptionId;\\n            address option = blankOption.option;\\n            address bullet = blankOption.bullet;\\n            address sniper = blankOption.sniper;\\n            IOption(option).initialize(strikePrice, exerciseTimestamp, optionType);\\n\\n            allOptions[optionID] = option;\\n\\n            {\\n                uint256 startBlock = startTimestamp.sub(block.timestamp).div(uint256(blockTime)).add(block.number);\\n                IOption(option).setup(optionID, startBlock, uHODL, bHODL, fund, bullet, sniper);\\n\\n                uint256 endBlock = exerciseTimestamp.sub(block.timestamp).div(uint256(blockTime)).add(block.number);\\n                IStakingPools(stakingPools).createPool(sniper, option, startBlock, endBlock, stakingRewardPerBlock);\\n            }\\n            {\\n                IDOBStakingPool(DOBStakingPool).addOption(option, bullet, sniper);\\n            }\\n            {\\n                emit OptionCreated(\\n                    optionID,\\n                    option,\\n                    bullet,\\n                    sniper,\\n                    strikePrice,\\n                    startTimestamp,\\n                    exerciseTimestamp,\\n                    optionType\\n                );\\n            }\\n        }\\n        for (uint8 i = 0; i < arrayLength; i++) {\\n            blankOptions.pop();\\n        }\\n        blankOptionCount = blankOptions.length;\\n    }\\n\\n    /**\\n     * @notice Updates the strike prices of the specified options.\\n     * @dev Must be called by an operator from the whitelist.\\n     * @param _optionIds The IDs of the options to be updated.\\n     * @param _strikePrices The new strike prices.\\n     */\\n    function updateOptionStrike(uint256[] memory _optionIds, uint256[] memory _strikePrices)\\n        external\\n        onlyWhitelist(msg.sender)\\n    {\\n        require(_optionIds.length == _strikePrices.length, \\\"OptionFactory:List length not equal\\\");\\n        uint256 arrayLength = _strikePrices.length;\\n        for (uint8 i = 0; i < arrayLength; i++) {\\n            uint256 optionId = _optionIds[i];\\n            uint256 strikePirce = _strikePrices[i];\\n            address option = allOptions[optionId];\\n            IOption(option).updateStrike(strikePirce);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the exercise fee ratio for a specific option.\\n     * @dev The new fee ratio must be in the range [0, 100].maximum ratio is 10%\\n     * @param optionId The ID of the option.\\n     * @param _feeRatio The new exercise fee ratio.\\n     */\\n    function setOptionExerciseFeeRatio(uint256 optionId, uint16 _feeRatio) external onlyOwner {\\n        require(0 <= _feeRatio && _feeRatio <= 100, \\\"OptionFactory: Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setOptionExerciseFeeRatio(_feeRatio);\\n    }\\n\\n    /**\\n     * @notice Sets the withdraw fee ratio for a specific option.\\n     * @dev The new fee ratio must be in the range [0, 100].maximum ratio is 10%\\n     * @param optionId The ID of the option.\\n     * @param _feeRatio The new withdraw fee ratio.\\n     */\\n    function setOptionWithdrawFeeRatio(uint256 optionId, uint16 _feeRatio) external onlyOwner {\\n        require(0 <= _feeRatio && _feeRatio <= 100, \\\"OptionFactory: Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setOptionWithdrawFeeRatio(_feeRatio);\\n    }\\n\\n    /**\\n     * @notice Sets the redeem fee ratio for a specific option.\\n     * @dev The new fee ratio must be in the range [0, 100].maximum ratio is 10%\\n     * @param optionId The ID of the option.\\n     * @param _feeRatio The new redeem fee ratio.\\n     */\\n    function setOptionRedeemFeeRatio(uint256 optionId, uint16 _feeRatio) external onlyOwner {\\n        require(0 <= _feeRatio && _feeRatio <= 100, \\\"OptionFactory: Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setOptionRedeemFeeRatio(_feeRatio);\\n    }\\n\\n    /**\\n     * @notice Sets the bullet to reward ratio for a specific option.\\n     * @dev The new ratio must be in the range [0, 80].\\n     * @param optionId The ID of the option.\\n     * @param _feeRatio The new bullet to reward ratio.\\n     */\\n    function setOptionBulletToRewardRatio(uint256 optionId, uint16 _feeRatio) external onlyOwner {\\n        require(0 <= _feeRatio && _feeRatio <= 80, \\\"OptionFactory: Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setOptionBulletToRewardRatio(_feeRatio);\\n    }\\n\\n    /**\\n     * @notice Sets the entry fee ratio for a specific option.\\n     * @dev The new fee ratio must be in the range [0, 100].maximum ratio is 10%\\n     * @param optionId The ID of the option.\\n     * @param _feeRatio The new entry fee ratio.\\n     */\\n    function setOptionEntryFeeRatio(uint256 optionId, uint16 _feeRatio) external onlyOwner {\\n        require(0 <= _feeRatio && _feeRatio <= 100, \\\"OptionFactory: Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setOptionEntryFeeRatio(_feeRatio);\\n    }\\n\\n    /**\\n     * @notice Extends the end block of the staking pool for a specific option.\\n     * @param optionId The ID of the option.\\n     * @param newEndBlock The new end block for the staking pool.\\n     */\\n    function extendStakingPoolEndBlock(uint256 optionId, uint256 newEndBlock) public onlyOwner {\\n        IStakingPools(stakingPools).extendEndBlock(optionId, newEndBlock);\\n    }\\n\\n    /**\\n     * @notice Sets all ratios for a specific option.\\n     * @dev All ratios must be in their respective legal value ranges.\\n     * @param optionId The ID of the option.\\n     * @param _entryFeeRatio The new entry fee ratio.\\n     * @param _exerciseFeeRatio The new exercise fee ratio.\\n     * @param _withdrawFeeRatio The new withdraw fee ratio.\\n     * @param _redeemFeeRatio The new redeem fee ratio.\\n     * @param _bulletToRewardRatio The new bullet to reward ratio.\\n     */\\n    function setOptionAllRatio(\\n        uint256 optionId,\\n        uint16 _entryFeeRatio,\\n        uint16 _exerciseFeeRatio,\\n        uint16 _withdrawFeeRatio,\\n        uint16 _redeemFeeRatio,\\n        uint16 _bulletToRewardRatio\\n    ) external onlyOwner {\\n        require(0 <= _entryFeeRatio && _entryFeeRatio <= 100, \\\"Option: entryFeeRatio Illegal value range\\\");\\n        require(0 <= _exerciseFeeRatio && _exerciseFeeRatio <= 100, \\\"Option: exerciseFeeRatio Illegal value range\\\");\\n        require(0 <= _withdrawFeeRatio && _withdrawFeeRatio <= 100, \\\"Option: withdrawFeeRatio Illegal value range\\\");\\n        require(0 <= _redeemFeeRatio && _redeemFeeRatio <= 100, \\\"Option: redeemFeeRatio Illegal value range\\\");\\n        require(0 <= _bulletToRewardRatio && _bulletToRewardRatio <= 80, \\\"Option: bulletToRewardRatio Illegal value range\\\");\\n        address option = allOptions[optionId];\\n        IOption(option).setAllRatio(\\n            _entryFeeRatio,\\n            _exerciseFeeRatio,\\n            _withdrawFeeRatio,\\n            _redeemFeeRatio,\\n            _bulletToRewardRatio\\n        );\\n    }\\n\\n    /**\\n     * @notice Updates the fund address for a list of options.\\n     * @dev The fund address must not be the zero address.\\n     * @param optionIds The ID of the option.\\n     * @param _fund The new fund address.\\n     */\\n    function updateOptionFund(uint256[] memory optionIds, address _fund) external onlyOwner {\\n        require(_fund != address(0), \\\"OptionFactory: zero address\\\");\\n        for (uint256 i = 0; i < optionIds.length; i++) {\\n            address option = allOptions[optionIds[i]];\\n            IOption(option).setFund(_fund);\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes an activated option from the DOBStakingPool.\\n     * @dev The option address must not be the zero address.\\n     * @param _optionAddress The address of the option to remove.\\n     */\\n    function removeActivatedOptions(address _optionAddress) external onlyOwner {\\n        require(_optionAddress != address(0), \\\"OptionFactory: zero address\\\");\\n        IDOBStakingPool(DOBStakingPool).removeOption(_optionAddress);\\n    }\\n\\n    /**\\n     * @notice Removes all options from the blankOptions array.\\n     * @dev Iterates through the blankOptions array and removes each element.\\n     */\\n    function emptyBlankOptions() external onlyOwner {\\n        uint256 blankOptionsLen = blankOptions.length;\\n        for (uint8 i = 0; i < blankOptionsLen; i++) {\\n            blankOptions.pop();\\n        }\\n        blankOptionCount = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title IOptionFactory interface\\r\\n * @author DeOrderBook\\r\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\r\\n * @dev Interface for managing option factory contracts\\r\\n */\\r\\ninterface IOptionFactory {\\r\\n    /**\\r\\n     * @notice Get the ID of the last created option contract\\r\\n     * @dev Returns the ID of the last created option contract\\r\\n     * @return The ID of the last created option contract\\r\\n     */\\r\\n    function getLastOptionId() external view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @notice Create a new option contract with the specified parameters\\r\\n     * @dev Creates a new option contract with the specified strike price, start timestamp, exercise timestamp, and option type\\r\\n     * @param _strikePrice The strike price of the option\\r\\n     * @param _startTimestamp The start timestamp of the option\\r\\n     * @param _exerciseTimestamp The exercise timestamp of the option\\r\\n     * @param _optionType The type of the option (i.e., call or put)\\r\\n     * @return optionID The ID of the newly created option contract\\r\\n     */\\r\\n    function createOption(\\r\\n        uint256 _strikePrice,\\r\\n        uint256 _startTimestamp,\\r\\n        uint256 _exerciseTimestamp,\\r\\n        uint8 _optionType\\r\\n    ) external returns (uint256 optionID);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the address of the option contract with the specified ID\\r\\n     * @dev Returns the address of the option contract with the specified ID\\r\\n     * @param _optionID The ID of the option contract to retrieve the address for\\r\\n     * @return The address of the option contract\\r\\n     */\\r\\n    function getOptionByID(uint256 _optionID) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the address of the staking pool contract\\r\\n     * @dev Returns the address of the staking pool contract\\r\\n     * @return The address of the staking pool contract\\r\\n     */\\r\\n    function getStakingPools() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the address of the distributions contract\\r\\n     * @dev Returns the address of the distributions contract\\r\\n     * @return The address of the distributions contract\\r\\n     */\\r\\n    function distributions() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title IStakingPools interface\\r\\n * @author DeOrderBook\\r\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\r\\n * @dev Interface for staking pools contract\\r\\n */\\r\\ninterface IStakingPools {\\r\\n    /**\\r\\n     * @notice Create a new staking pool\\r\\n     * @dev Creates a new staking pool with the specified parameters\\r\\n     * @param token The address of the ERC20 token contract to be staked\\r\\n     * @param optionContract The address of the Option contract\\r\\n     * @param startBlock The block number at which staking begins\\r\\n     * @param endBlock The block number at which staking ends\\r\\n     * @param rewardPerBlock The amount of reward tokens to be distributed per block\\r\\n     */\\r\\n    function createPool(\\r\\n        address token,\\r\\n        address optionContract,\\r\\n        uint256 startBlock,\\r\\n        uint256 endBlock,\\r\\n        uint256 rewardPerBlock\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Extend the end block of a staking pool\\r\\n     * @dev Extends the end block of a staking pool with the specified pool ID\\r\\n     * @param poolId The ID of the staking pool to extend\\r\\n     * @param newEndBlock The new end block of the staking pool\\r\\n     */\\r\\n    function extendEndBlock(uint256 poolId, uint256 newEndBlock) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Get the staking amount for a user and pool ID\\r\\n     * @dev Gets the staking amount for the specified user and pool ID\\r\\n     * @param user The address of the user to get the staking amount for\\r\\n     * @param poolId The ID of the staking pool to get the staking amount for\\r\\n     * @return The staking amount for the specified user and pool ID\\r\\n     */\\r\\n    function getStakingAmountByPoolID(address user, uint256 poolId) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Stake tokens on behalf of a user\\r\\n     * @dev Stakes tokens on behalf of the specified user for the specified staking pool\\r\\n     * @param poolId The ID of the staking pool to stake tokens for\\r\\n     * @param amount The amount of tokens to stake\\r\\n     * @param user The address of the user to stake tokens for\\r\\n     */\\r\\n    function stakeFor(uint256 poolId, uint256 amount, address user) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unstake tokens on behalf of a user\\r\\n     * @dev Unstakes tokens on behalf of the specified user for the specified staking pool\\r\\n     * @param poolId The ID of the staking pool to unstake tokens for\\r\\n     * @param amount The amount of tokens to unstake\\r\\n     * @param user The address of the user to unstake tokens for\\r\\n     */\\r\\n    function unstakeFor(uint256 poolId, uint256 amount, address user) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem rewards for a user and pool ID\\r\\n     * @dev Redeems rewards for the specified user and pool ID\\r\\n     * @param poolId The ID of the staking pool to redeem rewards from\\r\\n     * @param user The address of the user to redeem rewards for\\r\\n     */\\r\\n    function redeemRewardsByAddress(uint256 poolId, address user) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDOBStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title IDOBStakingPool interface\\r\\n * @author DeOrderBook\\r\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\r\\n * @dev Interface for managing staking pools for DOB options\\r\\n */\\r\\ninterface IDOBStakingPool {\\r\\n    /**\\r\\n     * @notice Add an option to the staking pool\\r\\n     * @dev Adds the specified option to the staking pool and associates it with the specified Bullet and Sniper tokens\\r\\n     * @param _optionAddress The address of the option contract to add\\r\\n     * @param _bulletAddress The address of the associated BULLET token contract\\r\\n     * @param _sniperAddress The address of the associated SNIPER token contract\\r\\n     */\\r\\n    function addOption(address _optionAddress, address _bulletAddress, address _sniperAddress) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Remove an option from the staking pool\\r\\n     * @dev Removes the specified option from the staking pool\\r\\n     * @param _optionAddress The address of the option contract to remove\\r\\n     */\\r\\n    function removeOption(address _optionAddress) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IContractGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title IContractGenerator interface\\r\\n * @author DeOrderBook\\r\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\r\\n * @dev Interface for generating and cloning token and option contract instances\\r\\n */\\r\\ninterface IContractGenerator {\\r\\n    /**\\r\\n     * @notice Create a new BULLET and SNIPER token pair for the specified option\\r\\n     * @dev Generates a new token pair associated with the given option\\r\\n     * @param optionId The ID of the option associated with the token pair\\r\\n     * @param optionAddress The address of the option contract\\r\\n     * @return bullet The address of the newly created BULLET token\\r\\n     * @return sniper The address of the newly created SNIPER token\\r\\n     */\\r\\n    function createToken(uint256 optionId, address optionAddress) external returns (address bullet, address sniper);\\r\\n\\r\\n    /**\\r\\n     * @notice Clone existing Bullet and Sniper tokens for a new option contract\\r\\n     * @dev Creates new token instances by cloning the provided Bullet and Sniper token sources\\r\\n     * @param _optionAddress The address of the option contract associated with the new tokens\\r\\n     * @param _bulletSource The address of the source Bullet token to clone\\r\\n     * @param _sniperSource The address of the source Sniper token to clone\\r\\n     * @return bullet The address of the newly cloned Bullet token\\r\\n     * @return sniper The address of the newly cloned Sniper token\\r\\n     */\\r\\n    function cloneToken(\\r\\n        address _optionAddress,\\r\\n        address _bulletSource,\\r\\n        address _sniperSource\\r\\n    ) external returns (address bullet, address sniper);\\r\\n\\r\\n    /**\\r\\n     * @notice Clone an existing option pool for a new target address\\r\\n     * @dev Creates a new option pool instance by cloning the specified target pool\\r\\n     * @param _targetAddress The address of the target option pool to clone\\r\\n     * @param _optionFactory The address of the option factory contract\\r\\n     * @return option The address of the newly cloned option pool\\r\\n     */\\r\\n    function cloneOptionPool(address _targetAddress, address _optionFactory) external returns (address option);\\r\\n\\r\\n    /**\\r\\n     * @notice Create a new option contract with the specified parameters\\r\\n     * @dev Generates a new option contract instance with the specified strike price, exercise timestamp, and option type\\r\\n     * @param _strikePrice The strike price of the new option\\r\\n     * @param _exerciseTimestamp The exercise timestamp of the new option\\r\\n     * @param _optionType The type of the new option (i.e., call or put)\\r\\n     * @param _optionFactory The address of the option factory contract\\r\\n     * @return option The address of the newly created option contract\\r\\n     */\\r\\n    function createOptionContract(\\r\\n        uint256 _strikePrice,\\r\\n        uint256 _exerciseTimestamp,\\r\\n        uint8 _optionType,\\r\\n        address _optionFactory\\r\\n    ) external returns (address option);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title IOption interface\\r\\n * @author DeOrderBook\\r\\n * @custom:license Copyright (c) DeOrderBook, 2023 \u2014 All Rights Reserved\\r\\n * @dev Interface for managing options contracts\\r\\n */\\r\\ninterface IOption {\\r\\n    /**\\r\\n     * @notice Get the expiry time of the option\\r\\n     * @dev Returns the expiry time of the option in seconds since the Unix epoch\\r\\n     * @return The expiry time of the option\\r\\n     */\\r\\n    function getExpiryTime() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the option contract with the specified parameters\\r\\n     * @dev Initializes the option contract with the specified strike price, exercise timestamp, and option type\\r\\n     * @param _strikePrice The strike price of the option\\r\\n     * @param _exerciseTimestamp The exercise timestamp of the option\\r\\n     * @param _type The type of the option (i.e., call or put)\\r\\n     */\\r\\n    function initialize(uint256 _strikePrice, uint256 _exerciseTimestamp, uint8 _type) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set up the option contract with the specified parameters\\r\\n     * @dev Sets up the option contract with the specified option ID, start block, uHODL and bHODL token addresses, fund address, and Bullet and Sniper token addresses\\r\\n     * @param _optionID The ID of the option contract\\r\\n     * @param _startBlock The start block of the option contract\\r\\n     * @param _uHODLAddress The address of the uHODL token contract\\r\\n     * @param _bHODLTokenAddress The address of the bHODL token contract\\r\\n     * @param _fund The address of the fund contract\\r\\n     * @param _bullet The address of the BULLET token contract\\r\\n     * @param _sniper The address of the SNIPER token contract\\r\\n     */\\r\\n    function setup(\\r\\n        uint256 _optionID,\\r\\n        uint256 _startBlock,\\r\\n        address _uHODLAddress,\\r\\n        address _bHODLTokenAddress,\\r\\n        address _fund,\\r\\n        address _bullet,\\r\\n        address _sniper\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update the strike price of the option\\r\\n     * @dev Updates the strike price of the option to the specified value\\r\\n     * @param _strikePrice The new strike price of the option\\r\\n     */\\r\\n    function updateStrike(uint256 _strikePrice) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set all fee and reward ratios for the option contract\\r\\n     * @dev Sets all fee and reward ratios for the option contract to the specified values\\r\\n     * @param _entryFeeRatio The entry fee ratio to set in basis points\\r\\n     * @param _exerciseFeeRatio The exercise fee ratio to set in basis points\\r\\n     * @param _withdrawFeeRatio The withdraw fee ratio to set in basis points\\r\\n     * @param _redeemFeeRatio The redeem fee ratio to set in basis points\\r\\n     * @param _bulletToRewardRatio The BULLET-to-reward ratio to in base 100\\r\\n     */\\r\\n    function setAllRatio(\\r\\n        uint16 _entryFeeRatio,\\r\\n        uint16 _exerciseFeeRatio,\\r\\n        uint16 _withdrawFeeRatio,\\r\\n        uint16 _redeemFeeRatio,\\r\\n        uint16 _bulletToRewardRatio\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the entry fee ratio for the option contract\\r\\n     * @dev Sets the entry fee ratio for the option contract to the specified value\\r\\n     * @param _feeRatio The entry fee ratio to set\\r\\n     */\\r\\n    function setOptionEntryFeeRatio(uint16 _feeRatio) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the exercise fee ratio for the option contract\\r\\n     * @dev Sets the exercise fee ratio for the option contract to the specified value\\r\\n     * @param _feeRatio The exercise fee ratio to set\\r\\n     */\\r\\n    function setOptionExerciseFeeRatio(uint16 _feeRatio) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the withdraw fee ratio for the option contract\\r\\n     * @dev Sets the withdraw fee ratio for the option contract to the specified value\\r\\n     * @param _feeRatio The withdraw fee ratio to set\\r\\n     */\\r\\n    function setOptionWithdrawFeeRatio(uint16 _feeRatio) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the redeem fee ratio for the option contract\\r\\n     * @dev Sets the redeem fee ratio for the option contract to the specified value\\r\\n     * @param _feeRatio The redeem fee ratio to set\\r\\n     */\\r\\n    function setOptionRedeemFeeRatio(uint16 _feeRatio) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the BULLET-to-reward ratio for the option contract\\r\\n     * @dev Sets the BULLET-to-reward ratio for the option contract to the specified value\\r\\n     * @param _feeRatio The BULLET-to-reward ratio to set\\r\\n     */\\r\\n    function setOptionBulletToRewardRatio(uint16 _feeRatio) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the fund address for the option contract\\r\\n     * @dev Sets the fund address for the option contract to the specified value\\r\\n     * @param _fund The fund address to set\\r\\n     */\\r\\n    function setFund(address _fund) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Exits the option by unstaking and redeeming all rewards.\\r\\n     * @dev This function unstakes the user's tokens, redeems their SNIPER tokens, and withdraws their rewards.\\r\\n     */\\r\\n    function exitAll() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Enters an options contract by depositing a certain amount of tokens.\\r\\n     * @dev This function is used to enter an options contract. The sender should have approved the transfer.\\r\\n     *      The amount of tokens is transferred to this contract, the entry fee is calculated, distributed,\\r\\n     *      and subtracted from the amount. The remaining amount is used to mint BULLET and SNIPER tokens,\\r\\n     *      which are passed to the fund and the staking pool, respectively.\\r\\n     * @param _amount The amount of tokens to enter.\\r\\n     */\\r\\n    function enter(uint256 _amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Exercises the option by burning option tokens and receiving base tokens.\\r\\n     * @dev This function burns a specific amount of BULLET tokens and calculates the amount of base tokens\\r\\n     *      to transfer depending on the option type (call or put). It also calculates and applies the exercise fee.\\r\\n     * @param _targetAmount The amount of option tokens to exercise.\\r\\n     */\\r\\n    function exercise(uint256 _targetAmount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unwinds a specific amount of options.\\r\\n     * @dev This funciton burns the user's SNIPER and BULLET for the option to withdraw collateral.\\r\\n     * @param _unwindAmount The amount of options to unwind.\\r\\n     */\\r\\n    function unwind(uint256 _unwindAmount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldBlockTime\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBlocktime\",\"type\":\"uint8\"}],\"name\":\"BlockTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDOBStaking\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDOBStaking\",\"type\":\"address\"}],\"name\":\"DOBStakingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDDistribuions\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDistribuions\",\"type\":\"address\"}],\"name\":\"DistribuionsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"option\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bullet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exerciseTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionType\",\"type\":\"uint256\"}],\"name\":\"OptionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldStakingPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStakingPool\",\"type\":\"address\"}],\"name\":\"StakingPoolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"StakingRewardPerBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ContractGenerator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOBStakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bHodlAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uHodlAddress\",\"type\":\"address\"}],\"name\":\"__OptionFactory_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_strikePrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_exerciseTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_optionTypes\",\"type\":\"uint8[]\"}],\"name\":\"activateOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bHODL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blankOptionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTime\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_num\",\"type\":\"uint8\"}],\"name\":\"cloneOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exerciseTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"name\":\"createOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emptyBlankOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newEndBlock\",\"type\":\"uint256\"}],\"name\":\"extendStakingPoolEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastOptionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionID\",\"type\":\"uint256\"}],\"name\":\"getOptionByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operatorWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionAddress\",\"type\":\"address\"}],\"name\":\"removeActivatedOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_blockTime\",\"type\":\"uint8\"}],\"name\":\"setBlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ContractGenerator\",\"type\":\"address\"}],\"name\":\"setContractGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DOBstaking\",\"type\":\"address\"}],\"name\":\"setDOBStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributions\",\"type\":\"address\"}],\"name\":\"setDistributions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund\",\"type\":\"address\"}],\"name\":\"setFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_entryFeeRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_exerciseFeeRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_withdrawFeeRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_redeemFeeRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_bulletToRewardRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionAllRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_feeRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionBulletToRewardRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_feeRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionEntryFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_feeRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionExerciseFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_feeRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionRedeemFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_feeRatio\",\"type\":\"uint16\"}],\"name\":\"setOptionWithdrawFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingPools\",\"type\":\"address\"}],\"name\":\"setStakingPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"setStakingRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uHODL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"optionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_fund\",\"type\":\"address\"}],\"name\":\"updateOptionFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_optionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_strikePrices\",\"type\":\"uint256[]\"}],\"name\":\"updateOptionStrike\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OptionFactory", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}