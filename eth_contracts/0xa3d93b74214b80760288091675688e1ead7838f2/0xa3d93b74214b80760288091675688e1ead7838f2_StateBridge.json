{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/StateBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\n// Optimism interface for cross domain messaging\\nimport {ICrossDomainMessenger} from\\n    \\\"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\\\";\\nimport {IOpWorldID} from \\\"./interfaces/IOpWorldID.sol\\\";\\nimport {IPolygonWorldID} from \\\"./interfaces/IPolygonWorldID.sol\\\";\\nimport {IRootHistory} from \\\"./interfaces/IRootHistory.sol\\\";\\nimport {Ownable2Step} from \\\"openzeppelin-contracts/access/Ownable2Step.sol\\\";\\nimport {ICrossDomainOwnable3} from \\\"./interfaces/ICrossDomainOwnable3.sol\\\";\\nimport {FxBaseRootTunnel} from \\\"fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\\\";\\n\\n/// @title World ID State Bridge\\n/// @author Worldcoin\\n/// @notice Distributes new World ID Identity Manager roots to World ID supported networks\\n/// @dev This contract lives on Ethereum mainnet and is called by the World ID Identity Manager contract\\n/// in the registerIdentities method\\ncontract StateBridge is FxBaseRootTunnel, Ownable2Step {\\n    ///////////////////////////////////////////////////////////////////\\n    ///                           STORAGE                           ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice The address of the OPWorldID contract on Optimism\\n    address public immutable opWorldIDAddress;\\n\\n    /// @notice address for Optimism's Ethereum mainnet L1CrossDomainMessenger contract\\n    address internal immutable crossDomainMessengerAddress;\\n\\n    /// @notice worldID Address\\n    address public immutable worldIDAddress;\\n\\n    /// @notice Amount of gas purchased on Optimism for _sendRootToOptimism\\n    uint32 internal opGasLimitSendRootOptimism;\\n\\n    /// @notice Amount of gas purchased on Optimism for setRootHistoryExpiryOptimism\\n    uint32 internal opGasLimitSetRootHistoryExpiryOptimism;\\n\\n    /// @notice Amount of gas purchased on Optimism for transferOwnershipOptimism\\n    uint32 internal opGasLimitTransferOwnershipOptimism;\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                            EVENTS                           ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Emmitted when the the StateBridge gives ownership of the OPWorldID contract\\n    /// to the WorldID Identity Manager contract away\\n    /// @param previousOwner The previous owner of the OPWorldID contract\\n    /// @param newOwner The new owner of the OPWorldID contract\\n    /// @param isLocal Whether the ownership transfer is local (Optimism EOA/contract) or an Ethereum EOA or contract\\n    event OwnershipTransferredOptimism(\\n        address indexed previousOwner, address indexed newOwner, bool isLocal\\n    );\\n\\n    /// @notice Emmitted when the the StateBridge sets the root history expiry for OpWorldID and PolygonWorldID\\n    /// @param rootHistoryExpiry The new root history expiry\\n    event SetRootHistoryExpiry(uint256 rootHistoryExpiry);\\n\\n    /// @notice Emmitted when a root is sent to OpWorldID and PolygonWorldID\\n    /// @param root The latest WorldID Identity Manager root.\\n    /// @param timestamp The Ethereum block timestamp of the latest WorldID Identity Manager root.\\n    event RootSentMultichain(uint256 root, uint128 timestamp);\\n\\n    /// @notice Emmitted when the the StateBridge sets the opGasLimit for sendRootOptimism\\n    /// @param _opGasLimit The new opGasLimit for sendRootOptimism\\n    event SetOpGasLimitSendRootOptimism(uint32 _opGasLimit);\\n\\n    /// @notice Emmitted when the the StateBridge sets the opGasLimit for setRootHistoryExpiryOptimism\\n    /// @param _opGasLimit The new opGasLimit for setRootHistoryExpiryOptimism\\n    event SetOpGasLimitSetRootHistoryExpiryOptimism(uint32 _opGasLimit);\\n\\n    /// @notice Emmitted when the the StateBridge sets the opGasLimit for transferOwnershipOptimism\\n    /// @param _opGasLimit The new opGasLimit for transferOwnershipOptimism\\n    event SetOpGasLimitTransferOwnershipOptimism(uint32 _opGasLimit);\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                            ERRORS                           ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Thrown when the caller of `sendRootMultichain` is not the WorldID Identity Manager contract.\\n    error NotWorldIDIdentityManager();\\n\\n    /// @notice Thrown when an attempt is made to renounce ownership.\\n    error CannotRenounceOwnership();\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                          MODIFIERS                          ///\\n    ///////////////////////////////////////////////////////////////////\\n    modifier onlyWorldIDIdentityManager() {\\n        if (msg.sender != worldIDAddress) {\\n            revert NotWorldIDIdentityManager();\\n        }\\n        _;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                         CONSTRUCTOR                         ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice constructor\\n    /// @param _checkpointManager address of the checkpoint manager contract\\n    /// @param _fxRoot address of Polygon's fxRoot contract, part of the FxPortal bridge (Goerli or Mainnet)\\n    /// @param _worldIDIdentityManager Deployment address of the WorldID Identity Manager contract\\n    /// @param _opWorldIDAddress Address of the Optimism contract that will receive the new root and timestamp\\n    /// @param _crossDomainMessenger L1CrossDomainMessenger contract used to communicate with the Optimism network\\n    constructor(\\n        address _checkpointManager,\\n        address _fxRoot,\\n        address _worldIDIdentityManager,\\n        address _opWorldIDAddress,\\n        address _crossDomainMessenger\\n    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {\\n        opWorldIDAddress = _opWorldIDAddress;\\n        worldIDAddress = _worldIDIdentityManager;\\n        crossDomainMessengerAddress = _crossDomainMessenger;\\n        opGasLimitSendRootOptimism = 100000;\\n        opGasLimitSetRootHistoryExpiryOptimism = 100000;\\n        opGasLimitTransferOwnershipOptimism = 100000;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                          PUBLIC API                         ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Sends the latest WorldID Identity Manager root to all chains.\\n    /// @dev Calls this method on the L1 Proxy contract to relay roots and timestamps to WorldID supported chains.\\n    /// @param root The latest WorldID Identity Manager root.\\n    function sendRootMultichain(uint256 root) external onlyWorldIDIdentityManager {\\n        uint128 timestamp = uint128(block.timestamp);\\n        _sendRootToOptimism(root, timestamp);\\n        _sendRootToPolygon(root, timestamp);\\n        // add other chains here\\n\\n        emit RootSentMultichain(root, timestamp);\\n    }\\n\\n    /// @notice Sets the root history expiry for OpWorldID (on Optimism) and PolygonWorldID (on Polygon)\\n    /// @param expiryTime The new root history expiry for OpWorldID and PolygonWorldID\\n    function setRootHistoryExpiry(uint256 expiryTime) public onlyWorldIDIdentityManager {\\n        setRootHistoryExpiryOptimism(expiryTime);\\n        setRootHistoryExpiryPolygon(expiryTime);\\n\\n        emit SetRootHistoryExpiry(expiryTime);\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                           OPTIMISM                          ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Sends the latest WorldID Identity Manager root to all chains.\\n    /// @dev Calls this method on the L1 Proxy contract to relay roots and timestamps to WorldID supported chains.\\n    /// @param root The latest WorldID Identity Manager root.\\n    /// @param timestamp The Ethereum block timestamp of the latest WorldID Identity Manager root.\\n    function _sendRootToOptimism(uint256 root, uint128 timestamp) internal {\\n        // The `encodeCall` function is strongly typed, so this checks that we are passing the\\n        // correct data to the optimism bridge.\\n        bytes memory message = abi.encodeCall(IOpWorldID.receiveRoot, (root, timestamp));\\n\\n        ICrossDomainMessenger(crossDomainMessengerAddress).sendMessage(\\n            // Contract address on Optimism\\n            opWorldIDAddress,\\n            message,\\n            opGasLimitSendRootOptimism\\n        );\\n    }\\n\\n    /// @notice Adds functionality to the StateBridge to transfer ownership\\n    /// of OpWorldID to another contract on L1 or to a local Optimism EOA\\n    /// @param _owner new owner (EOA or contract)\\n    /// @param _isLocal true if new owner is on Optimism, false if it is a cross-domain owner\\n    function transferOwnershipOptimism(address _owner, bool _isLocal) public onlyOwner {\\n        bytes memory message;\\n\\n        // The `encodeCall` function is strongly typed, so this checks that we are passing the\\n        // correct data to the optimism bridge.\\n        message = abi.encodeCall(ICrossDomainOwnable3.transferOwnership, (_owner, _isLocal));\\n\\n        ICrossDomainMessenger(crossDomainMessengerAddress).sendMessage(\\n            // Contract address on Optimism\\n            opWorldIDAddress,\\n            message,\\n            opGasLimitTransferOwnershipOptimism\\n        );\\n\\n        emit OwnershipTransferredOptimism(owner(), _owner, _isLocal);\\n    }\\n\\n    /// @notice Adds functionality to the StateBridge to set the root history expiry on OpWorldID\\n    /// @param _rootHistoryExpiry new root history expiry\\n    function setRootHistoryExpiryOptimism(uint256 _rootHistoryExpiry) internal {\\n        bytes memory message;\\n\\n        // The `encodeCall` function is strongly typed, so this checks that we are passing the\\n        // correct data to the optimism bridge.\\n        message = abi.encodeCall(IRootHistory.setRootHistoryExpiry, (_rootHistoryExpiry));\\n\\n        ICrossDomainMessenger(crossDomainMessengerAddress).sendMessage(\\n            // Contract address on Optimism\\n            opWorldIDAddress,\\n            message,\\n            opGasLimitSetRootHistoryExpiryOptimism\\n        );\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                         OP GAS LIMIT                        ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Sets the gas limit for the Optimism sendRootMultichain method\\n    /// @param _opGasLimit The new gas limit for the sendRootMultichain method\\n    function setOpGasLimitSendRootOptimism(uint32 _opGasLimit) external onlyOwner {\\n        opGasLimitSendRootOptimism = _opGasLimit;\\n\\n        emit SetOpGasLimitSendRootOptimism(_opGasLimit);\\n    }\\n\\n    /// @notice Sets the gas limit for the Optimism setRootHistoryExpiry method\\n    /// @param _opGasLimit The new gas limit for the setRootHistoryExpiry method\\n    function setOpGasLimitSetRootHistoryExpiryOptimism(uint32 _opGasLimit) external onlyOwner {\\n        opGasLimitSetRootHistoryExpiryOptimism = _opGasLimit;\\n\\n        emit SetOpGasLimitSetRootHistoryExpiryOptimism(_opGasLimit);\\n    }\\n\\n    /// @notice Sets the gas limit for the transferOwnershipOptimism method\\n    /// @param _opGasLimit The new gas limit for the transferOwnershipOptimism method\\n    function setOpGasLimitTransferOwnershipOptimism(uint32 _opGasLimit) external onlyOwner {\\n        opGasLimitTransferOwnershipOptimism = _opGasLimit;\\n\\n        emit SetOpGasLimitTransferOwnershipOptimism(_opGasLimit);\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                           POLYGON                           ///\\n    ///////////////////////////////////////////////////////////////////\\n\\n    /// @notice Sends root and timestamp to Polygon's StateChild contract (PolygonWorldID)\\n    /// @param root The latest WorldID Identity Manager root to be sent to Polygon\\n    /// @param timestamp The Ethereum block timestamp of the latest WorldID Identity Manager root\\n    function _sendRootToPolygon(uint256 root, uint128 timestamp) internal {\\n        bytes memory message;\\n\\n        message = abi.encodeCall(IPolygonWorldID.receiveRoot, (root, timestamp));\\n\\n        /// @notice FxBaseRootTunnel method to send bytes payload to FxBaseChildTunnel contract\\n        _sendMessageToChild(message);\\n    }\\n\\n    /// @notice Sets the root history expiry for PolygonWorldID\\n    /// @param _rootHistoryExpiry The new root history expiry\\n    function setRootHistoryExpiryPolygon(uint256 _rootHistoryExpiry) internal {\\n        bytes memory message;\\n\\n        message = abi.encodeCall(IRootHistory.setRootHistoryExpiry, (_rootHistoryExpiry));\\n\\n        /// @notice FxBaseRootTunnel method to send bytes payload to FxBaseChildTunnel contract\\n        _sendMessageToChild(message);\\n    }\\n\\n    /// @notice boilerplate function to satisfy FxBaseRootTunnel inheritance (not going to be used)\\n    function _processMessageFromChild(bytes memory) internal override {\\n        /// WorldID \ud83c\udf0e\ud83c\udd94 State Bridge\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////\\n    ///                            ADDRESS MANAGEMENT                           ///\\n    ///////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Sets the `fxChildTunnel` address if not already set.\\n    /// @dev This implementation replicates the logic from `FxBaseRootTunnel` due to the inability\\n    ///      to call `external` superclass methods when overriding them.\\n    ///\\n    /// @param _fxChildTunnel The address of the child (non-L1) tunnel contract.\\n    ///\\n    /// @custom:reverts string If the root tunnel has already been set.\\n    function setFxChildTunnel(address _fxChildTunnel) public virtual override onlyOwner {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////\\n    ///                          OWNERSHIP                          ///\\n    ///////////////////////////////////////////////////////////////////\\n    /// @notice Ensures that ownership of WorldID implementations cannot be renounced.\\n    /// @dev This function is intentionally not `virtual` as we do not want it to be possible to\\n    ///      renounce ownership for any WorldID implementation.\\n    /// @dev This function is marked as `onlyOwner` to maintain the access restriction from the base\\n    ///      contract.\\n    function renounceOwnership() public view override onlyOwner {\\n        revert CannotRenounceOwnership();\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOpWorldID.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title Interface for the OpWorldID contract\\n/// @author Worldcoin\\n/// @custom:usage abi.encodeCall(IOpWorldID.receiveRoot, (_newRoot, _supersedeTimestamp));\\ninterface IOpWorldID {\\n    ////////////////////////////////////////////////////////////////////////////////\\n    ///                               ROOT MIRRORING                            ///\\n    ///////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice This function is called by the state bridge contract when it forwards a new root to\\n    ///         the bridged WorldID.\\n    /// @dev    This function can revert if Optimism's CrossDomainMessenger stops processing proofs\\n    ///         or if OPLabs stops submitting them. Next iteration of Optimism's cross-domain messaging, will be\\n    ///         fully permissionless for message-passing, so this will not be an issue.\\n    ///         Sequencer needs to include changes to the CrossDomainMessenger contract on L1, not economically penalized\\n    ///         if messages are not included, however the fraud prover (Cannon) can force the sequencer to include it.\\n    ///\\n    /// @param newRoot The value of the new root.\\n    /// @param supersedeTimestamp The value of the L1 timestamp at the time that `newRoot` became\\n    ///        the current root. This timestamp is associated with the latest root at the time of\\n    ///        the call being inserted into the root history.\\n    ///\\n    /// @custom:reverts CannotOverwriteRoot If the root already exists in the root history.\\n    /// @custom:reverts string If the caller is not the owner.\\n    function receiveRoot(uint256 newRoot, uint128 supersedeTimestamp) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPolygonWorldID.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title Interface for the PolygonWorldID contract\\n/// @author Worldcoin\\n/// @notice Interface for the CrossDomainOwnable contract for the Optimism L2\\n/// @custom:usage abi.encodeCall(IPolygonWorldID.receiveRoot, (_newRoot, _supersedeTimestamp));\\ninterface IPolygonWorldID {\\n    ////////////////////////////////////////////////////////////////////////////////\\n    ///                               ROOT MIRRORING                            ///\\n    ///////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice This function is called by the state bridge contract when it forwards a new root to\\n    ///         the bridged WorldID.\\n    ///\\n    /// @param newRoot The value of the new root.\\n    /// @param supersedeTimestamp The value of the L1 timestamp at the time that `newRoot` became\\n    ///        the current root. This timestamp is associated with the latest root at the time of\\n    ///        the call being inserted into the root history.\\n    ///\\n    /// @custom:reverts CannotOverwriteRoot If the root already exists in the root history.\\n    /// @custom:reverts string If the caller is not the owner.\\n    function receiveRoot(uint256 newRoot, uint128 supersedeTimestamp) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRootHistory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title Interface for WorldID setRooHistoryExpiry\\n/// @author Worldcoin\\n/// @notice Interface for WorldID setRooHistoryExpiry\\n/// @dev Used in StateBridge to set the root history expiry time on Optimism (OPWorldID)\\n/// @custom:usage abi.encodeCall(IRootHistory.setRootHistoryExpiry, (_expiryTime));\\ninterface IRootHistory {\\n    /// @notice Sets the amount of time it takes for a root in the root history to expire.\\n    ///\\n    /// @param expiryTime The new amount of time it takes for a root to expire.\\n    ///\\n    /// @custom:reverts string If the caller is not the owner.\\n    function setRootHistoryExpiry(uint256 expiryTime) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICrossDomainOwnable3.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.15;\\n\\n/// @title Optimism - CrossDomainOwnable3 Interface\\n/// @author Worldcoin\\n/// @notice Interface for the CrossDomainOwnable contract for the Optimism L2\\n/// @dev Adds functionality to the StateBridge to transfer ownership\\n/// of OpWorldID to another contract on L1 or to a local Optimism EOA\\n/// @custom:usage abi.encodeCall(ICrossDomainOwnable3.transferOwnership, (_owner, _isLocal));\\ninterface ICrossDomainOwnable3 {\\n    /// @notice transfers owner to a cross-domain or local owner\\n    /// @param _owner new owner (EOA or contract)\\n    /// @param _isLocal true if new owner is on Optimism, false if it is a cross-domain owner\\n    function transferOwnership(address _owner, bool _isLocal) external;\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/tunnel/FxBaseRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"../lib/RLPReader.sol\\\";\\nimport {MerklePatriciaProof} from \\\"../lib/MerklePatriciaProof.sol\\\";\\nimport {Merkle} from \\\"../lib/Merkle.sol\\\";\\nimport \\\"../lib/ExitPayloadReader.sol\\\";\\n\\ninterface IFxStateSender {\\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n\\n    /**\\n     * @notice mapping of checkpoint header numbers to block details\\n     * @dev These checkpoints are submited by plasma contracts\\n     */\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n    using RLPReader for RLPReader.RLPItem;\\n    using Merkle for bytes32;\\n    using ExitPayloadReader for bytes;\\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n    using ExitPayloadReader for ExitPayloadReader.Log;\\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\\n\\n    // keccak256(MessageSent(bytes))\\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n    // state sender contract\\n    IFxStateSender public fxRoot;\\n    // root chain manager\\n    ICheckpointManager public checkpointManager;\\n    // child tunnel contract which receives and sends messages\\n    address public fxChildTunnel;\\n\\n    // storage to avoid duplicate exits\\n    mapping(bytes32 => bool) public processedExits;\\n\\n    constructor(address _checkpointManager, address _fxRoot) {\\n        checkpointManager = ICheckpointManager(_checkpointManager);\\n        fxRoot = IFxStateSender(_fxRoot);\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(address _fxChildTunnel) public virtual {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    /**\\n     * @notice Send bytes message to Child Tunnel\\n     * @param message bytes message that will be sent to Child Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToChild(bytes memory message) internal {\\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\\n    }\\n\\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\\n\\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\\n        uint256 blockNumber = payload.getBlockNumber();\\n        // checking if exit has already been processed\\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n        bytes32 exitHash = keccak256(\\n            abi.encodePacked(\\n                blockNumber,\\n                // first 2 nibbles are dropped while generating nibble array\\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n                // so converting to nibble array and then hashing it\\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\\n                payload.getReceiptLogIndex()\\n            )\\n        );\\n        require(processedExits[exitHash] == false, \\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\");\\n        processedExits[exitHash] = true;\\n\\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n        ExitPayloadReader.Log memory log = receipt.getLog();\\n\\n        // check child tunnel\\n        require(fxChildTunnel == log.getEmitter(), \\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\");\\n\\n        bytes32 receiptRoot = payload.getReceiptRoot();\\n        // verify receipt inclusion\\n        require(\\n            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\\n            \\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n        );\\n\\n        // verify checkpoint inclusion\\n        _checkBlockMembershipInCheckpoint(\\n            blockNumber,\\n            payload.getBlockTime(),\\n            payload.getTxRoot(),\\n            receiptRoot,\\n            payload.getHeaderNumber(),\\n            payload.getBlockProof()\\n        );\\n\\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\\n\\n        require(\\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n            \\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n        );\\n\\n        // received message data\\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\\n        return message;\\n    }\\n\\n    function _checkBlockMembershipInCheckpoint(\\n        uint256 blockNumber,\\n        uint256 blockTime,\\n        bytes32 txRoot,\\n        bytes32 receiptRoot,\\n        uint256 headerNumber,\\n        bytes memory blockProof\\n    ) private view returns (uint256) {\\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\\n\\n        require(\\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\\n                blockNumber - startBlock,\\n                headerRoot,\\n                blockProof\\n            ),\\n            \\\"FxRootTunnel: INVALID_HEADER\\\"\\n        );\\n        return createdAt;\\n    }\\n\\n    /**\\n     * @notice receive message from  L2 to L1, validated by proof\\n     * @dev This function verifies if the transaction actually happened on child chain\\n     *\\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n     *  2 - blockNumber - Block number containing the reference tx on child chain\\n     *  3 - blockTime - Reference tx block time\\n     *  4 - txRoot - Transactions root of block\\n     *  5 - receiptRoot - Receipts root of block\\n     *  6 - receipt - Receipt of the reference transaction\\n     *  7 - receiptProof - Merkle proof of the reference receipt\\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n     *  9 - receiptLogIndex - Log Index to read from the receipt\\n     */\\n    function receiveMessage(bytes memory inputData) public virtual {\\n        bytes memory message = _validateAndExtractMessage(inputData);\\n        _processMessageFromChild(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Child Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param message bytes message that was sent from Child Tunnel\\n     */\\n    function _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/RLPReader.sol\": {\r\n      \"content\": \"/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len - _payloadOffset(item.memPtr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        return result == 0 ? false : true;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset;\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\\n        else if (byte0 < LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < parentNodes.length; i++) {\\n            if (pathPtr > path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble > 16) {\\n                    return false;\\n                }\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len = 0;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\\n        bytes memory nibbles = \\\"\\\";\\n        if (b.length > 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i < nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index < 2**proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/contracts/contracts/lib/ExitPayloadReader.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct ExitPayload {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    struct Receipt {\\n        RLPReader.RLPItem[] data;\\n        bytes raw;\\n        uint256 logIndex;\\n    }\\n\\n    struct Log {\\n        RLPReader.RLPItem data;\\n        RLPReader.RLPItem[] list;\\n    }\\n\\n    struct LogTopics {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n        \\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\\n\\n        return ExitPayload(payloadData);\\n    }\\n\\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[0].toUint();\\n    }\\n\\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[1].toBytes();\\n    }\\n\\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[2].toUint();\\n    }\\n\\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[3].toUint();\\n    }\\n\\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[4].toUint());\\n    }\\n\\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[5].toUint());\\n    }\\n\\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\\n        receipt.raw = payload.data[6].toBytes();\\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n        if (receiptItem.isList()) {\\n            // legacy tx\\n            receipt.data = receiptItem.toList();\\n        } else {\\n            // pop first byte before parsting receipt\\n            bytes memory typedBytes = receipt.raw;\\n            bytes memory result = new bytes(typedBytes.length - 1);\\n            uint256 srcPtr;\\n            uint256 destPtr;\\n            assembly {\\n                srcPtr := add(33, typedBytes)\\n                destPtr := add(0x20, result)\\n            }\\n\\n            copy(srcPtr, destPtr, result.length);\\n            receipt.data = result.toRlpItem().toList();\\n        }\\n\\n        receipt.logIndex = getReceiptLogIndex(payload);\\n        return receipt;\\n    }\\n\\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[7].toBytes();\\n    }\\n\\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[8].toBytes();\\n    }\\n\\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[8].toUint();\\n    }\\n\\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[9].toUint();\\n    }\\n\\n    // Receipt methods\\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\\n        return receipt.raw;\\n    }\\n\\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\\n        return Log(logData, logData.toList());\\n    }\\n\\n    // Log methods\\n    function getEmitter(Log memory log) internal pure returns (address) {\\n        return RLPReader.toAddress(log.list[0]);\\n    }\\n\\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\\n        return LogTopics(log.list[1].toList());\\n    }\\n\\n    function getData(Log memory log) internal pure returns (bytes memory) {\\n        return log.list[2].toBytes();\\n    }\\n\\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\\n        return log.data.toRlpBytes();\\n    }\\n\\n    // LogTopics methods\\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\\n        return topics.data[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@eth-optimism/contracts-bedrock/=node_modules/@eth-optimism/contracts-bedrock/\",\r\n      \"@eth-optimism/contracts/=node_modules/@eth-optimism/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"fx-portal/contracts/=lib/contracts/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"semaphore-v3/=lib/semaphore-v3/\",\r\n      \"semaphore/=lib/semaphore-v3/packages/contracts/contracts/\",\r\n      \"solmate/=lib/solmate/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkpointManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fxRoot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_worldIDIdentityManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_opWorldIDAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crossDomainMessenger\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotRenounceOwnership\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWorldIDIdentityManager\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLocal\",\"type\":\"bool\"}],\"name\":\"OwnershipTransferredOptimism\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"}],\"name\":\"RootSentMultichain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetOpGasLimitSendRootOptimism\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetOpGasLimitSetRootHistoryExpiryOptimism\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetOpGasLimitTransferOwnershipOptimism\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rootHistoryExpiry\",\"type\":\"uint256\"}],\"name\":\"SetRootHistoryExpiry\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opWorldIDAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"sendRootMultichain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"setOpGasLimitSendRootOptimism\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"setOpGasLimitSetRootHistoryExpiryOptimism\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_opGasLimit\",\"type\":\"uint32\"}],\"name\":\"setOpGasLimitTransferOwnershipOptimism\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"name\":\"setRootHistoryExpiry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLocal\",\"type\":\"bool\"}],\"name\":\"transferOwnershipOptimism\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"worldIDAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StateBridge", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a2000000000000000000000000316350d3ec608ffc30b01dcb7475de1c676ce9100000000000000000000000004055b6d4018e92e4d000865e61e87b57a4e5ab4900000000000000000000000025ace71c97b33cc4729cf772ae268934f7ab5fa1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}