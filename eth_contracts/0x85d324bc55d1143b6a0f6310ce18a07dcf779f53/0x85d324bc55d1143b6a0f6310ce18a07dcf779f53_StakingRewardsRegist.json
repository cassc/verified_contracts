{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StakingRewardsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts@4.9.3/access/Ownable2Step.sol\\\";\\n\\ninterface IStakingRewards {\\n    function stakingToken() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function cloneStakingPool(\\n        address _owner,\\n        address _stakingToken,\\n        address _zapContract\\n    ) external returns (address newStakingPool);\\n}\\n\\ncontract StakingRewardsRegistry is Ownable2Step {\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /// @notice If a stakingPool exists for a given token, it will be shown here.\\n    /// @dev Only stakingPools added to this registry will be shown.\\n    mapping(address => address) public stakingPool;\\n\\n    /// @notice Tokens that this registry has added stakingPools for.\\n    address[] public tokens;\\n\\n    /// @notice Check if a given stakingPool is known to this registry.\\n    mapping(address => bool) public isStakingPoolEndorsed;\\n\\n    /// @notice Check if an address is allowed to own stakingPools from this registry.\\n    mapping(address => bool) public approvedPoolOwner;\\n\\n    /// @notice Check if an address can add pools to this registry.\\n    mapping(address => bool) public poolEndorsers;\\n\\n    /// @notice Staking pools that have been replaced by a newer version.\\n    address[] public replacedStakingPools;\\n\\n    /// @notice Default StakingRewardsMulti contract to clone.\\n    address public stakingContract;\\n\\n    /// @notice Default zap contract.\\n    address public zapContract;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event StakingPoolAdded(address indexed token, address stakingPool);\\n    event ApprovedPoolOwnerUpdated(address governance, bool approved);\\n    event ApprovedPoolEndorser(address account, bool canEndorse);\\n    event DefaultContractsUpdated(address stakingContract, address zapContract);\\n\\n    /* ========== VIEWS ========== */\\n\\n    /// @notice The number of tokens with staking pools added to this registry.\\n    function numTokens() external view returns (uint256) {\\n        return tokens.length;\\n    }\\n\\n    /* ========== CORE FUNCTIONS ========== */\\n\\n    /**\\n     @notice Used for owner to clone an exact copy of the default staking pool and add to registry.\\n     @dev Also uses the default zap contract.\\n     @param _stakingToken Address of our staking token to use.\\n    */\\n    function cloneAndAddStakingPool(\\n        address _stakingToken\\n    ) external returns (address newStakingPool) {\\n        // don't let just anyone add to our registry\\n        require(poolEndorsers[msg.sender], \\\"!authorized\\\");\\n\\n        // Clone new pool.\\n        IStakingRewards stakingRewards = IStakingRewards(stakingContract);\\n\\n        newStakingPool = stakingRewards.cloneStakingPool(\\n            owner(),\\n            _stakingToken,\\n            zapContract\\n        );\\n\\n        bool tokenIsRegistered = stakingPool[_stakingToken] != address(0);\\n\\n        // Add to the registry.\\n        _addStakingPool(newStakingPool, _stakingToken, tokenIsRegistered);\\n    }\\n\\n    /**\\n    @notice\\n        Add a new staking pool to our registry, for new or existing tokens.\\n    @dev\\n        Throws if governance isn't set properly.\\n        Throws if sender isn't allowed to endorse.\\n        Throws if replacement is handled improperly.\\n        Emits a StakingPoolAdded event.\\n    @param _stakingPool The address of the new staking pool.\\n    @param _token The token to be deposited into the new staking pool.\\n    @param _replaceExistingPool If we are replacing an existing staking pool, set this to true.\\n     */\\n    function addStakingPool(\\n        address _stakingPool,\\n        address _token,\\n        bool _replaceExistingPool\\n    ) external {\\n        // don't let just anyone add to our registry\\n        require(poolEndorsers[msg.sender], \\\"!authorized\\\");\\n        _addStakingPool(_stakingPool, _token, _replaceExistingPool);\\n    }\\n\\n    function _addStakingPool(\\n        address _stakingPool,\\n        address _token,\\n        bool _replaceExistingPool\\n    ) internal {\\n        // load up the staking pool contract\\n        IStakingRewards stakingRewards = IStakingRewards(_stakingPool);\\n\\n        // check that gov is correct on the staking contract\\n        address poolGov = stakingRewards.owner();\\n        require(approvedPoolOwner[poolGov], \\\"not allowed pool owner\\\");\\n\\n        // make sure we didn't mess up our token/staking pool match\\n        require(\\n            stakingRewards.stakingToken() == _token,\\n            \\\"staking token doesn't match\\\"\\n        );\\n\\n        // Make sure we're only using the latest stakingPool in our registry\\n        if (_replaceExistingPool) {\\n            require(\\n                stakingPool[_token] != address(0),\\n                \\\"token isn't registered, can't replace\\\"\\n            );\\n            address oldPool = stakingPool[_token];\\n            isStakingPoolEndorsed[oldPool] = false;\\n            stakingPool[_token] = _stakingPool;\\n\\n            // move our old pool to the replaced list\\n            replacedStakingPools.push(oldPool);\\n        } else {\\n            require(\\n                stakingPool[_token] == address(0),\\n                \\\"replace instead, pool already exists\\\"\\n            );\\n            stakingPool[_token] = _stakingPool;\\n            tokens.push(_token);\\n        }\\n\\n        isStakingPoolEndorsed[_stakingPool] = true;\\n        emit StakingPoolAdded(_token, _stakingPool);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n    @notice Set the ability of an address to endorse staking pools.\\n    @dev Throws if caller is not owner.\\n    @param _addr The address to approve or deny access.\\n    @param _approved Allowed to endorse\\n     */\\n    function setPoolEndorsers(\\n        address _addr,\\n        bool _approved\\n    ) external onlyOwner {\\n        poolEndorsers[_addr] = _approved;\\n        emit ApprovedPoolEndorser(_addr, _approved);\\n    }\\n\\n    /**\\n    @notice Set the staking pool owners.\\n    @dev Throws if caller is not owner.\\n    @param _addr The address to approve or deny access.\\n    @param _approved Allowed to own staking pools\\n     */\\n    function setApprovedPoolOwner(\\n        address _addr,\\n        bool _approved\\n    ) external onlyOwner {\\n        approvedPoolOwner[_addr] = _approved;\\n        emit ApprovedPoolOwnerUpdated(_addr, _approved);\\n    }\\n\\n    /**\\n    @notice Set our default zap and staking pool contracts.\\n    @dev Throws if caller is not owner, and can't be set to zero address.\\n    @param _stakingPool Address of the default staking contract to use.\\n    @param _zapContract Address of the default zap contract to use.\\n     */\\n    function setDefaultContracts(\\n        address _stakingPool,\\n        address _zapContract\\n    ) external onlyOwner {\\n        require(\\n            _stakingPool != address(0) && _zapContract != address(0),\\n            \\\"no zero address\\\"\\n        );\\n        stakingContract = _stakingPool;\\n        zapContract = _zapContract;\\n        emit DefaultContractsUpdated(_stakingPool, _zapContract);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canEndorse\",\"type\":\"bool\"}],\"name\":\"ApprovedPoolEndorser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovedPoolOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakingContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zapContract\",\"type\":\"address\"}],\"name\":\"DefaultContractsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"StakingPoolAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_replaceExistingPool\",\"type\":\"bool\"}],\"name\":\"addStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedPoolOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"}],\"name\":\"cloneAndAddStakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newStakingPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStakingPoolEndorsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolEndorsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"replacedStakingPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovedPoolOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zapContract\",\"type\":\"address\"}],\"name\":\"setDefaultContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setPoolEndorsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zapContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingRewardsRegistry", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ab5a89f218da4b006f7a58636afa7d269995179dd854e916e3b24969f6cf359c"}