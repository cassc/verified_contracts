{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/internal/LeverageDepositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC BY-NC-ND 4.0\\npragma solidity >=0.8.21;\\n\\nimport { IERC20 } from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\nimport { AccessControl } from \\\"openzeppelin-contracts/access/AccessControl.sol\\\";\\n\\nimport { ILeverageDepositor } from \\\"src/interfaces/ILeverageDepositor.sol\\\";\\nimport { IMultiPoolStrategy } from \\\"src/interfaces/IMultiPoolStrategy.sol\\\";\\n\\nimport { ProtocolRoles } from \\\"src/libs/ProtocolRoles.sol\\\";\\nimport { DependencyAddresses } from \\\"src/libs/DependencyAddresses.sol\\\";\\nimport { ErrorsLeverageEngine } from \\\"src/libs/ErrorsLeverageEngine.sol\\\";\\n\\n// @notice: This contract holds strategy shares and deposit/withdraw tokens from strategy\\ncontract LeverageDepositor is ILeverageDepositor, AccessControl {\\n    using ProtocolRoles for *;\\n\\n    constructor() {\\n        _grantRole(ProtocolRoles.ADMIN_ROLE, msg.sender);\\n        _setRoleAdmin(ProtocolRoles.INTERNAL_CONTRACT_ROLE, ProtocolRoles.ADMIN_ROLE);\\n        _setRoleAdmin(ProtocolRoles.ADMIN_ROLE, ProtocolRoles.ADMIN_ROLE);\\n    }\\n\\n    function setDependencies(DependencyAddresses calldata dependencies) external onlyRole(ProtocolRoles.ADMIN_ROLE) {\\n        _grantRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE, dependencies.positionOpener);\\n        _grantRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE, dependencies.positionCloser);\\n        _grantRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE, dependencies.positionLiquidator);\\n        _grantRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE, dependencies.positionExpirator);\\n    }\\n\\n    function allowStrategyWithDepositor(address strategy) external onlyRole(ProtocolRoles.ADMIN_ROLE) {\\n        IERC20(IMultiPoolStrategy(strategy).asset()).approve(strategy, type(uint256).max);\\n    }\\n\\n    function denyStrategyWithDepositor(address strategy) external onlyRole(ProtocolRoles.ADMIN_ROLE) {\\n        IERC20(IMultiPoolStrategy(strategy).asset()).approve(strategy, 0);\\n    }\\n\\n    function deposit(\\n        address strategy,\\n        uint256 amount\\n    )\\n        external\\n        onlyRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE)\\n        returns (uint256)\\n    {\\n        if (amount <= 0) {\\n            revert ErrorsLeverageEngine.AmountMustBeGreaterThanZero();\\n        }\\n\\n        return IMultiPoolStrategy(strategy).deposit(amount, address(this));\\n    }\\n\\n    function redeem(\\n        address strategy,\\n        uint256 shares\\n    )\\n        external\\n        onlyRole(ProtocolRoles.INTERNAL_CONTRACT_ROLE)\\n        returns (uint256)\\n    {\\n        if (shares <= 0) {\\n            revert ErrorsLeverageEngine.AmountMustBeGreaterThanZero();\\n        }\\n\\n        return IMultiPoolStrategy(strategy).redeem(shares, msg.sender, address(this), 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILeverageDepositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.21;\\n\\ninterface ILeverageDepositor {\\n    function allowStrategyWithDepositor(address strategy) external;\\n    function denyStrategyWithDepositor(address strategy) external;\\n\\n    function deposit(address strategy, uint256 amount) external returns (uint256);\\n    function redeem(address strategy, uint256 strategyShares) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMultiPoolStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.21;\\n\\ninterface IMultiPoolStrategy {\\n    event Adjusted(uint256 amount, bool isAdjustIn);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n    event HardWork(uint256 totalClaimed, uint256 fee);\\n    event Initialized(uint8 version);\\n    event NewRewardsCycle(uint32 indexed cycleEnd, uint256 rewardAmount);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Withdraw(\\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\\n    );\\n\\n    struct Adjust {\\n        address adapter;\\n        uint256 amount;\\n        uint256 minReceive;\\n    }\\n\\n    struct SwapData {\\n        address token;\\n        uint256 amount;\\n        bytes callData;\\n    }\\n\\n    function LIFI_DIAMOND() external view returns (address);\\n    function adapters(uint256) external view returns (address);\\n    function addAdapter(address _adapter) external;\\n    function addAdapters(address[] memory _adapters) external;\\n    function adjust(\\n        Adjust[] memory _adjustIns,\\n        Adjust[] memory _adjustOuts,\\n        address[] memory _sortedAdapters\\n    )\\n        external;\\n    function adjustInInterval() external view returns (uint256);\\n    function adjustOutInterval() external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function asset() external view returns (address);\\n    function balanceOf(address account) external view returns (uint256);\\n    function changeAdapterHealthFactor(address _adapter, uint256 _healthFactor) external;\\n    function changeAdjustInInterval(uint256 _adjustInInterval) external;\\n    function changeAdjustOutInterval(uint256 _adjustOutInterval) external;\\n    function changeFeePercentage(uint256 _feePercentage) external;\\n    function changeFeeRecipient(address _feeRecipient) external;\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n    function decimals() external view returns (uint8);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n    function doHardWork(address[] memory _adaptersToClaim, SwapData[] memory _swapDatas) external;\\n    function feePercentage() external view returns (uint256);\\n    function feeRecipient() external view returns (address);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function initialize(address _stakingToken, address _monitor, string memory _name, string memory _symbol) external;\\n    function initialize(address _stakingToken, address _monitor) external;\\n    function isAdapter(address) external view returns (bool);\\n    function lastAdjustIn() external view returns (uint256);\\n    function lastAdjustOut() external view returns (uint256);\\n    function lastRewardAmount() external view returns (uint192);\\n    function lastSync() external view returns (uint32);\\n    function maxDeposit(address) external view returns (uint256);\\n    function maxMint(address) external view returns (uint256);\\n    function maxRedeem(address owner) external view returns (uint256);\\n    function maxWithdraw(address owner) external view returns (uint256);\\n    function minPercentage() external view returns (uint256);\\n    function monitor() external view returns (address);\\n    function name() external view returns (string memory);\\n    function owner() external view returns (address);\\n    function paused() external view returns (bool);\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n    function previewMint(uint256 shares) external view returns (uint256);\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner,\\n        uint256 minimumReceive\\n    )\\n        external\\n        returns (uint256);\\n    function removeAdapter(address _adapter) external;\\n    function renounceOwnership() external;\\n    function rewardsCycleEnd() external view returns (uint32);\\n    function rewardsCycleLength() external view returns (uint32);\\n    function setMinimumPercentage(uint256 _minPercentage) external;\\n    function setMonitor(address _monitor) external;\\n    function storedTotalAssets() external view returns (uint256);\\n    function symbol() external view returns (string memory);\\n    function togglePause() external;\\n    function totalAssets() external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n    function transferOwnership(address newOwner) external;\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner,\\n        uint256 minimumReceive\\n    )\\n        external\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/libs/ProtocolRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC BY-NC-ND 4.0\\npragma solidity >=0.8.21;\\n\\nlibrary ProtocolRoles {\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant MONITOR_ROLE = keccak256(\\\"MONITOR_ROLE\\\");\\n    bytes32 public constant EXPIRED_VAULT_ROLE = keccak256(\\\"EXPIRED_VAULT_ROLE\\\");\\n    bytes32 public constant INTERNAL_CONTRACT_ROLE = keccak256(\\\"INTERNAL_CONTRACT_ROLE\\\");\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n}\\n\"\r\n    },\r\n    \"src/libs/DependencyAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC BY-NC-ND 4.0\\npragma solidity >=0.8.21;\\n\\nstruct DependencyAddresses {\\n    address expiredVault;\\n    address leverageDepositor;\\n    address positionToken;\\n    address wbtcVault;\\n    address proxyAdmin;\\n    address leveragedStrategy;\\n    address protocolParameters;\\n    address oracleManager;\\n    address positionOpener;\\n    address positionCloser;\\n    address positionLiquidator;\\n    address positionExpirator;\\n    address positionLedger;\\n    address swapManager;\\n    address lvBTC;\\n    address lvBTCCurvePool;\\n}\\n\"\r\n    },\r\n    \"src/libs/ErrorsLeverageEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC BY-NC-ND 4.0\\npragma solidity >=0.8.21;\\n\\nlibrary ErrorsLeverageEngine {\\n    error ExceedBorrowLimit(); // 8b085be2\\n    error LessThanMinimumShares(); // 3beecf45\\n    error OracleNotSet(); // f8794e04\\n    error OraclePriceStale(); // 08b9f95b\\n    error OracleNegativePrice(); // 641f4716\\n    error NotEnoughTokensReceived(); // 828f02ae\\n    error OraclePriceError(); // fa80e24f\\n    error ExceedBorrowQuota(); // d7f5242d\\n    error NotOwner(); // 30cd7471\\n    error PositionNotLive(); // 5117a49b\\n    error PositionNotExpiredOrLiquidated(); // 382dc85b\\n    error NotEnoughWBTC(); // 8445ce78\\n    error NotEligibleForLiquidation(); // 5e6797f9\\n    error InsufficientFunds(); // 356680b7\\n    error PositionHasNoBalance(); // 1414023b\\n    error SwapAdapterAlreadySet(); // b33e2407\\n    error PositionMustLiveForMinDuration(); // 7616ad40\\n    error NotEligibleForExpiration(); //6db32f8f\\n    error AmountMustBeGreaterThanZero(); //5e85ae73\\n    error BlockCountTooLow(); //0d14f234\\n    error BlockCountTooHigh(); //4de7b564\\n    error SwapAdapterNotSet(); //afd1c360\\n    error PositionLifetimeTooShort(); //4ebfd554\\n    error PositionAlreadyExists(); //6e8de458\\n    error PositionDoesNotExist(); //f7b3b391\\n    error FeeTooHigh(); //cd4e6167\\n    error NotEnoughLvBTC();\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@contracts/=src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"prb-test/=lib/prb-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountMustBeGreaterThanZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"allowStrategyWithDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"denyStrategyWithDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"expiredVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leverageDepositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wbtcVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proxyAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leveragedStrategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolParameters\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionOpener\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionCloser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionLiquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionExpirator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionLedger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lvBTC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lvBTCCurvePool\",\"type\":\"address\"}],\"internalType\":\"struct DependencyAddresses\",\"name\":\"dependencies\",\"type\":\"tuple\"}],\"name\":\"setDependencies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LeverageDepositor", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}