{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV3Pool {\r\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n    function tickSpacing() external view returns (int24);\r\n    function ticks(int24 tick) external view returns (\r\n        uint128 liquidityGross,\r\n        int128 liquidityNet,\r\n        uint256 feeGrowthOutside0X128,\r\n        uint256 feeGrowthOutside1X128,\r\n        int56 tickCumulativeOutside,\r\n        uint160 secondsPerLiquidityOutsideX128,\r\n        uint32 secondsOutside,\r\n        bool initialized\r\n    );\r\n}\r\n\r\ncontract UniswapV3Helper {\r\n    struct TickData {\r\n        TickInfo[] initializedTicks;\r\n        uint256[] tickBitmaps;\r\n    }\r\n    struct TickInfo {\r\n        int24 tick;\r\n        uint128 liquidityGross;\r\n        int128 liquidityNet;\r\n        uint256 feeGrowthOutside0X128;\r\n        uint256 feeGrowthOutside1X128;\r\n        int56 tickCumulativeOutside;\r\n        uint160 secondsPerLiquidityOutsideX128;\r\n        uint32 secondsOutside;\r\n        bool initialized;\r\n    }\r\n\r\n    function getTickBitmap(address poolAddress) public view returns (int16[] memory, uint256[] memory) {\r\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\r\n\r\n        int16 minWord = -887272 >> 8;\r\n        int16 maxWord = 887272 >> 8;\r\n\r\n        uint256 arraySize = uint256(int256(maxWord) - int256(minWord) + 1);\r\n        int16[] memory wordPositions = new int16[](arraySize);\r\n        uint256[] memory tickBitmap = new uint256[](arraySize);\r\n        uint256 index = 0;\r\n\r\n        for (int16 i = minWord; i <= maxWord; i++) {\r\n            uint256 bitmap = pool.tickBitmap(i);\r\n            if (bitmap != 0) {\r\n                wordPositions[index] = i;\r\n                tickBitmap[index] = bitmap;\r\n                index++;\r\n            }\r\n        }\r\n\r\n        assembly { \r\n            mstore(wordPositions, index)\r\n            mstore(tickBitmap, index)\r\n        }\r\n\r\n        return (wordPositions, tickBitmap);\r\n    }\r\n\r\n    function getTickData(address poolAddress) public view returns (TickData memory) {\r\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\r\n\r\n        (int16[] memory wordPositions, uint256[] memory tickBitmap) = getTickBitmap(poolAddress);\r\n        uint256 totalTicks = 0;\r\n\r\n        for (uint256 i = 0; i < wordPositions.length; i++) {\r\n            uint256 bitmap = pool.tickBitmap(wordPositions[i]);\r\n            totalTicks += countInitializedTicks(bitmap);\r\n        }\r\n\r\n        TickInfo[] memory tempTicks = new TickInfo[](totalTicks);\r\n        uint256 currentIndex = 0;\r\n\r\n        for (uint256 i = 0; i < wordPositions.length; i++) {\r\n            uint256 bitmap = pool.tickBitmap(wordPositions[i]);\r\n            currentIndex = populateTicks(pool, bitmap, wordPositions[i], tempTicks, currentIndex);\r\n        }\r\n\r\n        TickInfo[] memory initializedTicks = new TickInfo[](currentIndex);\r\n        for (uint256 i = 0; i < currentIndex; i++) {\r\n            initializedTicks[i] = tempTicks[i];\r\n        }\r\n\r\n        return TickData({\r\n            initializedTicks: initializedTicks,\r\n            tickBitmaps: tickBitmap\r\n        });\r\n    }\r\n\r\n    function countInitializedTicks(uint256 bitmap) internal pure returns (uint256) {\r\n        uint256 count = 0;\r\n        while (bitmap != 0) {\r\n            bitmap &= (bitmap - 1);\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function populateTicks(\r\n        IUniswapV3Pool pool,\r\n        uint256 bitmap,\r\n        int16 wordPosition,\r\n        TickInfo[] memory ticks,\r\n        uint256 startIndex\r\n    ) internal view returns (uint256) {\r\n        uint256 index = startIndex;\r\n        for (uint256 i = 0; i < 256; i++) {\r\n            if ((bitmap & (1 << i)) != 0) {\r\n                int24 tickIndex = int24((int256(wordPosition) << 8) + int256(i));\r\n                TickInfo memory tickInfo = getTickInfo(pool, tickIndex);\r\n                if (tickInfo.initialized) {\r\n                    ticks[index] = tickInfo;\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n\r\n    function getTickInfo(IUniswapV3Pool pool, int24 tickIndex) internal view returns (TickInfo memory) {\r\n        (\r\n            uint128 liquidityGross,\r\n            int128 liquidityNet,\r\n            uint256 feeGrowthOutside0X128,\r\n            uint256 feeGrowthOutside1X128,\r\n            int56 tickCumulativeOutside,\r\n            uint160 secondsPerLiquidityOutsideX128,\r\n            uint32 secondsOutside,\r\n            bool initialized\r\n        ) = pool.ticks(tickIndex);\r\n\r\n        if (!initialized) {\r\n            return TickInfo({\r\n                tick: tickIndex,\r\n                liquidityGross: 0,\r\n                liquidityNet: 0,\r\n                feeGrowthOutside0X128: 0,\r\n                feeGrowthOutside1X128: 0,\r\n                tickCumulativeOutside: 0,\r\n                secondsPerLiquidityOutsideX128: 0,\r\n                secondsOutside: 0,\r\n                initialized: false\r\n            });\r\n        }\r\n\r\n        return TickInfo({\r\n            tick: tickIndex,\r\n            liquidityGross: liquidityGross,\r\n            liquidityNet: liquidityNet,\r\n            feeGrowthOutside0X128: feeGrowthOutside0X128,\r\n            feeGrowthOutside1X128: feeGrowthOutside1X128,\r\n            tickCumulativeOutside: tickCumulativeOutside,\r\n            secondsPerLiquidityOutsideX128: secondsPerLiquidityOutsideX128,\r\n            secondsOutside: secondsOutside,\r\n            initialized: initialized\r\n        });\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getTickBitmap\",\"outputs\":[{\"internalType\":\"int16[]\",\"name\":\"\",\"type\":\"int16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getTickData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthOutside0X128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthOutside1X128\",\"type\":\"uint256\"},{\"internalType\":\"int56\",\"name\":\"tickCumulativeOutside\",\"type\":\"int56\"},{\"internalType\":\"uint160\",\"name\":\"secondsPerLiquidityOutsideX128\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"secondsOutside\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapV3Helper.TickInfo[]\",\"name\":\"initializedTicks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tickBitmaps\",\"type\":\"uint256[]\"}],\"internalType\":\"struct UniswapV3Helper.TickData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapV3Helper", "CompilerVersion": "v0.8.25+commit.b61c2a91", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cb6e55fa5995f7cc17efa0bb1a116e5853edc4d8d7bd14537ad359773ce3051c"}