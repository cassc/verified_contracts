{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/crosschain-data/extensions/CoreStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { BaseStateRegistry } from \\\"src/crosschain-data/BaseStateRegistry.sol\\\";\\nimport { ICoreStateRegistry } from \\\"src/interfaces/ICoreStateRegistry.sol\\\";\\nimport { IBaseForm } from \\\"src/interfaces/IBaseForm.sol\\\";\\nimport { IBridgeValidator } from \\\"src/interfaces/IBridgeValidator.sol\\\";\\nimport { IDstSwapper } from \\\"src/interfaces/IDstSwapper.sol\\\";\\nimport { ISuperRBAC } from \\\"src/interfaces/ISuperRBAC.sol\\\";\\nimport { ISuperformFactory } from \\\"src/interfaces/ISuperformFactory.sol\\\";\\nimport { ISuperPositions } from \\\"src/interfaces/ISuperPositions.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { IPaymentHelper } from \\\"src/interfaces/IPaymentHelper.sol\\\";\\nimport { DataLib } from \\\"src/libraries/DataLib.sol\\\";\\nimport { ProofLib } from \\\"src/libraries/ProofLib.sol\\\";\\nimport { ArrayCastLib } from \\\"src/libraries/ArrayCastLib.sol\\\";\\nimport { PayloadUpdaterLib } from \\\"src/libraries/PayloadUpdaterLib.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport {\\n    PayloadState,\\n    AMBMessage,\\n    InitMultiVaultData,\\n    TransactionType,\\n    CallbackType,\\n    ReturnMultiData,\\n    ReturnSingleData,\\n    InitSingleVaultData,\\n    LiqRequest\\n} from \\\"src/types/DataTypes.sol\\\";\\nimport { IERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @title CoreStateRegistry\\n/// @dev Enables communication between Superform core contracts deployed on all supported networks\\n/// @author Zeropoint Labs\\ncontract CoreStateRegistry is BaseStateRegistry, ICoreStateRegistry {\\n    using SafeERC20 for IERC20;\\n    using DataLib for uint256;\\n    using ProofLib for AMBMessage;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev just stores the superformIds that failed in a specific payload id\\n    mapping(uint256 payloadId => FailedDeposit) failedDeposits;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlySender() override {\\n        if (msg.sender != _getAddress(keccak256(\\\"SUPERFORM_ROUTER\\\"))) revert Error.NOT_SUPERFORM_ROUTER();\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(ISuperRegistry superRegistry_) BaseStateRegistry(superRegistry_) { }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function getFailedDeposits(uint256 payloadId_)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory superformIds, uint256[] memory amounts, uint256 lastProposedTime)\\n    {\\n        FailedDeposit storage failedDeposit = failedDeposits[payloadId_];\\n        superformIds = failedDeposit.superformIds;\\n        amounts = failedDeposit.amounts;\\n        lastProposedTime = failedDeposit.lastProposedTimestamp;\\n    }\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function validateSlippage(uint256 finalAmount_, uint256 amount_, uint256 maxSlippage_) public view returns (bool) {\\n        // only internal transaction\\n        if (msg.sender != address(this)) {\\n            revert Error.INVALID_INTERNAL_CALL();\\n        }\\n\\n        return PayloadUpdaterLib.validateSlippage(finalAmount_, amount_, maxSlippage_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function updateDepositPayload(\\n        uint256 payloadId_,\\n        address[] calldata finalTokens_,\\n        uint256[] calldata finalAmounts_\\n    )\\n        external\\n        virtual\\n        override\\n    {\\n        /// @dev validates the caller\\n        _onlyAllowedCaller(keccak256(\\\"CORE_STATE_REGISTRY_UPDATER_ROLE\\\"));\\n\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        (uint256 prevPayloadHeader, bytes memory prevPayloadBody, bytes32 prevPayloadProof,,, uint8 isMulti,,,) =\\n            _getPayload(payloadId_);\\n\\n        PayloadUpdaterLib.validatePayloadUpdate(\\n            prevPayloadHeader, uint8(TransactionType.DEPOSIT), payloadTracking[payloadId_], isMulti\\n        );\\n\\n        PayloadState finalState;\\n        if (isMulti != 0) {\\n            (prevPayloadBody, finalState) =\\n                _updateMultiDeposit(payloadId_, prevPayloadBody, finalAmounts_, finalTokens_);\\n        } else {\\n            (prevPayloadBody, finalState) =\\n                _updateSingleDeposit(payloadId_, prevPayloadBody, finalAmounts_[0], finalTokens_[0]);\\n        }\\n\\n        /// @dev updates the payload proof\\n        _updatePayload(payloadId_, prevPayloadProof, prevPayloadBody, prevPayloadHeader, finalState);\\n\\n        /// @dev if payload is processed at this stage then it is failing\\n        if (finalState == PayloadState.PROCESSED) {\\n            emit PayloadProcessed(payloadId_);\\n            emit FailedXChainDeposits(payloadId_);\\n        }\\n    }\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function updateWithdrawPayload(uint256 payloadId_, bytes[] calldata txData_) external virtual override {\\n        /// @dev validates the caller\\n        _onlyAllowedCaller(keccak256(\\\"CORE_STATE_REGISTRY_UPDATER_ROLE\\\"));\\n\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        (\\n            uint256 prevPayloadHeader,\\n            bytes memory prevPayloadBody,\\n            bytes32 prevPayloadProof,\\n            ,\\n            ,\\n            uint8 isMulti,\\n            ,\\n            ,\\n            uint64 srcChainId\\n        ) = _getPayload(payloadId_);\\n\\n        /// @dev validate payload update\\n        PayloadUpdaterLib.validatePayloadUpdate(\\n            prevPayloadHeader, uint8(TransactionType.WITHDRAW), payloadTracking[payloadId_], isMulti\\n        );\\n        prevPayloadBody = _updateWithdrawPayload(prevPayloadBody, srcChainId, txData_, isMulti);\\n\\n        /// @dev updates the payload proof\\n        _updatePayload(payloadId_, prevPayloadProof, prevPayloadBody, prevPayloadHeader, PayloadState.UPDATED);\\n\\n        emit PayloadUpdated(payloadId_);\\n    }\\n\\n    /// @inheritdoc BaseStateRegistry\\n    function processPayload(uint256 payloadId_) external payable virtual override {\\n        /// @dev validates the caller\\n        _onlyAllowedCaller(keccak256(\\\"CORE_STATE_REGISTRY_PROCESSOR_ROLE\\\"));\\n\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        if (payloadTracking[payloadId_] == PayloadState.PROCESSED) {\\n            revert Error.PAYLOAD_ALREADY_PROCESSED();\\n        }\\n\\n        PayloadState initialState = payloadTracking[payloadId_];\\n        /// @dev sets status as processed to prevent re-entrancy\\n        payloadTracking[payloadId_] = PayloadState.PROCESSED;\\n\\n        (\\n            uint256 payloadHeader_,\\n            bytes memory payloadBody_,\\n            ,\\n            uint8 txType,\\n            uint8 callbackType,\\n            uint8 isMulti,\\n            ,\\n            address srcSender,\\n            uint64 srcChainId\\n        ) = _getPayload(payloadId_);\\n\\n        AMBMessage memory message_ = AMBMessage(payloadHeader_, payloadBody_);\\n\\n        /// @dev mint superPositions for successful deposits or remint for failed withdraws\\n        if (callbackType == uint256(CallbackType.RETURN) || callbackType == uint256(CallbackType.FAIL)) {\\n            ISuperPositions superPositions = ISuperPositions(_getAddress(keccak256(\\\"SUPER_POSITIONS\\\")));\\n            isMulti == 1 ? superPositions.stateMultiSync(message_) : superPositions.stateSync(message_);\\n        } else if (callbackType == uint8(CallbackType.INIT)) {\\n            /// @dev for initial payload processing\\n            bytes memory returnMessage;\\n\\n            if (txType == uint8(TransactionType.WITHDRAW)) {\\n                returnMessage = isMulti == 1\\n                    ? _multiWithdrawal(payloadId_, payloadBody_, srcSender, srcChainId)\\n                    : _singleWithdrawal(payloadId_, payloadBody_, srcSender, srcChainId);\\n            } else if (txType == uint8(TransactionType.DEPOSIT)) {\\n                if (initialState != PayloadState.UPDATED) {\\n                    revert Error.PAYLOAD_NOT_UPDATED();\\n                }\\n\\n                returnMessage = isMulti == 1\\n                    ? _multiDeposit(payloadId_, payloadBody_, srcSender, srcChainId)\\n                    : _singleDeposit(payloadId_, payloadBody_, srcSender, srcChainId);\\n            }\\n\\n            _processAck(payloadId_, srcChainId, returnMessage);\\n        } else {\\n            revert Error.INVALID_PAYLOAD_TYPE();\\n        }\\n\\n        emit PayloadProcessed(payloadId_);\\n    }\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function proposeRescueFailedDeposits(uint256 payloadId_, uint256[] calldata proposedAmounts_) external override {\\n        /// @dev validates the caller\\n        _onlyAllowedCaller(keccak256(\\\"CORE_STATE_REGISTRY_RESCUER_ROLE\\\"));\\n\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\\n\\n        if (failedDeposits_.superformIds.length == 0 || failedDeposits_.superformIds.length != proposedAmounts_.length)\\n        {\\n            revert Error.INVALID_RESCUE_DATA();\\n        }\\n\\n        if (failedDeposits_.lastProposedTimestamp != 0) {\\n            revert Error.RESCUE_ALREADY_PROPOSED();\\n        }\\n\\n        /// @dev should set this value to dstSwapper.failedSwap().amount for interim rescue\\n        failedDeposits[payloadId_].amounts = proposedAmounts_;\\n        failedDeposits[payloadId_].lastProposedTimestamp = block.timestamp;\\n\\n        (,, uint8 multi,,,) = DataLib.decodeTxInfo(payloadHeader[payloadId_]);\\n\\n        address receiverAddress;\\n        if (multi == 1) {\\n            receiverAddress = abi.decode(payloadBody[payloadId_], (InitMultiVaultData)).receiverAddress;\\n        } else {\\n            receiverAddress = abi.decode(payloadBody[payloadId_], (InitSingleVaultData)).receiverAddress;\\n        }\\n\\n        failedDeposits[payloadId_].receiverAddress = receiverAddress;\\n        emit RescueProposed(payloadId_, failedDeposits_.superformIds, proposedAmounts_, block.timestamp);\\n    }\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    function disputeRescueFailedDeposits(uint256 payloadId_) external override {\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\\n\\n        /// @dev the msg sender should be the refund address (or) the disputer\\n        if (\\n            !(\\n                msg.sender == failedDeposits_.receiverAddress\\n                    || _hasRole(keccak256(\\\"CORE_STATE_REGISTRY_DISPUTER_ROLE\\\"), msg.sender)\\n            )\\n        ) {\\n            revert Error.NOT_VALID_DISPUTER();\\n        }\\n\\n        /// @dev the timelock is already elapsed to dispute\\n        if (\\n            failedDeposits_.lastProposedTimestamp == 0\\n                || block.timestamp > failedDeposits_.lastProposedTimestamp + _getDelay()\\n        ) {\\n            revert Error.DISPUTE_TIME_ELAPSED();\\n        }\\n\\n        /// @dev just can reset last proposed time here, since amounts should be updated again to\\n        /// pass the lastProposedTimestamp zero check in finalize\\n        failedDeposits[payloadId_].lastProposedTimestamp = 0;\\n\\n        emit RescueDisputed(payloadId_);\\n    }\\n\\n    /// @inheritdoc ICoreStateRegistry\\n    /// @notice is an open function & can be executed by anyone\\n    function finalizeRescueFailedDeposits(uint256 payloadId_) external override {\\n        /// @dev validates the payload id\\n        _validatePayloadId(payloadId_);\\n\\n        FailedDeposit storage failedDeposits_ = failedDeposits[payloadId_];\\n\\n        /// @dev the timelock is elapsed\\n        if (\\n            failedDeposits_.lastProposedTimestamp == 0\\n                || block.timestamp <= failedDeposits_.lastProposedTimestamp + _getDelay()\\n        ) {\\n            revert Error.RESCUE_LOCKED();\\n        }\\n\\n        /// @dev set to zero to prevent re-entrancy\\n        failedDeposits_.lastProposedTimestamp = 0;\\n\\n        uint256 len = failedDeposits_.amounts.length;\\n        for (uint256 i; i < len; ++i) {\\n            /// @dev refunds the amount to user specified refund address\\n            if (failedDeposits_.settleFromDstSwapper[i]) {\\n                IDstSwapper(_getAddress(keccak256(\\\"DST_SWAPPER\\\"))).processFailedTx(\\n                    failedDeposits_.receiverAddress, failedDeposits_.settlementToken[i], failedDeposits_.amounts[i]\\n                );\\n            } else {\\n                IERC20(failedDeposits_.settlementToken[i]).safeTransfer(\\n                    failedDeposits_.receiverAddress, failedDeposits_.amounts[i]\\n                );\\n            }\\n        }\\n\\n        delete failedDeposits[payloadId_];\\n        emit RescueFinalized(payloadId_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns vault asset from superform\\n    function _getVaultAsset(address superform_) internal view returns (address) {\\n        return IBaseForm(superform_).getVaultAsset();\\n    }\\n\\n    /// @dev returns if superform is valid\\n    function _isSuperform(uint256 superformId_) internal view returns (bool) {\\n        return ISuperformFactory(_getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\"))).isSuperform(superformId_);\\n    }\\n\\n    /// @dev returns a superformAddress\\n    function _getSuperform(uint256 superformId_) internal pure returns (address superform) {\\n        (superform,,) = superformId_.getSuperform();\\n    }\\n\\n    /// @dev returns if an address has a specific role\\n    function _hasRole(bytes32 id_, address addressToCheck_) internal view returns (bool) {\\n        return ISuperRBAC(_getAddress(keccak256(\\\"SUPER_RBAC\\\"))).hasRole(id_, addressToCheck_);\\n    }\\n\\n    /// @dev returns the registry address for id\\n    function _getStateRegistryId(address registryAddress_) internal view returns (uint8 id) {\\n        return superRegistry.getStateRegistryId(registryAddress_);\\n    }\\n\\n    /// @dev returns the address from super registry\\n    function _getAddress(bytes32 id_) internal view returns (address) {\\n        return superRegistry.getAddress(id_);\\n    }\\n\\n    /// @dev returns the current timelock delay\\n    function _getDelay() internal view returns (uint256) {\\n        uint256 delay = superRegistry.delay();\\n        if (delay == 0) {\\n            revert Error.DELAY_NOT_SET();\\n        }\\n        return delay;\\n    }\\n\\n    function _validatePayloadId(uint256 payloadId_) internal view {\\n        if (payloadId_ > payloadsCount) {\\n            revert Error.INVALID_PAYLOAD_ID();\\n        }\\n    }\\n\\n    function _onlyAllowedCaller(bytes32 role_) internal view {\\n        if (!_hasRole(role_, msg.sender)) revert Error.NOT_PRIVILEGED_CALLER(role_);\\n    }\\n\\n    /// @dev retrieves information associated with the payload and validates quorum\\n    function _getPayload(uint256 payloadId_)\\n        internal\\n        view\\n        returns (\\n            uint256 payloadHeader_,\\n            bytes memory payloadBody_,\\n            bytes32 payloadProof,\\n            uint8 txType,\\n            uint8 callbackType,\\n            uint8 isMulti,\\n            uint8 registryId,\\n            address srcSender,\\n            uint64 srcChainId\\n        )\\n    {\\n        payloadHeader_ = payloadHeader[payloadId_];\\n        payloadBody_ = payloadBody[payloadId_];\\n        payloadProof = AMBMessage(payloadHeader_, payloadBody_).computeProof();\\n        (txType, callbackType, isMulti, registryId, srcSender, srcChainId) = payloadHeader_.decodeTxInfo();\\n\\n        /// @dev the number of valid proofs (quorum) must be equal or larger to the required messaging quorum\\n        if (messageQuorum[payloadProof] < _getQuorum(srcChainId)) {\\n            revert Error.INSUFFICIENT_QUORUM();\\n        }\\n    }\\n\\n    /// @dev helper function to update multi vault deposit payload\\n    function _updateMultiDeposit(\\n        uint256 payloadId_,\\n        bytes memory prevPayloadBody_,\\n        uint256[] calldata finalAmounts_,\\n        address[] calldata finalToken_\\n    )\\n        internal\\n        returns (bytes memory newPayloadBody_, PayloadState finalState_)\\n    {\\n        InitMultiVaultData memory multiVaultData = abi.decode(prevPayloadBody_, (InitMultiVaultData));\\n\\n        uint256 arrLen = finalAmounts_.length;\\n        /// @dev compare number of vaults to update with provided finalAmounts length\\n        if (multiVaultData.amounts.length != arrLen) {\\n            revert Error.DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n        }\\n\\n        uint256 validLen;\\n        for (uint256 i; i < arrLen; ++i) {\\n            if (finalAmounts_[i] == 0) {\\n                revert Error.ZERO_AMOUNT();\\n            }\\n\\n            /// @dev observe not consuming the second return value\\n            (multiVaultData.amounts[i],, validLen) = _updateAmount(\\n                IDstSwapper(_getAddress(keccak256(\\\"DST_SWAPPER\\\"))),\\n                multiVaultData.hasDstSwaps[i],\\n                payloadId_,\\n                i,\\n                finalAmounts_[i],\\n                finalToken_[i],\\n                multiVaultData.superformIds[i],\\n                multiVaultData.amounts[i],\\n                multiVaultData.maxSlippages[i],\\n                validLen\\n            );\\n        }\\n\\n        /// @dev validLen > 0 for the cases where there was at least one deposit update that had valid slippage\\n        /// @dev (v1: passedSlippage, v2: failedSlippage, v3: passedSlippage)\\n        /// @dev final vaults: (v1, v3) / PayloadState.UPDATED\\n        /// @dev if validLen is 0 then Payload is marked as processed and can be extracted via rescue\\n        if (validLen != 0) {\\n            uint256[] memory finalSuperformIds = new uint256[](validLen);\\n            uint256[] memory finalAmounts = new uint256[](validLen);\\n            uint256[] memory outputAmounts = new uint256[](validLen);\\n            uint256[] memory maxSlippage = new uint256[](validLen);\\n            bool[] memory hasDstSwaps = new bool[](validLen);\\n            bool[] memory retain4626s = new bool[](validLen);\\n\\n            uint256 currLen;\\n            for (uint256 i; i < arrLen; ++i) {\\n                if (multiVaultData.amounts[i] != 0) {\\n                    finalSuperformIds[currLen] = multiVaultData.superformIds[i];\\n                    finalAmounts[currLen] = multiVaultData.amounts[i];\\n                    outputAmounts[currLen] = multiVaultData.outputAmounts[i];\\n                    maxSlippage[currLen] = multiVaultData.maxSlippages[i];\\n                    hasDstSwaps[currLen] = multiVaultData.hasDstSwaps[i];\\n                    retain4626s[currLen] = multiVaultData.retain4626s[i];\\n\\n                    ++currLen;\\n                }\\n            }\\n\\n            multiVaultData.superformIds = finalSuperformIds;\\n            multiVaultData.amounts = finalAmounts;\\n            multiVaultData.outputAmounts = outputAmounts;\\n            multiVaultData.maxSlippages = maxSlippage;\\n            multiVaultData.hasDstSwaps = hasDstSwaps;\\n            multiVaultData.retain4626s = retain4626s;\\n            finalState_ = PayloadState.UPDATED;\\n        } else {\\n            finalState_ = PayloadState.PROCESSED;\\n        }\\n        newPayloadBody_ = abi.encode(multiVaultData);\\n    }\\n\\n    /// @dev helper function to update single vault deposit payload\\n    function _updateSingleDeposit(\\n        uint256 payloadId_,\\n        bytes memory prevPayloadBody_,\\n        uint256 finalAmount_,\\n        address finalToken_\\n    )\\n        internal\\n        returns (bytes memory newPayloadBody_, PayloadState finalState_)\\n    {\\n        InitSingleVaultData memory singleVaultData = abi.decode(prevPayloadBody_, (InitSingleVaultData));\\n\\n        if (finalAmount_ == 0) {\\n            revert Error.ZERO_AMOUNT();\\n        }\\n\\n        /// @dev observe not consuming the third return value\\n        (singleVaultData.amount, finalState_,) = _updateAmount(\\n            IDstSwapper(_getAddress(keccak256(\\\"DST_SWAPPER\\\"))),\\n            singleVaultData.hasDstSwap,\\n            payloadId_,\\n            0,\\n            finalAmount_,\\n            finalToken_,\\n            singleVaultData.superformId,\\n            singleVaultData.amount,\\n            singleVaultData.maxSlippage,\\n            0\\n        );\\n\\n        newPayloadBody_ = abi.encode(singleVaultData);\\n    }\\n\\n    function _updateAmount(\\n        IDstSwapper dstSwapper,\\n        bool hasDstSwap_,\\n        uint256 payloadId_,\\n        uint256 index_,\\n        uint256 finalAmount_,\\n        address finalToken_,\\n        uint256 superformId_,\\n        uint256 amount_,\\n        uint256 maxSlippage_,\\n        uint256 validLen_\\n    )\\n        internal\\n        returns (uint256, PayloadState finalState_, uint256)\\n    {\\n        if (finalToken_ == address(0)) {\\n            revert Error.ZERO_FINAL_TOKEN();\\n        }\\n\\n        bool failedSwapQueued;\\n        if (hasDstSwap_) {\\n            if (dstSwapper.swappedAmount(payloadId_, index_) != finalAmount_) {\\n                (address interimToken, uint256 amount) =\\n                    dstSwapper.getPostDstSwapFailureUpdatedTokenAmount(payloadId_, index_);\\n\\n                if (amount != finalAmount_) {\\n                    revert Error.INVALID_DST_SWAP_AMOUNT();\\n                }\\n\\n                if (interimToken != finalToken_) {\\n                    revert Error.INVALID_UPDATE_FINAL_TOKEN();\\n                }\\n\\n                failedSwapQueued = true;\\n                failedDeposits[payloadId_].superformIds.push(superformId_);\\n                failedDeposits[payloadId_].settlementToken.push(interimToken);\\n                failedDeposits[payloadId_].settleFromDstSwapper.push(true);\\n\\n                /// @dev sets amount to zero and will mark the payload as PROCESSED\\n                amount_ = 0;\\n                finalState_ = PayloadState.PROCESSED;\\n            }\\n        }\\n\\n        /// @dev validate payload update\\n        /// @dev validLen may only be increased here in the case where slippage for the update is valid\\n        /// @notice we enter this if condition only if there is a valid dstSwap OR if there is just bridging to this\\n        /// contract\\n        if (!failedSwapQueued) {\\n            /// if the slippage is within allowed amount && the superform id also exists\\n            try this.validateSlippage(finalAmount_, amount_, maxSlippage_) returns (bool valid) {\\n                /// @dev in case of a valid slippage check we update the amount to finalAmount_\\n                if (valid) {\\n                    amount_ = finalAmount_;\\n                    /// @dev Mark the payload as UPDATED\\n                    finalState_ = PayloadState.UPDATED;\\n                }\\n            } catch {\\n                /// @dev in case of negative slippage we don't update the amount in the user request to the amount\\n                /// provided by the keeper\\n                /// @notice it remains as the original amount supplied by the user in the original state request\\n                /// @notice This means than any difference from the amount provided by the keepeer to the user supplied\\n                /// amount will be collected in this contract and remain here\\n                /// @notice we consider this to also be validSlippage = true\\n                /// @dev Mark the payload as UPDATED\\n                finalState_ = PayloadState.UPDATED;\\n            }\\n\\n            if (!(_isSuperform(superformId_) && finalState_ == PayloadState.UPDATED)) {\\n                failedDeposits[payloadId_].superformIds.push(superformId_);\\n\\n                address asset = _fetchAndValidateFinalToken(superformId_, finalToken_, true);\\n\\n                /// @dev if superform is invalid, try catch will fail and asset pushed is address (0)\\n                /// @notice this means that if a user tries to game the protocol with an invalid superformId, the funds\\n                /// bridged over that failed will be stuck here\\n                /// @notice assets can still be spoofed with any vault.asset(), hence this is done via permissioned role\\n                failedDeposits[payloadId_].settlementToken.push(asset);\\n                failedDeposits[payloadId_].settleFromDstSwapper.push(false);\\n\\n                /// @dev sets amount to zero and will mark the payload as PROCESSED (overriding the previous memory\\n                /// settings)\\n                amount_ = 0;\\n                finalState_ = PayloadState.PROCESSED;\\n            } else {\\n                _fetchAndValidateFinalToken(superformId_, finalToken_, false);\\n                ++validLen_;\\n            }\\n        }\\n\\n        return (amount_, finalState_, validLen_);\\n    }\\n\\n    /// @dev helper function to update multi vault withdraw payload\\n    function _updateWithdrawPayload(\\n        bytes memory prevPayloadBody_,\\n        uint64 srcChainId_,\\n        bytes[] calldata txData_,\\n        uint8 multi\\n    )\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        InitMultiVaultData memory multiVaultData;\\n        InitSingleVaultData memory singleVaultData;\\n        if (multi == 1) {\\n            multiVaultData = abi.decode(prevPayloadBody_, (InitMultiVaultData));\\n        } else {\\n            singleVaultData = abi.decode(prevPayloadBody_, (InitSingleVaultData));\\n            multiVaultData = ArrayCastLib.castToMultiVaultData(singleVaultData);\\n        }\\n\\n        if (multiVaultData.liqData.length != txData_.length) {\\n            revert Error.DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n        }\\n\\n        multiVaultData = _updateTxData(txData_, multiVaultData, srcChainId_, CHAIN_ID);\\n\\n        if (multi == 0) {\\n            singleVaultData.liqData.txData = multiVaultData.liqData[0].txData;\\n            return abi.encode(singleVaultData);\\n        }\\n\\n        return abi.encode(multiVaultData);\\n    }\\n\\n    /// @dev validates the incoming update data\\n    function _updateTxData(\\n        bytes[] calldata txData_,\\n        InitMultiVaultData memory multiVaultData_,\\n        uint64 srcChainId_,\\n        uint64 dstChainId_\\n    )\\n        internal\\n        view\\n        returns (InitMultiVaultData memory)\\n    {\\n        uint256 len = multiVaultData_.liqData.length;\\n        IBaseForm superform;\\n\\n        for (uint256 i; i < len; ++i) {\\n            if (txData_[i].length != 0 && multiVaultData_.liqData[i].txData.length == 0) {\\n                superform = IBaseForm(_getSuperform(multiVaultData_.superformIds[i]));\\n\\n                /// @dev for withdrawals the payload update can happen on core state registry (for normal forms)\\n                /// and also can happen in timelock state registry (for timelock form)\\n\\n                /// @notice this check validates if the state registry is eligible to update tx data for the\\n                /// corresponding superform\\n                if (superform.getStateRegistryId() == _getStateRegistryId(address(this))) {\\n                    PayloadUpdaterLib.validateLiqReq(multiVaultData_.liqData[i]);\\n\\n                    IBridgeValidator bridgeValidator =\\n                        IBridgeValidator(superRegistry.getBridgeValidator(multiVaultData_.liqData[i].bridgeId));\\n\\n                    bridgeValidator.validateTxData(\\n                        IBridgeValidator.ValidateTxDataArgs(\\n                            txData_[i],\\n                            dstChainId_,\\n                            srcChainId_,\\n                            multiVaultData_.liqData[i].liqDstChainId,\\n                            false,\\n                            address(superform),\\n                            multiVaultData_.receiverAddress,\\n                            _getVaultAsset(address(superform)),\\n                            address(0)\\n                        )\\n                    );\\n\\n                    if (\\n                        !PayloadUpdaterLib.validateSlippage(\\n                            bridgeValidator.decodeAmountIn(txData_[i], false),\\n                            superform.previewRedeemFrom(multiVaultData_.amounts[i]),\\n                            multiVaultData_.maxSlippages[i]\\n                        )\\n                    ) {\\n                        revert Error.SLIPPAGE_OUT_OF_BOUNDS();\\n                    }\\n\\n                    multiVaultData_.liqData[i].txData = txData_[i];\\n                }\\n            }\\n        }\\n\\n        return multiVaultData_;\\n    }\\n\\n    function _multiWithdrawal(\\n        uint256 payloadId_,\\n        bytes memory payload_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        InitMultiVaultData memory multiVaultData = abi.decode(payload_, (InitMultiVaultData));\\n\\n        bool errors;\\n        uint256 len = multiVaultData.superformIds.length;\\n        address superformFactory = _getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\"));\\n\\n        for (uint256 i; i < len; ++i) {\\n            // @dev validates if superformId exists on factory\\n            if (!ISuperformFactory(superformFactory).isSuperform(multiVaultData.superformIds[i])) {\\n                revert Error.SUPERFORM_ID_NONEXISTENT();\\n            }\\n\\n            /// @dev Store destination payloadId_ & index in extraFormData (tbd: 1-step flow doesnt need this)\\n            try IBaseForm(_getSuperform(multiVaultData.superformIds[i])).xChainWithdrawFromVault(\\n                InitSingleVaultData({\\n                    payloadId: multiVaultData.payloadId,\\n                    superformId: multiVaultData.superformIds[i],\\n                    amount: multiVaultData.amounts[i],\\n                    outputAmount: multiVaultData.outputAmounts[i],\\n                    maxSlippage: multiVaultData.maxSlippages[i],\\n                    liqData: multiVaultData.liqData[i],\\n                    hasDstSwap: false,\\n                    retain4626: false,\\n                    receiverAddress: multiVaultData.receiverAddress,\\n                    extraFormData: abi.encode(payloadId_, i)\\n                }),\\n                srcSender_,\\n                srcChainId_\\n            ) {\\n                /// @dev marks the indexes that don't require a callback re-mint of shares (successful\\n                /// withdraws)\\n                multiVaultData.amounts[i] = 0;\\n            } catch {\\n                /// @dev detect if there is at least one failed withdraw\\n                errors = true;\\n            }\\n        }\\n\\n        /// @dev if at least one error happens, the shares will be re-minted for the affected superformIds\\n        if (errors) {\\n            return _multiReturnData(\\n                srcSender_,\\n                multiVaultData.payloadId,\\n                TransactionType.WITHDRAW,\\n                CallbackType.FAIL,\\n                multiVaultData.superformIds,\\n                multiVaultData.amounts\\n            );\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _multiDeposit(\\n        uint256 payloadId_,\\n        bytes memory payload_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        InitMultiVaultData memory multiVaultData = abi.decode(payload_, (InitMultiVaultData));\\n\\n        address[] memory superforms = DataLib.getSuperforms(multiVaultData.superformIds);\\n\\n        IERC20 underlying;\\n        uint256 numberOfVaults = multiVaultData.superformIds.length;\\n        bool fulfilment;\\n        bool errors;\\n        for (uint256 i; i < numberOfVaults; ++i) {\\n            /// @dev it is not possible in theory to have multiVaultData.amounts to be 0 at this point\\n            /// @dev this is due to the fact that 0 values are moved in updateDeposit which must always run prior to\\n            /// processing the payload\\n            /// @dev this check is added here only for sanity purposes and full coverage of the line is not possible\\n            if (multiVaultData.amounts[i] != 0) {\\n                underlying = IERC20(_getVaultAsset(superforms[i]));\\n\\n                if (underlying.balanceOf(address(this)) >= multiVaultData.amounts[i]) {\\n                    underlying.safeIncreaseAllowance(superforms[i], multiVaultData.amounts[i]);\\n                    LiqRequest memory emptyRequest;\\n\\n                    /// @notice  If a given deposit fails, we are minting 0 SPs back on source (slight gas waste)\\n                    try IBaseForm(superforms[i]).xChainDepositIntoVault(\\n                        InitSingleVaultData({\\n                            payloadId: multiVaultData.payloadId,\\n                            superformId: multiVaultData.superformIds[i],\\n                            amount: multiVaultData.amounts[i],\\n                            outputAmount: multiVaultData.outputAmounts[i],\\n                            maxSlippage: multiVaultData.maxSlippages[i],\\n                            liqData: emptyRequest,\\n                            hasDstSwap: false,\\n                            retain4626: multiVaultData.retain4626s[i],\\n                            receiverAddress: multiVaultData.receiverAddress,\\n                            extraFormData: multiVaultData.extraFormData\\n                        }),\\n                        srcSender_,\\n                        srcChainId_\\n                    ) returns (uint256 shares) {\\n                        if (shares != 0 && !multiVaultData.retain4626s[i]) {\\n                            fulfilment = true;\\n                            /// @dev marks the indexes that require a callback mint of shares (successful)\\n                            multiVaultData.amounts[i] = shares;\\n                        } else {\\n                            multiVaultData.amounts[i] = 0;\\n                        }\\n                    } catch {\\n                        /// @dev cleaning unused approval\\n                        underlying.safeDecreaseAllowance(superforms[i], multiVaultData.amounts[i]);\\n\\n                        /// @dev if any deposit fails, we mark errors as true and add it to failedDepositSuperformIds\\n                        /// mapping for future rescuing\\n                        errors = true;\\n\\n                        failedDeposits[payloadId_].superformIds.push(multiVaultData.superformIds[i]);\\n\\n                        /// @dev clearing multiVaultData.amounts so that in case that fulfillment is true these amounts\\n                        /// are not minted\\n                        multiVaultData.amounts[i] = 0;\\n                        failedDeposits[payloadId_].settlementToken.push(_getVaultAsset(superforms[i]));\\n                        failedDeposits[payloadId_].settleFromDstSwapper.push(false);\\n                    }\\n                } else {\\n                    revert Error.BRIDGE_TOKENS_PENDING();\\n                }\\n            }\\n        }\\n\\n        if (errors) {\\n            emit FailedXChainDeposits(payloadId_);\\n        }\\n\\n        /// @dev issue superPositions if at least one vault deposit passed\\n        if (fulfilment) {\\n            return _multiReturnData(\\n                srcSender_,\\n                multiVaultData.payloadId,\\n                TransactionType.DEPOSIT,\\n                CallbackType.RETURN,\\n                multiVaultData.superformIds,\\n                multiVaultData.amounts\\n            );\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _singleWithdrawal(\\n        uint256 payloadId_,\\n        bytes memory payload_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        InitSingleVaultData memory singleVaultData = abi.decode(payload_, (InitSingleVaultData));\\n        singleVaultData.extraFormData = abi.encode(payloadId_, 0);\\n\\n        if (!_isSuperform(singleVaultData.superformId)) {\\n            revert Error.SUPERFORM_ID_NONEXISTENT();\\n        }\\n\\n        /// @dev Withdraw from superform\\n        try IBaseForm(_getSuperform(singleVaultData.superformId)).xChainWithdrawFromVault(\\n            singleVaultData, srcSender_, srcChainId_\\n        ) {\\n            // Handle the case when the external call succeeds\\n        } catch {\\n            // Handle the case when the external call reverts for whatever reason\\n            /// https://solidity-by-example.org/try-catch/\\n            return _singleReturnData(\\n                srcSender_,\\n                singleVaultData.payloadId,\\n                TransactionType.WITHDRAW,\\n                CallbackType.FAIL,\\n                singleVaultData.superformId,\\n                singleVaultData.amount\\n            );\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _singleDeposit(\\n        uint256 payloadId_,\\n        bytes memory payload_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        returns (bytes memory)\\n    {\\n        InitSingleVaultData memory singleVaultData = abi.decode(payload_, (InitSingleVaultData));\\n\\n        address superform_ = _getSuperform(singleVaultData.superformId);\\n        address vaultAsset = _getVaultAsset(superform_);\\n        IERC20 underlying = IERC20(vaultAsset);\\n\\n        if (underlying.balanceOf(address(this)) >= singleVaultData.amount) {\\n            underlying.safeIncreaseAllowance(superform_, singleVaultData.amount);\\n\\n            /// @dev deposit to superform\\n            try IBaseForm(superform_).xChainDepositIntoVault(singleVaultData, srcSender_, srcChainId_) returns (\\n                uint256 shares\\n            ) {\\n                if (shares != 0 && !singleVaultData.retain4626) {\\n                    return _singleReturnData(\\n                        srcSender_,\\n                        singleVaultData.payloadId,\\n                        TransactionType.DEPOSIT,\\n                        CallbackType.RETURN,\\n                        singleVaultData.superformId,\\n                        shares\\n                    );\\n                }\\n            } catch {\\n                /// @dev cleaning unused approval\\n                underlying.safeDecreaseAllowance(superform_, singleVaultData.amount);\\n\\n                /// @dev if any deposit fails, add it to failedDepositSuperformIds mapping for future rescuing\\n                failedDeposits[payloadId_].superformIds.push(singleVaultData.superformId);\\n                failedDeposits[payloadId_].settlementToken.push(vaultAsset);\\n                failedDeposits[payloadId_].settleFromDstSwapper.push(false);\\n\\n                emit FailedXChainDeposits(payloadId_);\\n            }\\n        } else {\\n            revert Error.BRIDGE_TOKENS_PENDING();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _processAck(uint256 payloadId_, uint64 srcChainId_, bytes memory returnMessage_) internal {\\n        /// @dev if deposits succeeded or some withdrawal failed, dispatch a callback\\n        if (returnMessage_.length != 0) {\\n            uint8[] memory ambIds = msgAMBs[payloadId_];\\n\\n            (, bytes memory extraData) = IPaymentHelper(_getAddress(keccak256(\\\"PAYMENT_HELPER\\\"))).calculateAMBData(\\n                srcChainId_, ambIds, returnMessage_\\n            );\\n\\n            _dispatchPayload(msg.sender, ambIds, srcChainId_, returnMessage_, extraData);\\n        }\\n    }\\n\\n    /// @notice depositSync and withdrawSync internal method for sending message back to the source chain\\n    function _multiReturnData(\\n        address srcSender_,\\n        uint256 payloadId_,\\n        TransactionType txType,\\n        CallbackType returnType_,\\n        uint256[] memory superformIds_,\\n        uint256[] memory amounts_\\n    )\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        /// @dev Send Data to Source to issue superform positions (failed withdraws and successful deposits)\\n        return abi.encode(\\n            AMBMessage(\\n                DataLib.packTxInfo(\\n                    uint8(txType), uint8(returnType_), 1, _getStateRegistryId(address(this)), srcSender_, CHAIN_ID\\n                ),\\n                abi.encode(ReturnMultiData(payloadId_, superformIds_, amounts_))\\n            )\\n        );\\n    }\\n\\n    /// @notice depositSync and withdrawSync internal method for sending message back to the source chain\\n    function _singleReturnData(\\n        address srcSender_,\\n        uint256 payloadId_,\\n        TransactionType txType,\\n        CallbackType returnType_,\\n        uint256 superformId_,\\n        uint256 amount_\\n    )\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        /// @dev Send Data to Source to issue superform positions (failed withdraws and successful deposits)\\n        return abi.encode(\\n            AMBMessage(\\n                DataLib.packTxInfo(\\n                    uint8(txType), uint8(returnType_), 0, _getStateRegistryId(address(this)), srcSender_, CHAIN_ID\\n                ),\\n                abi.encode(ReturnSingleData(payloadId_, superformId_, amount_))\\n            )\\n        );\\n    }\\n\\n    /// @dev calls the function to update the proof during payload update\\n    function _updatePayload(\\n        uint256 payloadId_,\\n        bytes32 prevPayloadProof,\\n        bytes memory newPayloadBody,\\n        uint256 prevPayloadHeader,\\n        PayloadState finalState\\n    )\\n        internal\\n    {\\n        bytes32 newPayloadProof = AMBMessage(prevPayloadHeader, newPayloadBody).computeProof();\\n        if (newPayloadProof != prevPayloadProof) {\\n            messageQuorum[newPayloadProof] = messageQuorum[prevPayloadProof];\\n\\n            delete messageQuorum[prevPayloadProof];\\n        }\\n\\n        payloadBody[payloadId_] = newPayloadBody;\\n        payloadTracking[payloadId_] = finalState;\\n\\n        emit PayloadUpdated(payloadId_);\\n    }\\n\\n    /// @dev fetch vault asset and valid it against the final token\\n    function _fetchAndValidateFinalToken(\\n        uint256 superformId_,\\n        address finalToken_,\\n        bool validateInsideTry_\\n    )\\n        internal\\n        view\\n        returns (address vaultAsset_)\\n    {\\n        try IBaseForm(_getSuperform(superformId_)).getVaultAsset() returns (address asset_) {\\n            if (validateInsideTry_ && asset_ != finalToken_) {\\n                revert Error.INVALID_UPDATE_FINAL_TOKEN();\\n            }\\n\\n            vaultAsset_ = asset_;\\n        } catch {\\n            /// @dev if its error, we just consider asset as zero address\\n        }\\n\\n        /// @dev vaultAsset_ will be address(0) if it does not enter the loop\\n        if (!validateInsideTry_ && vaultAsset_ != finalToken_) {\\n            revert Error.INVALID_UPDATE_FINAL_TOKEN();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/crosschain-data/BaseStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IBaseStateRegistry } from \\\"src/interfaces/IBaseStateRegistry.sol\\\";\\nimport { IAmbImplementation } from \\\"src/interfaces/IAmbImplementation.sol\\\";\\nimport { IQuorumManager } from \\\"src/interfaces/IQuorumManager.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport { ProofLib } from \\\"src/libraries/ProofLib.sol\\\";\\nimport { PayloadState, AMBMessage, AMBExtraData } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title BaseStateRegistry\\n/// @dev Contract module that allows inheriting contracts to implement crosschain messaging & processing mechanisms.\\n/// @dev this is a lightweight version that allows only dispatching and receiving crosschain\\n/// @dev payloads (messages). Inheriting children contracts have the flexibility to define their own processing\\n/// mechanisms.\\n/// @author Zeropoint Labs\\nabstract contract BaseStateRegistry is IBaseStateRegistry {\\n    using ProofLib for AMBMessage;\\n    using ProofLib for bytes;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    ISuperRegistry public immutable superRegistry;\\n    uint64 public immutable CHAIN_ID;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    uint256 public payloadsCount;\\n\\n    /// @dev stores received payload after assigning them an unique identifier upon receiving\\n    mapping(uint256 => bytes) public payloadBody;\\n\\n    /// @dev stores received payload's header (txInfo)\\n    mapping(uint256 => uint256) public payloadHeader;\\n\\n    /// @dev stores a proof's quorum\\n    mapping(bytes32 => uint256) public messageQuorum;\\n\\n    /// @dev maps payloads to their current status\\n    mapping(uint256 => PayloadState) public payloadTracking;\\n\\n    /// @dev maps payloads to the amb ids that delivered them\\n    mapping(uint256 => uint8[]) internal msgAMBs;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev inheriting contracts should override this function based on functionality\\n    modifier onlySender() virtual {\\n        _;\\n    }\\n\\n    /// @dev ensures that only added AMB implementations are accepted\\n    modifier onlyValidAmbImplementation() {\\n        if (!superRegistry.isValidAmbImpl(msg.sender)) {\\n            revert Error.NOT_AMB_IMPLEMENTATION();\\n        }\\n\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(ISuperRegistry superRegistry_) {\\n        if (block.chainid > type(uint64).max) {\\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n        }\\n\\n        CHAIN_ID = uint64(block.chainid);\\n        superRegistry = superRegistry_;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IBaseStateRegistry\\n    function getMessageAMB(uint256 payloadId_) external view override returns (uint8[] memory) {\\n        return msgAMBs[payloadId_];\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IBaseStateRegistry\\n    function dispatchPayload(\\n        address srcSender_,\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable\\n        override\\n        onlySender\\n    {\\n        _dispatchPayload(srcSender_, ambIds_, dstChainId_, message_, extraData_);\\n    }\\n\\n    /// @inheritdoc IBaseStateRegistry\\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external override onlyValidAmbImplementation {\\n        AMBMessage memory data = abi.decode(message_, (AMBMessage));\\n\\n        /// @dev proofHash will always be 32 bytes length due to keccak256\\n        if (data.params.length == 32) {\\n            bytes32 proofHash = abi.decode(data.params, (bytes32));\\n            ++messageQuorum[proofHash];\\n\\n            emit ProofReceived(proofHash);\\n        } else {\\n            /// @dev if message, store header and body of it\\n            ++payloadsCount;\\n\\n            payloadHeader[payloadsCount] = data.txInfo;\\n            (msgAMBs[payloadsCount], payloadBody[payloadsCount]) = abi.decode(data.params, (uint8[], bytes));\\n\\n            emit PayloadReceived(srcChainId_, CHAIN_ID, payloadsCount);\\n        }\\n    }\\n\\n    /// @inheritdoc IBaseStateRegistry\\n    function processPayload(uint256 payloadId_) external payable virtual override;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    function _dispatchPayload(\\n        address srcSender_,\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        internal\\n    {\\n        AMBMessage memory data = abi.decode(message_, (AMBMessage));\\n        uint256 len = ambIds_.length;\\n\\n        if (len == 0) {\\n            revert Error.ZERO_AMB_ID_LENGTH();\\n        }\\n\\n        /// @dev revert here if quorum requirements might fail on the remote chain\\n        if (len - 1 < _getQuorum(dstChainId_)) {\\n            revert Error.INSUFFICIENT_QUORUM();\\n        }\\n\\n        AMBExtraData memory d = abi.decode(extraData_, (AMBExtraData));\\n\\n        _getAMBImpl(ambIds_[0]).dispatchPayload{ value: d.gasPerAMB[0] }(\\n            srcSender_,\\n            dstChainId_,\\n            abi.encode(AMBMessage(data.txInfo, abi.encode(ambIds_, data.params))),\\n            d.extraDataPerAMB[0]\\n        );\\n\\n        if (len > 1) {\\n            data.params = message_.computeProofBytes();\\n\\n            /// @dev i starts from 1 since 0 is primary amb id which dispatches the message itself\\n            for (uint8 i = 1; i < len; ++i) {\\n                if (ambIds_[i] == ambIds_[0]) {\\n                    revert Error.INVALID_PROOF_BRIDGE_ID();\\n                }\\n\\n                if (i - 1 != 0 && ambIds_[i] <= ambIds_[i - 1]) {\\n                    revert Error.INVALID_PROOF_BRIDGE_IDS();\\n                }\\n\\n                /// @dev proof is dispatched in the form of a payload\\n                _getAMBImpl(ambIds_[i]).dispatchPayload{ value: d.gasPerAMB[i] }(\\n                    srcSender_, dstChainId_, abi.encode(data), d.extraDataPerAMB[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @dev returns the required quorum for the src chain id from super registry\\n    /// @param chainId_ is the src chain id\\n    /// @return the quorum configured for the chain id\\n    function _getQuorum(uint64 chainId_) internal view returns (uint256) {\\n        return IQuorumManager(address(superRegistry)).getRequiredMessagingQuorum(chainId_);\\n    }\\n\\n    /// @dev returns the amb id for address\\n    function _getAmbAddress(uint8 id_) internal view returns (address amb) {\\n        return superRegistry.getAmbAddress(id_);\\n    }\\n\\n    function _getAMBImpl(uint8 id_) internal view returns (IAmbImplementation ambImplementation) {\\n        ambImplementation = IAmbImplementation(_getAmbAddress(id_));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICoreStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ICoreStateRegistry\\n/// @dev Interface for CoreStateRegistry\\n/// @author ZeroPoint Labs\\ninterface ICoreStateRegistry {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev holds all information about a failed deposit mapped to a payload id\\n    /// @param superformIds is an array of failing superform ids\\n    /// @param settlementToken is an array of tokens to be refunded for the failing superform\\n    /// @param amounts is an array of amounts of settlementToken to be refunded\\n    /// @param receiverAddress is the users refund address\\n    /// @param lastProposedTime indicates the rescue proposal timestamp\\n    struct FailedDeposit {\\n        uint256[] superformIds;\\n        address[] settlementToken;\\n        uint256[] amounts;\\n        bool[] settleFromDstSwapper;\\n        address receiverAddress;\\n        uint256 lastProposedTimestamp;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when any deposit fails\\n    event FailedXChainDeposits(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when a rescue is proposed for failed deposits in a payload\\n    event RescueProposed(\\n        uint256 indexed payloadId,\\n        uint256[] superformIds,\\n        uint256[] proposedAmount,\\n        uint256 proposedTime\\n    );\\n\\n    /// @dev is emitted when an user disputed his refund amounts\\n    event RescueDisputed(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when deposit rescue is finalized\\n    event RescueFinalized(uint256 indexed payloadId);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows users to read the superformIds that failed in a specific payloadId_\\n    /// @param payloadId_ is the identifier of the cross-chain payload.\\n    /// @return superformIds is the identifiers of superforms in the payloadId that got failed.\\n    /// @return amounts is the amounts of refund tokens issues\\n    /// @return lastProposedTime is the refund proposed time\\n    function getFailedDeposits(uint256 payloadId_)\\n        external\\n        view\\n        returns (uint256[] memory superformIds, uint256[] memory amounts, uint256 lastProposedTime);\\n\\n    /// @dev used internally for try/catching\\n    /// @param finalAmount_ is the final amount of tokens received\\n    /// @param amount_ is the indicated amount of tokens to be received\\n    /// @param maxSlippage_ is the amount of acceptable slippage for the transaction\\n    function validateSlippage(uint256 finalAmount_, uint256 amount_, uint256 maxSlippage_)\\n        external\\n        view\\n        returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_UPDATER_ROLE} to modify a received cross-chain deposit payload.\\n    /// @param payloadId_ is the identifier of the cross-chain payload to be updated.\\n    /// @param finalTokens_ is the token received by the core state registry.\\n    /// @param finalAmounts_ is the amount to be updated.\\n    /// NOTE: amounts cannot be updated beyond user specified safe slippage limit.\\n    function updateDepositPayload(\\n        uint256 payloadId_,\\n        address[] calldata finalTokens_,\\n        uint256[] calldata finalAmounts_\\n    )\\n        external;\\n\\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_UPDATER_ROLE} to modify a received cross-chain withdraw payload.\\n    /// @param payloadId_  is the identifier of the cross-chain payload to be updated.\\n    /// @param txData_ is the transaction data to be updated.\\n    function updateWithdrawPayload(uint256 payloadId_, bytes[] calldata txData_) external;\\n\\n    /// @dev allows accounts with {CORE_STATE_REGISTRY_PROCESSOR_ROLE} to rescue tokens on failed deposits\\n    /// @param payloadId_ is the identifier of the cross-chain payload.\\n    /// @param proposedAmounts_ is the array of proposed rescue amounts.\\n    function proposeRescueFailedDeposits(uint256 payloadId_, uint256[] memory proposedAmounts_) external;\\n\\n    /// @dev allows refund receivers to challenge their final receiving token amounts on failed deposits\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    /// @notice should challenge within the delay window configured on SuperRegistry\\n    function disputeRescueFailedDeposits(uint256 payloadId_) external;\\n\\n    /// @dev allows anyone to settle refunds for unprocessed/failed deposits past the challenge period\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    function finalizeRescueFailedDeposits(uint256 payloadId_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBaseForm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { InitSingleVaultData } from \\\"src/types/DataTypes.sol\\\";\\nimport { IERC165 } from \\\"openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\\\";\\nimport { IERC4626 } from \\\"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\\\";\\n\\n/// @title IBaseForm\\n/// @dev Interface for BaseForm\\n/// @author ZeroPoint Labs\\ninterface IBaseForm is IERC165 {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                           //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a new vault is added by the admin.\\n    event VaultAdded(uint256 indexed id, IERC4626 indexed vault);\\n\\n    /// @dev is emitted when a payload is processed by the destination contract.\\n    event Processed(\\n        uint64 indexed srcChainID,\\n        uint64 indexed dstChainId,\\n        uint256 indexed srcPayloadId,\\n        uint256 amount,\\n        address vault\\n    );\\n\\n    /// @dev is emitted when an emergency withdrawal is processed\\n    event EmergencyWithdrawalProcessed(address indexed refundAddress, uint256 indexed amount);\\n\\n    /// @dev is emitted when dust is forwarded to the paymaster\\n    event FormDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice get Superform name of the ERC20 vault representation\\n    /// @return The ERC20 name\\n    function superformYieldTokenName() external view returns (string memory);\\n\\n    /// @notice get Superform symbol of the ERC20 vault representation\\n    /// @return The ERC20 symbol\\n    function superformYieldTokenSymbol() external view returns (string memory);\\n\\n    /// @notice get the state registry id associated with the vault\\n    function getStateRegistryId() external view returns (uint8);\\n\\n    /// @notice Returns the vault address\\n    /// @return The address of the vault\\n    function getVaultAddress() external view returns (address);\\n\\n    /// @notice Returns the vault address\\n    /// @return The address of the vault asset\\n    function getVaultAsset() external view returns (address);\\n\\n    /// @notice Returns the name of the vault.\\n    /// @return The name of the vault\\n    function getVaultName() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of a vault.\\n    /// @return The symbol associated with a vault\\n    function getVaultSymbol() external view returns (string memory);\\n\\n    /// @notice Returns the number of decimals in a vault for accounting purposes\\n    /// @return The number of decimals in the vault balance\\n    function getVaultDecimals() external view returns (uint256);\\n\\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\\n    /// @return The pricePerVaultShare value\\n    function getPricePerVaultShare() external view returns (uint256);\\n\\n    /// @notice Returns the amount of vault shares owned by the form.\\n    /// @return The form's vault share balance\\n    function getVaultShareBalance() external view returns (uint256);\\n\\n    /// @notice get the total amount of underlying managed in the ERC4626 vault\\n    function getTotalAssets() external view returns (uint256);\\n\\n    /// @notice get the total amount of unredeemed vault shares in circulation\\n    function getTotalSupply() external view returns (uint256);\\n\\n    /// @notice get the total amount of assets received if shares are actually redeemed\\n    /// @notice https://eips.ethereum.org/EIPS/eip-4626\\n    function getPreviewPricePerVaultShare() external view returns (uint256);\\n\\n    /// @dev API may need to know state of funds deployed\\n    function previewDepositTo(uint256 assets_) external view returns (uint256);\\n\\n    /// @notice positionBalance() -> .vaultIds&destAmounts\\n    /// @return how much of an asset + interest (accrued) is to withdraw from the Vault\\n    function previewWithdrawFrom(uint256 assets_) external view returns (uint256);\\n\\n    /// @dev API may need to know state of funds deployed\\n    function previewRedeemFrom(uint256 shares_) external view returns (uint256);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev process same chain id deposits\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @return shares  The amount of vault shares received\\n    function directDepositIntoVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_\\n    )\\n        external\\n        payable\\n        returns (uint256 shares);\\n\\n    /// @dev process same chain id deposits\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @param srcChainId_ The chain id of the source chain\\n    /// @return shares  The amount of vault shares received\\n    /// @dev is shares is `0` then no further action/acknowledgement needs to be sent\\n    function xChainDepositIntoVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        external\\n        returns (uint256 shares);\\n\\n    /// @dev process withdrawal of asset from a vault\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @return assets  The amount of assets received\\n    function directWithdrawFromVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_\\n    )\\n        external\\n        returns (uint256 assets);\\n\\n    /// @dev process withdrawal of asset from a vault\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @param srcChainId_ The chain id of the source chain\\n    /// @return assets The amount of assets received\\n    function xChainWithdrawFromVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        external\\n        returns (uint256 assets);\\n\\n    /// @dev process withdrawal of shares if form is paused\\n    /// @param receiverAddress_ The address to refund the shares to\\n    /// @param amount_ The amount of vault shares to refund\\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external;\\n\\n    /// @dev moves all dust in the contract to Paymaster contract\\n    /// @param token_ The address of the token to forward\\n    function forwardDustToPaymaster(address token_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBridgeValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title Bridge Validator Interface\\n/// @dev Interface all Bridge Validators must follow\\n/// @author Zeropoint Labs\\ninterface IBridgeValidator {\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct ValidateTxDataArgs {\\n        bytes txData;\\n        uint64 srcChainId;\\n        uint64 dstChainId;\\n        uint64 liqDstChainId;\\n        bool deposit;\\n        address superform;\\n        address receiverAddress;\\n        address liqDataToken;\\n        address liqDataInterimToken;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev validates the receiver of the liquidity request\\n    /// @param txData_ is the txData of the cross chain deposit\\n    /// @param receiver_ is the address of the receiver to validate\\n    /// @return valid_ if the address is valid\\n    function validateReceiver(bytes calldata txData_, address receiver_) external view returns (bool valid_);\\n\\n    /// @dev validates the txData of a cross chain deposit\\n    /// @param args_ the txData arguments to validate in txData\\n    /// @return hasDstSwap if the txData contains a destination swap\\n    function validateTxData(ValidateTxDataArgs calldata args_) external view returns (bool hasDstSwap);\\n\\n    /// @dev decodes the txData and returns the amount of input token on source\\n    /// @param txData_ is the txData of the cross chain deposit\\n    /// @param genericSwapDisallowed_ true if generic swaps are disallowed\\n    /// @return amount_ the amount expected\\n    function decodeAmountIn(\\n        bytes calldata txData_,\\n        bool genericSwapDisallowed_\\n    )\\n        external\\n        view\\n        returns (uint256 amount_);\\n\\n    /// @dev decodes neccesary information for processing swaps on the destination chain\\n    /// @param txData_ is the txData to be decoded\\n    /// @return token_ is the address of the token\\n    /// @return amount_ the amount expected\\n    function decodeDstSwap(bytes calldata txData_) external pure returns (address token_, uint256 amount_);\\n\\n    /// @dev decodes the final output token address (for only direct chain actions!)\\n    /// @param txData_ is the txData to be decoded\\n    /// @return token_ the address of the token\\n    function decodeSwapOutputToken(bytes calldata txData_) external pure returns (address token_);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDstSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IDstSwapper\\n/// @dev Interface for DstSwapper\\n/// @author Zeropoint Labs\\ninterface IDstSwapper {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct FailedSwap {\\n        address interimToken;\\n        uint256 amount;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when the super registry is updated.\\n    event SuperRegistryUpdated(address indexed superRegistry);\\n\\n    /// @dev is emitted when a dst swap transaction is processed\\n    event SwapProcessed(\\n        uint256 indexed payloadId, uint256 indexed index, uint256 indexed bridgeId, uint256 finalAmount\\n    );\\n\\n    /// @dev is emitted when a dst swap fails and intermediary tokens are sent to CoreStateRegistry for rescue\\n    event SwapFailed(\\n        uint256 indexed payloadId, uint256 indexed index, address indexed intermediaryToken, uint256 amount\\n    );\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice returns the swapped amounts (if dst swap is successful)\\n    /// @param payloadId_ is the id of payload\\n    /// @param index_ represents the index in the payload (0 for single vault payload)\\n    /// @return amount is the amount forwarded to core state registry after the swap\\n    function swappedAmount(uint256 payloadId_, uint256 index_) external view returns (uint256 amount);\\n\\n    /// @notice returns the interim amounts (if dst swap is failing)\\n    /// @param payloadId_ is the id of payload\\n    /// @param index_ represents the index in the payload (0 for single vault payload)\\n    /// @return interimToken is the token that is to be refunded\\n    /// @return amount is the amount of interim token to be refunded\\n    function getPostDstSwapFailureUpdatedTokenAmount(\\n        uint256 payloadId_,\\n        uint256 index_\\n    )\\n        external\\n        view\\n        returns (address interimToken, uint256 amount);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice will process dst swap through a liquidity bridge\\n    /// @param payloadId_ represents the id of the payload\\n    /// @param bridgeId_ represents the id of liquidity bridge used\\n    /// @param txData_ represents the transaction data generated by liquidity bridge API.\\n    function processTx(uint256 payloadId_, uint8 bridgeId_, bytes calldata txData_) external;\\n\\n    /// @notice will process dst swaps in batch through a liquidity bridge\\n    /// @param payloadId_ represents the array of payload ids used\\n    /// @param indices_ represents the index of the superformid in the payload\\n    /// @param bridgeIds_ represents the array of ids of liquidity bridges used\\n    /// @param txDatas_  represents the array of transaction data generated by liquidity bridge API\\n    function batchProcessTx(\\n        uint256 payloadId_,\\n        uint256[] calldata indices_,\\n        uint8[] calldata bridgeIds_,\\n        bytes[] calldata txDatas_\\n    )\\n        external;\\n\\n    /// @notice updates the amounts of intermediary tokens stuck because of failing dst swap\\n    /// @param payloadId_ represents the id of the payload\\n    /// @param interimToken_ is the intermediary token that cannot be swapped to the vault underlying\\n    /// @param amount_ is the amount of the intermediary token\\n    function updateFailedTx(uint256 payloadId_, address interimToken_, uint256 amount_) external;\\n\\n    /// @notice updates the amounts of intermediary tokens stuck because of failing dst swap in batch\\n    /// @param payloadId_ represents the id of the payload\\n    /// @param indices_ represents the failing indices in the payload\\n    /// @param interimTokens_ is the list of intermediary tokens that cannot be swapped\\n    /// @param amounts_ are the amount of intermediary tokens that need to be refunded to the user\\n    function batchUpdateFailedTx(\\n        uint256 payloadId_,\\n        uint256[] calldata indices_,\\n        address[] calldata interimTokens_,\\n        uint256[] calldata amounts_\\n    )\\n        external;\\n\\n    /// @notice is a privileged function that allows Core State Registry to process refunds\\n    /// @param user_ is the final refund receiver of the interimToken_\\n    /// @param interimToken_ is the refund token\\n    /// @param amount_ is the refund amount\\n    function processFailedTx(address user_, address interimToken_, uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IAccessControl } from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\n/// @title ISuperRBAC\\n/// @dev Interface for SuperRBAC\\n/// @author Zeropoint Labs\\ninterface ISuperRBAC is IAccessControl {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct InitialRoleSetup {\\n        address admin;\\n        address emergencyAdmin;\\n        address paymentAdmin;\\n        address csrProcessor;\\n        address tlProcessor;\\n        address brProcessor;\\n        address csrUpdater;\\n        address srcVaaRelayer;\\n        address dstSwapper;\\n        address csrRescuer;\\n        address csrDisputer;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when superRegistry is set\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev is emitted when an admin is set for a role\\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the id of the protocol admin role\\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency admin role\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin role\\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcaster role\\n    function BROADCASTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor role\\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock state registry processor role\\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry processor role\\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater role\\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper role\\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescuer role\\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescue disputer role\\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of wormhole vaa relayer role\\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns whether the given address has the protocol admin role\\n    /// @param admin_ the address to check\\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\\n\\n    /// @dev returns whether the given address has the emergency admin role\\n    /// @param admin_ the address to check\\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev updates the super registry address\\n    function setSuperRegistry(address superRegistry_) external;\\n\\n    /// @dev configures a new role in superForm\\n    /// @param role_ the role to set\\n    /// @param adminRole_ the admin role to set as admin\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\\n\\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\\n    /// @param role_ the role to revoke\\n    /// @param extraData_ amb config if broadcasting is required\\n    /// @param superRegistryAddressId_ the super registry address id\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows sync of global roles from different chains using broadcast registry\\n    /// @notice may not work for all roles\\n    function stateSyncBroadcast(bytes memory data_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperformFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperformFactory\\n/// @dev Interface for SuperformFactory\\n/// @author ZeroPoint Labs\\ninterface ISuperformFactory {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    enum PauseStatus {\\n        NON_PAUSED,\\n        PAUSED\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when a new formImplementation is entered into the factory\\n    /// @param formImplementation is the address of the new form implementation\\n    /// @param formImplementationId is the id of the formImplementation\\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\\n    event FormImplementationAdded(\\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\\n    );\\n\\n    /// @dev emitted when a new Superform is created\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param vault is the address of the vault\\n    /// @param superformId is the id of the superform\\n    /// @param superform is the address of the superform\\n    event SuperformCreated(\\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\\n    );\\n\\n    /// @dev emitted when a new SuperRegistry is set\\n    /// @param superRegistry is the address of the super registry\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev emitted when a form implementation is paused\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param paused is the new paused status\\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the number of forms\\n    /// @return forms_ is the number of forms\\n    function getFormCount() external view returns (uint256 forms_);\\n\\n    /// @dev returns the number of superforms\\n    /// @return superforms_ is the number of superforms\\n    function getSuperformCount() external view returns (uint256 superforms_);\\n\\n    /// @dev returns the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return formImplementation_ is the address of the form implementation\\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\\n\\n    /// @dev returns the form state registry id of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return stateRegistryId_ is the additional state registry id of the form\\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\\n\\n    /// @dev returns the paused status of form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return paused_ is the current paused status of the form formImplementationId_\\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\\n\\n    /// @dev returns the address of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the id of the form implementation\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        external\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\\n\\n    /// @dev returns if an address has been added to a Form\\n    /// @param superformId_ is the id of the superform\\n    /// @return isSuperform_ bool if it exists\\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\\n\\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\\n    /// @param vault_ is the address of a vault\\n    /// @return superformIds_ is the id of the superform\\n    /// @return superforms_ is the address of the superform\\n    function getAllSuperformsFromVault(address vault_)\\n        external\\n        view\\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows an admin to add a Form implementation to the factory\\n    /// @param formImplementation_ is the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\\n    /// additional state registry is required\\n    function addFormImplementation(\\n        address formImplementation_,\\n        uint32 formImplementationId_,\\n        uint8 formStateRegistryId_\\n    )\\n        external;\\n\\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\\n    /// @param vault_ is the address of the vault\\n    /// @return superformId_ is the id of the created superform\\n    /// @return superform_ is the address of the created superform\\n    function createSuperform(\\n        uint32 formImplementationId_,\\n        address vault_\\n    )\\n        external\\n        returns (uint256 superformId_, address superform_);\\n\\n    /// @dev to synchronize superforms added to different chains using broadcast registry\\n    /// @param data_ is the cross-chain superform id\\n    function stateSyncBroadcast(bytes memory data_) external payable;\\n\\n    /// @dev allows an admin to change the status of a form\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @param status_ is the new status\\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\\n    function changeFormImplementationPauseStatus(\\n        uint32 formImplementationId_,\\n        PauseStatus status_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IERC1155A } from \\\"ERC1155A/interfaces/IERC1155A.sol\\\";\\nimport { AMBMessage } from \\\"../types/DataTypes.sol\\\";\\n\\n/// @title ISuperPositions\\n/// @dev Interface for SuperPositions\\n/// @author Zeropoint Labs\\ninterface ISuperPositions is IERC1155A {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct TxHistory {\\n        uint256 txInfo;\\n        address receiverAddressSP;\\n    }\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a dynamic uri is updated\\n    event DynamicURIUpdated(string indexed oldURI, string indexed newURI, bool indexed frozen);\\n\\n    /// @dev is emitted when a cross-chain transaction is completed.\\n    event Completed(uint256 indexed txId);\\n\\n    /// @dev is emitted when a aErc20 token is registered\\n    event AERC20TokenRegistered(uint256 indexed tokenId, address indexed tokenAddress);\\n\\n    /// @dev is emitted when a tx info is saved\\n    event TxHistorySet(uint256 indexed payloadId, uint256 txInfo, address indexed receiverAddress);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the payload header and the receiver address for a tx id on the source chain\\n    /// @param txId_ is the identifier of the transaction issued by superform router\\n    /// @return txInfo is the header of the payload\\n    /// @return receiverAddressSP is the address of the receiver of superPositions\\n    function txHistory(uint256 txId_) external view returns (uint256 txInfo, address receiverAddressSP);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev saves the message being sent together with the associated id formulated in a router\\n    /// @param payloadId_ is the id of the message being saved\\n    /// @param txInfo_ is the header of the AMBMessage of the transaction being saved\\n    /// @param receiverAddressSP_ is the address of the receiver of superPositions\\n    function updateTxHistory(uint256 payloadId_, uint256 txInfo_, address receiverAddressSP_) external;\\n\\n    /// @dev allows minter to mint shares on source\\n    /// @param receiverAddress_ is the beneficiary of shares\\n    /// @param id_ is the id of the shares\\n    /// @param amount_ is the amount of shares to mint\\n    function mintSingle(address receiverAddress_, uint256 id_, uint256 amount_) external;\\n\\n    /// @dev allows minter to mint shares on source in batch\\n    /// @param receiverAddress_ is the beneficiary of shares\\n    /// @param ids_ are the ids of the shares\\n    /// @param amounts_ are the amounts of shares to mint\\n    function mintBatch(address receiverAddress_, uint256[] memory ids_, uint256[] memory amounts_) external;\\n\\n    /// @dev allows superformRouter to burn shares on source\\n    /// @notice burn is done optimistically by the router in the beginning of the withdraw transactions\\n    /// @notice in case the withdraw tx fails on the destination, shares are reminted through stateSync\\n    /// @param srcSender_ is the address of the sender\\n    /// @param id_ is the id of the shares\\n    /// @param amount_ is the amount of shares to burn\\n    function burnSingle(address srcSender_, uint256 id_, uint256 amount_) external;\\n\\n    /// @dev allows burner to burn shares on source in batch\\n    /// @param srcSender_ is the address of the sender\\n    /// @param ids_ are the ids of the shares\\n    /// @param amounts_ are the amounts of shares to burn\\n    function burnBatch(address srcSender_, uint256[] memory ids_, uint256[] memory amounts_) external;\\n\\n    /// @dev allows state registry contract to mint shares on source\\n    /// @param data_ is the received information to be processed.\\n    /// @return srcChainId_ is the decoded srcChainId.\\n    function stateMultiSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\\n\\n    /// @dev allows state registry contract to mint shares on source\\n    /// @param data_ is the received information to be processed.\\n    /// @return srcChainId_ is the decoded srcChainId.\\n    function stateSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\\n\\n    /// @dev sets the dynamic uri for NFT\\n    /// @param dynamicURI_ is the dynamic uri of the NFT\\n    /// @param freeze_ is to prevent updating the metadata once migrated to IPFS\\n    function setDynamicURI(string memory dynamicURI_, bool freeze_) external;\\n\\n    /// @dev allows to create sERC0 using broadcast state registry\\n    /// @param data_ is the crosschain payload\\n    function stateSyncBroadcast(bytes memory data_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperRegistry\\n/// @dev Interface for SuperRegistry\\n/// @author Zeropoint Labs\\ninterface ISuperRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when permit2 is set.\\n    event SetPermit2(address indexed permit2);\\n\\n    /// @dev is emitted when an address is set.\\n    event AddressUpdated(\\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\\n    );\\n\\n    /// @dev is emitted when a new token bridge is configured.\\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\\n\\n    /// @dev is emitted when a new bridge validator is configured.\\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\\n\\n    /// @dev is emitted when a new amb is configured.\\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\\n\\n    /// @dev is emitted when a new state registry is configured.\\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\\n\\n    /// @dev is emitted when a new delay is configured.\\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\\n\\n    /// @dev is emitted when a new vault limit is configured\\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the deposit rescue delay\\n    function delay() external view returns (uint256);\\n\\n    /// @dev returns the permit2 address\\n    function PERMIT2() external view returns (address);\\n\\n    /// @dev returns the id of the superform router module\\n    function SUPERFORM_ROUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform factory module\\n    function SUPERFORM_FACTORY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform paymaster contract\\n    function PAYMASTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform payload helper contract\\n    function PAYMENT_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry module\\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry module\\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry module\\n    function BROADCAST_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super positions module\\n    function SUPER_POSITIONS() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super rbac module\\n    function SUPER_RBAC() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payload helper module\\n    function PAYLOAD_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper keeper\\n    function DST_SWAPPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency queue\\n    function EMERGENCY_QUEUE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform receiver\\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin keeper\\n    function PAYMENT_ADMIN() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor keeper\\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast registry processor keeper\\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry processor keeper\\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev gets the address of a contract on current chain\\n    /// @param id_ is the id of the contract\\n    function getAddress(bytes32 id_) external view returns (address);\\n\\n    /// @dev gets the address of a contract on a target chain\\n    /// @param id_ is the id of the contract\\n    /// @param chainId_ is the chain id of that chain\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\\n\\n    /// @dev gets the address of a bridge\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeAddress_ is the address of the form\\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\\n\\n    /// @dev gets the address of a bridge validator\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeValidator_ is the address of the form\\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\\n\\n    /// @dev gets the address of a amb\\n    /// @param ambId_ is the id of a bridge\\n    /// @return ambAddress_ is the address of the form\\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\\n\\n    /// @dev gets the id of the amb\\n    /// @param ambAddress_ is the address of an amb\\n    /// @return ambId_ is the identifier of an amb\\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\\n\\n    /// @dev gets the address of the registry\\n    /// @param registryId_ is the id of the state registry\\n    /// @return registryAddress_ is the address of the state registry\\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\\n\\n    /// @dev gets the id of the registry\\n    /// @notice reverts if the id is not found\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return registryId_ is the id of the state registry\\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\\n\\n    /// @dev gets the safe vault limit\\n    /// @param chainId_ is the id of the remote chain\\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\\n    /// without hitting out of gas error\\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\\n\\n    /// @dev helps validate if an address is a valid state registry\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid amb implementation\\n    /// @param ambAddress_ is the address of the amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid broadcast amb implementation\\n    /// @param ambAddress_ is the address of the broadcast amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev sets the deposit rescue delay\\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\\n    function setDelay(uint256 delay_) external;\\n\\n    /// @dev sets the permit2 address\\n    /// @param permit2_ the address of the permit2 contract\\n    function setPermit2(address permit2_) external;\\n\\n    /// @dev sets the safe vault limit\\n    /// @param chainId_ is the remote chain identifier\\n    /// @param vaultLimit_ is the max limit of vaults per transaction\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\\n\\n    /// @dev sets new addresses on specific chains.\\n    /// @param ids_ are the identifiers of the address on that chain\\n    /// @param newAddresses_  are the new addresses on that chain\\n    /// @param chainIds_ are the chain ids of that chain\\n    function batchSetAddress(\\n        bytes32[] calldata ids_,\\n        address[] calldata newAddresses_,\\n        uint64[] calldata chainIds_\\n    )\\n        external;\\n\\n    /// @dev sets a new address on a specific chain.\\n    /// @param id_ the identifier of the address on that chain\\n    /// @param newAddress_ the new address on that chain\\n    /// @param chainId_ the chain id of that chain\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\\n\\n    /// @dev allows admin to set the bridge address for an bridge id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param bridgeId_         represents the bridge unique identifier.\\n    /// @param bridgeAddress_    represents the bridge address.\\n    /// @param bridgeValidator_  represents the bridge validator address.\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the amb address for an amb id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param ambId_         represents the bridge unique identifier.\\n    /// @param ambAddress_    represents the bridge address.\\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the state registry address for an state registry id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param registryId_    represents the state registry's unique identifier.\\n    /// @param registryAddress_    represents the state registry's address.\\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPaymentHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport {\\n    MultiDstMultiVaultStateReq,\\n    MultiDstSingleVaultStateReq,\\n    SingleXChainMultiVaultStateReq,\\n    SingleXChainSingleVaultStateReq,\\n    SingleDirectSingleVaultStateReq,\\n    SingleDirectMultiVaultStateReq\\n} from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title IPaymentHelper\\n/// @dev Interface for PaymentHelper\\n/// @author ZeroPoint Labs\\ninterface IPaymentHelper {\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @param nativeFeedOracle is the native price feed oracle\\n    /// @param gasPriceOracle is the gas price oracle\\n    /// @param swapGasUsed is the swap gas params\\n    /// @param updateGasUsed is the update gas params\\n    /// @param depositGasUsed is the deposit per vault gas on the chain\\n    /// @param withdrawGasUsed is the withdraw per vault gas on the chain\\n    /// @param defaultNativePrice is the native price on the specified chain\\n    /// @param defaultGasPrice is the gas price on the specified chain\\n    /// @param dstGasPerByte is the gas per size of data on the specified chain\\n    /// @param ackGasCost is the gas cost for sending and processing from dst->src\\n    /// @param timelockCost is the extra cost for processing timelocked payloads\\n    /// @param emergencyCost is the extra cost for processing emergency payloads\\n    struct PaymentHelperConfig {\\n        address nativeFeedOracle;\\n        address gasPriceOracle;\\n        uint256 swapGasUsed;\\n        uint256 updateGasUsed;\\n        uint256 depositGasUsed;\\n        uint256 withdrawGasUsed;\\n        uint256 defaultNativePrice;\\n        uint256 defaultGasPrice;\\n        uint256 dstGasPerByte;\\n        uint256 ackGasCost;\\n        uint256 timelockCost;\\n        uint256 emergencyCost;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    event ChainConfigUpdated(uint64 indexed chainId_, uint256 indexed configType_, bytes config_);\\n    event ChainConfigAdded(uint64 chainId_, PaymentHelperConfig config_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @param dstChainId_ is the unique dst chain identifier\\n    /// @param ambIds_ is the identifiers of arbitrary message bridges to be used\\n    /// @param message_ is the encoded cross-chain payload\\n    function calculateAMBData(\\n        uint64 dstChainId_,\\n        uint8[] calldata ambIds_,\\n        bytes memory message_\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees, bytes memory extraData);\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @return extraData the amb specific override information\\n    function getRegisterTransmuterAMBData() external view returns (bytes memory extraData);\\n\\n    /// @dev estimates the gas fees for multiple destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstMultiVault(\\n        MultiDstMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstSingleVault(\\n        MultiDstSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainMultiVault(\\n        SingleXChainMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainSingleVault(\\n        SingleXChainSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectSingleVault(\\n        SingleDirectSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectMultiVault(\\n        SingleDirectMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    /// @dev returns the gas fees estimation in native tokens if we send message through a combination of AMBs\\n    /// @param ambIds_ is the identifier of different AMBs\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message\\n    /// @param extraData_ is any amb-specific information\\n    /// @return ambFees is the native_tokens to be sent along the transaction for all the ambIds_ included\\n    function estimateAMBFees(\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes[] memory extraData_\\n    )\\n        external\\n        view\\n        returns (uint256 ambFees, uint256[] memory);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing\\n    /// @param payloadId_ is the payload identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCost(uint256 payloadId_) external view returns (uint256 totalFees);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing without relying on payloadId (using max values)\\n    /// @param multi is the flag indicating if the payload is multi or single\\n    /// @param ackAmbIds is the list of ambIds to be used for acknowledgement\\n    /// @param srcChainId is the source chain identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCostDefault(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees);\\n\\n    /// @dev helps estimate the acknowledgement costs for amb processing without relying on payloadId (using max values)\\n    /// with source native amounts\\n    /// @param multi is the flag indicating if the payload is multi or single\\n    /// @param ackAmbIds is the list of ambIds to be used for acknowledgement\\n    /// @param srcChainId is the source chain identifier\\n    /// @return totalFees is the total fees to be paid in native tokens\\n    function estimateAckCostDefaultNativeSource(\\n        bool multi,\\n        uint8[] memory ackAmbIds,\\n        uint64 srcChainId\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees);\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev admin can configure a remote chain for first time\\n    /// @param chainId_ is the identifier of new chain id\\n    /// @param config_ is the chain config\\n    function addRemoteChain(uint64 chainId_, PaymentHelperConfig calldata config_) external;\\n\\n    /// @dev admin can specifically configure/update certain configuration of a remote chain\\n    /// @param chainId_ is the remote chain's identifier\\n    /// @param configType_ is the type of config from 1 -> 6\\n    /// @param config_ is the encoded new configuration\\n    function updateRemoteChain(uint64 chainId_, uint256 configType_, bytes memory config_) external;\\n\\n    /// @dev admin updates config for register transmuter amb params\\n    /// @param extraDataForTransmuter_ is the broadcast extra data\\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/DataLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\nlibrary DataLib {\\n    function packTxInfo(\\n        uint8 txType_,\\n        uint8 callbackType_,\\n        uint8 multi_,\\n        uint8 registryId_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 txInfo)\\n    {\\n        txInfo = uint256(txType_);\\n        txInfo |= uint256(callbackType_) << 8;\\n        txInfo |= uint256(multi_) << 16;\\n        txInfo |= uint256(registryId_) << 24;\\n        txInfo |= uint256(uint160(srcSender_)) << 32;\\n        txInfo |= uint256(srcChainId_) << 192;\\n    }\\n\\n    function decodeTxInfo(uint256 txInfo_)\\n        internal\\n        pure\\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\\n    {\\n        txType = uint8(txInfo_);\\n        callbackType = uint8(txInfo_ >> 8);\\n        multi = uint8(txInfo_ >> 16);\\n        registryId = uint8(txInfo_ >> 24);\\n        srcSender = address(uint160(txInfo_ >> 32));\\n        srcChainId = uint64(txInfo_ >> 192);\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the form id\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        internal\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\\n    {\\n        superform_ = address(uint160(superformId_));\\n        formImplementationId_ = uint32(superformId_ >> 160);\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of an array of superforms\\n    /// @param superformIds_  array of superforms\\n    /// @return superforms_ are the address of the vaults\\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\\n        uint256 len = superformIds_.length;\\n        superforms_ = new address[](len);\\n\\n        for (uint256 i; i < len; ++i) {\\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\\n        }\\n    }\\n\\n    /// @dev returns the destination chain of a given superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return chainId_ is the chain id\\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev generates the superformId\\n    /// @param superform_ is the address of the superform\\n    /// @param formImplementationId_ is the type of the form\\n    /// @param chainId_ is the chain id on which the superform is deployed\\n    function packSuperform(\\n        address superform_,\\n        uint32 formImplementationId_,\\n        uint64 chainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 superformId_)\\n    {\\n        superformId_ = uint256(uint160(superform_));\\n        superformId_ |= uint256(formImplementationId_) << 160;\\n        superformId_ |= uint256(chainId_) << 192;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { AMBMessage } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @dev generates proof for amb message and bytes encoded message\\nlibrary ProofLib {\\n    function computeProof(AMBMessage memory message_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(message_));\\n    }\\n\\n    function computeProofBytes(AMBMessage memory message_) internal pure returns (bytes memory) {\\n        return abi.encode(keccak256(abi.encode(message_)));\\n    }\\n\\n    function computeProof(bytes memory message_) internal pure returns (bytes32) {\\n        return keccak256(message_);\\n    }\\n\\n    function computeProofBytes(bytes memory message_) internal pure returns (bytes memory) {\\n        return abi.encode(keccak256(message_));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArrayCastLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { InitSingleVaultData, InitMultiVaultData, LiqRequest } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @dev library to cast single values into array for streamlining helper functions\\n/// @notice not gas optimized, suggested for usage only in view/pure functions\\nlibrary ArrayCastLib {\\n    function castLiqRequestToArray(LiqRequest memory value_) internal pure returns (LiqRequest[] memory values) {\\n        values = new LiqRequest[](1);\\n\\n        values[0] = value_;\\n    }\\n\\n    function castBoolToArray(bool value_) internal pure returns (bool[] memory values) {\\n        values = new bool[](1);\\n\\n        values[0] = value_;\\n    }\\n\\n    function castToMultiVaultData(InitSingleVaultData memory data_)\\n        internal\\n        pure\\n        returns (InitMultiVaultData memory castedData_)\\n    {\\n        uint256[] memory superformIds = new uint256[](1);\\n        superformIds[0] = data_.superformId;\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = data_.amount;\\n\\n        uint256[] memory outputAmounts = new uint256[](1);\\n        outputAmounts[0] = data_.outputAmount;\\n\\n        uint256[] memory maxSlippage = new uint256[](1);\\n        maxSlippage[0] = data_.maxSlippage;\\n\\n        LiqRequest[] memory liqData = new LiqRequest[](1);\\n        liqData[0] = data_.liqData;\\n\\n        castedData_ = InitMultiVaultData(\\n            data_.payloadId,\\n            superformIds,\\n            amounts,\\n            outputAmounts,\\n            maxSlippage,\\n            liqData,\\n            castBoolToArray(data_.hasDstSwap),\\n            castBoolToArray(data_.retain4626),\\n            data_.receiverAddress,\\n            data_.extraFormData\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PayloadUpdaterLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { DataLib } from \\\"src/libraries/DataLib.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport { PayloadState, CallbackType, LiqRequest } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @dev library to validate slippage updation\\nlibrary PayloadUpdaterLib {\\n    function validateSlippage(\\n        uint256 newAmount_,\\n        uint256 maxAmount_,\\n        uint256 slippage_\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        /// @dev args validation\\n        if (newAmount_ > maxAmount_) {\\n            revert Error.NEGATIVE_SLIPPAGE();\\n        }\\n\\n        uint256 minAmount = (maxAmount_ * (10_000 - slippage_)) / 10_000;\\n\\n        /// @dev amount must fall within the slippage bounds\\n        if (newAmount_ < minAmount) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function validateLiqReq(LiqRequest memory req_) internal pure {\\n        /// revert if token is address(0) -> user wants settlement without any liq data\\n        /// revert if token is not address(0) and txData is already present\\n        if (req_.token == address(0) || req_.txData.length != 0) {\\n            revert Error.CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n        }\\n    }\\n\\n    function validatePayloadUpdate(\\n        uint256 txInfo_,\\n        uint8 txType_,\\n        PayloadState currentPayloadState_,\\n        uint8 isMulti_\\n    )\\n        internal\\n        pure\\n    {\\n        (uint256 txType, uint256 callbackType, uint8 multi,,,) = DataLib.decodeTxInfo(txInfo_);\\n\\n        if (!(txType == txType_ && callbackType == uint256(CallbackType.INIT))) {\\n            revert Error.INVALID_PAYLOAD_UPDATE_REQUEST();\\n        }\\n\\n        if (currentPayloadState_ != PayloadState.STORED) {\\n            revert Error.PAYLOAD_ALREADY_UPDATED();\\n        }\\n\\n        if (multi != isMulti_) {\\n            revert Error.INVALID_PAYLOAD_UPDATE_REQUEST();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nlibrary Error {\\n    //////////////////////////////////////////////////////////////\\n    //                  CONFIGURATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown in protocol setup\\n\\n    /// @dev thrown if chain id exceeds max(uint64)\\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if not possible to revoke a role in broadcasting\\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n\\n    /// @dev thrown if not possible to revoke last admin\\n    error CANNOT_REVOKE_LAST_ADMIN();\\n\\n    /// @dev thrown if trying to set again pseudo immutables in super registry\\n    error DISABLED();\\n\\n    /// @dev thrown if rescue delay is not yet set for a chain\\n    error DELAY_NOT_SET();\\n\\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\\n    error INVALID_NATIVE_TOKEN_PRICE();\\n\\n    /// @dev thrown if wormhole refund chain id is not set\\n    error REFUND_CHAIN_ID_NOT_SET();\\n\\n    /// @dev thrown if wormhole relayer is not set\\n    error RELAYER_NOT_SET();\\n\\n    /// @dev thrown if a role to be revoked is not assigned\\n    error ROLE_NOT_ASSIGNED();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  AUTHORIZATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if functions cannot be called\\n\\n    /// COMMON AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if caller is not address(this), internal call\\n    error INVALID_INTERNAL_CALL();\\n\\n    /// @dev thrown if msg.sender is not a valid amb implementation\\n    error NOT_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not an allowed broadcaster\\n    error NOT_ALLOWED_BROADCASTER();\\n\\n    /// @dev thrown if msg.sender is not broadcast amb implementation\\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not broadcast state registry\\n    error NOT_BROADCAST_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not core state registry\\n    error NOT_CORE_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not emergency admin\\n    error NOT_EMERGENCY_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not emergency queue\\n    error NOT_EMERGENCY_QUEUE();\\n\\n    /// @dev thrown if msg.sender is not minter\\n    error NOT_MINTER();\\n\\n    /// @dev thrown if msg.sender is not minter state registry\\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\\n\\n    /// @dev thrown if msg.sender is not paymaster\\n    error NOT_PAYMASTER();\\n\\n    /// @dev thrown if msg.sender is not payment admin\\n    error NOT_PAYMENT_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not protocol admin\\n    error NOT_PROTOCOL_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not state registry\\n    error NOT_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not super registry\\n    error NOT_SUPER_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not superform router\\n    error NOT_SUPERFORM_ROUTER();\\n\\n    /// @dev thrown if msg.sender is not a superform\\n    error NOT_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not superform factory\\n    error NOT_SUPERFORM_FACTORY();\\n\\n    /// @dev thrown if msg.sender is not timelock form\\n    error NOT_TIMELOCK_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not timelock state registry\\n    error NOT_TIMELOCK_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not user or disputer\\n    error NOT_VALID_DISPUTER();\\n\\n    /// @dev thrown if the msg.sender is not privileged caller\\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\\n\\n    /// STATE REGISTRY AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\\n    error CALLER_NOT_ENDPOINT();\\n\\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\\n    error CALLER_NOT_MAILBOX();\\n\\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\\n    error CALLER_NOT_RELAYER();\\n\\n    /// @dev thrown if src chain sender is not valid\\n    error INVALID_SRC_SENDER();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INPUT VALIDATION ERRORS                 //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if input variables are not valid\\n\\n    /// COMMON INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if there is an array length mismatch\\n    error ARRAY_LENGTH_MISMATCH();\\n\\n    /// @dev thrown if payload id does not exist\\n    error INVALID_PAYLOAD_ID();\\n\\n    /// @dev error thrown when msg value should be zero in certain payable functions\\n    error MSG_VALUE_NOT_ZERO();\\n\\n    /// @dev thrown if amb ids length is 0\\n    error ZERO_AMB_ID_LENGTH();\\n\\n    /// @dev thrown if address input is address 0\\n    error ZERO_ADDRESS();\\n\\n    /// @dev thrown if amount input is 0\\n    error ZERO_AMOUNT();\\n\\n    /// @dev thrown if final token is address 0\\n    error ZERO_FINAL_TOKEN();\\n\\n    /// @dev thrown if value input is 0\\n    error ZERO_INPUT_VALUE();\\n\\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the vaults data is invalid\\n    error INVALID_SUPERFORMS_DATA();\\n\\n    /// @dev thrown if receiver address is not set\\n    error RECEIVER_ADDRESS_NOT_SET();\\n\\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if a form is not ERC165 compatible\\n    error ERC165_UNSUPPORTED();\\n\\n    /// @dev thrown if a form is not form interface compatible\\n    error FORM_INTERFACE_UNSUPPORTED();\\n\\n    /// @dev error thrown if form implementation address already exists\\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\\n\\n    /// @dev error thrown if form implementation id already exists\\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\\n\\n    /// @dev thrown if a form does not exist\\n    error FORM_DOES_NOT_EXIST();\\n\\n    /// @dev thrown if form id is larger than max uint16\\n    error INVALID_FORM_ID();\\n\\n    /// @dev thrown if superform not on factory\\n    error SUPERFORM_ID_NONEXISTENT();\\n\\n    /// @dev thrown if same vault and form implementation is used to create new superform\\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\\n\\n    /// FORM INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\\n    /// in case of txData, if token output of swap != vault.asset()\\n    error DIFFERENT_TOKENS();\\n\\n    /// @dev thrown if the amount in direct withdraw is not correct\\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// @dev thrown if the amount in xchain withdraw is not correct\\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if route id is blacklisted in socket\\n    error BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev thrown if route id is not blacklisted in socket\\n    error NOT_BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is a blacklisted selector\\n    error BLACKLISTED_SELECTOR();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is not a blacklisted selector\\n    error NOT_BLACKLISTED_SELECTOR();\\n\\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\\n    error INVALID_ACTION();\\n\\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\\n\\n    /// @dev thrown if index is invalid\\n    error INVALID_INDEX();\\n\\n    /// @dev thrown if the chain id in the txdata is invalid\\n    error INVALID_TXDATA_CHAIN_ID();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\\n    error INVALID_TXDATA_RECEIVER();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\\n    error INVALID_TXDATA_TOKEN();\\n\\n    /// @dev thrown if txData is not present (in case of xChain actions)\\n    error NO_TXDATA_PRESENT();\\n\\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n\\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n\\n    /// @dev thrown if keeper update final token is different than the vault underlying\\n    error INVALID_UPDATE_FINAL_TOKEN();\\n\\n    /// @dev thrown if broadcast finality for wormhole is invalid\\n    error INVALID_BROADCAST_FINALITY();\\n\\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\\n    error INVALID_BRIDGE_ID();\\n\\n    /// @dev thrown if chain id involved in xchain message is invalid\\n    error INVALID_CHAIN_ID();\\n\\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\\n    error INVALID_DST_SWAP_AMOUNT();\\n\\n    /// @dev thrown if message amb and proof amb are the same\\n    error INVALID_PROOF_BRIDGE_ID();\\n\\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\\n    error INVALID_PROOF_BRIDGE_IDS();\\n\\n    /// @dev thrown if rescue data lengths are invalid\\n    error INVALID_RESCUE_DATA();\\n\\n    /// @dev thrown if delay is invalid\\n    error INVALID_TIMELOCK_DELAY();\\n\\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\\n    error NEGATIVE_SLIPPAGE();\\n\\n    /// @dev thrown if slippage is outside of bounds\\n    error SLIPPAGE_OUT_OF_BOUNDS();\\n\\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if src senders mismatch in state sync\\n    error SRC_SENDER_MISMATCH();\\n\\n    /// @dev thrown if src tx types mismatch in state sync\\n    error SRC_TX_TYPE_MISMATCH();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  EXECUTION ERRORS                        //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown due to function execution logic\\n\\n    /// COMMON EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\\n    error DIRECT_DEPOSIT_SWAP_FAILED();\\n\\n    /// @dev thrown if payload is not unique\\n    error DUPLICATE_PAYLOAD();\\n\\n    /// @dev thrown if native tokens fail to be sent to superform contracts\\n    error FAILED_TO_SEND_NATIVE();\\n\\n    /// @dev thrown if allowance is not correct to deposit\\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\\n\\n    /// @dev thrown if contract has insufficient balance for operations\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @dev thrown if native amount is not at least equal to the amount in the request\\n    error INSUFFICIENT_NATIVE_AMOUNT();\\n\\n    /// @dev thrown if payload cannot be decoded\\n    error INVALID_PAYLOAD();\\n\\n    /// @dev thrown if payload status is invalid\\n    error INVALID_PAYLOAD_STATUS();\\n\\n    /// @dev thrown if payload type is invalid\\n    error INVALID_PAYLOAD_TYPE();\\n\\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\\n\\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\\n    error FAILED_TO_EXECUTE_TXDATA(address token);\\n\\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\\n    error INVALID_DEPOSIT_TOKEN();\\n\\n    /// STATE REGISTRY EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if bridge tokens haven't arrived to destination\\n    error BRIDGE_TOKENS_PENDING();\\n\\n    /// @dev thrown if withdrawal tx data cannot be updated\\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n\\n    /// @dev thrown if rescue passed dispute deadline\\n    error DISPUTE_TIME_ELAPSED();\\n\\n    /// @dev thrown if message failed to reach the specified level of quorum needed\\n    error INSUFFICIENT_QUORUM();\\n\\n    /// @dev thrown if broadcast payload is invalid\\n    error INVALID_BROADCAST_PAYLOAD();\\n\\n    /// @dev thrown if broadcast fee is invalid\\n    error INVALID_BROADCAST_FEE();\\n\\n    /// @dev thrown if retry fees is less than required\\n    error INVALID_RETRY_FEE();\\n\\n    /// @dev thrown if broadcast message type is wrong\\n    error INVALID_MESSAGE_TYPE();\\n\\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\\n    error INVALID_PAYLOAD_HASH();\\n\\n    /// @dev thrown if update payload function was called on a wrong payload\\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\\n\\n    /// @dev thrown if a state registry id is 0\\n    error INVALID_REGISTRY_ID();\\n\\n    /// @dev thrown if a form state registry id is 0\\n    error INVALID_FORM_REGISTRY_ID();\\n\\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\\n    error LOCKED();\\n\\n    /// @dev thrown if payload is already updated (during xChain deposits)\\n    error PAYLOAD_ALREADY_UPDATED();\\n\\n    /// @dev thrown if payload is already processed\\n    error PAYLOAD_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if payload is not in UPDATED state\\n    error PAYLOAD_NOT_UPDATED();\\n\\n    /// @dev thrown if rescue is still in timelocked state\\n    error RESCUE_LOCKED();\\n\\n    /// @dev thrown if rescue is already proposed\\n    error RESCUE_ALREADY_PROPOSED();\\n\\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\\n    error ZERO_PAYLOAD_HASH();\\n\\n    /// DST SWAPPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if process dst swap is tried for processed payload id\\n    error DST_SWAP_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if indices have duplicates\\n    error DUPLICATE_INDEX();\\n\\n    /// @dev thrown if failed dst swap is already updated\\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\\n\\n    /// @dev thrown if indices are out of bounds\\n    error INDEX_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if failed swap token amount is 0\\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\\n\\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\\n    error INVALID_INTERIM_TOKEN();\\n\\n    /// @dev thrown if dst swap output is less than minimum expected\\n    error INVALID_SWAP_OUTPUT();\\n\\n    /// FORM EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if try to forward 4626 share from the superform\\n    error CANNOT_FORWARD_4646_TOKEN();\\n\\n    /// @dev thrown in KYCDAO form if no KYC token is present\\n    error NO_VALID_KYC_TOKEN();\\n\\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\\n    error PAUSED();\\n\\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\\n    error VAULT_IMPLEMENTATION_FAILED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TOKEN_NOT_UPDATED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\\n\\n    /// @dev thrown when redeeming from vault yields zero collateral\\n    error WITHDRAW_ZERO_COLLATERAL();\\n\\n    /// PAYMENT HELPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if chainlink is reporting an improper price\\n    error CHAINLINK_MALFUNCTION();\\n\\n    /// @dev thrown if chainlink is reporting an incomplete round\\n    error CHAINLINK_INCOMPLETE_ROUND();\\n\\n    /// @dev thrown if feed decimals is not 8\\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\\n\\n    /// EMERGENCY QUEUE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if emergency withdraw is not queued\\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\\n\\n    /// @dev thrown if emergency withdraw is already processed\\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\\n\\n    /// SUPERPOSITION EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if uri cannot be updated\\n    error DYNAMIC_URI_FROZEN();\\n\\n    /// @dev thrown if tx history is not found while state sync\\n    error TX_HISTORY_NOT_FOUND();\\n}\\n\"\r\n    },\r\n    \"src/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @dev contains all the common struct and enums used for data communication between chains.\\n\\n/// @dev There are two transaction types in Superform Protocol\\nenum TransactionType {\\n    DEPOSIT,\\n    WITHDRAW\\n}\\n\\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\\nenum CallbackType {\\n    INIT,\\n    RETURN,\\n    FAIL\\n}\\n\\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\\nenum PayloadState {\\n    STORED,\\n    UPDATED,\\n    PROCESSED\\n}\\n\\n/// @dev contains all the common struct used for interchain token transfers.\\nstruct LiqRequest {\\n    /// @dev generated data\\n    bytes txData;\\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\\n    /// txData to be updated on destination for withdraws\\n    address token;\\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\\n    /// validation purposes\\n    address interimToken;\\n    /// @dev what bridge to use to move tokens\\n    uint8 bridgeId;\\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\\n    /// is to be delivered\\n    uint64 liqDstChainId;\\n    /// @dev currently this amount is used as msg.value in the txData call.\\n    uint256 nativeAmount;\\n}\\n\\n/// @dev main struct that holds required multi vault data for an action\\nstruct MultiVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256[] superformIds;\\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev main struct that holds required single vault data for an action\\nstruct SingleVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256 maxSlippage;\\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool hasDstSwap;\\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev overarching struct for multiDst requests with multi vaults\\nstruct MultiDstMultiVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    MultiVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with multi vaults\\nstruct SingleXChainMultiVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    MultiVaultSFData superformsData;\\n}\\n\\n/// @dev overarching struct for multiDst requests with single vaults\\nstruct MultiDstSingleVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    SingleVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with single vaults\\nstruct SingleXChainSingleVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with single vaults\\nstruct SingleDirectSingleVaultStateReq {\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with multi vaults\\nstruct SingleDirectMultiVaultStateReq {\\n    MultiVaultSFData superformData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\\nstruct InitMultiVaultData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n    uint256[] outputAmounts;\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqData;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\nstruct InitSingleVaultData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount;\\n    uint256 maxSlippage;\\n    LiqRequest liqData;\\n    bool hasDstSwap;\\n    bool retain4626;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for Emergency Queue\\nstruct QueuedWithdrawal {\\n    address receiverAddress;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 srcPayloadId;\\n    bool isProcessed;\\n}\\n\\n/// @dev all statuses of the timelock payload\\nenum TimelockStatus {\\n    UNAVAILABLE,\\n    PENDING,\\n    PROCESSED\\n}\\n\\n/// @dev holds information about the timelock payload\\nstruct TimelockPayload {\\n    uint8 isXChain;\\n    uint64 srcChainId;\\n    uint256 lockedTill;\\n    InitSingleVaultData data;\\n    TimelockStatus status;\\n}\\n\\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\\n/// data in params\\nstruct AMBMessage {\\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\\n        // srcSender and srcChainId\\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\\n}\\n\\n/// @dev struct that contains the information required for broadcasting changes\\nstruct BroadcastMessage {\\n    bytes target;\\n    bytes32 messageType;\\n    bytes message;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnMultiData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnSingleData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs\\nstruct AMBExtraData {\\n    uint256[] gasPerAMB;\\n    bytes[] extraDataPerAMB;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\\nstruct BroadCastAMBExtraData {\\n    uint256[] gasPerDst;\\n    bytes[] extraDataPerDst;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBaseStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { PayloadState } from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title IBaseStateRegistry\\n/// @dev Interface for BaseStateRegistry\\n/// @author ZeroPoint Labs\\ninterface IBaseStateRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a cross-chain payload is received in the state registry\\n    event PayloadReceived(uint64 indexed srcChainId, uint64 indexed dstChainId, uint256 indexed payloadId);\\n\\n    /// @dev is emitted when a cross-chain proof is received in the state registry\\n    /// NOTE: comes handy if quorum required is more than 0\\n    event ProofReceived(bytes32 indexed proof);\\n\\n    /// @dev is emitted when a payload id gets updated\\n    event PayloadUpdated(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when a payload id gets processed\\n    event PayloadProcessed(uint256 indexed payloadId);\\n\\n    /// @dev is emitted when the super registry address is updated\\n    event SuperRegistryUpdated(address indexed superRegistry);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows users to read the total payloads received by the registry\\n    function payloadsCount() external view returns (uint256);\\n\\n    /// @dev allows user to read the payload state\\n    /// uint256 payloadId_ is the unique payload identifier allocated on the destination chain\\n    function payloadTracking(uint256 payloadId_) external view returns (PayloadState payloadState_);\\n\\n    /// @dev allows users to read the bytes payload_ stored per payloadId_\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return payloadBody_ the crosschain data received\\n    function payloadBody(uint256 payloadId_) external view returns (bytes memory payloadBody_);\\n\\n    /// @dev allows users to read the uint256 payloadHeader stored per payloadId_\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return payloadHeader_ the crosschain header received\\n    function payloadHeader(uint256 payloadId_) external view returns (uint256 payloadHeader_);\\n\\n    /// @dev allows users to read the ambs that delivered the payload id\\n    /// @param payloadId_ is the unique payload identifier allocated on the destination chain\\n    /// @return ambIds_ is the identifier of ambs that delivered the message and proof\\n    function getMessageAMB(uint256 payloadId_) external view returns (uint8[] memory ambIds_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows core contracts to send payload to a destination chain.\\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\\n    /// @param ambIds_ is the identifier of the arbitrary message bridge to be used\\n    /// @param dstChainId_ is the internal chainId used throughout the protocol\\n    /// @param message_ is the crosschain payload to be sent\\n    /// @param extraData_ defines all the message bridge related overrides\\n    /// NOTE: dstChainId_ is mapped to message bridge's destination id inside it's implementation contract\\n    /// NOTE: ambIds_ are superform assigned unique identifier for arbitrary message bridges\\n    function dispatchPayload(\\n        address srcSender_,\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows state registry to receive messages from message bridge implementations\\n    /// @param srcChainId_ is the superform chainId from which the payload is dispatched/sent\\n    /// @param message_ is the crosschain payload received\\n    /// NOTE: Only {IMPLEMENTATION_CONTRACT} role can call this function.\\n    function receivePayload(uint64 srcChainId_, bytes memory message_) external;\\n\\n    /// @dev allows privileged actors to process cross-chain payloads\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    /// NOTE: Only {CORE_STATE_REGISTRY_PROCESSOR_ROLE} role can call this function\\n    /// NOTE: this should handle reverting the state on source chain in-case of failure\\n    /// (or) can implement scenario based reverting like in coreStateRegistry\\n    function processPayload(uint256 payloadId_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAmbImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IAmbImplementation\\n/// @dev Interface for arbitrary message bridge (AMB) implementations\\n/// @author ZeroPoint Labs\\ninterface IAmbImplementation {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    event ChainAdded(uint64 indexed superChainId);\\n    event AuthorizedImplAdded(uint64 indexed superChainId, address indexed authImpl);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the gas fees estimation in native tokens\\n    /// @notice not all AMBs will have on-chain estimation for which this function will return 0\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message\\n    /// @param extraData_ is any amb-specific information\\n    /// @return fees is the native_tokens to be sent along the transaction\\n    function estimateFees(\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        view\\n        returns (uint256 fees);\\n\\n    /// @dev returns the extra data for the given gas request\\n    /// @param gasLimit is the amount of gas limit in wei to override\\n    /// @return extraData is the bytes encoded extra data\\n    /// NOTE: this process is unique to the message bridge\\n    function generateExtraData(uint256 gasLimit) external pure returns (bytes memory extraData);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows state registry to send message via implementation.\\n    /// @param srcSender_ is the caller (used for gas refunds)\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message to be sent\\n    /// @param extraData_ is message amb specific override information\\n    function dispatchPayload(\\n        address srcSender_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows for the permissionless calling of the retry mechanism for encoded data\\n    /// @param data_ is the encoded retry data (different per AMB implementation)\\n    function retryPayload(bytes memory data_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuorumManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IQuorumManager\\n/// @dev Interface for QuorumManager\\n/// @author ZeroPoint Labs\\ninterface IQuorumManager {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                           //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when a new quorum is set for a specific chain\\n    /// @param srcChainId the chain id from which the message (payload) is sent\\n    /// @param quorum the minimum number of message bridges required for processing\\n    event QuorumSet(uint64 indexed srcChainId, uint256 indexed quorum);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the required quorum for the srcChain & dstChain\\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\\n    /// @return quorum_ the minimum number of message bridges required for processing\\n    function getRequiredMessagingQuorum(uint64 srcChainId_) external view returns (uint256 quorum_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows inheriting contracts to set the messaging quorum for a specific sender chain\\n    /// @notice quorum is the number of extra ambs a message proof must go through and be validated\\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\\n    /// @param quorum_ the minimum number of message bridges required for processing\\n    /// NOTE: overriding child contracts should handle the sender validation & setting of message quorum\\n    function setRequiredMessagingQuorum(uint64 srcChainId_, uint256 quorum_) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC-4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/src/interfaces/IERC1155A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC1155 } from \\\"openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title IERC1155A\\n/// @author Zeropoint Labs\\n/// @dev Single/range based id approve capability with conversion to ERC20s\\ninterface IERC1155A is IERC1155 {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when single id approval is set\\n    event ApprovalForOne(address indexed owner, address indexed spender, uint256 id, uint256 amount);\\n\\n    /// @dev emitted when an ERC1155A id is transmuted to an aERC20\\n    event TransmutedToERC20(address indexed user, uint256 id, uint256 amount, address indexed receiver);\\n\\n    /// @dev emitted when an aERC20 is transmuted to an ERC1155 id\\n    event TransmutedToERC1155A(address indexed user, uint256 id, uint256 amount, address indexed receiver);\\n\\n    /// @dev emitted when multiple ERC1155A ids are transmuted to aERC20s\\n    event TransmutedBatchToERC20(address indexed user, uint256[] ids, uint256[] amounts, address indexed receiver);\\n\\n    /// @dev emitted when multiple aERC20s are transmuted to ERC1155A ids\\n    event TransmutedBatchToERC1155A(address indexed user, uint256[] ids, uint256[] amounts, address indexed receiver);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          ERRORS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev thrown if aERC20 was already registered\\n    error AERC20_ALREADY_REGISTERED();\\n\\n    /// @dev thrown if aERC20 was not registered\\n    error AERC20_NOT_REGISTERED();\\n\\n    /// @dev thrown if allowance amount will be decreased below zero\\n    error DECREASED_ALLOWANCE_BELOW_ZERO();\\n\\n    /// @dev thrown if the associated ERC1155A id has not been minted before registering an aERC20\\n    error ID_NOT_MINTED_YET();\\n\\n    /// @dev thrown if there is a length mismatch in batch operations\\n    error LENGTH_MISMATCH();\\n\\n    /// @dev thrown if transfer is made to address 0\\n    error TRANSFER_TO_ADDRESS_ZERO();\\n\\n    /// @dev thrown if address is 0\\n    error ZERO_ADDRESS();\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice Public getter for existing single id total supply\\n    /// @param id id of the ERC1155\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /// @notice Public getter to know if a token id exists\\n    /// @dev determines based on total supply for the id\\n    /// @param id id of the ERC1155\\n    function exists(uint256 id) external view returns (bool);\\n\\n    /// @notice Public getter for existing single id approval\\n    /// @param owner address of the owner of the ERC1155A id\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    function allowance(address owner, address spender, uint256 id) external returns (uint256);\\n\\n    /// @notice handy helper to check if a AERC20 is registered\\n    /// @param id id of the ERC1155\\n    function aERC20Exists(uint256 id) external view returns (bool);\\n\\n    /// @notice Public getter for the address of the aErc20 token for a given ERC1155 id\\n    /// @param id id of the ERC1155 to get the aErc20 token address for\\n    /// @return aERC20 address of the aErc20 token for the given ERC1155 id\\n    function getERC20TokenAddress(uint256 id) external view returns (address aERC20);\\n\\n    /// @notice Compute return string from baseURI set for this contract and unique vaultId\\n    /// @param id id of the ERC1155\\n    function uri(uint256 id) external view returns (string memory);\\n\\n    /// @notice ERC1155A name\\n    function name() external view returns (string memory);\\n\\n    /// @notice ERC1155A symbol\\n    function symbol() external view returns (string memory);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice Public function for setting single id approval\\n    /// @dev Notice `owner` param, it will always be msg.sender, see _setApprovalForOne()\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param amount amount of the ERC1155A to approve\\n    function setApprovalForOne(address spender, uint256 id, uint256 amount) external;\\n\\n    /// @notice Public function for setting multiple id approval\\n    /// @dev extension of sigle id approval\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param amounts amounts of the ERC1155A to approve\\n    function setApprovalForMany(address spender, uint256[] memory ids, uint256[] memory amounts) external;\\n\\n    /// @notice Public function for increasing single id approval amount\\n    /// @dev Re-adapted from ERC20\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param addedValue amount of the allowance to increase by\\n    function increaseAllowance(address spender, uint256 id, uint256 addedValue) external returns (bool);\\n\\n    /// @notice Public function for decreasing single id approval amount\\n    /// @dev Re-adapted from ERC20\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param subtractedValue amount of the allowance to decrease by\\n    function decreaseAllowance(address spender, uint256 id, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Public function for increasing multiple id approval amount at once\\n    /// @dev extension of single id increase allowance\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param addedValues amounts of the allowance to increase by\\n    function increaseAllowanceForMany(\\n        address spender,\\n        uint256[] memory ids,\\n        uint256[] memory addedValues\\n    )\\n        external\\n        returns (bool);\\n\\n    /// @notice Public function for decreasing multiple id approval amount at once\\n    /// @dev extension of single id decrease allowance\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param subtractedValues amounts of the allowance to decrease by\\n    function decreaseAllowanceForMany(\\n        address spender,\\n        uint256[] memory ids,\\n        uint256[] memory subtractedValues\\n    )\\n        external\\n        returns (bool);\\n\\n    /// @notice Turn ERC1155A id into an aERC20\\n    /// @dev allows owner to send ERC1155A id as an aERC20 to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param id id of the ERC20s to transmute to aERC20\\n    /// @param amount amount of the ERC20s to transmute to aERC20\\n    /// @param receiver address of the user to receive the aERC20 token\\n    function transmuteToERC20(address owner, uint256 id, uint256 amount, address receiver) external;\\n\\n    /// @notice Turn aERC20 into an ERC1155A id\\n    /// @dev allows owner to send ERC20 as an ERC1155A id to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param id id of the ERC20s to transmute to erc1155\\n    /// @param amount amount of the ERC20s to transmute to erc1155\\n    /// @param receiver address of the user to receive the erc1155 token id\\n    function transmuteToERC1155A(address owner, uint256 id, uint256 amount, address receiver) external;\\n\\n    /// @notice Turn ERC1155A ids into aERC20s\\n    /// @dev allows owner to send ERC1155A ids as aERC20s to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param ids ids of the ERC1155A to transmute\\n    /// @param amounts amounts of the ERC1155A to transmute\\n    /// @param receiver address of the user to receive the aERC20 tokens\\n    function transmuteBatchToERC20(\\n        address owner,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        address receiver\\n    )\\n        external;\\n\\n    /// @notice Turn aERC20s into ERC1155A ids\\n    /// @dev allows owner to send aERC20s as ERC1155A ids to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param ids ids of the ERC20 to transmute\\n    /// @param amounts amounts of the ERC20 to transmute\\n    /// @param receiver address of the user to receive the ERC1155 token ids\\n    function transmuteBatchToERC1155A(\\n        address owner,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        address receiver\\n    )\\n        external;\\n\\n    /// @notice payable to allow any implementing cross-chain protocol to be paid for fees for broadcasting\\n    /// @dev should emit any required events inside _registerAERC20 internal function\\n    /// @param id of the ERC1155 to create a ERC20 for\\n    function registerAERC20(uint256 id) external payable returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/ERC1155A/lib/solmate/src/\",\r\n      \"ERC1155A/=lib/ERC1155A/src/\",\r\n      \"@openzeppelin/contracts/=lib/ERC1155A/lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ERC1155A/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/ERC1155A/lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\",\r\n      \"super-vaults/=lib/super-vaults/src/\",\r\n      \"v2-core/=lib/super-vaults/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/super-vaults/lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/super-vaults/lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BRIDGE_TOKENS_PENDING\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_UPDATE_WITHDRAW_TX_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DELAY_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DISPUTE_TIME_ELAPSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_QUORUM\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_DST_SWAP_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_INTERNAL_CALL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_UPDATE_REQUEST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROOF_BRIDGE_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROOF_BRIDGE_IDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_RESCUE_DATA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_UPDATE_FINAL_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NEGATIVE_SLIPPAGE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_AMB_IMPLEMENTATION\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"NOT_PRIVILEGED_CALLER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_SUPERFORM_ROUTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_VALID_DISPUTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_ALREADY_PROCESSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_ALREADY_UPDATED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAYLOAD_NOT_UPDATED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESCUE_ALREADY_PROPOSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESCUE_LOCKED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SLIPPAGE_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SUPERFORM_ID_NONEXISTENT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"SafeERC20FailedDecreaseAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMB_ID_LENGTH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_FINAL_TOKEN\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"FailedXChainDeposits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"PayloadUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proof\",\"type\":\"bytes32\"}],\"name\":\"ProofReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"RescueDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"}],\"name\":\"RescueFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"proposedAmount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposedTime\",\"type\":\"uint256\"}],\"name\":\"RescueProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"superRegistry\",\"type\":\"address\"}],\"name\":\"SuperRegistryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcSender_\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"ambIds_\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64\",\"name\":\"dstChainId_\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData_\",\"type\":\"bytes\"}],\"name\":\"dispatchPayload\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"disputeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"finalizeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"getFailedDeposits\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"superformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastProposedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"getMessageAMB\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"messageQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadBody\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadHeader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payloadTracking\",\"outputs\":[{\"internalType\":\"enum PayloadState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payloadsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"}],\"name\":\"processPayload\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"proposedAmounts_\",\"type\":\"uint256[]\"}],\"name\":\"proposeRescueFailedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"receivePayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"finalTokens_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"finalAmounts_\",\"type\":\"uint256[]\"}],\"name\":\"updateDepositPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"txData_\",\"type\":\"bytes[]\"}],\"name\":\"updateWithdrawPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"finalAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSlippage_\",\"type\":\"uint256\"}],\"name\":\"validateSlippage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CoreStateRegistry", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000017a332dc7b40ae701485023b219e9d6f493a2514", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}