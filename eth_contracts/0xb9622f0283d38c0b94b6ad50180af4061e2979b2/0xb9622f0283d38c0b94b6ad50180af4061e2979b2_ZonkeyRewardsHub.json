{"SourceCode": "/**\r\n    Website: https://zonkey.io\r\n    Twitter: https://twitter.com/zonkeyio\r\n    Telegram: https://t.me/zonkeyofficial\r\n**/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20Extended {\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function burn(address account, uint256 amount) external;\r\n\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract ZonkeyRewardsHub {\r\n    uint256 private constant _MAX_INT = type(uint256).max;\r\n    address private constant _UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    address public immutable owner;\r\n\r\n    mapping(address => bool) public activeRewardTokens;\r\n    mapping(address => address) _rewardUtilityMap;\r\n\r\n    struct RescueCall {\r\n        address to;\r\n        bytes data;\r\n        uint256 value;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setTokenConfiguration(\r\n        bool active,\r\n        address rewardTokenAddr,\r\n        address utilityToken\r\n    ) external onlyOwner {\r\n        activeRewardTokens[rewardTokenAddr] = active;\r\n        _rewardUtilityMap[rewardTokenAddr] = utilityToken;\r\n    }\r\n\r\n    function swapRewardBalanceForUtilityTokens(\r\n        address rewardToken\r\n    ) external onlyOwner {\r\n        require(activeRewardTokens[rewardToken], \"reward token not active\");\r\n\r\n        IERC20Extended token = IERC20Extended(rewardToken);\r\n\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance > 0, \"reward token balance == 0\");\r\n\r\n        uint256 allowance = token.allowance(address(this), _UNISWAP_V2_ROUTER);\r\n        if (allowance < balance)\r\n            require(\r\n                _approveToken(rewardToken, _UNISWAP_V2_ROUTER, _MAX_INT),\r\n                \"not approved for uniswap\"\r\n            );\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = rewardToken;\r\n        path[1] = _WETH;\r\n        path[2] = _rewardUtilityMap[rewardToken];\r\n\r\n        IUniswapV2Router02(_UNISWAP_V2_ROUTER)\r\n            .swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                balance,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n    }\r\n\r\n    function burnAndClaim(\r\n        address rewardTokenAddress,\r\n        uint256 rewardBurnAmount\r\n    ) external {\r\n        require(\r\n            activeRewardTokens[rewardTokenAddress],\r\n            \"reward token not active\"\r\n        );\r\n        require(rewardBurnAmount > 0, \"burn amount <= 0\");\r\n\r\n        IERC20Extended rewardToken = IERC20Extended(rewardTokenAddress);\r\n        IERC20Extended utilityToken = IERC20Extended(\r\n            _rewardUtilityMap[rewardTokenAddress]\r\n        );\r\n\r\n        uint256 utilityClaimAmount = _getClaimAmount(\r\n            rewardBurnAmount,\r\n            rewardToken.circulatingSupply(),\r\n            utilityToken.balanceOf(address(this))\r\n        );\r\n        require(utilityClaimAmount > 0, \"claimable utility tokens == 0\");\r\n\r\n        rewardToken.burn(msg.sender, rewardBurnAmount);\r\n        utilityToken.transfer(msg.sender, utilityClaimAmount);\r\n    }\r\n\r\n    function getClaimAmount(\r\n        address rewardTokenAddress,\r\n        uint256 rewardBurnAmount\r\n    ) external view returns (uint256) {\r\n        return\r\n            _getClaimAmount(\r\n                rewardBurnAmount,\r\n                IERC20Extended(rewardTokenAddress).circulatingSupply(),\r\n                IERC20Extended(_rewardUtilityMap[rewardTokenAddress]).balanceOf(\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    function _approveToken(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        return IERC20Extended(token).approve(spender, amount);\r\n    }\r\n\r\n    function _getClaimAmount(\r\n        uint256 rewardBurnAmount,\r\n        uint256 rewardCirculatingSupply,\r\n        uint256 contractUtilityBalance\r\n    ) internal pure returns (uint256) {\r\n        if (rewardBurnAmount == 0) return 0;\r\n        if (rewardCirculatingSupply == 0) return 0;\r\n        if (contractUtilityBalance == 0) return 0;\r\n\r\n        uint256 supplyPercentage = ((rewardBurnAmount * 100_000) /\r\n            rewardCirculatingSupply);\r\n        return (supplyPercentage * contractUtilityBalance) / 100_000;\r\n    }\r\n\r\n    function rescueTokens(\r\n        RescueCall[] calldata calls\r\n    ) external payable onlyOwner {\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, ) = payable(calls[i].to).call{value: calls[i].value}(\r\n                calls[i].data\r\n            );\r\n            require(success);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeRewardTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardBurnAmount\",\"type\":\"uint256\"}],\"name\":\"burnAndClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardBurnAmount\",\"type\":\"uint256\"}],\"name\":\"getClaimAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct ZonkeyRewardsHub.RescueCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"utilityToken\",\"type\":\"address\"}],\"name\":\"setTokenConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"swapRewardBalanceForUtilityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ZonkeyRewardsHub", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b97ec52ccc17d9f07bfcdbf9821a55dbef4a140c510dadbd15216591c8113a98"}