{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.18 <0.8.20;\r\n\r\n// ungravel.eth, GroupWalletFactory, GroupWalletMaster, GroupWallet, ProxyWallet, TokenMaster, ProxyToken, PrePaidContract, AuctionMaster, BiddingProxy, intDeedMaster, extDeedMaster, IntDeedProxy by pepihasenfuss.eth 2017-2024, Copyright (c) 2024\r\n\r\n// GroupWallet and ungravel is entirely based on Ethereum Name Service, \"ENS\", the domain name registry.\r\n\r\n//   ENS, ENSRegistryWithFallback, PublicResolver, Resolver, FIFS-Registrar, Registrar, AuctionRegistrar, BaseRegistrar, ReverseRegistrar, DefaultReverseResolver, ETHRegistrarController,\r\n//   PriceOracle, SimplePriceOracle, StablePriceOracle, ENSMigrationSubdomainRegistrar, CustomRegistrar, Root, RegistrarMigration are contracts of \"ENS\", by Nick Johnson and team.\r\n//\r\n//   Copyright (c) 2018, True Names Limited / ENS Labs Limited\r\n//\r\n//   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n//   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n//   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\ninterface ENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n  function owner(bytes32 node) external view returns (address);\r\n  function resolver(bytes32 node) external view returns (address);\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n  function recordExists(bytes32 node) external view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external view returns (bool);\r\n}\r\n\r\nabstract contract AbstractGWF_ENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external virtual;\r\n  function setOwner(bytes32 node, address owner) external virtual;\r\n  \r\n  function owner(bytes32 node) public view virtual returns (address);\r\n  function recordExists(bytes32 node) external virtual view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external virtual view returns (bool);\r\n}\r\n\r\nabstract contract AbstractGWF_ReverseRegistrar {\r\n  function claim(address owner) external virtual returns (bytes32);\r\n  function claimWithResolver(address owner, address resolver) external virtual returns (bytes32);\r\n  function setName(string memory name) external virtual returns (bytes32);\r\n  function node(address addr) external virtual pure returns (bytes32);\r\n}\r\n\r\nabstract contract AbstractBaseRegistrar {\r\n  event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n  bytes32 public baseNode;   // The namehash of the TLD this registrar owns eg, (.)eth\r\n  ENS public ens;\r\n}\r\n\r\nabstract contract AbstractGWF_GWP {\r\n  function getIsOwner(address _owner) external virtual view returns (bool);\r\n  function getOwners()                external virtual view returns (address[] memory);\r\n  function newProxyGroupWallet_j5O(address[] calldata _owners) external virtual payable;\r\n  function reverseENS(string calldata _domain, address _reverse) external virtual;\r\n}\r\n\r\ninterface Abstract_TokenProxy {\r\n  function newToken(uint256[] calldata _data) external payable;\r\n}\r\n\r\nabstract contract AbstractETHRegController {\r\n  mapping(bytes32=>uint) public commitments;\r\n\r\n  uint public minCommitmentAge;\r\n  uint public maxCommitmentAge;\r\n\r\n  address public nameWrapper;\r\n\r\n  event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\r\n  event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\r\n  event NewPriceOracle(address indexed oracle);\r\n\r\n  function rentPrice(string memory name, uint duration) view external virtual returns(uint);\r\n  function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure external virtual returns(bytes32);\r\n  function commit(bytes32 commitment) external virtual;\r\n  function register(string calldata name, address owner, uint duration, bytes32 secret) external virtual payable;\r\n  function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) external virtual payable;\r\n  function available(string memory name) external virtual view returns(bool);\r\n  function register(string calldata name,address owner,uint256 duration,bytes32 secret,address resolver,bytes[] calldata data,bool reverseRecord,uint16 ownerControlledFuses) external virtual payable;\r\n}\r\n\r\nabstract contract AbstractGWF_Resolver {\r\n  mapping(bytes32=>bytes) hashes;\r\n\r\n  event AddrChanged(bytes32 indexed node, address a);\r\n  event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n  event NameChanged(bytes32 indexed node, string name);\r\n  event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n  event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n  event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n  event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n  \r\n  function ABI(bytes32 node, uint256 contentTypes) external virtual view returns (uint256, bytes memory);\r\n  function addr(bytes32 node) external virtual view returns (address);\r\n  function addr(bytes32 node, uint coinType) external virtual view returns(bytes memory);\r\n  function name(bytes32 node) external virtual view returns (string memory);\r\n  function text(bytes32 node, string calldata key) external virtual view returns (string memory);\r\n  function supportsInterface(bytes4 interfaceId) external virtual view returns (bool);\r\n  function setApprovalForAll(address operator, bool approved) virtual external;\r\n\r\n  function setABI(bytes32 node, uint256 contentType, bytes calldata data) external virtual;\r\n  function setAddr(bytes32 node, address r_addr) external virtual;\r\n  function setAddr(bytes32 node, uint coinType, bytes calldata a) external virtual;\r\n  function setName(bytes32 node, string calldata _name) external virtual;\r\n  function setText(bytes32 node, string calldata key, string calldata value) external virtual;\r\n}\r\n\r\nabstract contract Abstract_GWF {\r\n  AbstractGWF_Resolver                  public  resolverContract;\r\n  AbstractETHRegController            public  controllerContract;\r\n  AbstractBaseRegistrar                   public  base;\r\n  AbstractGWF_ENS                          public  ens;\r\n  AbstractGWF_ReverseRegistrar   public  reverseContract;\r\n  address                                             public  GWFowner;\r\n  \r\n  mapping(uint64=>uint256)            private installations;                        // installTime +  proxyTokenAddr\r\n  mapping(bytes32=>uint256)         private commitments;                    // commitment  +  ownerAddr\r\n  \r\n  function version() public pure virtual returns(uint256 v);\r\n  function importGWP(bytes32 _dHash, uint256 commitment, uint256 installation) external virtual payable;\r\n  function getGWProxy(bytes32 _dHash) public virtual view returns (address);\r\n  function getProxyToken(bytes32 _domainHash) public virtual view returns (address p);\r\n}\r\n\r\ninterface Abstract_TM {\r\n  function owner() external view returns (address ow);\r\n}\r\n\r\ninterface Abstract_GWPC {\r\n  function getMasterCopy() external view returns (address);\r\n}\r\n\r\nabstract contract Abs_AuctionRegistrar {\r\n  function startAuction_ge0(bytes32 _hash, uint revealP) public virtual payable;\r\n}\r\n\r\nabstract contract NWrapper {\r\n  function setSubnodeRecord(bytes32 parentNode,string memory label,address owner,address resolver,uint64 ttl,uint32 fuses,uint64 expiry) external virtual returns (bytes32 node);\r\n  function setSubnodeOwner(bytes32 node,string calldata label,address newOwner,uint32 fuses,uint64 expiry) external virtual returns (bytes32);\r\n  function setApprovalForAll(address operator,bool approved) external virtual;\r\n}\r\n\r\ninterface I_NWrapper {\r\n  function setSubnodeRecord(bytes32 parentNode,string memory label,address owner,address resolver,uint64 ttl,uint32 fuses,uint64 expiry) external returns (bytes32 node);\r\n  function setSubnodeOwner(bytes32 node,string calldata label,address newOwner,uint32 fuses,uint64 expiry) external returns (bytes32);\r\n  function setApprovalForAll(address operator,bool approved) external;\r\n}\r\n\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm> /// ProxyToken adapted and applied for shares and token by pepihasenfuss.eth\r\npragma solidity ^0.8.18 <0.8.20;\r\n\r\ncontract ProxyToken {\r\n    address internal masterCopy;\r\n\r\n    bytes32 internal name32;\r\n    uint256 private ownerPrices;\r\n\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping  (address => uint256)) private allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event Deposit(address from, uint256 value);\r\n    event Deployment(address owner, address theContract);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n\r\n    constructor(address _masterCopy) payable\r\n    {\r\n      masterCopy = _masterCopy;\r\n    }\r\n    \r\n    fallback () external payable\r\n    {   \r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let master := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, master)\r\n                return(0, 0x20)\r\n            }\r\n\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let success := delegatecall(gas(), master, ptr, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { \r\n              if eq(returndatasize(),0) { revert(0, 0x404) }\r\n              revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n    \r\n    function upgrade(address master) external payable {\r\n      require(Abstract_TM(masterCopy).owner()==Abstract_TM(master).owner(),\" owner masterCopy!\");\r\n      masterCopy = master;\r\n    }\r\n    \r\n    receive() external payable { emit Deposit(msg.sender, msg.value); }         // *** PTC may receive payments ***\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm> /// ProxyGroupWallet adapted and applied for GroupWallet by pepihasenfuss.eth\r\npragma solidity ^0.8.18 <0.8.20;\r\n\r\ncontract ProxyGroupWallet {\r\n    address internal masterCopy;\r\n\r\n    mapping(uint256 => uint256) private tArr;\r\n    address[]                   private owners;\r\n    \r\n    address internal GWF;                                                       // GWF - GroupWalletFactory contract\r\n    mapping(uint256 => bytes)   private structures;\r\n  \r\n    // *************************************************************************\r\n    event Deposit(address dep_from, uint256 dep_value);\r\n    \r\n    constructor(address _masterCopy, string memory _domain, AbstractGWF_ReverseRegistrar _reverse) payable\r\n    { \r\n      masterCopy = _masterCopy;\r\n      if (block.chainid!=1) _reverse.setName(_domain);\r\n    }\r\n    \r\n    fallback () external payable\r\n    {   \r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let master := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, master)\r\n                return(0, 0x20)\r\n            }\r\n\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let success := delegatecall(gas(), master, ptr, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { \r\n              if eq(returndatasize(),0) { revert(0, 0x504) }\r\n              revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n    \r\n    function upgrade(address master) external payable {\r\n      require(Abstract_GWPC(masterCopy).getMasterCopy()==Abstract_GWPC(master).getMasterCopy(),\" gwp gwpc owner!\");\r\n      masterCopy = master;\r\n    }\r\n    \r\n    receive() external payable { emit Deposit(msg.sender, msg.value); }         // *** GWP can sell common shares to TokenProxy, thus reveiving payment ***\r\n}\r\n\r\n// GroupWalletFactory2 by pepihasenfuss.eth 2017-2023\r\ncontract GroupWalletFactory2 {\r\n\r\n    event TestReturn(uint256 v1, uint256 v2, uint256 v3, uint256 v4);\r\n    event Deposit(address from, uint256 value);\r\n    event PrePaidAccountReady(address from, uint256 value);\r\n    event StructureDeployed(bytes32 domainHash);\r\n    event ColorTableSaved(bytes32 domainHash);\r\n    event EtherScriptSaved(bytes32 domainHash,string key);\r\n    event ProxyTokenCreation(ProxyToken proxy);\r\n    event ProxyGroupWalletCreation(ProxyGroupWallet proxy);\r\n    event SetPrices(bytes32 domainHash);\r\n    event TransferOwner(bytes32 domainHash);\r\n    event FreezeToken(bytes32 domainHash);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    uint256 constant k_aMask        = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant k_commitMask   = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_commit2Mask  = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\r\n    uint256 constant k_lockedMask   = 0x0000000000000000000000010000000000000000000000000000000000000000;\r\n    \r\n    bytes32 constant k_abi80        = 0x0000000000000000000000000000000000000000000000000000000000000080;\r\n    uint256 constant k_rentMask     = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n    address constant k_add00        = address(0x0);\r\n\r\n\r\n    AbstractGWF_Resolver            public  resolverContract;\r\n    AbstractETHRegController        public  controllerContract;\r\n    AbstractBaseRegistrar           public  base;\r\n    AbstractGWF_ENS                 public  ens;\r\n    AbstractGWF_ReverseRegistrar    public  reverseContract;\r\n    address                         public  GWFowner;\r\n    NWrapper                        public  ensNameWrapper;\r\n    Abs_AuctionRegistrar            public  auctionContract;\r\n    \r\n    mapping(uint64=>uint256)        private installations;                      // installTime +  proxyTokenAddr\r\n    mapping(bytes32=>uint256)       private commitments;                        // commitment  +  ownerAddr\r\n\r\n  \r\n    function getGWF() external view returns (address) {\r\n      return address(this);                                                     // needed, to call GroupWallet or GroupWalletFactory transparently\r\n    }\r\n\r\n    function getCommitment(bytes32 _domainHash) private view returns (uint64 comm) {\r\n      return uint64( (uint256( commitments[_domainHash] & k_commitMask )>>160) & k_commit2Mask );\r\n    }\r\n    \r\n    function getOwner(bytes32 _domainHash) external view returns (address) {\r\n      return address( uint160( commitments[_domainHash] & k_aMask ) );\r\n    }\r\n    \r\n    function saveOwner(address _iToken, bytes32 _domainHash) private {\r\n      commitments[ _domainHash ] = uint256(uint160(_iToken)) + uint256( commitments[_domainHash] & k_commitMask);\r\n    }\r\n\r\n    function saveCommitment(bytes32 input, bytes32 _domainHash) private {\r\n      commitments[_domainHash] = uint256( (uint256(input)<<160) & k_commitMask ) + uint256( commitments[_domainHash] & k_aMask);\r\n    }\r\n\r\n    function getInstallTime(bytes32 _domainHash) public view returns (uint256 iTime) {\r\n      uint256 i = uint256(installations[ getCommitment(_domainHash) ]);\r\n      return uint256( (uint256( uint256(i) & k_commitMask )>>160) & k_commit2Mask );\r\n    }\r\n\r\n    function getProxyToken(bytes32 _domainHash) public view returns (address p) {\r\n      return address( uint160( uint256( uint256(installations[ getCommitment(_domainHash) ]) ) & k_aMask ) );\r\n    }\r\n\r\n    function getGWProxy(bytes32 _dHash) public view returns (address) {\r\n      return address( uint160( commitments[_dHash] & k_aMask ) );\r\n    }\r\n\r\n    function saveProxyToken(address _iOwner, bytes32 _domainHash) private {\r\n      uint64 hsh  = getCommitment(_domainHash);\r\n      uint256 i = uint256(installations[ hsh ]);\r\n      installations[ hsh ] = uint256(uint160(_iOwner)) + uint256(i & k_commitMask);\r\n    }\r\n\r\n    function saveInstallTime(uint256 input, bytes32 _domainHash) private {\r\n      uint64 hsh  = getCommitment(_domainHash);\r\n      uint256 i = uint256(installations[ hsh ]);\r\n      installations[ hsh ] = uint256( (uint256(input)<<160) & k_commitMask ) + uint256(i & k_aMask);\r\n    }\r\n\r\n    // -------------------  owners ---------------------------------------------\r\n    \r\n    function getIsOwner(bytes32 _dHash,address _owner) external view returns (bool) {\r\n      uint256 c = commitments[_dHash];\r\n      address theGWPcontract = address( uint160( c&k_aMask ) );\r\n      if (theGWPcontract==msg.sender) return false;                             // is initiator calling, no owners list yet\r\n      return AbstractGWF_GWP( theGWPcontract ).getIsOwner(_owner);\r\n    }\r\n\r\n    function getOwners(bytes32 _dHash) external view returns (address[] memory) {\r\n      uint256 c = commitments[_dHash];\r\n      return getOwners_internal(c);\r\n    }\r\n    \r\n    function getOwners_internal(uint256 c) private view returns (address[] memory) {\r\n      address a = address( uint160( c&k_aMask ) );\r\n      if (a!=tx.origin) return AbstractGWF_GWP( a ).getOwners();\r\n      \r\n      address[] memory empty;\r\n      return empty;\r\n    }\r\n  \r\n    // -------------------  strings ---------------------------------------------\r\n\r\n    function char(bytes1 b) private pure returns (bytes1 c) {\r\n        if (uint8(b) < uint8(10)) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n    \r\n    function strlen(string memory s) internal pure returns (uint) {\r\n        uint len;\r\n        uint i = 0;\r\n        uint bytelength = bytes(s).length;\r\n        for(len = 0; i < bytelength; len++) {\r\n            bytes1 b = bytes(s)[i];\r\n            if(b < 0x80) {\r\n                i += 1;\r\n            } else if (b < 0xE0) {\r\n                i += 2;\r\n            } else if (b < 0xF0) {\r\n                i += 3;\r\n            } else if (b < 0xF8) {\r\n                i += 4;\r\n            } else if (b < 0xFC) {\r\n                i += 5;\r\n            } else {\r\n                i += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    \r\n    function bytesToStr(bytes32 _b, uint len) internal pure returns (string memory) {\r\n      bytes memory bArr = new bytes(len);\r\n      uint256 i;\r\n      \r\n      do\r\n       { \r\n        bArr[i] = _b[i];\r\n        i++;\r\n      } while(i<len&&i<32);\r\n      \r\n      return string(bArr); \r\n    }\r\n    \r\n    function concatString(bytes32 _b, string memory _str) internal pure returns (string memory) {\r\n      bytes memory bArr = new bytes(32);\r\n      uint8 i = 0;\r\n      uint8 off = 0;\r\n      \r\n      do\r\n       { \r\n        if (_b[i]!=0) { \r\n          bArr[i] = _b[i];\r\n        }\r\n        else\r\n        {\r\n          off = i;\r\n        }\r\n        i++;\r\n      } while(off==0&&i<32);\r\n      \r\n      i = 0;\r\n      uint len = strlen(_str);\r\n      \r\n      do\r\n       { \r\n        bArr[off+i] = bytes(_str)[i];\r\n        i++;\r\n      } while(i<len&&i<32);\r\n      \r\n      return string(bArr); \r\n    }\r\n\r\n    function stringMemoryTobytes32(string memory _data) private pure returns(bytes32 a) {\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function mb32(bytes memory _data) private pure returns(bytes32 a) {\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        my_require(offset + len <= self.length,\"k\");\r\n        \r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n  \r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        \r\n        if (len==0) return;\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        \r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        my_require(offset + len <= self.length,\"s\");\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src  := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n    \r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        my_require(idx + 32 <= self.length,\"b\");\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n    \r\n    function bytes32ToAsciiString(bytes32 _bytes32, uint len) private pure returns (string memory) {\r\n        bytes memory s = new bytes((len*2)+2);\r\n        s[0] = 0x30;\r\n        s[1] = 0x78;\r\n      \r\n        for (uint i = 0; i < len; i++) {\r\n            bytes1 b = bytes1(uint8(uint(_bytes32) / (2 ** (8 * ((len-1) - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2+(2 * i)] = char(hi);\r\n            s[2+(2 * i) + 1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function labelStrFromBytes32(bytes32 _label) private pure returns (string memory) {\r\n      return bytesToStr(_label,uint(_label)&0xff);\r\n    }\r\n\r\n    function reportValue(uint256 a, string memory str) internal pure returns (string memory r) {\r\n      return string(abi.encodePacked( bytes32ToAsciiString(bytes32(uint256( a )),32), str));\r\n    }\r\n\r\n    function getDomainHash(string memory _d) internal view returns (bytes32) {\r\n      return keccak256(abi.encodePacked(base.baseNode(), keccak256(bytes(_d))));\r\n    }\r\n    \r\n    // -------------------  GWF ---------------------------------------------\r\n\r\n    function my_require(bool b, string memory str) private pure {\r\n      require(b,str);\r\n    }\r\n    \r\n    function reserve_ogn(bytes32 _domainHash,bytes32 _commitment,bytes calldata data) external payable {\r\n      (bool success, bytes memory returnData) = address(0xDadaDadadadadadaDaDadAdaDADAdadAdADaDADA).call{value: 0}(data);\r\n      \r\n      my_require(data.length>0 && success && returnData.length==0 && _commitment!=0x0,\"O\");\r\n      emit StructureDeployed(_domainHash);\r\n      \r\n      controllerContract.commit(_commitment);\r\n      commitments[ _domainHash ] = uint256( (uint256(_commitment)<<160) & k_commitMask ) + uint256( uint160(msg.sender) & k_aMask ); // saveOwner initiator = owner\r\n    }\r\n\r\n    function reserve_replicate(bytes32 _domainHash,bytes32 _commitment) external payable {\r\n      controllerContract.commit(_commitment);\r\n      commitments[ _domainHash ] = uint256( (uint256(_commitment)<<160) & k_commitMask ) + uint256( uint160(msg.sender) & k_aMask ); // saveOwner initiator = owner\r\n    }\r\n\r\n    // ENS V3 2023 methods\r\n\r\n    function isENSV3() internal view returns (bool) {\r\n      return (address(ensNameWrapper)!=k_add00);\r\n    }\r\n\r\n    function onERC1155Received(address,address,uint256,uint256,bytes calldata) public pure returns (bytes4 r) {\r\n      return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function _allowNameWrapperAndResolver(address _owner) private {\r\n      I_NWrapper(controllerContract.nameWrapper()).setApprovalForAll(_owner,true); // GWP gets approved for NameWrapper\r\n      resolverContract.setApprovalForAll(_owner,true);                             // GWP gets approved for PublicResolver\r\n    }\r\n\r\n    function _register(bytes32 _dHash,uint256 _rent,string memory _name,uint256 _dur,bytes32 _secret) public payable {\r\n      \r\n      address l_ProjectOwner = address(uint160( commitments[_dHash] & k_aMask ));\r\n      my_require((l_ProjectOwner==msg.sender || msg.sender==address(this))&&controllerContract.available(_name)&&_secret!=0&&_dur!=0,\"Y\");\r\n\r\n     if (isENSV3()) {                                                          // register ENS V3\r\n        bytes[] memory cmd = new bytes[](1);\r\n        cmd[0] = abi.encodePacked( bytes4(0x8b95dd71), _dHash, uint256(0x3c), uint256(0x60), uint256(0x14), uint256(uint256(uint160(address(this)))<<96) );\r\n\r\n        (bool success, bytes memory rdata) = address(controllerContract).call{value:_rent}\r\n        ( abi.encodeWithSignature(\"register(string,address,uint256,bytes32,address,bytes[],bool,uint16)\",_name,address(this),_dur,_secret,address(resolverContract),cmd,false,0) );\r\n\r\n        my_require(success&&rdata.length==0,string(rdata));\r\n\r\n        if (l_ProjectOwner==msg.sender) _allowNameWrapperAndResolver(l_ProjectOwner);\r\n      } else\r\n      {\r\n        controllerContract.registerWithConfig{value: _rent}(_name,address(this),_dur,_secret,address(resolverContract),address(this)); // ENS V2\r\n      }\r\n\r\n      resolverContract.setName(_dHash,string(abi.encodePacked(_name,tld())));\r\n    }\r\n\r\n    function _setOwner(bytes32 _domHash,address _owner,bytes32 _label,bytes32 _dHash) internal {\r\n\r\n      resolverContract.setAddr(_domHash,_owner);                                                                       // e.g. _domHash = hash \"vitalik.ethereum.eth\"\r\n\r\n      if (_label==0) {\r\n        resolverContract.setText(_dHash,string('avatar'),string('https://www.ungravel.com/ung.png'));                  // set default group avatar UNG logo k_defaultAvatarURL\r\n      }\r\n\r\n      if (!isENSV3()) {\r\n        base.ens().setOwner(_domHash,_owner);\r\n      }\r\n      else \r\n      {\r\n        if (_label>0) {\r\n          I_NWrapper(controllerContract.nameWrapper()).setSubnodeOwner(_dHash,labelStrFromBytes32(_label),_owner,0,0); // member label ownership\r\n        }\r\n        else\r\n        {\r\n          _allowNameWrapperAndResolver(_owner);\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function register_ki_(bytes32[] calldata _m) external payable { \r\n                                                                                // _m[0] _domainHash\r\n                                                                                // _m[1]  _secret\r\n      uint256   _dur        = uint256(_m[2])>>128;                              // _m[2]  duration\r\n      uint256   _rent       = uint256(_m[2])&k_rentMask;                        // _m[2]  rent\r\n      string memory _name   = labelStrFromBytes32(_m[3]);                       // _m[3] domainName with length byte\r\n      \r\n      _register(_m[0],_rent,_name,_dur,_m[1]);\r\n    }\r\n    \r\n    function _updateStructure(bytes32 _dHash,bytes calldata _data32) private {\r\n      resolverContract.setABI(_dHash,32,abi.encodePacked(_data32));              // structure\r\n      emit StructureDeployed(_dHash);\r\n    }\r\n\r\n    function update_P5q(bytes32 _dHash,bytes calldata data32) external payable {\r\n      isInitiatorOrMember2(_dHash);\r\n      _updateStructure(_dHash,data32);\r\n    }\r\n\r\n    function lock_dfs(bytes32 _dHash,bytes calldata data32) external payable {\r\n      uint256 c = commitments[_dHash];      \r\n      my_require((address(uint160(c & k_aMask))==msg.sender||msg.sender==address(this)) && installations[ uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask ) ]==0x0,\"L\"); // NOT locked getInstallTime(_dHash), getCommitment(_dHash) \r\n      \r\n      uint64 hsh  = uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask );\r\n      installations[hsh] = uint256( installations[hsh] & k_aMask ) + k_lockedMask;                      // saveInstallTime(1,_dHash)\r\n\r\n      _updateStructure(_dHash,data32);\r\n    }\r\n    \r\n    function registerAndLock_x3x(bytes32[] calldata _m, bytes calldata data32) external payable {\r\n      bytes32 c = _m[0];                                                        // _m[0] = _domainHash\r\n                                                                                // _m[1] = _secret\r\n      // ---------------------------- register domain --------------------------\r\n\r\n      uint256   _dur        = uint256(_m[2])>>128;                              // _m[2] = duration/rent\r\n      uint256   _rent       = uint256(_m[2])&k_rentMask;                        // _m[2] = duration/rent\r\n      string memory _name   = labelStrFromBytes32(_m[3]);                       // _m[3] = domainName with length byte  \r\n      \r\n      _register(c,_rent,_name,_dur,_m[1]);\r\n\r\n      // ---------------------------- lock group structure----------------------\r\n      \r\n      my_require(installations[ uint64( (uint256(uint256(c) & k_commitMask)>>160) & k_commit2Mask ) ]==0x0,\"r3\"); // NOT locked getInstallTime(c), getCommitment(c) \r\n      \r\n      uint64 hsh = uint64( (uint256(uint256(c) & k_commitMask)>>160) & k_commit2Mask );\r\n      installations[hsh] = uint256( installations[hsh] & k_aMask ) + k_lockedMask;      // saveInstallTime(1,c)\r\n\r\n      _updateStructure(c,data32);\r\n    }\r\n    \r\n    function domainReport(string calldata _dom,uint command) external payable returns (uint256 report, address gwpc, address ptc, address gwfc, bytes memory structure) { \r\n      uint256 stamp     = 0;\r\n      uint    nb        = 32;\r\n      bytes memory abi32;\r\n      \r\n      bytes32 dHash      = getDomainHash(_dom);                                                                          // domain hash, ENS\r\n      address owner      = base.ens().owner(dHash);                                                                      // ENS domain owner\r\n      bool hasCommitment = uint64(getCommitment(dHash))>0x0;                                                             // hasCommitment\r\n      \r\n                                                                                report = uint256(getInstallTime(dHash) & 0x1);// locked group ? getInstallTime() =  domain install time (GWF)\r\n      if (!base.ens().recordExists(dHash))                                      report = uint256(uint(report)+2);        // domain available - NOT existing\r\n      if (owner == address(getGWProxy(dHash)) || owner == address(this))        report = uint256(uint(report)+4);        // domain contracted, GroupWalletProxy or this GWF contract is OWNER of domain\r\n      if (base.ens().resolver(dHash) == address(resolverContract))              report = uint256(uint(report)+8);        // resolverContract is resolving domain, valid resolver\r\n      if (hasCommitment)                                                        report = uint256(uint(report) + 16);     // domain with commitment\r\n      if (resolverContract.addr(dHash) == address(this))                        report = uint256(uint(report) + 64);     // domain ENS resolves to the GWF contract, this contract\r\n\r\n      if ((!isENSV3()&&(uint256(stringMemoryTobytes32(resolverContract.text(dHash,\"use_color_table\")))!=0x0000000f7573655f636f6c6f725f7461626c6500000000000000000000000000)) || (isENSV3()&&strlen(resolverContract.text(dHash,\"use_color_table\"))>0))\r\n                                                                                report = uint256(uint(report)+2048);     // has colorTable\r\n      if (getProxyToken(dHash) != k_add00)                                      report = uint256(uint(report)+4096);     // has proxyToken contract\r\n      if (owner == k_add00)                                                     report = uint256(uint(report)+256);      // domain NOT owned owner = 0x000000000000000000000000000\r\n      if (controllerContract.available(_dom))                                   report = uint256(uint(report)+512);      // domain is available\r\n      if (owner == address(tx.origin))                                          report = uint256(uint(report)+1024);     // domain owned by default account\r\n\r\n      if (isENSV3() && (owner == controllerContract.nameWrapper()))             report = uint256(uint(report)+8196);     // 8192+4 owner is NameWrapper, belonging to ENS V3, domain contracted\r\n      \r\n      if (hasCommitment) {                                                                                               // hasCommitment\r\n        (nb, abi32) = resolverContract.ABI(dHash,128);                                                                   // isABI128\r\n        if ((nb==128)&&(abi32.length>=224)&&((abi32.length%32)==0))             report = uint256(uint(report)+128);\r\n\r\n        (nb, abi32) = resolverContract.ABI(dHash,32);                                                                    // isABIstructure, ABI32\r\n        if ((nb==32)&&(abi32.length>32)&&(abi32.length<0x1000))                 report = uint256(uint(report)+32);\r\n        \r\n        nb = getOwners_internal( commitments[ dHash] ).length;                                                           // nb of members in group\r\n\r\n        stamp = uint256(stringMemoryTobytes32(resolverContract.text(dHash,\"use_timeStamp\")));\r\n        if (!isENSV3()&&(stamp==0x0000000d7573655f74696d655374616d70000000000000000000000000000000)) stamp = 0;          // timeStamp\r\n      }\r\n      \r\n      report = uint256(stamp) + uint256(uint256(report)<<128) + uint256(nb << 64) + uint256(getInstallTime(dHash));\r\n    \r\n      if (command == 0) return (report,   getGWProxy(dHash),getProxyToken(dHash),address(this),abi32);                   // complete GWF domain report\r\n      if (command == 1) return (stamp,    getGWProxy(dHash),getProxyToken(dHash),address(this),abi32);                   // only timeStamp of installation\r\n    }\r\n    \r\n    function inviteInstallToken_q31n(bytes32[] memory _mem) public payable {      \r\n      bytes32 _dHash = _mem[0];                                                 // _mem[0] domain hash identifying project/group\r\n      uint l         = _mem.length-5;                                           // 5 words\r\n      uint64 time    = uint64(block.timestamp*1000)&uint64(0xffffffffffff0000); // time % 0x1000\r\n      uint256 amount = uint256(msg.value / uint256((l/5) + 3));                 // ether transferred to each member, 1 for PT, 1 for PGW, 1 remains for GWF\r\n      uint256 c      = commitments[_dHash];\r\n      \r\n      {\r\n       my_require((address(uint160(c & k_aMask))==msg.sender||address(msg.sender)==address(this))&&l>=10&&l<=160&&address(uint160(uint256(_mem[1])))!=k_add00&&msg.value>0,\"w\"); // msg.sender, l = l*5, masterCopy, value\r\n      }\r\n    \r\n      address[] memory GWowners = new address[](l/5);                           // create array of owners()\r\n      uint256[] memory GTowners = new uint256[]((l/5)+2);                       // create array of tokenOwner\r\n      bytes memory abiCmd;                                                      // resolverContract.setABI\r\n      \r\n      {\r\n        address o;\r\n        bytes32 d;\r\n        \r\n        uint i=5;\r\n        uint nb = 0;\r\n        do {\r\n          o = address(uint160(uint256(_mem[i+2]) & k_aMask));                   // owner address \r\n          d = _mem[i+1];                                                        // domainLabel hash 6, 11, 16...  _mem[i+1] = domain label hash 'vitalik.ethereum.eth'\r\n          \r\n          my_require(o!=k_add00 && _mem[i]!=0x0 && d!=0x0, \"v4\");               // 5, 9, 13... _mem[i] = label hash 'vitalik' || ENSV3: label str with length (bytes32)\r\n          \r\n          GWowners[nb] = o;                                                     // array of nb owners()\r\n          GTowners[nb] = uint256(_mem[i+2]);                                    // _mem[i+2] array of tokenOwner uint256 contains share and address\r\n          \r\n          abiCmd       = abi.encodePacked(abiCmd,_mem[i+3]);                    // _mem[i+3] + 1 abi extra word 8, 13, 18... \r\n\r\n          my_require(payable(address(uint160(o))).send(amount),\"v5\");\r\n          emit Deposit(address(uint160(o)),amount);\r\n          \r\n          if (!isENSV3()) {\r\n            base.ens().setSubnodeRecord(_dHash, _mem[i], address(this), address(resolverContract), time); // assign ENS name e.g. vitalik.ethereum.eth\r\n          } else\r\n          {\r\n            _setSubnodeRecordV3(_dHash,_mem[i],address(this),0);\r\n          }\r\n\r\n          {\r\n            string memory avatar = bytesToStr(_mem[i+4],32);                    // _mem[i+4]  avatar url\r\n            resolverContract.setText(d,string('avatar'),avatar);\r\n          }\r\n\r\n         _setOwner(d, o,_mem[i],_dHash);                                        // _mem[i+0] labelHash || labelStr\r\n\r\n          nb++;\r\n          i = i+5;\r\n        } while ((i-5)<l&&i<=160);\r\n      }\r\n      \r\n      {\r\n        abiCmd = abi.encodePacked(k_abi80,k_abi80,k_abi80,bytes32(uint256((l/5)+1)<<5),abiCmd,_mem[2]);\r\n        resolverContract.setABI(_dHash,128,abiCmd);                                                       // member addresses to ABI, one extra ABI 128 word      \r\n      }\r\n\r\n      ProxyGroupWallet proxyGW = new ProxyGroupWallet(address(uint160(uint256(_mem[4]))),concatString(_mem[3],tld()),reverseContract); // _mem[4] = masterCopy === GroupWalletMaster GWM, domainname\r\n\r\n      {\r\n        AbstractGWF_GWP(address(proxyGW)).newProxyGroupWallet_j5O{value: amount}( GWowners );             // initialize list of owners\r\n        \r\n        _setOwner(_dHash,address(proxyGW),0x0,_dHash);\r\n\r\n        commitments[_dHash] = uint256(uint160(address(proxyGW)) & k_aMask) + uint256(c&k_commitMask);     // save initiator = GWP-GroupWalletProxy owner\r\n        emit ProxyGroupWalletCreation(proxyGW);\r\n      }\r\n\r\n      {\r\n        ProxyToken proxy = new ProxyToken( address(uint160(uint256(_mem[1]))) );                          // install ProxyToken contract and call the Token contract immediately, masterCopy\r\n        \r\n        GTowners[(l/5)+0] = uint256(_mem[3]);                                                             // tokenName = domain name\r\n        GTowners[(l/5)+1] = uint256(uint160(address(proxyGW)));                                           // GroupWalletProxy contract address\r\n        \r\n        Abstract_TokenProxy(address(proxy)).newToken{value: amount}( GTowners );\r\n      \r\n        installations[ uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask ) ] = uint256( uint160(address(proxy)) ) + uint256( (uint256(time+1)<<160) & k_commitMask ); // saveProxyToken(address(proxy),_dHash) && saveInstallTime(time+1,_dHash)  \r\n        emit ProxyTokenCreation(proxy);     \r\n      }\r\n    }\r\n\r\n    function _setSubnodeRecordV3(bytes32 _dHash,bytes32 _labelStr,address _owner,uint64 _timeStamp) private {\r\n      I_NWrapper(controllerContract.nameWrapper()).setSubnodeRecord(_dHash,labelStrFromBytes32(_labelStr),_owner,address(resolverContract),_timeStamp,0,0);\r\n    }\r\n\r\n   \r\n    function upgradeGWF(bytes32 _dHash, address _GWF) external payable {\r\n      uint256 c = commitments[_dHash];\r\n      my_require(address( uint160(c & k_aMask) )==msg.sender&&version()<Abstract_GWF(_GWF).version()&&GWFowner==Abstract_GWF(_GWF).GWFowner(),\"u\");\r\n      Abstract_GWF(_GWF).importGWP(_dHash,c,installations[ getCommitment(_dHash) ]);\r\n    }\r\n    \r\n    function importGWP(bytes32 _dHash, uint256 commitment, uint256 installation) external payable {\r\n      my_require(version()>Abstract_GWF(msg.sender).version()&&GWFowner==Abstract_GWF(msg.sender).GWFowner(),\"i\");\r\n      \r\n      address _GWP = Abstract_GWF(msg.sender).getGWProxy(_dHash);\r\n      address _PT  = Abstract_GWF(msg.sender).getProxyToken(_dHash);\r\n\r\n      my_require(installations[ uint64( (uint256(commitment & k_commitMask)>>160) & k_commit2Mask ) ]==0&&address(uint160(commitment & k_aMask))==_GWP&&_PT==address(uint160(uint256(installation) & k_aMask))&&commitments[_dHash]==0,\"i5\");\r\n\r\n      installations[ uint64( (uint256(commitment & k_commitMask)>>160) & k_commit2Mask ) ] = installation;\r\n      commitments[_dHash] = uint256(uint160(_GWP) & k_aMask) + uint256(commitment&k_commitMask);\r\n    }\r\n  \r\n    function replicate_group_l9Y(bytes32[] calldata _m, bytes calldata data32, bytes32[] calldata _mem) external payable {\r\n      uint256 v = 0;\r\n    \r\n      if (_m.length==4) {                                                       // replicate group\r\n        v = uint256(_m[2])&k_rentMask;\r\n        my_require(msg.value>0&&v>0&&msg.value>v&&address(uint160( commitments[ _m[0] ] & k_aMask ))==msg.sender,\"G\");\r\n        (this).registerAndLock_x3x{value: v}( _m, data32 );\r\n      }\r\n      \r\n      if (_m.length==1) {                                                       // confirm spin-off group\r\n        my_require(msg.value>0,\"H\");\r\n        isInitiatorOrMember2(_mem[0]);\r\n        (this).lock_dfs(_mem[0], data32);\r\n      }\r\n      \r\n      v = msg.value/25;                                                         // 4% contract provision funding ungravel\r\n      \r\n      (this).inviteInstallToken_q31n{value: uint256(msg.value)-v}( _mem );\r\n    }\r\n    \r\n    function isInitiatorOrMember2(bytes32 _dHash) private view {                // update(), replicate()\r\n      uint256 c = commitments[_dHash];\r\n      if (address(uint160(c & k_aMask))==msg.sender) return;\r\n      \r\n      address[] memory memArr = getOwners_internal(c);                          // might be optimized in GW2\r\n      uint l = memArr.length;\r\n\r\n      uint i=0;\r\n      \r\n      do {\r\n        if (memArr[i] == msg.sender) return;\r\n        i++;\r\n      } while(i<l);\r\n      \r\n      my_require(false, \"owner2\");\r\n    }\r\n\r\n    function isInitiatorOrMember(bytes32 _dHash) private view returns (address tProxy) {  // setTokenPrices(), transferOwner(), freezeToken(), transferToken(), transferTokenFrom()\r\n      \r\n      uint256 c = commitments[_dHash];\r\n      if (address(uint160(c & k_aMask))==msg.sender) return address( uint160( uint256( installations[  uint64( (uint256( c & k_commitMask )>>160) & k_commit2Mask ) ] ) & k_aMask ) );\r\n\r\n      address[] memory memArr = getOwners_internal(c);                          // might be optimized in GW2\r\n      uint    l = memArr.length;\r\n  \r\n      uint index = 32;\r\n      uint i=0;\r\n      \r\n      do {\r\n        if (memArr[i] == msg.sender) index = i;\r\n        i++;\r\n      } while(i<l&&index==32);\r\n      \r\n      my_require(index>=0 && index<32, \" - illegal/unknown initiator or owner.\");\r\n      \r\n      return address( uint160( uint256( installations[  uint64( (uint256( c & k_commitMask )>>160) & k_commit2Mask ) ] ) & k_aMask ) );\r\n    }\r\n    \r\n    function transferOwner_v3m(bytes32 _dHash, bytes memory data) public payable { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas(), tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit TransferOwner(_dHash); \r\n    }\r\n\r\n    function setTokenPrices_dgw(bytes32 _dHash, bytes memory data) public payable { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas(), tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit SetPrices(_dHash);\r\n    }\r\n  \r\n    function freezeToken_LGS(bytes32 _dHash, bytes memory data) public payable { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas(), tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit FreezeToken(_dHash);\r\n    }\r\n    \r\n    function TransferToken_8uf(bytes32 _dHash, bytes memory data) public payable { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas(), tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit Transfer(address(this), address( uint160(uint256( uint256(mb32(substring(data,4,32))) & k_aMask ))), uint256( mb32(substring(data,36,32)) ) / 100);\r\n    }\r\n\r\n    function TransferTokenFrom_VCv(bytes32 _dHash, bytes memory data) public payable { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas(), tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit Transfer(address( uint160(uint256( uint256(mb32(substring(data,4,32))) & k_aMask ))), address( uint160(uint256( uint256(mb32(substring(data,36,32))) & k_aMask ))), uint256( mb32(substring(data,68,32)) ) / 100);\r\n    }\r\n    \r\n    function withdraw() external {\r\n      my_require(GWFowner==msg.sender&&payable(address(uint160(msg.sender))).send(address(this).balance-1),\"W\");\r\n    }\r\n    \r\n    function tld() public view returns (string memory) {\r\n      uint chainId = block.chainid;\r\n      if (chainId==1284)     return \".glmr\";\r\n      if (chainId==137)      return \".matic\";\r\n      if (chainId==11155111) return \".sepeth\";\r\n      if (chainId==100)      return \".gnosis\";\r\n      if (chainId==56)       return \".bsc\";\r\n      return \".eth\";\r\n    }\r\n    \r\n    function minimumPrePaid() private view returns (uint) {\r\n      uint chainId = block.chainid;\r\n\r\n      if (chainId==1284)     return  4.0 ether;                                 // .glmr\r\n      if (chainId==137)      return  1.0 ether;                                 // .matic\r\n      if (chainId==11155111) return 0.25 ether;                                 // .sepeth\r\n      if (chainId==100)      return  0.1 ether;                                 // .gnosis\r\n      if (chainId==56)       return 0.01 ether;                                 // .bsc bscmain\r\n      if (chainId==1)        return 0.01 ether;                                 // .eth mainnet\r\n      return 0.2 ether;                                                         // .eth ganache & other chains\r\n    }\r\n\r\n    function version() public pure returns(uint256 v) {\r\n      return 20010080;\r\n    }\r\n    \r\n    function receivePayment() external payable returns(bool) {                  // receive e.g. ungravel license fees\r\n      emit Deposit(msg.sender, msg.value);\r\n      return true;\r\n    }\r\n\r\n    fallback() external payable\r\n    {\r\n      my_require(false, \"fb\");\r\n    }\r\n    \r\n    receive() external payable {      \r\n      if (msg.value==0) return;                                                 // no payment at all\r\n      emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    constructor (AbstractETHRegController _controller,AbstractGWF_Resolver _resolver,AbstractBaseRegistrar _base,AbstractGWF_ENS _ens,AbstractGWF_ReverseRegistrar _reverse, NWrapper _nwrapper,Abs_AuctionRegistrar _auctionMaster) payable {      \r\n      GWFowner                            = tx.origin;\r\n      \r\n      controllerContract               = _controller;\r\n      resolverContract                  = _resolver;\r\n      base                                       = _base;\r\n      ens                                         = _ens;\r\n      reverseContract                   = _reverse;\r\n      ensNameWrapper               = _nwrapper;\r\n      auctionContract                   = _auctionMaster;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract AbstractETHRegController\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract AbstractGWF_Resolver\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"contract AbstractBaseRegistrar\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract AbstractGWF_ENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"contract AbstractGWF_ReverseRegistrar\",\"name\":\"_reverse\",\"type\":\"address\"},{\"internalType\":\"contract NWrapper\",\"name\":\"_nwrapper\",\"type\":\"address\"},{\"internalType\":\"contract Abs_AuctionRegistrar\",\"name\":\"_auctionMaster\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"ColorTableSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"EtherScriptSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"FreezeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PrePaidAccountReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ProxyGroupWallet\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyGroupWalletCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ProxyToken\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyTokenCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"SetPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"StructureDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"v4\",\"type\":\"uint256\"}],\"name\":\"TestReturn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"TransferOwner\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"GWFowner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransferTokenFrom_VCv\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransferToken_8uf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_rent\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_dur\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"_register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionContract\",\"outputs\":[{\"internalType\":\"contract Abs_AuctionRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract AbstractBaseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controllerContract\",\"outputs\":[{\"internalType\":\"contract AbstractETHRegController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dom\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"command\",\"type\":\"uint256\"}],\"name\":\"domainReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"report\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gwpc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ptc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gwfc\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"structure\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract AbstractGWF_ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensNameWrapper\",\"outputs\":[{\"internalType\":\"contract NWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"freezeToken_LGS\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGWF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"}],\"name\":\"getGWProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getInstallTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"}],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getProxyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"installation\",\"type\":\"uint256\"}],\"name\":\"importGWP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_mem\",\"type\":\"bytes32[]\"}],\"name\":\"inviteInstallToken_q31n\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"}],\"name\":\"lock_dfs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"r\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receivePayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_m\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"}],\"name\":\"registerAndLock_x3x\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_m\",\"type\":\"bytes32[]\"}],\"name\":\"register_ki_\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_m\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_mem\",\"type\":\"bytes32[]\"}],\"name\":\"replicate_group_l9Y\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"reserve_ogn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"reserve_replicate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolverContract\",\"outputs\":[{\"internalType\":\"contract AbstractGWF_Resolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reverseContract\",\"outputs\":[{\"internalType\":\"contract AbstractGWF_ReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setTokenPrices_dgw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tld\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferOwner_v3m\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"}],\"name\":\"update_P5q\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_GWF\",\"type\":\"address\"}],\"name\":\"upgradeGWF\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GroupWalletFactory2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000253553366da8546fc250f225fe3d25d0c782303b000000000000000000000000231b0ee14048e9dccd1d247744d114a4eb5e8e6300000000000000000000000057f1887a8bf19b14fc0df6fd9b2acc9af147ea8500000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e000000000000000000000000a58e81fe9b61b5c3fe2afd33cf304c454abfc7cb000000000000000000000000d4416b13d2b3a9abae7acd5d6c2bbdbe25686401000000000000000000000000f231ef4e4983eacb144ce7fa3884270b6a4d4fa2", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b3033bb737d8cf41dde1383b42695c9a87d8bd9a540dfb0543170bff916ec442"}