{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.23;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IJoin {\r\n    function join(address usr, uint wad) external;\r\n\r\n    function exit(address usr, uint wad) external;\r\n}\r\n\r\ninterface ISafeEngine {\r\n    struct CollateralType {\r\n        // Total debt issued for this specific collateral type\r\n        uint256 debtAmount; // [wad]\r\n        // Accumulator for interest accrued on this collateral type\r\n        uint256 accumulatedRate; // [ray]\r\n        // Floor price at which a SAFE is allowed to generate debt\r\n        uint256 safetyPrice; // [ray]\r\n        // Maximum amount of debt that can be generated with this collateral type\r\n        uint256 debtCeiling; // [rad]\r\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\r\n        uint256 debtFloor; // [rad]\r\n        // Price at which a SAFE gets liquidated\r\n        uint256 liquidationPrice; // [ray]\r\n    }\r\n\r\n    struct SAFE {\r\n        // Total amount of collateral locked in a SAFE\r\n        uint256 lockedCollateral; // [wad]\r\n        // Total amount of debt generated by a SAFE\r\n        uint256 generatedDebt; // [wad]\r\n    }\r\n\r\n    function modifySAFECollateralization(\r\n        bytes32 collateralType,\r\n        address safe,\r\n        address collateralSource,\r\n        address debtDestination,\r\n        int256 deltaCollateral,\r\n        int256 deltaDebt\r\n    ) external;\r\n\r\n    function approveSAFEModification(address account) external;\r\n\r\n    function safes(bytes32 id, address usr) external view returns (SAFE memory);\r\n\r\n    function collateralTypes(\r\n        bytes32 id\r\n    ) external view returns (CollateralType memory);\r\n\r\n    function tokenCollateral(\r\n        bytes32 id,\r\n        address usr\r\n    ) external view returns (uint256);\r\n\r\n    function coinBalance(\r\n        address usr\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IOracleRelayer {\r\n    function updateCollateralPrice(bytes32 collateralType) external;\r\n\r\n    function redemptionPrice() external returns (uint256);\r\n}\r\n\r\ninterface ILiquidation {\r\n    function liquidateSAFE(\r\n        bytes32 collateralType,\r\n        address safe\r\n    ) external returns (uint256 auctionId);\r\n}\r\n\r\ninterface IAuctionHouse {\r\n    function buyCollateral(uint256 id, uint256 wad) external;\r\n\r\n    function getCollateralBought(\r\n        uint256 id,\r\n        uint256 wad\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ninterface IRouterV2 {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IRouterV3 {\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n}\r\n\r\ninterface IERC3156FlashBorrower {\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IFlashLoanProvider {\r\n    function flashLoan(\r\n        IERC3156FlashBorrower receiver,\r\n        address token,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Tritium is IERC3156FlashBorrower {\r\n    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IERC20 ocean = IERC20(0x967da4048cD07aB37855c090aAF366e4ce1b9F48);\r\n    IJoin colJoin = IJoin(0x13288BD148160f76B37Bea93861cA61BAea120D1);\r\n    IJoin coinJoin = IJoin(0x99665a5252c15cA3E24fcEbAb56d0721fB9D1158);\r\n    ISafeEngine safeEngine =\r\n        ISafeEngine(0x1E6AfA340851D60E75be38494813C09b3356a009);\r\n    ILiquidation liquidation =\r\n        ILiquidation(0x3eFbB71321dB24810E8361a42218dc6e4225e981);\r\n    IAuctionHouse auction =\r\n        IAuctionHouse(0x1fe1a1313B4974909CbBC11b208B9062e0C6666A);\r\n    IERC20 h2o = IERC20(0x0642026E7f0B6cCaC5925b4E7Fa61384250e1701);\r\n    IOracleRelayer oracle =\r\n        IOracleRelayer(0x173d5e2395D0C20d5A3d35d5b7Ec71618211F353);\r\n    IRouterV2 routerV2 = IRouterV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IRouterV3 routerV3 = IRouterV3(0xE592427A0AEce92De3Edee1F18E0157C05861564);\r\n    IFlashLoanProvider flashLoan = IFlashLoanProvider(0x4EAF187ad4cE325bF6C84070b51c2f7224A51321);\r\n    bytes32 colId =\r\n        0x4f4345414e2d4100000000000000000000000000000000000000000000000000;\r\n    address owner;\r\n    //uint public colOut;\r\n    //uint public coinIn;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function _getCoin(uint wethToUsdcToH2o, uint ocToH2o) internal returns (uint256) {\r\n        //have ether\r\n        weth.approve(address(routerV3), wethToUsdcToH2o);\r\n        bytes memory path =\r\n            abi.encodePacked(weth, uint24(500), usdc, uint24(500), h2o);\r\n        IRouterV3.ExactInputParams memory params = IRouterV3\r\n            .ExactInputParams({\r\n            path: path,\r\n            recipient: address(this),\r\n            deadline: block.timestamp,\r\n            amountIn: wethToUsdcToH2o,\r\n            amountOutMinimum: 0\r\n        });\r\n\r\n        uint h2oOut0 = routerV3.exactInput(params);\r\n\r\n        address[] memory pathV2 = new address[](2);\r\n        pathV2[0] = address(weth);\r\n        pathV2[1] = address(ocean);\r\n\r\n        weth.approve(address(routerV2), weth.balanceOf(address(this)));\r\n        uint256[] memory amountsOut = routerV2.swapTokensForExactTokens(\r\n            ocToH2o, \r\n            weth.balanceOf(address(this)),\r\n            pathV2,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint oceanOut = amountsOut[amountsOut.length-1];\r\n\r\n        ocean.approve(address(routerV3), oceanOut);\r\n        path =\r\n            abi.encodePacked(ocean, uint24(3000), h2o);\r\n        params = IRouterV3\r\n            .ExactInputParams({\r\n            path: path,\r\n            recipient: address(this),\r\n            deadline: block.timestamp,\r\n            amountIn: ocToH2o,\r\n            amountOutMinimum: 0\r\n        });\r\n        uint h2oOut1 = routerV3.exactInput(params);\r\n\r\n\r\n        return h2oOut0 + h2oOut1;\r\n    }\r\n\r\n    function _toWeth() internal returns (uint256) {\r\n        ocean.approve(address(routerV2), ocean.balanceOf(address(this)));\r\n        address[] memory pathV2 = new address[](2);\r\n        pathV2[0] = address(ocean);\r\n        pathV2[1] = address(weth);\r\n\r\n        uint256[] memory amountsOut = routerV2.swapExactTokensForTokens(\r\n            ocean.balanceOf(address(this)), \r\n            0,\r\n            pathV2,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        return amountsOut[0];\r\n    }\r\n\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32) {\r\n        fee;\r\n        require(msg.sender == address(flashLoan),\"not flashloan\");\r\n        require(initiator == address(this), \"not this\");\r\n\r\n        (uint wethToUsdcToH2o, uint ocToH2o, address liquidTarget) = abi.decode(data, (uint256, uint256, address));\r\n\r\n        uint coinOut = _getCoin(wethToUsdcToH2o, ocToH2o);\r\n\r\n        safeEngine.approveSAFEModification(address(coinJoin));\r\n        safeEngine.approveSAFEModification(address(colJoin));\r\n        safeEngine.approveSAFEModification(address(auction));\r\n\r\n        h2o.approve(address(coinJoin), coinOut);\r\n        coinJoin.join(address(this), coinOut);\r\n\r\n        uint aucId = liquidation.liquidateSAFE(colId, liquidTarget);\r\n\r\n        //(colOut, coinIn) = auction.getCollateralBought(aucId, coinOut);\r\n\r\n        auction.buyCollateral(aucId, coinOut);\r\n        colJoin.exit(address(this), safeEngine.tokenCollateral(colId, address(this)));\r\n\r\n        _toWeth();\r\n\r\n        IERC20(token).approve(address(flashLoan), amount);\r\n        return keccak256('ERC3156FlashBorrower.onFlashLoan');\r\n    }\r\n\r\n    function radiate(\r\n        bool updatePrice, \r\n        uint flashAmount, \r\n        uint wethToUsdcToH2o, \r\n        uint ocToH2o,\r\n        uint minOut,\r\n        address target\r\n    ) external {\r\n        require(owner == msg.sender, \"not owner\");\r\n\r\n        if (updatePrice) {\r\n            oracle.updateCollateralPrice(colId);\r\n        }\r\n\r\n        flashLoan.flashLoan(this, address(weth), flashAmount, abi.encode(wethToUsdcToH2o, ocToH2o, target));\r\n        \r\n        uint out = weth.balanceOf(address(this));\r\n        require(out >= minOut, \"Not enough out\");\r\n        weth.transfer(msg.sender, weth.balanceOf(address(this)));\r\n    }\r\n\r\n    function rescue(IERC20 token) external {\r\n        require(owner == msg.sender, \"not owner\");\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function rescueCall(address target, bytes calldata callArg) external {\r\n        require(owner == msg.sender, \"not owner\");\r\n\r\n        (bool success, ) = target.call(callArg);\r\n        require(success, \"call failed\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"updatePrice\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"flashAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethToUsdcToH2o\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ocToH2o\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"radiate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callArg\",\"type\":\"bytes\"}],\"name\":\"rescueCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Tritium", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a94fc68e9c5b2f9a891f8aa13ea4ed3f464c8f4a82362d331b8b7b542179e85b"}