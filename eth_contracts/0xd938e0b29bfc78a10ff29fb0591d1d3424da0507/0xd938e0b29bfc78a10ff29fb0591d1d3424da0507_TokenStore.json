{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PythStructs.sol\\\";\\nimport \\\"./IPythEvents.sol\\\";\\n\\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\\n/// @author Pyth Data Association\\ninterface IPyth is IPythEvents {\\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\\n\\n    /// @notice Returns the price and confidence interval.\\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\\n    /// @dev Reverts if the EMA price is not available.\\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price of a price feed without any sanity checks.\\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\\n    /// However, if the price is not recent this function returns the latest available price.\\n    ///\\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\\n    /// the returned price is recent or useful for any particular application.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\\n    /// of the current time.\\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Update price feeds with given update messages.\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    /// Prices will be updated if they are more recent than the current stored prices.\\n    /// The call will succeed even if the update is not the most recent.\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\\n\\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\\n    ///\\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\\n    function updatePriceFeedsIfNecessary(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64[] calldata publishTimes\\n    ) external payable;\\n\\n    /// @notice Returns the required fee to update an array of price updates.\\n    /// @param updateData Array of price update data.\\n    /// @return feeAmount The required fee in Wei.\\n    function getUpdateFee(\\n        bytes[] calldata updateData\\n    ) external view returns (uint feeAmount);\\n\\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\\n    /// within `minPublishTime` and `maxPublishTime`.\\n    ///\\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdates(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n\\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\\n    /// this method will return the first update. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdatesUnique(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n}\\n\"\r\n    },\r\n    \"@pythnetwork/pyth-sdk-solidity/IPythEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @title IPythEvents contains the events that Pyth contract emits.\\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\\ninterface IPythEvents {\\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\\n    /// @param id The Pyth Price Feed ID.\\n    /// @param publishTime Publish time of the given price update.\\n    /// @param price Price of the given price update.\\n    /// @param conf Confidence interval of the given price update.\\n    event PriceFeedUpdate(\\n        bytes32 indexed id,\\n        uint64 publishTime,\\n        int64 price,\\n        uint64 conf\\n    );\\n}\\n\"\r\n    },\r\n    \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ncontract PythStructs {\\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\\n    //\\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\\n    // Both the price and confidence are stored in a fixed-point numeric representation,\\n    // `x * (10^expo)`, where `expo` is the exponent.\\n    //\\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\\n    // to how this price safely.\\n    struct Price {\\n        // Price\\n        int64 price;\\n        // Confidence interval around the price\\n        uint64 conf;\\n        // Price exponent\\n        int32 expo;\\n        // Unix timestamp describing when the price was published\\n        uint publishTime;\\n    }\\n\\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\\n    struct PriceFeed {\\n        // The price ID.\\n        bytes32 id;\\n        // Latest available price\\n        Price price;\\n        // Latest available exponentially-weighted moving average price\\n        Price emaPrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NONE\\n\\npragma solidity ^0.8.21;\\n\\ninterface ITokenStore {\\n  enum Option {\\n    Short,\\n    Long\\n  }\\n  enum Status {\\n    None,\\n    Opened,\\n    Closed\\n  }\\n\\n  struct TokenConfig {\\n    bool defined;\\n    bytes32 pythId;\\n    uint256 total;\\n    uint256 threshold;\\n  }\\n\\n  struct Stable {\\n    bool defined;\\n    uint256 total;\\n  }\\n\\n  struct Milestone {\\n    bool defined;\\n    Status state;\\n    uint256 sPrice;\\n    uint256 lPrice;\\n    uint256 sold;\\n    uint256 supply;\\n  }\\n\\n  struct Representative {\\n    bool defined;\\n    bool enabled;\\n    uint256 firstRepRate;\\n    uint256 secondRepRate;\\n  }\\n\\n  function isSaleActive() external view returns (bool);\\n  function getMilestoneInfo(uint256 index_) external view returns (Milestone memory);\\n  function getCurrentMilestoneIndex() external view returns (uint256);\\n  function regularDepositLimit(address receiver_) external view returns (uint256);\\n  function maxDepositLimit(address receiver_) external view returns (uint256);\\n  function getMinimalDepositAmount() external view returns (uint256);\\n  function getRepresentative(address receiver_, address ambasador_) external view returns (address);\\n  function getRepresentativeRate(address ambasador_) external view returns (uint256, uint256);\\n  function getCurrentMilestonePrice(Option option_) external view returns (uint256);\\n  function getTreasury() external view returns (address);\\n\\n  function balanceOf(uint256 round_, address user_) external view returns (uint256);\\n  function representativeBalanceOf(address asset_, address user_) external view returns (uint256);\\n  function getMilestoneAmount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/TokenStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NONE\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"./interfaces/ITokenStore.sol\\\";\\nimport \\\"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\\\";\\nimport \\\"@pythnetwork/pyth-sdk-solidity/IPyth.sol\\\";\\n\\ncontract TokenStore is ITokenStore, ReentrancyGuard, AccessControl, Pausable {\\n  using SafeERC20 for IERC20;\\n\\n  address internal constant tokenAddress = 0x8888888888888888888888888888888888888888;\\n  address internal constant ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  uint256 public constant MULTIPLIER = 1000000000000000000;\\n  uint256 public constant precision = 18;\\n  uint256 public constant defaultPythThreshold = 28800; // 8h\\n\\n  uint256 private _totalDepositAmount;\\n\\n  IPyth private _pyth;\\n  uint256 private _pythNativeThreshold;\\n  bytes32 private _pythNativePriceFeedId;\\n\\n  uint256 private _limit;\\n  uint256 private _totalSoldTokens;\\n\\n  uint256 private _cRepRate = 50;\\n  uint256 private _tRepRate = 50;\\n\\n  address private _treasury;\\n  Status private _saleStatus;\\n\\n  Milestone[] private _milestone;\\n  uint256 private _currentMilestone;\\n\\n  uint256 private _maxDepositAmount;\\n  uint256 private _minDepositAmount;\\n\\n  bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n  bytes32 public constant VERIFIED_ROLE = keccak256(\\\"VERIFIED_ROLE\\\");\\n\\n  mapping(address => Stable) private _stables;\\n  mapping(address => uint256) private _userTotalBalances;\\n  mapping(address => mapping(uint256 => uint256)) private _milestoneBalances;\\n  mapping(address => bool) private _verified;\\n  mapping(address => Representative) private _reps;\\n  mapping(address => address) private _repsUsers;\\n  mapping(address => mapping(address => uint256)) private _repBalances;\\n  mapping(address => TokenConfig) private _tokenConfig;\\n\\n  event DepositedToken(\\n    address indexed receiver,\\n    address indexed asset,\\n    address indexed representative,\\n    uint256 size,\\n    ITokenStore.Option option,\\n    uint256 tokensReleased,\\n    uint256 saleMilestone\\n  );\\n\\n  event DepositedNative(\\n    address indexed receiver,\\n    address indexed representative,\\n    uint256 size,\\n    ITokenStore.Option indexed option,\\n    uint256 tokensReleased,\\n    uint256 saleMilestone\\n  );\\n\\n  event Claimed(address indexed Representative, address indexed asset, uint256 amount);\\n\\n  constructor(address treasury_, address[] memory stables_, address pyth_, bytes32 pythNativePriceFeedId_, address[] memory tokens, bytes32[] memory pythIds) {\\n    require(treasury_ != address(0), \\\"TokenStore: zero bank address\\\");\\n    require(\\n      pyth_ != address(0),\\n      \\\"TokenStore: cant set zero addresses\\\"\\n    );\\n\\n    require(tokens.length == pythIds.length, \\\"TokenStore: arrays lengths not equals\\\");\\n\\n    _treasury = treasury_;\\n\\n    for (uint256 index = 0; index < stables_.length; index++) {\\n      require(stables_[index] != address(0), \\\"TokenStore: cant set zero asset address\\\");\\n      _stables[stables_[index]] = Stable({defined: true, total: 0});\\n    }\\n    \\n    for(uint256 i; i < tokens.length; i++) {\\n      _tokenConfig[tokens[i]] = TokenConfig({ defined: true, pythId: pythIds[i], total:0, threshold: defaultPythThreshold });\\n    }\\n\\n    _pyth = IPyth(pyth_);\\n    _pythNativeThreshold = defaultPythThreshold;\\n    _pythNativePriceFeedId = pythNativePriceFeedId_;\\n\\n    _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    _grantRole(MANAGER_ROLE, _msgSender());\\n  }\\n\\n  function getTreasury() external view returns (address) {\\n    return _treasury;\\n  }\\n\\n  function getMaxDepositAmount() external view returns (uint256) {\\n    return _maxDepositAmount;\\n  }\\n\\n  function getMinimalDepositAmount() external view returns (uint256) {\\n    return _minDepositAmount;\\n  }\\n\\n  function getMilestoneAmount() external view returns (uint256) {\\n    return _milestone.length;\\n  }\\n\\n  function getCurrentMilestoneIndex() external view returns (uint256) {\\n    return _currentMilestone;\\n  }\\n\\n  function getMilestoneInfo(uint256 index_) external view returns (Milestone memory) {\\n    return _milestone[index_];\\n  }\\n\\n  function getTotalSoldTokens() external view returns (uint256) {\\n    return _totalSoldTokens;\\n  }\\n\\n  function balanceOf(uint256 milestone_, address user_) external view returns (uint256) {\\n    return _milestoneBalances[user_][milestone_];\\n  }\\n\\n  function representativeBalanceOf(address asset_, address user_) external view returns (uint256) {\\n    return _repBalances[user_][asset_];\\n  }\\n\\n  function regularDepositLimit(address user_) public view returns (uint256) {\\n    uint256 amount = _userTotalBalances[user_];\\n    uint256 limit = _limit;\\n    if (isVerified(user_)) {\\n      limit = _maxDepositAmount;\\n    }\\n    return amount < limit ? limit - amount : 0;\\n  }\\n\\n  function maxDepositLimit(address user_) public view returns (uint256) {\\n    uint256 amount = _userTotalBalances[user_];\\n    return amount < _maxDepositAmount ? _maxDepositAmount - amount : 0;\\n  }\\n\\n  function getLimit() external view returns (uint256) {\\n    return _limit;\\n  }\\n\\n  function getRepresentativeRates() external view returns (uint256, uint256) {\\n    return (_cRepRate, _tRepRate);\\n  }\\n\\n  function getRepresentative(address user_, address rep_) public view returns (address) {\\n    Representative memory rep = _reps[_repsUsers[user_]];\\n    if (rep.defined && rep.enabled) {\\n      return _repsUsers[user_];\\n    }\\n    rep = _reps[rep_];\\n    if (!rep.defined || rep.enabled) {\\n      return rep_;\\n    }\\n    return address(0);\\n  }\\n\\n  function getRepresentativeRate(address rep_) public view returns (uint256, uint256) {\\n    Representative memory rep = _reps[rep_];\\n    if (rep.defined) {\\n      return (Math.max(rep.firstRepRate, _cRepRate), Math.max(rep.secondRepRate, _tRepRate));\\n    }\\n    return (_cRepRate, _tRepRate);\\n  }\\n\\n  function isSaleActive() public view returns (bool) {\\n    return _saleStatus == Status.Opened;\\n  }\\n\\n  function isSaleInactive() public view returns (bool) {\\n    return _saleStatus == Status.Closed;\\n  }\\n\\n  function getCurrentMilestonePrice(Option option_) public view returns (uint256) {\\n    if (_milestone[_currentMilestone].state == Status.Opened) {\\n      return\\n        option_ == Option.Short ? _milestone[_currentMilestone].sPrice : _milestone[_currentMilestone].lPrice;\\n    }\\n    return 0;\\n  }\\n\\n  function isVerified(address user_) public view returns (bool) {\\n    return _verified[user_];\\n  }\\n\\n  function open() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(_saleStatus == Status.None, \\\"TokenStore: sale already started\\\");\\n\\n    _saleStatus = Status.Opened;\\n  }\\n\\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(isSaleActive(), \\\"TokenStore: sale not started\\\");\\n\\n    _saleStatus = Status.Closed;\\n  }\\n\\n  function toggleAllowedTokens(\\n    address[] calldata tokens_,\\n    bytes32[] calldata pythIds_,\\n    uint256[] calldata thresholds_,\\n    bool[] calldata statuses_\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(tokens_.length == pythIds_.length && tokens_.length == statuses_.length && tokens_.length == thresholds_.length, \\\"TokenStore: arrays lengths not equals\\\");\\n\\n    for(uint256 i; i < tokens_.length; i++) {\\n      uint256 oldTotal = _tokenConfig[tokens_[i]].total;\\n      _tokenConfig[tokens_[i]] = TokenConfig({ defined: statuses_[i], pythId: pythIds_[i], total: oldTotal, threshold: thresholds_[i] });\\n    }\\n  }\\n\\n  function setNativePythThreshold(uint256 pythNativeThreshold_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    _pythNativeThreshold = pythNativeThreshold_;\\n  }\\n\\n  function getAllowedToken(address token_) external view returns(TokenConfig memory) {\\n    return _tokenConfig[token_];\\n  }\\n\\n  function setMilestone(\\n    uint256 sPrice_,\\n    uint256 lPrice_,\\n    uint256 supply_\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(!isSaleInactive(), \\\"TokenStore: sale closed\\\");\\n\\n    _milestone.push(\\n      Milestone({\\n        defined: true,\\n        state: Status.None,\\n        sPrice: sPrice_,\\n        lPrice: lPrice_,\\n        sold: 0,\\n        supply: supply_\\n      })\\n    );\\n  }\\n\\n  function setRepresentativeRate(\\n    uint256 firstRepRate_,\\n    uint256 secondRepRate_\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(!isSaleInactive(), \\\"TokenStore: sale closed\\\");\\n    require(firstRepRate_ <= 1000, \\\"TokenStore: cant set first rate more then 100%\\\");\\n    require(secondRepRate_ <= 1000, \\\"TokenStore: cant set second rate more then 100%\\\");\\n\\n    _cRepRate = firstRepRate_;\\n    _tRepRate = secondRepRate_;\\n  }\\n\\n  function setupRepresentatives(\\n    address[] calldata reps_,\\n    uint256[] calldata firstRepRates_,\\n    uint256[] calldata secondRepRates_\\n  ) external onlyRole(MANAGER_ROLE) {\\n    require(!isSaleInactive(), \\\"TokenStore: sale closed\\\");\\n    require(\\n      reps_.length == firstRepRates_.length && reps_.length == secondRepRates_.length,\\n      \\\"TokenStore: invalid arrays length setup\\\"\\n    );\\n\\n    for (uint256 index = 0; index < reps_.length; index++) {\\n      _reps[reps_[index]] = Representative({\\n        defined: true,\\n        enabled: true,\\n        firstRepRate: firstRepRates_[index],\\n        secondRepRate: secondRepRates_[index]\\n      });\\n    }\\n  }\\n\\n  function updateMilestonePrice(\\n    uint256 index_,\\n    uint256 sPrice_,\\n    uint256 lPrice_\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(!isSaleInactive(), \\\"TokenStore: sale closed\\\");\\n    require(_milestone[index_].defined, \\\"TokenStore: Milestone should be defined\\\");\\n    require(_milestone[index_].state == Status.None, \\\"TokenStore: Milestone should not be started\\\");\\n\\n    _milestone[index_].sPrice = sPrice_;\\n    _milestone[index_].lPrice = lPrice_;\\n  }\\n\\n  function updateMilestoneSupply(\\n    uint256 index_,\\n    uint256 supply_\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(!isSaleInactive(), \\\"TokenStore: sale closed\\\");\\n    require(_milestone[index_].defined, \\\"TokenStore: Milestone should be defined\\\");\\n    require(_milestone[index_].state != Status.Closed, \\\"TokenStore: Milestone should not be closed\\\");\\n    require(\\n      _milestone[index_].sold < supply_,\\n      \\\"TokenStore: new supply must be bigger then sold tokens\\\"\\n    );\\n\\n    _milestone[index_].supply = supply_;\\n  }\\n\\n  function start(uint256 index_) external onlyRole(MANAGER_ROLE) {\\n    require(isSaleActive(), \\\"TokenStore: sale not active\\\");\\n    require(_milestone[index_].defined, \\\"TokenStore: Milestone should be defined\\\");\\n    require(_milestone[index_].state == Status.None, \\\"TokenStore: Milestone should not be used\\\");\\n\\n    if (_milestone[_currentMilestone].state == Status.Opened) {\\n      _milestone[_currentMilestone].state = Status.Closed;\\n    }\\n    _milestone[index_].state = Status.Opened;\\n    _currentMilestone = index_;\\n  }\\n\\n  function finishMilestone(uint256 index_) external onlyRole(MANAGER_ROLE) {\\n    require(_milestone[index_].defined, \\\"TokenStore: Milestone should be defined\\\");\\n    require(_milestone[index_].state == Status.Opened, \\\"TokenStore: Milestone should be active\\\");\\n\\n    _milestone[index_].state = Status.Closed;\\n  }\\n\\n  function setVerified(address user_, bool value_) external onlyRole(MANAGER_ROLE) {\\n    _verified[user_] = value_;\\n  }\\n\\n  function setVerifiedBatch(\\n    address[] calldata users_,\\n    bool[] calldata values_\\n  ) external onlyRole(MANAGER_ROLE) {\\n    require(users_.length == values_.length, \\\"TokenStore: invalid arrays length setup\\\");\\n\\n    for (uint256 index = 0; index < users_.length; index++) {\\n      _verified[users_[index]] = values_[index];\\n    }\\n  }\\n\\n  function setMaxDepositAmount(uint256 amount_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(amount_ <= 10000000000000000000000000, \\\"TokenStore: value is too big\\\");\\n    require(amount_ >= _minDepositAmount, \\\"TokenStore: value is too small\\\");\\n\\n    _maxDepositAmount = amount_;\\n  }\\n\\n  function setMinDepositAmount(uint256 amount_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(amount_ >= 100000000000000000, \\\"TokenStore: value is too small\\\");\\n    require(amount_ <= _maxDepositAmount, \\\"TokenStore: value is too big\\\");\\n\\n    _minDepositAmount = amount_;\\n  }\\n\\n  function setLimit(uint256 amount_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(amount_ >= _minDepositAmount && amount_ <= _maxDepositAmount, \\\"TokenStore: invalid value\\\");\\n\\n    _limit = amount_;\\n  }\\n\\n  function setTreasury(address treasury_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(treasury_ != address(0), \\\"TokenStore: zero bank address\\\");\\n\\n    _treasury = treasury_;\\n  }\\n\\n  function _processPayment(\\n    address user_,\\n    address asset_,\\n    uint256 amount_,\\n    uint256 sold_,\\n    address rep_,\\n    uint256 fReward_,\\n    uint256 sReward_\\n  ) private {\\n    _userTotalBalances[user_] = _userTotalBalances[user_] + amount_;\\n    _totalSoldTokens = _totalSoldTokens + sold_;\\n    _milestone[_currentMilestone].sold = _milestone[_currentMilestone].sold + sold_;\\n    _milestoneBalances[user_][_currentMilestone] = _milestoneBalances[user_][_currentMilestone] + sold_;\\n\\n    if (rep_ != address(0)) {\\n      if (!_reps[rep_].defined) {\\n        _reps[rep_].defined = true;\\n        _reps[rep_].enabled = true;\\n      }\\n      _repBalances[rep_][asset_] += fReward_;\\n      _repBalances[rep_][tokenAddress] += sReward_;\\n      _repsUsers[user_] = rep_;\\n    }\\n  }\\n\\n  function enableRepresentative(address rep_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(_reps[rep_].defined, \\\"TokenStore: Representative not defined\\\");\\n    require(!_reps[rep_].enabled, \\\"TokenStore: Representative already enabled\\\");\\n\\n    _reps[rep_].enabled = true;\\n  }\\n\\n  function disableRepresentative(address rep_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    require(_reps[rep_].defined, \\\"TokenStore: Representative not defined\\\");\\n    require(_reps[rep_].enabled, \\\"TokenStore: Representative already disabled\\\");\\n\\n    _reps[rep_].enabled = false;\\n  }\\n\\n  function claimRepresentativeRewards(address[] calldata assets_) external nonReentrant {\\n    address rep = _msgSender();\\n\\n    require(assets_.length > 0, \\\"TokenStore: no stables to process\\\");\\n    require(_reps[rep].defined, \\\"TokenStore: Representative not defined\\\");\\n    require(_reps[rep].enabled, \\\"TokenStore: Representative not enabled\\\");\\n\\n    for (uint256 i = 0; i < assets_.length; i++) {\\n      address token = assets_[i];\\n      uint256 balance = _repBalances[rep][token];\\n      if (balance == 0) {\\n        continue;\\n      }\\n\\n      _repBalances[rep][token] = 0;\\n      if (token == ethAddress) {\\n        (bool success, ) = rep.call{value: balance}(\\\"\\\");\\n        require(success, \\\"TokenStore: native claim error\\\");\\n      } else {\\n        IERC20(token).safeTransfer(rep, balance);\\n      }\\n\\n      emit Claimed(rep, token, balance);\\n    }\\n  }\\n\\n  function recoverNative() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    uint256 balance = address(this).balance;\\n    _msgSender().call{value: balance}(\\\"\\\");\\n  }\\n\\n  function recoverErc20(address asset_, uint256 amount_) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    IERC20(asset_).safeTransfer(_msgSender(), amount_);\\n  }\\n\\n  receive() external payable {}\\n  \\n  // coin seller\\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    _pause();\\n  }\\n\\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    _unpause();\\n  }\\n\\n  function depositCollateral(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address representative_\\n  ) external nonReentrant {\\n    _deposit(asset_, amount_, option_, _msgSender(), representative_, false);\\n  }\\n\\n  function depositCollateralFor(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_\\n  ) external nonReentrant onlyRole(VERIFIED_ROLE) {\\n    _deposit(asset_, amount_, option_, receiver_, representative_, true);\\n  }\\n\\n  function depositToken(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address representative_\\n  ) external nonReentrant {\\n    _depositToken(asset_, amount_, option_, _msgSender(), representative_, false);\\n  }\\n\\n  function depositTokenFor(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_\\n  ) external nonReentrant onlyRole(VERIFIED_ROLE) {\\n    _depositToken(asset_, amount_, option_, receiver_, representative_, true);\\n  }\\n\\n  function isStableSupported(address asset_) external view returns (bool) {\\n    return _stables[asset_].defined;\\n  }\\n\\n  function getDepositedByToken(address asset_) external view returns (uint256) {\\n    return _stables[asset_].total;\\n  }\\n\\n  function _deposit(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_,\\n    bool isVerified_\\n  ) internal whenNotPaused {\\n    require(receiver_ != address(0), \\\"TokenStore: receiver is zero\\\");\\n    require(receiver_ != representative_, \\\"TokenStore: self-referring is disabled\\\");\\n    require(amount_ > 0, \\\"TokenStore: amount is zero\\\");\\n    require(_stables[asset_].defined, \\\"TokenStore: asset is not allowed\\\");\\n    require(isSaleActive(), \\\"TokenStore: sale is already closed\\\");\\n\\n    ITokenStore.Milestone memory milestone = _milestone[_currentMilestone];\\n\\n    require(\\n      milestone.state == ITokenStore.Status.Opened,\\n      \\\"TokenStore: milestone is not active\\\"\\n    );\\n    require(\\n      milestone.supply >= milestone.sold + _getSold(asset_, amount_, option_),\\n      \\\"TokenStore: milestone allocation exceed\\\"\\n    );\\n\\n    uint256 decimals = IERC20Metadata(asset_).decimals();\\n    uint256 funds = (amount_ * MULTIPLIER) / (10 ** decimals);\\n\\n    uint256 limit = isVerified_\\n      ? maxDepositLimit(receiver_)\\n      : regularDepositLimit(receiver_);\\n\\n    require(\\n      funds >= _minDepositAmount,\\n      \\\"TokenStore: deposit amount is too small\\\"\\n    );\\n    require(funds <= limit, \\\"TokenStore: deposit amount is too big\\\");\\n\\n    (address rep, uint256 fTokenFunds, uint256 sTokenFunds) = _getRepresentative(\\n      receiver_,\\n      asset_,\\n      representative_,\\n      option_,\\n      amount_\\n    );\\n    _process(_msgSender(), asset_, amount_, fTokenFunds);\\n\\n    _stables[asset_].total = _stables[asset_].total + amount_;\\n    uint256 sold = _getSold(asset_, amount_, option_);\\n    uint256 investment = (amount_ * MULTIPLIER) / (10 ** decimals);\\n    _processPayment(\\n      receiver_,\\n      asset_,\\n      investment,\\n      sold,\\n      rep,\\n      fTokenFunds,\\n      sTokenFunds\\n    );\\n\\n    emit DepositedToken(\\n      receiver_,\\n      asset_,\\n      rep,\\n      amount_,\\n      option_,\\n      sold,\\n      _currentMilestone\\n    );\\n  }\\n\\n  function _depositToken(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_,\\n    bool isVerified_\\n  ) internal whenNotPaused {\\n    require(receiver_ != address(0), \\\"TokenStore: receiver is zero\\\");\\n    require(receiver_ != representative_, \\\"TokenStore: self-referring is disabled\\\");\\n    require(amount_ > 0, \\\"TokenStore: amount is zero\\\");\\n    require(_tokenConfig[asset_].defined, \\\"TokenStore: token is not configured\\\");\\n    require(isSaleActive(), \\\"TokenStore: sale is already closed\\\");\\n\\n    ITokenStore.Milestone memory milestone = _milestone[_currentMilestone];\\n\\n    require(\\n      milestone.state == ITokenStore.Status.Opened,\\n      \\\"TokenStore: milestone is not active\\\"\\n    );\\n    require(\\n      milestone.supply >= milestone.sold + _getSoldTokens(asset_, amount_, option_),\\n      \\\"TokenStore: milestone allocation exceed\\\"\\n    );\\n\\n\\n    PythStructs.Price memory priceInfo = _pyth.getPriceUnsafe(_tokenConfig[asset_].pythId);\\n    require(priceInfo.publishTime > block.timestamp - _tokenConfig[asset_].threshold, \\\"TokenStore: Pyth Oracle price outdated\\\");\\n    \\n    uint256 price = uint256(uint64(priceInfo.price));\\n    uint256 tokenDecimals = IERC20Metadata(asset_).decimals();\\n    uint8 priceDecimals = uint8(uint32(-1 * priceInfo.expo));\\n\\n    uint256 funds = (amount_ * price * MULTIPLIER) / (10 ** (priceDecimals + tokenDecimals));\\n\\n    uint256 limit = isVerified_\\n      ? maxDepositLimit(receiver_)\\n      : regularDepositLimit(receiver_);\\n\\n    require(\\n      funds >= _minDepositAmount,\\n      \\\"TokenStore: deposit amount is too small\\\"\\n    );\\n    require(funds <= limit, \\\"TokenStore: deposit amount is too big\\\");\\n\\n    (address rep, uint256 fTokenFunds, uint256 sTokenFunds) = _getRepresentativeToken(\\n      receiver_,\\n      asset_,\\n      representative_,\\n      option_,\\n      amount_\\n    );\\n    _process(_msgSender(), asset_, amount_, fTokenFunds);\\n\\n    _tokenConfig[asset_].total += amount_;\\n    uint256 sold = _getSoldTokens(asset_, amount_, option_);\\n\\n    _processPayment(\\n      receiver_,\\n      asset_,\\n      funds,\\n      sold,\\n      rep,\\n      fTokenFunds,\\n      sTokenFunds\\n    );\\n\\n    emit DepositedToken(\\n      receiver_,\\n      asset_,\\n      rep,\\n      amount_,\\n      option_,\\n      sold,\\n      _currentMilestone\\n    );\\n  }\\n\\n  function _process(address receiver_, address asset_, uint256 amount_, uint256 reward_) internal {\\n    address treasury = _treasury;\\n    IERC20(asset_).safeTransferFrom(receiver_, treasury, amount_ - reward_);\\n    if (reward_ > 0) {\\n      IERC20(asset_).safeTransferFrom(receiver_, address(this), reward_);\\n    }\\n  }\\n\\n  function _getRepresentative(\\n    address receiver_,\\n    address asset_,\\n    address representative_,\\n    ITokenStore.Option option_,\\n    uint256 amount_\\n  ) internal view returns (address, uint256, uint256) {\\n    address representative = getRepresentative(receiver_, representative_);\\n    if (representative == address(0)) {\\n      return (representative, 0, 0);\\n    }\\n    (uint256 fReward_, uint256 secondaryReward_) = getRepresentativeRate(representative);\\n    uint256 fTokenFunds = (amount_ * fReward_) / 1000;\\n    uint256 sTokenFunds = (amount_ * secondaryReward_) / 1000;\\n    uint256 sTokenSold = _getSold(asset_, sTokenFunds, option_);\\n\\n    return (representative, fTokenFunds, sTokenSold);\\n  }\\n\\n\\n  function _getRepresentativeToken(\\n    address receiver_,\\n    address asset_,\\n    address representative_,\\n    ITokenStore.Option option_,\\n    uint256 amount_\\n  ) internal view returns (address, uint256, uint256) {\\n    address representative = getRepresentative(receiver_, representative_);\\n    if (representative == address(0)) {\\n      return (representative, 0, 0);\\n    }\\n    (uint256 fReward_, uint256 secondaryReward_) = getRepresentativeRate(representative);\\n    uint256 fTokenFunds = (amount_ * fReward_) / 1000;\\n    uint256 sTokenFunds = (amount_ * secondaryReward_) / 1000;\\n    uint256 sTokenSold = _getSoldTokens(asset_, sTokenFunds, option_);\\n\\n    return (representative, fTokenFunds, sTokenSold);\\n  }\\n\\n  function _getSold(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_\\n  ) internal view returns (uint256) {\\n    uint8 decimals = IERC20Metadata(asset_).decimals();\\n    return\\n      ((amount_ * 10 ** precision * MULTIPLIER) / 10 ** decimals) /\\n      getCurrentMilestonePrice(option_);\\n  }\\n\\n  function _getSoldTokens(\\n    address asset_,\\n    uint256 amount_,\\n    ITokenStore.Option option_\\n  ) internal view returns (uint256) {\\n    PythStructs.Price memory priceInfo = _pyth.getPriceUnsafe(_tokenConfig[asset_].pythId);\\n    require(priceInfo.publishTime > block.timestamp - _tokenConfig[asset_].threshold, \\\"TokenStore: Pyth Oracle price outdated\\\");\\n    uint256 price = uint256(uint64(priceInfo.price));\\n    uint8 priceDecimals = uint8(uint32(-1 * priceInfo.expo));\\n    uint8 decimals = IERC20Metadata(asset_).decimals();\\n\\n    return (amount_ * price * MULTIPLIER * MULTIPLIER) / getCurrentMilestonePrice(option_) / (10 ** (priceDecimals + decimals));\\n  }\\n\\n  function depositNative(\\n    ITokenStore.Option option_,\\n    address representative_\\n  ) external payable nonReentrant {\\n    _deposit(option_, _msgSender(), representative_, false);\\n  }\\n\\n  function depositNativeFor(\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_\\n  ) external payable onlyRole(VERIFIED_ROLE) nonReentrant {\\n    _deposit(option_, receiver_, representative_, true);\\n  }\\n\\n  function getTotalDepositAmount() external view returns (uint256) {\\n    return _totalDepositAmount;\\n  }\\n\\n  function _deposit(\\n    ITokenStore.Option option_,\\n    address receiver_,\\n    address representative_,\\n    bool isVerified_\\n  ) internal whenNotPaused {\\n    uint256 amount = msg.value;\\n\\n    require(receiver_ != address(0), \\\"TokenStore: receiver is zero\\\");\\n    require(receiver_ != representative_, \\\"TokenStore: self-referring is disabled\\\");\\n    require(amount > 0, \\\"TokenStore: amount is zero\\\");\\n    require(isSaleActive(), \\\"TokenStore: sale is already closed\\\");\\n\\n    ITokenStore.Milestone memory milestone = _milestone[_currentMilestone];\\n\\n    require(\\n      milestone.state == ITokenStore.Status.Opened,\\n      \\\"TokenStore: milestone is not active\\\"\\n    );\\n    require(\\n      milestone.supply >= milestone.sold + _getSold(amount, option_),\\n      \\\"TokenStore: milestone allocation exceed\\\"\\n    );\\n\\n    PythStructs.Price memory priceInfo = _pyth.getPriceUnsafe(_pythNativePriceFeedId);\\n    require(priceInfo.publishTime > block.timestamp - _pythNativeThreshold, \\\"TokenStore: Pyth Oracle price outdated\\\");\\n    uint8 decimals = uint8(uint32(-1 * priceInfo.expo));\\n    uint256 price = uint256(uint64(priceInfo.price));\\n\\n    uint256 funds = (amount * price * MULTIPLIER) / (10 ** (precision + decimals));\\n    uint256 limit = isVerified_\\n      ? maxDepositLimit(receiver_)\\n      : regularDepositLimit(receiver_);\\n\\n    require(\\n      funds >= _minDepositAmount,\\n      \\\"TokenStore: deposit amount is too small\\\"\\n    );\\n    require(funds <= limit, \\\"TokenStore: deposit amount is too big\\\");\\n\\n    (address representative, uint256 coinFunds, uint256 tokenFunds) = _getRepresentative(\\n      receiver_,\\n      representative_,\\n      option_,\\n      amount\\n    );\\n    _process(amount, coinFunds);\\n\\n    _totalDepositAmount = _totalDepositAmount + amount;\\n    uint256 sold = _getSold(amount, option_);\\n    uint256 investment = (amount * price * MULTIPLIER) / (10 ** (precision + decimals));\\n    _processPayment(\\n      receiver_,\\n      ethAddress,\\n      investment,\\n      sold,\\n      representative,\\n      coinFunds,\\n      tokenFunds\\n    );\\n\\n    emit DepositedNative(\\n      receiver_,\\n      representative,\\n      amount,\\n      option_,\\n      sold,\\n      _currentMilestone\\n    );\\n  }\\n\\n  function _process(uint256 amount_, uint256 reward_) internal {\\n    address treasury = _treasury;\\n    (bool success, ) = treasury.call{value: amount_ - reward_}(\\\"\\\");\\n    require(success, \\\"TokenStore: transfer is not processed\\\");\\n  }\\n\\n  function  _getRepresentative(\\n    address receiver_,\\n    address representative_,\\n    ITokenStore.Option option_,\\n    uint256 amount_\\n  ) internal view returns (address, uint256, uint256) {\\n    address representative = getRepresentative(receiver_, representative_);\\n    if (representative == address(0)) {\\n      return (representative, 0, 0);\\n    }\\n    (uint256 fRate, uint256 sRate) = getRepresentativeRate(representative);\\n    uint256 coinFunds = (amount_ * fRate) / 1000;\\n    uint256 tokenFunds = (amount_ * sRate) / 1000;\\n    uint256 tokenSold = _getSold(tokenFunds, option_);\\n\\n    return (representative, coinFunds, tokenSold);\\n  }\\n\\n  function _getSold(\\n    uint256 amount_,\\n    ITokenStore.Option option_\\n  ) internal view returns (uint256) {\\n    PythStructs.Price memory priceInfo = _pyth.getPriceUnsafe(_pythNativePriceFeedId);\\n    require(priceInfo.publishTime > block.timestamp - _pythNativeThreshold, \\\"TokenStore: Pyth Oracle price outdated\\\");\\n    uint8 decimals = uint8(uint32(-1 * priceInfo.expo));\\n    uint256 price = uint256(uint64(priceInfo.price));\\n\\n    return (amount_ * price * MULTIPLIER) / getCurrentMilestonePrice(option_) / (10 ** decimals);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 750\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"stables_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"pyth_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"pythNativePriceFeedId_\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"pythIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Representative\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReleased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleMilestone\",\"type\":\"uint256\"}],\"name\":\"DepositedNative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReleased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleMilestone\",\"type\":\"uint256\"}],\"name\":\"DepositedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIED_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"milestone_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets_\",\"type\":\"address[]\"}],\"name\":\"claimRepresentativeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPythThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositCollateralFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositNativeFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"representative_\",\"type\":\"address\"}],\"name\":\"depositTokenFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rep_\",\"type\":\"address\"}],\"name\":\"disableRepresentative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rep_\",\"type\":\"address\"}],\"name\":\"enableRepresentative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"finishMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"getAllowedToken\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"defined\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"pythId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenStore.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMilestoneIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ITokenStore.Option\",\"name\":\"option_\",\"type\":\"uint8\"}],\"name\":\"getCurrentMilestonePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"}],\"name\":\"getDepositedByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMilestoneAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"getMilestoneInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"defined\",\"type\":\"bool\"},{\"internalType\":\"enum ITokenStore.Status\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenStore.Milestone\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimalDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rep_\",\"type\":\"address\"}],\"name\":\"getRepresentative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rep_\",\"type\":\"address\"}],\"name\":\"getRepresentativeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRepresentativeRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSoldTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleInactive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"}],\"name\":\"isStableSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"maxDepositLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"regularDepositLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"representativeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"setMaxDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply_\",\"type\":\"uint256\"}],\"name\":\"setMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"setMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pythNativeThreshold_\",\"type\":\"uint256\"}],\"name\":\"setNativePythThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstRepRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondRepRate_\",\"type\":\"uint256\"}],\"name\":\"setRepresentativeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value_\",\"type\":\"bool\"}],\"name\":\"setVerified\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"values_\",\"type\":\"bool[]\"}],\"name\":\"setVerifiedBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"reps_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"firstRepRates_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"secondRepRates_\",\"type\":\"uint256[]\"}],\"name\":\"setupRepresentatives\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"pythIds_\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"thresholds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"statuses_\",\"type\":\"bool[]\"}],\"name\":\"toggleAllowedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lPrice_\",\"type\":\"uint256\"}],\"name\":\"updateMilestonePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply_\",\"type\":\"uint256\"}],\"name\":\"updateMilestoneSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenStore", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "750", "ConstructorArguments": "0000000000000000000000002c9d77a9107cb4551a2bb3b1beded22f520e9ced00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000004305fb66699c3b2702d4d05cf36551390a4c69c6ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c5f0f7b66764f6ec8c8dff7ba683102295e16409000000000000000000000000000000000000000000000000000000000000000100000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce0000000000000000000000000000000000000000000000000000000000000001f0d57deca57b3da2fe63a493f4c25925fdfd8edf834b20f93e1f84dbd1504d4a", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}