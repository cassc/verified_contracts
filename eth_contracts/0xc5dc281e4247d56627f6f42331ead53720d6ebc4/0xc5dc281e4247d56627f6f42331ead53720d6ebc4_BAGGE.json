{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Bagge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n// Local Imports\\nimport \\\"./IBagge.sol\\\";\\n\\n/*\\n............................................................................::..^JPPPPGGGPP555YYYJ?Y\\n..............................................................................^?PBBBBBBBBBBBBBBBBBBB\\n............................................................................:7PBBBBBBBBBBBBBBBBBBBBB\\n..........................................................................^7PBBBBBBBBBBBBBBBBBBBBBBB\\n................................................................:^^~!^..^?PBBBBBBBBBBBBBBBBBBBBBBBBB\\n...........................................................:^!JY5GGBBP?YGBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n........................................................:!JPGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n........................................................!GBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n...............................................:::^~~!7?YGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n......................................:~!7??JY55PPGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBY?\\n....................................^?PBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGP5P!.\\n................................:.:7PBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGPYJ?7!!~~JJ.\\n.................................^YBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGPYJ?7!~~~^^^~~~~?Y:\\n..............................:.^5BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGPYJ?7!~~^^^^^^~^~~~~~~~?Y:\\n................................?#BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGP5Y?7!~~~^^^^~~!!777?77!!~~~~~JJ.\\n..............................:.^PBBBBBBBBBBBBBBBBBBBBBBBBBBGPYJ?!~~~^^^~~~~~~!?JYYJJ????JJJJ?~~!5!.\\n.................................~PBBBBBBBBBBBBBBBBGGPBBGGPP5Y7~^~~~~~~~~~~~~?5?!~~~^^^^^^^~!5?~YJ:.\\n..................................^5BBBBBBBBBP5YJ?7!!~?7!~~~~!!!~~~~~~~~~~~^!P7~~~~~~~~~~~~~~J5YJ:..\\n............................:::^~!7YGPYJ?!~?GJ!^^^^~~~^^~!7!!~^^~~~^~~~~!7??5Y~~~~~~~~~~~~~~~J57:...\\n...................:^~!7?JJY5PGGGPJ7~:...:!YG57~~~~~~~~?YYYYJ??!~!77?JJJJ?7!J?~~~~~~~~~~~~~~!J~.....\\n.................:!YGBB##BBG5J7!^:......^J7^7Y~~~~~~~~JJ~^^~!77J5J??7!~~~^~~~!~~~~~~~~~~~~~~??:.....\\n...............:~YBBBPY?7~^::..........:~^..~PY?7~~~~~Y?^^^^^~7!JJ^^~^~~~~~~~~~~~~~~~~~~~~~!Y~......\\n.............:!5B#BY~:.....................~Y7?J?J?!7?55~^^^^^~?!5!~~7Y5Y?7~~~~~~~~~~~~~~~~J?:......\\n...........^75B#GY~:.......................!J^^^!7YPJ7!J57~^^^^7?5!~???P5!~~~~~~~~~~~~~~~~JJ:.......\\n.........~JPBBGJ~:.:.......................:J7^^^7P?~^^~7JJ?77J5J!~~~~~5P5!^~~~!~~~~~~~^!J?:........\\n......^!YB#B57^.............................:??~~JY~~~~~~~~!777!~~~~~^?P5PY~~~~!Y7~~~~!7?~:.........\\n...:!JGBBGJ~:..............................:.:~7JP7~~~~~~~~!!~~~~~~~~755Y5P?~~~~Y5????7~:...........\\n:~JPBBGY!^...................................:..!5!^~^^~!?YY!~~~~~~!JP5YYYPP!~~~?Y^:::..............\\nGBBPJ!^.........................................~57!!7?JPB5!~~~~~!YPP5YYYYYP?^~~!5!.................\\nY7~:............................................:7??7!^:!5J!~~!7JJJP5YYYYYYP5~~~~Y?:................\\n.........................................................:!????7^..~YP5YY55PP!~~~JY:................\\n............................................................:::.:~!!?GGPPPPPP7~~~?5^................\\n...............................................................^J?!JPP55Y555P?^~~?5^................\\n..............................................................:7Y7YP5Y555Y55G?^~~?5~................\\n.......................................................^~^:::~???P5YY55PP5555!~~~?5~................\\n....................................................:~?J???7J5J?5P55YYJ?7!~!~~~~~JP~................\\n..................................................:~??!~~~~~~~!!!!~~~~~^^~~~~~~~~5P^................\\n.................................................^??!~~~~~~~~~~~~~~~~~~~~~~~~^~7Y57:................\\n...............................................:7J7~~~~~~~~~~~~~~~~~~~~~~~~~!?YJ!:..................\\n..............................................:?J!~~~~~~~~~~~~~~~~~~~~~~~!7JY7^.....................\\n.............................................^YJ~~~~~~~~~~~~~~~~~~~~~~~7JJ7~:.......................\\n............................................:YJ~~~~~~~~~~~~~~~~~~^~!7JJ7~:..........................\\n...........................................:JY~~~~~~~~~~~~~~~^~~!?JJ7^:.............................\\n...........................................!P!^~~~~~~~~~~~^~!7JJJ7^:................................\\n...........................................JY~~~~~~~~~~~!?JYY?!^....................................\\n..........................................:J?~~~~~!7?JYYY?!^:.......................................\\n...........................................!5JJJYJJJ?!~::...........................................\\n*/\\n\\n/**\\n * @title BaggeToken ~ It takes COURAGE to HODL your $BAGGE\\n * @author Team M2xM ~ Your trustworthy dev.\\n *\\n * @notice https://t.me/baggeportal\\n * \\n *         We strive to be very transparent. Because of this, we've left\\n *         exhaustive documentation in the code to ensure holders know we are\\n *         only ever going to do what is fair, honest and non-manipulative.\\n * \\n *         Supply     = 8,000,000,000 (8 Billion)\\n *         Initial LP = 1.8 ETH \ud83d\udd25\\n *         Uniswap LP = 7,600,000,000 (7.6 Billion, 95% of Supply)\\n *         Dev Tokens = 400,000,000 (400 Million, 5% of Supply)\\n *         Tax Rate   = 0.8% / 0.8% Tax -  This tax is auto-burned \ud83d\udd25 \\n *                      There is a 95% snipe buy tax, punishes snipes waiting for LQ pool opening as well is not waiting for taxes to be lifted.\\n * \\n */\\ncontract BAGGE is IBAGGE, Context, Ownable {\\n    using SafeMath for uint256;\\n    // @notice ~ Constant-related variables.\\n    string private constant _name = unicode\\\"Eustace Bagge\\\";             // @dev Token name: Eustace Bagge.\\n    string private constant _symbol = unicode\\\"BAGGE\\\";                   // @dev Token symbol: $BAGGE.\\n    uint8 private constant _decimals = 9;                               // @dev Needed for calculating large numbers.\\n    uint256 private constant _supply = 8000000000 * 10 ** _decimals;    // @dev 8 Billion $BAGGE tokens.\\n\\n    // @notice ~ Tax-related variables.\\n    uint256 private constant _taxRate = 8;                               // @dev 0.8% Buy/Sell tax.\\n    uint256 private constant _snipeTaxRate = 950;                        // @dev Snipe Tax of 95% (Snipe prevention)\\n    uint256 private _autoBurnThreshold = 40000000 * 10 ** _decimals;     // @dev Auto burn threshold for when tax tokens should be burned. This is 0.5%\\n\\n    // @notice ~ Transaction-related variables.\\n    uint256 private _maxAmountPerTx = 120000000 * 10 ** _decimals;       // @dev Initially 1.5% of supply, limit removed later.\\n    uint256 private _maxAmountPerWallet = 120000000 * 10 ** _decimals;   // @dev Initially 1.5% of supply, limit removed later.\\n    uint256 private _initialBlock;                                       // @dev Block number tracked to assure contract is fully set up before trading.                                   \\n\\n    // @notice ~ Address-related variables.\\n    mapping(address => uint256) private _balances;                       // @dev Keeps track of balances of each user.\\n    mapping(address => mapping(address => uint256)) private _allowances; // @dev Keeps track of allowances of each user.\\n    mapping(address => bool) private _isExcludedFromFee;                 // @dev List of addresses that are excluded from fees.\\n    mapping (address => bool) private _bklist;                           // @dev Blacklist records, don't want to use this, but added if necessary.\\n    address payable private _deadWallet;                                 // @dev Deal wallet where token are auto burned after 1% tax is accumulated.\\n    address private uniswapV2Pair;                                       // @dev Address to UniswapV2Pair created by the contract.\\n    IUniswapV2Router02 private _uniswapV2Router;                         // @dev UniswapV2Router02 variable for LQ Pool & routing.\\n\\n    // @notice Flag-related variables.\\n    bool private isTrading = false;                                      // @dev signals whether trading is enabled.\\n    bool private isSwapping = false;                                     // @dev signals whether a swap is currently in action.\\n    bool private isSwapEnabled = false;                                  // @dev signals whether swapping is enabled or not.\\n    bool private isLimitLifted = false;                                  // @dev signals whether or not the limited have been lifted.\\n    bool private isTaxLifted = false;                                    // @dev signals whether or not the tax limits have been lifted.\\n\\n    /**\\n     * @notice Swap lock modifier to change the isSwapping state with a function in-between.\\n     */\\n    modifier SwapLock() {\\n        isSwapping = true;\\n        _;\\n        isSwapping = false;\\n    }\\n\\n    /**\\n     * @notice Constructor, assure contract launcher is initial owner & set deal wallet address.\\n     */\\n    constructor() Ownable(_msgSender()) {\\n        // Give initial supply contract deployer.\\n        _balances[_msgSender()] = _supply;\\n\\n        // Assign dead wallet.\\n        _deadWallet = payable(0x000000000000000000000000000000000000dEaD);\\n\\n        // Exclude owner, contract and bbb wallet from fees.\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _isExcludedFromFee[_deadWallet] = true;\\n\\n        // Emit transfer event.\\n        emit Transfer(address(0), _msgSender(), _supply);\\n    }\\n\\n    /**\\n     * @notice Return-related functions.\\n     */\\n    function name() public pure returns (string memory) {return _name;}\\n    function symbol() public pure returns (string memory) {return _symbol;}\\n    function decimals() public pure returns (uint8) {return _decimals;}\\n    function totalSupply() public pure override returns (uint256) {return _supply;}\\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\\n\\n    /**\\n     * @notice Override of IERC20::transfer. \\n     *\\n     * @param recipient address of the recipient.\\n     * @param amount amount to transfer.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _internalTransfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Override of IERC20::allowance. \\n     *\\n     * @param owner address of the owner.\\n     * @param spender address of the spender.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Override of IERC20::approve. \\n     *\\n     * @param spender address of the spender.\\n     * @param amount amount to approve.\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _internalApprove(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Override of IERC20::transferFrom. \\n     *\\n     * @param sender address of the sender.\\n     * @param recipient address of the recipient.\\n     * @param amount amount to approve.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _internalTransfer(sender, recipient, amount);\\n        _internalApprove(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"Can not exceed transfer allowance.\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Internal approve method that sets the allotment amount to map.\\n     * \\n     * @param owner address of the owner.\\n     * @param spender address of the spender.\\n     * @param amount amount to approve.\\n     */\\n    function _internalApprove(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Internal transfer function with added tax capabilities.\\n     * \\n     * @param from address of the sender.\\n     * @param to address of the recipient.\\n     * @param amount amount to transfer.\\n     */\\n    function _internalTransfer(address from, address to, uint256 amount) private {\\n        // Pre-check before transfer.\\n        require(from != address(0), \\\"Can not transfer from the zero address\\\");\\n        require(to != address(0), \\\"Can not transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        require(!_bklist[from] && !_bklist[to], \\\"Blocked from transferring, address flagged as bots\\\");\\n\\n        // Immediately finalize this transaction if [from] or [to] is in the excluded list with zero tax. excluded\\n        // parties are in the constructor.\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) return _finalizeTransfer(from, to, amount, 0);\\n\\n        // Calculate taxRate.\\n        // Example: If purchasing 100000 tokens during early tax rate or 8 (or 0.8%):\\n        //      \\n        //      taxAmount = 100000 (amount) * tax rate (8 (or 0.8%)) = 2400000 / 1000 = 2400 tokens for tax.\\n        //      So 800 tokens will be sent to the contract address, you will receive 99200 Tokens.\\n        //     \\n        //      Tax is burning by the contract when contract reaches 0.5%% of supply. See _autoBurnBagge() function.\\n        uint256 taxAmount = amount.mul(_taxRate).div(1000);\\n        if (to != uniswapV2Pair && !isTaxLifted) {\\n            // Taxes have not yet been lifted and this is likely a buy, indicating this might be a snipe due to uniswap pool\\n            // as token contract has not yet been given. As such, snipe tax is applied instead.\\n            taxAmount = amount.mul(_snipeTaxRate).div(1000);\\n        }\\n\\n        // Assure transfers from the UniSwapPair address to a holders wallet don't exceed the initially imposed\\n        // limits. These limits are later removed by liftLimits().\\n        if (from == uniswapV2Pair && to != address(_uniswapV2Router)) {\\n            require(amount <= _maxAmountPerTx, \\\"Exceeds the transaction maximum.\\\");\\n            require(balanceOf(to) + amount <= _maxAmountPerWallet, \\\"Exceeds the wallet maximum.\\\");\\n\\n            // Block any user from being able to transfer until after the 4th block\\n            if (_initialBlock + 3 > block.number) require(!isContract(to));\\n        }\\n\\n        // Assets balance of the to address is not above the allocated limit. Limit are removed later in the\\n        // liftLimits() function.\\n        if (to != uniswapV2Pair) require(balanceOf(to) + amount <= _maxAmountPerWallet, \\\"Exceeds the wallet maximum.\\\");\\n\\n        // Facilitate that transaction into the contracts BAGGE balance.\\n        _balances[address(this)] = _balances[address(this)].add(taxAmount);\\n        emit Transfer(from, address(this), taxAmount);\\n\\n        // Auto burn tokens collected in tax. This is dependent on 5 things:\\n        //  - Swapping is enabled.\\n        //  - Are limits lifted.\\n        //  - Not currently swapping.\\n        //  - [to] address is uniswapV2Pair.\\n        //  - token balance of the contract is larger than auto burn threshold (0.5% of supply).\\n        if (\\n            isSwapEnabled &&\\n            isLimitLifted &&\\n            isTaxLifted &&\\n            !isSwapping &&\\n            to == uniswapV2Pair &&\\n            balanceOf(address(this)) > _autoBurnThreshold\\n        ) _autoBurnBagge();\\n\\n        // Finalize the transaction.\\n        _finalizeTransfer(from, to, amount, taxAmount);\\n    }\\n\\n    /**\\n     * @dev Finalizes the _internalTransfer function.\\n     *\\n     * @param from address of the sender.\\n     * @param to address of the recipient.\\n     * @param amount amount to transfer.\\n     */\\n    function _finalizeTransfer(address from, address to, uint256 amount, uint256 tax) private {\\n        // Complete transfer transaction.\\n        _balances[from] = _balances[from].sub(amount);\\n        _balances[to] = _balances[to].add(amount.sub(tax));\\n        emit Transfer(from, to, amount.sub(tax));\\n    }\\n\\n    /**\\n     * @notice Minimum between two numbers.\\n     * \\n     * @param a first number.\\n     * @param b second number.\\n     */\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return (a > b) ? b : a;\\n    }\\n\\n    /**\\n     * @notice Validates whether or not the address is this contract or not.\\n     * \\n     * @param account Address to validate.\\n     */\\n    function isContract(address account) private view returns (bool) {\\n        uint256 size;\\n        assembly {size := extcodesize(account)}\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @notice automatically transfers the contracts supply of $BAAGE tokens collected from tax to the null address.\\n     */\\n    function _autoBurnBagge() private SwapLock {\\n        // Complete transfer transaction.\\n        uint256 balance = balanceOf(address(this));\\n        _balances[address(this)] = _balances[address(this)].sub(balance);\\n        _balances[_deadWallet] = _balances[_deadWallet].add(balance);\\n        emit Transfer(address(this), _deadWallet, balance);\\n    }\\n    \\n    /**\\n     * @dev Removes the initial transaction and wallets amount limits imposed on construction. This allows a use\\n     *         to allocate as much tokens as they may desire.\\n     */\\n    function liftWalletLimits() external onlyOwner {\\n        // Assure thus function can't be called twice\\n        require(!isLimitLifted, \\\"Limits have already been lifted, can not call this function twice.\\\");\\n\\n        // Allow wallets to accumulate as many token as they want\\n        _maxAmountPerTx = _supply;\\n        _maxAmountPerWallet = _supply;\\n\\n        // Change lift limits status.\\n        isLimitLifted = true;\\n        emit WalletLimitsRevised(_supply);\\n    }\\n\\n    /**\\n     * @dev Removes the initial transaction tax limits imposed on construction. This will reduce tax to 0.8%\\n     */\\n    function liftTaxLimits() external onlyOwner {\\n        // Assure thus function can't be called twice\\n        require(!isTaxLifted, \\\"Limits have already been lifted, can not call this function twice.\\\");\\n\\n        // Do a one-time transfer of the contract's balance to the contract owner. This is mostly snipe tax collected\\n        // by the contract owner that will go back to community and various project initiatives.\\n        _internalTransfer(address(this), owner(), balanceOf(address(this)));\\n\\n        // Change lift limits status.\\n        isTaxLifted = true;\\n        emit TaxLimitsRevised(_supply);\\n    }\\n    \\n    /**\\n     * @dev Adds all addresses passed to the function to the _bklist.\\n     * @param addList list of addresses to add to the bklist.\\n     */\\n    function addToBkList(address[] memory addList) public onlyOwner {\\n        for (uint i = 0; i < addList.length; i++) {\\n            _bklist[addList[i]] = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes all addresses passed to the function from the _bklist.\\n     * @param removeList list of addresses to remove from the bklist.\\n     */\\n    function removeFromBkList(address[] memory removeList) public onlyOwner {\\n        for (uint i = 0; i < removeList.length; i++) {\\n            _bklist[removeList[i]] = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Check if passed address is on the _bkList.\\n     * @param a address to check.\\n     */\\n    function isOnBkList(address a) public view returns (bool) {\\n        return _bklist[a];\\n    }\\n\\n    /**\\n     * @notice Creates a liquidity pool using all of the Ethereum & BAGGE tokens stored in the contracts address.\\n     *\\n     * @dev This assures that the LQ is locked indefinitely when the contract is renounced. There is no way to drain\\n     *      the LQ pool afterward since the contract is the owner of the LQ pool and the contract will owner will be\\n     *      renounced.\\n     */\\n    function createUniLQPoolAndBeginTrading() external onlyOwner {\\n        // First check if trading has already begun\\n        require(!isTrading, \\\"Trading has already begun\\\");\\n\\n        // Initialize Uniswap at the official UniswapV2Router02 address\\n        // https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02\\n        _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n        // Creates the LQ Pair of BAGGE/ETH on Uniswap.\\n        _internalApprove(address(this), address(_uniswapV2Router), _supply);\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\\n            address(this),\\n            _uniswapV2Router.WETH()\\n        );\\n\\n        // Adds all of the ETH currently allocated in this contract as well as all of the $BAGGE tokens in this to be\\n        // added to the LQ pool.\\n        _uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            balanceOf(address(this)),\\n            0,\\n            0,\\n            owner(),\\n            block.timestamp\\n        );\\n        IERC20(uniswapV2Pair).approve(address(_uniswapV2Router), type(uint).max);\\n\\n        // Enable swapping.\\n        isSwapEnabled = true;\\n\\n        // Enable trading.\\n        isTrading = true;\\n\\n        // Store the first block number for tracking.\\n        _initialBlock = block.number;\\n    }\\n\\n    /**\\n     * @dev Enables the contract to receive eth without call data\\n     */\\n    receive() external payable {}\\n}\"\r\n    },\r\n    \"contracts/IBagge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n// Local Imports\\nimport \\\"./math/SafeMath.sol\\\";\\nimport \\\"./uniswap/IUniswapV2Factory.sol\\\";\\nimport \\\"./uniswap/IUniswapV2Router02.sol\\\";\\n\\n// NPM Imports\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IBaggeToken ~ Bagge interface, containing imports, error types custom events.\\n * @author LTL & M2xM ~ Your trust worthy devs.\\n * @notice\\n */\\ninterface IBAGGE is IERC20 {\\n    /**\\n     * triggered when wallet limits are revised.\\n     * @param value New limits.\\n     */\\n    event WalletLimitsRevised(uint value);\\n\\n    /**\\n     * triggered when wallet limits are revised.\\n     * @param value New limits.\\n     */\\n    event TaxLimitsRevised(uint value);\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return (a > b) ? b : a;\\n    }\\n}\"\r\n    },\r\n    \"contracts/uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n\\n    function allPairs(uint) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1336\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TaxLimitsRevised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WalletLimitsRevised\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addList\",\"type\":\"address[]\"}],\"name\":\"addToBkList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createUniLQPoolAndBeginTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"isOnBkList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftTaxLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftWalletLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"removeList\",\"type\":\"address[]\"}],\"name\":\"removeFromBkList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BAGGE", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "1336", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}