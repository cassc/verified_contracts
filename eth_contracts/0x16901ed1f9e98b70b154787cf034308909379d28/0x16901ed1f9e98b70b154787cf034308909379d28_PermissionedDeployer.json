{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/DefinitiveErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.18;\\n\\n/**\\n * @notice Contains all errors used throughout the Definitive contracts\\n * @dev This file should only be used as an internal library.\\n * @dev When adding a new error, add alphabetically\\n */\\n\\nerror AccountMissingRole(address _account, bytes32 _role);\\nerror AccountNotAdmin(address);\\nerror AccountNotWhitelisted(address);\\nerror AddLiquidityFailed();\\nerror AlreadyDeployed();\\nerror BytecodeEmpty();\\nerror DeadlineExceeded();\\nerror DeployInitFailed();\\nerror DeployFailed();\\nerror BorrowFailed(uint256 errorCode);\\nerror DecollateralizeFailed(uint256 errorCode);\\nerror DepositMoreThanMax();\\nerror EmptyBytecode();\\nerror EnterAllFailed();\\nerror EnforcedSafeLTV(uint256 invalidLTV);\\nerror ExceededMaxDelta();\\nerror ExceededMaxLTV();\\nerror ExceededShareToAssetRatioDeltaThreshold();\\nerror ExitAllFailed();\\nerror ExitOneCoinFailed();\\nerror InitializeMarketsFailed();\\nerror InputGreaterThanStaked();\\nerror InsufficientBalance();\\nerror InsufficientSwapTokenBalance();\\nerror InvalidAddress();\\nerror InvalidAmount();\\nerror InvalidAmounts();\\nerror InvalidCalldata();\\nerror InvalidDestinationSwapper();\\nerror InvalidERC20Address();\\nerror InvalidExecutedOutputAmount();\\nerror InvalidFeePercent();\\nerror InvalidHandler();\\nerror InvalidInputs();\\nerror InvalidMsgValue();\\nerror InvalidSingleHopSwap();\\nerror InvalidMultiHopSwap();\\nerror InvalidOutputToken();\\nerror InvalidRedemptionRecipient(); // Used in cross-chain redeptions\\nerror InvalidReportedOutputAmount();\\nerror InvalidRewardsClaim();\\nerror InvalidSignature();\\nerror InvalidSignatureLength();\\nerror InvalidSwapHandler();\\nerror InvalidSwapInputAmount();\\nerror InvalidSwapOutputToken();\\nerror InvalidSwapPath();\\nerror InvalidSwapPayload();\\nerror InvalidSwapToken();\\nerror MintMoreThanMax();\\nerror MismatchedChainId();\\nerror NativeAssetWrapFailed(bool wrappingToNative);\\nerror NoSignatureVerificationSignerSet();\\nerror RedeemMoreThanMax();\\nerror RemoveLiquidityFailed();\\nerror RepayDebtFailed();\\nerror SafeHarborModeEnabled();\\nerror SafeHarborRedemptionDisabled();\\nerror SlippageExceeded(uint256 _outputAmount, uint256 _outputAmountMin);\\nerror StakeFailed();\\nerror SupplyFailed();\\nerror StopGuardianEnabled();\\nerror SwapDeadlineExceeded();\\nerror SwapLimitExceeded();\\nerror SwapTokenIsOutputToken();\\nerror TransfersLimitExceeded();\\nerror UnstakeFailed();\\nerror UnauthenticatedFlashloan();\\nerror UntrustedFlashLoanSender(address);\\nerror WithdrawMoreThanMax();\\nerror ZeroShares();\\n\"\r\n    },\r\n    \"contracts/core/libraries/SignatureVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.18;\\n\\nimport { InvalidSignature, InvalidSignatureLength } from \\\"./DefinitiveErrors.sol\\\";\\n\\nlibrary SignatureVerifier {\\n    function verifySignature(\\n        mapping(address => bool) storage validSigners,\\n        bytes32 messageHash,\\n        bytes memory signature\\n    ) internal view {\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        address signer = recoverSigner(ethSignedMessageHash, signature);\\n\\n        if (!validSigners[signer]) {\\n            revert InvalidSignature();\\n        }\\n    }\\n\\n    /* cSpell:disable */\\n    function getEthSignedMessageHash(bytes32 messageHash) public pure returns (bytes32) {\\n        /*\\n            Signature is produced by signing a keccak256 hash with the following format:\\n            \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash));\\n    }\\n\\n    /* cSpell:enable */\\n\\n    function recoverSigner(bytes32 ethSignedMessageHash, bytes memory signature) private pure returns (address signer) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\\n        return ecrecover(ethSignedMessageHash, v, r, s);\\n    }\\n\\n    // https://solidity-by-example.org/signature\\n    function splitSignature(bytes memory sig) private pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        if (sig.length != 65) {\\n            revert InvalidSignatureLength();\\n        }\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            /*\\n            First 32 bytes stores the length of the signature\\n\\n            add(sig, 32) = pointer of sig + 32\\n            effectively, skips first 32 bytes of signature\\n\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\n            */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // implicitly return (r, s, v)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/Create2Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport { SignatureLogic, DeploymentParams } from \\\"../SignatureLogic.sol\\\";\\nimport { DeployFailed, EmptyBytecode, DeployInitFailed } from \\\"../../../core/libraries/DefinitiveErrors.sol\\\";\\nimport { SafeNativeTransfer } from \\\"../libs/SafeNativeTransfer.sol\\\";\\n\\nabstract contract Create2Deployer is SignatureLogic {\\n    using SafeNativeTransfer for address;\\n\\n    event Deployed(bytes32 indexed bytecodeHash, bytes32 indexed salt, address indexed deployedAddress);\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     */\\n    function deployCreate2(\\n        DeploymentParams calldata deployParams,\\n        bytes memory authorizedDeploySignature\\n    ) external payable returns (address deployedAddress_) {\\n        _verifyDeploymentParams(deployParams, authorizedDeploySignature);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n        deployedAddress_ = _deployCreate2(deployParams.bytecode, deployParams.deploySalt);\\n    }\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2` and initialize it. The address where the contract\\n     * will be deployed can be known in advance via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     * - `init` is used to initialize the deployed contract\\n     *    as an option to not have the constructor args affect the address derived by `CREATE2`.\\n     */\\n    function deployCreate2AndInit(\\n        DeploymentParams calldata deployParams,\\n        bytes memory authorizedDeploySignature,\\n        bytes calldata init\\n    ) external returns (address deployedAddress_) {\\n        _verifyDeploymentParams(deployParams, authorizedDeploySignature);\\n\\n        deployedAddress_ = _deployCreate2(deployParams.bytecode, deployParams.deploySalt);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = deployedAddress_.call(init);\\n        if (!success) revert DeployInitFailed();\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * Any change in the `bytecode`, `sender`, or `salt` will result in a new destination address.\\n     */\\n    function deployedCreate2Address(\\n        bytes calldata bytecode,\\n        bytes32 salt\\n    ) external view returns (address deployedAddress_) {\\n        deployedAddress_ = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            address(this),\\n                            salt,\\n                            keccak256(bytecode) // init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function _deployCreate2(bytes memory bytecode, bytes32 salt) internal returns (address deployedAddress_) {\\n        if (bytecode.length == 0) revert EmptyBytecode();\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            deployedAddress_ := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        if (deployedAddress_ == address(0)) revert DeployFailed();\\n\\n        emit Deployed(keccak256(bytecode), salt, deployedAddress_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/Create3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { ContractAddress } from \\\"../libs/ContractAddress.sol\\\";\\nimport { CreateDeploy } from \\\"./CreateDeploy.sol\\\";\\nimport { Create3Address } from \\\"./Create3Address.sol\\\";\\n\\nimport { EmptyBytecode, AlreadyDeployed, DeployFailed } from \\\"../../../core/libraries/DefinitiveErrors.sol\\\";\\n\\n/**\\n * @title Create3 contract\\n * @notice This contract can be used to deploy a contract with a deterministic address that depends only on\\n * the deployer address and deployment salt, not the contract bytecode and constructor parameters.\\n */\\nabstract contract Create3 is Create3Address {\\n    using ContractAddress for address;\\n\\n    /**\\n     * @notice Deploys a new contract using the `CREATE3` method.\\n     * @dev This function first deploys the CreateDeploy contract using\\n     * the `CREATE2` opcode and then utilizes the CreateDeploy to deploy the\\n     * new contract with the `CREATE` opcode.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt to influence the contract address\\n     * @return deployed The address of the deployed contract\\n     */\\n    function _create3(bytes memory bytecode, bytes32 deploySalt) internal returns (address deployed) {\\n        deployed = _create3Address(deploySalt);\\n\\n        if (bytecode.length == 0) revert EmptyBytecode();\\n        if (deployed.isContract()) revert AlreadyDeployed();\\n\\n        // Deploy using create2\\n        CreateDeploy create = new CreateDeploy{ salt: deploySalt }();\\n\\n        if (address(create) == address(0)) revert DeployFailed();\\n\\n        // Deploy using create\\n        create.deploy(bytecode);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/Create3Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport { CreateDeploy } from \\\"./CreateDeploy.sol\\\";\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Create3Address contract\\n * @notice This contract can be used to predict the deterministic\\n * deployment address of a contract deployed with the `CREATE3` technique.\\n */\\nabstract contract Create3Address {\\n    /// @dev bytecode hash of the CreateDeploy helper contract\\n    /* immutable-vars-naming */\\n    bytes32 internal immutable createDeployBytecodeHash;\\n\\n    constructor() {\\n        createDeployBytecodeHash = keccak256(type(CreateDeploy).creationCode);\\n    }\\n\\n    /**\\n     * @notice Compute the deployed address that will result from the `CREATE3` method.\\n     * @param deploySalt A salt to influence the contract address\\n     * @return deployed The deterministic contract address if it was deployed\\n     */\\n    function _create3Address(bytes32 deploySalt) internal view returns (address deployed) {\\n        address deployer = address(\\n            uint160(uint256(keccak256(abi.encodePacked(hex\\\"ff\\\", address(this), deploySalt, createDeployBytecodeHash))))\\n        );\\n\\n        deployed = address(uint160(uint256(keccak256(abi.encodePacked(hex\\\"d6_94\\\", deployer, hex\\\"01\\\")))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/CreateDeploy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title CreateDeploy Contract\\n * @notice This contract deploys new contracts using the `CREATE` opcode and is used as part of\\n * the `CREATE3` deployment method.\\n */\\ncontract CreateDeploy {\\n    /**\\n     * @dev Deploys a new contract with the specified bytecode using the `CREATE` opcode.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deploy(bytes memory bytecode) external payable {\\n        assembly {\\n            if iszero(create(0, add(bytecode, 32), mload(bytecode))) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        /// @dev If we want to redeploy to the same contract we must self destruct this intermediate contract\\n        // slither-disable-next-line suicidal\\n        selfdestruct(payable(address(0)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { SafeNativeTransfer } from \\\"../libs/SafeNativeTransfer.sol\\\";\\nimport { DeploymentParams, SignatureLogic } from \\\"../SignatureLogic.sol\\\";\\nimport { DeployInitFailed } from \\\"../../../core/libraries/DefinitiveErrors.sol\\\";\\n\\n/**\\n * @title Deployer Contract\\n * @notice This contract is responsible for deploying and initializing new contracts using\\n * a deployment method, such as `CREATE2` or `CREATE3`.\\n */\\nabstract contract Deployer is SignatureLogic {\\n    using SafeNativeTransfer for address;\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts.\\n     * @dev The address where the contract will be deployed can be known in\\n     * advance via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     *\\n     * @param deployParams Deployment parameters\\n     * @param authorizedDeploySignature valid signature authorizing the deploy\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deploy(\\n        DeploymentParams calldata deployParams,\\n        bytes memory authorizedDeploySignature\\n    ) public payable returns (address deployedAddress_) {\\n        _verifyDeploymentParams(deployParams, authorizedDeploySignature);\\n\\n        deployedAddress_ = _deployedAddress(deployParams.bytecode, deployParams.deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(deployParams.bytecode, deployParams.deploySalt);\\n    }\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts and initializes it.\\n     * @dev The address where the contract will be deployed can be known in advance\\n     * via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     * - `init` is used to initialize the deployed contract as an option to not have the\\n     *    constructor args affect the address derived by `CREATE2`.\\n     *\\n     * @param deployParams Deployment parameters\\n     * @param authorizedDeploySignature valid signature authorizing the deploy\\n     * @param init Init data used to initialize the deployed contract\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deployAndInit(\\n        DeploymentParams calldata deployParams,\\n        bytes memory authorizedDeploySignature,\\n        bytes calldata init\\n    ) external payable returns (address deployedAddress_) {\\n        _verifyDeploymentParams(deployParams, authorizedDeploySignature);\\n\\n        deployedAddress_ = _deployedAddress(deployParams.bytecode, deployParams.deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(deployParams.bytecode, deployParams.deploySalt);\\n\\n        (bool success, ) = deployedAddress_.call(init);\\n        if (!success) revert DeployInitFailed();\\n    }\\n\\n    /**\\n     *\\n     * @notice Returns the address where a contract will be stored\\n     * if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * @dev Any change in the `bytecode` (except for `CREATE3`), `sender`,\\n     * or `salt` will result in a new deployed address.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt The salt that will be used to influence the contract address\\n     * @return deployedAddress_ The address that the contract will be deployed to\\n     */\\n    function deployedAddress(bytes memory bytecode, bytes32 salt) public view returns (address) {\\n        return _deployedAddress(bytecode, salt);\\n    }\\n\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal virtual returns (address);\\n\\n    function _deployedAddress(bytes memory bytecode, bytes32 deploySalt) internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/deploy/PermissionedDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { Deployer } from \\\"./Deployer.sol\\\";\\nimport { Create3 } from \\\"./Create3.sol\\\";\\nimport { Create2Deployer } from \\\"./Create2Deployer.sol\\\";\\nimport { SignatureLogic } from \\\"../SignatureLogic.sol\\\";\\n\\n/**\\n * @title PermissionedDeployer Contract\\n * @notice This contract is responsible for deploying and initializing new contracts using the `CREATE3` method\\n * which computes the deployed contract address based on the deployer address and deployment salt.\\n */\\ncontract PermissionedDeployer is Create3, Create2Deployer, Deployer {\\n    constructor(address _owner, address[] memory _initialVerifiers) SignatureLogic(_owner, _initialVerifiers) {}\\n\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal override returns (address deployedAddress_) {\\n        deployedAddress_ = _create3(bytecode, deploySalt);\\n\\n        emit Deployed(keccak256(bytecode), deploySalt, deployedAddress_);\\n    }\\n\\n    function _deployedAddress(\\n        bytes memory /* bytecode */,\\n        bytes32 deploySalt\\n    ) internal view override returns (address) {\\n        return _create3Address(deploySalt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/libs/ContractAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary ContractAddress {\\n    function isContract(address contractAddress) internal view returns (bool) {\\n        bytes32 existingCodeHash = contractAddress.codehash;\\n\\n        // https://eips.ethereum.org/EIPS/eip-1052\\n        // keccak256('') == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\\n        return\\n            existingCodeHash != bytes32(0) &&\\n            existingCodeHash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/libs/SafeNativeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nerror NativeTransferFailed();\\n\\n/*\\n * @title SafeNativeTransfer\\n * @dev This library is used for performing safe native value transfers in Solidity by utilizing inline assembly.\\n */\\nlibrary SafeNativeTransfer {\\n    /*\\n     * @notice Perform a native transfer to a given address.\\n     * @param receiver The recipient address to which the amount will be sent.\\n     * @param amount The amount of native value to send.\\n     * @throws NativeTransferFailed error if transfer is not successful.\\n     */\\n    function safeNativeTransfer(address receiver, uint256 amount) internal {\\n        bool success;\\n\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            success := call(gas(), receiver, amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!success) revert NativeTransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/PermissionedDeployer/SignatureLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { SignatureVerifier } from \\\"../../core/libraries/SignatureVerifier.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {\\n    DeadlineExceeded,\\n    BytecodeEmpty,\\n    MismatchedChainId,\\n    InvalidAddress\\n} from \\\"../../core/libraries/DefinitiveErrors.sol\\\";\\n\\nstruct DeploymentParams {\\n    uint256 chainId;\\n    uint256 deadline;\\n    bytes bytecode;\\n    bytes32 deploySalt;\\n}\\n\\ncontract SignatureLogic is Ownable {\\n    event SignatureVerifierAdded(address signatureVerifier);\\n    event SignatureVerifierRemoved(address signatureVerifier);\\n\\n    mapping(address => bool) public isSignatureVerifier;\\n\\n    constructor(address _owner, address[] memory _initialVerifiers) {\\n        transferOwnership(_owner);\\n\\n        uint256 length = _initialVerifiers.length;\\n        for (uint256 i = 0; i < length; ) {\\n            _addSignatureVerifier(_initialVerifiers[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function addSignatureVerifier(address _signatureVerifier) public onlyOwner {\\n        _addSignatureVerifier(_signatureVerifier);\\n    }\\n\\n    function removeSignatureVerifier(address _signatureVerifier) public onlyOwner {\\n        _removeSignatureVerifier(_signatureVerifier);\\n    }\\n\\n    function encodeDepositParams(DeploymentParams calldata deploymentParameters) public pure returns (bytes32) {\\n        return keccak256(abi.encode(deploymentParameters));\\n    }\\n\\n    function _verifyDeploymentParams(\\n        DeploymentParams calldata deployParams,\\n        bytes memory authorizedDeploySignature\\n    ) internal view {\\n        SignatureVerifier.verifySignature(\\n            isSignatureVerifier,\\n            keccak256(abi.encode(deployParams)),\\n            authorizedDeploySignature\\n        );\\n\\n        if (deployParams.bytecode.length == 0) {\\n            revert BytecodeEmpty();\\n        }\\n\\n        if (deployParams.deadline < block.timestamp) {\\n            revert DeadlineExceeded();\\n        }\\n\\n        if (deployParams.chainId != block.chainid) {\\n            revert MismatchedChainId();\\n        }\\n    }\\n\\n    function _addSignatureVerifier(address _signatureVerifier) private {\\n        if (_signatureVerifier == address(0)) {\\n            revert InvalidAddress();\\n        }\\n        isSignatureVerifier[_signatureVerifier] = true;\\n        emit SignatureVerifierAdded(_signatureVerifier);\\n    }\\n\\n    function _removeSignatureVerifier(address _signatureVerifier) private {\\n        if (_signatureVerifier == address(0)) {\\n            revert InvalidAddress();\\n        }\\n        isSignatureVerifier[_signatureVerifier] = false;\\n        emit SignatureVerifierRemoved(_signatureVerifier);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"viaIR\": false,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_initialVerifiers\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BytecodeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeadlineExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployInitFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBytecode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signatureVerifier\",\"type\":\"address\"}],\"name\":\"SignatureVerifierAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signatureVerifier\",\"type\":\"address\"}],\"name\":\"SignatureVerifierRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signatureVerifier\",\"type\":\"address\"}],\"name\":\"addSignatureVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deploySalt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DeploymentParams\",\"name\":\"deployParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"authorizedDeploySignature\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deploySalt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DeploymentParams\",\"name\":\"deployParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"authorizedDeploySignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"init\",\"type\":\"bytes\"}],\"name\":\"deployAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deploySalt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DeploymentParams\",\"name\":\"deployParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"authorizedDeploySignature\",\"type\":\"bytes\"}],\"name\":\"deployCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deploySalt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DeploymentParams\",\"name\":\"deployParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"authorizedDeploySignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"init\",\"type\":\"bytes\"}],\"name\":\"deployCreate2AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployedCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deploySalt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DeploymentParams\",\"name\":\"deploymentParameters\",\"type\":\"tuple\"}],\"name\":\"encodeDepositParams\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSignatureVerifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signatureVerifier\",\"type\":\"address\"}],\"name\":\"removeSignatureVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PermissionedDeployer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "0000000000000000000000003b016025cd3d213c5779e10fe94a35ba440bd1c900000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000aba36de8208002e05a757377a76d50093233eb51000000000000000000000000af212671793921bcb84f04ceeed1dec1ef742dac000000000000000000000000bb08295b3a9c3c1787ad26bf04a08a1b5867d952000000000000000000000000dd8913000a02be65af040931bb3537ece1d139ae", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}