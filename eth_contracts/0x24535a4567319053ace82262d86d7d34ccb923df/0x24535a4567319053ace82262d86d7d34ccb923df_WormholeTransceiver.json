{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Transceiver/WormholeTransceiver/WormholeTransceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"wormhole-solidity-sdk/WormholeRelayerSDK.sol\\\";\\nimport \\\"wormhole-solidity-sdk/libraries/BytesParsing.sol\\\";\\nimport \\\"wormhole-solidity-sdk/interfaces/IWormhole.sol\\\";\\n\\nimport \\\"../../libraries/TransceiverHelpers.sol\\\";\\nimport \\\"../../libraries/TransceiverStructs.sol\\\";\\n\\nimport \\\"../../interfaces/IWormholeTransceiver.sol\\\";\\nimport \\\"../../interfaces/ISpecialRelayer.sol\\\";\\nimport \\\"../../interfaces/INttManager.sol\\\";\\n\\nimport \\\"./WormholeTransceiverState.sol\\\";\\n\\n/// @title WormholeTransceiver\\n/// @author Wormhole Project Contributors.\\n/// @notice Transceiver implementation for Wormhole.\\n///\\n/// @dev This contract is responsible for sending and receiving NTT messages\\n///      that are authenticated through Wormhole Core.\\n///\\n/// @dev Messages can be delivered either via standard relaying or special relaying, or\\n///      manually via the core layer.\\n///\\n/// @dev Once a message is received, it is delivered to its corresponding\\n///      NttManager contract.\\ncontract WormholeTransceiver is\\n    IWormholeTransceiver,\\n    IWormholeReceiver,\\n    WormholeTransceiverState\\n{\\n    using BytesParsing for bytes;\\n\\n    string public constant WORMHOLE_TRANSCEIVER_VERSION = \\\"0.1.0\\\";\\n\\n    constructor(\\n        address nttManager,\\n        address wormholeCoreBridge,\\n        address wormholeRelayerAddr,\\n        address specialRelayerAddr,\\n        uint8 _consistencyLevel,\\n        uint256 _gasLimit\\n    )\\n        WormholeTransceiverState(\\n            nttManager,\\n            wormholeCoreBridge,\\n            wormholeRelayerAddr,\\n            specialRelayerAddr,\\n            _consistencyLevel,\\n            _gasLimit\\n        )\\n    {}\\n\\n    // ==================== External Interface ===============================================\\n\\n    /// @inheritdoc IWormholeTransceiver\\n    function receiveMessage(bytes memory encodedMessage) external {\\n        uint16 sourceChainId;\\n        bytes memory payload;\\n        (sourceChainId, payload) = _verifyMessage(encodedMessage);\\n\\n        // parse the encoded Transceiver payload\\n        TransceiverStructs.TransceiverMessage memory parsedTransceiverMessage;\\n        TransceiverStructs.NttManagerMessage memory parsedNttManagerMessage;\\n        (parsedTransceiverMessage, parsedNttManagerMessage) = TransceiverStructs\\n            .parseTransceiverAndNttManagerMessage(WH_TRANSCEIVER_PAYLOAD_PREFIX, payload);\\n\\n        _deliverToNttManager(\\n            sourceChainId,\\n            parsedTransceiverMessage.sourceNttManagerAddress,\\n            parsedTransceiverMessage.recipientNttManagerAddress,\\n            parsedNttManagerMessage\\n        );\\n    }\\n\\n    /// @inheritdoc IWormholeReceiver\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalMessages,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable onlyRelayer {\\n        if (getWormholePeer(sourceChain) != sourceAddress) {\\n            revert InvalidWormholePeer(sourceChain, sourceAddress);\\n        }\\n\\n        // VAA replay protection:\\n        // - Note that this VAA is for the AR delivery, not for the raw message emitted by the source\\n        // - chain Transceiver contract. The VAAs received by this entrypoint are different than the\\n        // - VAA received by the receiveMessage entrypoint.\\n        if (isVAAConsumed(deliveryHash)) {\\n            revert TransferAlreadyCompleted(deliveryHash);\\n        }\\n        _setVAAConsumed(deliveryHash);\\n\\n        // We don't honor additional messages in this handler.\\n        if (additionalMessages.length > 0) {\\n            revert UnexpectedAdditionalMessages();\\n        }\\n\\n        // emit `ReceivedRelayedMessage` event\\n        emit ReceivedRelayedMessage(deliveryHash, sourceChain, sourceAddress);\\n\\n        // parse the encoded Transceiver payload\\n        TransceiverStructs.TransceiverMessage memory parsedTransceiverMessage;\\n        TransceiverStructs.NttManagerMessage memory parsedNttManagerMessage;\\n        (parsedTransceiverMessage, parsedNttManagerMessage) = TransceiverStructs\\n            .parseTransceiverAndNttManagerMessage(WH_TRANSCEIVER_PAYLOAD_PREFIX, payload);\\n\\n        _deliverToNttManager(\\n            sourceChain,\\n            parsedTransceiverMessage.sourceNttManagerAddress,\\n            parsedTransceiverMessage.recipientNttManagerAddress,\\n            parsedNttManagerMessage\\n        );\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiver\\n    function parseWormholeTransceiverInstruction(bytes memory encoded)\\n        public\\n        pure\\n        returns (WormholeTransceiverInstruction memory instruction)\\n    {\\n        // If the user doesn't pass in any transceiver instructions then the default is false\\n        if (encoded.length == 0) {\\n            instruction.shouldSkipRelayerSend = false;\\n            return instruction;\\n        }\\n\\n        uint256 offset = 0;\\n        (instruction.shouldSkipRelayerSend, offset) = encoded.asBoolUnchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiver\\n    function encodeWormholeTransceiverInstruction(WormholeTransceiverInstruction memory instruction)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(instruction.shouldSkipRelayerSend);\\n    }\\n\\n    // ==================== Internal ========================================================\\n\\n    function _quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TransceiverStructs.TransceiverInstruction memory instruction\\n    ) internal view override returns (uint256 nativePriceQuote) {\\n        // Check the special instruction up front to see if we should skip sending via a relayer\\n        WormholeTransceiverInstruction memory weIns =\\n            parseWormholeTransceiverInstruction(instruction.payload);\\n        if (weIns.shouldSkipRelayerSend) {\\n            return wormhole.messageFee();\\n        }\\n\\n        if (_checkInvalidRelayingConfig(targetChain)) {\\n            revert InvalidRelayingConfig(targetChain);\\n        }\\n\\n        if (_shouldRelayViaStandardRelaying(targetChain)) {\\n            (uint256 cost,) = wormholeRelayer.quoteEVMDeliveryPrice(targetChain, 0, gasLimit);\\n            return cost;\\n        } else if (isSpecialRelayingEnabled(targetChain)) {\\n            uint256 cost = specialRelayer.quoteDeliveryPrice(getNttManagerToken(), targetChain, 0);\\n            // We need to pay both the special relayer cost and the Wormhole message fee independently\\n            return cost + wormhole.messageFee();\\n        } else {\\n            return wormhole.messageFee();\\n        }\\n    }\\n\\n    function _sendMessage(\\n        uint16 recipientChain,\\n        uint256 deliveryPayment,\\n        address caller,\\n        bytes32 recipientNttManagerAddress,\\n        bytes32 refundAddress,\\n        TransceiverStructs.TransceiverInstruction memory instruction,\\n        bytes memory nttManagerMessage\\n    ) internal override {\\n        TransceiverStructs.TransceiverMessage memory transceiverMessage;\\n        bytes memory encodedTransceiverPayload;\\n        bytes32 wormholeFormattedCaller = toWormholeFormat(caller);\\n\\n        WormholeTransceiverInstruction memory weIns =\\n            parseWormholeTransceiverInstruction(instruction.payload);\\n\\n        if (!weIns.shouldSkipRelayerSend && _shouldRelayViaStandardRelaying(recipientChain)) {\\n            // NOTE: standard relaying supports refunds. The amount to be refunded will be sent\\n            // to a refundAddress specified by the client on the destination chain.\\n\\n            (transceiverMessage, encodedTransceiverPayload) = TransceiverStructs\\n                .buildAndEncodeTransceiverMessage(\\n                WH_TRANSCEIVER_PAYLOAD_PREFIX,\\n                wormholeFormattedCaller,\\n                recipientNttManagerAddress,\\n                nttManagerMessage,\\n                new bytes(0)\\n            );\\n\\n            // push onto the stack again to avoid stack too deep error\\n            bytes32 refundRecipient = refundAddress;\\n            uint16 destinationChain = recipientChain;\\n\\n            wormholeRelayer.sendPayloadToEvm{value: deliveryPayment}(\\n                destinationChain,\\n                fromWormholeFormat(getWormholePeer(destinationChain)),\\n                encodedTransceiverPayload,\\n                0,\\n                gasLimit,\\n                destinationChain,\\n                fromWormholeFormat(refundRecipient)\\n            );\\n\\n            emit RelayingInfo(uint8(RelayingType.Standard), refundAddress, deliveryPayment);\\n        } else if (!weIns.shouldSkipRelayerSend && isSpecialRelayingEnabled(recipientChain)) {\\n            // This transceiver payload is used to signal whether the message should be\\n            // picked up by the special relayer or not:\\n            //  - It only affects the off-chain special relayer.\\n            //  - It is not used by the target NTT Manager contract.\\n            // Transceiver payload is prefixed with 1 byte representing the version of\\n            // the payload. The rest of the bytes are the -actual- payload data. In payload\\n            // v1, the payload data is a boolean representing whether the message should\\n            // be picked up by the special relayer or not.\\n            bytes memory transceiverPayload = abi.encodePacked(uint8(1), true);\\n            (transceiverMessage, encodedTransceiverPayload) = TransceiverStructs\\n                .buildAndEncodeTransceiverMessage(\\n                WH_TRANSCEIVER_PAYLOAD_PREFIX,\\n                wormholeFormattedCaller,\\n                recipientNttManagerAddress,\\n                nttManagerMessage,\\n                transceiverPayload\\n            );\\n\\n            // push onto the stack again to avoid stack too deep error\\n            uint256 deliveryFee = deliveryPayment;\\n            uint16 destinationChain = recipientChain;\\n\\n            uint256 wormholeFee = wormhole.messageFee();\\n            uint64 sequence = wormhole.publishMessage{value: wormholeFee}(\\n                0, encodedTransceiverPayload, consistencyLevel\\n            );\\n            specialRelayer.requestDelivery{value: deliveryFee - wormholeFee}(\\n                getNttManagerToken(), destinationChain, 0, sequence\\n            );\\n\\n            // NOTE: specialized relaying does not currently support refunds. The zero address\\n            // is used as a placeholder for the refund address until support is added.\\n            emit RelayingInfo(uint8(RelayingType.Special), bytes32(0), deliveryFee);\\n        } else {\\n            (transceiverMessage, encodedTransceiverPayload) = TransceiverStructs\\n                .buildAndEncodeTransceiverMessage(\\n                WH_TRANSCEIVER_PAYLOAD_PREFIX,\\n                wormholeFormattedCaller,\\n                recipientNttManagerAddress,\\n                nttManagerMessage,\\n                new bytes(0)\\n            );\\n\\n            wormhole.publishMessage{value: deliveryPayment}(\\n                0, encodedTransceiverPayload, consistencyLevel\\n            );\\n\\n            // NOTE: manual relaying does not currently support refunds. The zero address\\n            // is used as refundAddress.\\n            emit RelayingInfo(uint8(RelayingType.Manual), bytes32(0), deliveryPayment);\\n        }\\n\\n        emit SendTransceiverMessage(recipientChain, transceiverMessage);\\n    }\\n\\n    function _verifyMessage(bytes memory encodedMessage) internal returns (uint16, bytes memory) {\\n        // verify VAA against Wormhole Core Bridge contract\\n        (IWormhole.VM memory vm, bool valid, string memory reason) =\\n            wormhole.parseAndVerifyVM(encodedMessage);\\n\\n        // ensure that the VAA is valid\\n        if (!valid) {\\n            revert InvalidVaa(reason);\\n        }\\n\\n        // ensure that the message came from a registered peer contract\\n        if (!_verifyBridgeVM(vm)) {\\n            revert InvalidWormholePeer(vm.emitterChainId, vm.emitterAddress);\\n        }\\n\\n        // save the VAA hash in storage to protect against replay attacks.\\n        if (isVAAConsumed(vm.hash)) {\\n            revert TransferAlreadyCompleted(vm.hash);\\n        }\\n        _setVAAConsumed(vm.hash);\\n\\n        // emit `ReceivedMessage` event\\n        emit ReceivedMessage(vm.hash, vm.emitterChainId, vm.emitterAddress, vm.sequence);\\n\\n        return (vm.emitterChainId, vm.payload);\\n    }\\n\\n    function _verifyBridgeVM(IWormhole.VM memory vm) internal view returns (bool) {\\n        checkFork(wormholeTransceiver_evmChainId);\\n        return getWormholePeer(vm.emitterChainId) == vm.emitterAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/WormholeRelayerSDK.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"./Chains.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport {Base} from \\\"./Base.sol\\\";\\nimport {TokenBase, TokenReceiver, TokenSender} from \\\"./TokenBase.sol\\\";\\nimport {CCTPBase, CCTPReceiver, CCTPSender} from \\\"./CCTPBase.sol\\\";\\nimport {CCTPAndTokenBase, CCTPAndTokenReceiver, CCTPAndTokenSender} from \\\"./CCTPAndTokenBase.sol\\\";\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/libraries/BytesParsing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nlibrary BytesParsing {\\n  uint256 private constant freeMemoryPtr = 0x40;\\n  uint256 private constant wordSize = 32;\\n\\n  error OutOfBounds(uint256 offset, uint256 length);\\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\\n  error InvalidBoolVal(uint8 val);\\n\\n  function checkBound(uint offset, uint length) internal pure {\\n    if (offset > length)\\n      revert OutOfBounds(offset, length);\\n  }\\n\\n  function checkLength(bytes memory encoded, uint256 expected) internal pure {\\n    if (encoded.length != expected)\\n      revert LengthMismatch(encoded.length, expected);\\n  }\\n\\n  function sliceUnchecked(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    //bail early for degenerate case\\n    if (length == 0)\\n      return (new bytes(0), offset);\\n\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, length)\\n      ret := mload(freeMemoryPtr)\\n\\n      //Explanation on how we copy data here:\\n      //  The bytes type has the following layout in memory:\\n      //    [length: 32 bytes, data: length bytes]\\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\\n      //    will be written into the length part of our `ret` slice.\\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\\n      //    overwritting those garbage bytes.\\n      let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\\n      if iszero(shift) {\\n        shift := wordSize\\n      }\\n\\n      let dest := add(ret, shift)\\n      let end := add(dest, length)\\n      for {\\n        let src := add(add(encoded, shift), offset)\\n      } lt(dest, end) {\\n        src := add(src, wordSize)\\n        dest := add(dest, wordSize)\\n      } {\\n        mstore(dest, mload(src))\\n      }\\n\\n      mstore(ret, length)\\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\\n      //  memory alignment and so we enforce the same memory alignment here.\\n      mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\\n    }\\n  }\\n\\n  function slice(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asAddressUnchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\\n    return (address(ret), nextOffset);\\n  }\\n\\n  function asAddress(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address ret, uint nextOffset) {\\n    (ret, nextOffset) = asAddressUnchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBoolUnchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool, uint) {\\n    (uint8 val, uint nextOffset) = asUint8Unchecked(encoded, offset);\\n    if (val & 0xfe != 0)\\n      revert InvalidBoolVal(val);\\n\\n    uint cleanedVal = uint(val);\\n    bool ret;\\n    //skip 2x iszero opcode\\n    assembly (\\\"memory-safe\\\") {\\n      ret := cleanedVal\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asBool(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool ret, uint nextOffset) {\\n    (ret, nextOffset) = asBoolUnchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n/* -------------------------------------------------------------------------------------------------\\nRemaining library code below was auto-generated by via the following js/node code:\\n\\nfor (let bytes = 1; bytes <= 32; ++bytes) {\\n  const bits = bytes*8;\\n  console.log(\\n`function asUint${bits}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  assembly (\\\"memory-safe\\\") {\\n    nextOffset := add(offset, ${bytes})\\n    ret := mload(add(encoded, nextOffset))\\n  }\\n  return (ret, nextOffset);\\n}\\n\\nfunction asUint${bits}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  checkBound(nextOffset, encoded.length);\\n}\\n\\nfunction asBytes${bytes}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n\\nfunction asBytes${bytes}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n`\\n  );\\n}\\n------------------------------------------------------------------------------------------------- */\\n\\n  function asUint8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 1)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint8Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes1Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8Unchecked(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asBytes1(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asUint16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 2)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint16Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes2Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16Unchecked(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asBytes2(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asUint24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 3)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint24Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes3Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24Unchecked(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asBytes3(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asUint32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 4)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint32Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes4Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32Unchecked(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asBytes4(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asUint40Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 5)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint40(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint40Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes5Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40Unchecked(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asBytes5(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asUint48Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 6)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint48(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint48Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes6Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48Unchecked(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asBytes6(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asUint56Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 7)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint56(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint56Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes7Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56Unchecked(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asBytes7(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asUint64Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 8)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint64(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint64Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64Unchecked(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asBytes8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asUint72Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 9)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint72(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint72Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes9Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72Unchecked(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asBytes9(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asUint80Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 10)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint80(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint80Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes10Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80Unchecked(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asBytes10(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asUint88Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 11)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint88(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint88Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes11Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88Unchecked(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asBytes11(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asUint96Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 12)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint96(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint96Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes12Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96Unchecked(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asBytes12(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asUint104Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 13)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint104(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint104Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes13Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104Unchecked(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asBytes13(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asUint112Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 14)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint112(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint112Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes14Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112Unchecked(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asBytes14(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asUint120Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 15)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint120(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint120Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes15Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120Unchecked(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asBytes15(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asUint128Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 16)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint128(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint128Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128Unchecked(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asBytes16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asUint136Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 17)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint136(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint136Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes17Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136Unchecked(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asBytes17(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asUint144Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 18)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint144(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint144Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes18Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144Unchecked(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asBytes18(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asUint152Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 19)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint152(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint152Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes19Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152Unchecked(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asBytes19(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asUint160Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 20)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint160(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint160Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes20Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asBytes20(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asUint168Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 21)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint168(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint168Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes21Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168Unchecked(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asBytes21(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asUint176Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 22)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint176(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint176Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes22Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176Unchecked(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asBytes22(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asUint184Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 23)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint184(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint184Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes23Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184Unchecked(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asBytes23(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asUint192Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 24)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint192(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint192Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192Unchecked(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asBytes24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asUint200Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 25)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint200(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint200Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes25Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200Unchecked(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asBytes25(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asUint208Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 26)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint208(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint208Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes26Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208Unchecked(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asBytes26(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asUint216Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 27)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint216(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint216Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes27Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216Unchecked(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asBytes27(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asUint224Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 28)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint224(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint224Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes28Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224Unchecked(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asBytes28(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asUint232Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 29)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint232(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint232Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes29Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232Unchecked(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asBytes29(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asUint240Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 30)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint240(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint240Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes30Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240Unchecked(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asBytes30(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asUint248Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 31)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint248(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint248Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes31Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248Unchecked(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asBytes31(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asUint256Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 32)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint256(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint256Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256Unchecked(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n\\n  function asBytes32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IWormhole.sol\": {\r\n      \"content\": \"// contracts/Messages.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWormhole {\\n    struct GuardianSet {\\n        address[] keys;\\n        uint32 expirationTime;\\n    }\\n\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        uint8 guardianIndex;\\n    }\\n\\n    struct VM {\\n        uint8 version;\\n        uint32 timestamp;\\n        uint32 nonce;\\n        uint16 emitterChainId;\\n        bytes32 emitterAddress;\\n        uint64 sequence;\\n        uint8 consistencyLevel;\\n        bytes payload;\\n        uint32 guardianSetIndex;\\n        Signature[] signatures;\\n        bytes32 hash;\\n    }\\n\\n    struct ContractUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        address newContract;\\n    }\\n\\n    struct GuardianSetUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        GuardianSet newGuardianSet;\\n        uint32 newGuardianSetIndex;\\n    }\\n\\n    struct SetMessageFee {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        uint256 messageFee;\\n    }\\n\\n    struct TransferFees {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        uint256 amount;\\n        bytes32 recipient;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event LogMessagePublished(\\n        address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel\\n    );\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n    event GuardianSetAdded(uint32 indexed index);\\n\\n    function publishMessage(uint32 nonce, bytes memory payload, uint8 consistencyLevel)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function initialize() external;\\n\\n    function parseAndVerifyVM(bytes calldata encodedVM)\\n        external\\n        view\\n        returns (VM memory vm, bool valid, string memory reason);\\n\\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\n\\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet)\\n        external\\n        pure\\n        returns (bool valid, string memory reason);\\n\\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\n\\n    function quorum(uint256 numGuardians) external pure returns (uint256 numSignaturesRequiredForQuorum);\\n\\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\\n\\n    function getCurrentGuardianSetIndex() external view returns (uint32);\\n\\n    function getGuardianSetExpiry() external view returns (uint32);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function messageFee() external view returns (uint256);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function nextSequence(address emitter) external view returns (uint64);\\n\\n    function parseContractUpgrade(bytes memory encodedUpgrade) external pure returns (ContractUpgrade memory cu);\\n\\n    function parseGuardianSetUpgrade(bytes memory encodedUpgrade)\\n        external\\n        pure\\n        returns (GuardianSetUpgrade memory gsu);\\n\\n    function parseSetMessageFee(bytes memory encodedSetMessageFee) external pure returns (SetMessageFee memory smf);\\n\\n    function parseTransferFees(bytes memory encodedTransferFees) external pure returns (TransferFees memory tf);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId)\\n        external\\n        pure\\n        returns (RecoverChainId memory rci);\\n\\n    function submitContractUpgrade(bytes memory _vm) external;\\n\\n    function submitSetMessageFee(bytes memory _vm) external;\\n\\n    function submitNewGuardianSet(bytes memory _vm) external;\\n\\n    function submitTransferFees(bytes memory _vm) external;\\n\\n    function submitRecoverChainId(bytes memory _vm) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/TransceiverHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nerror InvalidFork(uint256 evmChainId, uint256 blockChainId);\\n\\nfunction checkFork(uint256 evmChainId) view {\\n    if (isFork(evmChainId)) {\\n        revert InvalidFork(evmChainId, block.chainid);\\n    }\\n}\\n\\nfunction isFork(uint256 evmChainId) view returns (bool) {\\n    return evmChainId != block.chainid;\\n}\\n\\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\\n    return a < b ? a : b;\\n}\\n\\n// @dev Count the number of set bits in a uint64\\nfunction countSetBits(uint64 x) pure returns (uint8 count) {\\n    while (x != 0) {\\n        x &= x - 1;\\n        count++;\\n    }\\n\\n    return count;\\n}\\n\"\r\n    },\r\n    \"src/libraries/TransceiverStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"wormhole-solidity-sdk/libraries/BytesParsing.sol\\\";\\nimport \\\"./TrimmedAmount.sol\\\";\\n\\nlibrary TransceiverStructs {\\n    using BytesParsing for bytes;\\n    using TrimmedAmountLib for TrimmedAmount;\\n\\n    /// @notice Error thrown when the payload length exceeds the allowed maximum.\\n    /// @dev Selector 0xa3419691.\\n    /// @param size The size of the payload.\\n    error PayloadTooLong(uint256 size);\\n\\n    /// @notice Error thrown when the prefix of an encoded message\\n    ///         does not match the expected value.\\n    /// @dev Selector 0x56d2569d.\\n    /// @param prefix The prefix that was found in the encoded message.\\n    error IncorrectPrefix(bytes4 prefix);\\n\\n    /// @notice Error thrown when the transceiver instructions aren't\\n    ///         encoded with strictly increasing indices\\n    /// @dev Selector 0x0555a4b9.\\n    /// @param lastIndex Last parsed instruction index\\n    /// @param instructionIndex The instruction index that was unordered\\n    error UnorderedInstructions(uint256 lastIndex, uint256 instructionIndex);\\n\\n    /// @notice Error thrown when a transceiver instruction index\\n    ///         is greater than the number of registered transceivers\\n    /// @dev We index from 0 so if providedIndex == numTransceivers then we're out-of-bounds too\\n    /// @dev Selector 0x689f5016.\\n    /// @param providedIndex The index specified in the instruction\\n    /// @param numTransceivers The number of registered transceivers\\n    error InvalidInstructionIndex(uint256 providedIndex, uint256 numTransceivers);\\n\\n    /// @dev Prefix for all NativeTokenTransfer payloads\\n    ///      This is 0x99'N''T''T'\\n    bytes4 constant NTT_PREFIX = 0x994E5454;\\n\\n    /// @dev Message emitted and received by the nttManager contract.\\n    ///      The wire format is as follows:\\n    ///      - id - 32 bytes\\n    ///      - sender - 32 bytes\\n    ///      - payloadLength - 2 bytes\\n    ///      - payload - `payloadLength` bytes\\n    struct NttManagerMessage {\\n        /// @notice unique message identifier\\n        /// @dev This is incrementally assigned on EVM chains, but this is not\\n        /// guaranteed on other runtimes.\\n        bytes32 id;\\n        /// @notice original message sender address.\\n        bytes32 sender;\\n        /// @notice payload that corresponds to the type.\\n        bytes payload;\\n    }\\n\\n    function nttManagerMessageDigest(\\n        uint16 sourceChainId,\\n        NttManagerMessage memory m\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(sourceChainId, encodeNttManagerMessage(m)));\\n    }\\n\\n    function encodeNttManagerMessage(NttManagerMessage memory m)\\n        public\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        if (m.payload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.payload.length);\\n        }\\n        uint16 payloadLength = uint16(m.payload.length);\\n        return abi.encodePacked(m.id, m.sender, payloadLength, m.payload);\\n    }\\n\\n    /// @notice Parse a NttManagerMessage.\\n    /// @param encoded The byte array corresponding to the encoded message\\n    /// @return nttManagerMessage The parsed NttManagerMessage struct.\\n    function parseNttManagerMessage(bytes memory encoded)\\n        public\\n        pure\\n        returns (NttManagerMessage memory nttManagerMessage)\\n    {\\n        uint256 offset = 0;\\n        (nttManagerMessage.id, offset) = encoded.asBytes32Unchecked(offset);\\n        (nttManagerMessage.sender, offset) = encoded.asBytes32Unchecked(offset);\\n        uint256 payloadLength;\\n        (payloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (nttManagerMessage.payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Native Token Transfer payload.\\n    ///      The wire format is as follows:\\n    ///      - NTT_PREFIX - 4 bytes\\n    ///      - numDecimals - 1 byte\\n    ///      - amount - 8 bytes\\n    ///      - sourceToken - 32 bytes\\n    ///      - to - 32 bytes\\n    ///      - toChain - 2 bytes\\n    struct NativeTokenTransfer {\\n        /// @notice Amount being transferred (big-endian u64 and u8 for decimals)\\n        TrimmedAmount amount;\\n        /// @notice Source chain token address.\\n        bytes32 sourceToken;\\n        /// @notice Address of the recipient.\\n        bytes32 to;\\n        /// @notice Chain ID of the recipient\\n        uint16 toChain;\\n    }\\n\\n    function encodeNativeTokenTransfer(NativeTokenTransfer memory m)\\n        public\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        // The `amount` and `decimals` fields are encoded in reverse order compared to how they are declared in the\\n        // `TrimmedAmount` type. This is consistent with the Rust NTT implementation.\\n        TrimmedAmount transferAmount = m.amount;\\n        return abi.encodePacked(\\n            NTT_PREFIX,\\n            transferAmount.getDecimals(),\\n            transferAmount.getAmount(),\\n            m.sourceToken,\\n            m.to,\\n            m.toChain\\n        );\\n    }\\n\\n    /// @dev Parse a NativeTokenTransfer.\\n    /// @param encoded The byte array corresponding to the encoded message\\n    /// @return nativeTokenTransfer The parsed NativeTokenTransfer struct.\\n    function parseNativeTokenTransfer(bytes memory encoded)\\n        public\\n        pure\\n        returns (NativeTokenTransfer memory nativeTokenTransfer)\\n    {\\n        uint256 offset = 0;\\n        bytes4 prefix;\\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\\n        if (prefix != NTT_PREFIX) {\\n            revert IncorrectPrefix(prefix);\\n        }\\n\\n        // The `amount` and `decimals` fields are parsed in reverse order compared to how they are declared in the\\n        // `TrimmedAmount` struct. This is consistent with the Rust NTT implementation.\\n        uint8 numDecimals;\\n        (numDecimals, offset) = encoded.asUint8Unchecked(offset);\\n        uint64 amount;\\n        (amount, offset) = encoded.asUint64Unchecked(offset);\\n        nativeTokenTransfer.amount = packTrimmedAmount(amount, numDecimals);\\n\\n        (nativeTokenTransfer.sourceToken, offset) = encoded.asBytes32Unchecked(offset);\\n        (nativeTokenTransfer.to, offset) = encoded.asBytes32Unchecked(offset);\\n        (nativeTokenTransfer.toChain, offset) = encoded.asUint16Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Message emitted by Transceiver implementations.\\n    ///      Each message includes an Transceiver-specified 4-byte prefix.\\n    ///      The wire format is as follows:\\n    ///      - prefix - 4 bytes\\n    ///      - sourceNttManagerAddress - 32 bytes\\n    ///      - recipientNttManagerAddress - 32 bytes\\n    ///      - nttManagerPayloadLength - 2 bytes\\n    ///      - nttManagerPayload - `nttManagerPayloadLength` bytes\\n    ///      - transceiverPayloadLength - 2 bytes\\n    ///      - transceiverPayload - `transceiverPayloadLength` bytes\\n    struct TransceiverMessage {\\n        /// @notice Address of the NttManager contract that emitted this message.\\n        bytes32 sourceNttManagerAddress;\\n        /// @notice Address of the NttManager contract that receives this message.\\n        bytes32 recipientNttManagerAddress;\\n        /// @notice Payload provided to the Transceiver contract by the NttManager contract.\\n        bytes nttManagerPayload;\\n        /// @notice Optional payload that the transceiver can encode and use for its own message passing purposes.\\n        bytes transceiverPayload;\\n    }\\n\\n    // @notice Encodes an Transceiver message for communication between the\\n    //         NttManager and the Transceiver.\\n    // @param m The TransceiverMessage struct containing the message details.\\n    // @return encoded The byte array corresponding to the encoded message.\\n    // @custom:throw PayloadTooLong if the length of transceiverId, nttManagerPayload,\\n    //         or transceiverPayload exceeds the allowed maximum.\\n    function encodeTransceiverMessage(\\n        bytes4 prefix,\\n        TransceiverMessage memory m\\n    ) public pure returns (bytes memory encoded) {\\n        if (m.nttManagerPayload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.nttManagerPayload.length);\\n        }\\n        uint16 nttManagerPayloadLength = uint16(m.nttManagerPayload.length);\\n\\n        if (m.transceiverPayload.length > type(uint16).max) {\\n            revert PayloadTooLong(m.transceiverPayload.length);\\n        }\\n        uint16 transceiverPayloadLength = uint16(m.transceiverPayload.length);\\n\\n        return abi.encodePacked(\\n            prefix,\\n            m.sourceNttManagerAddress,\\n            m.recipientNttManagerAddress,\\n            nttManagerPayloadLength,\\n            m.nttManagerPayload,\\n            transceiverPayloadLength,\\n            m.transceiverPayload\\n        );\\n    }\\n\\n    function buildAndEncodeTransceiverMessage(\\n        bytes4 prefix,\\n        bytes32 sourceNttManagerAddress,\\n        bytes32 recipientNttManagerAddress,\\n        bytes memory nttManagerMessage,\\n        bytes memory transceiverPayload\\n    ) public pure returns (TransceiverMessage memory, bytes memory) {\\n        TransceiverMessage memory transceiverMessage = TransceiverMessage({\\n            sourceNttManagerAddress: sourceNttManagerAddress,\\n            recipientNttManagerAddress: recipientNttManagerAddress,\\n            nttManagerPayload: nttManagerMessage,\\n            transceiverPayload: transceiverPayload\\n        });\\n        bytes memory encoded = encodeTransceiverMessage(prefix, transceiverMessage);\\n        return (transceiverMessage, encoded);\\n    }\\n\\n    /// @dev Parses an encoded message and extracts information into an TransceiverMessage struct.\\n    /// @param encoded The encoded bytes containing information about the TransceiverMessage.\\n    /// @return transceiverMessage The parsed TransceiverMessage struct.\\n    /// @custom:throw IncorrectPrefix if the prefix of the encoded message does not\\n    ///         match the expected prefix.\\n    function parseTransceiverMessage(\\n        bytes4 expectedPrefix,\\n        bytes memory encoded\\n    ) internal pure returns (TransceiverMessage memory transceiverMessage) {\\n        uint256 offset = 0;\\n        bytes4 prefix;\\n\\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\\n\\n        if (prefix != expectedPrefix) {\\n            revert IncorrectPrefix(prefix);\\n        }\\n\\n        (transceiverMessage.sourceNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (transceiverMessage.recipientNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        uint16 nttManagerPayloadLength;\\n        (nttManagerPayloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (transceiverMessage.nttManagerPayload, offset) =\\n            encoded.sliceUnchecked(offset, nttManagerPayloadLength);\\n        uint16 transceiverPayloadLength;\\n        (transceiverPayloadLength, offset) = encoded.asUint16Unchecked(offset);\\n        (transceiverMessage.transceiverPayload, offset) =\\n            encoded.sliceUnchecked(offset, transceiverPayloadLength);\\n\\n        // Check if the entire byte array has been processed\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Parses the payload of an Transceiver message and returns\\n    ///      the parsed NttManagerMessage struct.\\n    /// @param expectedPrefix The prefix that should be encoded in the nttManager message.\\n    /// @param payload The payload sent across the wire.\\n    function parseTransceiverAndNttManagerMessage(\\n        bytes4 expectedPrefix,\\n        bytes memory payload\\n    ) public pure returns (TransceiverMessage memory, NttManagerMessage memory) {\\n        // parse the encoded message payload from the Transceiver\\n        TransceiverMessage memory parsedTransceiverMessage =\\n            parseTransceiverMessage(expectedPrefix, payload);\\n\\n        // parse the encoded message payload from the NttManager\\n        NttManagerMessage memory parsedNttManagerMessage =\\n            parseNttManagerMessage(parsedTransceiverMessage.nttManagerPayload);\\n\\n        return (parsedTransceiverMessage, parsedNttManagerMessage);\\n    }\\n\\n    /// @dev Variable-length transceiver-specific instruction that can be passed by the caller to the nttManager.\\n    ///      The index field refers to the index of the registeredTransceiver that this instruction should be passed to.\\n    ///      The serialization format is:\\n    ///      - index - 1 byte\\n    ///      - payloadLength - 1 byte\\n    ///      - payload - `payloadLength` bytes\\n    struct TransceiverInstruction {\\n        uint8 index;\\n        bytes payload;\\n    }\\n\\n    function encodeTransceiverInstruction(TransceiverInstruction memory instruction)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (instruction.payload.length > type(uint8).max) {\\n            revert PayloadTooLong(instruction.payload.length);\\n        }\\n        uint8 payloadLength = uint8(instruction.payload.length);\\n        return abi.encodePacked(instruction.index, payloadLength, instruction.payload);\\n    }\\n\\n    function parseTransceiverInstructionUnchecked(\\n        bytes memory encoded,\\n        uint256 offset\\n    ) public pure returns (TransceiverInstruction memory instruction, uint256 nextOffset) {\\n        (instruction.index, nextOffset) = encoded.asUint8Unchecked(offset);\\n        uint8 instructionLength;\\n        (instructionLength, nextOffset) = encoded.asUint8Unchecked(nextOffset);\\n        (instruction.payload, nextOffset) = encoded.sliceUnchecked(nextOffset, instructionLength);\\n    }\\n\\n    function parseTransceiverInstructionChecked(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverInstruction memory instruction)\\n    {\\n        uint256 offset = 0;\\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    /// @dev Encode an array of multiple variable-length transceiver-specific instructions.\\n    ///      The serialization format is:\\n    ///      - instructionsLength - 1 byte\\n    ///      - `instructionsLength` number of serialized `TransceiverInstruction` types.\\n    function encodeTransceiverInstructions(TransceiverInstruction[] memory instructions)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (instructions.length > type(uint8).max) {\\n            revert PayloadTooLong(instructions.length);\\n        }\\n        uint256 instructionsLength = instructions.length;\\n\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < instructionsLength; i++) {\\n            bytes memory innerEncoded = encodeTransceiverInstruction(instructions[i]);\\n            encoded = bytes.concat(encoded, innerEncoded);\\n        }\\n        return abi.encodePacked(uint8(instructionsLength), encoded);\\n    }\\n\\n    function parseTransceiverInstructions(\\n        bytes memory encoded,\\n        uint256 numRegisteredTransceivers\\n    ) public pure returns (TransceiverInstruction[] memory) {\\n        uint256 offset = 0;\\n        uint256 instructionsLength;\\n        (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\\n\\n        // We allocate an array with the length of the number of registered transceivers\\n        // This gives us the flexibility to not have to pass instructions for transceivers that\\n        // don't need them\\n        TransceiverInstruction[] memory instructions =\\n            new TransceiverInstruction[](numRegisteredTransceivers);\\n\\n        uint256 lastIndex = 0;\\n        for (uint256 i = 0; i < instructionsLength; i++) {\\n            TransceiverInstruction memory instruction;\\n            (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\\n\\n            uint8 instructionIndex = instruction.index;\\n\\n            // The instructions passed in have to be strictly increasing in terms of transceiver index\\n            if (i != 0 && instructionIndex <= lastIndex) {\\n                revert UnorderedInstructions(lastIndex, instructionIndex);\\n            }\\n\\n            // Instruction index is out of bounds\\n            if (instructionIndex >= numRegisteredTransceivers) {\\n                revert InvalidInstructionIndex(instructionIndex, numRegisteredTransceivers);\\n            }\\n\\n            lastIndex = instructionIndex;\\n\\n            instructions[instructionIndex] = instruction;\\n        }\\n\\n        encoded.checkLength(offset);\\n\\n        return instructions;\\n    }\\n\\n    struct TransceiverInit {\\n        bytes4 transceiverIdentifier;\\n        bytes32 nttManagerAddress;\\n        uint8 nttManagerMode;\\n        bytes32 tokenAddress;\\n        uint8 tokenDecimals;\\n    }\\n\\n    function encodeTransceiverInit(TransceiverInit memory init)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            init.transceiverIdentifier,\\n            init.nttManagerAddress,\\n            init.nttManagerMode,\\n            init.tokenAddress,\\n            init.tokenDecimals\\n        );\\n    }\\n\\n    function decodeTransceiverInit(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverInit memory init)\\n    {\\n        uint256 offset = 0;\\n        (init.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\\n        (init.nttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (init.nttManagerMode, offset) = encoded.asUint8Unchecked(offset);\\n        (init.tokenAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (init.tokenDecimals, offset) = encoded.asUint8Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n\\n    struct TransceiverRegistration {\\n        bytes4 transceiverIdentifier;\\n        uint16 transceiverChainId;\\n        bytes32 transceiverAddress;\\n    }\\n\\n    function encodeTransceiverRegistration(TransceiverRegistration memory registration)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            registration.transceiverIdentifier,\\n            registration.transceiverChainId,\\n            registration.transceiverAddress\\n        );\\n    }\\n\\n    function decodeTransceiverRegistration(bytes memory encoded)\\n        public\\n        pure\\n        returns (TransceiverRegistration memory registration)\\n    {\\n        uint256 offset = 0;\\n        (registration.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\\n        (registration.transceiverChainId, offset) = encoded.asUint16Unchecked(offset);\\n        (registration.transceiverAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        encoded.checkLength(offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWormholeTransceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\n\\nimport \\\"./IWormholeTransceiverState.sol\\\";\\n\\ninterface IWormholeTransceiver is IWormholeTransceiverState {\\n    /// @notice The instruction for the WormholeTransceiver contract\\n    ///         to skip delivery via the relayer.\\n    struct WormholeTransceiverInstruction {\\n        bool shouldSkipRelayerSend;\\n    }\\n\\n    /// @notice Emitted when a relayed message is received.\\n    /// @dev Topic0\\n    ///      0xf557dbbb087662f52c815f6c7ee350628a37a51eae9608ff840d996b65f87475\\n    /// @param digest The digest of the message.\\n    /// @param emitterChainId The chain ID of the emitter.\\n    /// @param emitterAddress The address of the emitter.\\n    event ReceivedRelayedMessage(bytes32 digest, uint16 emitterChainId, bytes32 emitterAddress);\\n\\n    /// @notice Emitted when a message is received.\\n    /// @dev Topic0\\n    ///     0xf6fc529540981400dc64edf649eb5e2e0eb5812a27f8c81bac2c1d317e71a5f0.\\n    /// @param digest The digest of the message.\\n    /// @param emitterChainId The chain ID of the emitter.\\n    /// @param emitterAddress The address of the emitter.\\n    /// @param sequence The sequence of the message.\\n    event ReceivedMessage(\\n        bytes32 digest, uint16 emitterChainId, bytes32 emitterAddress, uint64 sequence\\n    );\\n\\n    /// @notice Emitted when a message is sent from the transceiver.\\n    /// @dev Topic0\\n    ///      0x53b3e029c5ead7bffc739118953883859d30b1aaa086e0dca4d0a1c99cd9c3f5.\\n    /// @param recipientChain The chain ID of the recipient.\\n    /// @param message The message.\\n    event SendTransceiverMessage(\\n        uint16 recipientChain, TransceiverStructs.TransceiverMessage message\\n    );\\n\\n    /// @notice Error when the relaying configuration is invalid. (e.g. chainId is not registered)\\n    /// @dev Selector: 0x9449a36c.\\n    /// @param chainId The chain ID that is invalid.\\n    error InvalidRelayingConfig(uint16 chainId);\\n\\n    /// @notice Error when the peer transceiver is invalid.\\n    /// @dev Selector: 0x79b1ce56.\\n    /// @param chainId The chain ID of the peer.\\n    /// @param peerAddress The address of the invalid peer.\\n    error InvalidWormholePeer(uint16 chainId, bytes32 peerAddress);\\n\\n    /// @notice Error when the VAA has already been consumed.\\n    /// @dev Selector: 0x406e719e.\\n    /// @param vaaHash The hash of the VAA.\\n    error TransferAlreadyCompleted(bytes32 vaaHash);\\n\\n    /// @notice Receive an attested message from the verification layer.\\n    ///         This function should verify the `encodedVm` and then deliver the attestation\\n    /// to the transceiver NttManager contract.\\n    /// @param encodedMessage The attested message.\\n    function receiveMessage(bytes memory encodedMessage) external;\\n\\n    /// @notice Parses the encoded instruction and returns the instruction struct.\\n    ///         This instruction is specific to the WormholeTransceiver contract.\\n    /// @param encoded The encoded instruction.\\n    /// @return instruction The parsed `WormholeTransceiverInstruction`.\\n    function parseWormholeTransceiverInstruction(bytes memory encoded)\\n        external\\n        pure\\n        returns (WormholeTransceiverInstruction memory instruction);\\n\\n    /// @notice Encodes the `WormholeTransceiverInstruction` into a byte array.\\n    /// @param instruction The `WormholeTransceiverInstruction` to encode.\\n    /// @return encoded The encoded instruction.\\n    function encodeWormholeTransceiverInstruction(WormholeTransceiverInstruction memory instruction)\\n        external\\n        pure\\n        returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISpecialRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\ninterface ISpecialRelayer {\\n    function quoteDeliveryPrice(\\n        address sourceContract,\\n        uint16 targetChain,\\n        uint256 additionalValue\\n    ) external view returns (uint256 nativePriceQuote);\\n\\n    function requestDelivery(\\n        address sourceContract,\\n        uint16 targetChain,\\n        uint256 additionalValue,\\n        uint64 sequence\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INttManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"../libraries/TrimmedAmount.sol\\\";\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\n\\nimport \\\"./IManagerBase.sol\\\";\\n\\ninterface INttManager is IManagerBase {\\n    /// @dev The peer on another chain.\\n    struct NttManagerPeer {\\n        bytes32 peerAddress;\\n        uint8 tokenDecimals;\\n    }\\n\\n    /// @notice Emitted when a message is sent from the nttManager.\\n    /// @dev Topic0\\n    ///      0x9cc8ade41ef46b98ba8bcad8c6bfa643934e6b84d3ce066cd38b5f0813bb2ae5.\\n    /// @param recipient The recipient of the message.\\n    /// @param refundAddress The address on the destination chain to which the\\n    ///                      refund of unused gas will be paid\\n    /// @param amount The amount transferred.\\n    /// @param fee The amount of ether sent along with the tx to cover the delivery fee.\\n    /// @param recipientChain The chain ID of the recipient.\\n    /// @param msgSequence The unique sequence ID of the message.\\n    event TransferSent(\\n        bytes32 recipient,\\n        bytes32 refundAddress,\\n        uint256 amount,\\n        uint256 fee,\\n        uint16 recipientChain,\\n        uint64 msgSequence\\n    );\\n\\n    /// @notice Emitted when the peer contract is updated.\\n    /// @dev Topic0\\n    ///      0x1456404e7f41f35c3daac941bb50bad417a66275c3040061b4287d787719599d.\\n    /// @param chainId_ The chain ID of the peer contract.\\n    /// @param oldPeerContract The old peer contract address.\\n    /// @param oldPeerDecimals The old peer contract decimals.\\n    /// @param peerContract The new peer contract address.\\n    /// @param peerDecimals The new peer contract decimals.\\n    event PeerUpdated(\\n        uint16 indexed chainId_,\\n        bytes32 oldPeerContract,\\n        uint8 oldPeerDecimals,\\n        bytes32 peerContract,\\n        uint8 peerDecimals\\n    );\\n\\n    /// @notice Emitted when a transfer has been redeemed\\n    ///         (either minted or unlocked on the recipient chain).\\n    /// @dev Topic0\\n    ///      0x504e6efe18ab9eed10dc6501a417f5b12a2f7f2b1593aed9b89f9bce3cf29a91.\\n    /// @param digest The digest of the message.\\n    event TransferRedeemed(bytes32 indexed digest);\\n\\n    /// @notice Emitted when an outbound transfer has been cancelled\\n    /// @dev Topic0\\n    ///      0xf80e572ae1b63e2449629b6c7d783add85c36473926f216077f17ee002bcfd07.\\n    /// @param sequence The sequence number being cancelled\\n    /// @param recipient The canceller and recipient of the funds\\n    /// @param amount The amount of the transfer being cancelled\\n    event OutboundTransferCancelled(uint256 sequence, address recipient, uint256 amount);\\n\\n    /// @notice The transfer has some dust.\\n    /// @dev Selector 0x71f0634a\\n    /// @dev This is a security measure to prevent users from losing funds.\\n    ///      This is the result of trimming the amount and then untrimming it.\\n    /// @param  amount The amount to transfer.\\n    error TransferAmountHasDust(uint256 amount, uint256 dust);\\n\\n    /// @notice The mode is invalid. It is neither in LOCKING or BURNING mode.\\n    /// @dev Selector 0x66001a89\\n    /// @param mode The mode.\\n    error InvalidMode(uint8 mode);\\n\\n    /// @notice Error when trying to execute a message on an unintended target chain.\\n    /// @dev Selector 0x3dcb204a.\\n    /// @param targetChain The target chain.\\n    /// @param thisChain The current chain.\\n    error InvalidTargetChain(uint16 targetChain, uint16 thisChain);\\n\\n    /// @notice Error when the transfer amount is zero.\\n    /// @dev Selector 0x9993626a.\\n    error ZeroAmount();\\n\\n    /// @notice Error when the recipient is invalid.\\n    /// @dev Selector 0x9c8d2cd2.\\n    error InvalidRecipient();\\n\\n    /// @notice Error when the recipient is invalid.\\n    /// @dev Selector 0xe2fe2726.\\n    error InvalidRefundAddress();\\n\\n    /// @notice Error when the amount burned is different than the balance difference,\\n    ///         since NTT does not support burn fees.\\n    /// @dev Selector 0x02156a8f.\\n    /// @param burnAmount The amount burned.\\n    /// @param balanceDiff The balance after burning.\\n    error BurnAmountDifferentThanBalanceDiff(uint256 burnAmount, uint256 balanceDiff);\\n\\n    /// @notice The caller is not the deployer.\\n    error UnexpectedDeployer(address expectedOwner, address owner);\\n\\n    /// @notice Peer for the chain does not match the configuration.\\n    /// @param chainId ChainId of the source chain.\\n    /// @param peerAddress Address of the peer nttManager contract.\\n    error InvalidPeer(uint16 chainId, bytes32 peerAddress);\\n\\n    /// @notice Peer chain ID cannot be zero.\\n    error InvalidPeerChainIdZero();\\n\\n    /// @notice Peer cannot be the zero address.\\n    error InvalidPeerZeroAddress();\\n\\n    /// @notice Peer cannot have zero decimals.\\n    error InvalidPeerDecimals();\\n\\n    /// @notice Staticcall reverted\\n    /// @dev Selector 0x1222cd83\\n    error StaticcallFailed();\\n\\n    /// @notice Error when someone other than the original sender tries to cancel a queued outbound transfer.\\n    /// @dev Selector 0xceb40a85.\\n    /// @param canceller The address trying to cancel the transfer.\\n    /// @param sender The original sender that initiated the transfer that was queued.\\n    error CancellerNotSender(address canceller, address sender);\\n\\n    /// @notice An unexpected msg.value was passed with the call\\n    /// @dev Selector 0xbd28e889.\\n    error UnexpectedMsgValue();\\n\\n    /// @notice Peer cannot be on the same chain\\n    /// @dev Selector 0x20371f2a.\\n    error InvalidPeerSameChainId();\\n\\n    /// @notice Transfer a given amount to a recipient on a given chain. This function is called\\n    ///         by the user to send the token cross-chain. This function will either lock or burn the\\n    ///         sender's tokens. Finally, this function will call into registered `Endpoint` contracts\\n    ///         to send a message with the incrementing sequence number and the token transfer payload.\\n    /// @param amount The amount to transfer.\\n    /// @param recipientChain The chain ID for the destination.\\n    /// @param recipient The recipient address.\\n    function transfer(\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient\\n    ) external payable returns (uint64 msgId);\\n\\n    /// @notice Transfer a given amount to a recipient on a given chain. This function is called\\n    ///         by the user to send the token cross-chain. This function will either lock or burn the\\n    ///         sender's tokens. Finally, this function will call into registered `Endpoint` contracts\\n    ///         to send a message with the incrementing sequence number and the token transfer payload.\\n    /// @dev Transfers are queued if the outbound limit is hit and must be completed by the client.\\n    /// @param amount The amount to transfer.\\n    /// @param recipientChain The chain ID for the destination.\\n    /// @param recipient The recipient address.\\n    /// @param refundAddress The address to which a refund for unussed gas is issued on the recipient chain.\\n    /// @param shouldQueue Whether the transfer should be queued if the outbound limit is hit.\\n    /// @param encodedInstructions Additional instructions to be forwarded to the recipient chain.\\n    function transfer(\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient,\\n        bytes32 refundAddress,\\n        bool shouldQueue,\\n        bytes memory encodedInstructions\\n    ) external payable returns (uint64 msgId);\\n\\n    /// @notice Complete an outbound transfer that's been queued.\\n    /// @dev This method is called by the client to complete an outbound transfer that's been queued.\\n    /// @param queueSequence The sequence of the message in the queue.\\n    /// @return msgSequence The sequence of the message.\\n    function completeOutboundQueuedTransfer(uint64 queueSequence)\\n        external\\n        payable\\n        returns (uint64 msgSequence);\\n\\n    /// @notice Cancels an outbound transfer that's been queued.\\n    /// @dev This method is called by the client to cancel an outbound transfer that's been queued.\\n    /// @param queueSequence The sequence of the message in the queue.\\n    function cancelOutboundQueuedTransfer(uint64 queueSequence) external;\\n\\n    /// @notice Complete an inbound queued transfer.\\n    /// @param digest The digest of the message to complete.\\n    function completeInboundQueuedTransfer(bytes32 digest) external;\\n\\n    /// @notice Called by an Endpoint contract to deliver a verified attestation.\\n    /// @dev This function enforces attestation threshold and replay logic for messages. Once all\\n    ///      validations are complete, this function calls `executeMsg` to execute the command specified\\n    ///      by the message.\\n    /// @param sourceChainId The chain id of the sender.\\n    /// @param sourceNttManagerAddress The address of the sender's nttManager contract.\\n    /// @param payload The VAA payload.\\n    function attestationReceived(\\n        uint16 sourceChainId,\\n        bytes32 sourceNttManagerAddress,\\n        TransceiverStructs.NttManagerMessage memory payload\\n    ) external;\\n\\n    /// @notice Called after a message has been sufficiently verified to execute\\n    ///         the command in the message. This function will decode the payload\\n    ///         as an NttManagerMessage to extract the sequence, msgType, and other parameters.\\n    /// @dev This function is exposed as a fallback for when an `Transceiver` is deregistered\\n    ///      when a message is in flight.\\n    /// @param sourceChainId The chain id of the sender.\\n    /// @param sourceNttManagerAddress The address of the sender's nttManager contract.\\n    /// @param message The message to execute.\\n    function executeMsg(\\n        uint16 sourceChainId,\\n        bytes32 sourceNttManagerAddress,\\n        TransceiverStructs.NttManagerMessage memory message\\n    ) external;\\n\\n    /// @notice Returns the number of decimals of the token managed by the NttManager.\\n    /// @return decimals The number of decimals of the token.\\n    function tokenDecimals() external view returns (uint8);\\n\\n    /// @notice Returns registered peer contract for a given chain.\\n    /// @param chainId_ chain ID.\\n    function getPeer(uint16 chainId_) external view returns (NttManagerPeer memory);\\n\\n    /// @notice Sets the corresponding peer.\\n    /// @dev The nttManager that executes the message sets the source nttManager as the peer.\\n    /// @param peerChainId The chain ID of the peer.\\n    /// @param peerContract The address of the peer nttManager contract.\\n    /// @param decimals The number of decimals of the token on the peer chain.\\n    /// @param inboundLimit The inbound rate limit for the peer chain id\\n    function setPeer(\\n        uint16 peerChainId,\\n        bytes32 peerContract,\\n        uint8 decimals,\\n        uint256 inboundLimit\\n    ) external;\\n\\n    /// @notice Sets the outbound transfer limit for a given chain.\\n    /// @dev This method can only be executed by the `owner`.\\n    /// @param limit The new outbound limit.\\n    function setOutboundLimit(uint256 limit) external;\\n\\n    /// @notice Sets the inbound transfer limit for a given chain.\\n    /// @dev This method can only be executed by the `owner`.\\n    /// @param limit The new limit.\\n    /// @param chainId The chain to set the limit for.\\n    function setInboundLimit(uint256 limit, uint16 chainId) external;\\n}\\n\"\r\n    },\r\n    \"src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"wormhole-solidity-sdk/WormholeRelayerSDK.sol\\\";\\nimport \\\"wormhole-solidity-sdk/libraries/BytesParsing.sol\\\";\\nimport \\\"wormhole-solidity-sdk/interfaces/IWormhole.sol\\\";\\n\\nimport \\\"../../libraries/TransceiverHelpers.sol\\\";\\nimport \\\"../../libraries/BooleanFlag.sol\\\";\\nimport \\\"../../libraries/TransceiverStructs.sol\\\";\\n\\nimport \\\"../../interfaces/IWormholeTransceiver.sol\\\";\\nimport \\\"../../interfaces/IWormholeTransceiverState.sol\\\";\\nimport \\\"../../interfaces/ISpecialRelayer.sol\\\";\\nimport \\\"../../interfaces/INttManager.sol\\\";\\n\\nimport \\\"../Transceiver.sol\\\";\\n\\nabstract contract WormholeTransceiverState is IWormholeTransceiverState, Transceiver {\\n    using BytesParsing for bytes;\\n    using BooleanFlagLib for bool;\\n    using BooleanFlagLib for BooleanFlag;\\n\\n    // ==================== Immutables ===============================================\\n    uint8 public immutable consistencyLevel;\\n    IWormhole public immutable wormhole;\\n    IWormholeRelayer public immutable wormholeRelayer;\\n    ISpecialRelayer public immutable specialRelayer;\\n    uint256 immutable wormholeTransceiver_evmChainId;\\n    uint256 public immutable gasLimit;\\n\\n    // ==================== Constants ================================================\\n\\n    /// @dev Prefix for all TransceiverMessage payloads\\n    ///      This is 0x99'E''W''H'\\n    /// @notice Magic string (constant value set by messaging provider) that idenfies the payload as an transceiver-emitted payload.\\n    ///         Note that this is not a security critical field. It's meant to be used by messaging providers to identify which messages are Transceiver-related.\\n    bytes4 constant WH_TRANSCEIVER_PAYLOAD_PREFIX = 0x9945FF10;\\n\\n    /// @dev Prefix for all Wormhole transceiver initialisation payloads\\n    ///      This is bytes4(keccak256(\\\"WormholeTransceiverInit\\\"))\\n    bytes4 constant WH_TRANSCEIVER_INIT_PREFIX = 0x9c23bd3b;\\n\\n    /// @dev Prefix for all Wormhole peer registration payloads\\n    ///      This is bytes4(keccak256(\\\"WormholePeerRegistration\\\"))\\n    bytes4 constant WH_PEER_REGISTRATION_PREFIX = 0x18fc67c2;\\n\\n    constructor(\\n        address nttManager,\\n        address wormholeCoreBridge,\\n        address wormholeRelayerAddr,\\n        address specialRelayerAddr,\\n        uint8 _consistencyLevel,\\n        uint256 _gasLimit\\n    ) Transceiver(nttManager) {\\n        wormhole = IWormhole(wormholeCoreBridge);\\n        wormholeRelayer = IWormholeRelayer(wormholeRelayerAddr);\\n        specialRelayer = ISpecialRelayer(specialRelayerAddr);\\n        wormholeTransceiver_evmChainId = block.chainid;\\n        consistencyLevel = _consistencyLevel;\\n        gasLimit = _gasLimit;\\n    }\\n\\n    enum RelayingType {\\n        Standard,\\n        Special,\\n        Manual\\n    }\\n\\n    function _initialize() internal override {\\n        super._initialize();\\n        _initializeTransceiver();\\n    }\\n\\n    function _initializeTransceiver() internal {\\n        TransceiverStructs.TransceiverInit memory init = TransceiverStructs.TransceiverInit({\\n            transceiverIdentifier: WH_TRANSCEIVER_INIT_PREFIX,\\n            nttManagerAddress: toWormholeFormat(nttManager),\\n            nttManagerMode: INttManager(nttManager).getMode(),\\n            tokenAddress: toWormholeFormat(nttManagerToken),\\n            tokenDecimals: INttManager(nttManager).tokenDecimals()\\n        });\\n        wormhole.publishMessage{value: msg.value}(\\n            0, TransceiverStructs.encodeTransceiverInit(init), consistencyLevel\\n        );\\n    }\\n\\n    function _checkImmutables() internal view override {\\n        super._checkImmutables();\\n        assert(this.wormhole() == wormhole);\\n        assert(this.wormholeRelayer() == wormholeRelayer);\\n        assert(this.specialRelayer() == specialRelayer);\\n        assert(this.consistencyLevel() == consistencyLevel);\\n    }\\n\\n    // =============== Storage ===============================================\\n\\n    bytes32 private constant WORMHOLE_CONSUMED_VAAS_SLOT =\\n        bytes32(uint256(keccak256(\\\"whTransceiver.consumedVAAs\\\")) - 1);\\n\\n    bytes32 private constant WORMHOLE_PEERS_SLOT =\\n        bytes32(uint256(keccak256(\\\"whTransceiver.peers\\\")) - 1);\\n\\n    bytes32 private constant WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT =\\n        bytes32(uint256(keccak256(\\\"whTransceiver.relayingEnabledChains\\\")) - 1);\\n\\n    bytes32 private constant SPECIAL_RELAYING_ENABLED_CHAINS_SLOT =\\n        bytes32(uint256(keccak256(\\\"whTransceiver.specialRelayingEnabledChains\\\")) - 1);\\n\\n    bytes32 private constant WORMHOLE_EVM_CHAIN_IDS =\\n        bytes32(uint256(keccak256(\\\"whTransceiver.evmChainIds\\\")) - 1);\\n\\n    // =============== Storage Setters/Getters ========================================\\n\\n    function _getWormholeConsumedVAAsStorage()\\n        internal\\n        pure\\n        returns (mapping(bytes32 => bool) storage $)\\n    {\\n        uint256 slot = uint256(WORMHOLE_CONSUMED_VAAS_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _getWormholePeersStorage()\\n        internal\\n        pure\\n        returns (mapping(uint16 => bytes32) storage $)\\n    {\\n        uint256 slot = uint256(WORMHOLE_PEERS_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _getWormholeRelayingEnabledChainsStorage()\\n        internal\\n        pure\\n        returns (mapping(uint16 => BooleanFlag) storage $)\\n    {\\n        uint256 slot = uint256(WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _getSpecialRelayingEnabledChainsStorage()\\n        internal\\n        pure\\n        returns (mapping(uint16 => BooleanFlag) storage $)\\n    {\\n        uint256 slot = uint256(SPECIAL_RELAYING_ENABLED_CHAINS_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _getWormholeEvmChainIdsStorage()\\n        internal\\n        pure\\n        returns (mapping(uint16 => BooleanFlag) storage $)\\n    {\\n        uint256 slot = uint256(WORMHOLE_EVM_CHAIN_IDS);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    // =============== Public Getters ======================================================\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function isVAAConsumed(bytes32 hash) public view returns (bool) {\\n        return _getWormholeConsumedVAAsStorage()[hash];\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function getWormholePeer(uint16 chainId) public view returns (bytes32) {\\n        return _getWormholePeersStorage()[chainId];\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function isWormholeRelayingEnabled(uint16 chainId) public view returns (bool) {\\n        return _getWormholeRelayingEnabledChainsStorage()[chainId].toBool();\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function isSpecialRelayingEnabled(uint16 chainId) public view returns (bool) {\\n        return _getSpecialRelayingEnabledChainsStorage()[chainId].toBool();\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function isWormholeEvmChain(uint16 chainId) public view returns (bool) {\\n        return _getWormholeEvmChainIdsStorage()[chainId].toBool();\\n    }\\n\\n    // =============== Admin ===============================================================\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function setWormholePeer(uint16 peerChainId, bytes32 peerContract) external payable onlyOwner {\\n        if (peerChainId == 0) {\\n            revert InvalidWormholeChainIdZero();\\n        }\\n        if (peerContract == bytes32(0)) {\\n            revert InvalidWormholePeerZeroAddress();\\n        }\\n\\n        bytes32 oldPeerContract = _getWormholePeersStorage()[peerChainId];\\n\\n        // We don't want to allow updating a peer since this adds complexity in the accountant\\n        // If the owner makes a mistake with peer registration they should deploy a new Wormhole\\n        // transceiver and register this new transceiver with the NttManager\\n        if (oldPeerContract != bytes32(0)) {\\n            revert PeerAlreadySet(peerChainId, oldPeerContract);\\n        }\\n\\n        _getWormholePeersStorage()[peerChainId] = peerContract;\\n\\n        // Publish a message for this transceiver registration\\n        TransceiverStructs.TransceiverRegistration memory registration = TransceiverStructs\\n            .TransceiverRegistration({\\n            transceiverIdentifier: WH_PEER_REGISTRATION_PREFIX,\\n            transceiverChainId: peerChainId,\\n            transceiverAddress: peerContract\\n        });\\n        wormhole.publishMessage{value: msg.value}(\\n            0, TransceiverStructs.encodeTransceiverRegistration(registration), consistencyLevel\\n        );\\n\\n        emit SetWormholePeer(peerChainId, peerContract);\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function setIsWormholeEvmChain(uint16 chainId, bool isEvm) external onlyOwner {\\n        if (chainId == 0) {\\n            revert InvalidWormholeChainIdZero();\\n        }\\n        _getWormholeEvmChainIdsStorage()[chainId] = isEvm.toWord();\\n\\n        emit SetIsWormholeEvmChain(chainId, isEvm);\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function setIsWormholeRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\\n        if (chainId == 0) {\\n            revert InvalidWormholeChainIdZero();\\n        }\\n        _getWormholeRelayingEnabledChainsStorage()[chainId] = isEnabled.toWord();\\n\\n        emit SetIsWormholeRelayingEnabled(chainId, isEnabled);\\n    }\\n\\n    /// @inheritdoc IWormholeTransceiverState\\n    function setIsSpecialRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\\n        if (chainId == 0) {\\n            revert InvalidWormholeChainIdZero();\\n        }\\n        _getSpecialRelayingEnabledChainsStorage()[chainId] = isEnabled.toWord();\\n\\n        emit SetIsSpecialRelayingEnabled(chainId, isEnabled);\\n    }\\n\\n    // ============= Internal ===============================================================\\n\\n    function _checkInvalidRelayingConfig(uint16 chainId) internal view returns (bool) {\\n        return isWormholeRelayingEnabled(chainId) && !isWormholeEvmChain(chainId);\\n    }\\n\\n    function _shouldRelayViaStandardRelaying(uint16 chainId) internal view returns (bool) {\\n        return isWormholeRelayingEnabled(chainId) && isWormholeEvmChain(chainId);\\n    }\\n\\n    function _setVAAConsumed(bytes32 hash) internal {\\n        _getWormholeConsumedVAAsStorage()[hash] = true;\\n    }\\n\\n    // =============== MODIFIERS ===============================================\\n\\n    modifier onlyRelayer() {\\n        if (msg.sender != address(wormholeRelayer)) {\\n            revert CallerNotRelayer(msg.sender);\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which can receive Wormhole messages.\\n */\\ninterface IWormholeReceiver {\\n    /**\\n     * @notice When a `send` is performed with this contract as the target, this function will be\\n     *     invoked by the WormholeRelayer contract\\n     *\\n     * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\n     *\\n     * We also recommend that this function checks that `sourceChain` and `sourceAddress` are indeed who\\n     *       you expect to have requested the calling of `send` on the source chain\\n     *\\n     * The invocation of this function corresponding to the `send` request will have msg.value equal\\n     *   to the receiverValue specified in the send request.\\n     *\\n     * If the invocation of this function reverts or exceeds the gas limit\\n     *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\n     *\\n     * @param payload - an arbitrary message which was included in the delivery by the\\n     *     requester. This message's signature will already have been verified (as long as msg.sender is the Wormhole Relayer contract)\\n     * @param additionalMessages - Additional messages which were requested to be included in this delivery.\\n     *      Note: There are no contract-level guarantees that the messages in this array are what was requested\\n     *      so **you should verify any sensitive information given here!**\\n     *\\n     *      For example, if a 'VaaKey' was specified on the source chain, then MAKE SURE the corresponding message here\\n     *      has valid signatures (by calling `parseAndVerifyVM(message)` on the Wormhole core contract)\\n     *\\n     *      This field can be used to perform and relay TokenBridge or CCTP transfers, and there are example\\n     *      usages of this at\\n     *         https://github.com/wormhole-foundation/hello-token\\n     *         https://github.com/wormhole-foundation/hello-cctp\\n     *\\n     * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\n     *     this delivery.\\n     * @param sourceChain - the wormhole chain ID where this delivery was requested.\\n     * @param deliveryHash - the VAA hash of the deliveryVAA.\\n     *\\n     */\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalMessages,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WormholeRelayer\\n * @author\\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\\n * write and run their own relaying infrastructure\\n *\\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages)\\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n    uint16 chainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n}\\n\\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\nuint8 constant VAA_KEY_TYPE = 1;\\n\\nstruct MessageKey {\\n    uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\n    bytes encodedKey;\\n}\\n\\ninterface IWormholeRelayerBase {\\n    event SendEvent(\\n        uint64 indexed sequence,\\n        uint256 deliveryQuote,\\n        uint256 paymentForExtraReceiverValue\\n    );\\n\\n    function getRegisteredWormholeRelayerContract(\\n        uint16 chainId\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if a delivery has been attempted for the given deliveryHash\\n     * Note: invalid deliveries where the tx reverts are not considered attempted\\n     */\\n    function deliveryAttempted(\\n        bytes32 deliveryHash\\n    ) external view returns (bool attempted);\\n\\n    /**\\n     * @notice block number at which a delivery was successfully executed\\n     */\\n    function deliverySuccessBlock(\\n        bytes32 deliveryHash\\n    ) external view returns (uint256 blockNumber);\\n\\n    /**\\n     * @notice block number of the latest attempt to execute a delivery that failed\\n     */\\n    function deliveryFailureBlock(\\n        bytes32 deliveryHash\\n    ) external view returns (uint256 blockNumber);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     * (e.g. with a different delivery provider)\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     * @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     */\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        uint256 newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     *\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified.\\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 nativePriceQuote,\\n            uint256 targetChainRefundPerGasUnused\\n        );\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified\\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address deliveryProviderAddress\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 nativePriceQuote,\\n            uint256 targetChainRefundPerGasUnused\\n        );\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\\n     *              if a refundAddress is specified)\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    )\\n        external\\n        view\\n        returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n     *         receiverValue + targetChainAmount\\n     */\\n    function quoteNativeForChain(\\n        uint16 targetChain,\\n        uint256 currentChainAmount,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 targetChainAmount);\\n\\n    /**\\n     * @notice Returns the address of the current default delivery provider\\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n     *   chain. This must be a contract that implements IDeliveryProvider.\\n     */\\n    function getDefaultDeliveryProvider()\\n        external\\n        view\\n        returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n    enum DeliveryStatus {\\n        SUCCESS,\\n        RECEIVER_FAILURE\\n    }\\n\\n    enum RefundStatus {\\n        REFUND_SENT,\\n        REFUND_FAIL,\\n        CROSS_CHAIN_REFUND_SENT,\\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\\n        NO_REFUND_REQUESTED\\n    }\\n\\n    /**\\n     * @custom:member recipientContract - The target contract address\\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n     *     ChainID format)\\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n     *     corresponding to this delivery request\\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n     *     request\\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract\\n     * @custom:member status:\\n     *   - RECEIVER_FAILURE, if the target contract reverts\\n     *   - SUCCESS, if the target contract doesn't revert\\n     * @custom:member additionalStatusInfo:\\n     *   - If status is SUCCESS, then this is empty.\\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n     *       return data (i.e. potentially truncated revert reason information).\\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n     *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\\n     * @custom:member overridesInfo:\\n     *   - If not an override: empty bytes array\\n     *   - Otherwise: An encoded `DeliveryOverride`\\n     */\\n    event Delivery(\\n        address indexed recipientContract,\\n        uint16 indexed sourceChain,\\n        uint64 indexed sequence,\\n        bytes32 deliveryVaaHash,\\n        DeliveryStatus status,\\n        uint256 gasUsed,\\n        RefundStatus refundStatus,\\n        bytes additionalStatusInfo,\\n        bytes overridesInfo\\n    );\\n\\n    /**\\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n     *\\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n     *\\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n     * - the delivery VAA has a valid signature\\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\\n     * - the instruction's target chain is this chain\\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n     *\\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n     *     transaction)\\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n     *     contract with payload being the encoded delivery instruction container\\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n     *     should be sent\\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n     *     an encoded DeliveryOverride struct\\n     */\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(\\n    address relayer,\\n    uint16 chainId\\n);\\nerror DeliveryProviderCannotReceivePayment();\\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\\n\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\nerror TooManyMessageKeys(uint256 numMessageKeys);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/Chains.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\n// In the wormhole wire format, 0 indicates that a message is for any destination chain\\nuint16 constant CHAIN_ID_UNSET = 0;\\nuint16 constant CHAIN_ID_SOLANA = 1;\\nuint16 constant CHAIN_ID_ETHEREUM = 2;\\nuint16 constant CHAIN_ID_TERRA = 3;\\nuint16 constant CHAIN_ID_BSC = 4;\\nuint16 constant CHAIN_ID_POLYGON = 5;\\nuint16 constant CHAIN_ID_AVALANCHE = 6;\\nuint16 constant CHAIN_ID_OASIS = 7;\\nuint16 constant CHAIN_ID_ALGORAND = 8;\\nuint16 constant CHAIN_ID_AURORA = 9;\\nuint16 constant CHAIN_ID_FANTOM = 10;\\nuint16 constant CHAIN_ID_KARURA = 11;\\nuint16 constant CHAIN_ID_ACALA = 12;\\nuint16 constant CHAIN_ID_KLAYTN = 13;\\nuint16 constant CHAIN_ID_CELO = 14;\\nuint16 constant CHAIN_ID_NEAR = 15;\\nuint16 constant CHAIN_ID_MOONBEAM = 16;\\nuint16 constant CHAIN_ID_NEON = 17;\\nuint16 constant CHAIN_ID_TERRA2 = 18;\\nuint16 constant CHAIN_ID_INJECTIVE = 19;\\nuint16 constant CHAIN_ID_OSMOSIS = 20;\\nuint16 constant CHAIN_ID_SUI = 21;\\nuint16 constant CHAIN_ID_APTOS = 22;\\nuint16 constant CHAIN_ID_ARBITRUM = 23;\\nuint16 constant CHAIN_ID_OPTIMISM = 24;\\nuint16 constant CHAIN_ID_GNOSIS = 25;\\nuint16 constant CHAIN_ID_PYTHNET = 26;\\nuint16 constant CHAIN_ID_XPLA = 28;\\nuint16 constant CHAIN_ID_BTC = 29;\\nuint16 constant CHAIN_ID_BASE = 30;\\nuint16 constant CHAIN_ID_SEI = 32;\\nuint16 constant CHAIN_ID_ROOTSTOCK = 33;\\nuint16 constant CHAIN_ID_SCROLL = 34;\\nuint16 constant CHAIN_ID_MANTLE = 35;\\nuint16 constant CHAIN_ID_WORMCHAIN = 3104;\\nuint16 constant CHAIN_ID_COSMOSHUB = 4000;\\nuint16 constant CHAIN_ID_EVMOS = 4001;\\nuint16 constant CHAIN_ID_KUJIRA = 4002;\\nuint16 constant CHAIN_ID_NEUTRON = 4003;\\nuint16 constant CHAIN_ID_CELESTIA = 4004;\\nuint16 constant CHAIN_ID_SEPOLIA = 10002;\\nuint16 constant CHAIN_ID_ARBITRUM_SEPOLIA = 10003;\\nuint16 constant CHAIN_ID_BASE_SEPOLIA = 10004;\\nuint16 constant CHAIN_ID_OPTIMISM_SEPOLIA = 10005;\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/Utils.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\n\\nfunction toWormholeFormat(address addr) pure returns (bytes32) {\\n    return bytes32(uint256(uint160(addr)));\\n}\\n\\nfunction fromWormholeFormat(bytes32 whFormatAddress) pure returns (address) {\\n    if (uint256(whFormatAddress) >> 160 != 0) {\\n        revert NotAnEvmAddress(whFormatAddress);\\n    }\\n    return address(uint160(uint256(whFormatAddress)));\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"./interfaces/IWormhole.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nabstract contract Base {\\n    IWormholeRelayer public immutable wormholeRelayer;\\n    IWormhole public immutable wormhole;\\n\\n    address registrationOwner;\\n    mapping(uint16 => bytes32) registeredSenders;\\n\\n    constructor(address _wormholeRelayer, address _wormhole) {\\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\\n        wormhole = IWormhole(_wormhole);\\n        registrationOwner = msg.sender;\\n    }\\n\\n    modifier onlyWormholeRelayer() {\\n        require(\\n            msg.sender == address(wormholeRelayer),\\n            \\\"Msg.sender is not Wormhole Relayer\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\\n        require(\\n            registeredSenders[sourceChain] == sourceAddress,\\n            \\\"Not registered sender\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * Sets the registered address for 'sourceChain' to 'sourceAddress'\\n     * So that for messages from 'sourceChain', only ones from 'sourceAddress' are valid\\n     *\\n     * Assumes only one sender per chain is valid\\n     * Sender is the address that called 'send' on the Wormhole Relayer contract on the source chain)\\n     */\\n    function setRegisteredSender(\\n        uint16 sourceChain,\\n        bytes32 sourceAddress\\n    ) public {\\n        require(\\n            msg.sender == registrationOwner,\\n            \\\"Not allowed to set registered sender\\\"\\n        );\\n        registeredSenders[sourceChain] = sourceAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/TokenBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"./interfaces/ITokenBridge.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {Base} from \\\"./WormholeRelayerSDK.sol\\\";\\n\\nimport \\\"./Utils.sol\\\";\\n\\nabstract contract TokenBase is Base {\\n    ITokenBridge public immutable tokenBridge;\\n\\n    constructor(\\n        address _wormholeRelayer,\\n        address _tokenBridge,\\n        address _wormhole\\n    ) Base(_wormholeRelayer, _wormhole) {\\n        tokenBridge = ITokenBridge(_tokenBridge);\\n    }\\n}\\n\\nabstract contract TokenSender is TokenBase {\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     *\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (VaaKey memory) {\\n        return\\n            transferTokens(\\n                token,\\n                amount,\\n                targetChain,\\n                targetAddress,\\n                bytes(\\\"\\\")\\n            );\\n    }\\n\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer.\\n     * A payload can be included in the transfer vaa. By including a payload here instead of the deliveryVaa,\\n     * fewer trust assumptions are placed on the WormholeRelayer contract.\\n     *\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload\\n    ) internal returns (VaaKey memory) {\\n        IERC20(token).approve(address(tokenBridge), amount);\\n        uint64 sequence = tokenBridge.transferTokensWithPayload{\\n            value: wormhole.messageFee()\\n        }(\\n            token,\\n            amount,\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            0,\\n            payload\\n        );\\n        return\\n            VaaKey({\\n                emitterAddress: toWormholeFormat(address(tokenBridge)),\\n                chainId: wormhole.chainId(),\\n                sequence: sequence\\n            });\\n    }\\n\\n    // Publishes a wormhole message representing a 'TokenBridge' transfer of 'amount' of 'token'\\n    // and requests a delivery of the transfer along with 'payload' to 'targetAddress' on 'targetChain'\\n    //\\n    // The second step is done by publishing a wormhole message representing a request\\n    // to call 'receiveWormholeMessages' on the address 'targetAddress' on chain 'targetChain'\\n    // with the payload 'payload'\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount\\n    ) internal returns (uint64) {\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys\\n            );\\n    }\\n\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) internal returns (uint64) {\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys,\\n                refundChain,\\n                refundAddress\\n            );\\n    }\\n}\\n\\nabstract contract TokenReceiver is TokenBase {\\n    struct TokenReceived {\\n        bytes32 tokenHomeAddress;\\n        uint16 tokenHomeChain;\\n        address tokenAddress; // wrapped address if tokenHomeChain !== this chain, else tokenHomeAddress (in evm address format)\\n        uint256 amount;\\n        uint256 amountNormalized; // if decimals > 8, normalized to 8 decimal places\\n    }\\n\\n    function getDecimals(\\n        address tokenAddress\\n    ) internal view returns (uint8 decimals) {\\n        // query decimals\\n        (, bytes memory queriedDecimals) = address(tokenAddress).staticcall(\\n            abi.encodeWithSignature(\\\"decimals()\\\")\\n        );\\n        decimals = abi.decode(queriedDecimals, (uint8));\\n    }\\n\\n    function getTokenAddressOnThisChain(\\n        uint16 tokenHomeChain,\\n        bytes32 tokenHomeAddress\\n    ) internal view returns (address tokenAddressOnThisChain) {\\n        return\\n            tokenHomeChain == wormhole.chainId()\\n                ? fromWormholeFormat(tokenHomeAddress)\\n                : tokenBridge.wrappedAsset(tokenHomeChain, tokenHomeAddress);\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable {\\n        TokenReceived[] memory receivedTokens = new TokenReceived[](\\n            additionalVaas.length\\n        );\\n\\n        for (uint256 i = 0; i < additionalVaas.length; ++i) {\\n            IWormhole.VM memory parsed = wormhole.parseVM(additionalVaas[i]);\\n            require(\\n                parsed.emitterAddress ==\\n                    tokenBridge.bridgeContracts(parsed.emitterChainId),\\n                \\\"Not a Token Bridge VAA\\\"\\n            );\\n            ITokenBridge.TransferWithPayload memory transfer = tokenBridge\\n                .parseTransferWithPayload(parsed.payload);\\n            require(\\n                transfer.to == toWormholeFormat(address(this)) &&\\n                    transfer.toChain == wormhole.chainId(),\\n                \\\"Token was not sent to this address\\\"\\n            );\\n\\n            tokenBridge.completeTransferWithPayload(additionalVaas[i]);\\n\\n            address thisChainTokenAddress = getTokenAddressOnThisChain(\\n                transfer.tokenChain,\\n                transfer.tokenAddress\\n            );\\n            uint8 decimals = getDecimals(thisChainTokenAddress);\\n            uint256 denormalizedAmount = transfer.amount;\\n            if (decimals > 8)\\n                denormalizedAmount *= uint256(10) ** (decimals - 8);\\n\\n            receivedTokens[i] = TokenReceived({\\n                tokenHomeAddress: transfer.tokenAddress,\\n                tokenHomeChain: transfer.tokenChain,\\n                tokenAddress: thisChainTokenAddress,\\n                amount: denormalizedAmount,\\n                amountNormalized: transfer.amount\\n            });\\n        }\\n\\n        // call into overriden method\\n        receivePayloadAndTokens(\\n            payload,\\n            receivedTokens,\\n            sourceAddress,\\n            sourceChain,\\n            deliveryHash\\n        );\\n    }\\n\\n    // Implement this function to handle in-bound deliveries that include a TokenBridge transfer\\n    function receivePayloadAndTokens(\\n        bytes memory payload,\\n        TokenReceived[] memory receivedTokens,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/CCTPBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/CCTPInterfaces/ITokenMessenger.sol\\\";\\nimport \\\"./interfaces/CCTPInterfaces/IMessageTransmitter.sol\\\";\\n\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./Base.sol\\\";\\n\\nlibrary CCTPMessageLib {\\n    // The second standardized key type is a CCTP Key\\n    // representing a CCTP transfer of USDC\\n    // (on the IWormholeRelayer interface)\\n\\n    // Note - the default delivery provider only will relay CCTP transfers that were sent\\n    // in the same transaction that this message was emitted!\\n    // (This will always be the case if 'CCTPSender' is used)\\n\\n    uint8 constant CCTP_KEY_TYPE = 2;\\n\\n    // encoded using abi.encodePacked(domain, nonce)\\n    struct CCTPKey {\\n        uint32 domain;\\n        uint64 nonce;\\n    }\\n\\n    // encoded using abi.encode(message, signature)\\n    struct CCTPMessage {\\n        bytes message;\\n        bytes signature;\\n    }\\n}\\n\\nabstract contract CCTPBase is Base {\\n    ITokenMessenger immutable circleTokenMessenger;\\n    IMessageTransmitter immutable circleMessageTransmitter;\\n    address immutable USDC;\\n    address cctpConfigurationOwner;\\n\\n    constructor(\\n        address _wormholeRelayer,\\n        address _wormhole,\\n        address _circleMessageTransmitter,\\n        address _circleTokenMessenger,\\n        address _USDC\\n    ) Base(_wormholeRelayer, _wormhole) {\\n        circleTokenMessenger = ITokenMessenger(_circleTokenMessenger);\\n        circleMessageTransmitter = IMessageTransmitter(\\n            _circleMessageTransmitter\\n        );\\n        USDC = _USDC;\\n        cctpConfigurationOwner = msg.sender;\\n    }\\n}\\n\\nabstract contract CCTPSender is CCTPBase {\\n    uint8 internal constant CONSISTENCY_LEVEL_FINALIZED = 15;\\n\\n    using CCTPMessageLib for *;\\n\\n    mapping(uint16 => uint32) public chainIdToCCTPDomain;\\n\\n    /**\\n     * Sets the CCTP Domain corresponding to chain 'chain' to be 'cctpDomain'\\n     * So that transfers of USDC to chain 'chain' use the target CCTP domain 'cctpDomain'\\n     *\\n     * This action can only be performed by 'cctpConfigurationOwner', who is set to be the deployer\\n     *\\n     * Currently, cctp domains are:\\n     * Ethereum: Wormhole chain id 2, cctp domain 0\\n     * Avalanche: Wormhole chain id 6, cctp domain 1\\n     * Optimism: Wormhole chain id 24, cctp domain 2\\n     * Arbitrum: Wormhole chain id 23, cctp domain 3\\n     * Base: Wormhole chain id 30, cctp domain 6\\n     *\\n     * These can be set via:\\n     * setCCTPDomain(2, 0);\\n     * setCCTPDomain(6, 1);\\n     * setCCTPDomain(24, 2);\\n     * setCCTPDomain(23, 3);\\n     * setCCTPDomain(30, 6);\\n     */\\n    function setCCTPDomain(uint16 chain, uint32 cctpDomain) public {\\n        require(\\n            msg.sender == cctpConfigurationOwner,\\n            \\\"Not allowed to set CCTP Domain\\\"\\n        );\\n        chainIdToCCTPDomain[chain] = cctpDomain;\\n    }\\n\\n    function getCCTPDomain(uint16 chain) internal view returns (uint32) {\\n        return chainIdToCCTPDomain[chain];\\n    }\\n\\n    /**\\n     * transferUSDC wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\\n     * - approves the Circle TokenMessenger contract to spend 'amount' of USDC\\n     * - calls Circle's 'depositForBurnWithCaller'\\n     * - returns key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this requires that only the targetAddress can redeem transfers.\\n     *\\n     */\\n\\n    function transferUSDC(\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (MessageKey memory) {\\n        IERC20(USDC).approve(address(circleTokenMessenger), amount);\\n        bytes32 targetAddressBytes32 = addressToBytes32CCTP(targetAddress);\\n        uint64 nonce = circleTokenMessenger.depositForBurnWithCaller(\\n            amount,\\n            getCCTPDomain(targetChain),\\n            targetAddressBytes32,\\n            USDC,\\n            targetAddressBytes32\\n        );\\n        return\\n            MessageKey(\\n                CCTPMessageLib.CCTP_KEY_TYPE,\\n                abi.encodePacked(getCCTPDomain(wormhole.chainId()), nonce)\\n            );\\n    }\\n\\n    // Publishes a CCTP transfer of 'amount' of USDC\\n    // and requests a delivery of the transfer along with 'payload' to 'targetAddress' on 'targetChain'\\n    //\\n    // The second step is done by publishing a wormhole message representing a request\\n    // to call 'receiveWormholeMessages' on the address 'targetAddress' on chain 'targetChain'\\n    // with the payload 'abi.encode(amount, payload)'\\n    // (and we encode the amount so it can be checked on the target chain)\\n    function sendUSDCWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint256 amount\\n    ) internal returns (uint64 sequence) {\\n        MessageKey[] memory messageKeys = new MessageKey[](1);\\n        messageKeys[0] = transferUSDC(amount, targetChain, targetAddress);\\n\\n        bytes memory userPayload = abi.encode(amount, payload);\\n        address defaultDeliveryProvider = wormholeRelayer\\n            .getDefaultDeliveryProvider();\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n\\n        sequence = wormholeRelayer.sendToEvm{value: cost}(\\n            targetChain,\\n            targetAddress,\\n            userPayload,\\n            receiverValue,\\n            0,\\n            gasLimit,\\n            targetChain,\\n            address(0x0),\\n            defaultDeliveryProvider,\\n            messageKeys,\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function addressToBytes32CCTP(address addr) private pure returns (bytes32) {\\n        return bytes32(uint256(uint160(addr)));\\n    }\\n}\\n\\nabstract contract CCTPReceiver is CCTPBase {\\n    function redeemUSDC(\\n        bytes memory cctpMessage\\n    ) internal returns (uint256 amount) {\\n        (bytes memory message, bytes memory signature) = abi.decode(\\n            cctpMessage,\\n            (bytes, bytes)\\n        );\\n        uint256 beforeBalance = IERC20(USDC).balanceOf(address(this));\\n        circleMessageTransmitter.receiveMessage(message, signature);\\n        return IERC20(USDC).balanceOf(address(this)) - beforeBalance;\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalMessages,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable {\\n        // Currently, 'sendUSDCWithPayloadToEVM' only sends one CCTP transfer\\n        // That can be modified if the integrator desires to send multiple CCTP transfers\\n        // in which case the following code would have to be modified to support\\n        // redeeming these multiple transfers and checking that their 'amount's are accurate\\n        require(\\n            additionalMessages.length <= 1,\\n            \\\"CCTP: At most one Message is supported\\\"\\n        );\\n\\n        uint256 amountUSDCReceived;\\n        if (additionalMessages.length == 1) {\\n            amountUSDCReceived = redeemUSDC(additionalMessages[0]);\\n        }\\n\\n        (uint256 amount, bytes memory userPayload) = abi.decode(\\n            payload,\\n            (uint256, bytes)\\n        );\\n\\n        // Check that the correct amount was received\\n        // It is important to verify that the 'USDC' sent in by the relayer is the same amount\\n        // that the sender sent in on the source chain\\n        require(amount == amountUSDCReceived, \\\"Wrong amount received\\\");\\n\\n        receivePayloadAndUSDC(\\n            userPayload,\\n            amountUSDCReceived,\\n            sourceAddress,\\n            sourceChain,\\n            deliveryHash\\n        );\\n    }\\n\\n    // Implement this function to handle in-bound deliveries that include a CCTP transfer\\n    function receivePayloadAndUSDC(\\n        bytes memory payload,\\n        uint256 amountUSDCReceived,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/CCTPAndTokenBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"./interfaces/ITokenBridge.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/CCTPInterfaces/ITokenMessenger.sol\\\";\\nimport \\\"./interfaces/CCTPInterfaces/IMessageTransmitter.sol\\\";\\n\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./TokenBase.sol\\\";\\nimport \\\"./CCTPBase.sol\\\";\\n\\nabstract contract CCTPAndTokenBase is CCTPBase {\\n    ITokenBridge public immutable tokenBridge;\\n\\n    enum Transfer {\\n        TOKEN_BRIDGE,\\n        CCTP\\n    }\\n\\n    constructor(\\n        address _wormholeRelayer,\\n        address _tokenBridge,\\n        address _wormhole,\\n        address _circleMessageTransmitter,\\n        address _circleTokenMessenger,\\n        address _USDC\\n    )\\n        CCTPBase(\\n            _wormholeRelayer,\\n            _wormhole,\\n            _circleMessageTransmitter,\\n            _circleTokenMessenger,\\n            _USDC\\n        )\\n    {\\n        tokenBridge = ITokenBridge(_tokenBridge);\\n    }\\n}\\n\\nabstract contract CCTPAndTokenSender is CCTPAndTokenBase {\\n    // CCTP Sender functions, taken from \\\"./CCTPBase.sol\\\"\\n\\n    uint8 internal constant CONSISTENCY_LEVEL_FINALIZED = 15;\\n\\n    using CCTPMessageLib for *;\\n\\n    mapping(uint16 => uint32) public chainIdToCCTPDomain;\\n\\n    /**\\n     * Sets the CCTP Domain corresponding to chain 'chain' to be 'cctpDomain'\\n     * So that transfers of USDC to chain 'chain' use the target CCTP domain 'cctpDomain'\\n     *\\n     * This action can only be performed by 'cctpConfigurationOwner', who is set to be the deployer\\n     *\\n     * Currently, cctp domains are:\\n     * Ethereum: Wormhole chain id 2, cctp domain 0\\n     * Avalanche: Wormhole chain id 6, cctp domain 1\\n     * Optimism: Wormhole chain id 24, cctp domain 2\\n     * Arbitrum: Wormhole chain id 23, cctp domain 3\\n     * Base: Wormhole chain id 30, cctp domain 6\\n     *\\n     * These can be set via:\\n     * setCCTPDomain(2, 0);\\n     * setCCTPDomain(6, 1);\\n     * setCCTPDomain(24, 2);\\n     * setCCTPDomain(23, 3);\\n     * setCCTPDomain(30, 6);\\n     */\\n    function setCCTPDomain(uint16 chain, uint32 cctpDomain) public {\\n        require(\\n            msg.sender == cctpConfigurationOwner,\\n            \\\"Not allowed to set CCTP Domain\\\"\\n        );\\n        chainIdToCCTPDomain[chain] = cctpDomain;\\n    }\\n\\n    function getCCTPDomain(uint16 chain) internal view returns (uint32) {\\n        return chainIdToCCTPDomain[chain];\\n    }\\n\\n    /**\\n     * transferUSDC wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\\n     * - approves the Circle TokenMessenger contract to spend 'amount' of USDC\\n     * - calls Circle's 'depositForBurnWithCaller'\\n     * - returns key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this requires that only the targetAddress can redeem transfers.\\n     *\\n     */\\n\\n    function transferUSDC(\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (MessageKey memory) {\\n        IERC20(USDC).approve(address(circleTokenMessenger), amount);\\n        bytes32 targetAddressBytes32 = addressToBytes32CCTP(targetAddress);\\n        uint64 nonce = circleTokenMessenger.depositForBurnWithCaller(\\n            amount,\\n            getCCTPDomain(targetChain),\\n            targetAddressBytes32,\\n            USDC,\\n            targetAddressBytes32\\n        );\\n        return\\n            MessageKey(\\n                CCTPMessageLib.CCTP_KEY_TYPE,\\n                abi.encodePacked(getCCTPDomain(wormhole.chainId()), nonce)\\n            );\\n    }\\n\\n    // Publishes a CCTP transfer of 'amount' of USDC\\n    // and requests a delivery of the transfer along with 'payload' to 'targetAddress' on 'targetChain'\\n    //\\n    // The second step is done by publishing a wormhole message representing a request\\n    // to call 'receiveWormholeMessages' on the address 'targetAddress' on chain 'targetChain'\\n    // with the payload 'abi.encode(Transfer.CCTP, amount, payload)'\\n    // (we encode a Transfer enum to distinguish this from a TokenBridge transfer)\\n    // (and we encode the amount so it can be checked on the target chain)\\n    function sendUSDCWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint256 amount\\n    ) internal returns (uint64 sequence) {\\n        MessageKey[] memory messageKeys = new MessageKey[](1);\\n        messageKeys[0] = transferUSDC(amount, targetChain, targetAddress);\\n\\n        bytes memory userPayload = abi.encode(Transfer.CCTP, amount, payload);\\n        address defaultDeliveryProvider = wormholeRelayer\\n            .getDefaultDeliveryProvider();\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n\\n        sequence = wormholeRelayer.sendToEvm{value: cost}(\\n            targetChain,\\n            targetAddress,\\n            userPayload,\\n            receiverValue,\\n            0,\\n            gasLimit,\\n            targetChain,\\n            address(0x0),\\n            defaultDeliveryProvider,\\n            messageKeys,\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function addressToBytes32CCTP(address addr) private pure returns (bytes32) {\\n        return bytes32(uint256(uint160(addr)));\\n    }\\n\\n    // TokenBridge Sender functions, taken from \\\"./TokenBase.sol\\\"\\n\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     *\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (VaaKey memory) {\\n        return\\n            transferTokens(\\n                token,\\n                amount,\\n                targetChain,\\n                targetAddress,\\n                bytes(\\\"\\\")\\n            );\\n    }\\n\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer.\\n     * A payload can be included in the transfer vaa. By including a payload here instead of the deliveryVaa,\\n     * fewer trust assumptions are placed on the WormholeRelayer contract.\\n     *\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload\\n    ) internal returns (VaaKey memory) {\\n        IERC20(token).approve(address(tokenBridge), amount);\\n        uint64 sequence = tokenBridge.transferTokensWithPayload{\\n            value: wormhole.messageFee()\\n        }(\\n            token,\\n            amount,\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            0,\\n            payload\\n        );\\n        return\\n            VaaKey({\\n                emitterAddress: toWormholeFormat(address(tokenBridge)),\\n                chainId: wormhole.chainId(),\\n                sequence: sequence\\n            });\\n    }\\n\\n    // Publishes a wormhole message representing a 'TokenBridge' transfer of 'amount' of 'token'\\n    // and requests a delivery of the transfer along with 'payload' to 'targetAddress' on 'targetChain'\\n    //\\n    // The second step is done by publishing a wormhole message representing a request\\n    // to call 'receiveWormholeMessages' on the address 'targetAddress' on chain 'targetChain'\\n    // with the payload 'abi.encode(Transfer.TOKEN_BRIDGE, payload)'\\n    // (we encode a Transfer enum to distinguish this from a CCTP transfer)\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount\\n    ) internal returns (uint64) {\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                abi.encode(Transfer.TOKEN_BRIDGE, payload),\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys\\n            );\\n    }\\n\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) internal returns (uint64) {\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                abi.encode(Transfer.TOKEN_BRIDGE, payload),\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys,\\n                refundChain,\\n                refundAddress\\n            );\\n    }\\n}\\n\\nabstract contract CCTPAndTokenReceiver is CCTPAndTokenBase {\\n    function redeemUSDC(\\n        bytes memory cctpMessage\\n    ) internal returns (uint256 amount) {\\n        (bytes memory message, bytes memory signature) = abi.decode(\\n            cctpMessage,\\n            (bytes, bytes)\\n        );\\n        uint256 beforeBalance = IERC20(USDC).balanceOf(address(this));\\n        circleMessageTransmitter.receiveMessage(message, signature);\\n        return IERC20(USDC).balanceOf(address(this)) - beforeBalance;\\n    }\\n\\n    struct TokenReceived {\\n        bytes32 tokenHomeAddress;\\n        uint16 tokenHomeChain;\\n        address tokenAddress; // wrapped address if tokenHomeChain !== this chain, else tokenHomeAddress (in evm address format)\\n        uint256 amount;\\n        uint256 amountNormalized; // if decimals > 8, normalized to 8 decimal places\\n    }\\n\\n    function getDecimals(\\n        address tokenAddress\\n    ) internal view returns (uint8 decimals) {\\n        // query decimals\\n        (, bytes memory queriedDecimals) = address(tokenAddress).staticcall(\\n            abi.encodeWithSignature(\\\"decimals()\\\")\\n        );\\n        decimals = abi.decode(queriedDecimals, (uint8));\\n    }\\n\\n    function getTokenAddressOnThisChain(\\n        uint16 tokenHomeChain,\\n        bytes32 tokenHomeAddress\\n    ) internal view returns (address tokenAddressOnThisChain) {\\n        return\\n            tokenHomeChain == wormhole.chainId()\\n                ? fromWormholeFormat(tokenHomeAddress)\\n                : tokenBridge.wrappedAsset(tokenHomeChain, tokenHomeAddress);\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalMessages,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable {\\n        Transfer transferType = abi.decode(payload, (Transfer));\\n        if (transferType == Transfer.TOKEN_BRIDGE) {\\n            TokenReceived[] memory receivedTokens = new TokenReceived[](\\n                additionalMessages.length\\n            );\\n\\n            for (uint256 i = 0; i < additionalMessages.length; ++i) {\\n                IWormhole.VM memory parsed = wormhole.parseVM(\\n                    additionalMessages[i]\\n                );\\n                require(\\n                    parsed.emitterAddress ==\\n                        tokenBridge.bridgeContracts(parsed.emitterChainId),\\n                    \\\"Not a Token Bridge VAA\\\"\\n                );\\n                ITokenBridge.TransferWithPayload memory transfer = tokenBridge\\n                    .parseTransferWithPayload(parsed.payload);\\n                require(\\n                    transfer.to == toWormholeFormat(address(this)) &&\\n                        transfer.toChain == wormhole.chainId(),\\n                    \\\"Token was not sent to this address\\\"\\n                );\\n\\n                tokenBridge.completeTransferWithPayload(additionalMessages[i]);\\n\\n                address thisChainTokenAddress = getTokenAddressOnThisChain(\\n                    transfer.tokenChain,\\n                    transfer.tokenAddress\\n                );\\n                uint8 decimals = getDecimals(thisChainTokenAddress);\\n                uint256 denormalizedAmount = transfer.amount;\\n                if (decimals > 8)\\n                    denormalizedAmount *= uint256(10) ** (decimals - 8);\\n\\n                receivedTokens[i] = TokenReceived({\\n                    tokenHomeAddress: transfer.tokenAddress,\\n                    tokenHomeChain: transfer.tokenChain,\\n                    tokenAddress: thisChainTokenAddress,\\n                    amount: denormalizedAmount,\\n                    amountNormalized: transfer.amount\\n                });\\n            }\\n\\n            (, bytes memory userPayload) = abi.decode(\\n                payload,\\n                (Transfer, bytes)\\n            );\\n\\n            // call into overriden method\\n            receivePayloadAndTokens(\\n                userPayload,\\n                receivedTokens,\\n                sourceAddress,\\n                sourceChain,\\n                deliveryHash\\n            );\\n        } else if (transferType == Transfer.CCTP) {\\n            // Currently, 'sendUSDCWithPayloadToEVM' only sends one CCTP transfer\\n            // That can be modified if the integrator desires to send multiple CCTP transfers\\n            // in which case the following code would have to be modified to support\\n            // redeeming these multiple transfers and checking that their 'amount's are accurate\\n            require(\\n                additionalMessages.length <= 1,\\n                \\\"CCTP: At most one Message is supported\\\"\\n            );\\n\\n            uint256 amountUSDCReceived;\\n            if (additionalMessages.length == 1) {\\n                amountUSDCReceived = redeemUSDC(additionalMessages[0]);\\n            }\\n\\n            (, uint256 amount, bytes memory userPayload) = abi.decode(\\n                payload,\\n                (Transfer, uint256, bytes)\\n            );\\n\\n            // Check that the correct amount was received\\n            // It is important to verify that the 'USDC' sent in by the relayer is the same amount\\n            // that the sender sent in on the source chain\\n            require(amount == amountUSDCReceived, \\\"Wrong amount received\\\");\\n\\n            receivePayloadAndUSDC(\\n                userPayload,\\n                amountUSDCReceived,\\n                sourceAddress,\\n                sourceChain,\\n                deliveryHash\\n            );\\n        } else {\\n            revert(\\\"Invalid transfer type\\\");\\n        }\\n    }\\n\\n    // Implement this function to handle in-bound deliveries that include a CCTP transfer\\n    function receivePayloadAndUSDC(\\n        bytes memory payload,\\n        uint256 amountUSDCReceived,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal virtual {}\\n\\n    // Implement this function to handle in-bound deliveries that include a TokenBridge transfer\\n    function receivePayloadAndTokens(\\n        bytes memory payload,\\n        TokenReceived[] memory receivedTokens,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/libraries/TrimmedAmount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @dev TrimmedAmount is a bit-packed representation of a token amount and its decimals.\\n/// @dev 64 bits: [0 - 64] amount\\n/// @dev 8 bits: [64 - 72] decimals\\ntype TrimmedAmount is uint72;\\n\\nusing {gt as >, lt as <, sub as -, add as +, eq as ==, min, unwrap} for TrimmedAmount global;\\n\\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\\n    return a < b ? a : b;\\n}\\n\\n/// @notice Error when the decimals of two TrimmedAmounts are not equal\\n/// @dev Selector. b9cdb6c2\\n/// @param decimals the decimals of the first TrimmedAmount\\n/// @param decimalsOther the decimals of the second TrimmedAmount\\nerror NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\\n\\nuint8 constant TRIMMED_DECIMALS = 8;\\n\\nfunction unwrap(TrimmedAmount a) pure returns (uint72) {\\n    return TrimmedAmount.unwrap(a);\\n}\\n\\nfunction packTrimmedAmount(uint64 amt, uint8 decimals) pure returns (TrimmedAmount) {\\n    // cast to u72 first to prevent overflow\\n    uint72 amount = uint72(amt);\\n    uint72 dec = uint72(decimals);\\n\\n    // shift the amount to the left 8 bits\\n    amount <<= 8;\\n\\n    return TrimmedAmount.wrap(amount | dec);\\n}\\n\\nfunction eq(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    return TrimmedAmountLib.getAmount(a) == TrimmedAmountLib.getAmount(b)\\n        && TrimmedAmountLib.getDecimals(a) == TrimmedAmountLib.getDecimals(b);\\n}\\n\\nfunction checkDecimals(TrimmedAmount a, TrimmedAmount b) pure {\\n    uint8 aDecimals = TrimmedAmountLib.getDecimals(a);\\n    uint8 bDecimals = TrimmedAmountLib.getDecimals(b);\\n    if (aDecimals != bDecimals) {\\n        revert NumberOfDecimalsNotEqual(aDecimals, bDecimals);\\n    }\\n}\\n\\nfunction gt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) > TrimmedAmountLib.getAmount(b);\\n}\\n\\nfunction lt(TrimmedAmount a, TrimmedAmount b) pure returns (bool) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) < TrimmedAmountLib.getAmount(b);\\n}\\n\\nfunction sub(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return packTrimmedAmount(\\n        TrimmedAmountLib.getAmount(a) - TrimmedAmountLib.getAmount(b),\\n        TrimmedAmountLib.getDecimals(a)\\n    );\\n}\\n\\nfunction add(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return packTrimmedAmount(\\n        TrimmedAmountLib.getAmount(a) + TrimmedAmountLib.getAmount(b),\\n        TrimmedAmountLib.getDecimals(b)\\n    );\\n}\\n\\nfunction min(TrimmedAmount a, TrimmedAmount b) pure returns (TrimmedAmount) {\\n    checkDecimals(a, b);\\n\\n    return TrimmedAmountLib.getAmount(a) < TrimmedAmountLib.getAmount(b) ? a : b;\\n}\\n\\nlibrary TrimmedAmountLib {\\n    /// @notice Error when the amount to be trimmed is greater than u64MAX.\\n    /// @dev Selector 0x08083b2a.\\n    /// @param amount The amount to be trimmed.\\n    error AmountTooLarge(uint256 amount);\\n\\n    function getAmount(TrimmedAmount a) internal pure returns (uint64) {\\n        // Extract the raw integer value from TrimmedAmount\\n        uint72 rawValue = TrimmedAmount.unwrap(a);\\n\\n        // Right shift to keep only the higher 64 bits\\n        uint64 result = uint64(rawValue >> 8);\\n        return result;\\n    }\\n\\n    function getDecimals(TrimmedAmount a) internal pure returns (uint8) {\\n        return uint8(TrimmedAmount.unwrap(a) & 0xFF);\\n    }\\n\\n    function isNull(TrimmedAmount a) internal pure returns (bool) {\\n        return (getAmount(a) == 0 && getDecimals(a) == 0);\\n    }\\n\\n    function saturatingAdd(\\n        TrimmedAmount a,\\n        TrimmedAmount b\\n    ) internal pure returns (TrimmedAmount) {\\n        checkDecimals(a, b);\\n\\n        uint256 saturatedSum;\\n        uint64 aAmount = getAmount(a);\\n        uint64 bAmount = getAmount(b);\\n        unchecked {\\n            saturatedSum = uint256(aAmount) + uint256(bAmount);\\n            saturatedSum = saturatedSum > type(uint64).max ? type(uint64).max : saturatedSum;\\n        }\\n\\n        return packTrimmedAmount(SafeCast.toUint64(saturatedSum), getDecimals(a));\\n    }\\n\\n    /// @dev scale the amount from original decimals to target decimals (base 10)\\n    function scale(\\n        uint256 amount,\\n        uint8 fromDecimals,\\n        uint8 toDecimals\\n    ) internal pure returns (uint256) {\\n        if (fromDecimals == toDecimals) {\\n            return amount;\\n        }\\n\\n        if (fromDecimals > toDecimals) {\\n            return amount / (10 ** (fromDecimals - toDecimals));\\n        } else {\\n            return amount * (10 ** (toDecimals - fromDecimals));\\n        }\\n    }\\n\\n    function shift(TrimmedAmount amount, uint8 toDecimals) internal pure returns (TrimmedAmount) {\\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\\n        return packTrimmedAmount(\\n            SafeCast.toUint64(scale(getAmount(amount), getDecimals(amount), actualToDecimals)),\\n            actualToDecimals\\n        );\\n    }\\n\\n    function max(uint8 decimals) internal pure returns (TrimmedAmount) {\\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\\n        return packTrimmedAmount(type(uint64).max, actualDecimals);\\n    }\\n\\n    /// @dev trim the amount to target decimals.\\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\\n    ///      destroyed on either side of the transfer.\\n    /// @param amt the amount to be trimmed\\n    /// @param fromDecimals the original decimals of the amount\\n    /// @param toDecimals the target decimals of the amount\\n    /// @return TrimmedAmount uint72 value type bit-packed with decimals\\n    function trim(\\n        uint256 amt,\\n        uint8 fromDecimals,\\n        uint8 toDecimals\\n    ) internal pure returns (TrimmedAmount) {\\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\\n\\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\\n        // trimming, as Solana only supports uint64 for token amts)\\n        return packTrimmedAmount(SafeCast.toUint64(amountScaled), actualToDecimals);\\n    }\\n\\n    function untrim(TrimmedAmount amt, uint8 toDecimals) internal pure returns (uint256) {\\n        uint256 deNorm = uint256(getAmount(amt));\\n        uint8 fromDecimals = getDecimals(amt);\\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\\n\\n        return amountScaled;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWormholeTransceiverState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\n\\ninterface IWormholeTransceiverState {\\n    /// @notice Emitted when a message is sent from the transceiver.\\n    /// @dev Topic0\\n    ///      0xc3192e083c87c556db539f071d8a298869f487e951327b5616a6f85ae3da958e.\\n    /// @param relayingType The type of relaying.\\n    /// @param deliveryPayment The amount of ether sent along with the tx to cover the delivery fee.\\n    event RelayingInfo(uint8 relayingType, bytes32 refundAddress, uint256 deliveryPayment);\\n\\n    /// @notice Emitted when a peer transceiver is set.\\n    /// @dev Topic0\\n    ///      0xa559263ee060c7a2560843b3a064ff0376c9753ae3e2449b595a3b615d326466.\\n    /// @param chainId The chain ID of the peer.\\n    /// @param peerContract The address of the peer contract.\\n    event SetWormholePeer(uint16 chainId, bytes32 peerContract);\\n\\n    /// @notice Emitted when relaying is enabled for the given chain.\\n    /// @dev Topic0\\n    ///      0x528b18a533e892b5401d1fb63597275df9d2bb45b13e7695c3147cd07b9746c3.\\n    /// @param chainId The chain ID to set.\\n    /// @param isRelayingEnabled A boolean indicating whether relaying is enabled.\\n    event SetIsWormholeRelayingEnabled(uint16 chainId, bool isRelayingEnabled);\\n\\n    /// @notice Emitted when special relaying is enabled for the given chain.\\n    /// @dev Topic0\\n    ///      0x0fe301480713b2c2072ee91b3bcfcbf2c0014f0447c89046f020f0f80727003c.\\n    /// @param chainId The chain ID to set.\\n    event SetIsSpecialRelayingEnabled(uint16 chainId, bool isRelayingEnabled);\\n\\n    /// @notice Emitted when the chain is EVM compatible.\\n    /// @dev Topic0\\n    ///      0x50bbeb4e180e8f9e429f6ef6b53496616c747fe502441c4f423d5fc9ec958d9c.\\n    /// @param chainId The chain ID to set.\\n    /// @param isEvm A boolean indicating whether relaying is enabled.\\n    event SetIsWormholeEvmChain(uint16 chainId, bool isEvm);\\n\\n    /// @notice Additonal messages are not allowed.\\n    /// @dev Selector: 0xc504ea29.\\n    error UnexpectedAdditionalMessages();\\n\\n    /// @notice Error if the VAA is invalid.\\n    /// @dev Selector: 0x8ee2e336.\\n    /// @param reason The reason the VAA is invalid.\\n    error InvalidVaa(string reason);\\n\\n    /// @notice Error if the peer has already been set.\\n    /// @dev Selector: 0xb55eeae9.\\n    /// @param chainId The chain ID of the peer.\\n    /// @param peerAddress The address of the peer.\\n    error PeerAlreadySet(uint16 chainId, bytes32 peerAddress);\\n\\n    /// @notice Error the peer contract cannot be the zero address.\\n    /// @dev Selector: 0x26e0c7de.\\n    error InvalidWormholePeerZeroAddress();\\n\\n    /// @notice The chain ID cannot be zero.\\n    /// @dev Selector: 0x3dd98b24.\\n    error InvalidWormholeChainIdZero();\\n\\n    /// @notice The caller is not the relayer.\\n    /// @dev Selector: 0x1c269589.\\n    /// @param caller The caller.\\n    error CallerNotRelayer(address caller);\\n\\n    /// @notice Get the corresponding Transceiver contract on other chains that have been registered\\n    /// via governance. This design should be extendable to other chains, so each Transceiver would\\n    /// be potentially concerned with Transceivers on multiple other chains.\\n    /// @dev that peers are registered under Wormhole chain ID values.\\n    /// @param chainId The Wormhole chain ID of the peer to get.\\n    /// @return peerContract The address of the peer contract on the given chain.\\n    function getWormholePeer(uint16 chainId) external view returns (bytes32);\\n\\n    /// @notice Returns a boolean indicating whether the given VAA hash has been consumed.\\n    /// @param hash The VAA hash to check.\\n    function isVAAConsumed(bytes32 hash) external view returns (bool);\\n\\n    /// @notice Returns a boolean indicating whether Wormhole relaying is enabled for the given chain.\\n    /// @param chainId The Wormhole chain ID to check.\\n    function isWormholeRelayingEnabled(uint16 chainId) external view returns (bool);\\n\\n    /// @notice Returns a boolean indicating whether special relaying is enabled for the given chain.\\n    /// @param chainId The Wormhole chain ID to check.\\n    function isSpecialRelayingEnabled(uint16 chainId) external view returns (bool);\\n\\n    /// @notice Returns a boolean indicating whether the given chain is EVM compatible.\\n    /// @param chainId The Wormhole chain ID to check.\\n    function isWormholeEvmChain(uint16 chainId) external view returns (bool);\\n\\n    /// @notice Set the Wormhole peer contract for the given chain.\\n    /// @dev This function is only callable by the `owner`.\\n    /// @param chainId The Wormhole chain ID of the peer to set.\\n    /// @param peerContract The address of the peer contract on the given chain.\\n    function setWormholePeer(uint16 chainId, bytes32 peerContract) external payable;\\n\\n    /// @notice Set whether the chain is EVM compatible.\\n    /// @dev This function is only callable by the `owner`.\\n    /// @param chainId The Wormhole chain ID to set.\\n    /// @param isEvm A boolean indicating whether the chain is an EVM chain.\\n    function setIsWormholeEvmChain(uint16 chainId, bool isEvm) external;\\n\\n    /// @notice Set whether Wormhole relaying is enabled for the given chain.\\n    /// @dev This function is only callable by the `owner`.\\n    /// @param chainId The Wormhole chain ID to set.\\n    /// @param isRelayingEnabled A boolean indicating whether relaying is enabled.\\n    function setIsWormholeRelayingEnabled(uint16 chainId, bool isRelayingEnabled) external;\\n\\n    /// @notice Set whether special relaying is enabled for the given chain.\\n    /// @dev This function is only callable by the `owner`.\\n    /// @param chainId The Wormhole chain ID to set.\\n    /// @param isRelayingEnabled A boolean indicating whether special relaying is enabled.\\n    function setIsSpecialRelayingEnabled(uint16 chainId, bool isRelayingEnabled) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IManagerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\n\\ninterface IManagerBase {\\n    /// @notice The mode is either LOCKING or BURNING. In LOCKING mode, the NttManager locks the\\n    ///         tokens of the sender and mints an equivalent amount on the target chain. In BURNING\\n    ///         mode, the NttManager burns the tokens of the sender and mints an equivalent amount\\n    ///         on the target chain.LOCKING mode preserves the total supply of the tokens.\\n    enum Mode {\\n        LOCKING,\\n        BURNING\\n    }\\n\\n    /// @notice Information about attestations for a given message.\\n    /// @dev The fields are as follows:\\n    ///      - executed: whether the message has been executed.\\n    ///      - attested: bitmap of transceivers that have attested to this message.\\n    ///                  (NOTE: might contain disabled transceivers)\\n    struct AttestationInfo {\\n        bool executed;\\n        uint64 attestedTransceivers;\\n    }\\n\\n    struct _Sequence {\\n        uint64 num;\\n    }\\n\\n    struct _Threshold {\\n        uint8 num;\\n    }\\n\\n    /// @notice Emitted when a message has been attested to.\\n    /// @dev Topic0\\n    ///      0x35a2101eaac94b493e0dfca061f9a7f087913fde8678e7cde0aca9897edba0e5.\\n    /// @param digest The digest of the message.\\n    /// @param transceiver The address of the transceiver.\\n    /// @param index The index of the transceiver in the bitmap.\\n    event MessageAttestedTo(bytes32 digest, address transceiver, uint8 index);\\n\\n    /// @notice Emmitted when the threshold required transceivers is changed.\\n    /// @dev Topic0\\n    ///      0x2a855b929b9a53c6fb5b5ed248b27e502b709c088e036a5aa17620c8fc5085a9.\\n    /// @param oldThreshold The old threshold.\\n    /// @param threshold The new threshold.\\n    event ThresholdChanged(uint8 oldThreshold, uint8 threshold);\\n\\n    /// @notice Emitted when an transceiver is removed from the nttManager.\\n    /// @dev Topic0\\n    ///      0xc6289e62021fd0421276d06677862d6b328d9764cdd4490ca5ac78b173f25883.\\n    /// @param transceiver The address of the transceiver.\\n    /// @param transceiversNum The current number of transceivers.\\n    /// @param threshold The current threshold of transceivers.\\n    event TransceiverAdded(address transceiver, uint256 transceiversNum, uint8 threshold);\\n\\n    /// @notice Emitted when an transceiver is removed from the nttManager.\\n    /// @dev Topic0\\n    ///     0x638e631f34d9501a3ff0295873b29f50d0207b5400bf0e48b9b34719e6b1a39e.\\n    /// @param transceiver The address of the transceiver.\\n    /// @param threshold The current threshold of transceivers.\\n    event TransceiverRemoved(address transceiver, uint8 threshold);\\n\\n    /// @notice payment for a transfer is too low.\\n    /// @param requiredPayment The required payment.\\n    /// @param providedPayment The provided payment.\\n    error DeliveryPaymentTooLow(uint256 requiredPayment, uint256 providedPayment);\\n\\n    /// @notice Error when the refund to the sender fails.\\n    /// @dev Selector 0x2ca23714.\\n    /// @param refundAmount The refund amount.\\n    error RefundFailed(uint256 refundAmount);\\n\\n    /// @notice The number of thresholds should not be zero.\\n    error ZeroThreshold();\\n\\n    error RetrievedIncorrectRegisteredTransceivers(uint256 retrieved, uint256 registered);\\n\\n    /// @notice The threshold for transceiver attestations is too high.\\n    /// @param threshold The threshold.\\n    /// @param transceivers The number of transceivers.\\n    error ThresholdTooHigh(uint256 threshold, uint256 transceivers);\\n\\n    /// @notice Error when the tranceiver already attested to the message.\\n    ///         To ensure the client does not continue to initiate calls to the attestationReceived function.\\n    /// @dev Selector 0x2113894.\\n    /// @param nttManagerMessageHash The hash of the message.\\n    error TransceiverAlreadyAttestedToMessage(bytes32 nttManagerMessageHash);\\n\\n    /// @notice Error when the message is not approved.\\n    /// @dev Selector 0x451c4fb0.\\n    /// @param msgHash The hash of the message.\\n    error MessageNotApproved(bytes32 msgHash);\\n\\n    /// @notice Emitted when a message has already been executed to\\n    ///         notify client of against retries.\\n    /// @dev Topic0\\n    ///      0x4069dff8c9df7e38d2867c0910bd96fd61787695e5380281148c04932d02bef2.\\n    /// @param sourceNttManager The address of the source nttManager.\\n    /// @param msgHash The keccak-256 hash of the message.\\n    event MessageAlreadyExecuted(bytes32 indexed sourceNttManager, bytes32 indexed msgHash);\\n\\n    /// @notice There are no transceivers enabled with the Manager\\n    /// @dev Selector 0x69cf632a\\n    error NoEnabledTransceivers();\\n\\n    /// @notice Error when the manager doesn't have a peer registered for the destination chain\\n    /// @dev Selector 0x3af256bc.\\n    /// @param chainId The target chain id\\n    error PeerNotRegistered(uint16 chainId);\\n\\n    /// @notice Fetch the delivery price for a given recipient chain transfer.\\n    /// @param recipientChain The chain ID of the transfer destination.\\n    /// @param transceiverInstructions The transceiver specific instructions for quoting and sending\\n    /// @return - The delivery prices associated with each enabled endpoint and the total price.\\n    function quoteDeliveryPrice(\\n        uint16 recipientChain,\\n        bytes memory transceiverInstructions\\n    ) external view returns (uint256[] memory, uint256);\\n\\n    /// @notice Sets the threshold for the number of attestations required for a message\\n    /// to be considered valid.\\n    /// @param threshold The new threshold.\\n    /// @dev This method can only be executed by the `owner`.\\n    function setThreshold(uint8 threshold) external;\\n\\n    /// @notice Sets the transceiver for the given chain.\\n    /// @param transceiver The address of the transceiver.\\n    /// @dev This method can only be executed by the `owner`.\\n    function setTransceiver(address transceiver) external;\\n\\n    /// @notice Removes the transceiver for the given chain.\\n    /// @param transceiver The address of the transceiver.\\n    /// @dev This method can only be executed by the `owner`.\\n    function removeTransceiver(address transceiver) external;\\n\\n    /// @notice Checks if a message has been approved. The message should have at least\\n    /// the minimum threshold of attestations from distinct endpoints.\\n    /// @param digest The digest of the message.\\n    /// @return - Boolean indicating if message has been approved.\\n    function isMessageApproved(bytes32 digest) external view returns (bool);\\n\\n    /// @notice Checks if a message has been executed.\\n    /// @param digest The digest of the message.\\n    /// @return - Boolean indicating if message has been executed.\\n    function isMessageExecuted(bytes32 digest) external view returns (bool);\\n\\n    /// @notice Returns the next message sequence.\\n    function nextMessageSequence() external view returns (uint64);\\n\\n    /// @notice Upgrades to a new manager implementation.\\n    /// @dev This is upgraded via a proxy, and can only be executed\\n    /// by the `owner`.\\n    /// @param newImplementation The address of the new implementation.\\n    function upgrade(address newImplementation) external;\\n\\n    /// @notice Pauses the manager.\\n    function pause() external;\\n\\n    /// @notice Returns the mode (locking or burning) of the NttManager.\\n    /// @return mode A uint8 corresponding to the mode\\n    function getMode() external view returns (uint8);\\n\\n    /// @notice Returns the number of Transceivers that must attest to a msgId for\\n    /// it to be considered valid and acted upon.\\n    function getThreshold() external view returns (uint8);\\n\\n    /// @notice Returns a boolean indicating if the transceiver has attested to the message.\\n    function transceiverAttestedToMessage(\\n        bytes32 digest,\\n        uint8 index\\n    ) external view returns (bool);\\n\\n    /// @notice Returns the number of attestations for a given message.\\n    function messageAttestations(bytes32 digest) external view returns (uint8 count);\\n\\n    /// @notice Returns of the address of the token managed by this contract.\\n    function token() external view returns (address);\\n\\n    /// @notice Returns the chain ID.\\n    function chainId() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"src/libraries/BooleanFlag.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity >=0.8.8 <0.9.0;\\n\\n/// @dev A boolean flag represented as a uint256 (the native EVM word size)\\n/// This is more gas efficient when setting and clearing the flag\\ntype BooleanFlag is uint256;\\n\\nlibrary BooleanFlagLib {\\n    /// @notice Error when boolean flag is not 0 or 1\\n    /// @dev Selector: 0x837017c0.\\n    /// @param value The value of the boolean flag\\n    error InvalidBoolValue(BooleanFlag value);\\n\\n    uint256 constant FALSE = 0;\\n    uint256 constant TRUE = 1;\\n\\n    function isSet(BooleanFlag value) internal pure returns (bool) {\\n        return BooleanFlag.unwrap(value) == TRUE;\\n    }\\n\\n    function toBool(BooleanFlag value) internal pure returns (bool) {\\n        if (BooleanFlag.unwrap(value) == 0) return false;\\n        if (BooleanFlag.unwrap(value) == 1) return true;\\n\\n        revert InvalidBoolValue(value);\\n    }\\n\\n    function toWord(bool value) internal pure returns (BooleanFlag) {\\n        if (value) {\\n            return BooleanFlag.wrap(TRUE);\\n        } else {\\n            return BooleanFlag.wrap(FALSE);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Transceiver/Transceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"wormhole-solidity-sdk/Utils.sol\\\";\\n\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\nimport \\\"../libraries/PausableOwnable.sol\\\";\\nimport \\\"../libraries/external/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../libraries/Implementation.sol\\\";\\n\\nimport \\\"../interfaces/INttManager.sol\\\";\\nimport \\\"../interfaces/ITransceiver.sol\\\";\\n\\n/// @title Transceiver\\n/// @author Wormhole Project Contributors.\\n/// @notice This contract is a base contract for Transceivers.\\n/// @dev The Transceiver provides basic functionality for transmitting / receiving NTT messages.\\n///      The contract supports pausing via an admin or owner and is upgradable.\\n///\\n/// @dev The interface for receiving messages is not enforced by this contract.\\n///      Instead, inheriting contracts should implement their own receiving logic,\\n///      based on the verification model and serde logic associated with message handling.\\nabstract contract Transceiver is\\n    ITransceiver,\\n    PausableOwnable,\\n    ReentrancyGuardUpgradeable,\\n    Implementation\\n{\\n    /// @dev updating bridgeNttManager requires a new Transceiver deployment.\\n    /// Projects should implement their own governance to remove the old Transceiver\\n    /// contract address and then add the new one.\\n    address public immutable nttManager;\\n    address public immutable nttManagerToken;\\n    address immutable deployer;\\n\\n    constructor(address _nttManager) {\\n        nttManager = _nttManager;\\n        nttManagerToken = INttManager(nttManager).token();\\n        deployer = msg.sender;\\n    }\\n\\n    /// =============== MODIFIERS ===============================================\\n\\n    modifier onlyNttManager() {\\n        if (msg.sender != nttManager) {\\n            revert CallerNotNttManager(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /// =============== ADMIN ===============================================\\n\\n    function _initialize() internal virtual override {\\n        // check if the owner is the deployer of this contract\\n        if (msg.sender != deployer) {\\n            revert UnexpectedDeployer(deployer, msg.sender);\\n        }\\n\\n        __ReentrancyGuard_init();\\n        // owner of the transceiver is set to the owner of the nttManager\\n        __PausedOwnable_init(msg.sender, getNttManagerOwner());\\n    }\\n\\n    /// @dev transfer the ownership of the transceiver to a new address\\n    /// the nttManager should be able to update transceiver ownership.\\n    function transferTransceiverOwnership(address newOwner) external onlyNttManager {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function upgrade(address newImplementation) external onlyOwner {\\n        _upgrade(newImplementation);\\n    }\\n\\n    function _migrate() internal virtual override {}\\n\\n    // @define This method checks that the the referecnes to the nttManager and its corresponding function\\n    // are correct When new immutable variables are added, this function should be updated.\\n    function _checkImmutables() internal view virtual override {\\n        assert(this.nttManager() == nttManager);\\n        assert(this.nttManagerToken() == nttManagerToken);\\n    }\\n\\n    /// =============== GETTERS & SETTERS ===============================================\\n\\n    function getNttManagerOwner() public view returns (address) {\\n        return IOwnableUpgradeable(nttManager).owner();\\n    }\\n\\n    function getNttManagerToken() public view virtual returns (address) {\\n        return nttManagerToken;\\n    }\\n\\n    /// =============== TRANSCEIVING LOGIC ===============================================\\n\\n    /// @inheritdoc ITransceiver\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TransceiverStructs.TransceiverInstruction memory instruction\\n    ) external view returns (uint256) {\\n        return _quoteDeliveryPrice(targetChain, instruction);\\n    }\\n\\n    /// @inheritdoc ITransceiver\\n    function sendMessage(\\n        uint16 recipientChain,\\n        TransceiverStructs.TransceiverInstruction memory instruction,\\n        bytes memory nttManagerMessage,\\n        bytes32 recipientNttManagerAddress,\\n        bytes32 refundAddress\\n    ) external payable nonReentrant onlyNttManager {\\n        _sendMessage(\\n            recipientChain,\\n            msg.value,\\n            msg.sender,\\n            recipientNttManagerAddress,\\n            refundAddress,\\n            instruction,\\n            nttManagerMessage\\n        );\\n    }\\n\\n    /// ============================= INTERNAL =========================================\\n\\n    function _sendMessage(\\n        uint16 recipientChain,\\n        uint256 deliveryPayment,\\n        address caller,\\n        bytes32 recipientNttManagerAddress,\\n        bytes32 refundAddress,\\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction,\\n        bytes memory nttManagerMessage\\n    ) internal virtual;\\n\\n    // @define This method is called by the BridgeNttManager contract to send a cross-chain message.\\n    // @reverts if:\\n    //     - `recipientNttManagerAddress` does not match the address of this manager contract\\n    function _deliverToNttManager(\\n        uint16 sourceChainId,\\n        bytes32 sourceNttManagerAddress,\\n        bytes32 recipientNttManagerAddress,\\n        TransceiverStructs.NttManagerMessage memory payload\\n    ) internal virtual {\\n        if (recipientNttManagerAddress != toWormholeFormat(nttManager)) {\\n            revert UnexpectedRecipientNttManagerAddress(\\n                toWormholeFormat(nttManager), recipientNttManagerAddress\\n            );\\n        }\\n        INttManager(nttManager).attestationReceived(sourceChainId, sourceNttManagerAddress, payload);\\n    }\\n\\n    function _quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction\\n    ) internal view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/ITokenBridge.sol\": {\r\n      \"content\": \"// contracts/Bridge.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IWormhole.sol\\\";\\n\\ninterface ITokenBridge {\\n    struct Transfer {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        uint256 fee;\\n    }\\n\\n    struct TransferWithPayload {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        bytes32 fromAddress;\\n        bytes payload;\\n    }\\n\\n    struct AssetMeta {\\n        uint8 payloadID;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        uint8 decimals;\\n        bytes32 symbol;\\n        bytes32 name;\\n    }\\n\\n    struct RegisterChain {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n        uint16 emitterChainID;\\n        bytes32 emitterAddress;\\n    }\\n\\n    struct UpgradeContract {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n        bytes32 newContract;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n\\n    function _parseTransferCommon(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);\\n\\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient,\\n        uint256 arbiterFee,\\n        uint32 nonce\\n    ) external payable returns (uint64 sequence);\\n\\n    function transferTokensWithPayload(\\n        address token,\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient,\\n        uint32 nonce,\\n        bytes memory payload\\n    ) external payable returns (uint64 sequence);\\n\\n    function updateWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function createWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransfer(bytes memory encodedVm) external;\\n\\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\\n\\n    function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\\n\\n    function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\\n\\n    function encodeTransferWithPayload(TransferWithPayload memory transfer)\\n        external\\n        pure\\n        returns (bytes memory encoded);\\n\\n    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\\n\\n    function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\\n\\n    function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function parseTransferWithPayload(bytes memory encoded)\\n        external\\n        pure\\n        returns (TransferWithPayload memory transfer);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\\n\\n    function wormhole() external view returns (IWormhole);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\\n\\n    function bridgeContracts(uint16 chainId_) external view returns (bytes32);\\n\\n    function tokenImplementation() external view returns (address);\\n\\n    function WETH() external view returns (IWETH);\\n\\n    function outstandingBridged(address token) external view returns (uint256);\\n\\n    function isWrappedAsset(address token) external view returns (bool);\\n\\n    function finality() external view returns (uint8);\\n\\n    function implementation() external view returns (address);\\n\\n    function initialize() external;\\n\\n    function registerChain(bytes memory encodedVM) external;\\n\\n    function upgrade(bytes memory encodedVM) external;\\n\\n    function submitRecoverChainId(bytes memory encodedVM) external;\\n\\n    function parseRegisterChain(bytes memory encoded) external pure returns (RegisterChain memory chain);\\n\\n    function parseUpgrade(bytes memory encoded) external pure returns (UpgradeContract memory chain);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId)\\n        external\\n        pure\\n        returns (RecoverChainId memory rci);\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/CCTPInterfaces/ITokenMessenger.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\ninterface ITokenMessenger {\\n   /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\\n     * on the destination domain must be called by `destinationCaller`.\\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given destinationCaller is zero address\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - MessageTransmitter returns false or reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken address of contract to burn deposited tokens, on local domain\\n     * @param destinationCaller caller on the destination domain, as bytes32\\n     * @return nonce unique nonce reserved by message\\n     */\\n    function depositForBurnWithCaller(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken,\\n        bytes32 destinationCaller\\n    ) external returns (uint64 nonce);\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/CCTPInterfaces/IMessageTransmitter.sol\": {\r\n      \"content\": \"/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRelayer.sol\\\";\\nimport \\\"./IReceiver.sol\\\";\\n\\n/**\\n * @title IMessageTransmitter\\n * @notice Interface for message transmitters, which both relay and receive messages.\\n */\\ninterface IMessageTransmitter is IRelayer, IReceiver {\\n\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PausableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"./PausableUpgradeable.sol\\\";\\nimport \\\"./external/OwnableUpgradeable.sol\\\";\\n\\nabstract contract PausableOwnable is PausableUpgradeable, OwnableUpgradeable {\\n    /*\\n     * @dev Modifier to allow only the Pauser and the Owner to access pausing functionality\\n     */\\n    modifier onlyOwnerOrPauser() {\\n        _checkOwnerOrPauser(owner());\\n        _;\\n    }\\n\\n    /*\\n     * @dev Modifier to allow only the Pauser to access some functionality\\n     */\\n    function _checkOwnerOrPauser(address owner) internal view {\\n        if (pauser() != msg.sender && owner != msg.sender) {\\n            revert InvalidPauser(msg.sender);\\n        }\\n    }\\n\\n    function __PausedOwnable_init(address initialPauser, address owner) internal onlyInitializing {\\n        __Paused_init(initialPauser);\\n        __Ownable_init(owner);\\n    }\\n\\n    /**\\n     * @dev Transfers the ability to pause to a new account (`newPauser`).\\n     */\\n    function transferPauserCapability(address newPauser) public virtual onlyOwnerOrPauser {\\n        PauserStorage storage $ = _getPauserStorage();\\n        address oldPauser = $._pauser;\\n        $._pauser = newPauser;\\n        emit PauserTransferred(oldPauser, newPauser);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/external/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation =\\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"./external/Initializable.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/// @dev This contract should be used as a base contract for implementation contracts\\n///      that are used with ERC1967Proxy.\\n///      It ensures that the contract cannot be initialized directly, only through\\n///      the proxy (by disabling initializers in the constructor).\\n///      It also exposes a migrate function that is called during upgrades.\\nabstract contract Implementation is Initializable, ERC1967Upgrade {\\n    address immutable _this;\\n\\n    error OnlyDelegateCall();\\n    error NotMigrating();\\n\\n    constructor() {\\n        _disableInitializers();\\n        _this = address(this);\\n    }\\n\\n    modifier onlyDelegateCall() {\\n        _checkDelegateCall();\\n        _;\\n    }\\n\\n    struct _Migrating {\\n        bool isMigrating;\\n    }\\n\\n    struct _Bool {\\n        bool value;\\n    }\\n\\n    bytes32 private constant MIGRATING_SLOT = bytes32(uint256(keccak256(\\\"ntt.migrating\\\")) - 1);\\n\\n    bytes32 private constant MIGRATES_IMMUTABLES_SLOT =\\n        bytes32(uint256(keccak256(\\\"ntt.migratesImmutables\\\")) - 1);\\n\\n    function _getMigratingStorage() private pure returns (_Migrating storage $) {\\n        uint256 slot = uint256(MIGRATING_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _getMigratesImmutablesStorage() internal pure returns (_Bool storage $) {\\n        uint256 slot = uint256(MIGRATES_IMMUTABLES_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _checkDelegateCall() internal view {\\n        if (address(this) == _this) {\\n            revert OnlyDelegateCall();\\n        }\\n    }\\n\\n    function initialize() external payable onlyDelegateCall initializer {\\n        _initialize();\\n    }\\n\\n    function migrate() external onlyDelegateCall reinitializer(_getInitializedVersion() + 1) {\\n        // NOTE: we add the reinitializer() modifier so that onlyInitializing\\n        // functions can be called inside\\n        if (!_getMigratingStorage().isMigrating) {\\n            revert NotMigrating();\\n        }\\n        _migrate();\\n    }\\n\\n    function _migrate() internal virtual;\\n\\n    function _initialize() internal virtual;\\n\\n    function _checkImmutables() internal view virtual;\\n\\n    function _upgrade(address newImplementation) internal {\\n        _checkDelegateCall();\\n        _upgradeTo(newImplementation);\\n\\n        _Migrating storage _migrating = _getMigratingStorage();\\n        assert(!_migrating.isMigrating);\\n        _migrating.isMigrating = true;\\n\\n        this.migrate();\\n        if (!this.getMigratesImmutables()) {\\n            _checkImmutables();\\n        }\\n        _setMigratesImmutables(false);\\n\\n        _migrating.isMigrating = false;\\n    }\\n\\n    function getMigratesImmutables() public view returns (bool) {\\n        return _getMigratesImmutablesStorage().value;\\n    }\\n\\n    function _setMigratesImmutables(bool value) internal {\\n        _getMigratesImmutablesStorage().value = value;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITransceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport \\\"../libraries/TransceiverStructs.sol\\\";\\n\\ninterface ITransceiver {\\n    /// @notice The caller is not the deployer.\\n    /// @dev Selector: 0xc68a0e42.\\n    /// @param deployer The address of the deployer.\\n    /// @param caller The address of the caller.\\n    error UnexpectedDeployer(address deployer, address caller);\\n\\n    /// @notice The caller is not the NttManager.\\n    /// @dev Selector: 0xc5aa6153.\\n    /// @param caller The address of the caller.\\n    error CallerNotNttManager(address caller);\\n\\n    /// @notice Error when trying renounce transceiver ownership.\\n    ///         Ensures the owner of the transceiver is in sync with\\n    ///         the owner of the NttManager.\\n    /// @dev Selector: 0x66791dd6.\\n    /// @param currentOwner he current owner of the transceiver.\\n    error CannotRenounceTransceiverOwnership(address currentOwner);\\n\\n    /// @notice Error when trying to transfer transceiver ownership.\\n    /// @dev Selector: 0x306239eb.\\n    /// @param currentOwner The current owner of the transceiver.\\n    /// @param newOwner The new owner of the transceiver.\\n    error CannotTransferTransceiverOwnership(address currentOwner, address newOwner);\\n\\n    /// @notice Error when the recipient NttManager address is not the\\n    ///         corresponding manager of the transceiver.\\n    /// @dev Selector: 0x73bdd322.\\n    /// @param recipientNttManagerAddress The address of the recipient NttManager.\\n    /// @param expectedRecipientNttManagerAddress The expected address of the recipient NttManager.\\n    error UnexpectedRecipientNttManagerAddress(\\n        bytes32 recipientNttManagerAddress, bytes32 expectedRecipientNttManagerAddress\\n    );\\n\\n    /// @notice Fetch the delivery price for a given recipient chain transfer.\\n    /// @param recipientChain The Wormhole chain ID of the target chain.\\n    /// @param instruction An additional Instruction provided by the Transceiver to be\\n    ///        executed on the recipient chain.\\n    /// @return deliveryPrice The cost of delivering a message to the recipient chain,\\n    ///         in this chain's native token.\\n    function quoteDeliveryPrice(\\n        uint16 recipientChain,\\n        TransceiverStructs.TransceiverInstruction memory instruction\\n    ) external view returns (uint256);\\n\\n    /// @dev Send a message to another chain.\\n    /// @param recipientChain The Wormhole chain ID of the recipient.\\n    /// @param instruction An additional Instruction provided by the Transceiver to be\\n    /// executed on the recipient chain.\\n    /// @param nttManagerMessage A message to be sent to the nttManager on the recipient chain.\\n    function sendMessage(\\n        uint16 recipientChain,\\n        TransceiverStructs.TransceiverInstruction memory instruction,\\n        bytes memory nttManagerMessage,\\n        bytes32 recipientNttManagerAddress,\\n        bytes32 refundAddress\\n    ) external payable;\\n\\n    /// @notice Upgrades the transceiver to a new implementation.\\n    function upgrade(address newImplementation) external;\\n\\n    /// @notice Transfers the ownership of the transceiver to a new address.\\n    function transferTransceiverOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/IWETH.sol\": {\r\n      \"content\": \"// contracts/Bridge.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/CCTPInterfaces/IRelayer.sol\": {\r\n      \"content\": \"/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IRelayer\\n * @notice Sends messages from source domain to destination domain\\n */\\ninterface IRelayer {\\n    /**\\n     * @notice Sends an outgoing message from the source domain.\\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\\n     * @param destinationDomain Domain of destination chain\\n     * @param recipient Address of message recipient on destination domain as bytes32\\n     * @param messageBody Raw bytes content of message\\n     * @return nonce reserved by message\\n     */\\n    function sendMessage(\\n        uint32 destinationDomain,\\n        bytes32 recipient,\\n        bytes calldata messageBody\\n    ) external returns (uint64);\\n\\n    /**\\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\\n     * destination domain.\\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\\n     * @param destinationDomain Domain of destination chain\\n     * @param recipient Address of message recipient on destination domain as bytes32\\n     * @param destinationCaller caller on the destination domain, as bytes32\\n     * @param messageBody Raw bytes content of message\\n     * @return nonce reserved by message\\n     */\\n    function sendMessageWithCaller(\\n        uint32 destinationDomain,\\n        bytes32 recipient,\\n        bytes32 destinationCaller,\\n        bytes calldata messageBody\\n    ) external returns (uint64);\\n\\n    /**\\n     * @notice Replace a message with a new message body and/or destination caller.\\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\\n     * @param originalMessage original message to replace\\n     * @param originalAttestation attestation of `originalMessage`\\n     * @param newMessageBody new message body of replaced message\\n     * @param newDestinationCaller the new destination caller\\n     */\\n    function replaceMessage(\\n        bytes calldata originalMessage,\\n        bytes calldata originalAttestation,\\n        bytes calldata newMessageBody,\\n        bytes32 newDestinationCaller\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/wormhole-solidity-sdk/src/interfaces/CCTPInterfaces/IReceiver.sol\": {\r\n      \"content\": \"/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IReceiver\\n * @notice Receives messages on destination chain and forwards them to IMessageDestinationHandler\\n */\\ninterface IReceiver {\\n    /**\\n     * @notice Receives an incoming message, validating the header and passing\\n     * the body to application-specific handler.\\n     * @param message The message raw bytes\\n     * @param signature The message signature\\n     * @return success bool, true if successful\\n     */\\n    function receiveMessage(bytes calldata message, bytes calldata signature)\\n        external\\n        returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/libraries/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity >=0.8.8 <0.9.0;\\n\\n/**\\n * @dev Contact Module that allows children to implement logic to pause and unpause the contract.\\n * This is based on the OpenZeppelin Pausable contract but makes use of deterministic storage slots\\n * and the EVM native word size to optimize gas costs.\\n *\\n * The `whenPaused` and `whenNotPaused` modifiers are used to\\n * execute code based on the current state of the contract.\\n *\\n */\\nimport {Initializable} from \\\"./external/Initializable.sol\\\";\\n\\nabstract contract PausableUpgradeable is Initializable {\\n    /*\\n     * @custom:storage-location erc7201:openzeppelin.storage.Pausable.\\n     * @dev Storage slot with the pauser account, this is managed by the `PauserStorage` struct\\n    */\\n    struct PauserStorage {\\n        address _pauser;\\n    }\\n\\n    // @dev Storage slot with the pause flag, this is managed by the `PauseStorage` struct\\n    struct PauseStorage {\\n        uint256 _pauseFlag;\\n    }\\n\\n    /// NOTE: use uint256 to save on gas because it is the native word size of the EVM\\n    /// it is cheaper than using a bool because modifying a boolean value requires an extra SLOAD\\n    uint256 private constant NOT_PAUSED = 1;\\n    uint256 private constant PAUSED = 2;\\n\\n    event PauserTransferred(address indexed oldPauser, address indexed newPauser);\\n\\n    /**\\n     * @dev Contract is not paused, functionality is unblocked\\n     */\\n    error RequireContractIsNotPaused();\\n    /**\\n     * @dev Contract state is paused, blocking\\n     */\\n    error RequireContractIsPaused();\\n\\n    /**\\n     * @dev the pauser is not a valid pauser account (e.g. `address(0)`)\\n     */\\n    error InvalidPauser(address account);\\n\\n    // @dev Emitted when the contract is paused\\n    event Paused(bool paused);\\n    event NotPaused(bool notPaused);\\n\\n    bytes32 private constant PAUSE_SLOT = bytes32(uint256(keccak256(\\\"Pause.pauseFlag\\\")) - 1);\\n    bytes32 private constant PAUSER_ROLE_SLOT = bytes32(uint256(keccak256(\\\"Pause.pauseRole\\\")) - 1);\\n\\n    function _getPauserStorage() internal pure returns (PauserStorage storage $) {\\n        uint256 slot = uint256(PAUSER_ROLE_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current pauser account address.\\n     */\\n    function pauser() public view returns (address) {\\n        return _getPauserStorage()._pauser;\\n    }\\n\\n    function _getPauseStorage() private pure returns (PauseStorage storage $) {\\n        uint256 slot = uint256(PAUSE_SLOT);\\n        assembly (\\\"memory-safe\\\") {\\n            $.slot := slot\\n        }\\n    }\\n\\n    function _setPauseStorage(uint256 pauseFlag) internal {\\n        _getPauseStorage()._pauseFlag = pauseFlag;\\n    }\\n\\n    function __Paused_init(address initialPauser) internal onlyInitializing {\\n        __Paused_init_unchained(initialPauser);\\n    }\\n\\n    function __Paused_init_unchained(address initialPauser) internal onlyInitializing {\\n        // set pause flag to false initially\\n        PauseStorage storage $ = _getPauseStorage();\\n        $._pauseFlag = NOT_PAUSED;\\n\\n        // set the initial pauser\\n        PauserStorage storage $_role = _getPauserStorage();\\n        $_role._pauser = initialPauser;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\\n     */\\n    modifier whenNotPaused() {\\n        if (isPaused()) {\\n            revert RequireContractIsNotPaused();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\\n     */\\n    modifier whenPaused() {\\n        if (!isPaused()) {\\n            revert RequireContractIsPaused();\\n        }\\n        _;\\n    }\\n\\n    /*\\n     * @dev Modifier to allow only the Pauser to access pausing functionality\\n     */\\n    modifier onlyPauser() {\\n        _checkPauser();\\n        _;\\n    }\\n\\n    /*\\n     * @dev Modifier to allow only the Pauser to access some functionality\\n     */\\n    function _checkPauser() internal view {\\n        if (pauser() != msg.sender) {\\n            revert InvalidPauser(msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev pauses the function and emits the `Paused` event\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        // this can only be set to PAUSED when the state is NOTPAUSED\\n        _setPauseStorage(PAUSED);\\n        emit Paused(true);\\n    }\\n\\n    /**\\n     * @dev unpauses the function\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        // this can only be set to NOTPAUSED when the state is PAUSED\\n        _setPauseStorage(NOT_PAUSED);\\n        emit NotPaused(false);\\n    }\\n\\n    /**\\n     * @dev Returns true if the method is paused, and false otherwise.\\n     */\\n    function isPaused() public view returns (bool) {\\n        PauseStorage storage $ = _getPauseStorage();\\n        return $._pauseFlag == PAUSED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/external/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\n// COPIED FROM OPENZEPPELIN v5.0.1\\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\\n\\npragma solidity ^0.8.19;\\n\\nimport {ContextUpgradeable} from \\\"./ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\nimport \\\"../../interfaces/IOwnableUpgradeable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable, IOwnableUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation =\\n        0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/external/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\n// COPIED FROM OPENZEPPELIN v5.0.1\\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE =\\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/external/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\n// COPIED FROM OPENZEPPELIN v5.0.1\\n// COPIED TO CHANGE SOLC FROM ^0.8.20 TO ^0.8.19\\n\\npragma solidity ^0.8.19;\\n\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {}\\n\\n    function __Context_init_unchained() internal onlyInitializing {}\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n//\\npragma solidity >=0.8.8 <0.9.0;\\n\\ninterface IOwnableUpgradeable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {\r\n      \"src/libraries/TransceiverStructs.sol\": {\r\n        \"TransceiverStructs\": \"0xd9122900F53E64E0074450374925B6eA374f5Cf1\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nttManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wormholeCoreBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wormholeRelayerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"specialRelayerAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_consistencyLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerNotNttManager\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerNotRelayer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"CannotRenounceTransceiverOwnership\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"CannotTransferTransceiverOwnership\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"val\",\"type\":\"uint8\"}],\"name\":\"InvalidBoolVal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"BooleanFlag\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidBoolValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"evmChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockChainId\",\"type\":\"uint256\"}],\"name\":\"InvalidFork\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidPauser\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"InvalidRelayingConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidVaa\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWormholeChainIdZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"peerAddress\",\"type\":\"bytes32\"}],\"name\":\"InvalidWormholePeer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWormholePeerZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"encodedLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedLength\",\"type\":\"uint256\"}],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NotAnEvmAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMigrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDelegateCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"peerAddress\",\"type\":\"bytes32\"}],\"name\":\"PeerAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequireContractIsNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequireContractIsPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vaaHash\",\"type\":\"bytes32\"}],\"name\":\"TransferAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedAdditionalMessages\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"UnexpectedDeployer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedRecipientNttManagerAddress\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedRecipientNttManagerAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"notPaused\",\"type\":\"bool\"}],\"name\":\"NotPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"emitterChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"name\":\"ReceivedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"emitterChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"}],\"name\":\"ReceivedRelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"relayingType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deliveryPayment\",\"type\":\"uint256\"}],\"name\":\"RelayingInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"recipientChain\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transceiverPayload\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct TransceiverStructs.TransceiverMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"SendTransceiverMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRelayingEnabled\",\"type\":\"bool\"}],\"name\":\"SetIsSpecialRelayingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEvm\",\"type\":\"bool\"}],\"name\":\"SetIsWormholeEvmChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRelayingEnabled\",\"type\":\"bool\"}],\"name\":\"SetIsWormholeRelayingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"peerContract\",\"type\":\"bytes32\"}],\"name\":\"SetWormholePeer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WORMHOLE_TRANSCEIVER_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consistencyLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"shouldSkipRelayerSend\",\"type\":\"bool\"}],\"internalType\":\"struct IWormholeTransceiver.WormholeTransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"name\":\"encodeWormholeTransceiverInstruction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigratesImmutables\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNttManagerOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNttManagerToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"getWormholePeer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"isSpecialRelayingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"isVAAConsumed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"isWormholeEvmChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"isWormholeRelayingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nttManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nttManagerToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"parseWormholeTransceiverInstruction\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"shouldSkipRelayerSend\",\"type\":\"bool\"}],\"internalType\":\"struct IWormholeTransceiver.WormholeTransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"}],\"name\":\"quoteDeliveryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedMessage\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"additionalMessages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"receiveWormholeMessages\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"recipientChain\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct TransceiverStructs.TransceiverInstruction\",\"name\":\"instruction\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"nttManagerMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"recipientNttManagerAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"setIsSpecialRelayingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isEvm\",\"type\":\"bool\"}],\"name\":\"setIsWormholeEvmChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"setIsWormholeRelayingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"peerChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"peerContract\",\"type\":\"bytes32\"}],\"name\":\"setWormholePeer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialRelayer\",\"outputs\":[{\"internalType\":\"contract ISpecialRelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"transferPauserCapability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferTransceiverOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormhole\",\"outputs\":[{\"internalType\":\"contract IWormhole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormholeRelayer\",\"outputs\":[{\"internalType\":\"contract IWormholeRelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WormholeTransceiver", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cd024c7eb854f6799a343828773cb3a8107d17d400000000000000000000000098f3c9e6e3face36baad05fe09d375ef1464288b00000000000000000000000027428dd2d3dd32a4d7f7c497eaaa23130d89491100000000000000000000000063be47835c7d66c4aa5b2c688dc6ed9771c94c7400000000000000000000000000000000000000000000000000000000000000ca000000000000000000000000000000000000000000000000000000000007a120", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}