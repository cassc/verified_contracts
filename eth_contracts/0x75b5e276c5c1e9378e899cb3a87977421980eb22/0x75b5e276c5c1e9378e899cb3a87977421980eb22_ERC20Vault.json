{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokenvault/ERC20Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../bridge/IQuotaManager.sol\\\";\\nimport \\\"../common/LibStrings.sol\\\";\\nimport \\\"../libs/LibAddress.sol\\\";\\nimport \\\"./IBridgedERC20.sol\\\";\\nimport \\\"./BaseVault.sol\\\";\\n\\n/// @title ERC20Vault\\n/// @notice This vault holds all ERC20 tokens (excluding Ether) that users have\\n/// deposited. It also manages the mapping between canonical ERC20 tokens and\\n/// their bridged tokens. This vault does not support rebase/elastic tokens.\\n/// @dev Labeled in AddressResolver as \\\"erc20_vault\\\".\\n/// @custom:security-contact security@taiko.xyz\\ncontract ERC20Vault is BaseVault {\\n    using Address for address;\\n    using LibAddress for address;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant MIN_MIGRATION_DELAY = 90 days;\\n\\n    /// @dev Represents a canonical ERC20 token.\\n    struct CanonicalERC20 {\\n        uint64 chainId;\\n        address addr;\\n        uint8 decimals;\\n        string symbol;\\n        string name;\\n    }\\n\\n    /// @dev Represents an operation to send tokens to another chain.\\n    /// 4 slots\\n    struct BridgeTransferOp {\\n        // Destination chain ID.\\n        uint64 destChainId;\\n        // The owner of the bridge message on the destination chain.\\n        address destOwner;\\n        // Recipient address.\\n        address to;\\n        // Processing fee for the relayer.\\n        uint64 fee;\\n        // Address of the token.\\n        address token;\\n        // Gas limit for the operation.\\n        uint32 gasLimit;\\n        // Amount to be bridged.\\n        uint256 amount;\\n    }\\n\\n    /// @notice Mappings from bridged tokens to their canonical tokens.\\n    mapping(address btoken => CanonicalERC20 canonical) public bridgedToCanonical;\\n\\n    /// @notice Mappings from canonical tokens to their bridged tokens. Also storing\\n    /// the chainId for tokens across other chains aside from Ethereum.\\n    mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged;\\n\\n    /// @notice Mappings from bridged tokens to their blacklist status.\\n    mapping(address btoken => bool denied) public btokenDenylist;\\n\\n    /// @notice Mappings from ctoken to its last migration timestamp.\\n    mapping(uint256 chainId => mapping(address ctoken => uint256 timestamp)) public\\n        lastMigrationStart;\\n\\n    uint256[46] private __gap;\\n\\n    /// @notice Emitted when a new bridged token is deployed.\\n    /// @param srcChainId The chain ID of the canonical token.\\n    /// @param ctoken The address of the canonical token.\\n    /// @param btoken The address of the bridged token.\\n    /// @param ctokenSymbol The symbol of the canonical token.\\n    /// @param ctokenName The name of the canonical token.\\n    /// @param ctokenDecimal The decimal of the canonical token.\\n    event BridgedTokenDeployed(\\n        uint256 indexed srcChainId,\\n        address indexed ctoken,\\n        address indexed btoken,\\n        string ctokenSymbol,\\n        string ctokenName,\\n        uint8 ctokenDecimal\\n    );\\n\\n    /// @notice Emitted when a bridged token is changed.\\n    /// @param srcChainId The chain ID of the canonical token.\\n    /// @param ctoken The address of the canonical token.\\n    /// @param btokenOld The address of the old bridged token.\\n    /// @param btokenNew The address of the new bridged token.\\n    /// @param ctokenSymbol The symbol of the canonical token.\\n    /// @param ctokenName The name of the canonical token.\\n    /// @param ctokenDecimal The decimal of the canonical token.\\n    event BridgedTokenChanged(\\n        uint256 indexed srcChainId,\\n        address indexed ctoken,\\n        address btokenOld,\\n        address btokenNew,\\n        string ctokenSymbol,\\n        string ctokenName,\\n        uint8 ctokenDecimal\\n    );\\n\\n    /// @notice Emitted when a token is sent to another chain.\\n    /// @param msgHash The hash of the message.\\n    /// @param from The address of the sender.\\n    /// @param to The address of the recipient.\\n    /// @param canonicalChainId The chain ID of the canonical token.\\n    /// @param destChainId The chain ID of the destination chain.\\n    /// @param ctoken The address of the canonical token.\\n    /// @param token The address of the bridged token.\\n    /// @param amount The amount of tokens sent.\\n    event TokenSent(\\n        bytes32 indexed msgHash,\\n        address indexed from,\\n        address indexed to,\\n        uint64 canonicalChainId,\\n        uint64 destChainId,\\n        address ctoken,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when a token is released from a message.\\n    /// @param msgHash The hash of the message.\\n    /// @param from The address of the sender.\\n    /// @param ctoken The address of the canonical token.\\n    /// @param token The address of the bridged token.\\n    /// @param amount The amount of tokens released.\\n    event TokenReleased(\\n        bytes32 indexed msgHash, address indexed from, address ctoken, address token, uint256 amount\\n    );\\n\\n    /// @notice Emitted when a token is received from another chain.\\n    /// @param msgHash The hash of the message.\\n    /// @param from The address of the sender.\\n    /// @param to The address of the recipient.\\n    /// @param srcChainId The chain ID of the source chain.\\n    /// @param ctoken The address of the canonical token.\\n    /// @param token The address of the bridged token.\\n    /// @param amount The amount of tokens received.\\n    event TokenReceived(\\n        bytes32 indexed msgHash,\\n        address indexed from,\\n        address indexed to,\\n        uint64 srcChainId,\\n        address ctoken,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    error VAULT_BTOKEN_BLACKLISTED();\\n    error VAULT_CTOKEN_MISMATCH();\\n    error VAULT_INVALID_TOKEN();\\n    error VAULT_INVALID_AMOUNT();\\n    error VAULT_INVALID_CTOKEN();\\n    error VAULT_INVALID_NEW_BTOKEN();\\n    error VAULT_LAST_MIGRATION_TOO_CLOSE();\\n\\n    /// @notice Initializes the contract.\\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\\n    /// @param _addressManager The address of the {AddressManager} contract.\\n    function init(address _owner, address _addressManager) external initializer {\\n        __Essential_init(_owner, _addressManager);\\n    }\\n\\n    /// @notice Change bridged token.\\n    /// @param _ctoken The canonical token.\\n    /// @param _btokenNew The new bridged token address.\\n    /// @return btokenOld_ The old bridged token address.\\n    function changeBridgedToken(\\n        CanonicalERC20 calldata _ctoken,\\n        address _btokenNew\\n    )\\n        external\\n        onlyOwner\\n        nonReentrant\\n        returns (address btokenOld_)\\n    {\\n        if (\\n            _btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)\\n                || !_btokenNew.isContract()\\n        ) {\\n            revert VAULT_INVALID_NEW_BTOKEN();\\n        }\\n\\n        if (_ctoken.addr == address(0) || _ctoken.chainId == block.chainid) {\\n            revert VAULT_INVALID_CTOKEN();\\n        }\\n\\n        if (btokenDenylist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();\\n\\n        uint256 _lastMigrationStart = lastMigrationStart[_ctoken.chainId][_ctoken.addr];\\n        if (block.timestamp < _lastMigrationStart + MIN_MIGRATION_DELAY) {\\n            revert VAULT_LAST_MIGRATION_TOO_CLOSE();\\n        }\\n\\n        btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];\\n\\n        if (btokenOld_ != address(0)) {\\n            CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];\\n\\n            // The ctoken must match the saved one.\\n            if (keccak256(abi.encode(_ctoken)) != keccak256(abi.encode(ctoken))) {\\n                revert VAULT_CTOKEN_MISMATCH();\\n            }\\n\\n            delete bridgedToCanonical[btokenOld_];\\n            btokenDenylist[btokenOld_] = true;\\n\\n            // Start the migration\\n            if (\\n                btokenOld_.supportsInterface(type(IBridgedERC20Migratable).interfaceId)\\n                    && _btokenNew.supportsInterface(type(IBridgedERC20Migratable).interfaceId)\\n            ) {\\n                IBridgedERC20Migratable(btokenOld_).changeMigrationStatus(_btokenNew, false);\\n                IBridgedERC20Migratable(_btokenNew).changeMigrationStatus(btokenOld_, true);\\n            }\\n        }\\n\\n        bridgedToCanonical[_btokenNew] = _ctoken;\\n        canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;\\n        lastMigrationStart[_ctoken.chainId][_ctoken.addr] = block.timestamp;\\n\\n        emit BridgedTokenChanged({\\n            srcChainId: _ctoken.chainId,\\n            ctoken: _ctoken.addr,\\n            btokenOld: btokenOld_,\\n            btokenNew: _btokenNew,\\n            ctokenSymbol: _ctoken.symbol,\\n            ctokenName: _ctoken.name,\\n            ctokenDecimal: _ctoken.decimals\\n        });\\n    }\\n\\n    /// @notice Transfers ERC20 tokens to this vault and sends a message to the\\n    /// destination chain so the user can receive the same amount of tokens by\\n    /// invoking the message call.\\n    /// @param _op Option for sending ERC20 tokens.\\n    /// @return message_ The constructed message.\\n    function sendToken(BridgeTransferOp calldata _op)\\n        external\\n        payable\\n        whenNotPaused\\n        nonReentrant\\n        returns (IBridge.Message memory message_)\\n    {\\n        if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();\\n        if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();\\n        if (btokenDenylist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();\\n        if (msg.value < _op.fee) revert VAULT_INSUFFICIENT_FEE();\\n\\n        (bytes memory data, CanonicalERC20 memory ctoken, uint256 balanceChange) =\\n            _handleMessage(_op);\\n\\n        IBridge.Message memory message = IBridge.Message({\\n            id: 0, // will receive a new value\\n            from: address(0), // will receive a new value\\n            srcChainId: 0, // will receive a new value\\n            destChainId: _op.destChainId,\\n            srcOwner: msg.sender,\\n            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,\\n            to: resolve(_op.destChainId, name(), false),\\n            value: msg.value - _op.fee,\\n            fee: _op.fee,\\n            gasLimit: _op.gasLimit,\\n            data: data\\n        });\\n\\n        bytes32 msgHash;\\n        (msgHash, message_) =\\n            IBridge(resolve(LibStrings.B_BRIDGE, false)).sendMessage{ value: msg.value }(message);\\n\\n        emit TokenSent({\\n            msgHash: msgHash,\\n            from: message_.srcOwner,\\n            to: _op.to,\\n            canonicalChainId: ctoken.chainId,\\n            destChainId: _op.destChainId,\\n            ctoken: ctoken.addr,\\n            token: _op.token,\\n            amount: balanceChange\\n        });\\n    }\\n\\n    /// @inheritdoc IMessageInvocable\\n    function onMessageInvocation(bytes calldata _data) public payable whenNotPaused nonReentrant {\\n        (CanonicalERC20 memory ctoken, address from, address to, uint256 amount) =\\n            abi.decode(_data, (CanonicalERC20, address, address, uint256));\\n\\n        // `onlyFromBridge` checked in checkProcessMessageContext\\n        IBridge.Context memory ctx = checkProcessMessageContext();\\n\\n        // Don't allow sending to disallowed addresses.\\n        // Don't send the tokens back to `from` because `from` is on the source chain.\\n        checkToAddress(to);\\n\\n        // Transfer the ETH and the tokens to the `to` address\\n        address token = _transferTokens(ctoken, to, amount);\\n        to.sendEtherAndVerify(msg.value);\\n\\n        emit TokenReceived({\\n            msgHash: ctx.msgHash,\\n            from: from,\\n            to: to,\\n            srcChainId: ctx.srcChainId,\\n            ctoken: ctoken.addr,\\n            token: token,\\n            amount: amount\\n        });\\n    }\\n\\n    /// @inheritdoc IRecallableSender\\n    function onMessageRecalled(\\n        IBridge.Message calldata _message,\\n        bytes32 _msgHash\\n    )\\n        external\\n        payable\\n        override\\n        whenNotPaused\\n        nonReentrant\\n    {\\n        // `onlyFromBridge` checked in checkRecallMessageContext\\n        checkRecallMessageContext();\\n\\n        (bytes memory data) = abi.decode(_message.data[4:], (bytes));\\n        (CanonicalERC20 memory ctoken,,, uint256 amount) =\\n            abi.decode(data, (CanonicalERC20, address, address, uint256));\\n\\n        // Transfer the ETH and tokens back to the owner\\n        address token = _transferTokens(ctoken, _message.srcOwner, amount);\\n        _message.srcOwner.sendEtherAndVerify(_message.value);\\n\\n        emit TokenReleased({\\n            msgHash: _msgHash,\\n            from: _message.srcOwner,\\n            ctoken: ctoken.addr,\\n            token: token,\\n            amount: amount\\n        });\\n    }\\n\\n    /// @inheritdoc BaseVault\\n    function name() public pure override returns (bytes32) {\\n        return LibStrings.B_ERC20_VAULT;\\n    }\\n\\n    function _transferTokens(\\n        CanonicalERC20 memory _ctoken,\\n        address _to,\\n        uint256 _amount\\n    )\\n        private\\n        returns (address token_)\\n    {\\n        if (_ctoken.chainId == block.chainid) {\\n            token_ = _ctoken.addr;\\n            IERC20(token_).safeTransfer(_to, _amount);\\n        } else {\\n            token_ = _getOrDeployBridgedToken(_ctoken);\\n            //For native bridged tokens (like USDC), the mint() signature is the same, so no need to\\n            // check.\\n            IBridgedERC20(token_).mint(_to, _amount);\\n        }\\n        _consumeTokenQuota(token_, _amount);\\n    }\\n\\n    /// @dev Handles the message on the source chain and returns the encoded\\n    /// call on the destination call.\\n    /// @param _op The BridgeTransferOp object.\\n    /// @return msgData_ Encoded message data.\\n    /// @return ctoken_ The canonical token.\\n    /// @return balanceChange_ User token balance actual change after the token\\n    /// transfer. This value is calculated so we do not assume token balance\\n    /// change is the amount of token transferred away.\\n    function _handleMessage(BridgeTransferOp calldata _op)\\n        private\\n        returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)\\n    {\\n        // If it's a bridged token\\n        CanonicalERC20 storage _ctoken = bridgedToCanonical[_op.token];\\n        if (_ctoken.addr != address(0)) {\\n            ctoken_ = _ctoken;\\n            // Following the \\\"transfer and burn\\\" pattern, as used by USDC\\n            IERC20(_op.token).safeTransferFrom(msg.sender, address(this), _op.amount);\\n            IBridgedERC20(_op.token).burn(_op.amount);\\n            balanceChange_ = _op.amount;\\n        } else {\\n            // If it's a canonical token\\n            ctoken_ = CanonicalERC20({\\n                chainId: uint64(block.chainid),\\n                addr: _op.token,\\n                decimals: _safeDecimals(_op.token),\\n                symbol: safeSymbol(_op.token),\\n                name: safeName(_op.token)\\n            });\\n\\n            // Query the balance then query it again to get the actual amount of\\n            // token transferred into this address, this is more accurate than\\n            // simply using `amount` -- some contract may deduct a fee from the\\n            // transferred amount.\\n            IERC20 t = IERC20(_op.token);\\n            uint256 _balance = t.balanceOf(address(this));\\n            t.safeTransferFrom(msg.sender, address(this), _op.amount);\\n            balanceChange_ = t.balanceOf(address(this)) - _balance;\\n        }\\n\\n        msgData_ = abi.encodeCall(\\n            this.onMessageInvocation, abi.encode(ctoken_, msg.sender, _op.to, balanceChange_)\\n        );\\n    }\\n\\n    /// @dev Retrieve or deploy a bridged ERC20 token contract.\\n    /// @param ctoken CanonicalERC20 data.\\n    /// @return btoken Address of the bridged token contract.\\n    function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken)\\n        private\\n        returns (address btoken)\\n    {\\n        btoken = canonicalToBridged[ctoken.chainId][ctoken.addr];\\n\\n        if (btoken == address(0)) {\\n            btoken = _deployBridgedToken(ctoken);\\n        }\\n    }\\n\\n    /// @dev Deploy a new BridgedERC20 contract and initialize it.\\n    /// This must be called before the first time a bridged token is sent to\\n    /// this chain.\\n    /// @param ctoken CanonicalERC20 data.\\n    /// @return btoken Address of the deployed bridged token contract.\\n    function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) {\\n        bytes memory data = abi.encodeCall(\\n            IBridgedERC20Initializable.init,\\n            (\\n                owner(),\\n                addressManager,\\n                ctoken.addr,\\n                ctoken.chainId,\\n                ctoken.decimals,\\n                ctoken.symbol,\\n                ctoken.name\\n            )\\n        );\\n\\n        btoken = address(new ERC1967Proxy(resolve(LibStrings.B_BRIDGED_ERC20, false), data));\\n        bridgedToCanonical[btoken] = ctoken;\\n        canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken;\\n\\n        emit BridgedTokenDeployed({\\n            srcChainId: ctoken.chainId,\\n            ctoken: ctoken.addr,\\n            btoken: btoken,\\n            ctokenSymbol: ctoken.symbol,\\n            ctokenName: ctoken.name,\\n            ctokenDecimal: ctoken.decimals\\n        });\\n    }\\n\\n    function _consumeTokenQuota(address _token, uint256 _amount) private {\\n        address quotaManager = resolve(LibStrings.B_QUOTA_MANAGER, true);\\n        if (quotaManager != address(0)) {\\n            IQuotaManager(quotaManager).consumeQuota(_token, _amount);\\n        }\\n    }\\n\\n    function _safeDecimals(address _token) private view returns (uint8) {\\n        (bool success, bytes memory data) =\\n            address(_token).staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/IQuotaManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title IQuotaManager\\n/// @custom:security-contact security@taiko.xyz\\ninterface IQuotaManager {\\n    /// @notice Consumes a specific amount of quota for a given address.\\n    /// This function must revert if available quota is smaller than the given amount of quota.\\n    ///\\n    /// @dev Note that IQuotaManager is used by vaults and bridge, and should be registered in a\\n    /// shared address manager on the L1, therefore, a registered IQuotaManager and its per-token\\n    /// quota settings will be shared by all Taiko L2s. To enable a per-L2 quota, we need to modify\\n    /// this function to:\\n    ///  `function consumeQuota(uint256 _srcChainId, address _token, uint256 _amount) `\\n    ///\\n    /// @param _token The token address. Ether is represented with address(0).\\n    /// @param _amount The amount of quota to consume.\\n    function consumeQuota(address _token, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/common/LibStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title LibStrings\\n/// @custom:security-contact security@taiko.xyz\\nlibrary LibStrings {\\n    bytes32 internal constant B_AUTOMATA_DCAP_ATTESTATION = bytes32(\\\"automata_dcap_attestation\\\");\\n    bytes32 internal constant B_BRIDGE = bytes32(\\\"bridge\\\");\\n    bytes32 internal constant B_BRIDGE_WATCHDOG = bytes32(\\\"bridge_watchdog\\\");\\n    bytes32 internal constant B_BRIDGED_ERC1155 = bytes32(\\\"bridged_erc1155\\\");\\n    bytes32 internal constant B_BRIDGED_ERC20 = bytes32(\\\"bridged_erc20\\\");\\n    bytes32 internal constant B_BRIDGED_ERC721 = bytes32(\\\"bridged_erc721\\\");\\n    bytes32 internal constant B_CHAIN_WATCHDOG = bytes32(\\\"chain_watchdog\\\");\\n    bytes32 internal constant B_ERC1155_VAULT = bytes32(\\\"erc1155_vault\\\");\\n    bytes32 internal constant B_ERC20_VAULT = bytes32(\\\"erc20_vault\\\");\\n    bytes32 internal constant B_ERC721_VAULT = bytes32(\\\"erc721_vault\\\");\\n    bytes32 internal constant B_PROVER_ASSIGNMENT = bytes32(\\\"PROVER_ASSIGNMENT\\\");\\n    bytes32 internal constant B_PROVER_SET = bytes32(\\\"prover_set\\\");\\n    bytes32 internal constant B_QUOTA_MANAGER = bytes32(\\\"quota_manager\\\");\\n    bytes32 internal constant B_SGX_WATCHDOG = bytes32(\\\"sgx_watchdog\\\");\\n    bytes32 internal constant B_SIGNAL_SERVICE = bytes32(\\\"signal_service\\\");\\n    bytes32 internal constant B_TAIKO = bytes32(\\\"taiko\\\");\\n    bytes32 internal constant B_TAIKO_TOKEN = bytes32(\\\"taiko_token\\\");\\n    bytes32 internal constant B_TIER_GUARDIAN = bytes32(\\\"tier_guardian\\\");\\n    bytes32 internal constant B_TIER_GUARDIAN_MINORITY = bytes32(\\\"tier_guardian_minority\\\");\\n    bytes32 internal constant B_TIER_ROUTER = bytes32(\\\"tier_router\\\");\\n    bytes32 internal constant B_TIER_SGX = bytes32(\\\"tier_sgx\\\");\\n    bytes32 internal constant B_TIER_SGX_ZKVM = bytes32(\\\"tier_sgx_zkvm\\\");\\n    bytes32 internal constant B_WITHDRAWER = bytes32(\\\"withdrawer\\\");\\n    bytes32 internal constant H_RETURN_LIVENESS_BOND = keccak256(\\\"RETURN_LIVENESS_BOND\\\");\\n    bytes32 internal constant H_SIGNAL_ROOT = keccak256(\\\"SIGNAL_ROOT\\\");\\n    bytes32 internal constant H_STATE_ROOT = keccak256(\\\"STATE_ROOT\\\");\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\n\\n/// @title LibAddress\\n/// @dev Provides utilities for address-related operations.\\n/// @custom:security-contact security@taiko.xyz\\nlibrary LibAddress {\\n    error ETH_TRANSFER_FAILED();\\n\\n    /// @dev Sends Ether to the specified address. This method will not revert even if sending ether\\n    /// fails.\\n    /// This function is inspired by\\n    /// https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol\\n    /// @param _to The recipient address.\\n    /// @param _amount The amount of Ether to send in wei.\\n    /// @param _gasLimit The max amount gas to pay for this transaction.\\n    /// @return success_ true if the call is successful, false otherwise.\\n    function sendEther(\\n        address _to,\\n        uint256 _amount,\\n        uint256 _gasLimit,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool success_)\\n    {\\n        // Check for zero-address transactions\\n        if (_to == address(0)) revert ETH_TRANSFER_FAILED();\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gasLimit, // gas\\n                    _to, // recipient\\n                    _amount, // ether value\\n                    add(_calldata, 0x20), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends Ether to the specified address. This method will revert if sending ether fails.\\n    /// @param _to The recipient address.\\n    /// @param _amount The amount of Ether to send in wei.\\n    /// @param _gasLimit The max amount gas to pay for this transaction.\\n    function sendEtherAndVerify(address _to, uint256 _amount, uint256 _gasLimit) internal {\\n        if (_amount == 0) return;\\n        if (!sendEther(_to, _amount, _gasLimit, \\\"\\\")) {\\n            revert ETH_TRANSFER_FAILED();\\n        }\\n    }\\n\\n    /// @dev Sends Ether to the specified address. This method will revert if sending ether fails.\\n    /// @param _to The recipient address.\\n    /// @param _amount The amount of Ether to send in wei.\\n    function sendEtherAndVerify(address _to, uint256 _amount) internal {\\n        sendEtherAndVerify(_to, _amount, gasleft());\\n    }\\n\\n    function supportsInterface(\\n        address _addr,\\n        bytes4 _interfaceId\\n    )\\n        internal\\n        view\\n        returns (bool result_)\\n    {\\n        if (!Address.isContract(_addr)) return false;\\n\\n        try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) {\\n            result_ = _result;\\n        } catch { }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenvault/IBridgedERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title IBridgedERC20\\n/// @notice Interface for all bridged tokens.\\n/// @dev To facilitate compatibility with third-party bridged tokens, sometimes it might be\\n/// necessary to implement an intermediary adapter contract which should conform to this interface,\\n/// enabling effective interaction with third-party contracts.\\n/// @custom:security-contact security@taiko.xyz\\ninterface IBridgedERC20 {\\n    /// @notice Mints `amount` tokens and assigns them to the `account` address.\\n    /// @param _account The account to receive the minted tokens.\\n    /// @param _amount The amount of tokens to mint.\\n    function mint(address _account, uint256 _amount) external;\\n\\n    /// @notice Burns tokens from msg.sender. This is only allowed if:\\n    /// - 1) tokens are migrating out to a new bridged token\\n    /// - 2) The token is burned by ERC20Vault to bridge back to the canonical chain.\\n    /// @param _amount The amount of tokens to burn.\\n    function burn(uint256 _amount) external;\\n\\n    /// @notice Gets the canonical token's address and chain ID.\\n    /// @return The canonical token's address.\\n    /// @return The canonical token's chain ID.\\n    function canonical() external view returns (address, uint256);\\n}\\n\\n/// @title IBridgedERC20Migratable\\n/// @custom:security-contact security@taiko.xyz\\ninterface IBridgedERC20Migratable {\\n    /// @notice Starts or stops migration to/from a specified contract.\\n    /// @param _addr The address migrating 'to' or 'from'.\\n    /// @param _inbound If false then signals migrating 'from', true if migrating 'into'.\\n    function changeMigrationStatus(address _addr, bool _inbound) external;\\n}\\n\\n/// @title IBridgedERC20Initializable\\n/// @custom:security-contact security@taiko.xyz\\ninterface IBridgedERC20Initializable {\\n    /// @notice Initializes the contract.\\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\\n    /// @param _addressManager The address of the {AddressManager} contract.\\n    /// @param _srcToken The source token address.\\n    /// @param _srcChainId The source chain ID.\\n    /// @param _decimals The number of decimal places of the source token.\\n    /// @param _symbol The symbol of the token.\\n    /// @param _name The name of the token.\\n    function init(\\n        address _owner,\\n        address _addressManager,\\n        address _srcToken,\\n        uint256 _srcChainId,\\n        uint8 _decimals,\\n        string calldata _symbol,\\n        string calldata _name\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokenvault/BaseVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../common/EssentialContract.sol\\\";\\nimport \\\"../common/LibStrings.sol\\\";\\nimport \\\"../libs/LibBytes.sol\\\";\\n\\n/// @title INameSymbol\\n/// @notice Interface for contracts that provide name() and symbol()\\n/// functions. These functions may not be part of the official interface but are\\n/// used by some contracts.\\n/// @custom:security-contact security@taiko.xyz\\ninterface INameSymbol {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n}\\n\\n/// @title BaseVault\\n/// @notice This abstract contract provides a base implementation for vaults.\\n/// @custom:security-contact security@taiko.xyz\\nabstract contract BaseVault is\\n    EssentialContract,\\n    IRecallableSender,\\n    IMessageInvocable,\\n    IERC165Upgradeable\\n{\\n    using LibBytes for bytes;\\n\\n    uint256[50] private __gap;\\n\\n    error VAULT_INSUFFICIENT_FEE();\\n    error VAULT_INVALID_TO_ADDR();\\n    error VAULT_PERMISSION_DENIED();\\n\\n    /// @notice Checks if the contract supports the given interface.\\n    /// @param _interfaceId The interface identifier.\\n    /// @return true if the contract supports the interface, false otherwise.\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n        return _interfaceId == type(IRecallableSender).interfaceId\\n            || _interfaceId == type(IMessageInvocable).interfaceId\\n            || _interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /// @notice Returns the name of the vault.\\n    /// @return The name of the vault.\\n    function name() public pure virtual returns (bytes32);\\n\\n    function checkProcessMessageContext()\\n        internal\\n        view\\n        onlyFromNamed(LibStrings.B_BRIDGE)\\n        returns (IBridge.Context memory ctx_)\\n    {\\n        ctx_ = IBridge(msg.sender).context();\\n        address selfOnSourceChain = resolve(ctx_.srcChainId, name(), false);\\n        if (ctx_.from != selfOnSourceChain) revert VAULT_PERMISSION_DENIED();\\n    }\\n\\n    function checkRecallMessageContext()\\n        internal\\n        view\\n        onlyFromNamed(LibStrings.B_BRIDGE)\\n        returns (IBridge.Context memory ctx_)\\n    {\\n        ctx_ = IBridge(msg.sender).context();\\n        if (ctx_.from != msg.sender) revert VAULT_PERMISSION_DENIED();\\n    }\\n\\n    function checkToAddress(address _to) internal view {\\n        if (_to == address(0) || _to == address(this)) revert VAULT_INVALID_TO_ADDR();\\n    }\\n\\n    function safeSymbol(address _token) internal view returns (string memory symbol_) {\\n        (bool success, bytes memory data) =\\n            address(_token).staticcall(abi.encodeCall(INameSymbol.symbol, ()));\\n        return success ? data.toString() : \\\"\\\";\\n    }\\n\\n    function safeName(address _token) internal view returns (string memory) {\\n        (bool success, bytes memory data) =\\n            address(_token).staticcall(abi.encodeCall(INameSymbol.name, ()));\\n        return success ? data.toString() : \\\"\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title IBridge\\n/// @notice The bridge used in conjunction with the {ISignalService}.\\n/// @dev Ether is held by Bridges on L1 and L2s.\\n/// @custom:security-contact security@taiko.xyz\\ninterface IBridge {\\n    enum Status {\\n        NEW,\\n        RETRIABLE,\\n        DONE,\\n        FAILED,\\n        RECALLED\\n    }\\n\\n    enum StatusReason {\\n        INVOCATION_OK,\\n        INVOCATION_PROHIBITED,\\n        INVOCATION_FAILED,\\n        OUT_OF_ETH_QUOTA\\n    }\\n\\n    struct Message {\\n        // Message ID whose value is automatically assigned.\\n        uint64 id;\\n        // The max processing fee for the relayer. This fee has 3 parts:\\n        // - the fee for message calldata.\\n        // - the minimal fee reserve for general processing, excluding function call.\\n        // - the invocation fee for the function call.\\n        // Any unpaid fee will be refunded to the destOwner on the destination chain.\\n        // Note that fee must be 0 if gasLimit is 0, or large enough to make the invocation fee\\n        // non-zero.\\n        uint64 fee;\\n        // gasLimit that the processMessage call must have.\\n        uint32 gasLimit;\\n        // The address, EOA or contract, that interacts with this bridge.\\n        // The value is automatically assigned.\\n        address from;\\n        // Source chain ID whose value is automatically assigned.\\n        uint64 srcChainId;\\n        // The owner of the message on the source chain.\\n        address srcOwner;\\n        // Destination chain ID where the `to` address lives.\\n        uint64 destChainId;\\n        // The owner of the message on the destination chain.\\n        address destOwner;\\n        // The destination address on the destination chain.\\n        address to;\\n        // value to invoke on the destination chain.\\n        uint256 value;\\n        // callData to invoke on the destination chain.\\n        bytes data;\\n    }\\n\\n    // Struct representing the context of a bridge operation.\\n    // 2 slots\\n    struct Context {\\n        bytes32 msgHash; // Message hash.\\n        address from; // Sender's address.\\n        uint64 srcChainId; // Source chain ID.\\n    }\\n\\n    /// @notice Emitted when a message is sent.\\n    /// @param msgHash The hash of the message.\\n    /// @param message The message.\\n    event MessageSent(bytes32 indexed msgHash, Message message);\\n\\n    /// @notice Emitted when the status of a message changes.\\n    /// @param msgHash The hash of the message.\\n    /// @param status The new status of the message.\\n    event MessageStatusChanged(bytes32 indexed msgHash, Status status);\\n\\n    /// @notice Sends a message to the destination chain and takes custody\\n    /// of Ether required in this contract.\\n    /// @param _message The message to be sent.\\n    /// @return msgHash_ The hash of the sent message.\\n    /// @return message_ The updated message sent.\\n    function sendMessage(Message calldata _message)\\n        external\\n        payable\\n        returns (bytes32 msgHash_, Message memory message_);\\n\\n    /// @notice Recalls a failed message on its source chain, releasing\\n    /// associated assets.\\n    /// @dev This function checks if the message failed on the source chain and\\n    /// releases associated Ether or tokens.\\n    /// @param _message The message whose associated Ether should be released.\\n    /// @param _proof The merkle inclusion proof.\\n    function recallMessage(Message calldata _message, bytes calldata _proof) external;\\n\\n    /// @notice Processes a bridge message on the destination chain. This\\n    /// function is callable by any address, including the `message.destOwner`.\\n    /// @dev The process begins by hashing the message and checking the message\\n    /// status in the bridge  If the status is \\\"NEW\\\", the message is invoked. The\\n    /// status is updated accordingly, and processing fees are refunded as\\n    /// needed.\\n    /// @param _message The message to be processed.\\n    /// @param _proof The merkle inclusion proof.\\n    /// @return The message's status after processing and the reason for the change.\\n    function processMessage(\\n        Message calldata _message,\\n        bytes calldata _proof\\n    )\\n        external\\n        returns (Status, StatusReason);\\n\\n    /// @notice Retries to invoke the messageCall after releasing associated\\n    /// Ether and tokens.\\n    /// @dev This function can be called by any address, including the\\n    /// `message.destOwner`.\\n    /// It attempts to invoke the messageCall and updates the message status\\n    /// accordingly.\\n    /// @param _message The message to retry.\\n    /// @param _isLastAttempt Specifies if this is the last attempt to retry the\\n    /// message.\\n    function retryMessage(Message calldata _message, bool _isLastAttempt) external;\\n\\n    /// @notice Mark a message as failed if the message is currently retriable.\\n    /// @dev This function can only be called by `message.destOwner`.\\n    /// @param _message The message to fail.\\n    /// message.\\n    function failMessage(Message calldata _message) external;\\n\\n    /// @notice Returns the bridge state context.\\n    /// @return ctx_ The context of the current bridge operation.\\n    function context() external view returns (Context memory ctx_);\\n\\n    /// @notice Checks if the message was sent.\\n    /// @param _message The message.\\n    /// @return true if the message was sent.\\n    function isMessageSent(Message calldata _message) external view returns (bool);\\n\\n    /// @notice Hash the message\\n    /// @param _message The message struct variable to be hashed.\\n    /// @return The message's hash.\\n    function hashMessage(Message memory _message) external pure returns (bytes32);\\n}\\n\\n/// @title IRecallableSender\\n/// @notice An interface that all recallable message senders shall implement.\\ninterface IRecallableSender {\\n    /// @notice Called when a message is recalled.\\n    /// @param _message The recalled message.\\n    /// @param _msgHash The hash of the recalled message.\\n    function onMessageRecalled(\\n        IBridge.Message calldata _message,\\n        bytes32 _msgHash\\n    )\\n        external\\n        payable;\\n}\\n\\n/// @title IMessageInvocable\\n/// @notice An interface that all bridge message receiver shall implement\\ninterface IMessageInvocable {\\n    /// @notice Called when this contract is the bridge target.\\n    /// @param _data The data for this contract to interpret.\\n    /// @dev This method should be guarded with `onlyFromNamed(\\\"bridge\\\")`.\\n    function onMessageInvocation(bytes calldata _data) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/common/EssentialContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"./AddressResolver.sol\\\";\\nimport \\\"../libs/LibNetwork.sol\\\";\\n\\n/// @title EssentialContract\\n/// @custom:security-contact security@taiko.xyz\\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\\n    uint8 private constant _FALSE = 1;\\n\\n    uint8 private constant _TRUE = 2;\\n\\n    /// @dev The slot in transient storage of the reentry lock.\\n    /// This is the result of keccak256(\\\"ownerUUPS.reentry_slot\\\") plus 1. The addition aims to\\n    /// prevent hash collisions with slots defined in EIP-1967, where slots are derived by\\n    /// keccak256(\\\"something\\\") - 1, and with slots in SignalService, calculated directly with\\n    /// keccak256(\\\"something\\\").\\n    bytes32 private constant _REENTRY_SLOT =\\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721b;\\n\\n    /// @dev Slot 1.\\n    uint8 private __reentry;\\n    uint8 private __paused;\\n    uint64 public lastUnpausedAt;\\n\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when the contract is paused.\\n    /// @param account The account that paused the contract.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the contract is unpaused.\\n    /// @param account The account that unpaused the contract.\\n    event Unpaused(address account);\\n\\n    error INVALID_PAUSE_STATUS();\\n    error FUNC_NOT_IMPLEMENTED();\\n    error REENTRANT_CALL();\\n    error ZERO_ADDRESS();\\n    error ZERO_VALUE();\\n\\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\\n    /// @param _name The name to check against.\\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\\n        _;\\n    }\\n\\n    modifier notImplemented() {\\n        revert FUNC_NOT_IMPLEMENTED();\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\\n        _storeReentryLock(_TRUE);\\n        _;\\n        _storeReentryLock(_FALSE);\\n    }\\n\\n    modifier whenPaused() {\\n        if (!paused()) revert INVALID_PAUSE_STATUS();\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        if (paused()) revert INVALID_PAUSE_STATUS();\\n        _;\\n    }\\n\\n    modifier nonZeroAddr(address _addr) {\\n        if (_addr == address(0)) revert ZERO_ADDRESS();\\n        _;\\n    }\\n\\n    modifier nonZeroValue(bytes32 _value) {\\n        if (_value == 0) revert ZERO_VALUE();\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Pauses the contract.\\n    function pause() public virtual {\\n        _pause();\\n        // We call the authorize function here to avoid:\\n        // Warning (5740): Unreachable code.\\n        _authorizePause(msg.sender, true);\\n    }\\n\\n    /// @notice Unpauses the contract.\\n    function unpause() public virtual {\\n        _unpause();\\n        // We call the authorize function here to avoid:\\n        // Warning (5740): Unreachable code.\\n        _authorizePause(msg.sender, false);\\n    }\\n\\n    function impl() public view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /// @notice Returns true if the contract is paused, and false otherwise.\\n    /// @return true if paused, false otherwise.\\n    function paused() public view returns (bool) {\\n        return __paused == _TRUE;\\n    }\\n\\n    function inNonReentrant() public view returns (bool) {\\n        return _loadReentryLock() == _TRUE;\\n    }\\n\\n    /// @notice Initializes the contract.\\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\\n    /// @param _addressManager The address of the {AddressManager} contract.\\n    function __Essential_init(\\n        address _owner,\\n        address _addressManager\\n    )\\n        internal\\n        nonZeroAddr(_addressManager)\\n    {\\n        __Essential_init(_owner);\\n        __AddressResolver_init(_addressManager);\\n    }\\n\\n    function __Essential_init(address _owner) internal virtual onlyInitializing {\\n        __Context_init();\\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\\n        __paused = _FALSE;\\n    }\\n\\n    function _pause() internal whenNotPaused {\\n        __paused = _TRUE;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        __paused = _FALSE;\\n        lastUnpausedAt = uint64(block.timestamp);\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\\n\\n    function _authorizePause(address, bool) internal virtual onlyOwner { }\\n\\n    // Stores the reentry lock\\n    function _storeReentryLock(uint8 _reentry) internal virtual {\\n        if (LibNetwork.isDencunSupported(block.chainid)) {\\n            assembly {\\n                tstore(_REENTRY_SLOT, _reentry)\\n            }\\n        } else {\\n            __reentry = _reentry;\\n        }\\n    }\\n\\n    // Loads the reentry lock\\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\\n        if (LibNetwork.isDencunSupported(block.chainid)) {\\n            assembly {\\n                reentry_ := tload(_REENTRY_SLOT)\\n            }\\n        } else {\\n            reentry_ = __reentry;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nlibrary LibBytes {\\n    error INNER_ERROR(bytes innerError);\\n\\n    // Function body taken from:\\n    // https://github.com/clober-dex/core/blob/main/contracts/utils/BoringERC20.sol#L17-L33\\n    /// @notice Function to convert returned data to string\\n    /// returns '' as fallback value.\\n    function toString(bytes memory _data) internal pure returns (string memory) {\\n        if (_data.length >= 64) {\\n            return abi.decode(_data, (string));\\n        } else if (_data.length == 32) {\\n            uint8 i = 0;\\n            while (i < 32 && _data[i] != 0) {\\n                i++;\\n            }\\n            bytes memory bytesArray = new bytes(i);\\n            for (i = 0; i < 32 && _data[i] != 0; i++) {\\n                bytesArray[i] = _data[i];\\n            }\\n            return string(bytesArray);\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\\n\\n    // Taken from:\\n    // https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\\n    /// @dev Helper function to extract a useful revert message from a failed call.\\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail\\n    /// itself.\\n    function revertWithExtractedError(bytes memory _returnData) internal pure {\\n        // If the _res length is less than 68, then\\n        // the transaction failed with custom error or silently (without a revert message)\\n        if (_returnData.length < 68) revert INNER_ERROR(_returnData);\\n\\n        assembly {\\n            // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        revert(abi.decode(_returnData, (string))); // All that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/common/AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./IAddressManager.sol\\\";\\nimport \\\"./IAddressResolver.sol\\\";\\n\\n/// @title AddressResolver\\n/// @notice See the documentation in {IAddressResolver}.\\n/// @custom:security-contact security@taiko.xyz\\nabstract contract AddressResolver is IAddressResolver, Initializable {\\n    /// @notice Address of the AddressManager.\\n    address public addressManager;\\n    uint256[49] private __gap;\\n\\n    error RESOLVER_DENIED();\\n    error RESOLVER_INVALID_MANAGER();\\n    error RESOLVER_UNEXPECTED_CHAINID();\\n    error RESOLVER_ZERO_ADDR(uint64 chainId, bytes32 name);\\n\\n    /// @dev Modifier that ensures the caller is the resolved address of a given\\n    /// name.\\n    /// @param _name The name to check against.\\n    modifier onlyFromNamed(bytes32 _name) {\\n        if (msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\\n        _;\\n    }\\n\\n    /// @dev Modifier that ensures the caller is a resolved address to either _name1 or _name2\\n    /// name.\\n    /// @param _name1 The first name to check against.\\n    /// @param _name2 The second name to check against.\\n    modifier onlyFromNamedEither(bytes32 _name1, bytes32 _name2) {\\n        if (msg.sender != resolve(_name1, true) && msg.sender != resolve(_name2, true)) {\\n            revert RESOLVER_DENIED();\\n        }\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @inheritdoc IAddressResolver\\n    function resolve(\\n        bytes32 _name,\\n        bool _allowZeroAddress\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address payable)\\n    {\\n        return _resolve(uint64(block.chainid), _name, _allowZeroAddress);\\n    }\\n\\n    /// @inheritdoc IAddressResolver\\n    function resolve(\\n        uint64 _chainId,\\n        bytes32 _name,\\n        bool _allowZeroAddress\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address payable)\\n    {\\n        return _resolve(_chainId, _name, _allowZeroAddress);\\n    }\\n\\n    /// @dev Initialization method for setting up AddressManager reference.\\n    /// @param _addressManager Address of the AddressManager.\\n    function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing {\\n        if (block.chainid > type(uint64).max) {\\n            revert RESOLVER_UNEXPECTED_CHAINID();\\n        }\\n        addressManager = _addressManager;\\n    }\\n\\n    /// @dev Helper method to resolve name-to-address.\\n    /// @param _chainId The chainId of interest.\\n    /// @param _name Name whose address is to be resolved.\\n    /// @param _allowZeroAddress If set to true, does not throw if the resolved\\n    /// address is `address(0)`.\\n    /// @return addr_ Address associated with the given name on the specified\\n    /// chain.\\n    function _resolve(\\n        uint64 _chainId,\\n        bytes32 _name,\\n        bool _allowZeroAddress\\n    )\\n        private\\n        view\\n        returns (address payable addr_)\\n    {\\n        address _addressManager = addressManager;\\n        if (_addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();\\n\\n        addr_ = payable(IAddressManager(_addressManager).getAddress(_chainId, _name));\\n\\n        if (!_allowZeroAddress && addr_ == address(0)) {\\n            revert RESOLVER_ZERO_ADDR(_chainId, _name);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibNetwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title LibNetwork\\nlibrary LibNetwork {\\n    uint256 internal constant MAINNET = 1;\\n    uint256 internal constant ROPSTEN = 2;\\n    uint256 internal constant RINKEBY = 4;\\n    uint256 internal constant GOERLI = 5;\\n    uint256 internal constant KOVAN = 42;\\n    uint256 internal constant HOLESKY = 17_000;\\n    uint256 internal constant SEPOLIA = 11_155_111;\\n\\n    uint64 internal constant TAIKO = 167_000;\\n\\n    /// @dev Checks if the chain ID represents an Ethereum testnet.\\n    /// @param _chainId The chain ID.\\n    /// @return true if the chain ID represents an Ethereum testnet, false otherwise.\\n    function isEthereumTestnet(uint256 _chainId) internal pure returns (bool) {\\n        return _chainId == LibNetwork.ROPSTEN || _chainId == LibNetwork.RINKEBY\\n            || _chainId == LibNetwork.GOERLI || _chainId == LibNetwork.KOVAN\\n            || _chainId == LibNetwork.HOLESKY || _chainId == LibNetwork.SEPOLIA;\\n    }\\n\\n    /// @dev Checks if the chain ID represents an Ethereum testnet or the Etheruem mainnet.\\n    /// @param _chainId The chain ID.\\n    /// @return true if the chain ID represents an Ethereum testnet or the Etheruem mainnet, false\\n    /// otherwise.\\n    function isEthereumMainnetOrTestnet(uint256 _chainId) internal pure returns (bool) {\\n        return _chainId == LibNetwork.MAINNET || isEthereumTestnet(_chainId);\\n    }\\n\\n    /// @dev Checks if the chain ID represents the Taiko L2 mainnet.\\n    /// @param _chainId The chain ID.\\n    /// @return true if the chain ID represents the Taiko L2 mainnet.\\n    function isTaikoMainnet(uint256 _chainId) internal pure returns (bool) {\\n        return _chainId == TAIKO;\\n    }\\n\\n    /// @dev Checks if the chain ID represents an internal Taiko devnet's base layer.\\n    /// @param _chainId The chain ID.\\n    /// @return true if the chain ID represents an internal Taiko devnet's base layer, false\\n    /// otherwise.\\n    function isTaikoDevnet(uint256 _chainId) internal pure returns (bool) {\\n        return _chainId >= 32_300 && _chainId <= 32_400;\\n    }\\n\\n    /// @dev Checks if the chain supports Dencun hardfork. Note that this check doesn't need to be\\n    /// exhaustive.\\n    /// @param _chainId The chain ID.\\n    /// @return true if the chain supports Dencun hardfork, false otherwise.\\n    function isDencunSupported(uint256 _chainId) internal pure returns (bool) {\\n        return _chainId == LibNetwork.MAINNET || _chainId == LibNetwork.HOLESKY\\n            || _chainId == LibNetwork.SEPOLIA || isTaikoDevnet(_chainId);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC1967.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/IAddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title IAddressManager\\n/// @notice Manages a mapping of (chainId, name) pairs to Ethereum addresses.\\n/// @custom:security-contact security@taiko.xyz\\ninterface IAddressManager {\\n    /// @notice Gets the address mapped to a specific chainId-name pair.\\n    /// @dev Note that in production, this method shall be a pure function\\n    /// without any storage access.\\n    /// @param _chainId The chainId for which the address needs to be fetched.\\n    /// @param _name The name for which the address needs to be fetched.\\n    /// @return Address associated with the chainId-name pair.\\n    function getAddress(uint64 _chainId, bytes32 _name) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/common/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// @title IAddressResolver\\n/// @notice This contract acts as a bridge for name-to-address resolution.\\n/// It delegates the resolution to the AddressManager. By separating the logic,\\n/// we can maintain flexibility in address management without affecting the\\n/// resolving process.\\n/// @dev Note that the address manager should be changed using upgradability, there\\n/// is no setAddressManager() function to guarantee atomicity across all\\n/// contracts that are resolvers.\\n/// @custom:security-contact security@taiko.xyz\\ninterface IAddressResolver {\\n    /// @notice Resolves a name to its address deployed on this chain.\\n    /// @param _name Name whose address is to be resolved.\\n    /// @param _allowZeroAddress If set to true, does not throw if the resolved\\n    /// address is `address(0)`.\\n    /// @return Address associated with the given name.\\n    function resolve(\\n        bytes32 _name,\\n        bool _allowZeroAddress\\n    )\\n        external\\n        view\\n        returns (address payable);\\n\\n    /// @notice Resolves a name to its address deployed on a specified chain.\\n    /// @param _chainId The chainId of interest.\\n    /// @param _name Name whose address is to be resolved.\\n    /// @param _allowZeroAddress If set to true, does not throw if the resolved\\n    /// address is `address(0)`.\\n    /// @return Address associated with the given name on the specified\\n    /// chain.\\n    function resolve(\\n        uint64 _chainId,\\n        bytes32 _name,\\n        bool _allowZeroAddress\\n    )\\n        external\\n        view\\n        returns (address payable);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"solady/=node_modules/solady/\",\r\n      \"forge-std/=node_modules/forge-std/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"p256-verifier/=node_modules/p256-verifier/\",\r\n      \"forge-safe/=node_modules/forge-safe/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ETH_TRANSFER_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FUNC_NOT_IMPLEMENTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAUSE_STATUS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"REENTRANT_CALL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESOLVER_DENIED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESOLVER_INVALID_MANAGER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESOLVER_UNEXPECTED_CHAINID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"RESOLVER_ZERO_ADDR\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_BTOKEN_BLACKLISTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_CTOKEN_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INSUFFICIENT_FEE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INVALID_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INVALID_CTOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INVALID_NEW_BTOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INVALID_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_INVALID_TO_ADDR\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_LAST_MIGRATION_TOO_CLOSE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_PERMISSION_DENIED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_VALUE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"btokenOld\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"btokenNew\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ctokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ctokenName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctokenDecimal\",\"type\":\"uint8\"}],\"name\":\"BridgedTokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"btoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ctokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ctokenName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctokenDecimal\",\"type\":\"uint8\"}],\"name\":\"BridgedTokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"canonicalChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"destChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_MIGRATION_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"btoken\",\"type\":\"address\"}],\"name\":\"bridgedToCanonical\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"btoken\",\"type\":\"address\"}],\"name\":\"btokenDenylist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"denied\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"}],\"name\":\"canonicalToBridged\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"btoken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct ERC20Vault.CanonicalERC20\",\"name\":\"_ctoken\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_btokenNew\",\"type\":\"address\"}],\"name\":\"changeBridgedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"btokenOld_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inNonReentrant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressManager\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ctoken\",\"type\":\"address\"}],\"name\":\"lastMigrationStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUnpausedAt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onMessageInvocation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"fee\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"srcOwner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"destChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"destOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IBridge.Message\",\"name\":\"_message\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_msgHash\",\"type\":\"bytes32\"}],\"name\":\"onMessageRecalled\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_allowZeroAddress\",\"type\":\"bool\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_allowZeroAddress\",\"type\":\"bool\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"destChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"destOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"fee\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Vault.BridgeTransferOp\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"sendToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"fee\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"srcOwner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"destChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"destOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IBridge.Message\",\"name\":\"message_\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "ERC20Vault", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}