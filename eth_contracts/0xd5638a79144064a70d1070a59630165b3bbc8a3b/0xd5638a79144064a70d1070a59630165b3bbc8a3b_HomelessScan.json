{"SourceCode": "// Sources flattened with hardhat v2.12.3 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.9.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @solvprotocol/erc-3525/IERC721.sol@v1.3.0\r\n\r\n// \r\n\r\npragma solidity ^0.8.1;\r\n\r\n/** \r\n * @title ERC-721 Non-Fungible Token Standard\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n *  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /** \r\n     * @dev This emits when ownership of any NFT changes by any mechanism.\r\n     *  This event emits when NFTs are created (`from` == 0) and destroyed\r\n     *  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n     *  may be created and assigned without emitting Transfer. At the time of\r\n     *  any transfer, the approved address for that NFT (if any) is reset to none.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when the approved address for an NFT is changed or\r\n     *  reaffirmed. The zero address indicates there is no approved address.\r\n     *  When a Transfer event emits, this also indicates that the approved\r\n     *  address for that NFT (if any) is reset to none.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when an operator is enabled or disabled for an owner.\r\n     *  The operator can manage all NFTs of the owner.\r\n     */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @notice Count all NFTs assigned to an owner\r\n     * @dev NFTs assigned to the zero address are considered invalid, and this\r\n     *  function throws for queries about the zero address.\r\n     * @param _owner An address for whom to query the balance\r\n     * @return The number of NFTs owned by `_owner`, possibly zero\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Find the owner of an NFT\r\n     * @dev NFTs assigned to zero address are considered invalid, and queries\r\n     *  about them do throw.\r\n     * @param _tokenId The identifier for an NFT\r\n     * @return The address of the owner of the NFT\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n     *  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     *  `onERC721Received` on `_to` and throws if the return value is not\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     * @param data Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev This works identically to the other function with an extra data parameter,\r\n     *  except this function just sets data to \"\".\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n     *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n     *  THEY MAY BE PERMANENTLY LOST\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Change or reaffirm the approved address for an NFT\r\n     * @dev The zero address indicates there is no approved address.\r\n     *  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n     *  operator of the current owner.\r\n     * @param _approved The new approved NFT controller\r\n     * @param _tokenId The NFT to approve\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s assets\r\n     * @dev Emits the ApprovalForAll event. The contract MUST allow\r\n     *  multiple operators per owner.\r\n     * @param _operator Address to add to the set of authorized operators\r\n     * @param _approved True if the operator is approved, false to revoke approval\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n     * @notice Get the approved address for a single NFT\r\n     * @dev Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId The NFT to find the approved address for\r\n     * @return The approved address for this NFT, or the zero address if there is none\r\n     */\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @notice Query if an address is an authorized operator for another address\r\n     * @param _owner The address that owns the NFTs\r\n     * @param _operator The address that acts on behalf of the owner\r\n     * @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n\r\n// File @solvprotocol/erc-3525/IERC3525.sol@v1.3.0\r\n\r\n// \r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-3525 Semi-Fungible Token Standard\r\n * @dev See https://eips.ethereum.org/EIPS/eip-3525\r\n * Note: the ERC-165 identifier for this interface is 0xd5358140.\r\n */\r\ninterface IERC3525 is IERC165, IERC721 {\r\n    /**\r\n     * @dev MUST emit when value of a token is transferred to another token with the same slot,\r\n     *  including zero value transfers (_value == 0) as well as transfers when tokens are created\r\n     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).\r\n     * @param _fromTokenId The token id to transfer value from\r\n     * @param _toTokenId The token id to transfer value to\r\n     * @param _value The transferred value\r\n     */\r\n    event TransferValue(uint256 indexed _fromTokenId, uint256 indexed _toTokenId, uint256 _value);\r\n\r\n    /**\r\n     * @dev MUST emits when the approval value of a token is set or changed.\r\n     * @param _tokenId The token to approve\r\n     * @param _operator The operator to approve for\r\n     * @param _value The maximum value that `_operator` is allowed to manage\r\n     */\r\n    event ApprovalValue(uint256 indexed _tokenId, address indexed _operator, uint256 _value);\r\n\r\n    /**\r\n     * @dev MUST emit when the slot of a token is set or changed.\r\n     * @param _tokenId The token of which slot is set or changed\r\n     * @param _oldSlot The previous slot of the token\r\n     * @param _newSlot The updated slot of the token\r\n     */ \r\n    event SlotChanged(uint256 indexed _tokenId, uint256 indexed _oldSlot, uint256 indexed _newSlot);\r\n\r\n    /**\r\n     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user\r\n     *  representation of the value of a token can be calculated by dividing it by 1,000,000.\r\n     *  Considering the compatibility with third-party wallets, this function is defined as\r\n     *  `valueDecimals()` instead of `decimals()` to avoid conflict with ERC20 tokens.\r\n     * @return The number of decimals for value\r\n     */\r\n    function valueDecimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Get the value of a token.\r\n     * @param _tokenId The token for which to query the balance\r\n     * @return The value of `_tokenId`\r\n     */\r\n    function balanceOf(uint256 _tokenId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the slot of a token.\r\n     * @param _tokenId The identifier for a token\r\n     * @return The slot of the token\r\n     */\r\n    function slotOf(uint256 _tokenId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Allow an operator to manage the value of a token, up to the `_value` amount.\r\n     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved\r\n     *  address for `_tokenId`.\r\n     *  MUST emit ApprovalValue event.\r\n     * @param _tokenId The token to approve\r\n     * @param _operator The operator to be approved\r\n     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage\r\n     */\r\n    function approve(\r\n        uint256 _tokenId,\r\n        address _operator,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Get the maximum value of a token that an operator is allowed to manage.\r\n     * @param _tokenId The token for which to query the allowance\r\n     * @param _operator The address of an operator\r\n     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage\r\n     */\r\n    function allowance(uint256 _tokenId, address _operator) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Transfer value from a specified token to another specified token with the same slot.\r\n     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been\r\n     *  approved the whole `_fromTokenId` or part of it.\r\n     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.\r\n     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.\r\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\r\n     *  operator.\r\n     *  MUST emit `TransferValue` event.\r\n     * @param _fromTokenId The token to transfer value from\r\n     * @param _toTokenId The token to transfer value to\r\n     * @param _value The transferred value\r\n     */\r\n    function transferFrom(\r\n        uint256 _fromTokenId,\r\n        uint256 _toTokenId,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Transfer value from a specified token to an address. The caller should confirm that\r\n     *  `_to` is capable of receiving ERC3525 tokens.\r\n     * @dev This function MUST create a new ERC3525 token with the same slot for `_to` to receive\r\n     *  the transferred value.\r\n     *  MUST revert if `_fromTokenId` is zero token id or does not exist.\r\n     *  MUST revert if `_to` is zero address.\r\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\r\n     *  operator.\r\n     *  MUST emit `Transfer` and `TransferValue` events.\r\n     * @param _fromTokenId The token to transfer value from\r\n     * @param _to The address to transfer value to\r\n     * @param _value The transferred value\r\n     * @return ID of the new token created for `_to` which receives the transferred value\r\n     */\r\n    function transferFrom(\r\n        uint256 _fromTokenId,\r\n        address _to,\r\n        uint256 _value\r\n    ) external payable returns (uint256);\r\n}\r\n\r\n\r\n// File @solvprotocol/erc-3525/extensions/IERC721Enumerable.sol@v1.3.0\r\n\r\n// \r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n *  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /** \r\n     * @notice Count NFTs tracked by this contract\r\n     * @return A count of valid NFTs tracked by this contract, where each one of\r\n     *  them has an assigned and queryable owner not equal to the zero address\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /** \r\n     * @notice Enumerate valid NFTs\r\n     * @dev Throws if `_index` >= `totalSupply()`.\r\n     * @param _index A counter less than `totalSupply()`\r\n     * @return The token identifier for the `_index`th NFT,\r\n     *  (sort order not specified)\r\n     */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /** \r\n     * @notice Enumerate NFTs assigned to an owner\r\n     * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n     *  `_owner` is the zero address, representing invalid NFTs.\r\n     * @param _owner An address where we are interested in NFTs owned by them\r\n     * @param _index A counter less than `balanceOf(_owner)`\r\n     * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n     *  (sort order not specified)\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/HomelessScan.sol\r\n\r\n// \r\npragma solidity ^0.8.9;\r\ninterface IHomelessCard {\r\n    function totalShare() external view returns (uint256);\r\n}\r\n\r\ninterface IHomelessDog {\r\n    function round() external view returns (uint256);\r\n\r\n    function mintCount() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function tokenAmount() external view returns (uint256);\r\n\r\n    function shareAmount() external view returns (uint256);\r\n\r\n    function balanceOf(address addr) external view returns (uint256);\r\n}\r\n\r\ncontract HomelessScan {\r\n    address public homelessDog;\r\n    address public homelessCard;\r\n\r\n    constructor(address homelessDog_, address homelessCard_) {\r\n        homelessDog = homelessDog_;\r\n        homelessCard = homelessCard_;\r\n    }\r\n\r\n    function scan()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 round,\r\n            uint256 mintCount,\r\n            uint256 totalSupply,\r\n            uint256 tokenAmount,\r\n            uint256 shareAmount,\r\n            uint256 sharePrice\r\n        )\r\n    {\r\n        round = IHomelessDog(homelessDog).round();\r\n        mintCount = IHomelessDog(homelessDog).mintCount();\r\n        totalSupply = IHomelessDog(homelessDog).totalSupply();\r\n        tokenAmount = IHomelessDog(homelessDog).tokenAmount();\r\n        shareAmount = IHomelessDog(homelessDog).shareAmount();\r\n\r\n        if (IHomelessCard(homelessCard).totalShare() == 0) {\r\n            sharePrice = 0;\r\n        } else {\r\n            sharePrice = (address(homelessCard).balance * 10 ** 18) / IHomelessCard(homelessCard).totalShare();\r\n        }\r\n    }\r\n\r\n    function scanByAddress(\r\n        address addr\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 balance,\r\n            uint256[] memory tokenIdArray,\r\n            uint256[] memory shareArray,\r\n            uint256[] memory valueArray\r\n        )\r\n    {\r\n        balance = IHomelessDog(homelessDog).balanceOf(addr);\r\n\r\n        uint256 num = IERC3525(homelessCard).balanceOf(addr);\r\n        tokenIdArray = new uint256[](num);\r\n        shareArray = new uint256[](num);\r\n        valueArray = new uint256[](num);\r\n\r\n        if (num > 0) {\r\n            for (uint256 i = 0; i < num; i++) {\r\n                uint256 tokenId = IERC721Enumerable(homelessCard).tokenOfOwnerByIndex(addr, i);\r\n                tokenIdArray[i] = tokenId;\r\n                shareArray[i] = IERC3525(homelessCard).balanceOf(tokenId);\r\n                if (IHomelessCard(homelessCard).totalShare() == 0) {\r\n                    valueArray[i] = 0;\r\n                } else {\r\n                    valueArray[i] =\r\n                        (shareArray[i] * address(homelessCard).balance) /\r\n                        IHomelessCard(homelessCard).totalShare();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"homelessDog_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"homelessCard_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"homelessCard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"homelessDog\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"scanByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIdArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shareArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"valueArray\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HomelessScan", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000035557192c231af36f6c7df9bb03355a4c72977d300000000000000000000000056bd2ca9095a711fad20892db0ac4a23146ad238", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b4959c5606cca44b19d6b7b0f6c97cf8ab47e044ce62ad9ce5431abe02a8e6ac"}