{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AnteTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// \u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u2501\u2513\u250f\u2513\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\\n// \u2503\u250f\u2501\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2523\u252b\u2503\u250f\u2513\u2513\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2513\u2513\u2503\u250f\u2501\u251b\u2503\u250f\u2513\u2503\\n// \u2503\u2503 \u2503\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u252b\u2501\u250f\u2513\u2501\u2503\u2503\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u251b\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u2503\u2503\u2501\u252b\\n// \u2517\u251b \u2517\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u251b\u2501\u2517\u251b\u2501\u2501\u2501\u2517\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IAnteTest.sol\\\";\\n\\n/// @title Ante V0.6 Ante Test smart contract\\n/// @notice Abstract inheritable contract that supplies syntactic sugar for writing Ante Tests\\n/// @dev Usage: contract YourAnteTest is AnteTest(\\\"String descriptor of test\\\") { ... }\\nabstract contract AnteTest is IAnteTest {\\n    /// @inheritdoc IAnteTest\\n    address public override testAuthor;\\n    /// @inheritdoc IAnteTest\\n    string public override testName;\\n    /// @inheritdoc IAnteTest\\n    string public override protocolName;\\n    /// @inheritdoc IAnteTest\\n    address[] public override testedContracts;\\n\\n    /// @dev testedContracts and protocolName are optional parameters which should\\n    /// be set in the constructor of your AnteTest\\n    /// @param _testName The name of the Ante Test\\n    constructor(string memory _testName) {\\n        testAuthor = msg.sender;\\n        testName = _testName;\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function setStateAndCheckTestPasses(bytes memory _state) external override returns (bool) {\\n        if (_state.length > 0) {\\n            _setState(_state);\\n        }\\n        return checkTestPasses();\\n    }\\n\\n    /// @notice Returns the testedContracts array of addresses\\n    /// @return The list of tested contracts as an array of addresses\\n    function getTestedContracts() external view returns (address[] memory) {\\n        return testedContracts;\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function setTestAuthor(address _testAuthor) external {\\n        require(msg.sender == testAuthor, \\\"Only the current testAuthor can set a new test author\\\");\\n        require(_testAuthor != address(0), \\\"ANTE: Test author cannot be the zero address\\\");\\n        address previousAuthor = testAuthor;\\n        testAuthor = _testAuthor;\\n\\n        emit TestAuthorChanged(previousAuthor, _testAuthor);\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function getStateTypes() external pure virtual override returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function getStateNames() external pure virtual override returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function checkTestPasses() public virtual override returns (bool passes) {}\\n\\n    /// @notice Function containing the logic to set the AnteTest state\\n    function _setState(bytes memory) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAnteTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// \u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u2501\u2513\u250f\u2513\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\\n// \u2503\u250f\u2501\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2523\u252b\u2503\u250f\u2513\u2513\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2513\u2513\u2503\u250f\u2501\u251b\u2503\u250f\u2513\u2503\\n// \u2503\u2503 \u2503\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u252b\u2501\u250f\u2513\u2501\u2503\u2503\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u251b\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u2503\u2503\u2501\u252b\\n// \u2517\u251b \u2517\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u251b\u2501\u2517\u251b\u2501\u2501\u2501\u2517\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the Ante V0.6 Ante Test\\n/// @notice The Ante V0.6 Ante Test wraps test logic for verifying fundamental invariants of a protocol\\ninterface IAnteTest {\\n    /// @notice Emitted when the test author is changed\\n    /// @param previousAuthor The address of the previous author\\n    /// @param newAuthor The address of the new author\\n    event TestAuthorChanged(address indexed previousAuthor, address indexed newAuthor);\\n\\n    /// @notice Function containing the logic to set the AnteTest state and call checkTestPasses\\n    /// @param _state The encoded data required to set the test state\\n    /// @return A single bool indicating if the Ante Test passes/fails\\n    function setStateAndCheckTestPasses(bytes memory _state) external returns (bool);\\n\\n    /// @notice Function containing test logic to inspect the protocol invariant\\n    /// @dev This should usually return True\\n    /// @return A single bool indicating if the Ante Test passes/fails\\n    function checkTestPasses() external returns (bool);\\n\\n    /// @notice Returns the author of the Ante Test\\n    /// @dev This overrides the auto-generated getter for testAuthor as a public var\\n    /// @return The address of the test author\\n    function testAuthor() external view returns (address);\\n\\n    /// @notice Sets the author of the Ante Test\\n    /// @dev This can only be called by the current author, which is the deployer initially\\n    /// @param _testAuthor The address of the test author\\n    function setTestAuthor(address _testAuthor) external;\\n\\n    /// @notice Returns the name of the protocol the Ante Test is testing\\n    /// @dev This overrides the auto-generated getter for protocolName as a public var\\n    /// @return The name of the protocol in string format\\n    function protocolName() external view returns (string memory);\\n\\n    /// @notice Returns a single address in the testedContracts array\\n    /// @dev This overrides the auto-generated getter for testedContracts [] as a public var\\n    /// @param i The array index of the address to return\\n    /// @return The address of the i-th element in the list of tested contracts\\n    function testedContracts(uint256 i) external view returns (address);\\n\\n    /// @notice Returns the name of the Ante Test\\n    /// @dev This overrides the auto-generated getter for testName as a public var\\n    /// @return The name of the Ante Test in string format\\n    function testName() external view returns (string memory);\\n\\n    /// @notice Returns a string of comma delimited types used for setting the AnteTest state\\n    /// @return The types of the state variables\\n    function getStateTypes() external pure returns (string memory);\\n\\n    /// @notice Returns a string of comma delimited names used for setting the AnteTest state\\n    /// @return The names of the state variables\\n    function getStateNames() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/nexus_mutual/AnteNexusMutualCapitalPoolTVLPlungeTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {AnteTest} from \\\"../AnteTest.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\n// @title  Nexus Mutual Capital Pool TVL Plunge Test\\n// @notice Ante Test to check that assets in the Nexus Mutual capital pool\\n//         (currently ETH, stETH, and DAI) does not plunge by 90% from the time of\\n//         test deploy\\ncontract AnteNexusMutualCapitalPoolTVLPlungeTest is AnteTest(\\\"Nexus Mutual Capital Pool TVL does not plunge by 90%\\\") {\\n    address constant NEXUS_MUTUAL_POOL = 0xcafea112Db32436c2390F5EC988f3aDB96870627;\\n\\n    IERC20 constant STETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\\n    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\\n\\n    AggregatorV3Interface internal ETHPriceFeed;\\n    AggregatorV3Interface internal stETHPriceFeed;\\n    AggregatorV3Interface internal DAIPriceFeed;\\n\\n    uint256 immutable tvlThreshold;\\n\\n    constructor() {\\n        protocolName = \\\"Nexus Mutual\\\";\\n        testedContracts = [NEXUS_MUTUAL_POOL];\\n\\n        // Chainlink ETH/USD price feeds\\n        ETHPriceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n        stETHPriceFeed = AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8);\\n        DAIPriceFeed = AggregatorV3Interface(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\\n\\n\\n        tvlThreshold = getCurrentTVL() / 10;\\n    }\\n\\n    // @return current pool ETH balance (18 decimals)\\n    function getETHBalance() public view returns (uint256) {\\n        return NEXUS_MUTUAL_POOL.balance;\\n    }\\n    \\n    // @return current pool stETH balance (18 decimals)\\n    function getSTETHBalance() public view returns (uint256) {\\n        return STETH.balanceOf(NEXUS_MUTUAL_POOL);\\n    }\\n    \\n    // @return current pool DAI balance (18 decimals)\\n    function getDAIBalance() public view returns (uint256) {\\n        return DAI.balanceOf(NEXUS_MUTUAL_POOL);\\n    }\\n\\n    // @return 0 if price is negative, or price\\n    function excludeNegative(int256 price) private pure returns (int256) {\\n        if (price < 0) {\\n            return 0;\\n        }\\n        else return price;\\n    }\\n\\n    // @notice Get current pool balances\\n    // @return the sum of tested pool balances (ETH, stETH, DAI) with 6 decimals\\n    function getCurrentTVL() public view returns (uint256) {\\n        // Grab latest price from Chainlink feed\\n        (, int256 ethUsdPrice, , , ) = ETHPriceFeed.latestRoundData();\\n        (, int256 stethUsdPrice, , , ) = stETHPriceFeed.latestRoundData();\\n        (, int256 daiUsdPrice, , , ) = DAIPriceFeed.latestRoundData();\\n\\n        // Exclude negative prices so we can safely cast to uint\\n        ethUsdPrice = excludeNegative(ethUsdPrice);\\n        stethUsdPrice = excludeNegative(stethUsdPrice);\\n        daiUsdPrice = excludeNegative(daiUsdPrice);\\n\\n        return (\\n            getETHBalance() / 10**15 * uint256(ethUsdPrice) / 10**5 + \\n            getSTETHBalance() / 10**15 * uint256(stethUsdPrice) / 10**5 + \\n            getDAIBalance() / 10**15 * uint256(daiUsdPrice) / 10**5\\n        );\\n    }\\n\\n    // @notice Check if current pool balances are greater than TVL threshold\\n    // @return true if current TVL > 10% of TVL at time of test deploy\\n    function checkTestPasses() public view override returns (bool) {\\n        return (getCurrentTVL() > tvlThreshold);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAuthor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAuthor\",\"type\":\"address\"}],\"name\":\"TestAuthorChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkTestPasses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTVL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAIBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSTETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStateNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStateTypes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTestedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_state\",\"type\":\"bytes\"}],\"name\":\"setStateAndCheckTestPasses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_testAuthor\",\"type\":\"address\"}],\"name\":\"setTestAuthor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testAuthor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"testedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AnteNexusMutualCapitalPoolTVLPlungeTest", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}