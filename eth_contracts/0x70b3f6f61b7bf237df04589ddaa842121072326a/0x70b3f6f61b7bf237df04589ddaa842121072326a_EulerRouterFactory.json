{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/EulerRouterFactory/EulerRouterFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {BaseFactory} from \\\"../BaseFactory/BaseFactory.sol\\\";\\nimport {EulerRouter} from \\\"euler-price-oracle/EulerRouter.sol\\\";\\nimport {IEulerRouterFactory} from \\\"./interfaces/IEulerRouterFactory.sol\\\";\\n\\n/// @title EulerRouterFactory\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice A minimal factory for EulerRouter.\\ncontract EulerRouterFactory is BaseFactory, IEulerRouterFactory {\\n    address public immutable EVC;\\n\\n    /// @notice Constructor for the EulerRouterFactory contract.\\n    /// @param _evc The address of the Ethereum Vault Connector (EVC).\\n    constructor(address _evc) {\\n        require(_evc != address(0), \\\"Invalid EVC address\\\");\\n        EVC = _evc;\\n    }\\n\\n    /// @notice Deploys a new EulerRouter.\\n    /// @param governor The governor of the router.\\n    /// @return The deployment address.\\n    function deploy(address governor) external returns (address) {\\n        address router = address(new EulerRouter(EVC, governor));\\n        deploymentInfo[router] = DeploymentInfo(msg.sender, uint96(block.timestamp));\\n        deployments.push(address(router));\\n        emit ContractDeployed(router, msg.sender, block.timestamp);\\n        return router;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/BaseFactory/BaseFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IFactory} from \\\"./interfaces/IFactory.sol\\\";\\n\\n/// @title BaseFactory\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice A minimal factory for deploying various contracts.\\nabstract contract BaseFactory is IFactory {\\n    /// @notice Contracts deployed by the factory.\\n    mapping(address => DeploymentInfo) internal deploymentInfo;\\n\\n    /// @notice An array of addresses of all the contracts deployed by the factory\\n    address[] public deployments;\\n\\n    /// @inheritdoc IFactory\\n    function getDeploymentInfo(address contractAddress) external view returns (address deployer, uint96 deployedAt) {\\n        DeploymentInfo memory info = deploymentInfo[contractAddress];\\n        return (info.deployer, info.deployedAt);\\n    }\\n\\n    /// @inheritdoc IFactory\\n    function isValidDeployment(address contractAddress) external view returns (bool) {\\n        return deploymentInfo[contractAddress].deployedAt != 0;\\n    }\\n\\n    /// @inheritdoc IFactory\\n    function getDeploymentsListLength() external view returns (uint256) {\\n        return deployments.length;\\n    }\\n\\n    /// @inheritdoc IFactory\\n    function getDeploymentsListSlice(uint256 start, uint256 end) external view returns (address[] memory list) {\\n        if (end == type(uint256).max) end = deployments.length;\\n        if (end < start || end > deployments.length) revert Factory_BadQuery();\\n\\n        list = new address[](end - start);\\n        for (uint256 i; i < end - start; ++i) {\\n            list[i] = deployments[start + i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/euler-price-oracle/src/EulerRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IERC4626} from \\\"forge-std/interfaces/IERC4626.sol\\\";\\nimport {IPriceOracle} from \\\"./interfaces/IPriceOracle.sol\\\";\\nimport {Errors} from \\\"./lib/Errors.sol\\\";\\nimport {Governable} from \\\"./lib/Governable.sol\\\";\\n\\n/// @title EulerRouter\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Default Oracle resolver for Euler lending products.\\n/// @dev Integration Note: The router supports pricing via `convertToAssets` for trusted `resolvedVaults`.\\n/// By ERC4626 spec `convert*` ignores liquidity restrictions, fees, slippage and per-user restrictions.\\n/// Therefore the reported price may not be realizable through `redeem` or `withdraw`.\\ncontract EulerRouter is Governable, IPriceOracle {\\n    /// @inheritdoc IPriceOracle\\n    string public constant name = \\\"EulerRouter\\\";\\n    /// @notice The PriceOracle to call if this router is not configured for base/quote.\\n    /// @dev If `address(0)` then there is no fallback.\\n    address public fallbackOracle;\\n    /// @notice ERC4626 vaults resolved using internal pricing (`convertToAssets`).\\n    mapping(address vault => address asset) public resolvedVaults;\\n    /// @notice PriceOracle configured per asset pair.\\n    /// @dev The keys are lexicographically sorted (asset0 < asset1).\\n    mapping(address asset0 => mapping(address asset1 => address oracle)) internal oracles;\\n\\n    /// @notice Configure a PriceOracle to resolve an asset pair.\\n    /// @param asset0 The address first in lexicographic order.\\n    /// @param asset1 The address second in lexicographic order.\\n    /// @param oracle The address of the PriceOracle that resolves the pair.\\n    /// @dev If `oracle` is `address(0)` then the configuration was removed.\\n    /// The keys are lexicographically sorted (asset0 < asset1).\\n    event ConfigSet(address indexed asset0, address indexed asset1, address indexed oracle);\\n    /// @notice Set a PriceOracle as a fallback resolver.\\n    /// @param fallbackOracle The address of the PriceOracle that is called when base/quote is not configured.\\n    /// @dev If `fallbackOracle` is `address(0)` then there is no fallback resolver.\\n    event FallbackOracleSet(address indexed fallbackOracle);\\n    /// @notice Mark an ERC4626 vault to be resolved to its `asset` via its `convert*` methods.\\n    /// @param vault The address of the ERC4626 vault.\\n    /// @param asset The address of the vault's asset.\\n    /// @dev If `asset` is `address(0)` then the configuration was removed.\\n    event ResolvedVaultSet(address indexed vault, address indexed asset);\\n\\n    /// @notice Deploy EulerRouter.\\n    /// @param _governor The address of the governor.\\n    constructor(address _evc, address _governor) Governable(_evc, _governor) {\\n        if (_governor == address(0)) revert Errors.PriceOracle_InvalidConfiguration();\\n    }\\n\\n    /// @notice Configure a PriceOracle to resolve base/quote and quote/base.\\n    /// @param base The address of the base token.\\n    /// @param quote The address of the quote token.\\n    /// @param oracle The address of the PriceOracle to resolve the pair.\\n    /// @dev Callable only by the governor.\\n    function govSetConfig(address base, address quote, address oracle) external onlyEVCAccountOwner onlyGovernor {\\n        // This case is handled by `resolveOracle`.\\n        if (base == quote) revert Errors.PriceOracle_InvalidConfiguration();\\n        (address asset0, address asset1) = _sort(base, quote);\\n        oracles[asset0][asset1] = oracle;\\n        emit ConfigSet(asset0, asset1, oracle);\\n    }\\n\\n    /// @notice Configure an ERC4626 vault to use internal pricing via `convert*` methods.\\n    /// @param vault The address of the ERC4626 vault.\\n    /// @param set True to configure the vault, false to clear the record.\\n    /// @dev Callable only by the governor. Vault must implement ERC4626.\\n    /// Note: Before configuring a vault verify that its `convertToAssets` is secure.\\n    function govSetResolvedVault(address vault, bool set) external onlyEVCAccountOwner onlyGovernor {\\n        address asset = set ? IERC4626(vault).asset() : address(0);\\n        resolvedVaults[vault] = asset;\\n        emit ResolvedVaultSet(vault, asset);\\n    }\\n\\n    /// @notice Set a PriceOracle as a fallback resolver.\\n    /// @param _fallbackOracle The address of the PriceOracle that is called when base/quote is not configured.\\n    /// @dev Callable only by the governor. `address(0)` removes the fallback.\\n    function govSetFallbackOracle(address _fallbackOracle) external onlyEVCAccountOwner onlyGovernor {\\n        fallbackOracle = _fallbackOracle;\\n        emit FallbackOracleSet(_fallbackOracle);\\n    }\\n\\n    /// @inheritdoc IPriceOracle\\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256) {\\n        address oracle;\\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\\n        if (base == quote) return inAmount;\\n        return IPriceOracle(oracle).getQuote(inAmount, base, quote);\\n    }\\n\\n    /// @inheritdoc IPriceOracle\\n    function getQuotes(uint256 inAmount, address base, address quote) external view returns (uint256, uint256) {\\n        address oracle;\\n        (inAmount, base, quote, oracle) = resolveOracle(inAmount, base, quote);\\n        if (base == quote) return (inAmount, inAmount);\\n        return IPriceOracle(oracle).getQuotes(inAmount, base, quote);\\n    }\\n\\n    /// @notice Get the PriceOracle configured for base/quote.\\n    /// @param base The address of the base token.\\n    /// @param quote The address of the quote token.\\n    /// @return The configured `PriceOracle` for the pair or `address(0)` if no oracle is configured.\\n    function getConfiguredOracle(address base, address quote) public view returns (address) {\\n        (address asset0, address asset1) = _sort(base, quote);\\n        return oracles[asset0][asset1];\\n    }\\n\\n    /// @notice Resolve the PriceOracle to call for a given base/quote pair.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @dev Implements the following resolution logic:\\n    /// 1. Check the base case: `base == quote` and terminate if true.\\n    /// 2. If a PriceOracle is configured for base/quote in the `oracles` mapping, return it.\\n    /// 3. If `base` is configured as a resolved ERC4626 vault, call `convertToAssets(inAmount)`\\n    /// and continue the recursion, substituting the ERC4626 `asset` for `base`.\\n    /// 4. As a last resort, return the fallback oracle or revert if it is not set.\\n    /// @return The resolved amount. This value may be different from the original `inAmount`\\n    /// if the resolution path included an ERC4626 vault present in `resolvedVaults`.\\n    /// @return The resolved base.\\n    /// @return The resolved quote.\\n    /// @return The resolved PriceOracle to call.\\n    function resolveOracle(uint256 inAmount, address base, address quote)\\n        public\\n        view\\n        returns (uint256, /* resolvedAmount */ address, /* base */ address, /* quote */ address /* oracle */ )\\n    {\\n        // 1. Check the base case.\\n        if (base == quote) return (inAmount, base, quote, address(0));\\n        // 2. Check if there is a PriceOracle configured for base/quote.\\n        address oracle = getConfiguredOracle(base, quote);\\n        if (oracle != address(0)) return (inAmount, base, quote, oracle);\\n        // 3. Recursively resolve `base`.\\n        address baseAsset = resolvedVaults[base];\\n        if (baseAsset != address(0)) {\\n            inAmount = IERC4626(base).convertToAssets(inAmount);\\n            return resolveOracle(inAmount, baseAsset, quote);\\n        }\\n        // 4. Return the fallback or revert if not configured.\\n        oracle = fallbackOracle;\\n        if (oracle == address(0)) revert Errors.PriceOracle_NotSupported(base, quote);\\n        return (inAmount, base, quote, oracle);\\n    }\\n\\n    /// @notice Lexicographically sort two addresses.\\n    /// @param assetA One of the assets in the pair.\\n    /// @param assetB The other asset in the pair.\\n    /// @return The address first in lexicographic order.\\n    /// @return The address second in lexicographic order.\\n    function _sort(address assetA, address assetB) internal pure returns (address, address) {\\n        return assetA < assetB ? (assetA, assetB) : (assetB, assetA);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/EulerRouterFactory/interfaces/IEulerRouterFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IFactory} from \\\"../../BaseFactory/interfaces/IFactory.sol\\\";\\n\\n/// @title IEulerRouterFactory\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice A minimal factory for EulerRouter.\\ninterface IEulerRouterFactory is IFactory {\\n    /// @notice Deploys a new EulerRouter.\\n    /// @param governor The governor of the router.\\n    /// @return The deployment address.\\n    function deploy(address governor) external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/BaseFactory/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IFactory\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice A minimal factory interface for deploying contracts.\\ninterface IFactory {\\n    struct DeploymentInfo {\\n        /// @notice The sender of the deployment call.\\n        address deployer;\\n        /// @notice The timestamp when the contract was deployed.\\n        uint96 deployedAt;\\n    }\\n\\n    /// @notice An instance of a contract was deployed.\\n    /// @param deployedContract The deployment address of the contract.\\n    /// @param deployer The sender of the deployment call.\\n    /// @param deployedAt The deployment timestamp of the contract.\\n    event ContractDeployed(address indexed deployedContract, address indexed deployer, uint256 deployedAt);\\n\\n    /// @notice Error thrown when the query is incorrect.\\n    error Factory_BadQuery();\\n\\n    /// @notice Contracts deployed by the factory.\\n    function getDeploymentInfo(address contractAddress) external view returns (address deployer, uint96 deployedAt);\\n\\n    /// @notice Checks if the deployment at the given address is valid.\\n    /// @param contractAddress The address of the contract to check.\\n    /// @return True if the deployment is valid, false otherwise.\\n    function isValidDeployment(address contractAddress) external view returns (bool);\\n\\n    /// @notice Returns the number of contracts deployed by the factory.\\n    /// @return The number of deployed contracts.\\n    function getDeploymentsListLength() external view returns (uint256);\\n\\n    /// @notice Returns a slice of the list of deployments.\\n    /// @param start The starting index of the slice.\\n    /// @param end The ending index of the slice (exclusive).\\n    /// @return list An array of addresses of the deployed contracts in the specified range.\\n    function getDeploymentsListSlice(uint256 start, uint256 end) external view returns (address[] memory list);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/// @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n/// https://eips.ethereum.org/EIPS/eip-4626\\ninterface IERC4626 is IERC20 {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\\n    );\\n\\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n    /// @dev\\n    /// - MUST be an ERC-20 token contract.\\n    /// - MUST NOT revert.\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @notice Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n    /// @dev\\n    /// - SHOULD include any compounding that occurs from yield.\\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT revert.\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n    /// \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n    /// \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n    /// through a deposit call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n    /// - MUST NOT revert.\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   deposit execution, and are accounted for during deposit.\\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some mint limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n    /// - MUST NOT revert.\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n    ///   execution, and are accounted for during mint.\\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n    /// Vault, through a withdraw call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n    ///   called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   withdraw execution, and are accounted for during withdraw.\\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n    /// through a redeem call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   redeem execution, and are accounted for during redeem.\\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"lib/euler-price-oracle/src/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title IPriceOracle\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Common PriceOracle interface.\\ninterface IPriceOracle {\\n    /// @notice Get the name of the oracle.\\n    /// @return The name of the oracle.\\n    function name() external view returns (string memory);\\n\\n    /// @notice One-sided price: How much quote token you would get for inAmount of base token, assuming no price spread.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return outAmount The amount of `quote` that is equivalent to `inAmount` of `base`.\\n    function getQuote(uint256 inAmount, address base, address quote) external view returns (uint256 outAmount);\\n\\n    /// @notice Two-sided price: How much quote token you would get/spend for selling/buying inAmount of base token.\\n    /// @param inAmount The amount of `base` to convert.\\n    /// @param base The token that is being priced.\\n    /// @param quote The token that is the unit of account.\\n    /// @return bidOutAmount The amount of `quote` you would get for selling `inAmount` of `base`.\\n    /// @return askOutAmount The amount of `quote` you would spend for buying `inAmount` of `base`.\\n    function getQuotes(uint256 inAmount, address base, address quote)\\n        external\\n        view\\n        returns (uint256 bidOutAmount, uint256 askOutAmount);\\n}\\n\"\r\n    },\r\n    \"lib/euler-price-oracle/src/lib/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Collects common errors in PriceOracles.\\nlibrary Errors {\\n    /// @notice The external feed returned an invalid answer.\\n    error PriceOracle_InvalidAnswer();\\n    /// @notice The configuration parameters for the PriceOracle are invalid.\\n    error PriceOracle_InvalidConfiguration();\\n    /// @notice The base/quote path is not supported.\\n    /// @param base The address of the base asset.\\n    /// @param quote The address of the quote asset.\\n    error PriceOracle_NotSupported(address base, address quote);\\n    /// @notice The quote cannot be completed due to overflow.\\n    error PriceOracle_Overflow();\\n    /// @notice The price is too stale.\\n    /// @param staleness The time elapsed since the price was updated.\\n    /// @param maxStaleness The maximum time elapsed since the last price update.\\n    error PriceOracle_TooStale(uint256 staleness, uint256 maxStaleness);\\n    /// @notice The method can only be called by the governor.\\n    error Governance_CallerNotGovernor();\\n}\\n\"\r\n    },\r\n    \"lib/euler-price-oracle/src/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {EVCUtil} from \\\"ethereum-vault-connector/utils/EVCUtil.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/// @title Governable\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Contract mixin for governance, compatible with EVC.\\nabstract contract Governable is EVCUtil {\\n    /// @notice The active governor address. If `address(0)` then the role is renounced.\\n    address public governor;\\n\\n    /// @notice Set the governor of the contract.\\n    /// @param oldGovernor The address of the previous governor.\\n    /// @param newGovernor The address of the newly appointed governor.\\n    event GovernorSet(address indexed oldGovernor, address indexed newGovernor);\\n\\n    constructor(address _evc, address _governor) EVCUtil(_evc) {\\n        _setGovernor(_governor);\\n    }\\n\\n    /// @notice Transfer the governor role to another address.\\n    /// @param newGovernor The address of the next governor.\\n    /// @dev Can only be called by the current governor.\\n    function transferGovernance(address newGovernor) external onlyEVCAccountOwner onlyGovernor {\\n        _setGovernor(newGovernor);\\n    }\\n\\n    /// @notice Restrict access to the governor.\\n    /// @dev Consider also adding `onlyEVCAccountOwner` for stricter caller checks.\\n    modifier onlyGovernor() {\\n        if (_msgSender() != governor) {\\n            revert Errors.Governance_CallerNotGovernor();\\n        }\\n        _;\\n    }\\n\\n    /// @notice Set the governor address.\\n    /// @param newGovernor The address of the new governor.\\n    function _setGovernor(address newGovernor) internal {\\n        emit GovernorSet(governor, newGovernor);\\n        governor = newGovernor;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n/// @dev Interface of the ERC20 standard as defined in the EIP.\\n/// @dev This includes the optional name, symbol, and decimals metadata.\\ninterface IERC20 {\\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\\n    /// is the new allowance.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\\n    /// to spend on behalf of `owner`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\\n    /// `amount` is then deducted from the caller's allowance.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/utils/EVCUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVC} from \\\"../interfaces/IEthereumVaultConnector.sol\\\";\\nimport {ExecutionContext, EC} from \\\"../ExecutionContext.sol\\\";\\n\\n/// @title EVCUtil\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract is an abstract base contract for interacting with the Ethereum Vault Connector (EVC).\\n/// It provides utility functions for authenticating the callers in the context of the EVC, a pattern for enforcing the\\n/// contracts to be called through the EVC.\\nabstract contract EVCUtil {\\n    using ExecutionContext for EC;\\n\\n    uint160 internal constant ACCOUNT_ID_OFFSET = 8;\\n    IEVC internal immutable evc;\\n\\n    error EVC_InvalidAddress();\\n    error NotAuthorized();\\n    error ControllerDisabled();\\n\\n    constructor(address _evc) {\\n        if (_evc == address(0)) revert EVC_InvalidAddress();\\n\\n        evc = IEVC(_evc);\\n    }\\n\\n    /// @notice Returns the address of the Ethereum Vault Connector (EVC) used by this contract.\\n    /// @return The address of the EVC contract.\\n    function EVC() external view returns (address) {\\n        return address(evc);\\n    }\\n\\n    /// @notice Ensures that the msg.sender is the EVC by using the EVC callback functionality if necessary.\\n    /// @dev Optional to use for functions requiring account and vault status checks to enforce predictable behavior.\\n    /// @dev If this modifier used in conjuction with any other modifier, it must appear as the first (outermost)\\n    /// modifier of the function.\\n    modifier callThroughEVC() virtual {\\n        _callThroughEVC();\\n        _;\\n    }\\n\\n    /// @notice Ensures that the caller is the EVC in the appropriate context.\\n    /// @dev Should be used for checkAccountStatus and checkVaultStatus functions.\\n    modifier onlyEVCWithChecksInProgress() virtual {\\n        _onlyEVCWithChecksInProgress();\\n        _;\\n    }\\n\\n    /// @notice Ensures a standard authentication path on the EVC.\\n    /// @dev This modifier checks if the caller is the EVC and if so, verifies the execution context.\\n    /// It reverts if the operator is authenticated, control collateral is in progress, or checks are in progress.\\n    /// It reverts if the authenticated account owner is known and it is not the account owner.\\n    /// @dev It assumes that if the caller is not the EVC, the caller is the account owner.\\n    /// @dev This modifier must not be used on functions utilized by liquidation flows, i.e. transfer or withdraw.\\n    /// @dev This modifier must not be used on checkAccountStatus and checkVaultStatus functions.\\n    /// @dev This modifier can be used on access controlled functions to prevent non-standard authentication paths on\\n    /// the EVC.\\n    modifier onlyEVCAccountOwner() virtual {\\n        _onlyEVCAccountOwner();\\n        _;\\n    }\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function _haveCommonOwner(address account, address otherAccount) internal pure returns (bool) {\\n        bool result;\\n        assembly {\\n            result := lt(xor(account, otherAccount), 0x100)\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function _getAddressPrefix(address account) internal pure returns (bytes19) {\\n        return bytes19(uint152(uint160(account) >> ACCOUNT_ID_OFFSET));\\n    }\\n\\n    /// @notice Retrieves the message sender in the context of the EVC.\\n    /// @dev This function returns the account on behalf of which the current operation is being performed, which is\\n    /// either msg.sender or the account authenticated by the EVC.\\n    /// @return The address of the message sender.\\n    function _msgSender() internal view virtual returns (address) {\\n        address sender = msg.sender;\\n\\n        if (sender == address(evc)) {\\n            (sender,) = evc.getCurrentOnBehalfOfAccount(address(0));\\n        }\\n\\n        return sender;\\n    }\\n\\n    /// @notice Retrieves the message sender in the context of the EVC for a borrow operation.\\n    /// @dev This function returns the account on behalf of which the current operation is being performed, which is\\n    /// either msg.sender or the account authenticated by the EVC. This function reverts if this contract is not enabled\\n    /// as a controller for the account on behalf of which the operation is being executed.\\n    /// @return The address of the message sender.\\n    function _msgSenderForBorrow() internal view virtual returns (address) {\\n        address sender = msg.sender;\\n        bool controllerEnabled;\\n\\n        if (sender == address(evc)) {\\n            (sender, controllerEnabled) = evc.getCurrentOnBehalfOfAccount(address(this));\\n        } else {\\n            controllerEnabled = evc.isControllerEnabled(sender, address(this));\\n        }\\n\\n        if (!controllerEnabled) {\\n            revert ControllerDisabled();\\n        }\\n\\n        return sender;\\n    }\\n\\n    /// @notice Calls the current external function through the EVC.\\n    /// @dev This function is used to route the current call through the EVC if it's not already coming from the EVC. It\\n    /// makes the EVC set the execution context and call back this contract with unchanged calldata. msg.sender is used\\n    /// as the onBehalfOfAccount.\\n    /// @dev This function shall only be used by the callThroughEVC modifier.\\n    function _callThroughEVC() internal {\\n        address _evc = address(evc);\\n        if (msg.sender == _evc) return;\\n\\n        assembly {\\n            mstore(0, 0x1f8b521500000000000000000000000000000000000000000000000000000000) // EVC.call selector\\n            mstore(4, address()) // EVC.call 1st argument - address(this)\\n            mstore(36, caller()) // EVC.call 2nd argument - msg.sender\\n            mstore(68, callvalue()) // EVC.call 3rd argument - msg.value\\n            mstore(100, 128) // EVC.call 4th argument - msg.data, offset to the start of encoding - 128 bytes\\n            mstore(132, calldatasize()) // msg.data length\\n            calldatacopy(164, 0, calldatasize()) // original calldata\\n\\n            // abi encoded bytes array should be zero padded so its length is a multiple of 32\\n            // store zero word after msg.data bytes and round up calldatasize to nearest multiple of 32\\n            mstore(add(164, calldatasize()), 0)\\n            let result := call(gas(), _evc, callvalue(), 0, add(164, and(add(calldatasize(), 31), not(31))), 0, 0)\\n\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(64, sub(returndatasize(), 64)) } // strip bytes encoding from call return\\n        }\\n    }\\n\\n    /// @notice Ensures that the function is called only by the EVC during the checks phase\\n    /// @dev Reverts if the caller is not the EVC or if checks are not in progress.\\n    function _onlyEVCWithChecksInProgress() internal view {\\n        if (msg.sender != address(evc) || !evc.areChecksInProgress()) {\\n            revert NotAuthorized();\\n        }\\n    }\\n\\n    /// @notice Ensures that the function is called only by the EVC account owner\\n    /// @dev This function checks if the caller is the EVC and if so, verifies that the execution context is not in a\\n    /// special state (operator authenticated, collateral control in progress, or checks in progress). If the owner was\\n    /// already registered on the EVC, it verifies that the onBehalfOfAccount is the owner.\\n    /// @dev Reverts if the caller is not the EVC or if the execution context is in a special state.\\n    function _onlyEVCAccountOwner() internal view {\\n        if (msg.sender == address(evc)) {\\n            EC ec = EC.wrap(evc.getRawExecutionContext());\\n\\n            if (ec.isOperatorAuthenticated() || ec.isControlCollateralInProgress() || ec.areChecksInProgress()) {\\n                revert NotAuthorized();\\n            }\\n\\n            address onBehalfOfAccount = ec.getOnBehalfOfAccount();\\n            address owner = evc.getAccountOwner(onBehalfOfAccount);\\n\\n            if (owner != address(0) && owner != onBehalfOfAccount) {\\n                revert NotAuthorized();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/interfaces/IEthereumVaultConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IEVC\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Ethereum Vault Connector.\\ninterface IEVC {\\n    /// @notice A struct representing a batch item.\\n    /// @dev Each batch item represents a single operation to be performed within a checks deferred context.\\n    struct BatchItem {\\n        /// @notice The target contract to be called.\\n        address targetContract;\\n        /// @notice The account on behalf of which the operation is to be performed. msg.sender must be authorized to\\n        /// act on behalf of this account. Must be address(0) if the target contract is the EVC itself.\\n        address onBehalfOfAccount;\\n        /// @notice The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n        /// balance of the EVC contract will be forwarded. Must be 0 if the target contract is the EVC itself.\\n        uint256 value;\\n        /// @notice The encoded data which is called on the target contract.\\n        bytes data;\\n    }\\n\\n    /// @notice A struct representing the result of a batch item operation.\\n    /// @dev Used only for simulation purposes.\\n    struct BatchItemResult {\\n        /// @notice A boolean indicating whether the operation was successful.\\n        bool success;\\n        /// @notice The result of the operation.\\n        bytes result;\\n    }\\n\\n    /// @notice A struct representing the result of the account or vault status check.\\n    /// @dev Used only for simulation purposes.\\n    struct StatusCheckResult {\\n        /// @notice The address of the account or vault for which the check was performed.\\n        address checkedAddress;\\n        /// @notice A boolean indicating whether the status of the account or vault is valid.\\n        bool isValid;\\n        /// @notice The result of the check.\\n        bytes result;\\n    }\\n\\n    /// @notice Returns current raw execution context.\\n    /// @dev When checks in progress, on behalf of account is always address(0).\\n    /// @return context Current raw execution context.\\n    function getRawExecutionContext() external view returns (uint256 context);\\n\\n    /// @notice Returns an account on behalf of which the operation is being executed at the moment and whether the\\n    /// controllerToCheck is an enabled controller for that account.\\n    /// @dev This function should only be used by external smart contracts if msg.sender is the EVC. Otherwise, the\\n    /// account address returned must not be trusted.\\n    /// @dev When checks in progress, on behalf of account is always address(0). When address is zero, the function\\n    /// reverts to protect the consumer from ever relying on the on behalf of account address which is in its default\\n    /// state.\\n    /// @param controllerToCheck The address of the controller for which it is checked whether it is an enabled\\n    /// controller for the account on behalf of which the operation is being executed at the moment.\\n    /// @return onBehalfOfAccount An account that has been authenticated and on behalf of which the operation is being\\n    /// executed at the moment.\\n    /// @return controllerEnabled A boolean value that indicates whether controllerToCheck is an enabled controller for\\n    /// the account on behalf of which the operation is being executed at the moment. Always false if controllerToCheck\\n    /// is address(0).\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled);\\n\\n    /// @notice Checks if checks are deferred.\\n    /// @return A boolean indicating whether checks are deferred.\\n    function areChecksDeferred() external view returns (bool);\\n\\n    /// @notice Checks if checks are in progress.\\n    /// @return A boolean indicating whether checks are in progress.\\n    function areChecksInProgress() external view returns (bool);\\n\\n    /// @notice Checks if control collateral is in progress.\\n    /// @return A boolean indicating whether control collateral is in progress.\\n    function isControlCollateralInProgress() external view returns (bool);\\n\\n    /// @notice Checks if an operator is authenticated.\\n    /// @return A boolean indicating whether an operator is authenticated.\\n    function isOperatorAuthenticated() external view returns (bool);\\n\\n    /// @notice Checks if a simulation is in progress.\\n    /// @return A boolean indicating whether a simulation is in progress.\\n    function isSimulationInProgress() external view returns (bool);\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool);\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function getAddressPrefix(address account) external pure returns (bytes19);\\n\\n    /// @notice Returns the owner for the specified account.\\n    /// @dev The function returns address(0) if the owner is not registered. Registration of the owner happens on the\\n    /// initial\\n    /// interaction with the EVC that requires authentication of an owner.\\n    /// @param account The address of the account whose owner is being retrieved.\\n    /// @return owner The address of the account owner. An account owner is an EOA/smart contract which address matches\\n    /// the first 19 bytes of the account address.\\n    function getAccountOwner(address account) external view returns (address);\\n\\n    /// @notice Checks if lockdown mode is enabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for lockdown mode status.\\n    /// @return A boolean indicating whether lockdown mode is enabled.\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Checks if permit functionality is disabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for permit functionality status.\\n    /// @return A boolean indicating whether permit functionality is disabled.\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Returns the current nonce for a given address prefix and nonce namespace.\\n    /// @dev Each nonce namespace provides 256 bit nonce that has to be used sequentially. There's no requirement to use\\n    /// all the nonces for a given nonce namespace before moving to the next one which allows to use permit messages in\\n    /// a non-sequential manner.\\n    /// @param addressPrefix The address prefix for which the nonce is being retrieved.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being retrieved.\\n    /// @return nonce The current nonce for the given address prefix and nonce namespace.\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256 nonce);\\n\\n    /// @notice Returns the bit field for a given address prefix and operator.\\n    /// @dev The bit field is used to store information about authorized operators for a given address prefix. Each bit\\n    /// in the bit field corresponds to one account belonging to the same owner. If the bit is set, the operator is\\n    /// authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being retrieved.\\n    /// @param operator The address of the operator for which the bit field is being retrieved.\\n    /// @return operatorBitField The bit field for the given address prefix and operator. The bit field defines which\\n    /// accounts the operator is authorized for. It is a 256-position binary array like 0...010...0, marking the account\\n    /// positionally in a uint256. The position in the bit field corresponds to the account ID (0-255), where 0 is the\\n    /// owner account's ID.\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256 operatorBitField);\\n\\n    /// @notice Returns whether a given operator has been authorized for a given account.\\n    /// @param account The address of the account whose operator is being checked.\\n    /// @param operator The address of the operator that is being checked.\\n    /// @return authorized A boolean value that indicates whether the operator is authorized for the account.\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool authorized);\\n\\n    /// @notice Enables or disables lockdown mode for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or\\n    /// permit message.\\n    /// @param addressPrefix The address prefix for which the lockdown mode is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable lockdown mode.\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Enables or disables permit functionality for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or (by\\n    /// definition) permit message. To support permit functionality by default, note that the logic was inverted here. To\\n    /// disable  the permit functionality, one must pass true as the second argument. To enable the permit\\n    /// functionality, one must pass false as the second argument.\\n    /// @param addressPrefix The address prefix for which the permit functionality is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable the disable-permit mode.\\n    function setPermitDisabledMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Sets the nonce for a given address prefix and nonce namespace.\\n    /// @dev This function can only be called by the owner of the address prefix. Each nonce namespace provides a 256\\n    /// bit nonce that has to be used sequentially. There's no requirement to use all the nonces for a given nonce\\n    /// namespace before moving to the next one which allows the use of permit messages in a non-sequential manner. To\\n    /// invalidate signed permit messages, set the nonce for a given nonce namespace accordingly. To invalidate all the\\n    /// permit messages for a given nonce namespace, set the nonce to type(uint).max.\\n    /// @param addressPrefix The address prefix for which the nonce is being set.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being set.\\n    /// @param nonce The new nonce for the given address prefix and nonce namespace.\\n    function setNonce(bytes19 addressPrefix, uint256 nonceNamespace, uint256 nonce) external payable;\\n\\n    /// @notice Sets the bit field for a given address prefix and operator.\\n    /// @dev This function can only be called by the owner of the address prefix. Each bit in the bit field corresponds\\n    /// to one account belonging to the same owner. If the bit is set, the operator is authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being set.\\n    /// @param operator The address of the operator for which the bit field is being set. Can neither be the EVC address\\n    /// nor an address belonging to the same address prefix.\\n    /// @param operatorBitField The new bit field for the given address prefix and operator. Reverts if the provided\\n    /// value is equal to the currently stored value.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) external payable;\\n\\n    /// @notice Authorizes or deauthorizes an operator for the account.\\n    /// @dev Only the owner or authorized operator of the account can call this function. An operator is an address that\\n    /// can perform actions for an account on behalf of the owner. If it's an operator calling this function, it can\\n    /// only deauthorize itself.\\n    /// @param account The address of the account whose operator is being set or unset.\\n    /// @param operator The address of the operator that is being installed or uninstalled. Can neither be the EVC\\n    /// address nor an address belonging to the same owner as the account.\\n    /// @param authorized A boolean value that indicates whether the operator is being authorized or deauthorized.\\n    /// Reverts if the provided value is equal to the currently stored value.\\n    function setAccountOperator(address account, address operator, bool authorized) external payable;\\n\\n    /// @notice Returns an array of collaterals enabled for an account.\\n    /// @dev A collateral is a vault for which an account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account whose collaterals are being queried.\\n    /// @return An array of addresses that are enabled collaterals for the account.\\n    function getCollaterals(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a collateral is enabled for an account.\\n    /// @dev A collateral is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the collateral that is being checked.\\n    /// @return A boolean value that indicates whether the vault is an enabled collateral for the account or not.\\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a collateral for an account.\\n    /// @dev A collaterals is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. Unless it's a duplicate,\\n    /// the collateral is added to the end of the array. There can be at most 10 unique collaterals enabled at a time.\\n    /// Account status checks are performed.\\n    /// @param account The account address for which the collateral is being enabled.\\n    /// @param vault The address being enabled as a collateral.\\n    function enableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Disables a collateral for an account.\\n    /// @dev This function does not preserve the order of collaterals in the array obtained using the getCollaterals\\n    /// function; the order may change. A collateral is a vault for which account\u2019s balances are under the control of\\n    /// the currently enabled controller vault. Only the owner or an operator of the account can call this function.\\n    /// Disabling a collateral might change the order of collaterals in the array obtained using getCollaterals\\n    /// function. Account status checks are performed.\\n    /// @param account The account address for which the collateral is being disabled.\\n    /// @param vault The address of a collateral being disabled.\\n    function disableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Swaps the position of two collaterals so that they appear switched in the array of collaterals for a\\n    /// given account obtained by calling getCollaterals function.\\n    /// @dev A collateral is a vault for which account\u2019s balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. The order of collaterals\\n    /// can be changed by specifying the indices of the two collaterals to be swapped. Indices are zero-based and must\\n    /// be in the range of 0 to the number of collaterals minus 1. index1 must be lower than index2. Account status\\n    /// checks are performed.\\n    /// @param account The address of the account for which the collaterals are being reordered.\\n    /// @param index1 The index of the first collateral to be swapped.\\n    /// @param index2 The index of the second collateral to be swapped.\\n    function reorderCollaterals(address account, uint8 index1, uint8 index2) external payable;\\n\\n    /// @notice Returns an array of enabled controllers for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over the account's\\n    /// balances in enabled collaterals vaults. A user can have multiple controllers during a call execution, but at\\n    /// most one can be selected when the account status check is performed.\\n    /// @param account The address of the account whose controllers are being queried.\\n    /// @return An array of addresses that are the enabled controllers for the account.\\n    function getControllers(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a controller is enabled for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the controller that is being checked.\\n    /// @return A boolean value that indicates whether the vault is enabled controller for the account or not.\\n    function isControllerEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. Only the owner or an operator of the account can call this function.\\n    /// Unless it's a duplicate, the controller is added to the end of the array. Transiently, there can be at most 10\\n    /// unique controllers enabled at a time, but at most one can be enabled after the outermost checks-deferrable\\n    /// call concludes. Account status checks are performed.\\n    /// @param account The address for which the controller is being enabled.\\n    /// @param vault The address of the controller being enabled.\\n    function enableController(address account, address vault) external payable;\\n\\n    /// @notice Disables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over account\u2019s\\n    /// balances in the enabled collaterals vaults. Only the vault itself can call this function. Disabling a controller\\n    /// might change the order of controllers in the array obtained using getControllers function. Account status checks\\n    /// are performed.\\n    /// @param account The address for which the calling controller is being disabled.\\n    function disableController(address account) external payable;\\n\\n    /// @notice Executes signed arbitrary data by self-calling into the EVC.\\n    /// @dev Low-level call function is used to execute the arbitrary data signed by the owner or the operator on the\\n    /// EVC contract. During that call, EVC becomes msg.sender.\\n    /// @param signer The address signing the permit message (ECDSA) or verifying the permit message signature\\n    /// (ERC-1271). It's also the owner or the operator of all the accounts for which authentication will be needed\\n    /// during the execution of the arbitrary data call.\\n    /// @param sender The address of the msg.sender which is expected to execute the data signed by the signer. If\\n    /// address(0) is passed, the msg.sender is ignored.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being used.\\n    /// @param nonce The nonce for the given account and nonce namespace. A valid nonce value is considered to be the\\n    /// value currently stored and can take any value between 0 and type(uint256).max - 1.\\n    /// @param deadline The timestamp after which the permit is considered expired.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is self-called on the EVC contract.\\n    /// @param signature The signature of the data signed by the signer.\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /// @notice Calls into a target contract as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred. If the target contract\\n    /// is msg.sender, msg.sender is called back with the calldata provided and the context set up according to the\\n    /// account provided. If the target contract is not msg.sender, only the owner or the operator of the account\\n    /// provided can call this function.\\n    /// @dev This function can be used to recover the remaining value from the EVC contract.\\n    /// @param targetContract The address of the contract to be called.\\n    /// @param onBehalfOfAccount  If the target contract is msg.sender, the address of the account which will be set\\n    /// in the context. It assumes msg.sender has authenticated the account themselves. If the target contract is\\n    /// not msg.sender, the address of the account for which it is checked whether msg.sender is authorized to act\\n    /// on behalf of.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target contract.\\n    /// @return result The result of the call.\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice For a given account, calls into one of the enabled collateral vaults from the currently enabled\\n    /// controller vault as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred as long as the contract\\n    /// is enabled as a collateral of the account and the msg.sender is the only enabled controller of the account.\\n    /// @param targetCollateral The collateral address to be called.\\n    /// @param onBehalfOfAccount The address of the account for which it is checked whether msg.sender is authorized to\\n    /// act on behalf.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target collateral.\\n    /// @return result The result of the call.\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev The authentication rules for each batch item are the same as for the call function.\\n    /// @param items An array of batch items to be executed.\\n    function batch(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function always reverts as it's only used for simulation purposes. This function cannot be called\\n    /// within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    function batchRevert(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function does not modify state and should only be used for simulation purposes. This function cannot\\n    /// be called within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    /// @return batchItemsResult An array of batch item results for each item.\\n    /// @return accountsStatusCheckResult An array of account status check results for each account.\\n    /// @return vaultsStatusCheckResult An array of vault status check results for each vault.\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        );\\n\\n    /// @notice Retrieves the timestamp of the last successful account status check performed for a specific account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @dev The account status check is considered to be successful if it calls into the selected controller vault and\\n    /// obtains expected magic value. This timestamp does not change if the account status is considered valid when no\\n    /// controller enabled. When consuming, one might need to ensure that the account status check is not deferred at\\n    /// the moment.\\n    /// @param account The address of the account for which the last status check timestamp is being queried.\\n    /// @return The timestamp of the last status check as a uint256.\\n    function getLastAccountStatusCheckTimestamp(address account) external view returns (uint256);\\n\\n    /// @notice Checks whether the status check is deferred for a given account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param account The address of the account for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isAccountStatusCheckDeferred(address account) external view returns (bool);\\n\\n    /// @notice Checks the status of an account and reverts if it is not valid.\\n    /// @dev If checks deferred, the account is added to the set of accounts to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique accounts added to the set at a time. Account status\\n    /// check is performed by calling into the selected controller vault and passing the array of currently enabled\\n    /// collaterals. If controller is not selected, the account is always considered valid.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Forgives previously deferred account status check.\\n    /// @dev Account address is removed from the set of addresses for which status checks are deferred. This function\\n    /// can only be called by the currently enabled controller of a given account. Depending on the vault\\n    /// implementation, may be needed in the liquidation flow.\\n    /// @param account The address of the account for which the status check is forgiven.\\n    function forgiveAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Checks whether the status check is deferred for a given vault.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param vault The address of the vault for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool);\\n\\n    /// @notice Checks the status of a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the vault is added to the set of vaults to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique vaults added to the set at a time. This function can\\n    /// only be called by the vault itself.\\n    function requireVaultStatusCheck() external payable;\\n\\n    /// @notice Forgives previously deferred vault status check.\\n    /// @dev Vault address is removed from the set of addresses for which status checks are deferred. This function can\\n    /// only be called by the vault itself.\\n    function forgiveVaultStatusCheck() external payable;\\n\\n    /// @notice Checks the status of an account and a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the account and the vault are added to the respective sets of accounts and vaults to be\\n    /// checked at the end of the outermost checks-deferrable call. Account status check is performed by calling into\\n    /// selected controller vault and passing the array of currently enabled collaterals. If controller is not selected,\\n    /// the account is always considered valid. This function can only be called by the vault itself.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountAndVaultStatusCheck(address account) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/ethereum-vault-connector/src/ExecutionContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ntype EC is uint256;\\n\\n/// @title ExecutionContext\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing the execution context in the Ethereum Vault Connector.\\n/// @dev The execution context is a bit field that stores the following information:\\n/// @dev - on behalf of account - an account on behalf of which the currently executed operation is being performed\\n/// @dev - checks deferred flag - used to indicate whether checks are deferred\\n/// @dev - checks in progress flag - used to indicate that the account/vault status checks are in progress. This flag is\\n/// used to prevent re-entrancy.\\n/// @dev - control collateral in progress flag - used to indicate that the control collateral is in progress. This flag\\n/// is used to prevent re-entrancy.\\n/// @dev - operator authenticated flag - used to indicate that the currently executed operation is being performed by\\n/// the account operator\\n/// @dev - simulation flag - used to indicate that the currently executed batch call is a simulation\\n/// @dev - stamp - dummy value for optimization purposes\\nlibrary ExecutionContext {\\n    uint256 internal constant ON_BEHALF_OF_ACCOUNT_MASK =\\n        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant CHECKS_DEFERRED_MASK = 0x0000000000000000000000FF0000000000000000000000000000000000000000;\\n    uint256 internal constant CHECKS_IN_PROGRESS_MASK =\\n        0x00000000000000000000FF000000000000000000000000000000000000000000;\\n    uint256 internal constant CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK =\\n        0x000000000000000000FF00000000000000000000000000000000000000000000;\\n    uint256 internal constant OPERATOR_AUTHENTICATED_MASK =\\n        0x0000000000000000FF0000000000000000000000000000000000000000000000;\\n    uint256 internal constant SIMULATION_MASK = 0x00000000000000FF000000000000000000000000000000000000000000000000;\\n    uint256 internal constant STAMP_OFFSET = 200;\\n\\n    // None of the functions below modifies the state. All the functions operate on the copy\\n    // of the execution context and return its modified value as a result. In order to update\\n    // one should use the result of the function call as a new execution context value.\\n\\n    function getOnBehalfOfAccount(EC self) internal pure returns (address result) {\\n        result = address(uint160(EC.unwrap(self) & ON_BEHALF_OF_ACCOUNT_MASK));\\n    }\\n\\n    function setOnBehalfOfAccount(EC self, address account) internal pure returns (EC result) {\\n        result = EC.wrap((EC.unwrap(self) & ~ON_BEHALF_OF_ACCOUNT_MASK) | uint160(account));\\n    }\\n\\n    function areChecksDeferred(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_DEFERRED_MASK != 0;\\n    }\\n\\n    function setChecksDeferred(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_DEFERRED_MASK);\\n    }\\n\\n    function areChecksInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_IN_PROGRESS_MASK != 0;\\n    }\\n\\n    function setChecksInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_IN_PROGRESS_MASK);\\n    }\\n\\n    function isControlCollateralInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK != 0;\\n    }\\n\\n    function setControlCollateralInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK);\\n    }\\n\\n    function isOperatorAuthenticated(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & OPERATOR_AUTHENTICATED_MASK != 0;\\n    }\\n\\n    function setOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function clearOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) & ~OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function isSimulationInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & SIMULATION_MASK != 0;\\n    }\\n\\n    function setSimulationInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | SIMULATION_MASK);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ethereum-vault-connector/=lib/ethereum-vault-connector/src/\",\r\n      \"evc/=lib/ethereum-vault-connector/src/\",\r\n      \"evk/=lib/euler-vault-kit/src/\",\r\n      \"evk-test/=lib/euler-vault-kit/test/\",\r\n      \"euler-price-oracle/=lib/euler-price-oracle/src/\",\r\n      \"euler-price-oracle-test/=lib/euler-price-oracle/test/\",\r\n      \"fee-flow/=lib/fee-flow/src/\",\r\n      \"reward-streams/=lib/reward-streams/src/\",\r\n      \"@openzeppelin/contracts/utils/math/=lib/euler-price-oracle/lib/openzeppelin-contracts/contracts/utils/math/\",\r\n      \"@chainlink/=lib/euler-price-oracle/node_modules/@chainlink/\",\r\n      \"@eth-optimism/=lib/euler-price-oracle/node_modules/@eth-optimism/contracts/\",\r\n      \"@pyth/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"@redstone-finance/=lib/euler-price-oracle/node_modules/@redstone-finance/\",\r\n      \"@redstone/evm-connector/=lib/euler-price-oracle/lib/redstone-oracles-monorepo/packages/evm-connector/contracts/\",\r\n      \"@solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"@uniswap/v3-core/=lib/euler-price-oracle/lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/\",\r\n      \"ds-test/=lib/fee-flow/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"euler-vault-kit/=lib/euler-vault-kit/src/\",\r\n      \"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\r\n      \"openzeppelin/=lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\r\n      \"permit2/=lib/euler-vault-kit/lib/permit2/\",\r\n      \"pyth-sdk-solidity/=lib/euler-price-oracle/lib/pyth-sdk-solidity/\",\r\n      \"redstone-oracles-monorepo/=lib/euler-price-oracle/lib/\",\r\n      \"solady/=lib/euler-price-oracle/lib/solady/src/\",\r\n      \"solmate/=lib/fee-flow/lib/solmate/src/\",\r\n      \"v3-core/=lib/euler-price-oracle/lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/euler-price-oracle/lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_evc\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Factory_BadQuery\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deployedAt\",\"type\":\"uint256\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EVC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getDeploymentInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"deployedAt\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeploymentsListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getDeploymentsListSlice\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"isValidDeployment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EulerRouterFactory", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000000c9a3dd6b8f28529d72d7f9ce918d493519ee383", "EVMVersion": "cancun", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}