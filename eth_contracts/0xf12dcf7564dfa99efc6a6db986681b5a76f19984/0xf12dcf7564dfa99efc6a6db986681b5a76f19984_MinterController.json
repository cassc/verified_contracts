{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MinterController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IStanceRKLCollection} from \\\"./interfaces/IStanceRKLCollection.sol\\\";\\nimport {IMinterController} from \\\"./interfaces/IMinterController.sol\\\";\\n\\nimport {Ownable} from \\\"./common/Ownable.sol\\\";\\nimport {Constants} from \\\"./common/Constants.sol\\\";\\n\\ncontract MinterController is IMinterController, Ownable, Constants {\\n    IStanceRKLCollection public STANCE_RKL_COLLECTION;\\n    mapping(address minter => IMinterController.MinterAllowedTokenIds allowedTokenIdRange) public registeredMinters;\\n\\n    constructor() {\\n        admin = msg.sender;\\n    }\\n\\n    /// @dev we start minting from token id = 1. so checking for lower bound to be\\n    //       equal to zero is essentially checking if minter has been registered\\n    function _checkMinterIsRegistered(address minter) private view {\\n        if (registeredMinters[minter].lowerBound == 0) {\\n            revert MinterNotRegistered();\\n        }\\n    }\\n\\n    function _checkMinterIsNotRegistered(address minter) private view {\\n        if (registeredMinters[minter].lowerBound != 0) {\\n            revert MinterAlreadyRegistered();\\n        }\\n    }\\n\\n    function _checkMintersBounds(IMinterController.MinterAllowedTokenIds calldata bounds) private pure {\\n        if (bounds.lowerBound > bounds.upperBound) {\\n            revert InvalidBounds(bounds.lowerBound, bounds.upperBound);\\n        }\\n    }\\n\\n    /// @dev 1. checks if minter is registered for mint with StanceRKLCollection\\n    //       2. checks if minter is allowed to mint those specific tokenIds\\n    function checkMinterAllowedForTokenIds(address minter, uint256[] memory tokenIds) external view override {\\n        if (minter == ZERO_ADDRESS) {\\n            revert MinterZeroAddressNotAllowed();\\n        }\\n        _checkMinterIsRegistered(minter);\\n        IMinterController.MinterAllowedTokenIds memory bounds = registeredMinters[minter];\\n        for (uint256 i = 0; i < tokenIds.length;) {\\n            if (tokenIds[i] < bounds.lowerBound || tokenIds[i] > bounds.upperBound) {\\n                revert MinterNotAllowedForTokenId(tokenIds[i], bounds.lowerBound, bounds.upperBound);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // =====================================================================//\\n    //                              Admin                                   //\\n    // =====================================================================//\\n\\n    function setStanceRKLCollection(address stanceRklCollection) external onlyOwner {\\n        STANCE_RKL_COLLECTION = IStanceRKLCollection(stanceRklCollection);\\n    }\\n\\n    function registerMinter(address minter, IMinterController.MinterAllowedTokenIds calldata bounds)\\n        external\\n        onlyOwner\\n    {\\n        if (minter == ZERO_ADDRESS) {\\n            revert MinterZeroAddressNotAllowed();\\n        }\\n        _checkMinterIsNotRegistered(minter);\\n        _checkMintersBounds(bounds);\\n        registeredMinters[minter] = bounds;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStanceRKLCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IStanceRKLCollection {\\n    error NothingToMint();\\n    error ArgLengthMismatch();\\n    error MintToZeroAddr();\\n\\n    function mint(address to, uint256[] memory tokenIds, uint256[] memory amounts) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinterController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @dev responsible for registering minters with StanceRKLCollection\\n///      responsible for checking if particular Minter is allowed to mint token ids\\n///      responsible for managing token ids for StanceRKLCollection\\ninterface IMinterController {\\n    error MinterZeroAddressNotAllowed();\\n    error MinterNotRegistered();\\n    error MinterNotAllowedForTokenId(uint256 requestedTokenId, uint256 allowedLowerBound, uint256 allowedUpperBound);\\n    error MinterAlreadyRegistered();\\n    error InvalidBounds(uint128 lowerBound, uint128 upperBound);\\n\\n    /// @dev if only one token id is allowed, then lowerBound == upperBound\\n    ///      note that the bounds are inclusive, so lowerBound := 2 and\\n    ///      upperBound := 4 would mean that minter is allowed to mint token\\n    ///      ids 2, 3 and 4.\\n    struct MinterAllowedTokenIds {\\n        uint128 lowerBound;\\n        uint128 upperBound;\\n    }\\n\\n    /// @dev minter is the address of the contract that implementes IMinter\\n    ///      throws MinterNotAllowedForTokenId\\n    function checkMinterAllowedForTokenIds(address minter, uint256[] memory tokenIds) external;\\n\\n    /// @dev registers a new minter with StanceRKLCollection\\n    function registerMinter(address minter, MinterAllowedTokenIds calldata) external;\\n}\\n\"\r\n    },\r\n    \"src/common/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nabstract contract Ownable {\\n    error NotAdmin();\\n\\n    address public admin;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != admin) {\\n            revert NotAdmin();\\n        }\\n        _;\\n    }\\n\\n    function changeAdmin(address newAdmin) external onlyOwner {\\n        admin = newAdmin;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/common/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nabstract contract Constants {\\n    address internal constant ZERO_ADDRESS = address(0);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"lowerBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"upperBound\",\"type\":\"uint128\"}],\"name\":\"InvalidBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinterAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestedTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowedLowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowedUpperBound\",\"type\":\"uint256\"}],\"name\":\"MinterNotAllowedForTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinterNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinterZeroAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STANCE_RKL_COLLECTION\",\"outputs\":[{\"internalType\":\"contract IStanceRKLCollection\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkMinterAllowedForTokenIds\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"lowerBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"upperBound\",\"type\":\"uint128\"}],\"internalType\":\"struct IMinterController.MinterAllowedTokenIds\",\"name\":\"bounds\",\"type\":\"tuple\"}],\"name\":\"registerMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"registeredMinters\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"lowerBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"upperBound\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stanceRklCollection\",\"type\":\"address\"}],\"name\":\"setStanceRKLCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterController", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}