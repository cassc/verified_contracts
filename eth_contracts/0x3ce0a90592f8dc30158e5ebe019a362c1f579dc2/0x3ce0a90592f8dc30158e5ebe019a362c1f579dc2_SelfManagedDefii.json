{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/defii/execution/Execution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {SharedLiquidity} from \\\"./SharedLiquidity.sol\\\";\\nimport {Logic} from \\\"./Logic.sol\\\";\\nimport {Constants} from \\\"../../libraries/Constants.sol\\\";\\n\\nabstract contract Execution is SharedLiquidity, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    struct ExecutionConstructorParams {\\n        address logic;\\n        address incentiveVault;\\n        address treasury;\\n        uint256 fixedFee;\\n        uint256 performanceFee;\\n    }\\n\\n    address public immutable LOGIC;\\n    address public immutable INCENTIVE_VAULT;\\n    address public immutable TREASURY;\\n    uint256 public immutable PERFORMANCE_FEE;\\n    uint256 public immutable FIXED_FEE;\\n    bool public killed;\\n\\n    event Entered(uint256 liquidityDelta);\\n    event EmergencyExited();\\n\\n    error EnterFailed();\\n    error ExitFailed();\\n    error Killed();\\n    error NotKilled();\\n\\n    modifier alive() {\\n        if (killed) revert Killed();\\n        _;\\n    }\\n\\n    constructor(ExecutionConstructorParams memory params) Ownable(msg.sender) {\\n        LOGIC = params.logic;\\n        INCENTIVE_VAULT = params.incentiveVault;\\n        TREASURY = params.treasury;\\n        PERFORMANCE_FEE = params.performanceFee;\\n        FIXED_FEE = params.fixedFee;\\n    }\\n\\n    function claimRewards() external {\\n        _logic(abi.encodeCall(Logic.claimRewards, (INCENTIVE_VAULT)));\\n    }\\n\\n    function emergencyExit() external alive onlyOwner {\\n        _logic(abi.encodeCall(Logic.emergencyExit, ()));\\n\\n        killed = true;\\n        emit EmergencyExited();\\n    }\\n\\n    function totalLiquidity() public view override returns (uint256) {\\n        return Logic(LOGIC).accountLiquidity(address(this));\\n    }\\n\\n    function _enter(\\n        uint256 minLiquidityDelta\\n    ) internal alive returns (uint256 newShares) {\\n        uint256 liquidityBefore = totalLiquidity();\\n        _logic(abi.encodeCall(Logic.enter, ()));\\n        uint256 liquidityAfter = totalLiquidity();\\n        if (\\n            liquidityBefore >= liquidityAfter ||\\n            (liquidityAfter - liquidityBefore) < minLiquidityDelta\\n        ) {\\n            revert EnterFailed();\\n        }\\n        emit Entered(liquidityAfter - liquidityBefore);\\n\\n        return _sharesFromLiquidityDelta(liquidityBefore, liquidityAfter);\\n    }\\n\\n    function _exit(\\n        uint256 shares,\\n        address[] memory tokens,\\n        uint256[] memory minDeltas\\n    ) internal alive {\\n        uint256 n = tokens.length;\\n        for (uint256 i = 0; i < n; i++) {\\n            minDeltas[i] += IERC20(tokens[i]).balanceOf(address(this));\\n        }\\n\\n        uint256 liquidity = _toLiquidity(shares);\\n        _logic(abi.encodeCall(Logic.exit, (liquidity)));\\n\\n        for (uint256 i = 0; i < n; i++) {\\n            if (IERC20(tokens[i]).balanceOf(address(this)) < minDeltas[i]) {\\n                revert ExitFailed();\\n            }\\n        }\\n    }\\n\\n    function _withdrawLiquidity(\\n        address recipient,\\n        uint256 amount\\n    ) internal alive {\\n        _logic(abi.encodeCall(Logic.withdrawLiquidity, (recipient, amount)));\\n    }\\n\\n    function _withdrawAfterEmergencyExit(\\n        address recipient,\\n        uint256 shares,\\n        uint256 totalShares,\\n        address[] memory tokens\\n    ) internal {\\n        if (!killed) revert NotKilled();\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n            if (tokenBalance > 0) {\\n                IERC20(tokens[i]).safeTransfer(\\n                    recipient,\\n                    (tokenBalance * shares) / totalShares\\n                );\\n            }\\n        }\\n    }\\n\\n    function _logic(bytes memory call) internal returns (bytes memory data) {\\n        bool success;\\n        (success, data) = LOGIC.delegatecall(call);\\n\\n        if (!success) {\\n            assembly {\\n                revert(add(data, 32), mload(data))\\n            }\\n        }\\n    }\\n\\n    function _calculateFixedFeeAmount(\\n        uint256 shares\\n    ) internal view returns (uint256 performanceFeeAmount) {\\n        return (shares * FIXED_FEE) / Constants.BPS;\\n    }\\n\\n    function _calculatePerformanceFeeAmount(\\n        uint256 shares\\n    ) internal view returns (uint256 performanceFeeAmount) {\\n        return (shares * PERFORMANCE_FEE) / Constants.BPS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/defii/execution/Logic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nabstract contract Logic {\\n    error NotImplemented();\\n\\n    function claimRewards(address recipient) external payable virtual {\\n        revert NotImplemented();\\n    }\\n\\n    function emergencyExit() external payable virtual {\\n        revert NotImplemented();\\n    }\\n\\n    function withdrawLiquidity(\\n        address recipient,\\n        uint256 amount\\n    ) external payable virtual {\\n        revert NotImplemented();\\n    }\\n\\n    function enter() external payable virtual;\\n\\n    function exit(uint256 liquidity) external payable virtual;\\n\\n    function accountLiquidity(\\n        address account\\n    ) external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/defii/execution/SharedLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\n/* solhint-disable named-return-values */\\nabstract contract SharedLiquidity {\\n    function totalShares() public view virtual returns (uint256);\\n\\n    function totalLiquidity() public view virtual returns (uint256);\\n\\n    function _sharesFromLiquidityDelta(\\n        uint256 liquidityBefore,\\n        uint256 liquidityAfter\\n    ) internal view returns (uint256) {\\n        uint256 totalShares_ = totalShares();\\n        uint256 liquidityDelta = liquidityAfter - liquidityBefore;\\n        if (totalShares_ == 0) {\\n            return liquidityDelta;\\n        } else {\\n            return (liquidityDelta * totalShares_) / liquidityBefore;\\n        }\\n    }\\n\\n    function _toLiquidity(uint256 shares) internal view returns (uint256) {\\n        return (shares * totalLiquidity()) / totalShares();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/defii/instructions/LocalInstructions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {IVault} from \\\"../../interfaces/IVault.sol\\\";\\nimport {IDefii} from \\\"../../interfaces/IDefii.sol\\\";\\n\\ncontract LocalInstructions {\\n    using SafeERC20 for IERC20;\\n\\n    address immutable SWAP_ROUTER;\\n\\n    event Swap(\\n        address tokenIn,\\n        address tokenOut,\\n        address swapRouter,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    error WrongInstructionType(\\n        IDefii.InstructionType provided,\\n        IDefii.InstructionType required\\n    );\\n    error InstructionFailed();\\n\\n    constructor(address swapRouter) {\\n        SWAP_ROUTER = swapRouter;\\n    }\\n\\n    function _doSwap(\\n        IDefii.SwapInstruction memory swapInstruction\\n    ) internal returns (uint256 amountOut) {\\n        if (swapInstruction.tokenIn == swapInstruction.tokenOut) {\\n            return swapInstruction.amountIn;\\n        }\\n        amountOut = IERC20(swapInstruction.tokenOut).balanceOf(address(this));\\n        IERC20(swapInstruction.tokenIn).safeIncreaseAllowance(\\n            SWAP_ROUTER,\\n            swapInstruction.amountIn\\n        );\\n        (bool success, ) = SWAP_ROUTER.call(swapInstruction.routerCalldata);\\n\\n        amountOut =\\n            IERC20(swapInstruction.tokenOut).balanceOf(address(this)) -\\n            amountOut;\\n\\n        if (!success || amountOut < swapInstruction.minAmountOut)\\n            revert InstructionFailed();\\n\\n        emit Swap(\\n            swapInstruction.tokenIn,\\n            swapInstruction.tokenOut,\\n            SWAP_ROUTER,\\n            swapInstruction.amountIn,\\n            amountOut\\n        );\\n    }\\n\\n    function _returnAllFunds(\\n        address vault,\\n        uint256 positionId,\\n        address token\\n    ) internal {\\n        _returnFunds(\\n            vault,\\n            positionId,\\n            token,\\n            IERC20(token).balanceOf(address(this))\\n        );\\n    }\\n\\n    function _returnFunds(\\n        address vault,\\n        uint256 positionId,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            IERC20(token).safeIncreaseAllowance(vault, amount);\\n            IVault(vault).depositToPosition(positionId, token, amount, 0);\\n        }\\n    }\\n\\n    function _checkInstructionType(\\n        IDefii.Instruction memory instruction,\\n        IDefii.InstructionType requiredType\\n    ) internal pure {\\n        if (instruction.type_ != requiredType) {\\n            revert WrongInstructionType(instruction.type_, requiredType);\\n        }\\n    }\\n\\n    /* solhint-disable named-return-values */\\n    function _decodeSwap(\\n        IDefii.Instruction memory instruction\\n    ) internal pure returns (IDefii.SwapInstruction memory) {\\n        _checkInstructionType(instruction, IDefii.InstructionType.SWAP);\\n        return abi.decode(instruction.data, (IDefii.SwapInstruction));\\n    }\\n\\n    function _decodeMinLiquidityDelta(\\n        IDefii.Instruction memory instruction\\n    ) internal pure returns (uint256) {\\n        _checkInstructionType(\\n            instruction,\\n            IDefii.InstructionType.MIN_LIQUIDITY_DELTA\\n        );\\n        return abi.decode(instruction.data, (uint256));\\n    }\\n\\n    function _decodeMinTokensDelta(\\n        IDefii.Instruction memory instruction\\n    ) internal pure returns (IDefii.MinTokensDeltaInstruction memory) {\\n        _checkInstructionType(\\n            instruction,\\n            IDefii.InstructionType.MIN_TOKENS_DELTA\\n        );\\n        return abi.decode(instruction.data, (IDefii.MinTokensDeltaInstruction));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/defii/supported-tokens/SupportedTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nabstract contract SupportedTokens {\\n    error TokenNotSupported(address token);\\n\\n    function supportedTokens() public view virtual returns (address[] memory t);\\n\\n    function _checkToken(address token) internal view {\\n        if (!_isTokenSupported(token)) {\\n            revert TokenNotSupported(token);\\n        }\\n    }\\n\\n    function _isTokenSupported(\\n        address\\n    ) internal view virtual returns (bool isSupported);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDefii.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDefii is IERC20 {\\n    /// @notice Instruction type\\n    /// @dev SWAP_BRIDGE is combination of SWAP + BRIDGE instructions.\\n    /// @dev Data for MIN_LIQUIDITY_DELTA type is just `uint256`\\n    enum InstructionType {\\n        SWAP,\\n        BRIDGE,\\n        SWAP_BRIDGE,\\n        REMOTE_CALL,\\n        MIN_LIQUIDITY_DELTA,\\n        MIN_TOKENS_DELTA\\n    }\\n\\n    /// @notice DEFII type\\n    enum Type {\\n        LOCAL,\\n        REMOTE\\n    }\\n\\n    /// @notice DEFII instruction\\n    struct Instruction {\\n        InstructionType type_;\\n        bytes data;\\n    }\\n\\n    /// @notice Swap instruction\\n    /// @dev `routerCalldata` - 1inch router calldata from API\\n    struct SwapInstruction {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        bytes routerCalldata;\\n    }\\n\\n    /// @notice Bridge instruction\\n    /// @dev `slippage` should be in bps\\n    struct BridgeInstruction {\\n        address token;\\n        uint256 amount;\\n        uint256 slippage;\\n        address bridgeAdapter;\\n        uint256 value;\\n        bytes bridgeParams;\\n    }\\n\\n    /// @notice Swap and bridge instruction. Do swap and bridge all token from swap\\n    /// @dev `routerCalldata` - 1inch router calldata from API\\n    /// @dev `slippage` should be in bps\\n    struct SwapBridgeInstruction {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        bytes routerCalldata;\\n        address bridgeAdapter;\\n        uint256 value;\\n        bytes bridgeParams;\\n        uint256 slippage;\\n    }\\n\\n    struct MinTokensDeltaInstruction {\\n        address[] tokens;\\n        uint256[] deltas;\\n    }\\n\\n    /// @notice Enters DEFII with predefined logic\\n    /// @param amount Notion amount for enter\\n    /// @param positionId Position id (used in callback)\\n    /// @param instructions List with instructions for enter\\n    /// @dev Caller should implement `IVault` interface\\n    function enter(\\n        uint256 amount,\\n        uint256 positionId,\\n        Instruction[] calldata instructions\\n    ) external payable;\\n\\n    /// @notice Exits from DEFII with predefined logic\\n    /// @param shares Defii lp amount to burn\\n    /// @param positionId Position id (used in callback)\\n    /// @param instructions List with instructions for enter\\n    /// @dev Caller should implement `IVault` interface\\n    function exit(\\n        uint256 shares,\\n        uint256 positionId,\\n        Instruction[] calldata instructions\\n    ) external payable;\\n\\n    /// @notice Withdraw liquidity (eg lp tokens) from\\n    /// @param shares Defii lp amount to burn\\n    /// @param recipient Address for withdrawal\\n    /// @param instructions List with instructions\\n    /// @dev Caller should implement `IVault` interface\\n    function withdrawLiquidity(\\n        address recipient,\\n        uint256 shares,\\n        Instruction[] calldata instructions\\n    ) external payable;\\n\\n    /// @notice DEFII notion (start token)\\n    /// @return notion address\\n    // solhint-disable-next-line named-return-values\\n    function notion() external view returns (address);\\n\\n    /// @notice DEFII type\\n    /// @return type Type\\n    // solhint-disable-next-line named-return-values\\n    function defiiType() external pure returns (Type);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Enumerable} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\nimport {IDefii} from \\\"./IDefii.sol\\\";\\nimport {Status} from \\\"../libraries/StatusLogic.sol\\\";\\n\\ninterface IVault is IERC721Enumerable {\\n    /// @notice Event emitted when vault balance has changed\\n    /// @param positionId Position id\\n    /// @param token token address\\n    /// @param amount token amount\\n    /// @param increased True if balance increased, False if balance decreased\\n    /// @dev You can get current balance via `funds(token, positionId)`\\n    event BalanceChanged(\\n        uint256 indexed positionId,\\n        address indexed token,\\n        uint256 amount,\\n        bool increased\\n    );\\n\\n    /// @notice Event emitted when defii status changed\\n    /// @param positionId Position id\\n    /// @param defii Defii address\\n    /// @param newStatus New status\\n    event DefiiStatusChanged(\\n        uint256 indexed positionId,\\n        address indexed defii,\\n        Status indexed newStatus\\n    );\\n\\n    /// @notice Reverts, for example, if you try twice run enterDefii before processing ended\\n    /// @param currentStatus - Current defii status\\n    /// @param wantStatus - Want defii status\\n    /// @param positionStatus - Position status\\n    error CantChangeDefiiStatus(\\n        Status currentStatus,\\n        Status wantStatus,\\n        Status positionStatus\\n    );\\n\\n    /// @notice Reverts if trying to decrease more balance than there is\\n    error InsufficientBalance(\\n        uint256 positionId,\\n        address token,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n\\n    /// @notice Reverts if trying to exit with 0% or > 100%\\n    error WrongExitPercentage(uint256 percentage);\\n\\n    /// @notice Reverts if position processing in case we can't\\n    error PositionProcessing();\\n\\n    /// @notice Reverts if trying use unknown defii\\n    error UnsupportedDefii(address defii);\\n\\n    /// @notice Deposits token to vault. If caller don't have position, opens it\\n    /// @param token Token address.\\n    /// @param amount Token amount.\\n    /// @param operatorFeeAmount Fee for operator (offchain service help)\\n    /// @dev You need to get `operatorFeeAmount` from API or set it to 0, if you don't need operator\\n    function deposit(\\n        address token,\\n        uint256 amount,\\n        uint256 operatorFeeAmount\\n    ) external returns (uint256 positionId);\\n\\n    /// @notice Deposits token to vault. If caller don't have position, opens it\\n    /// @param token Token address\\n    /// @param amount Token amount\\n    /// @param operatorFeeAmount Fee for operator (offchain service help)\\n    /// @param deadline Permit deadline\\n    /// @param permitV The V parameter of ERC712 permit sig\\n    /// @param permitR The R parameter of ERC712 permit sig\\n    /// @param permitS The S parameter of ERC712 permit sig\\n    /// @dev You need to get `operatorFeeAmount` from API or set it to 0, if you don't need operator\\n    function depositWithPermit(\\n        address token,\\n        uint256 amount,\\n        uint256 operatorFeeAmount,\\n        uint256 deadline,\\n        uint8 permitV,\\n        bytes32 permitR,\\n        bytes32 permitS\\n    ) external returns (uint256 positionId);\\n\\n    /// @notice Deposits token to vault. If caller don't have position, opens it\\n    /// @param positionId Position id\\n    /// @param token Token address\\n    /// @param amount Token amount\\n    /// @param operatorFeeAmount Fee for operator (offchain service help)\\n    /// @dev You need to get `operatorFeeAmount` from API or set it to 0, if you don't need operator\\n    function depositToPosition(\\n        uint256 positionId,\\n        address token,\\n        uint256 amount,\\n        uint256 operatorFeeAmount\\n    ) external;\\n\\n    /// @notice Withdraws token from vault\\n    /// @param token Token address\\n    /// @param amount Token amount\\n    /// @param positionId Position id\\n    /// @dev Validates, that position not processing, if `token` is `NOTION`\\n    function withdraw(\\n        address token,\\n        uint256 amount,\\n        uint256 positionId\\n    ) external;\\n\\n    /// @notice Enters the defii\\n    /// @param defii Defii address\\n    /// @param positionId Position id\\n    /// @param instructions List with encoded instructions for DEFII\\n    function enterDefii(\\n        address defii,\\n        uint256 positionId,\\n        IDefii.Instruction[] calldata instructions\\n    ) external payable;\\n\\n    /// @notice Callback for DEFII\\n    /// @param positionId Position id\\n    /// @param shares Minted shares amount\\n    /// @dev DEFII should call it after enter\\n    function enterCallback(uint256 positionId, uint256 shares) external;\\n\\n    /// @notice Exits from defii\\n    /// @param defii Defii address\\n    /// @param positionId Position id\\n    /// @param instructions List with encoded instructions for DEFII\\n    function exitDefii(\\n        address defii,\\n        uint256 positionId,\\n        IDefii.Instruction[] calldata instructions\\n    ) external payable;\\n\\n    /// @notice Callback for DEFII\\n    /// @param positionId Position id\\n    /// @dev DEFII should call it after exit\\n    function exitCallback(uint256 positionId) external;\\n\\n    function NOTION() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nlibrary Constants {\\n    uint256 constant BPS = 1e4;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StatusLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {IVault} from \\\"../interfaces/IVault.sol\\\";\\n\\nuint256 constant MASK_SIZE = 2;\\nuint256 constant ONES_MASK = (1 << MASK_SIZE) - 1;\\nuint256 constant MAX_DEFII_AMOUNT = 256 / MASK_SIZE - 1;\\n\\nenum Status {\\n    NOT_PROCESSING,\\n    ENTERING,\\n    EXITING,\\n    PROCESSED\\n}\\n\\ntype Statuses is uint256;\\nusing StatusLogic for Statuses global;\\n\\nlibrary StatusLogic {\\n    /*\\n    Library for gas efficient status updates.\\n\\n    We have more than 2 statuses, so, we can't use simple bitmask. To solve\\n    this problem, we use MASK_SIZE bits for every status.\\n    */\\n\\n    function getPositionStatus(\\n        Statuses statuses\\n    ) internal pure returns (Status positionStatus) {\\n        return\\n            Status(Statuses.unwrap(statuses) >> (MASK_SIZE * MAX_DEFII_AMOUNT));\\n    }\\n\\n    function getDefiiStatus(\\n        Statuses statuses,\\n        uint256 defiiIndex\\n    ) internal pure returns (Status defiiStatus) {\\n        return\\n            Status(\\n                (Statuses.unwrap(statuses) >> (MASK_SIZE * defiiIndex)) &\\n                    ONES_MASK\\n            );\\n    }\\n\\n    // solhint-disable-next-line named-return-values\\n    function isAllDefiisProcessed(\\n        Statuses statuses,\\n        uint256 numDefiis\\n    ) internal pure returns (bool) {\\n        // Status.PROCESSED = 3 = 0b11\\n        // So, if all defiis processed, we have\\n        // statuses = 0b0100......111111111\\n\\n        // First we need remove 2 left bits (position status)\\n        uint256 withoutPosition = Statuses.unwrap(\\n            statuses.setPositionStatus(Status.NOT_PROCESSING)\\n        );\\n\\n        return (withoutPosition + 1) == (2 ** (MASK_SIZE * numDefiis));\\n    }\\n\\n    function updateDefiiStatus(\\n        Statuses statuses,\\n        uint256 defiiIndex,\\n        Status newStatus,\\n        uint256 numDefiis\\n    ) internal pure returns (Statuses newStatuses) {\\n        Status positionStatus = statuses.getPositionStatus();\\n\\n        if (positionStatus == Status.NOT_PROCESSING) {\\n            // If position not processing:\\n            // - we can start enter/exit\\n            // - we need to update position status too\\n            if (newStatus == Status.ENTERING || newStatus == Status.EXITING) {\\n                return\\n                    statuses\\n                        .setDefiiStatus(defiiIndex, newStatus)\\n                        .setPositionStatus(newStatus);\\n            }\\n        } else {\\n            Status currentStatus = statuses.getDefiiStatus(defiiIndex);\\n            // If position entering:\\n            // - we can start/finish enter\\n            // - we need to reset position status, if all defiis has processed\\n\\n            // If position exiting:\\n            // - we can start/finish exit\\n            // - we need to reset position status, if all defiis has processed\\n\\n            // prettier-ignore\\n            if ((\\n        positionStatus == Status.ENTERING && currentStatus == Status.NOT_PROCESSING && newStatus == Status.ENTERING)\\n        || (positionStatus == Status.ENTERING && currentStatus == Status.ENTERING && newStatus == Status.PROCESSED)\\n        || (positionStatus == Status.EXITING && currentStatus == Status.NOT_PROCESSING && newStatus == Status.EXITING)\\n        || (positionStatus == Status.EXITING && currentStatus == Status.EXITING && newStatus == Status.PROCESSED)) {\\n                statuses = statuses.setDefiiStatus(defiiIndex, newStatus);\\n                if (statuses.isAllDefiisProcessed(numDefiis)) {\\n                    return Statuses.wrap(0);\\n                } else {\\n                    return statuses;\\n                }\\n            }\\n        }\\n\\n        revert IVault.CantChangeDefiiStatus(\\n            statuses.getDefiiStatus(defiiIndex),\\n            newStatus,\\n            positionStatus\\n        );\\n    }\\n\\n    function setPositionStatus(\\n        Statuses statuses,\\n        Status newStatus\\n    ) internal pure returns (Statuses newStatuses) {\\n        uint256 offset = MASK_SIZE * MAX_DEFII_AMOUNT;\\n        uint256 cleanupMask = ~(ONES_MASK << offset);\\n        uint256 newStatusMask = uint256(newStatus) << offset;\\n        return\\n            Statuses.wrap(\\n                (Statuses.unwrap(statuses) & cleanupMask) | newStatusMask\\n            );\\n    }\\n\\n    function setDefiiStatus(\\n        Statuses statuses,\\n        uint256 defiiIndex,\\n        Status newStatus\\n    ) internal pure returns (Statuses newStatuses) {\\n        uint256 offset = MASK_SIZE * defiiIndex;\\n        uint256 cleanupMask = ~(ONES_MASK << offset);\\n        uint256 newStatusMask = uint256(newStatus) << offset;\\n        return\\n            Statuses.wrap(\\n                (Statuses.unwrap(statuses) & cleanupMask) | newStatusMask\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/self-managed/ISelfManagedFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\ninterface ISelfManagedFactory {\\n    function operator() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/self-managed/SelfManagedDefii.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20Metadata, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport {Logic} from \\\"../defii/execution/Logic.sol\\\";\\nimport {SelfManagedLogic} from \\\"./SelfManagedLogic.sol\\\";\\nimport {Execution} from \\\"../defii/execution/Execution.sol\\\";\\nimport {SupportedTokens} from \\\"../defii/supported-tokens/SupportedTokens.sol\\\";\\nimport {LocalInstructions} from \\\"../defii/instructions/LocalInstructions.sol\\\";\\nimport {IDefii} from \\\"../interfaces/IDefii.sol\\\";\\nimport {ISelfManagedFactory} from \\\"./ISelfManagedFactory.sol\\\";\\n\\ncontract SelfManagedDefii is Ownable {\\n    using Address for address;\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n    using SafeCast for int256;\\n\\n    uint256 public constant PERCENTAGE_BPS = 100;\\n    uint256 public constant SLIPPAGE_BPS = 10000;\\n\\n    // immutable like\\n    ISelfManagedFactory public immutable FACTORY;\\n    address public LOGIC;\\n\\n    address public incentiveVault;\\n\\n    modifier onlyOwnerOrOperator() {\\n        if (msg.sender != owner() && msg.sender != FACTORY.operator())\\n            revert Ownable.OwnableUnauthorizedAccount(msg.sender);\\n        _;\\n    }\\n\\n    constructor(address factory) Ownable(factory) {\\n        FACTORY = ISelfManagedFactory(factory);\\n    }\\n\\n    receive() external payable {}\\n\\n    function init(\\n        address logic,\\n        address owner,\\n        address incentiveVault_\\n    ) external {\\n        require(LOGIC == address(0));\\n        LOGIC = logic;\\n\\n        incentiveVault = incentiveVault_;\\n        _transferOwnership(owner);\\n    }\\n\\n    function enter(uint256 minLiquidityDelta) external onlyOwner {\\n        uint256 liquidityBefore = totalLiquidity();\\n        LOGIC.functionDelegateCall(abi.encodeCall(Logic.enter, ()));\\n        uint256 liquidityAfter = totalLiquidity();\\n        if (\\n            liquidityBefore > liquidityAfter ||\\n            (liquidityAfter - liquidityBefore) < minLiquidityDelta\\n        ) {\\n            revert Execution.EnterFailed();\\n        }\\n    }\\n\\n    function enterWithParameters(\\n        uint256 minLiquidityDelta,\\n        bytes calldata params\\n    ) external onlyOwner {\\n        uint256 liquidityBefore = totalLiquidity();\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(SelfManagedLogic.enterWithParams, (params))\\n        );\\n        uint256 liquidityAfter = totalLiquidity();\\n        if (\\n            liquidityBefore > liquidityAfter ||\\n            (liquidityAfter - liquidityBefore) < minLiquidityDelta\\n        ) {\\n            revert Execution.EnterFailed();\\n        }\\n    }\\n\\n    function exit(\\n        uint256 percentage,\\n        IDefii.MinTokensDeltaInstruction memory minTokensDelta\\n    ) external onlyOwner {\\n        if (percentage == 0) percentage = 100;\\n        uint256 liquidity = (percentage * totalLiquidity()) / PERCENTAGE_BPS;\\n\\n        uint256 n = minTokensDelta.tokens.length;\\n        for (uint256 i = 0; i < n; i++) {\\n            minTokensDelta.deltas[i] += IERC20(minTokensDelta.tokens[i])\\n                .balanceOf(address(this));\\n        }\\n\\n        LOGIC.functionDelegateCall(abi.encodeCall(Logic.exit, (liquidity)));\\n\\n        for (uint256 i = 0; i < n; i++) {\\n            if (\\n                IERC20(minTokensDelta.tokens[i]).balanceOf(address(this)) <\\n                minTokensDelta.deltas[i]\\n            ) {\\n                revert Execution.ExitFailed();\\n            }\\n        }\\n        for (uint256 i = 0; i < n; i++) {\\n            withdrawERC20(IERC20(minTokensDelta.tokens[i]));\\n        }\\n        claimRewards();\\n    }\\n\\n    function claimRewards() public onlyOwnerOrOperator {\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(Logic.claimRewards, (incentiveVault))\\n        );\\n    }\\n\\n    function emergencyExit() external onlyOwnerOrOperator {\\n        LOGIC.functionDelegateCall(abi.encodeCall(Logic.emergencyExit, ()));\\n    }\\n\\n    function emergencyExitPrivate() external onlyOwnerOrOperator {\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(SelfManagedLogic.emergencyExitPrivate, ())\\n        );\\n    }\\n\\n    function withdrawLiquidity(\\n        address account,\\n        uint256 amount\\n    ) external onlyOwner {\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(Logic.withdrawLiquidity, (account, amount))\\n        );\\n    }\\n\\n    function exitBuildingBlock(\\n        uint256 buildingBlockId\\n    ) external onlyOwnerOrOperator {\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(\\n                SelfManagedLogic.exitBuildingBlock,\\n                (buildingBlockId)\\n            )\\n        );\\n    }\\n\\n    function withdrawERC20(IERC20 token) public onlyOwnerOrOperator {\\n        uint256 tokenAmount = token.balanceOf(address(this));\\n        if (tokenAmount > 0) {\\n            token.safeTransfer(owner(), tokenAmount);\\n        }\\n    }\\n\\n    function withdrawETH() external onlyOwnerOrOperator {\\n        payable(owner()).sendValue(address(this).balance);\\n    }\\n\\n    function changeIncentiveVault(address incentiveVault_) external onlyOwner {\\n        incentiveVault = incentiveVault_;\\n    }\\n\\n    function runMultipleTx(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata datas\\n    ) external {\\n        // we don't need onlyOwner modifier, owner checks in runTx\\n        require(targets.length == datas.length);\\n        require(targets.length == values.length);\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            runTx(targets[i], values[i], datas[i]);\\n        }\\n    }\\n\\n    function runTx(\\n        address target,\\n        uint256 value,\\n        bytes memory data\\n    ) public onlyOwner {\\n        target.functionCallWithValue(data, value);\\n    }\\n\\n    function simulateEnterWithParams(\\n        bytes memory params\\n    ) external returns (uint256 liquidityChanged) {\\n        try this.simulateEnterWithParamsAndRevert(params) {} catch (\\n            bytes memory result\\n        ) {\\n            liquidityChanged = abi.decode(result, (uint256));\\n        }\\n    }\\n\\n    function simulateEnterWithParamsAndRevert(bytes memory params) external {\\n        uint256 liquidityBefore = totalLiquidity();\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(SelfManagedLogic.enterWithParams, (params))\\n        );\\n        uint256 liquidityAfter = totalLiquidity();\\n        uint256 delta = liquidityAfter - liquidityBefore;\\n        bytes memory returnData = abi.encode(delta);\\n        uint256 returnDataLength = returnData.length;\\n        assembly {\\n            revert(add(returnData, 0x20), returnDataLength)\\n        }\\n    }\\n\\n    function simulateEnter() external returns (uint256 liquidityChanged) {\\n        try this.simulateEnterAndRevert() {} catch (bytes memory result) {\\n            liquidityChanged = abi.decode(result, (uint256));\\n        }\\n    }\\n\\n    function simulateEnterAndRevert() external {\\n        uint256 liquidityBefore = totalLiquidity();\\n        LOGIC.functionDelegateCall(abi.encodeCall(Logic.enter, ()));\\n        uint256 liquidityAfter = totalLiquidity();\\n        uint256 delta = liquidityAfter - liquidityBefore;\\n        bytes memory returnData = abi.encode(delta);\\n        uint256 returnDataLength = returnData.length;\\n        assembly {\\n            revert(add(returnData, 0x20), returnDataLength)\\n        }\\n    }\\n\\n    function simulateExit(\\n        uint256 percentage,\\n        address[] calldata tokens\\n    ) external returns (int256[] memory balanceChanges) {\\n        require(percentage >= 0 && percentage <= 100, \\\"Wrong percentage\\\");\\n        try this.simulateExitAndRevert(percentage, tokens) {} catch (\\n            bytes memory result\\n        ) {\\n            balanceChanges = abi.decode(result, (int256[]));\\n        }\\n    }\\n\\n    function simulateExitAndRevert(\\n        uint256 percentage,\\n        address[] calldata tokens\\n    ) external {\\n        int256[] memory balanceChanges = new int256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balanceChanges[i] = int256(\\n                IERC20(tokens[i]).balanceOf(address(this))\\n            );\\n        }\\n\\n        if (percentage == 0) percentage = 100;\\n        uint256 liquidity = (percentage * totalLiquidity()) / PERCENTAGE_BPS;\\n\\n        LOGIC.functionDelegateCall(abi.encodeCall(Logic.exit, (liquidity)));\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balanceChanges[i] =\\n                int256(IERC20(tokens[i]).balanceOf(address(this))) -\\n                balanceChanges[i];\\n        }\\n\\n        bytes memory returnData = abi.encode(balanceChanges);\\n        uint256 returnDataLength = returnData.length;\\n\\n        assembly {\\n            revert(add(returnData, 0x20), returnDataLength)\\n        }\\n    }\\n\\n    function simulateClaimRewards(\\n        address[] calldata rewardTokens\\n    ) external returns (int256[] memory balanceChanges) {\\n        try this.simulateClaimRewardsAndRevert(rewardTokens) {} catch (\\n            bytes memory result\\n        ) {\\n            balanceChanges = abi.decode(result, (int256[]));\\n        }\\n    }\\n\\n    function simulateClaimRewardsAndRevert(\\n        address[] calldata rewardTokens\\n    ) external {\\n        int256[] memory balanceChanges = new int256[](rewardTokens.length);\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\n            balanceChanges[i] = int256(\\n                IERC20(rewardTokens[i]).balanceOf(incentiveVault)\\n            );\\n        }\\n\\n        LOGIC.functionDelegateCall(\\n            abi.encodeCall(Logic.claimRewards, (incentiveVault))\\n        );\\n\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\n            balanceChanges[i] =\\n                int256(IERC20(rewardTokens[i]).balanceOf(incentiveVault)) -\\n                balanceChanges[i];\\n        }\\n\\n        bytes memory returnData = abi.encode(balanceChanges);\\n        uint256 returnDataLength = returnData.length;\\n        assembly {\\n            revert(add(returnData, 0x20), returnDataLength)\\n        }\\n    }\\n\\n    function totalLiquidity() public view returns (uint256) {\\n        return SelfManagedLogic(LOGIC).accountLiquidity(address(this));\\n    }\\n\\n    function getMinLiquidityDelta(uint256 slippage) external returns (uint256) {\\n        uint256 minLiquidityDelta = this.simulateEnter();\\n        return (minLiquidityDelta * slippage) / SLIPPAGE_BPS;\\n    }\\n\\n    function getMinTokensDeltas(\\n        uint256 percentage,\\n        uint256 slippage,\\n        address[] memory tokens\\n    ) external returns (IDefii.MinTokensDeltaInstruction memory) {\\n        int256[] memory balanceChanged = this.simulateExit(percentage, tokens);\\n        IDefii.MinTokensDeltaInstruction memory instruction;\\n        instruction.tokens = new address[](tokens.length);\\n        instruction.deltas = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            instruction.tokens[i] = tokens[i];\\n            instruction.deltas[i] =\\n                (balanceChanged[i].toUint256() * slippage) /\\n                SLIPPAGE_BPS;\\n        }\\n        return instruction;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/self-managed/SelfManagedLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SHIFT-1.0\\npragma solidity ^0.8.20;\\n\\nimport {Logic} from \\\"../defii/execution/Logic.sol\\\";\\nimport {IDefii} from \\\"../interfaces/IDefii.sol\\\";\\n\\nabstract contract SelfManagedLogic is Logic {\\n    error WrongBuildingBlockId(uint256);\\n\\n    function enterWithParams(bytes memory params) external payable virtual {\\n        revert NotImplemented();\\n    }\\n\\n    function emergencyExitPrivate() external payable virtual {\\n        revert NotImplemented();\\n    }\\n\\n    function exitBuildingBlock(\\n        uint256 buildingBlockId\\n    ) external payable virtual;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnterFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExitFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"SafeCastOverflowedIntToUint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract ISelfManagedFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOGIC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTAGE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLIPPAGE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"incentiveVault_\",\"type\":\"address\"}],\"name\":\"changeIncentiveVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExitPrivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLiquidityDelta\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLiquidityDelta\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"enterWithParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deltas\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IDefii.MinTokensDeltaInstruction\",\"name\":\"minTokensDelta\",\"type\":\"tuple\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buildingBlockId\",\"type\":\"uint256\"}],\"name\":\"exitBuildingBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"getMinLiquidityDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getMinTokensDeltas\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deltas\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IDefii.MinTokensDeltaInstruction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentiveVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveVault_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"runMultipleTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"runTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"}],\"name\":\"simulateClaimRewards\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"balanceChanges\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"}],\"name\":\"simulateClaimRewardsAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"simulateEnter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityChanged\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"simulateEnterAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"simulateEnterWithParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityChanged\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"simulateEnterWithParamsAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"simulateExit\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"balanceChanges\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"simulateExitAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SelfManagedDefii", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000001b487c719e3d8ab6eed780f452c9a5f73d921be1", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}