{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/token/ERC721/presets/ERC721Sovreign.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\r\\n|*               \u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557              *|\\r\\n|*               \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551              *|\\r\\n|*                \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551              *|\\r\\n|*                 \u255a\u2588\u2588\u2554\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551              *|\\r\\n|*                  \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551              *|\\r\\n|*                  \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d              *|\\r\\n|*----------------------------------------------------------*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nimport \\\"../../../access/AccessControl.sol\\\";\\r\\nimport \\\"../extensions/ERC721Enumerable.sol\\\";\\r\\nimport \\\"../extensions/ERC721Metadata_URI.sol\\\";\\r\\nimport \\\"../extensions/ERC721Burnable.sol\\\";\\r\\nimport \\\"../extensions/ERC721LazyMintableSovreign.sol\\\";\\r\\nimport \\\"../extensions/ERC721Royalties.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @title ERC721Sovreign                                     *\\r\\n *                                                           *\\r\\n * @notice Self-sovreign ERC-721 minter preset               *\\r\\n *                                                           *\\r\\n * @dev {ERC721} token                                       *\\r\\n *                                                           *\\r\\n * @custom:security-contact tech@ninfa.io                    *\\r\\n *\\r\\n */\\r\\n\\r\\ncontract ERC721Sovreign is\\r\\nAccessControl,\\r\\n    ERC721LazyMintableSovreign,\\r\\n    ERC721Burnable, \\r\\n    ERC721Royalties,\\r\\n    ERC721Metadata_URI,\\r\\n    ERC721Enumerable\\r\\n    \\r\\n    \\r\\n{\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # ACCESS CONTROL                                        *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @dev `MINTER_ROLE` is needed in case the deployer may want to use or\\r\\n     * allow other accounts to mint on their\\r\\n     * self-sovreign collection\\r\\n     */\\r\\n    bytes32 private constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; // keccak256(\\\"MINTER_ROLE\\\");\\r\\n    /**\\r\\n     * @dev constant set at deployment of master contract, replaces\\r\\n     * `initializer` modifier reducing the cost of calling\\r\\n     * `initialize` from the factory contract when a new clone is deployed.\\r\\n     */\\r\\n    address private immutable _FACTORY;\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # MINTING                                               *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @param _data bytes should be in the following format/order:\\r\\n     * `abi.encodePacked(bytes32 _tokenURI, address [] memory _royaltyRecipients, uint16[] memory _royaltyBps`\\r\\n     * @dev _tokenURI Replaces deprecated Openzeppelin contracts v4.0\\r\\n     * `ERC721Metadata_URI` extension\\r\\n     *      See\\r\\n     * https://forum.openzeppelin.com/t/why-doesnt-openzeppelin-erc721-contain-settokenuri/6373\\r\\n     * and\\r\\n     * https://forum.openzeppelin.com/t/function-settokenuri-in-erc721-is-gone-with-pragma-0-8-0/5978/2\\r\\n     * @dev when minted for the first time, royalty recipient MUST be set to\\r\\n     * msg.sender, i.e. minter/artist;\\r\\n     *      royalty receipient cannot and SHOULD not be set to an address\\r\\n     * different than the minter's such as a payment\\r\\n     * splitter or else `setRoyaltyRecipient` function will revert when called\\r\\n     * (unless receiver )\\r\\n     */\\r\\n    function mint(address _to,\\r\\n        bytes memory _data) external onlyRole(MINTER_ROLE) {\\r\\n        /*----------------------------------------------------------*|\\r\\n        |*  # MINT                                                  *|\\r\\n        |*----------------------------------------------------------*/\\r\\n\\r\\n        uint256 tokenId = _owners.length;\\r\\n        \\r\\n        _mint(_to, tokenId, _data);\\r\\n\\r\\n        /*----------------------------------------------------------*|\\r\\n        |*  # URI STORAGE                                           *|\\r\\n        |*----------------------------------------------------------*/\\r\\n\\r\\n        // if(_data.length > 32) {\\r\\n        //     (bytes32 tokenURI_, address[] memory royaltyRecipients, uint16[] memory royaltyBps) = abi.decode(_data, (bytes32, address[], uint16[]));\\r\\n        //     _setRoyaltyInfo(tokenId, royaltyBps, royaltyRecipients);\\r\\n        //     _setTokenURI(tokenId, tokenURI_);\\r\\n        // } else {\\r\\n        //     (bytes32 tokenURI_) = abi.decode(_data, (bytes32));\\r\\n        //     _setTokenURI(tokenId, tokenURI_);\\r\\n        // }\\r\\n        \\r\\n        // _royaltyInfo[tokenId].minter = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implements interface function {IERC721-mint}. Creates a new token\\r\\n     * for `msg.sender`. Its token ID will be\\r\\n     * automatically\\r\\n     *      assigned (and available on the emitted {IERC721-Transfer} event),\\r\\n     * and the token\\r\\n     *      URI autogenerated based on the base URI passed at construction.\\r\\n     * @dev it is assumed that the caller is the minter and thus the owner of\\r\\n     * the token,\\r\\n     *      therefore instead of calling the internal _transfer function, the\\r\\n     * tansfer logic has been reimplemented in\\r\\n     * this function\\r\\n     *      in order to avoid unnecessary `require` statements.\\r\\n     * @dev when minted for the first time, royalty recipient MUST be set to\\r\\n     * msg.sender, i.e. minter/artist;\\r\\n     *      royalty receipient MUST not be set to an address different than the\\r\\n     * minter's such as a payment splitter or\\r\\n     * else this function will revert\\r\\n     */\\r\\n    function mintAndTransfer(\\r\\n        address _to,\\r\\n        address [] memory _royaltyRecipients,\\r\\n        uint16[] memory _royaltyBps,\\r\\n        bytes calldata _data,\\r\\n        bytes32 _tokenURI\\r\\n    )\\r\\n        external\\r\\n        onlyRole(MINTER_ROLE)\\r\\n    {\\r\\n        /*----------------------------------------------------------*|\\r\\n        |*  # MINT                                                  *|\\r\\n        |*----------------------------------------------------------*/\\r\\n\\r\\n        uint256 tokenId = _owners.length;\\r\\n        _mintAndTransfer(msg.sender, _to, tokenId, _data);\\r\\n\\r\\n        /*----------------------------------------------------------*|\\r\\n        |*  # URI STORAGE                                           *|\\r\\n        |*----------------------------------------------------------*/\\r\\n\\r\\n        _setTokenURI(tokenId, _tokenURI);\\r\\n        _setRoyaltyInfo(tokenId, _royaltyBps, _royaltyRecipients);\\r\\n    }\\r\\n\\r\\n    function lazyMint(\\r\\n        Voucher memory _voucher,\\r\\n        bytes calldata _signature,\\r\\n        bytes calldata _data,\\r\\n        address _to\\r\\n    ) external payable{\\r\\n        uint256 tokenId = _owners.length;\\r\\n        address _signer = _lazyMint(_voucher, _signature, _data, _to, tokenId);\\r\\n        require(hasRole(MINTER_ROLE, _signer));\\r\\n        _setTokenURI(tokenId, _voucher.tokenURI);\\r\\n        _setRoyaltyInfo(tokenId, _voucher.royaltyBps, _voucher.royaltyRecipients);\\r\\n        _royaltyInfo[tokenId].minter = _signer;\\r\\n        _royaltyInfo[tokenId].secondary = true;\\r\\n    }\\r\\n\\r\\n    function lazyBuy(\\r\\n        Voucher memory _voucher,\\r\\n        bytes calldata _signature,\\r\\n        bytes calldata _data,\\r\\n        address _to\\r\\n    ) external payable{\\r\\n        uint16[] memory bps;\\r\\n        address[] memory recipients;\\r\\n\\r\\n        if(_royaltyInfo[_voucher.tokenId].secondary == true) {\\r\\n            if (_royaltyInfo[_voucher.tokenId].totalBps == 0) {\\r\\n                recipients = new address[](1);\\r\\n                bps = new uint16[](1);\\r\\n                recipients[0] = _royaltyInfo[_voucher.tokenId].minter;\\r\\n                bps[0] = DEFAULT_ROYALTY_BPS;\\r\\n            }\\r\\n            else{\\r\\n                recipients = _royaltyInfo[_voucher.tokenId].recipients;\\r\\n                bps = _royaltyInfo[_voucher.tokenId].bps;\\r\\n            }\\r\\n        }\\r\\n        else _royaltyInfo[_voucher.tokenId].secondary = true;\\r\\n        \\r\\n        _lazyBuy(_voucher, _signature, _data, _to, bps, recipients);\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # ROYALTY INFO SETTER                                   *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    function setRoyaltyInfo(\\r\\n        uint256 _tokenId,\\r\\n        uint16[] memory _royaltyBps,\\r\\n        address [] memory _royaltyRecipients\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(_royaltyInfo[_tokenId].minter == msg.sender);\\r\\n        _setRoyaltyInfo(_tokenId, _royaltyBps, _royaltyRecipients);\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # URI STORAGE                                           *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    function setBaseURI(string calldata baseURI_) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\\r\\n        _setBaseURI(baseURI_);\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # REQUIRED SOLIDITY OVERRIDES                           *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @param _data MUST be abi.encodePacked\\r\\n     */\\r\\n    function _mint(address _to, uint256 _id, bytes memory _data) internal override( ERC721Royalties, ERC721Metadata_URI, ERC721) {\\r\\n        // emit extension(\\\"sovreign _mint\\\");\\r\\n        // emit mintData(_data);\\r\\n        super._mint(_to, _id, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *\\r\\n     * @param _tokenId token ID to burn\\r\\n     * @dev overrides _burn function of base contract and all extensions\\r\\n     * @dev deletes royalty info from storage\\r\\n     */\\r\\n    function _burn(uint256 _tokenId) internal override( ERC721Royalties, ERC721Metadata_URI, ERC721) {\\r\\n        _deleteRoyaltyInfo(_tokenId);\\r\\n        super._burn(_tokenId);\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # VIEW FUNCTIONS                                        *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @dev same function interface as erc1155, so that external contracts, i.e.\\r\\n     * the marketplace, can check either erc\\r\\n     * without requiring an if/else statement\\r\\n     */\\r\\n    function exists(uint256 _id) external view returns (bool) {\\r\\n        return _owners[_id] != ZERO_ADDRESS;\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # ERC-165                                               *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     * `supportsInterface()` was first implemented by all contracts and later\\r\\n     * all implementations removed, hardcoding\\r\\n     * interface IDs in order to save some gas and simplify the code.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\r\\n        return interfaceId == 0x80ac58cd // type(IERC721).interfaceId\\r\\n            || interfaceId == 0x780e9d63 // type(IERC721Enumerable).interfaceId\\r\\n            || interfaceId == 0x5b5e139f // type(IERC721Metadata).interfaceId\\r\\n            || interfaceId == 0x01ffc9a7 // type(IERC165).interfaceId\\r\\n            || interfaceId == 0x2a55205a // type(IERC2981).interfaceId\\r\\n            || interfaceId == 0x7965db0b; // type(IAccessControl).interfaceId;\\r\\n    }\\r\\n\\r\\n    /*----------------------------------------------------------*|\\r\\n    |*  # INITIALIZATION                                        *|\\r\\n    |*----------------------------------------------------------*/\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the account that\\r\\n     * deploys the contract.\\r\\n     *      `MINTER_ROLE` is needed in case the deployer may want to use or\\r\\n     * allow other accounts to mint on their\\r\\n     * self-sovreign collection\\r\\n     */\\r\\n    function initialize(bytes calldata _data) external {\\r\\n        require(msg.sender == _FACTORY);\\r\\n\\r\\n        address owner;\\r\\n        string memory _eip712DomainName;\\r\\n        (name, symbol, _eip712DomainName, owner) = abi.decode(_data, (string, string, string, address ));\\r\\n\\r\\n        // setRoyaltyInfo(royaltyRecipient, royaltyBps);\\r\\n\\r\\n        _grantRole(DEFAULT_ADMIN_ROLE, owner); // DEFAULT_ADMIN_ROLE is by\\r\\n            // default admin of all other roles, i.e.\\r\\n            // MINTER_ROLE, meaning it can assign MINTER_ROLE to other addresses\\r\\n            // _grantRole(MINTER_ROLE, msg.sender); //\\r\\n            // grant MINTER_ROLE to factory contract\\r\\n        _grantRole(MINTER_ROLE, owner); // grant MINTER_ROLE to owner, this way\\r\\n            // minting requires only checking for\\r\\n            // MINTER_ROLE rather than DEFAULT_ADMIN_ROLE, allowing the\\r\\n            // deployer/admin to grant MINTER_ROLE to other\\r\\n            // addresses.\\r\\n        \\r\\n        DOMAIN_SEPARATOR = keccak256(\\r\\n            abi.encode(\\r\\n                DOMAIN_TYPEHASH,\\r\\n                keccak256(bytes(_eip712DomainName)), // name\\r\\n                block.chainid, // chainId\\r\\n                address(this) // verifyingContract\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    constructor(address factory_){\\r\\n        _FACTORY = factory_;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow\\n * enumerating role\\n * members except through off-chain means by accessing the contract event logs.\\n * Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role,\\n     * replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 role, bytes32 previousAdminRole, bytes32 newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 role, address account, address sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 role, address account, address sender);\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular\\n     * expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role\\n     * (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular\\n     * expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role\\n     * (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\\"Account is missing role\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external {\\n        require(account == msg.sender); // \\\"AccessControl: can only renounce\\n            // roles for self\\\"\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*----------------------------------------------------------*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../ERC721.sol\\\";\\n\\n/**\\n *\\n * @title ERC721Enumerable                                   *\\n *                                                           *\\n * @dev This implements an optional extension of {ERC721}    *\\n *      defined in the EIP that adds enumerability of all    *\\n *      the token ids in the contract as well as all token   *\\n *      ids owned by each account.                           *\\n *                                                           *\\n * @custom:security-contact tech@ninfa.io                    *\\n *\\n */\\nabstract contract ERC721Enumerable is ERC721 {\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\\n        require(_owner == ownerOf(_index));\\n        return _index;\\n    }\\n\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one\\n    /// of\\n    ///  them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256) {\\n        return _owners.length;\\n    }\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    ///  (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\\n        require(_exists(_index));\\n        return _index;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/extensions/ERC721Metadata_URI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0)\\n// (token/ERC721/extensions/ERC721Metadata_URI.sol)\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"../../common/DecodeTokenURI.sol\\\";\\n\\n/**\\n * @dev ERC721 token with storage based token URI management.\\n */\\nabstract contract ERC721Metadata_URI is ERC721 {\\n\\n\\n    using DecodeTokenURI for bytes;\\n\\n    // Token name\\n    string public name;\\n\\n    // Token symbol\\n    string public symbol;\\n\\n    /**\\n     * @dev Hardcoded base URI in order to remove the need for a constructor, it\\n     * can be set anytime by an admin\\n     * (multisig).\\n     */\\n    string private _baseTokenURI = \\\"ipfs://\\\";\\n\\n    /**\\n     * @dev Optional mapping for token URIs\\n     */\\n    mapping(uint256 => bytes32) private _tokenURIs;\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}. It needs to be overridden because\\n     * the new OZ contracts concatenate _baseURI\\n     * + tokenId instead of _baseURI + _tokenURI\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId));\\n\\n        return string( // once hex encoded base58 is converted to string, we get\\n            // the initial IPFS hash\\n            abi.encodePacked(\\n                _baseTokenURI,\\n                abi.encodePacked(bytes2(0x1220), _tokenURIs[tokenId]) // full\\n                    // bytes of base58 + hex encoded IPFS hash\\n                    // example.\\n                    // prepending 2 bytes IPFS hash identifier that was removed\\n                    // before storing the hash in order to\\n                    // fit in bytes32. 0x1220 is \\\"Qm\\\" base58 and hex encoded\\n                    // tokenURI (IPFS hash) with its first 2 bytes truncated,\\n                    // base58 and hex encoded returned as\\n                    // bytes32\\n                    .toBase58()\\n            )\\n        );\\n    }\\n\\n    function _mint(address _to, uint256 _tokenId, bytes memory _data) internal virtual override {\\n\\n        (bytes32 tokenUriData, bytes memory remainingData) = abi.decode(_data, (bytes32, bytes));\\n    \\n        _setTokenURI(_tokenId, tokenUriData);\\n        \\n        super._mint(_to, _tokenId, remainingData);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     * @dev only called when a new token is minted, therefore\\n     * `require(_exists(tokenId))` check was removed\\n     * Since Openzeppelin contracts v4.0 the _setTokenURI() function was\\n     * removed, instead we must append the tokenID\\n     * directly to this variable returned by _baseURI() internal function.\\n     * This contract implements all the required functionality from\\n     * ERC721Metadata_URI, which is the OpenZeppelin\\n     * extension for supporting _setTokenURI.\\n     * See\\n     * https://forum.openzeppelin.com/t/why-doesnt-openzeppelin-erc721-contain-settokenuri/6373\\n     * and\\n     * https://forum.openzeppelin.com/t/function-settokenuri-in-erc721-is-gone-with-pragma-0-8-0/5978/2\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, bytes32 _tokenURI) internal {\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @notice Optional function to set the base URI\\n     * @dev child contract MAY require access control to the external function\\n     * implementation\\n     */\\n    function _setBaseURI(string calldata baseURI_) internal {\\n        // require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\\n        _baseTokenURI = baseURI_;\\n    }\\n\\n    \\n\\n    /**\\n     * @dev See {ERC721-_burn}.\\n     */\\n    function _burn(uint256 _tokenId) internal virtual override {\\n        super._burn(_tokenId);\\n\\n        delete _tokenURIs[_tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/extensions/ERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"../ERC721.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be burned (destroyed).\\n */\\nabstract contract ERC721Burnable is ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 _tokenId) external {\\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\\n        _burn(_tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/extensions/ERC721LazyMintableSovreign.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*----------------------------------------------------------*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../ERC721.sol\\\";\\n\\n/// @custom:security-contact tech@ninfa.io\\nabstract contract ERC721LazyMintableSovreign is ERC721 {\\n    /*----------------------------------------------------------*|\\n    |*  # EIP-712                                               *|\\n    |*----------------------------------------------------------*/\\n\\n    /**\\n     * @param endTime timestamp for when the signed voucher should expire,\\n     *      if no expiration is needed, timestamp should be `type(uint256).max`\\n     * i.e. 2**256 - 1,\\n     *      or anything above 2^32, i.e. 4294967296, i.e. voucher expires after\\n     * 2106 (in 83 years time)\\n     * @param tokenId the tokenId will be ignored in lazyMint, because it will be _owners.length\\n     * while it must beused in lazyBuy\\n     * @param royaltyBps royalty basis points. Will be ignored in lazyBuy, while it must be used in lazyMint\\n     * @param royaltyRecipients royalty recipient. Will be ignored in lazyBuy, while it must be used in lazyMint\\n     */\\n    struct Voucher {\\n        bytes32 tokenURI;\\n        uint256 price;\\n        uint256 endTime;\\n        uint256 tokenId;\\n        uint256 salt;\\n        address buyerAddress;\\n        uint16[] royaltyBps;\\n        uint16[] commissionBps;\\n        address[] royaltyRecipients;\\n        address[] commissionRecipients;\\n    }\\n\\n    bytes32 internal DOMAIN_SEPARATOR;\\n    bytes32 internal immutable DOMAIN_TYPEHASH;\\n    bytes32 private immutable VOUCHER_TYPEHASH;\\n\\n    /*----------------------------------------------------------*|\\n    |*  # LAZY MINTING                                          *|\\n    |*----------------------------------------------------------*/\\n\\n    mapping(bytes32 => bool) private _mintedURIs;\\n\\n    mapping(bytes => bool) private _invalidSignatures;\\n\\n    event SignaturesInvalidated(bytes[] signatures);\\n\\n    /**\\n     * @dev invalidates signatures\\n     * in case of lazy mint: must be used in case the signer raises the price, edits the split or cancels the voucher\\n     * in case of lazy buy: must be used in any case the signer wants to modify the voucher, except burn, because\\n     * no one can be the owner of the token anymore.\\n     */\\n    function invalidateSignatures(Voucher[] memory _vouchers, bytes[] calldata _signatures) external {\\n        uint256 i;\\n        uint256 length = _signatures.length;\\n        do {\\n            address _signer = _recover(_vouchers[i], _signatures[i]);\\n            require(msg.sender == _signer);\\n            _invalidSignatures[_signatures[i]] = true;\\n            i++;\\n        } while (i < length);\\n        emit SignaturesInvalidated(_signatures);\\n    }\\n\\n    /**\\n     * @param _to buyer, needed if using a external payment gateway, so that the\\n     * minted tokenId value is sent to the\\n     * address specified insead of `msg.sender`\\n     * @param _data data bytes are passed to `onErc721Received` function if the\\n     * `_to` address is a contract, for\\n     * example a marketplace.\\n     *      `onErc721Received` is not being called on the minter's address when\\n     * a new tokenId is minted however, even\\n     * if it was contract.\\n     * @dev Creates a new token for `msg.sender`. Its token ID will be\\n     * automatically\\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the\\n     * token\\n     * URI autogenerated based on the base URI passed at construction.\\n     * See {ERC721-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the voucher signer must have the `MINTER_ROLE` role.\\n     * - access control must be set in derived contracts, e.g.\\n     * `require(hasRole(MINTER_ROLE, signer)`\\n     * - extensions must be overridden in derived contract\\n     */\\n    function _lazyMint(\\n        Voucher memory _voucher,\\n        bytes calldata _signature,\\n        bytes calldata _data,\\n        address _to,\\n        uint256 _tokenId\\n    )\\n        internal\\n        returns (address _signer)\\n    {\\n        uint256 _sellerAmount = msg.value;\\n        require(\\n            // prevents more than 1 tokenId with the same URI to be minted\\n            !_mintedURIs[_voucher.tokenURI] &&\\n            // allows to set an expiration date for the voucher\\n            _voucher.endTime >= block.timestamp &&\\n            // prevents invalid signatures to be used\\n            !_invalidSignatures[_signature] &&\\n            // make sure the buyer is not paying the wrong price\\n            _sellerAmount == _voucher.price\\n        );\\n\\n        if(_voucher.buyerAddress != address(0)){\\n            require(_voucher.buyerAddress == _to);\\n        }\\n\\n        /**\\n         * @dev no need to invalidate the signature. All the signatures signed before will be automatically\\n         * invalidated because they all contain the same tokenURI, which is now minted.\\n         */\\n\\n        /*----------------------------------------------------------*|\\n        |*  # EIP-712 TYPED DATA SIGNATURE VERIFICATION             *|\\n        |*----------------------------------------------------------*/\\n\\n        _signer = _recover(_voucher, _signature);\\n\\n        \\n\\n        /*----------------------------------------------------------*|\\n        |*  # PAY COMMISSIONS (if any)                              *|\\n        |*----------------------------------------------------------*/\\n\\n        uint256 recipientsLength = _voucher.commissionRecipients.length;\\n        if (recipientsLength > 0) {         \\n            // pays all the recipients\\n            uint256 i;\\n            uint256 receiverAmount;\\n            do{\\n                receiverAmount = (_voucher.price * _voucher.commissionBps[i]) / 10_000;\\n                _sellerAmount -= receiverAmount;\\n                _sendValue(_voucher.commissionRecipients[i], receiverAmount);\\n                i++;\\n            } while (i < recipientsLength);\\n        }\\n       \\n\\n        /*----------------------------------------------------------*|\\n        |*  # PAY SELLER                                            *|\\n        |*----------------------------------------------------------*/\\n\\n        _sendValue(_signer, _sellerAmount);\\n\\n        /*----------------------------------------------------------*|\\n        |*  # MINT & TRANSFER                                       *|\\n        |*----------------------------------------------------------*/\\n\\n        _mintAndTransfer(_signer, _to, _tokenId, _data);\\n\\n        _mintedURIs[_voucher.tokenURI] = true;\\n    }\\n\\n    function _lazyBuy(\\n        Voucher memory _voucher,\\n        bytes calldata _signature,\\n        bytes calldata _data,\\n        address _to,\\n        uint16[] memory _royaltyBps,\\n        address [] memory _royaltyRecipients\\n    ) \\n        internal\\n    {\\n        uint256 _sellerAmount = msg.value;\\n        require(\\n            // allows to set an expiration date for the voucher\\n            _voucher.endTime >= block.timestamp &&\\n            // prevents invalid signatures to be used\\n            !_invalidSignatures[_signature] &&\\n            // make sure the buyer is not paying the wrong price\\n            _sellerAmount == _voucher.price\\n        );\\n\\n        if(_voucher.buyerAddress != address(0)){\\n            require(_voucher.buyerAddress == _to);\\n        }\\n\\n        /**\\n         * @dev here the signatue must be invalidated. Otherwise, if the token is transferred back to the seller\\n         * all valid signatures would be still valid\\n         */\\n        _invalidSignatures[_signature] = true;\\n\\n        address _signer = _recover(_voucher, _signature);\\n\\n        require(_signer == _owners[_voucher.tokenId]);\\n\\n        uint256 recipientsLength = _voucher.commissionRecipients.length;\\n        if (recipientsLength > 0) {\\n            // pays all the recipients\\n            uint256 i;\\n            uint256 receiverAmount;\\n            do{\\n                receiverAmount = (_voucher.price * _voucher.commissionBps[i]) / 10_000;\\n                _sellerAmount -= receiverAmount;\\n                _sendValue(_voucher.commissionRecipients[i], receiverAmount);\\n                i++;\\n            } while (i < recipientsLength);\\n        }\\n\\n        if(_royaltyBps.length > 0) {\\n             for (uint256 i; i < _royaltyBps.length; i++) {\\n                uint256 royaltyAmount = (_voucher.price * _royaltyBps[i]) / 10_000;\\n                _sellerAmount -= royaltyAmount;\\n                _sendValue(_royaltyRecipients[i], royaltyAmount);\\n            }\\n        }\\n\\n        _sendValue(_signer, _sellerAmount);\\n\\n        _safeTransfer(_signer, _to, _voucher.tokenId, _data);\\n    }\\n\\n    function _recover(Voucher memory _voucher, bytes memory _signature) private view returns (address _signer) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        VOUCHER_TYPEHASH, \\n                        _voucher.tokenURI,\\n                        _voucher.price,\\n                        _voucher.endTime,\\n                        _voucher.tokenId,\\n                        _voucher.salt,\\n                        _voucher.buyerAddress,\\n                        keccak256(abi.encodePacked(_voucher.royaltyBps)),\\n                        keccak256(abi.encodePacked(_voucher.commissionBps)),\\n                        keccak256(abi.encodePacked(_voucher.royaltyRecipients)),\\n                        keccak256(abi.encodePacked(_voucher.commissionRecipients))\\n                    )\\n                )\\n            )\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(_signature, 0x20))\\n            s := mload(add(_signature, 0x40))\\n            v := byte(0, mload(add(_signature, 0x60)))\\n        }\\n\\n        _signer = ecrecover(digest, v, r, s);\\n        if (_signer == ZERO_ADDRESS) revert();\\n    }\\n\\n    function _sendValue(address _receiver, uint256 _amount) internal {\\n        (bool success,) = payable(_receiver).call{ value: _amount }(\\\"\\\");\\n        require(success);\\n    }\\n\\n    /**\\n     * @notice creates `DOMAIN_SEPARATOR`,\\n     *      Grants `DEFAULT_ADMIN_ROLE` to the account that deploys the\\n     * contract,\\n     *      assigns `CURATOR_ROLE` as the admin role for `MINTER_ROLE`,\\n     */\\n    constructor() {\\n        DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n        VOUCHER_TYPEHASH = keccak256(\\n            \\\"Voucher(bytes32 tokenURI,uint256 price,uint256 endTime,uint256 tokenId,uint256 salt,address buyerAddress,uint16[] royaltyBps,uint16[] commissionBps,address[] royaltyRecipients,address[] commissionRecipients)\\\"\\n        );\\n        /**\\n         * @dev The EIP712Domain fields should be the order as above, skipping\\n         * any absent fields.\\n         *      Protocol designers only need to include the fields that make\\n         * sense for their signing domain. Unused\\n         * fields are left out of the struct type.\\n         * @param name the user readable name of signing domain, i.e. the name\\n         * of the DApp or the protocol.\\n         * @param chainId the EIP-155 chain id. The user-agent should refuse\\n         * signing if it does not match the currently\\n         * active chain.\\n         * @param verifyingContract the address of the contract that will verify\\n         * the signature. The user-agent may do\\n         * contract specific phishing prevention.\\n         *      verifyingContract is the only variable parameter in the\\n         * DOMAIN_SEPARATOR in order to avoid signature\\n         * replay across different contracts\\n         *      therefore the DOMAIN_SEPARATOR MUST be calculated inside of the\\n         * `initialize` function rather than the\\n         * constructor.\\n         */\\n        \\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/extensions/ERC721Royalties.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*----------------------------------------------------------*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"../../common/ERC2981.sol\\\";\\n\\n/**\\n * @dev Extension of ERC721 with the ERC2981 NFT Royalty Standard, a\\n * standardized way to retrieve royalty payment\\n * information.\\n */\\nabstract contract ERC721Royalties is ERC2981, ERC721 {\\n\\n\\n    /**\\n     * @dev See {ERC721-_burn}. This override additionally clears the royalty\\n     * information for the token.\\n     */\\n    function _burn(uint256 tokenId) internal virtual override {\\n        _deleteRoyaltyInfo(tokenId);\\n        super._burn(tokenId);\\n    }\\n\\n    function _mint(address _to, uint256 _id, bytes memory _data) internal virtual override {\\n\\n        \\n        (address[] memory royaltyRecipients, \\n        uint16[] memory royaltyBps, \\n        bytes memory data) = abi.decode(_data, (address[], uint16[], bytes));\\n\\n        if (royaltyRecipients.length > 0) {\\n            _setRoyaltyInfo(_id, royaltyBps, royaltyRecipients);\\n            _royaltyInfo[_id].minter = _to;\\n        }\\n        \\n        super._mint(_to, _id, data);\\n}\\n\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721]\\n * Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is\\n * available separately as\\n * {ERC721Enumerable}.\\n * @dev removed constructor in order to allow name and symbol to be set by\\n * facory clones contracts via the `initialize`\\n * function instead.\\n *      name and symbol should be set in most derived contract's constructor\\n * instead\\n */\\ncontract ERC721 {\\n\\n    // event extension(string message);\\n    // event mintData(bytes data);\\n    //  event mintURI(bytes32 uri);\\n    //  event addressArray(address[] array);\\n    //  event uintArray(uint16[] array);\\n    //  event number(uint256 number);\\n    // array of token owners, accessed in {NinfaERC721-totalSupply}\\n    address[] internal _owners;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // util to save on gas in various functions\\n    address internal constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId`\\n     * token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to\\n     * manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function ownerOf(uint256 tokenId) public view returns (address _owner) {\\n        _owner = _owners[tokenId];\\n        if (_owner == ZERO_ADDRESS) revert();\\n    }\\n\\n    function approve(address to, uint256 tokenId) external {\\n        address owner = ownerOf(tokenId);\\n\\n        require(msg.sender == owner || _operatorApprovals[owner][msg.sender]);\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) external view returns (address) {\\n        require(_exists(tokenId));\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(msg.sender, tokenId));\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\\n        _safeTransfer(_from, _to, _tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first\\n     * that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever\\n     * locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in\\n     * call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be\\n     * used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as\\n     * signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon\\n     * a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal {\\n        _transfer(_from, _to, _tokenId);\\n        _requireOnERC721Received(_from, _to, _tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     *      The approval is cleared when the token is burned.\\n     *      This is an internal function that does not check if the sender is\\n     * authorized to operate on the token.\\n     *      Emits a {Transfer} event.\\n     * @param _tokenId MUST exist.\\n     */\\n    function _burn(uint256 _tokenId) internal virtual {\\n        // Clear approvals\\n        delete _tokenApprovals[_tokenId];\\n\\n        delete _owners[_tokenId]; // equivalent to Openzeppelin's\\n            // `_balances[owner] -= 1`\\n\\n        emit Transfer(msg.sender, ZERO_ADDRESS, _tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve}\\n     * or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _owners[tokenId] != ZERO_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId));\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || _tokenApprovals[tokenId] == spender || _operatorApprovals[owner][spender]);\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`. Doesn't support safe\\n     * transfers while minting, i.e. doesn't call\\n     * onErc721Received function because when minting the receiver is\\n     * msg.sender.\\n     * We don\u2019t need to zero address check because msg.sender is never the\\n     * zero address.\\n     * Because the tokenId is always incremented, we don\u2019t need to check if\\n     * the token exists already.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n\\n        // emit extension(\\\"ERC721 _mint\\\");\\n        // emit mintData(_data);\\n\\n        _owners.push(_to);\\n\\n        emit Transfer(ZERO_ADDRESS, _to, _tokenId);\\n\\n        _requireOnERC721Received(address(0), _to, _tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev rather than calling the internal `_mint` function which would create\\n     * a new owner like so\\n     * `_owners.push(_to)`,\\n     *      however ownership will be reassigned/overridden with the buyer's\\n     * address by the time the `lazyMint` function\\n     * has finished executing\\n     *      therefore the `transfer` event is emitted in order to signal to\\n     * DApps that a mint has occurred\\n     */\\n    function _mintAndTransfer(address _minter, address _to, uint256 _tokenId, bytes calldata _data) internal {\\n        if (_to == ZERO_ADDRESS) revert();\\n        /*----------------------------------------------------------*|\\n        |*  # MINT                                                  *|\\n        |*----------------------------------------------------------*/\\n\\n        emit Transfer(ZERO_ADDRESS, _minter, _tokenId);\\n\\n        /*----------------------------------------------------------*|\\n        |*  # SAFE TRANSFER                                         *|\\n        |*----------------------------------------------------------*/\\n\\n        _owners.push(_to);\\n\\n        emit Transfer(_minter, _to, _tokenId);\\n\\n        _requireOnERC721Received(_minter, _to, _tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on\\n     * msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\\n        require(ownerOf(_tokenId) == _from);\\n        if (_to == ZERO_ADDRESS) revert();\\n\\n        // Clear approvals _from the previous owner\\n        _approve(ZERO_ADDRESS, _tokenId);\\n\\n        _owners[_tokenId] = _to;\\n\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 _tokenId) private {\\n        _tokenApprovals[_tokenId] = to;\\n        emit Approval(ownerOf(_tokenId), to, _tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address _owner, address _operator, bool _approved) private {\\n        if (_owner == _operator) revert();\\n        _operatorApprovals[_owner][_operator] = _approved;\\n        emit ApprovalForAll(_owner, _operator, _approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a\\n     * target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param _to target address that will receive the tokens\\n     * @param _from address representing the previous owner of the given token\\n     * ID\\n     * @param _tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     */\\n    function _requireOnERC721Received(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    )\\n        private\\n    {\\n\\n        require(\\n            _to.code.length == 0 ||\\n                IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) ==\\n                0x150b7a02 /* IERC721Receiver.onERC721Received.selector */\\n        ); \\n    }\\n\\n    /**\\n     * @dev WARNING this function SHOULD only be called by frontends due to\\n     * unbound loop\\n     * @dev public visibility as it is needed by\\n     */\\n    function balanceOf(address _owner) external view returns (uint256) {\\n        if (_owner == ZERO_ADDRESS) revert();\\n        uint256 count = 0;\\n        uint256 totalSupply = _owners.length;\\n        for (uint256 i; i < totalSupply; i++) {\\n            if (_owner == _owners[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/common/DecodeTokenURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\n/// @dev stripped down version of https://github.com/MrChico/verifyIPFS/\\nlibrary DecodeTokenURI {\\n    bytes constant ALPHABET = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\n\\n    /**\\n     * @dev Converts hex string to base 58\\n     */\\n    function toBase58(bytes memory source) internal pure returns (bytes memory) {\\n        if (source.length == 0) return new bytes(0);\\n        uint8[] memory digits = new uint8[](64);\\n        digits[0] = 0;\\n        uint8 digitlength = 1;\\n        for (uint256 i = 0; i < source.length; ++i) {\\n            uint256 carry = uint8(source[i]);\\n            for (uint256 j = 0; j < digitlength; ++j) {\\n                carry += uint256(digits[j]) * 256;\\n                digits[j] = uint8(carry % 58);\\n                carry = carry / 58;\\n            }\\n\\n            while (carry > 0) {\\n                digits[digitlength] = uint8(carry % 58);\\n                digitlength++;\\n                carry = carry / 58;\\n            }\\n        }\\n        return toAlphabet(reverse(truncate(digits, digitlength)));\\n    }\\n\\n    function toAlphabet(uint8[] memory indices) private pure returns (bytes memory) {\\n        bytes memory output = new bytes(indices.length);\\n        for (uint256 i = 0; i < indices.length; i++) {\\n            output[i] = ALPHABET[indices[i]];\\n        }\\n        return output;\\n    }\\n\\n    function truncate(uint8[] memory array, uint8 length) private pure returns (uint8[] memory) {\\n        uint8[] memory output = new uint8[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            output[i] = array[i];\\n        }\\n        return output;\\n    }\\n\\n    function reverse(uint8[] memory input) private pure returns (uint8[] memory) {\\n        uint8[] memory output = new uint8[](input.length);\\n        for (uint256 i = 0; i < input.length; i++) {\\n            output[i] = input[input.length - 1 - i];\\n        }\\n        return output;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/token/common/ERC2981.sol\": {\r\n      \"content\": \"/*----------------------------------------------------------*|\\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\\n|*----------------------------------------------------------*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/**\\n *\\n * @title ERC2981NSovreign                                   *\\n *                                                           *\\n * @notice adds ERC2981 support to ERC-721.                  *\\n *                                                           *\\n * @dev Royalties BPS and recipient are token level        *\\n * and may be set by owner in child contract by writing      *\\n * directly to internal storage variables                    *\\n *                                                           *\\n * @dev Royalty information can be specified globally for    *\\n * all token ids via {ERC2981-_setDefaultRoyalty}, and/or    *\\n * individually for specific token ids via                   *\\n * {ERC2981-_setTokenRoyalty}. The latter takes precedence.  *\\n *                                                           *\\n * @custom:security-contact tech@ninfa.io                    *\\n *\\n */\\n\\n\\ncontract ERC2981 {\\n    uint16 private constant TOTAL_SHARES = 10_000;\\n    uint16 internal constant DEFAULT_ROYALTY_BPS = 1_000;\\n    \\n    mapping(uint256 => RoyaltyInfo) internal _royaltyInfo;\\n\\n    /**\\n     * @dev `bps`; \\\"For precision purposes, it's better to express the royalty\\n     * percentage as \\\"basis points\\\" (points per\\n     * 10_000, e.g., 10% = 1000 bps) and compute the amount is\\n     * `(royaltyBps[_tokenId] * _salePrice) / 10000`\\\" -\\n     * https://forum.openzeppelin.com/t/setting-erc2981/16065/2\\n     * @dev minter is only set if different from deployer account in order to save gas, if inherited by a sovreign contract,\\n     * for communal contracts, minter must be always set when minting\\n     * > \\\"If you plan on having a contract where NFTs are created by\\n     * multiple authors\\n     *      AND they can update royalty details after minting, you will need to\\n     * record the original author of each\\n     * token.\\\" - https://forum.openzeppelin.com/t/setting-\\n     * /16065/2\\n     *      i.e. the original artist's address if different from the royalty\\n     * recipient's address, MUST be stored in\\n     * order to be used for access control on setter functions\\n     \\n     */\\n    struct RoyaltyInfo {\\n        address minter;\\n        address[] recipients;\\n        uint16[] bps;\\n        uint16 totalBps;\\n        bool secondary;\\n    }\\n\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _value\\n    )\\n        external view\\n        returns (address recipient, uint256 value) {\\n\\n            if (_royaltyInfo[_tokenId].totalBps == 0) {\\n                recipient = _royaltyInfo[_tokenId].minter;\\n                value = uint256(DEFAULT_ROYALTY_BPS * _value / TOTAL_SHARES);\\n            }\\n            else{\\n                recipient = _royaltyInfo[_tokenId].minter;\\n                value = uint256(_royaltyInfo[_tokenId].totalBps * _value / TOTAL_SHARES);\\n            }\\n        }\\n    \\n    // /**\\n    //  * @notice Called with the sale price to determine how much royalty\\n    //  *          is owed and to whom.\\n    //  * @param _tokenId - the NFT asset queried for royalty information\\n    //  * @param _value - the sale price of the NFT asset specified by _tokenId\\n    //  * @return recipients - address of who should be sent the royalty payment\\n    //  * @return bps - the royalty payment bps shares.\\n     \\n    //  */\\n    function getNinfaRoyaltyInfo(\\n        uint256 _tokenId\\n    )\\n        external\\n        returns (address [] memory recipients, uint16[] memory bps) {\\n            /// @dev \\\"Marketplaces that support this standard SHOULD NOT send a zero-value transaction if the royaltyAmount returned is 0\\\" - https://eips.ethereum.org/EIPS/eip-2981\\n            /* if (_royaltyInfo[_tokenId].bps.length > 0)  {\\n                recipients = _royaltyInfo[_tokenId].recipients;\\n                royaltyAmount = (_value * _royaltyInfo[_tokenId].bps) / TOTAL_SHARES;\\n            } else if (msg.sender.code.length > 0) {\\n                \\n                _royaltyInfo[_tokenId].recipient = (_royaltyInfo[_tokenId].minter);\\n                _royaltyInfo[_tokenId].bps[0] = DEFAULT_ROYALTY_BPS;\\n            }  */  \\n            require(msg.sender.code.length > 0, \\\"Invalid call\\\");  \\n\\n            if(_royaltyInfo[_tokenId].secondary == false)\\n              _royaltyInfo[_tokenId].secondary = true;\\n            else{\\n                if (_royaltyInfo[_tokenId].totalBps == 0) {\\n                    recipients = new address[](1);\\n                    bps = new uint16[](1);\\n                    recipients[0] = _royaltyInfo[_tokenId].minter;\\n                    bps[0] = DEFAULT_ROYALTY_BPS;\\n                }\\n                else{\\n                    recipients = _royaltyInfo[_tokenId].recipients;\\n                    bps = _royaltyInfo[_tokenId].bps;\\n                }\\n            }\\n            \\n        }\\n        \\n    function getRoyalties(uint256 tokenId) external view returns (address [] memory, uint256[] memory) {\\n         if(_royaltyInfo[tokenId].minter == address(0)) revert();\\n         return _getRoyalties(tokenId);\\n    }\\n\\n    function _getRoyalties(uint256 tokenId) view internal returns (address [] memory _royaltyRecipients, uint256[] memory _bps) {\\n        // Get token level royalties\\n        RoyaltyInfo memory tokenRoyaltyInfo = _royaltyInfo[tokenId];\\n        uint256 arraysLength = tokenRoyaltyInfo.recipients.length;\\n\\n        if (arraysLength == 0) {\\n            _royaltyRecipients = new address[](1);\\n            _bps = new uint256[](1);\\n            _royaltyRecipients[0] = _royaltyInfo[tokenId].minter;\\n            _bps[0] = uint256(DEFAULT_ROYALTY_BPS);\\n        } else {\\n            _royaltyRecipients = tokenRoyaltyInfo.recipients;\\n\\n            _bps = new uint256[](arraysLength);\\n            \\n            for (uint i = 0; i < arraysLength; i++) {\\n                _bps[i] = uint256(tokenRoyaltyInfo.bps[i]);\\n            }\\n        }\\n    }\\n    \\n    \\n    /**\\n     * @notice Called with the sale price to determine how much royalty\\n     *          is owed and to whom.\\n     * An artist may decide to set the royalty recipient to an address other than its own;\\n     * it adds the artist address to the `_minters` mapping, in order to use it for access control\\n     * by the derived contract. This removes the burden of setting this\\n     * mapping in the `mint()` function as it will\\n     * rarely be needed.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _royaltyBps - The actual royalty bps, calculated on the total sale amount\\n     */\\n    function _setRoyaltyInfo(uint256 _tokenId, uint16[] memory _royaltyBps, address [] memory _royaltyRecipients) internal {\\n        uint256 bpsLength = _royaltyBps.length;\\n        /// @dev bpsLength must be > 0 because of the unchecked block below; if it were == 0, bpsLength would underflow to 2**256 - 1 and the loop would run forever.\\n        require(bpsLength == _royaltyRecipients.length);\\n        uint16 royaltyBps;\\n\\n        if(bpsLength > 0){\\n            do {\\n                unchecked {\\n                    --bpsLength;\\n                }\\n                royaltyBps += _royaltyBps[bpsLength];\\n            } while (bpsLength > 0);\\n            require(royaltyBps < TOTAL_SHARES);\\n        }\\n\\n        _royaltyInfo[_tokenId].recipients = _royaltyRecipients;\\n        _royaltyInfo[_tokenId].bps = _royaltyBps;\\n        _royaltyInfo[_tokenId].totalBps = royaltyBps;\\n    }\\n\\n    function _deleteRoyaltyInfo(uint256 _tokenId) internal {\\n        delete _royaltyInfo[_tokenId];\\n    }\\n\\n    \\n\\n    \\n\\n \\n\\n    // /**\\n    //  * @dev Set royalties of an extension\\n    //  */\\n    // function getRoyalties(uint256 tokenId) external view returns (address [] memory, uint256[] memory) {\\n    //     require(_exists(tokenId), \\\"Nonexistent token\\\");\\n    //     return _getRoyalties(tokenId);\\n    // }\\n\\n    // function _getRoyalties(uint256 tokenId) view internal returns (address [] memory recipients, uint256[] memory bps) {\\n\\n    //     // Get token level royalties\\n    //     RoyaltyConfig[] memory royalties = _tokenRoyalty[tokenId];\\n    //     if (royalties.length == 0) {\\n    //         // Get extension specific royalties\\n    //         address extension = _tokenExtension(tokenId);\\n    //         if (extension != address(0)) {\\n    //             if (ERC165Checker.supportsInterface(extension, type(ICreatorExtensionRoyalties).interfaceId)) {\\n    //                 (recipients, bps) = ICreatorExtensionRoyalties(extension).getRoyalties(address(this), tokenId);\\n    //                 // Extension override exists, just return that\\n    //                 if (recipients.length > 0) return (recipients, bps);\\n    //             }\\n    //             royalties = _extensionRoyalty[extension];\\n    //         }\\n    //     }\\n    //     if (royalties.length == 0) {\\n    //         // Get the default royalty\\n    //         royalties = _extensionRoyalty[address(0)];\\n    //     }\\n        \\n    //     if (royalties.length > 0) {\\n    //         recipients = new address [](royalties.length);\\n    //         bps = new uint256[](royalties.length);\\n    //         for (uint i; i < royalties.length;) {\\n    //             recipients[i] = royalties[i].receiver;\\n    //             bps[i] = royalties[i].bps;\\n    //             unchecked { ++i; }\\n    //         }\\n    //     }\\n    // }\\n\\n\\n}\\n\"\r\n    },\r\n    \"src/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this\\n     * contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the\\n     * recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with\\n     * `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    )\\n        external\\n        returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4194304,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"SignaturesInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getNinfaRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"bps\",\"type\":\"uint16[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyalties\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"tokenURI\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"royaltyBps\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"commissionBps\",\"type\":\"uint16[]\"},{\"internalType\":\"address[]\",\"name\":\"royaltyRecipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"commissionRecipients\",\"type\":\"address[]\"}],\"internalType\":\"struct ERC721LazyMintableSovreign.Voucher[]\",\"name\":\"_vouchers\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"}],\"name\":\"invalidateSignatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"tokenURI\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"royaltyBps\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"commissionBps\",\"type\":\"uint16[]\"},{\"internalType\":\"address[]\",\"name\":\"royaltyRecipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"commissionRecipients\",\"type\":\"address[]\"}],\"internalType\":\"struct ERC721LazyMintableSovreign.Voucher\",\"name\":\"_voucher\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"lazyBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"tokenURI\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"royaltyBps\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"commissionBps\",\"type\":\"uint16[]\"},{\"internalType\":\"address[]\",\"name\":\"royaltyRecipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"commissionRecipients\",\"type\":\"address[]\"}],\"internalType\":\"struct ERC721LazyMintableSovreign.Voucher\",\"name\":\"_voucher\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"lazyMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_royaltyRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_royaltyBps\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenURI\",\"type\":\"bytes32\"}],\"name\":\"mintAndTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint16[]\",\"name\":\"_royaltyBps\",\"type\":\"uint16[]\"},{\"internalType\":\"address[]\",\"name\":\"_royaltyRecipients\",\"type\":\"address[]\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC721Sovreign", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "4194304", "ConstructorArguments": "0000000000000000000000006447549f936f39dd2199e33579bb4e82ad15a732", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}