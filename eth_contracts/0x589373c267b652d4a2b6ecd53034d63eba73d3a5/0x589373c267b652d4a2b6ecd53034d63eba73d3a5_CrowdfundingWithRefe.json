{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface Oracle {\r\n    function latestAnswer() external view returns (uint256);\r\n}\r\n\r\n// Interface for ERC20 tokens, defining standard functions.\r\ninterface IERC20 {\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20USDT {\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function transfer(address to, uint256 value) external;\r\n}\r\n\r\n// Interface for Wrapped Ether (WETH).\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n// Ownable contract providing basic authorization control.\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    // set owner to deployer\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    // transfer ownership to new address\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// ReentrancyGuard contract to prevent reentrant calls.\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor() {\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// Crowdfunding contract with referral and airdrop features.\r\ncontract CrowdfundingWithReferral is Ownable, ReentrancyGuard {\r\n    // Structure to store user information.\r\n    struct User {\r\n        address referrer;\r\n        uint256 totalAirdrop;\r\n        uint256 lastAirdropPhase;\r\n        uint256 totalPurchasedTokens;\r\n        uint256 totalContributionUSDT;\r\n        uint256 totalContributionETH;\r\n        uint256 totalCommissionUSDT;\r\n        uint256 totalCommissionETH;\r\n        uint256 totalCommissionDBTT;\r\n    }\r\n\r\n    struct Presale {\r\n        uint256 priceUSDTRate;\r\n        uint256 saleCapDBTT;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint256 => Presale) public contributionRound;\r\n\r\n    // Addresses for USDT, WETH, and DBTT tokens.\r\n    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant DBTT = 0xe97CAbCBa4C9bdf35b3321c98440F7a88C745aCf;\r\n    address public serviceFeeReceiver;\r\n    IWETH private constant weth = IWETH(WETH);\r\n    Oracle public constant priceFeed =\r\n        Oracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    // Commission rates for the referral program.\r\n    uint256[] public commissionRates;\r\n\r\n    // Various configuration parameters.\r\n    uint256 public referralDepth;\r\n    uint256 public priceUSDTRate;\r\n    uint256 public launchPriceUSDTRate = 1960;\r\n    uint256 public nextPriceUSDTRate;\r\n    uint256 public minUSDTContribution;\r\n    uint256 public minETHContribution;\r\n    uint256 public maxDBTTAllocation;\r\n    uint256 public saleCapDBTT;\r\n    uint256 public vestingInterval;\r\n\r\n    // Presale status tracking variables.\r\n    uint256 public successTimestamp;\r\n    bool public isPresaleOpened;\r\n    bool public isPresaleSuccess;\r\n    bool public isPresaleCancelled;\r\n    bool public isCommissionDBTT;\r\n\r\n    // Counters\r\n    uint256 public globalCommissionETH;\r\n    uint256 public globalCommissionUSDT;\r\n    uint256 public globalCommissionDBTT;\r\n    uint256 public globalTotalAirdrop;\r\n    uint256 public globalCommissionETHPaid;\r\n    uint256 public globalCommissionUSDTPaid;\r\n    uint256 public globalCommissionDBTTPaid;\r\n    uint256 public globalTotalAirdropClaimed;\r\n    uint256 public totalPurchasedDBTT;\r\n    uint256 public totalRaisedUSDT;\r\n    uint256 public totalRaisedETH;\r\n    uint256 public totalPurchasedDBTTClaimed;\r\n    uint256 public totalContributionRounds;\r\n    uint256 public currentRound;\r\n    uint256 public purchasedDBTTRound;\r\n    uint256 public serviceFee;\r\n\r\n    // Event for new contribution\r\n    event NewContribution(\r\n        address indexed contributor,\r\n        uint256 amount,\r\n        address indexed referrer\r\n    );\r\n\r\n    /////////////////////////////// GETTERS ///////////////////////////////\r\n\r\n    // Retrieves the current price of ETH in USD\r\n    function getETHPrice() public view returns (uint256) {\r\n        return priceFeed.latestAnswer();\r\n    }\r\n\r\n    // retrieve global USDT value raised\r\n    function getGlobalRaisedUSDT() public view returns (uint256) {\r\n        //convert ETH to USDT for totalRaisedETH has 18 decimals, USDT 6 decimals and ETH price has 8 decimals\r\n        uint256 ethToUSDT = ((totalRaisedETH * getETHPrice()) / 10 ** 20);\r\n        return totalRaisedUSDT + ethToUSDT;\r\n    }\r\n\r\n    // Calculates the total commission based on commission rates.\r\n    function getTotalCommission() public view returns (uint256) {\r\n        uint256 totalCommission = 0;\r\n        for (uint256 i = 0; i < commissionRates.length; i++) {\r\n            totalCommission += commissionRates[i];\r\n        }\r\n        return totalCommission;\r\n    }\r\n\r\n    // Retrieves user details for a given address.\r\n    function getUserDetails(\r\n        address userAddress\r\n    ) public view returns (User memory) {\r\n        return users[userAddress];\r\n    }\r\n\r\n    // Determines the current vesting phase based on the timestamp.\r\n    function getVestingPhase() public view returns (uint256) {\r\n        if (vestingInterval > 0 && successTimestamp > 0) {\r\n            uint256 vestingPhase = 0;\r\n            if (block.timestamp >= successTimestamp + 4 * vestingInterval) {\r\n                vestingPhase = 4;\r\n            } else if (\r\n                block.timestamp >= successTimestamp + 3 * vestingInterval\r\n            ) {\r\n                vestingPhase = 3;\r\n            } else if (\r\n                block.timestamp >= successTimestamp + 2 * vestingInterval\r\n            ) {\r\n                vestingPhase = 2;\r\n            } else if (\r\n                block.timestamp >= successTimestamp + 1 * vestingInterval\r\n            ) {\r\n                vestingPhase = 1;\r\n            }\r\n            return vestingPhase;\r\n        } else return 0;\r\n    }\r\n\r\n    /////////////////////////////// SETTERS ///////////////////////////////\r\n\r\n    // Sets the referrer for a specific contributor.\r\n    function setReferrer(address contributor, address referrer) internal {\r\n        require(referrer != contributor, \"Cannot refer self\");\r\n        users[contributor].referrer = referrer;\r\n    }\r\n\r\n    // Sets airdrop amounts for a list of addresses.\r\n    function setAirdropList(\r\n        address[] calldata airdropList,\r\n        uint256 airdropAmount\r\n    ) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        require(\r\n            airdropList.length < 251,\r\n            \"GAS Error: max airdrop limit is 251 addresses\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < airdropList.length; i++) {\r\n            users[airdropList[i]].totalAirdrop += airdropAmount;\r\n        }\r\n\r\n        globalTotalAirdrop += airdropList.length * airdropAmount;\r\n    }\r\n\r\n    // Sets airdrop amount for an individual address.\r\n    function setUserAirdrop(\r\n        address userAddress,\r\n        uint256 airdropAmount\r\n    ) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        globalTotalAirdrop -= users[userAddress].totalAirdrop;\r\n        users[userAddress].totalAirdrop = airdropAmount;\r\n        globalTotalAirdrop += airdropAmount;\r\n    }\r\n\r\n    // Sets the referral depth and corresponding commission rates.\r\n    function setReferral(\r\n        uint256 _referralDepth,\r\n        uint256[] calldata _commissionRates\r\n    ) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        require(\r\n            _commissionRates.length == _referralDepth,\r\n            \"Rates must have same depth\"\r\n        );\r\n        referralDepth = _referralDepth;\r\n        commissionRates = _commissionRates;\r\n    }\r\n\r\n    // Function to set vesting interval\r\n    function setVestingInterval(uint256 _vestingInterval) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        vestingInterval = _vestingInterval;\r\n    }\r\n\r\n    // Function to set presale success\r\n    function setPresaleSuccess(bool _isPresaleSuccess) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        if (_isPresaleSuccess) {\r\n            isPresaleSuccess = true;\r\n            successTimestamp = block.timestamp;\r\n        } else {\r\n            isPresaleCancelled = true;\r\n        }\r\n        isPresaleOpened = false;\r\n    }\r\n\r\n    // Function to set presale opened\r\n    function setPresaleOpened() external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        require(!isPresaleOpened, \"Presale is already opened\");\r\n        isPresaleOpened = true;\r\n        _startNewRound();\r\n    }\r\n\r\n    // Function to set commission DBTT\r\n    function setCommissionDBTT(bool _isCommissionDBTT) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        isCommissionDBTT = _isCommissionDBTT;\r\n    }\r\n\r\n    function setPrice(uint256 _priceUSDTRate) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        priceUSDTRate = _priceUSDTRate;\r\n    }\r\n\r\n    // Function to set min USDT contribution\r\n    function setMinUSDTContribution(\r\n        uint256 _minUSDTContribution\r\n    ) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        minUSDTContribution = _minUSDTContribution;\r\n    }\r\n\r\n    // Function to set min ETH contribution\r\n    function setMinETHContribution(\r\n        uint256 _minETHContribution\r\n    ) external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        minETHContribution = _minETHContribution;\r\n    }\r\n\r\n    // Function to set max DBTT allocation\r\n    function setMaxAllocationDBTT(uint256 _maxAllocationDBTT) public onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        maxDBTTAllocation = _maxAllocationDBTT;\r\n    }\r\n\r\n    // Remove contribution limits\r\n    function setRemoveContributionLimits() external onlyOwner {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        minUSDTContribution = 0;\r\n        minETHContribution = 0;\r\n        maxDBTTAllocation = 0;\r\n    }\r\n\r\n    function setRoundSaleCapDBTT(\r\n        uint256 _round,\r\n        uint256 _saleCapDBTT\r\n    ) external onlyOwner {\r\n        require(\r\n            !isPresaleOpened && !isPresaleSuccess && !isPresaleCancelled,\r\n            \"Presale is already started\"\r\n        );\r\n        require(_round > 0, \"Round must be greater than 0\");\r\n        contributionRound[_round - 1].saleCapDBTT = _saleCapDBTT * 10 ** 18;\r\n    }\r\n\r\n    function setRoundPriceUSDTRate(\r\n        uint256 _round,\r\n        uint256 _priceUSDTRate\r\n    ) external onlyOwner {\r\n        require(\r\n            !isPresaleOpened && !isPresaleSuccess && !isPresaleCancelled,\r\n            \"Presale is already started\"\r\n        );\r\n        require(_round > 0, \"Round must be greater than 0\");\r\n        contributionRound[_round - 1].priceUSDTRate = _priceUSDTRate;\r\n    }\r\n\r\n    function setServiceFee(\r\n        uint256 _serviceFee,\r\n        address _serviceFeeReceiver\r\n    ) external onlyOwner {\r\n        require(\r\n            !isPresaleSuccess && !isPresaleCancelled,\r\n            \"Presale is already started\"\r\n        );\r\n        serviceFee = _serviceFee;\r\n        serviceFeeReceiver = _serviceFeeReceiver;\r\n    }\r\n\r\n    function setLaunchPrice(uint256 _launchPriceUSDTRate) external onlyOwner {\r\n        require(_launchPriceUSDTRate > 0, \"Price must be greater than 0\");\r\n        launchPriceUSDTRate = _launchPriceUSDTRate;\r\n    }\r\n\r\n    function _startNewRound() internal {\r\n        require(totalContributionRounds > 0, \"No round exists yet!\");\r\n\r\n        if (purchasedDBTTRound > 0) {\r\n            purchasedDBTTRound = 0;\r\n        }\r\n\r\n        priceUSDTRate = contributionRound[currentRound].priceUSDTRate;\r\n        saleCapDBTT = contributionRound[currentRound].saleCapDBTT;\r\n        if (contributionRound[currentRound + 1].priceUSDTRate > 0) {\r\n            nextPriceUSDTRate = contributionRound[currentRound + 1]\r\n                .priceUSDTRate;\r\n        } else {\r\n            nextPriceUSDTRate = 0;\r\n        }\r\n\r\n        currentRound++;\r\n    }\r\n\r\n    function addNewRound(\r\n        uint256 _saleCapDBTT,\r\n        uint256 _priceUSDTRate\r\n    ) external onlyOwner {\r\n        require(\r\n            !isPresaleOpened && !isPresaleSuccess && !isPresaleCancelled,\r\n            \"Presale is already started\"\r\n        );\r\n        require(\r\n            _saleCapDBTT > 0 && _priceUSDTRate > 0,\r\n            \"Sale cap and price must be greater than 0\"\r\n        );\r\n\r\n        totalContributionRounds++;\r\n        contributionRound[totalContributionRounds - 1].saleCapDBTT =\r\n            _saleCapDBTT *\r\n            10 ** 18;\r\n        contributionRound[totalContributionRounds - 1]\r\n            .priceUSDTRate = _priceUSDTRate;\r\n    }\r\n\r\n    /////////////////////////////// MAIN ///////////////////////////////\r\n\r\n    function contributeWithETH(address referrer) external payable nonReentrant {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        require(isPresaleOpened, \"Presale is closed\");\r\n\r\n        if (minETHContribution > 0) {\r\n            require(\r\n                msg.value >= minETHContribution,\r\n                \"Amount must be greater than min contribution\"\r\n            );\r\n        } else {\r\n            require(msg.value > 1000, \"Amount must be greater than 1000 wei\");\r\n        }\r\n\r\n        require(msg.value > 0, \"Amount must be greater than 0\");\r\n        weth.deposit{value: msg.value}();\r\n\r\n        users[msg.sender].totalContributionETH += msg.value;\r\n\r\n        if (purchasedDBTTRound == saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                _startNewRound();\r\n            } else {\r\n                revert(\"Sale cap reached\");\r\n            }\r\n        }\r\n\r\n        uint256 allocation = ((msg.value * getETHPrice()) / priceUSDTRate) /\r\n            10 ** 2;\r\n\r\n        // maybe not here\r\n        if (maxDBTTAllocation > 0) {\r\n            require(\r\n                users[msg.sender].totalPurchasedTokens + allocation <=\r\n                    maxDBTTAllocation,\r\n                \"Amount must be less than max allocation\"\r\n            );\r\n        }\r\n\r\n        if (purchasedDBTTRound + allocation > saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                uint256 currentRoundDBTT = saleCapDBTT - purchasedDBTTRound;\r\n                uint256 getSpent = (currentRoundDBTT * priceUSDTRate) /\r\n                    10 ** 18;\r\n                uint256 getUSDTInitial = (msg.value * getETHPrice()) / 10 ** 20;\r\n                _startNewRound();\r\n                uint256 remainingDBTT = ((getUSDTInitial - getSpent) *\r\n                    10 ** 18) / priceUSDTRate;\r\n                allocation = currentRoundDBTT + remainingDBTT;\r\n                purchasedDBTTRound += remainingDBTT;\r\n                require(purchasedDBTTRound <= saleCapDBTT, \"Sale cap reached\");\r\n            } else {\r\n                revert(\"Sale cap reached\");\r\n            }\r\n        } else if (purchasedDBTTRound + allocation == saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                _startNewRound();\r\n            } else {\r\n                purchasedDBTTRound += allocation;\r\n            }\r\n        } else {\r\n            purchasedDBTTRound += allocation;\r\n        }\r\n\r\n        users[msg.sender].totalPurchasedTokens += allocation;\r\n        totalPurchasedDBTT += allocation;\r\n        totalRaisedETH += msg.value;\r\n\r\n        if (referrer != address(0)) {\r\n            setReferrer(msg.sender, referrer);\r\n        }\r\n\r\n        // Distribute commissions (if applicable)\r\n        if (referralDepth > 0) {\r\n            distributeCommissions(msg.sender, WETH, msg.value);\r\n        }\r\n\r\n        emit NewContribution(msg.sender, msg.value, referrer);\r\n    }\r\n\r\n    // Function to contribute with ERC20 tokens\r\n    function contributeWithToken(\r\n        address token,\r\n        uint256 amount,\r\n        address referrer\r\n    ) external nonReentrant {\r\n        require(!isPresaleSuccess && !isPresaleCancelled, \"Presale is ended\");\r\n        require(isPresaleOpened, \"Presale is closed\");\r\n\r\n        if (minUSDTContribution > 0 && token == USDT) {\r\n            require(\r\n                amount >= minUSDTContribution,\r\n                \"Amount must be greater than min contribution\"\r\n            );\r\n        } else if (token == USDT) {\r\n            require(amount > 1000, \"Amount must be greater than 1000 wei\");\r\n        }\r\n        if (minETHContribution > 0 && token == WETH) {\r\n            require(\r\n                amount >= minETHContribution,\r\n                \"Amount must be greater than min contribution\"\r\n            );\r\n        } else if (token == WETH) {\r\n            require(amount > 1000, \"Amount must be greater than 1000 wei\");\r\n        }\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(\r\n            IERC20(token).allowance(msg.sender, address(this)) >= amount,\r\n            \"Token allowance too low\"\r\n        );\r\n        require(token == USDT || token == WETH, \"ERC20 token not valid\");\r\n\r\n        if (token == USDT) {\r\n            // Transfer tokens to this contract\r\n            IERC20USDT(token).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                amount\r\n            );\r\n        } else {\r\n            // Transfer tokens to this contract\r\n            bool sent = IERC20(token).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                amount\r\n            );\r\n            require(sent, \"Token transfer failed\");\r\n        }\r\n\r\n        if (purchasedDBTTRound == saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                _startNewRound();\r\n            } else {\r\n                revert(\"Sale cap reached\");\r\n            }\r\n        }\r\n\r\n        uint256 allocation;\r\n        if (token == USDT) {\r\n            users[msg.sender].totalContributionUSDT += amount;\r\n            allocation = (amount * 10 ** (18)) / priceUSDTRate;\r\n            totalRaisedUSDT += amount;\r\n        } else {\r\n            users[msg.sender].totalContributionETH += amount;\r\n            allocation = ((amount * getETHPrice()) / priceUSDTRate) / 10 ** 2;\r\n            totalRaisedETH += amount;\r\n        }\r\n\r\n        if (maxDBTTAllocation > 0) {\r\n            require(\r\n                users[msg.sender].totalPurchasedTokens + allocation <=\r\n                    maxDBTTAllocation,\r\n                \"Amount must be less than max allocation\"\r\n            );\r\n        }\r\n\r\n        if (purchasedDBTTRound + allocation > saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                uint256 currentRoundDBTT = saleCapDBTT - purchasedDBTTRound;\r\n                uint256 getSpent = (currentRoundDBTT * priceUSDTRate) /\r\n                    10 ** 18;\r\n                uint256 getUSDTInitial;\r\n                if (token == USDT) {\r\n                    getUSDTInitial = amount;\r\n                } else {\r\n                    getUSDTInitial = (amount * getETHPrice()) / 10 ** 20;\r\n                }\r\n                _startNewRound();\r\n                uint256 remainingDBTT = ((getUSDTInitial - getSpent) *\r\n                    10 ** 18) / priceUSDTRate;\r\n                allocation = currentRoundDBTT + remainingDBTT;\r\n                purchasedDBTTRound += remainingDBTT;\r\n                require(purchasedDBTTRound <= saleCapDBTT, \"Sale cap reached\");\r\n            } else {\r\n                revert(\"Sale cap reached\");\r\n            }\r\n        } else if (purchasedDBTTRound + allocation == saleCapDBTT) {\r\n            if (currentRound < totalContributionRounds) {\r\n                _startNewRound();\r\n            } else {\r\n                purchasedDBTTRound += allocation;\r\n            }\r\n        } else {\r\n            purchasedDBTTRound += allocation;\r\n        }\r\n\r\n        users[msg.sender].totalPurchasedTokens += allocation;\r\n        totalPurchasedDBTT += allocation;\r\n\r\n        if (referrer != address(0)) {\r\n            setReferrer(msg.sender, referrer);\r\n        }\r\n\r\n        // Distribute commissions (if applicable)\r\n        if (referralDepth > 0) {\r\n            distributeCommissions(msg.sender, token, amount);\r\n        }\r\n\r\n        emit NewContribution(msg.sender, amount, referrer);\r\n    }\r\n\r\n    // Internal function to handle commission distribution\r\n    function distributeCommissions(\r\n        address contributor,\r\n        address token,\r\n        uint256 amount\r\n    ) internal {\r\n        address currentReferrer = users[contributor].referrer;\r\n\r\n        for (uint256 i = 0; i < referralDepth; i++) {\r\n            if (currentReferrer == address(0)) {\r\n                break;\r\n            }\r\n\r\n            if (currentReferrer == contributor) {\r\n                break;\r\n            }\r\n\r\n            uint256 commission = (amount * commissionRates[i]) / 1000;\r\n\r\n            if (isCommissionDBTT && token == USDT) {\r\n                uint256 commissionDBTT = (commission * 10 ** 18) /\r\n                    priceUSDTRate;\r\n                users[currentReferrer].totalCommissionDBTT += commissionDBTT;\r\n                globalCommissionDBTT += commissionDBTT;\r\n            } else if (isCommissionDBTT) {\r\n                uint256 commissionDBTT = (commission * getETHPrice()) /\r\n                    priceUSDTRate /\r\n                    10 ** 2;\r\n                users[currentReferrer].totalCommissionDBTT += commissionDBTT;\r\n                globalCommissionDBTT += commissionDBTT;\r\n            } else if (token == USDT) {\r\n                users[currentReferrer].totalCommissionUSDT += commission;\r\n                globalCommissionUSDT += commission;\r\n            } else {\r\n                users[currentReferrer].totalCommissionETH += commission;\r\n                globalCommissionETH += commission;\r\n            }\r\n\r\n            // Move to the next referrer\r\n            currentReferrer = users[currentReferrer].referrer;\r\n        }\r\n    }\r\n\r\n    // Function to withdraw commissions\r\n    function withdrawCommissions() external nonReentrant {\r\n        require(isPresaleSuccess, \"Claim not active\");\r\n        require(\r\n            users[msg.sender].totalCommissionUSDT > 0 ||\r\n                users[msg.sender].totalCommissionETH > 0 ||\r\n                users[msg.sender].totalCommissionDBTT > 0,\r\n            \"No commissions to claim\"\r\n        );\r\n\r\n        _withdrawCommissions();\r\n    }\r\n\r\n    // Function to withdraw commissions\r\n    function _withdrawCommissions() internal {\r\n        uint256 amountUSDT = users[msg.sender].totalCommissionUSDT;\r\n        if (amountUSDT > 0) {\r\n            users[msg.sender].totalCommissionUSDT = 0;\r\n            IERC20USDT(USDT).transfer(msg.sender, amountUSDT);\r\n            globalCommissionUSDTPaid += amountUSDT;\r\n        }\r\n        uint256 amountETH = users[msg.sender].totalCommissionETH;\r\n        if (amountETH > 0) {\r\n            users[msg.sender].totalCommissionETH = 0;\r\n            bool sent = IERC20(WETH).transfer(msg.sender, amountETH);\r\n            require(sent, \"Token transfer failed\");\r\n            globalCommissionETHPaid += amountETH;\r\n        }\r\n        uint256 amountDBTT = users[msg.sender].totalCommissionDBTT;\r\n        if (amountDBTT > 0) {\r\n            users[msg.sender].totalCommissionDBTT = 0;\r\n            bool sent = IERC20(DBTT).transfer(msg.sender, amountDBTT);\r\n            require(sent, \"Token transfer failed\");\r\n            globalCommissionDBTTPaid += amountDBTT;\r\n        }\r\n    }\r\n\r\n    // Function to withdraw purchased tokens\r\n    function claimTokens() external nonReentrant {\r\n        require(isPresaleSuccess, \"Claim not active\");\r\n        require(users[msg.sender].totalPurchasedTokens > 0, \"Nothing to claim\");\r\n        _claimTokens();\r\n    }\r\n\r\n    function _claimTokens() internal {\r\n        uint256 amount = users[msg.sender].totalPurchasedTokens;\r\n        users[msg.sender].totalPurchasedTokens = 0;\r\n\r\n        bool sent = IERC20(DBTT).transfer(msg.sender, amount);\r\n        require(sent, \"Token transfer failed\");\r\n        totalPurchasedDBTTClaimed += amount;\r\n    }\r\n\r\n    // Function to withdraw ETH\r\n    function withdrawETH(uint256 _amount) external onlyOwner nonReentrant {\r\n        uint256 amount = IERC20(WETH).balanceOf(address(this));\r\n        require(amount >= _amount, \"Not enough ETH to withdraw\");\r\n        require(\r\n            amount - _amount >= globalCommissionETH - globalCommissionETHPaid,\r\n            \"Not enough ETH to withdraw\"\r\n        );\r\n\r\n        if (serviceFeeReceiver != address(0) && serviceFee > 0) {\r\n            uint256 serviceFeeAmount = (_amount * serviceFee) / 1000;\r\n            bool sentFees = IERC20(WETH).transfer(\r\n                serviceFeeReceiver,\r\n                serviceFeeAmount\r\n            );\r\n            require(sentFees, \"ETH Token transfer failed\");\r\n            _amount -= serviceFeeAmount;\r\n        }\r\n\r\n        bool sent = IERC20(WETH).transfer(msg.sender, _amount);\r\n        require(sent, \"ETH Token transfer failed\");\r\n    }\r\n\r\n    // Function to withdraw USDT\r\n    function withdrawUSDT(uint256 _amount) external onlyOwner nonReentrant {\r\n        uint256 amount = IERC20(USDT).balanceOf(address(this));\r\n        require(amount >= _amount, \"Not enough USDT to withdraw\");\r\n        require(\r\n            amount - _amount >= globalCommissionUSDT - globalCommissionUSDTPaid,\r\n            \"Not enough USDT to withdraw\"\r\n        );\r\n\r\n        if (serviceFeeReceiver != address(0) && serviceFee > 0) {\r\n            uint256 serviceFeeAmount = (_amount * serviceFee) / 1000;\r\n            IERC20USDT(USDT).transfer(\r\n                serviceFeeReceiver,\r\n                serviceFeeAmount\r\n            );\r\n            _amount -= serviceFeeAmount;\r\n        }\r\n\r\n        IERC20USDT(USDT).transfer(msg.sender, _amount);\r\n    }\r\n\r\n    // Function to withdraw all USDT and all WETH\r\n    function withdrawAll() external onlyOwner nonReentrant {\r\n        require(isPresaleSuccess, \"Presale is not completed\");\r\n        uint256 amountUSDT = IERC20(USDT).balanceOf(address(this));\r\n        uint256 amountETH = IERC20(WETH).balanceOf(address(this));\r\n        require(\r\n            amountUSDT >= globalCommissionUSDT - globalCommissionUSDTPaid,\r\n            \"Not enough USDT to withdraw\"\r\n        );\r\n        require(\r\n            amountETH >= globalCommissionETH - globalCommissionETHPaid,\r\n            \"Not enough ETH to withdraw\"\r\n        );\r\n\r\n        amountUSDT -= globalCommissionUSDT - globalCommissionUSDTPaid;\r\n        amountETH -= globalCommissionETH - globalCommissionETHPaid;\r\n\r\n        if (serviceFeeReceiver != address(0) && serviceFee > 0) {\r\n            uint256 serviceFeeAmountUSDT = (amountUSDT * serviceFee) / 1000;\r\n            uint256 serviceFeeAmountETH = (amountETH * serviceFee) / 1000;\r\n            IERC20USDT(USDT).transfer(\r\n                serviceFeeReceiver,\r\n                serviceFeeAmountUSDT\r\n            );\r\n            bool sentFeesETH = IERC20(WETH).transfer(\r\n                serviceFeeReceiver,\r\n                serviceFeeAmountETH\r\n            );\r\n            require(sentFeesETH, \"ETH Token transfer failed\");\r\n            amountUSDT -= serviceFeeAmountUSDT;\r\n            amountETH -= serviceFeeAmountETH;\r\n        }\r\n\r\n        IERC20USDT(USDT).transfer(msg.sender, amountUSDT);\r\n        bool sentETH = IERC20(WETH).transfer(msg.sender, amountETH);\r\n        require(sentETH, \"ETH Token transfer failed\");\r\n    }\r\n\r\n    // Function to withdraw DBTT\r\n    function withdrawDBTT() external onlyOwner nonReentrant {\r\n        uint256 amount = IERC20(DBTT).balanceOf(address(this));\r\n        if (isPresaleSuccess) {\r\n            require(\r\n                amount >\r\n                    globalCommissionDBTT +\r\n                        totalPurchasedDBTT +\r\n                        globalTotalAirdrop -\r\n                        globalCommissionDBTTPaid -\r\n                        totalPurchasedDBTTClaimed -\r\n                        globalTotalAirdropClaimed,\r\n                \"Not enough DBTT to withdraw\"\r\n            );\r\n            amount -=\r\n                globalCommissionDBTT +\r\n                totalPurchasedDBTT +\r\n                globalTotalAirdrop -\r\n                globalCommissionDBTTPaid -\r\n                totalPurchasedDBTTClaimed -\r\n                globalTotalAirdropClaimed;\r\n            bool sent = IERC20(DBTT).transfer(msg.sender, amount);\r\n            require(sent, \"DBTT Token transfer failed\");\r\n        } else if (isPresaleCancelled && amount > 0) {\r\n            bool sent = IERC20(DBTT).transfer(msg.sender, amount);\r\n            require(sent, \"DBTT Token transfer failed\");\r\n        } else revert(\"No DBTT to withdraw\");\r\n    }\r\n\r\n    // refund USDT or WETH to user\r\n    function refund() external nonReentrant {\r\n        require(isPresaleCancelled, \"Presale has not been cancelled\");\r\n        uint256 amountUSDT = users[msg.sender].totalContributionUSDT;\r\n        uint256 amountETH = users[msg.sender].totalContributionETH;\r\n        require(\r\n            amountUSDT > 0 || amountETH > 0,\r\n            \"Amount must be greater than 0\"\r\n        );\r\n        users[msg.sender].totalContributionUSDT = 0;\r\n        users[msg.sender].totalContributionETH = 0;\r\n        if (amountUSDT > 0) {\r\n            IERC20USDT(USDT).transfer(msg.sender, amountUSDT);\r\n        }\r\n        if (amountETH > 0) {\r\n            bool sent = IERC20(WETH).transfer(msg.sender, amountETH);\r\n            require(sent, \"ETH Token transfer failed\");\r\n        }\r\n    }\r\n\r\n    // claim airdrop with vesting\r\n    function claimAirdrop() external nonReentrant {\r\n        require(isPresaleSuccess, \"Claim not active\");\r\n        require(\r\n            users[msg.sender].lastAirdropPhase <= 4,\r\n            \"Airdrop already claimed\"\r\n        );\r\n        if (vestingInterval > 0) {\r\n            require(\r\n                getVestingPhase() > users[msg.sender].lastAirdropPhase,\r\n                \"Nothing to claim yet\"\r\n            );\r\n            require(users[msg.sender].totalAirdrop > 0, \"No airdrop for user\");\r\n        }\r\n\r\n        _claimAirdrop();\r\n    }\r\n\r\n    function _claimAirdrop() internal {\r\n        uint256 amount = users[msg.sender].totalAirdrop;\r\n        if (vestingInterval > 0) {\r\n            uint256 vestingPhase = getVestingPhase();\r\n            uint256 vestingAmount = (amount *\r\n                (vestingPhase - users[msg.sender].lastAirdropPhase)) / 4;\r\n            users[msg.sender].lastAirdropPhase = vestingPhase;\r\n            bool sent = IERC20(DBTT).transfer(msg.sender, vestingAmount);\r\n            require(sent, \"Token transfer failed\");\r\n            globalTotalAirdropClaimed += vestingAmount;\r\n        } else {\r\n            bool sent = IERC20(DBTT).transfer(msg.sender, amount);\r\n            require(sent, \"Token transfer failed\");\r\n            users[msg.sender].lastAirdropPhase = 4;\r\n            globalTotalAirdropClaimed += amount;\r\n        }\r\n    }\r\n\r\n    function claim() external nonReentrant {\r\n        require(isPresaleSuccess, \"Claim not active\");\r\n        require(\r\n            users[msg.sender].totalCommissionUSDT > 0 ||\r\n                users[msg.sender].totalCommissionETH > 0 ||\r\n                users[msg.sender].totalCommissionDBTT > 0 ||\r\n                users[msg.sender].totalPurchasedTokens > 0 ||\r\n                (users[msg.sender].lastAirdropPhase <= 4 &&\r\n                    getVestingPhase() > users[msg.sender].lastAirdropPhase &&\r\n                    users[msg.sender].totalAirdrop > 0),\r\n            \"No commissions to claim\"\r\n        );\r\n        if (\r\n            users[msg.sender].totalCommissionUSDT > 0 ||\r\n            users[msg.sender].totalCommissionETH > 0 ||\r\n            users[msg.sender].totalCommissionDBTT > 0\r\n        ) {\r\n            _withdrawCommissions();\r\n        }\r\n        if (users[msg.sender].totalPurchasedTokens > 0) {\r\n            _claimTokens();\r\n        }\r\n        if (\r\n            users[msg.sender].lastAirdropPhase <= 4 &&\r\n            getVestingPhase() > users[msg.sender].lastAirdropPhase &&\r\n            users[msg.sender].totalAirdrop > 0\r\n        ) {\r\n            _claimAirdrop();\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DBTT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saleCapDBTT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceUSDTRate\",\"type\":\"uint256\"}],\"name\":\"addNewRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissionRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"contributeWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"contributeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributionRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceUSDTRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleCapDBTT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalRaisedUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAirdropPhase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchasedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContributionUSDT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContributionETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionUSDT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionDBTT\",\"type\":\"uint256\"}],\"internalType\":\"struct CrowdfundingWithReferral.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionDBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionDBTTPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionETHPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCommissionUSDTPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalTotalAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalTotalAirdropClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCommissionDBTT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresaleCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresaleOpened\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresaleSuccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchPriceUSDTRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDBTTAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minETHContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minUSDTContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPriceUSDTRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceUSDTRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchasedDBTTRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralDepth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleCapDBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"airdropList\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"airdropAmount\",\"type\":\"uint256\"}],\"name\":\"setAirdropList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isCommissionDBTT\",\"type\":\"bool\"}],\"name\":\"setCommissionDBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_launchPriceUSDTRate\",\"type\":\"uint256\"}],\"name\":\"setLaunchPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAllocationDBTT\",\"type\":\"uint256\"}],\"name\":\"setMaxAllocationDBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minETHContribution\",\"type\":\"uint256\"}],\"name\":\"setMinETHContribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minUSDTContribution\",\"type\":\"uint256\"}],\"name\":\"setMinUSDTContribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPresaleOpened\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPresaleSuccess\",\"type\":\"bool\"}],\"name\":\"setPresaleSuccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceUSDTRate\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralDepth\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_commissionRates\",\"type\":\"uint256[]\"}],\"name\":\"setReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRemoveContributionLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceUSDTRate\",\"type\":\"uint256\"}],\"name\":\"setRoundPriceUSDTRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_saleCapDBTT\",\"type\":\"uint256\"}],\"name\":\"setRoundSaleCapDBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_serviceFeeReceiver\",\"type\":\"address\"}],\"name\":\"setServiceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"airdropAmount\",\"type\":\"uint256\"}],\"name\":\"setUserAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestingInterval\",\"type\":\"uint256\"}],\"name\":\"setVestingInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributionRounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPurchasedDBTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPurchasedDBTTClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRaisedETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRaisedUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAirdrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAirdropPhase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchasedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContributionUSDT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContributionETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionUSDT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCommissionDBTT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCommissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDBTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CrowdfundingWithReferral", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://70ca6edcf84dec95599bdd067be83ce23a1a0aae2948ecaa513c0d9f504550a2"}