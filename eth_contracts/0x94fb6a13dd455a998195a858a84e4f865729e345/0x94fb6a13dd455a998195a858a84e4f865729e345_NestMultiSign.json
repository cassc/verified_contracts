{"SourceCode": "// Sources flattened with hardhat v2.5.0 https://hardhat.org\r\n\r\n// File contracts/libs/TransferHelper.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value,gas:5000}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/NestMultiSign.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev NestMultiSign implementation\r\ncontract NestMultiSign {\r\n\r\n    // Passed Thresholds, max M\r\n    uint constant P = 2;\r\n    // Number of members, max 8\r\n    uint constant M = 2;\r\n    // Number of addresses per each account, max 3\r\n    uint constant N = 3;\r\n\r\n    // Transaction data structure\r\n    struct Transaction {\r\n        // Address of token to transfer\r\n        address tokenAddress;\r\n        // Transaction start block\r\n        uint32 startBlock;\r\n        // Transaction execute block\r\n        uint32 executeBlock;\r\n        // sign7(1+3)|sign6(1+3)|sign5(1+3)|sign4(1+3)|sign3(1+3)|sign2(1+3)|sign1(1+3)|sign0(1+3)\r\n        uint32 signs;\r\n        // Token receive address\r\n        address to;\r\n        // Transfer value\r\n        uint96 value;\r\n    }\r\n\r\n    // Transaction information for view method\r\n    struct TransactionView {\r\n        // Index of transaction in _transactions\r\n        uint32 index;\r\n        // Address of token to transfer\r\n        address tokenAddress;\r\n        // Transaction start block\r\n        uint32 startBlock;\r\n        // Transaction execute block\r\n        uint32 executeBlock;\r\n        // Token receive address\r\n        address to;\r\n        // Transfer value\r\n        uint96 value;\r\n        // signs: 0 address means not signed\r\n        address[M] signs;\r\n    }\r\n\r\n    // Members of this multi sign account\r\n    address[N][M] _members;\r\n\r\n    // Transaction array\r\n    Transaction[] _transactions;\r\n\r\n    // Only member is allowed\r\n    modifier onlyMember(uint i, uint j) {\r\n        require(_members[i][j] == msg.sender, \"NMS:member not found\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Ctor\r\n    /// @param members Member array, stored by group, don't repeat\r\n    constructor(address[N][M] memory members) {\r\n        // TODO: check repeat\r\n        _members = members;\r\n    }\r\n\r\n    /// @dev Get member at given position\r\n    /// @param i Index of member\r\n    /// @param j Index of address\r\n    /// @return member Member at (i, j)\r\n    /// @return m Number of members\r\n    /// @return n Number of addresses per each account\r\n    function getMember(uint i, uint j) external view returns (address member, uint m, uint n) {\r\n        return (_members[i][j], M, N);\r\n    }\r\n\r\n    /// @dev Find member by target address\r\n    /// @param target Target address\r\n    /// @return Index of member\r\n    /// @return Index of address\r\n    function findMember(address target) external view returns (uint, uint) {\r\n        for (uint i = 0; i < M; ++i) {\r\n            for (uint j = 0; j < N; ++j) {\r\n                if (_members[i][j] == target) {\r\n                    return (i, j);\r\n                }\r\n            }\r\n        }\r\n        revert(\"NMS:member not found\");\r\n    }\r\n\r\n    /// @dev List transactions\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return transactionArray List of TransactionView\r\n    function list(\r\n        uint offset, \r\n        uint count, \r\n        uint order\r\n    ) external view returns (TransactionView[] memory transactionArray) {\r\n        // Load mint requests\r\n        Transaction[] storage transactions = _transactions;\r\n        // Create result array\r\n        transactionArray = new TransactionView[](count);\r\n        uint length = transactions.length;\r\n        uint i = 0;\r\n\r\n        // Reverse order\r\n        if (order == 0) {\r\n            uint index = length - offset;\r\n            uint end = index > count ? index - count : 0;\r\n            while (index > end) {\r\n                --index;\r\n                (transactionArray[i++] = _toTransactionView(transactions[index])).index = uint32(index);\r\n            }\r\n        } \r\n        // Positive order\r\n        else {\r\n            uint index = offset;\r\n            uint end = index + count;\r\n            if (end > length) {\r\n                end = length;\r\n            }\r\n            while (index < end) {\r\n                (transactionArray[i++] = _toTransactionView(transactions[index])).index = uint32(index);\r\n                ++index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Start a new transaction\r\n    /// @param i Index of member\r\n    /// @param j Index of address\r\n    /// @param tokenAddress Address of target token\r\n    /// @param to Target address\r\n    /// @param value Transaction amount\r\n    function newTransaction(uint i, uint j, address tokenAddress, address to, uint96 value) external onlyMember(i, j) {\r\n        _transactions.push(Transaction(\r\n            tokenAddress,\r\n            uint32(block.number),\r\n            uint32(0),\r\n            uint32((1 << j) << (i << 2)),\r\n            to,\r\n            value\r\n        ));\r\n    }\r\n\r\n    /// @dev Sign transaction\r\n    /// @param i Index of member\r\n    /// @param j Index of address\r\n    /// @param index Index of transaction\r\n    function signTransaction(uint i, uint j, uint index) external onlyMember(i, j) {\r\n        _transactions[index].signs |= uint32((1 << j) << (i << 2));\r\n    }\r\n\r\n    /// @dev Reject transaction\r\n    /// @param i Index of member\r\n    /// @param j Index of address\r\n    /// @param index Index of transaction\r\n    function rejectTransaction(uint i, uint j, uint index) external onlyMember(i, j) {\r\n        _transactions[index].signs |= uint32((1 << 3) << (i << 2));\r\n    }\r\n\r\n    /// @dev Execute transaction\r\n    /// @param i Index of member\r\n    /// @param j Index of address\r\n    /// @param index Index of transaction\r\n    function executeTransaction(uint i, uint j, uint index) external onlyMember(i, j) {\r\n        // Load transaction\r\n        Transaction memory transaction = _transactions[index];\r\n        // executeBlock == 0 means executed\r\n        require(transaction.executeBlock == 0, \"NMS:executed\");\r\n        // Load sign, and sign with current member\r\n        uint signs = uint(transaction.signs) | ((1 << j) << (i << 2));\r\n        \r\n        // Count of signs\r\n        uint p = 0;\r\n        for (uint k = 0; k < M; ++k) {\r\n            uint sign = (signs >> (k << 2)) & 0xF;\r\n            if (sign > 0 && sign < 8) {\r\n                ++p;\r\n            }\r\n        }\r\n        require(p >= P, \"NMS:not passed\");\r\n\r\n        // Update transaction\r\n        transaction.signs = uint32(signs);\r\n        transaction.executeBlock = uint32(block.number);\r\n        _transactions[index] = transaction;\r\n\r\n        uint value = uint(transaction.value);\r\n        // Transfer eth\r\n        if (transaction.tokenAddress == address(0)) {\r\n            payable(transaction.to).transfer(value);\r\n        } \r\n        // Modify member\r\n        else if (transaction.tokenAddress == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF) {\r\n            _members[value >> 32][value & 0xFFFFFFFF] = transaction.to;\r\n        }\r\n        // Transfer token\r\n        else {\r\n            TransferHelper.safeTransfer(transaction.tokenAddress, transaction.to, value);\r\n        }\r\n    }\r\n\r\n    // Convert to TransactionView\r\n    function _toTransactionView(Transaction memory transaction) internal view returns (TransactionView memory tv) {\r\n        // Resolve signs\r\n        uint signs = uint(transaction.signs);\r\n        address[M] memory signArray;\r\n        for (uint k = 0; k < M; ++k) {\r\n            uint sign = (signs >> (k << 2)) & 0xF;\r\n            if (sign > 0 && sign < 8) {\r\n                for (uint j = 0; j < N; ++j) {\r\n                    if ((sign >> j) & 0x01 == 0x01) {\r\n                        signArray[k] = _members[k][j];\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                signArray[k] = address(0); \r\n            }\r\n        }\r\n\r\n        tv = TransactionView(\r\n            uint32(0),\r\n            transaction.tokenAddress,\r\n            transaction.startBlock,\r\n            transaction.executeBlock,\r\n            transaction.to,\r\n            transaction.value,\r\n            signArray\r\n        );\r\n    }\r\n\r\n    // Support eth\r\n    receive() external payable { }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[3][2]\",\"name\":\"members\",\"type\":\"address[3][2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"j\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"findMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"j\",\"type\":\"uint256\"}],\"name\":\"getMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"order\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executeBlock\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"address[2]\",\"name\":\"signs\",\"type\":\"address[2]\"}],\"internalType\":\"struct NestMultiSign.TransactionView[]\",\"name\":\"transactionArray\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"j\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"name\":\"newTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"j\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"rejectTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"j\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"signTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NestMultiSign", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "0000000000000000000000005fa1dd7f6dce7066d8be8b8787575d66a20dc44c00000000000000000000000045b0d42174d2845cf99834db81437c984e02db770000000000000000000000004c41369a139ffee81e66641c87f59cf130a65a0a000000000000000000000000bf0d04623a9efeea50b536cbcde28bf76770afe8000000000000000000000000822f65588dddfe025572a5ac20fe5acd4af5d1ed000000000000000000000000bba04dd3c5fa1abad51899dfcaf049d362666915", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cef3c37f381e44de41afc40388596639efc2dae1ae621f3a223767784364859c"}