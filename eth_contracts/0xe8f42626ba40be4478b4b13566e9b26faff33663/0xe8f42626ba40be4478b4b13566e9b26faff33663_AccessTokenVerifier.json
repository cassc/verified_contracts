{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AccessTokenVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { IAccessTokenVerifier, AccessToken, FunctionCall, EIP712Domain } from \\\"./interfaces/IAccessTokenVerifier.sol\\\";\\nimport { KeyInfrastructure } from \\\"./KeyInfrastructure.sol\\\";\\n\\ncontract AccessTokenVerifier is IAccessTokenVerifier, KeyInfrastructure {\\n    bytes32 private constant EIP712DOMAIN_TYPEHASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // solhint-disable max-line-length\\n    bytes32 private constant FUNCTIONCALL_TYPEHASH =\\n        keccak256(\\\"FunctionCall(bytes4 functionSignature,address target,address caller,bytes parameters)\\\");\\n\\n    // solhint-disable max-line-length\\n    bytes32 private constant TOKEN_TYPEHASH =\\n        keccak256(\\n            \\\"AccessToken(uint256 expiry,FunctionCall functionCall)FunctionCall(bytes4 functionSignature,address target,address caller,bytes parameters)\\\"\\n        );\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    constructor(address root) KeyInfrastructure(root) {\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    function hash(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    EIP712DOMAIN_TYPEHASH,\\n                    keccak256(bytes(eip712Domain.name)),\\n                    keccak256(bytes(eip712Domain.version)),\\n                    eip712Domain.chainId,\\n                    eip712Domain.verifyingContract\\n                )\\n            );\\n    }\\n\\n    function hash(FunctionCall calldata call) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    FUNCTIONCALL_TYPEHASH,\\n                    call.functionSignature,\\n                    call.target,\\n                    call.caller,\\n                    keccak256(call.parameters)\\n                )\\n            );\\n    }\\n\\n    function hash(AccessToken calldata token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(TOKEN_TYPEHASH, token.expiry, hash(token.functionCall)));\\n    }\\n\\n    function verifySignerOf(AccessToken calldata token, uint8 v, bytes32 r, bytes32 s) external view returns (address) {\\n        return _retrieveSignerFromToken(token, v, r, s);\\n    }\\n\\n    function verify(AccessToken calldata token, uint8 v, bytes32 r, bytes32 s) public view override returns (bool) {\\n        address signer = _retrieveSignerFromToken(token, v, r, s);\\n        return _isActiveIssuer[signer];\\n    }\\n\\n    function _domainSeparator() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return\\n            hash(\\n                EIP712Domain({\\n                    name: \\\"Ethereum Access Token\\\",\\n                    version: \\\"1\\\",\\n                    chainId: block.chainid,\\n                    verifyingContract: address(this)\\n                })\\n            );\\n    }\\n\\n    function _retrieveSignerFromToken(\\n        AccessToken calldata token,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address) {\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparator(), hash(token)));\\n        // HE -> Has Expired\\n        require(token.expiry > block.timestamp, \\\"AccessToken: HE\\\");\\n\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            // ISS -> Invalid Signature S\\n            revert(\\\"AccessToken: ISS\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            // ISV -> Invalid Signature V\\n            revert(\\\"AccessToken: ISV\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(digest, v, r, s);\\n\\n        if (signer == address(0)) {\\n            // IS -> Invalid Signature\\n            revert(\\\"AccessToken: IS\\\");\\n        }\\n\\n        return signer;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessTokenVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nstruct EIP712Domain {\\n    string name;\\n    string version;\\n    uint256 chainId;\\n    address verifyingContract;\\n}\\n\\nstruct FunctionCall {\\n    bytes4 functionSignature;\\n    address target;\\n    address caller;\\n    bytes parameters;\\n}\\n\\nstruct AccessToken {\\n    uint256 expiry;\\n    FunctionCall functionCall;\\n}\\n\\ninterface IAccessTokenVerifier {\\n    function verify(AccessToken calldata token, uint8 v, bytes32 r, bytes32 s) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/KeyInfrastructure.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ncontract KeyInfrastructure {\\n    address internal immutable _root;\\n    address internal _intermediate;\\n    address[] internal _activeIssuers;\\n    mapping(address => bool) internal _isActiveIssuer;\\n\\n    event IntermediateRotated(address newKey);\\n    event IssuerActivated(address activatedIssuer);\\n    event IssuerDeactivated(address deactivatedIssuer);\\n\\n    modifier onlyRoot() {\\n        // MBR -> Must be root\\n        require(msg.sender == _root, \\\"unauthorised: MBR\\\");\\n        _;\\n    }\\n\\n    modifier onlyIntermediate() {\\n        // MBI -> Must be intermediate\\n        require(msg.sender == _intermediate, \\\"unauthorised: MBI\\\");\\n        _;\\n    }\\n\\n    constructor(address root) {\\n        _root = root;\\n    }\\n\\n    function rotateIntermediate(address newIntermediate) public onlyRoot {\\n        _intermediate = newIntermediate;\\n        emit IntermediateRotated(newIntermediate);\\n    }\\n\\n    function activateIssuers(address[] calldata newIssuers) public onlyIntermediate {\\n        for (uint256 i = 0; i < newIssuers.length; i++) {\\n            address newKey = newIssuers[i];\\n            if (!_isActiveIssuer[newKey]) {\\n                _addToActiveIssuers(newKey);\\n                emit IssuerActivated(newKey);\\n            }\\n        }\\n    }\\n\\n    function deactivateIssuers(address[] calldata issuers) public onlyIntermediate {\\n        for (uint256 i = 0; i < issuers.length; i++) {\\n            address oldKey = issuers[i];\\n            if (_isActiveIssuer[oldKey]) {\\n                _removeFromActiveIssuers(oldKey);\\n                emit IssuerDeactivated(oldKey);\\n            }\\n        }\\n    }\\n\\n    function getRootKey() public view returns (address) {\\n        return _root;\\n    }\\n\\n    function getIntermediateKey() public view returns (address) {\\n        return _intermediate;\\n    }\\n\\n    function getActiveIssuers() public view returns (address[] memory) {\\n        return _activeIssuers;\\n    }\\n\\n    function isActiveIssuer(address addr) public view returns (bool) {\\n        return _isActiveIssuer[addr];\\n    }\\n\\n    function _addToActiveIssuers(address addr) internal {\\n        _isActiveIssuer[addr] = true;\\n        _activeIssuers.push(addr);\\n    }\\n\\n    function _removeFromActiveIssuers(address addr) internal {\\n        _isActiveIssuer[addr] = false;\\n\\n        for (uint256 i = 0; i < _activeIssuers.length; i++) {\\n            address issuer = _activeIssuers[i];\\n            if (addr == issuer) {\\n                _activeIssuers[i] = _activeIssuers[_activeIssuers.length - 1];\\n                _activeIssuers.pop();\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"root\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newKey\",\"type\":\"address\"}],\"name\":\"IntermediateRotated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"activatedIssuer\",\"type\":\"address\"}],\"name\":\"IssuerActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deactivatedIssuer\",\"type\":\"address\"}],\"name\":\"IssuerDeactivated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newIssuers\",\"type\":\"address[]\"}],\"name\":\"activateIssuers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"issuers\",\"type\":\"address[]\"}],\"name\":\"deactivateIssuers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveIssuers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIntermediateKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRootKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isActiveIssuer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newIntermediate\",\"type\":\"address\"}],\"name\":\"rotateIntermediate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"functionSignature\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"internalType\":\"struct FunctionCall\",\"name\":\"functionCall\",\"type\":\"tuple\"}],\"internalType\":\"struct AccessToken\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"functionSignature\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"internalType\":\"struct FunctionCall\",\"name\":\"functionCall\",\"type\":\"tuple\"}],\"internalType\":\"struct AccessToken\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"verifySignerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AccessTokenVerifier", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000b61e4e07c3eba5c04547578e0cbf4be931d502d6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}