{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/IE.sol\": {\r\n      \"content\": \"// \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318 \u2318\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {SafeTransferLib} from \\\"../lib/solady/src/utils/SafeTransferLib.sol\\\";\\nimport {MetadataReaderLib} from \\\"../lib/solady/src/utils/MetadataReaderLib.sol\\\";\\n\\n/// @title Intents Engine (IE)\\n/// @notice Simple helper contract for turning transactional intents into executable code.\\n/// @dev V1 simulates typical commands (sending and swapping tokens) and includes execution.\\n/// IE also has a workflow to verify the intent of ERC4337 account userOps against calldata.\\n/// @author nani.eth (https://github.com/NaniDAO/ie)\\n/// @custom:version 1.0.0\\ncontract IE {\\n    /// ======================= LIBRARY USAGE ======================= ///\\n\\n    /// @dev Metadata reader library.\\n    using MetadataReaderLib for address;\\n\\n    /// @dev Safe token transfer library.\\n    using SafeTransferLib for address;\\n\\n    /// ======================= CUSTOM ERRORS ======================= ///\\n\\n    /// @dev Bad math.\\n    error Overflow();\\n\\n    /// @dev Caller fails.\\n    error Unauthorized();\\n\\n    /// @dev 0-liquidity.\\n    error InvalidSwap();\\n\\n    /// @dev Invalid command.\\n    error InvalidSyntax();\\n\\n    /// @dev Non-numeric character.\\n    error InvalidCharacter();\\n\\n    /// =========================== EVENTS =========================== ///\\n\\n    /// @dev Logs the registration of a token name.\\n    event NameSet(address indexed token, string name);\\n\\n    /// ========================== STRUCTS ========================== ///\\n\\n    /// @dev The ERC4337 user operation (userOp) struct.\\n    struct UserOperation {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n    /// @dev The packed ERC4337 user operation (userOp) struct.\\n    struct PackedUserOperation {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        bytes32 accountGasLimits;\\n        uint256 preVerificationGas;\\n        bytes32 gasFees; // `maxPriorityFee` and `maxFeePerGas`.\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n    /// =========================== ENUMS =========================== ///\\n\\n    /// @dev `ENSAsciiNormalizer` rules.\\n    enum Rule {\\n        DISALLOWED,\\n        VALID\\n    }\\n\\n    /// ========================= CONSTANTS ========================= ///\\n\\n    /// @dev The governing DAO address.\\n    address internal constant DAO = 0xDa000000000000d2885F108500803dfBAaB2f2aA;\\n\\n    /// @dev The NANI token address.\\n    address internal constant NANI = 0x00000000000025824328358250920B271f348690;\\n\\n    /// @dev The conventional ERC7528 ETH address.\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @dev The canonical wrapped ETH address.\\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The popular wrapped BTC address.\\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n\\n    /// @dev The Circle USD stablecoin address.\\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n\\n    /// @dev The Tether USD stablecoin address.\\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n\\n    /// @dev The Maker DAO USD stablecoin address.\\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    /// @dev ENS fallback registry contract.\\n    IENSHelper internal constant ENS_REGISTRY =\\n        IENSHelper(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\n\\n    /// @dev ENS name wrapper token contract.\\n    IENSHelper internal constant ENS_WRAPPER =\\n        IENSHelper(0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401);\\n\\n    /// @dev The address of the Uniswap V3 Factory.\\n    address internal constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\n\\n    /// @dev The Uniswap V3 Pool `initcodehash`.\\n    bytes32 internal constant UNISWAP_V3_POOL_INIT_CODE_HASH =\\n        0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\\n\\n    /// @dev The minimum value that can be returned from `getSqrtRatioAtTick` (plus one).\\n    uint160 internal constant MIN_SQRT_RATIO_PLUS_ONE = 4295128740;\\n\\n    /// @dev The maximum value that can be returned from `getSqrtRatioAtTick` (minus one).\\n    uint160 internal constant MAX_SQRT_RATIO_MINUS_ONE =\\n        1461446703485210103287273052203988822378723970341;\\n\\n    /// @dev String mapping for `ENSAsciiNormalizer` logic.\\n    bytes internal constant ASCII_MAP =\\n        hex\\\"2d00020101000a010700016101620163016401650166016701680169016a016b016c016d016e016f0170017101720173017401750176017701780179017a06001a010500\\\";\\n\\n    /// ========================== STORAGE ========================== ///\\n\\n    /// @dev DAO-governed token address naming.\\n    mapping(string name => address) public tokens;\\n\\n    /// @dev Each index in idnamap refers to an ascii code point.\\n    /// If idnamap[char] > 2, char maps to a valid ascii character.\\n    /// Otherwise, idna[char] returns Rule.DISALLOWED or Rule.VALID.\\n    /// Modified from `ENSAsciiNormalizer` deployed by royalfork.eth\\n    /// (0x4A5cae3EC0b144330cf1a6CeAD187D8F6B891758).\\n    bytes1[] internal _idnamap;\\n\\n    /// ======================== CONSTRUCTOR ======================== ///\\n\\n    /// @dev Constructs this IE with `ASCII_MAP`.\\n    constructor() payable {\\n        unchecked {\\n            for (uint256 i; i != ASCII_MAP.length; i += 2) {\\n                bytes1 r = ASCII_MAP[i + 1];\\n                for (uint8 j; j != uint8(ASCII_MAP[i]); ++j) {\\n                    _idnamap.push(r);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// ====================== COMMAND PREVIEW ====================== ///\\n\\n    /// @notice Preview natural language smart contract command.\\n    /// The `send` syntax uses ENS naming: 'send vitalik 20 DAI'.\\n    /// `swap` syntax uses common format: 'swap 100 DAI for WETH'.\\n    function previewCommand(string calldata intent)\\n        public\\n        view\\n        virtual\\n        returns (\\n            address to, // Receiver address.\\n            uint256 amount, // Formatted amount.\\n            address token, // Asset to send `to`.\\n            bytes memory callData, // Raw calldata for send transaction.\\n            bytes memory executeCallData // Anticipates common execute API.\\n        )\\n    {\\n        string memory normalized = _lowercase(intent);\\n        bytes32 action = _extraction(normalized);\\n        if (action == \\\"send\\\" || action == \\\"transfer\\\") {\\n            (string memory _to, string memory _amount, string memory _token) =\\n                _extractSend(normalized);\\n            (to, amount, token, callData, executeCallData) = previewSend(_to, _amount, _token);\\n        } else if (action == \\\"swap\\\" || action == \\\"exchange\\\") {\\n            (string memory amountIn, string memory tokenIn, string memory tokenOut) =\\n                _extractSwap(normalized);\\n            (amount, token, to) = previewSwap(amountIn, tokenIn, tokenOut);\\n        } else {\\n            revert InvalidSyntax(); // Invalid command format.\\n        }\\n    }\\n\\n    /// @dev Previews a `send` command from the parts of a matched intent string.\\n    function previewSend(string memory to, string memory amount, string memory token)\\n        public\\n        view\\n        virtual\\n        returns (\\n            address _to,\\n            uint256 _amount,\\n            address _token,\\n            bytes memory callData,\\n            bytes memory executeCallData\\n        )\\n    {\\n        _token = _returnTokenConstant(bytes32(bytes(token))); // Check constant.\\n        if (_token == address(0)) _token = tokens[token]; // Check storage.\\n        bool isETH = _token == ETH; // Memo whether the token is ETH or not.\\n        (, _to,) = whatIsTheAddressOf(to); // Fetch receiver address from ENS.\\n        _amount = _stringToUint(amount, isETH ? 18 : _token.readDecimals());\\n        if (!isETH) callData = abi.encodeCall(IToken.transfer, (_to, _amount));\\n        executeCallData =\\n            abi.encodeCall(IExecutor.execute, (isETH ? _to : _token, isETH ? _amount : 0, callData));\\n    }\\n\\n    /// @dev Previews a `swap` command from the parts of a matched intent string.\\n    function previewSwap(string memory amountIn, string memory tokenIn, string memory tokenOut)\\n        public\\n        view\\n        virtual\\n        returns (uint256 _amountIn, address _tokenIn, address _tokenOut)\\n    {\\n        _tokenIn = _returnTokenConstant(bytes32(bytes(tokenIn)));\\n        if (_tokenIn == address(0)) _tokenIn = tokens[tokenIn];\\n        _tokenOut = _returnTokenConstant(bytes32(bytes(tokenOut)));\\n        if (_tokenOut == address(0)) _tokenOut = tokens[tokenOut];\\n        _amountIn = _stringToUint(amountIn, _tokenIn == ETH ? 18 : _tokenIn.readDecimals());\\n    }\\n\\n    /// @dev Checks ERC4337 userOp against the output of the command intent.\\n    function checkUserOp(string calldata intent, UserOperation calldata userOp)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        (,,,, bytes memory executeCallData) = previewCommand(intent);\\n        if (executeCallData.length != userOp.callData.length) return false;\\n        return keccak256(executeCallData) == keccak256(userOp.callData);\\n    }\\n\\n    /// @dev Checks packed ERC4337 userOp against the output of the command intent.\\n    function checkPackedUserOp(string calldata intent, PackedUserOperation calldata userOp)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        (,,,, bytes memory executeCallData) = previewCommand(intent);\\n        if (executeCallData.length != userOp.callData.length) return false;\\n        return keccak256(executeCallData) == keccak256(userOp.callData);\\n    }\\n\\n    /// @dev Checks and returns the canonical token address constant for a matched intent string.\\n    function _returnTokenConstant(bytes32 token) internal view virtual returns (address _token) {\\n        if (token == \\\"eth\\\" || token == \\\"ether\\\") return ETH;\\n        if (token == \\\"usdc\\\") return USDC;\\n        if (token == \\\"usdt\\\") return USDT;\\n        if (token == \\\"dai\\\") return DAI;\\n        if (token == \\\"nani\\\") return NANI;\\n        if (token == \\\"weth\\\") return WETH;\\n        if (token == \\\"wbtc\\\" || token == \\\"btc\\\" || token == \\\"bitcoin\\\") return WBTC;\\n    }\\n\\n    /// ===================== COMMAND EXECUTION ===================== ///\\n\\n    /// @dev Executes a text command from an intent string.\\n    function command(string calldata intent) public payable virtual {\\n        string memory normalized = _lowercase(intent);\\n        bytes32 action = _extraction(normalized);\\n        if (action == \\\"send\\\" || action == \\\"transfer\\\") {\\n            (string memory to, string memory amount, string memory token) = _extractSend(normalized);\\n            send(to, amount, token);\\n        } else if (action == \\\"swap\\\" || action == \\\"exchange\\\") {\\n            (string memory amountIn, string memory tokenIn, string memory tokenOut) =\\n                _extractSwap(normalized);\\n            swap(amountIn, tokenIn, tokenOut);\\n        } else {\\n            revert InvalidSyntax(); // Invalid command format.\\n        }\\n    }\\n\\n    /// @dev Executes a `send` command from the parts of a matched intent string.\\n    function send(string memory to, string memory amount, string memory token)\\n        public\\n        payable\\n        virtual\\n    {\\n        address _token = _returnTokenConstant(bytes32(bytes(token)));\\n        if (_token == address(0)) _token = tokens[token];\\n        (, address _to,) = whatIsTheAddressOf(to);\\n        if (_token == ETH) {\\n            _to.safeTransferETH(_stringToUint(amount, 18));\\n        } else {\\n            _token.safeTransferFrom(msg.sender, _to, _stringToUint(amount, _token.readDecimals()));\\n        }\\n    }\\n\\n    /// @dev Executes a `swap` command from the parts of a matched intent string.\\n    function swap(string memory amountIn, string memory tokenIn, string memory tokenOut)\\n        public\\n        payable\\n        virtual\\n    {\\n        address _tokenIn = _returnTokenConstant(bytes32(bytes(tokenIn)));\\n        if (_tokenIn == address(0)) _tokenIn = tokens[tokenIn];\\n        address _tokenOut = _returnTokenConstant(bytes32(bytes(tokenOut)));\\n        if (_tokenOut == address(0)) _tokenOut = tokens[tokenOut];\\n        bool ETHIn = _tokenIn == ETH;\\n        bool ETHOut = _tokenOut == ETH;\\n        if (ETHIn) _tokenIn = WETH;\\n        if (ETHOut) _tokenOut = WETH;\\n        uint256 _amountIn = _stringToUint(amountIn, ETHIn ? 18 : _tokenIn.readDecimals());\\n        if (_amountIn >= 1 << 255) revert Overflow();\\n        (address pool, bool zeroForOne) = _computePoolAddress(_tokenIn, _tokenOut);\\n        ISwapRouter(pool).swap(\\n            !ETHOut ? msg.sender : address(this),\\n            zeroForOne,\\n            int256(_amountIn),\\n            zeroForOne ? MIN_SQRT_RATIO_PLUS_ONE : MAX_SQRT_RATIO_MINUS_ONE,\\n            abi.encodePacked(ETHIn, ETHOut, msg.sender, _tokenIn, _tokenOut)\\n        );\\n    }\\n\\n    /// @dev Fallback `uniswapV3SwapCallback`.\\n    /// If ETH is swapped, WETH is forwarded.\\n    fallback() external payable virtual {\\n        int256 amount0Delta;\\n        int256 amount1Delta;\\n        bool ETHIn;\\n        bool ETHOut;\\n        address payer;\\n        address tokenIn;\\n        address tokenOut;\\n        assembly (\\\"memory-safe\\\") {\\n            amount0Delta := calldataload(0x4)\\n            amount1Delta := calldataload(0x24)\\n            ETHIn := byte(0, calldataload(0x84))\\n            ETHOut := byte(0, calldataload(add(0x84, 1)))\\n            payer := shr(96, calldataload(add(0x84, 2)))\\n            tokenIn := shr(96, calldataload(add(0x84, 22)))\\n            tokenOut := shr(96, calldataload(add(0x84, 42)))\\n        }\\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert InvalidSwap();\\n        (address pool, bool zeroForOne) = _computePoolAddress(tokenIn, tokenOut);\\n        if (msg.sender != pool) revert Unauthorized(); // Only pair pool can call.\\n        if (ETHIn) {\\n            _wrapETH(uint256(zeroForOne ? amount0Delta : amount1Delta));\\n        } else {\\n            tokenIn.safeTransferFrom(\\n                payer, msg.sender, uint256(zeroForOne ? amount0Delta : amount1Delta)\\n            );\\n        }\\n        if (ETHOut) {\\n            uint256 amount = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\\n            _unwrapETH(amount);\\n            payer.safeTransferETH(amount);\\n        }\\n    }\\n\\n    /// @dev Computes the create2 address for given token pair.\\n    function _computePoolAddress(address tokenA, address tokenB)\\n        internal\\n        view\\n        virtual\\n        returns (address pool, bool zeroForOne)\\n    {\\n        if (tokenA < tokenB) zeroForOne = true;\\n        else (tokenA, tokenB) = (tokenB, tokenA);\\n        pool = _computePairHash(tokenA, tokenB, 3000); // Mid fee.\\n        if (pool.code.length != 0) return (pool, zeroForOne);\\n        else pool = _computePairHash(tokenA, tokenB, 500); // Low fee.\\n        if (pool.code.length != 0) return (pool, zeroForOne);\\n        else pool = _computePairHash(tokenA, tokenB, 100); // Lowest fee.\\n        if (pool.code.length != 0) return (pool, zeroForOne);\\n        else pool = _computePairHash(tokenA, tokenB, 10000); // Highest fee.\\n        if (pool.code.length != 0) return (pool, zeroForOne);\\n    }\\n\\n    /// @dev Computes the create2 deployment hash for given token pair.\\n    function _computePairHash(address token0, address token1, uint24 fee)\\n        internal\\n        pure\\n        virtual\\n        returns (address pool)\\n    {\\n        bytes32 salt = keccak256(abi.encode(token0, token1, fee));\\n        assembly (\\\"memory-safe\\\") {\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, UNISWAP_V3_POOL_INIT_CODE_HASH)\\n            mstore(0x01, shl(96, UNISWAP_V3_FACTORY))\\n            mstore(0x15, salt)\\n            pool := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore overwritten.\\n        }\\n    }\\n\\n    /// @dev Wraps an `amount` of ETH to WETH and funds pool caller for swap.\\n    function _wrapETH(uint256 amount) internal virtual {\\n        assembly (\\\"memory-safe\\\") {\\n            pop(call(gas(), WETH, amount, codesize(), 0x00, codesize(), 0x00))\\n            mstore(0x14, caller()) // Store the `pool` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            pop(call(gas(), WETH, 0, 0x10, 0x44, codesize(), 0x00))\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Unwraps an `amount` of ETH from WETH for return.\\n    function _unwrapETH(uint256 amount) internal virtual {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x2e1a7d4d) // `withdraw(uint256)`.\\n            mstore(0x20, amount) // Store the `amount` argument.\\n            pop(call(gas(), WETH, 0, 0x1c, 0x24, codesize(), 0x00))\\n        }\\n    }\\n\\n    /// @dev ETH receiver fallback.\\n    receive() external payable virtual {\\n        if (msg.sender != WETH) revert Unauthorized();\\n    }\\n\\n    /// ================== BALANCE & SUPPLY HELPERS ================== ///\\n\\n    /// @dev Returns the balance of a named account in a named token.\\n    function whatIsTheBalanceOf(string calldata name, /*(bob)*/ /*in*/ string calldata token)\\n        public\\n        view\\n        virtual\\n        returns (uint256 balance, uint256 balanceAdjusted)\\n    {\\n        (, address _name,) = whatIsTheAddressOf(name);\\n        string memory normalized = _lowercase(token);\\n        address _token = _returnTokenConstant(bytes32(bytes(normalized)));\\n        if (_token == address(0)) _token = tokens[token];\\n        bool isETH = _token == ETH;\\n        balance = isETH ? _name.balance : _token.balanceOf(_name);\\n        balanceAdjusted = balance / 10 ** (isETH ? 18 : _token.readDecimals());\\n    }\\n\\n    /// @dev Returns the total supply of a named token.\\n    function whatIsTheTotalSupplyOf(string calldata token)\\n        public\\n        view\\n        virtual\\n        returns (uint256 supply, uint256 supplyAdjusted)\\n    {\\n        address _token = _returnTokenConstant(bytes32(bytes(token)));\\n        if (_token == address(0)) _token = tokens[token];\\n        if (_token == ETH) revert InvalidSyntax();\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\\n            if iszero(staticcall(gas(), _token, 0x1c, 0x04, 0x20, 0x20)) {\\n                revert(codesize(), 0x00)\\n            }\\n            supply := mload(0x20)\\n        }\\n        supplyAdjusted = supply / 10 ** _token.readDecimals();\\n    }\\n\\n    /// ====================== ENS VERIFICATION ====================== ///\\n\\n    /// @dev Returns ENS name ownership details.\\n    function whatIsTheAddressOf(string memory name)\\n        public\\n        view\\n        virtual\\n        returns (address owner, address receiver, bytes32 node)\\n    {\\n        node = _namehash(string(abi.encodePacked(name, \\\".eth\\\")));\\n        owner = ENS_REGISTRY.owner(node);\\n        if (IENSHelper(owner) == ENS_WRAPPER) owner = ENS_WRAPPER.ownerOf(uint256(node));\\n        receiver = IENSHelper(ENS_REGISTRY.resolver(node)).addr(node); // Fails on misname.\\n    }\\n\\n    /// @dev Computes an ENS domain namehash.\\n    function _namehash(string memory domain) internal view virtual returns (bytes32 node) {\\n        // Process labels (in reverse order for namehash).\\n        uint256 i = bytes(domain).length;\\n        uint256 lastDot = i;\\n        unchecked {\\n            for (; i != 0; --i) {\\n                bytes1 c = bytes(domain)[i - 1];\\n                if (c == \\\".\\\") {\\n                    node = keccak256(abi.encodePacked(node, _labelhash(domain, i, lastDot)));\\n                    lastDot = i - 1;\\n                    continue;\\n                }\\n                require(c < 0x80);\\n                bytes1 r = _idnamap[uint8(c)];\\n                require(uint8(r) != uint8(Rule.DISALLOWED));\\n                if (uint8(r) > 1) {\\n                    bytes(domain)[i - 1] = r;\\n                }\\n            }\\n        }\\n        return keccak256(abi.encodePacked(node, _labelhash(domain, i, lastDot)));\\n    }\\n\\n    /// @dev Computes an ENS domain labelhash given its start and end.\\n    function _labelhash(string memory domain, uint256 start, uint256 end)\\n        internal\\n        pure\\n        virtual\\n        returns (bytes32 hash)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            hash := keccak256(add(add(domain, 0x20), start), sub(end, start))\\n        }\\n    }\\n\\n    /// ========================= GOVERNANCE ========================= ///\\n\\n    /// @dev Sets a public `name` tag for a given `token` address. Governed by DAO.\\n    function setName(address token, string calldata name) public payable virtual {\\n        if (msg.sender != DAO) revert Unauthorized();\\n        string memory normalized = _lowercase(name);\\n        emit NameSet(tokens[normalized] = token, normalized);\\n    }\\n\\n    /// @dev Sets a public name and ticker for a given `token` address.\\n    function setNameAndTicker(address token) public payable virtual {\\n        string memory normalizedName = _lowercase(token.readName());\\n        string memory normalizedSymbol = _lowercase(token.readSymbol());\\n        emit NameSet(tokens[normalizedName] = token, normalizedName);\\n        emit NameSet(tokens[normalizedSymbol] = token, normalizedSymbol);\\n    }\\n\\n    /// ===================== STRING OPERATIONS ===================== ///\\n\\n    /// @dev Returns copy of string in lowercase.\\n    /// Modified from Solady LibString `toCase`.\\n    function _lowercase(string memory subject)\\n        internal\\n        pure\\n        virtual\\n        returns (string memory result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, 0)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Extracts the first word (action) as bytes32.\\n    function _extraction(string memory normalizedIntent)\\n        internal\\n        pure\\n        virtual\\n        returns (bytes32 result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            let str := add(normalizedIntent, 0x20)\\n            for { let i } lt(i, 0x20) { i := add(i, 1) } {\\n                let char := byte(0, mload(add(str, i)))\\n                if eq(char, 0x20) { break }\\n                result := or(result, shl(sub(248, mul(i, 8)), char))\\n            }\\n        }\\n    }\\n\\n    /// @dev Extract the key words of normalized `send` intent.\\n    function _extractSend(string memory normalizedIntent)\\n        internal\\n        pure\\n        virtual\\n        returns (string memory to, string memory amount, string memory token)\\n    {\\n        string[] memory parts = _split(normalizedIntent, \\\" \\\");\\n        if (parts.length == 4) return (parts[1], parts[2], parts[3]);\\n        if (parts.length == 5) return (parts[4], parts[1], parts[2]);\\n        else revert InvalidSyntax(); // Command is not formatted.\\n    }\\n\\n    /// @dev Extract the key words of normalized `swap` intent.\\n    function _extractSwap(string memory normalizedIntent)\\n        internal\\n        pure\\n        virtual\\n        returns (string memory amountIn, string memory tokenIn, string memory tokenOut)\\n    {\\n        string[] memory parts = _split(normalizedIntent, \\\" \\\");\\n        if (parts.length == 5) return (parts[1], parts[2], parts[4]);\\n        else revert InvalidSyntax(); // Command is not formatted.\\n    }\\n\\n    /// @dev Split the intent into an array of words.\\n    function _split(string memory base, bytes1 delimiter)\\n        internal\\n        pure\\n        virtual\\n        returns (string[] memory parts)\\n    {\\n        unchecked {\\n            bytes memory baseBytes = bytes(base);\\n            uint256 count = 1;\\n            for (uint256 i; i != baseBytes.length; ++i) {\\n                if (baseBytes[i] == delimiter) {\\n                    ++count;\\n                }\\n            }\\n            parts = new string[](count);\\n            uint256 partIndex;\\n            uint256 start;\\n            for (uint256 i; i <= baseBytes.length; ++i) {\\n                if (i == baseBytes.length || baseBytes[i] == delimiter) {\\n                    bytes memory part = new bytes(i - start);\\n                    for (uint256 j = start; j != i; ++j) {\\n                        part[j - start] = baseBytes[j];\\n                    }\\n                    parts[partIndex] = string(part);\\n                    ++partIndex;\\n                    start = i + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert string to decimalized numerical value.\\n    function _stringToUint(string memory s, uint8 decimals)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 result)\\n    {\\n        unchecked {\\n            bool hasDecimal;\\n            uint256 decimalPlaces;\\n            bytes memory b = bytes(s);\\n            for (uint256 i; i != b.length; ++i) {\\n                if (b[i] >= \\\"0\\\" && b[i] <= \\\"9\\\") {\\n                    result = result * 10 + uint8(b[i]) - 48;\\n                    if (hasDecimal) {\\n                        ++decimalPlaces;\\n                        if (decimalPlaces > decimals) {\\n                            break;\\n                        }\\n                    }\\n                } else if (b[i] == \\\".\\\" && !hasDecimal) {\\n                    hasDecimal = true;\\n                } else {\\n                    revert InvalidCharacter();\\n                }\\n            }\\n            if (decimalPlaces < decimals) {\\n                result *= 10 ** (decimals - decimalPlaces);\\n            }\\n        }\\n    }\\n}\\n\\n/// @dev ENS name resolution helper contracts interface.\\ninterface IENSHelper {\\n    function addr(bytes32) external view returns (address);\\n    function owner(bytes32) external view returns (address);\\n    function ownerOf(uint256) external view returns (address);\\n    function resolver(bytes32) external view returns (address);\\n}\\n\\n/// @dev Simple token transfer interface.\\ninterface IToken {\\n    function transfer(address, uint256) external returns (bool);\\n}\\n\\n/// @notice Simple calldata executor interface.\\ninterface IExecutor {\\n    function execute(address, uint256, bytes calldata) external payable returns (bytes memory);\\n}\\n\\n/// @dev Simple Uniswap V3 swapping interface.\\ninterface ISwapRouter {\\n    function swap(address, bool, int256, uint160, bytes calldata)\\n        external\\n        returns (int256, int256);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/MetadataReaderLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for reading contract metadata robustly.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\\nlibrary MetadataReaderLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Default gas stipend for contract reads. High enough for most practical use cases\\n    /// (able to SLOAD about 1000 bytes of data), but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev Default string byte length limit.\\n    uint256 internal constant STRING_LIMIT_DEFAULT = 1000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                METADATA READING OPERATIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Best-effort string reading operations.\\n    // Should NOT revert as long as sufficient gas is provided.\\n    //\\n    // Performs the following in order:\\n    // 1. Returns the empty string for the following cases:\\n    //     - Reverts.\\n    //     - No returndata (e.g. function returns nothing, EOA).\\n    //     - Returns empty string.\\n    // 2. Attempts to `abi.decode` the returndata into a string.\\n    // 3. With any remaining gas, scans the returndata from start to end for the\\n    //    null byte '\\\\0', to interpret the returndata as a null-terminated string.\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"name()\\\"))`.\\n    function readName(address target) internal view returns (string memory) {\\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"name()\\\"), limit)`.\\n    function readName(address target, uint256 limit) internal view returns (string memory) {\\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"name()\\\"), limit, gasStipend)`.\\n    function readName(address target, uint256 limit, uint256 gasStipend)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\\n    }\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"symbol()\\\"))`.\\n    function readSymbol(address target) internal view returns (string memory) {\\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"symbol()\\\"), limit)`.\\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\\\"symbol()\\\"), limit, gasStipend)`.\\n    function readSymbol(address target, uint256 limit, uint256 gasStipend)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\\n    }\\n\\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\\n    /// The string will be truncated to `STRING_LIMIT_DEFAULT` (1000) bytes.\\n    function readString(address target, bytes memory data) internal view returns (string memory) {\\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\\n    /// The string will be truncated to `limit` bytes.\\n    function readString(address target, bytes memory data, uint256 limit)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\\n    /// The string will be truncated to `limit` bytes.\\n    function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return _string(target, _ptr(data), limit, gasStipend);\\n    }\\n\\n    // Best-effort unsigned integer reading operations.\\n    // Should NOT revert as long as sufficient gas is provided.\\n    //\\n    // Performs the following in order:\\n    // 1. Attempts to `abi.decode` the result into a uint256\\n    //    (equivalent across all Solidity uint types, downcast as needed).\\n    // 2. Returns zero for the following cases:\\n    //     - Reverts.\\n    //     - No returndata (e.g. function returns nothing, EOA).\\n    //     - Returns zero.\\n    //     - `abi.decode` failure.\\n\\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\\\"decimal()\\\")))`.\\n    function readDecimals(address target) internal view returns (uint8) {\\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\\n    }\\n\\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\\\"decimal()\\\"), gasStipend))`.\\n    function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\\n    }\\n\\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\\n    }\\n\\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\\n    function readUint(address target, bytes memory data, uint256 gasStipend)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _uint(target, _ptr(data), gasStipend);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Attempts to read and return a string at `target`.\\n    function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\\n        private\\n        view\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function min(x_, y_) -> _z {\\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\\n            }\\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\\n                let m := mload(0x40) // Grab the free memory pointer.\\n                let s := add(0x20, m) // Start of the string's bytes in memory.\\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\\n                if iszero(lt(returndatasize(), 0x40)) {\\n                    let o := mload(0x00) // Load the string's offset in the returndata.\\n                    // If the string's offset is within bounds.\\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\\n                        // If the full string's end is within bounds.\\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\\n                        // for compliance purposes, regardless if the truncated string can fit.\\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\\n                            let n := min(mload(m), limit) // Truncate if needed.\\n                            mstore(m, n) // Overwrite the length.\\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\\n                            result := m\\n                            break\\n                        }\\n                    }\\n                }\\n                // Try interpreting as a null-terminated string.\\n                let n := min(returndatasize(), limit) // Truncate if needed.\\n                returndatacopy(s, 0, n) // Copy the string's bytes.\\n                mstore8(add(s, n), 0) // Place a '\\\\0' at the end.\\n                let i := s // Pointer to the next byte to scan.\\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\\\0'.\\n                mstore(m, sub(i, s)) // Store the string's length.\\n                mstore(i, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\\n                result := m\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Attempts to read and return a uint at `target`.\\n    function _uint(address target, bytes32 ptr, uint256 gasStipend)\\n        private\\n        view\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Casts the function selector `s` into a pointer.\\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Layout the calldata in the scratch space for temporary usage.\\n            mstore(0x04, s) // Store the function selector.\\n            mstore(result, 4) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Casts the `data` into a pointer.\\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := data\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidCharacter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSyntax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"intent\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IE.PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"checkPackedUserOp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"intent\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IE.UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"checkUserOp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"intent\",\"type\":\"string\"}],\"name\":\"command\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"intent\",\"type\":\"string\"}],\"name\":\"previewCommand\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"executeCallData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"amount\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"previewSend\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"executeCallData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"amountIn\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenIn\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenOut\",\"type\":\"string\"}],\"name\":\"previewSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"amount\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setNameAndTicker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"amountIn\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenIn\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenOut\",\"type\":\"string\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"whatIsTheAddressOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"whatIsTheBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceAdjusted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"whatIsTheTotalSupplyOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAdjusted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IE", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}