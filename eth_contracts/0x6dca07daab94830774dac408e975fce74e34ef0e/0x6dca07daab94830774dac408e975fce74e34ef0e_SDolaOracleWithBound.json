{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/SDolaOracleAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================== sDollaOracle ============================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// ====================================================================\\n\\nimport { Timelock2Step } from \\\"frax-std/access-control/v1/Timelock2Step.sol\\\";\\nimport { ITimelock2Step } from \\\"frax-std/access-control/v1/interfaces/ITimelock2Step.sol\\\";\\nimport { DualOracleBase, ConstructorParams as DualOracleBaseParams } from \\\"./DualOracleBase.sol\\\";\\nimport { ICurvePoolEmaPriceOracleWithMinMax } from \\\"interfaces/oracles/abstracts/ICurvePoolEmaPriceOracleWithMinMax.sol\\\";\\nimport { IEmaPriceOracleStableSwapNG } from \\\"interfaces/IEmaPriceOracleStableSwap.sol\\\";\\nimport { ERC165Storage } from \\\"src/contracts/utils/ERC165Storage.sol\\\";\\nimport { UniswapV3SingleTwapOracle, IStaticOracle, ConstructorParams as UniswapV3SingleTwapOracleParams } from \\\"./abstracts/UniswapV3SingleTwapOracle.sol\\\";\\nimport { ChainlinkOracleWithMaxDelay, ConstructorParams as ChainlinkOracleWithMaxDelayParams } from \\\"./abstracts/ChainlinkOracleWithMaxDelay.sol\\\";\\nimport { UsdcUsdChainlinkOracleWithMaxDelay, ConstructorParams as UsdcUsdChainlinkOracleWithMaxDelayParams } from \\\"src/contracts/abstracts/UsdcUsdChainlinkOracleWithMaxDelay.sol\\\";\\nimport { IERC4626 } from \\\"src/contracts/interfaces/IERC4626.sol\\\";\\nimport \\\"interfaces/IDualOracle.sol\\\";\\n\\nstruct ConstructorParams {\\n    address sDollaErc20;\\n    address sDollaOracle;\\n    uint256 minimumOracleBound;\\n    uint256 maximumOracleBound;\\n    uint256 maximumVaultValue;\\n    uint256 maximumOracleDelay;\\n    address timelockAddress;\\n    address uniV3PairAddress;\\n    uint32 twapDuration;\\n    address dolaERC20;\\n    address usdcERC20;\\n    address usdcUsdChainlink;\\n    uint256 usdcUsdChainlinkMaxOracleDelay;\\n}\\n\\ncontract SDolaOracleWithBounds is\\n    DualOracleBase,\\n    Timelock2Step,\\n    ERC165Storage,\\n    ChainlinkOracleWithMaxDelay,\\n    UniswapV3SingleTwapOracle,\\n    UsdcUsdChainlinkOracleWithMaxDelay\\n{\\n    /// @notice SDOLA contract\\n    IERC4626 public immutable SDOLA_ERC20;\\n\\n    /// @notice Minumum price of token1 in token0 units of the EMA\\n    /// @dev Must match precision of EMA\\n    uint256 public minimumOracleBound;\\n\\n    /// @notice Maximum price of token1 in token0 units of the EMA\\n    /// @dev Must match precision of EMA\\n    uint256 public maximumOracleBound;\\n\\n    /// @notice Maximum price of token1 in token0 units of the EMA\\n    /// @dev Must match precision of EMA\\n    uint256 public maxVaultValue;\\n\\n    constructor(\\n        ConstructorParams memory _params\\n    )\\n        DualOracleBase(\\n            DualOracleBaseParams({\\n                baseToken0: address(840),\\n                baseToken0Decimals: 18,\\n                quoteToken0: _params.sDollaErc20,\\n                quoteToken0Decimals: 18,\\n                baseToken1: address(840),\\n                baseToken1Decimals: 18,\\n                quoteToken1: _params.sDollaErc20,\\n                quoteToken1Decimals: 18\\n            })\\n        )\\n        Timelock2Step()\\n        ChainlinkOracleWithMaxDelay(\\n            ChainlinkOracleWithMaxDelayParams({\\n                chainlinkFeedAddress: _params.sDollaOracle,\\n                maximumOracleDelay: _params.maximumOracleDelay\\n            })\\n        )\\n        UniswapV3SingleTwapOracle(\\n            UniswapV3SingleTwapOracleParams({\\n                uniswapV3PairAddress: _params.uniV3PairAddress,\\n                twapDuration: _params.twapDuration,\\n                baseToken: _params.usdcERC20,\\n                quoteToken: _params.dolaERC20\\n            })\\n        )\\n        UsdcUsdChainlinkOracleWithMaxDelay(\\n            UsdcUsdChainlinkOracleWithMaxDelayParams({\\n                usdcUsdChainlinkFeedAddress: _params.usdcUsdChainlink,\\n                usdcUsdMaximumOracleDelay: _params.usdcUsdChainlinkMaxOracleDelay\\n            })\\n        )\\n    {\\n        _setTimelock({ _newTimelock: _params.timelockAddress });\\n\\n        SDOLA_ERC20 = IERC4626(_params.sDollaErc20);\\n        _registerInterface({ interfaceId: type(IDualOracle).interfaceId });\\n        _registerInterface({ interfaceId: type(ITimelock2Step).interfaceId });\\n\\n        minimumOracleBound = _params.minimumOracleBound;\\n        maximumOracleBound = _params.maximumOracleBound;\\n        maxVaultValue = _params.maximumVaultValue;\\n    }\\n\\n    // ====================================================================\\n    // View Helpers\\n    // ====================================================================\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"sDOLA Oracle Adapter w/ Bounds + Uniswap V3 TWAP\\\";\\n    }\\n\\n    // ====================================================================\\n    // Internal Setters\\n    // ====================================================================\\n\\n    /// @notice The ```setMaximumCurvePoolEma``` function sets the maximum price of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _maximumPrice The maximum price of the EMA\\n    function _setMaximumOracleBound(uint256 _maximumPrice) internal {\\n        emit MaximumOracleBoundSet({ oldMaximum: maximumOracleBound, newMaximum: _maximumPrice });\\n        maximumOracleBound = _maximumPrice;\\n    }\\n\\n    /// @notice The ```setEmaMinimum``` function sets the minimum price of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _minimumPrice The minimum price of the EMA\\n    function _setMinimumOracleBound(uint256 _minimumPrice) internal {\\n        emit MinimumOracleBoundSet({ oldMinimum: minimumOracleBound, newMinimum: _minimumPrice });\\n        minimumOracleBound = _minimumPrice;\\n    }\\n\\n    function setMinimumCurvePoolEma(uint256 _minimumPrice) public {\\n        _requireTimelock();\\n        _setMinimumOracleBound(_minimumPrice);\\n    }\\n\\n    function setMaximumCurvePoolEma(uint256 _maximumPrice) public {\\n        _requireTimelock();\\n        _setMaximumOracleBound(_maximumPrice);\\n    }\\n\\n    // ====================================================================\\n    // Configuration Setters\\n    // ====================================================================\\n\\n    /// @notice The ```setMaximumOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @dev Requires msg.sender to be the timelock address\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function setMaximumOracleDelay(uint256 _newMaxOracleDelay) external override {\\n        _requireTimelock();\\n        _setMaximumOracleDelay({ _newMaxOracleDelay: _newMaxOracleDelay });\\n    }\\n\\n    /// @notice The ```setTwapDuration``` function sets the twap duration for the Uniswap V3 TWAP oracle\\n    /// @dev Requires msg.sender to be the timelock address\\n    /// @param _newTwapDuration The new twap duration\\n    function setTwapDuration(uint32 _newTwapDuration) external override {\\n        _requireTimelock();\\n        _setTwapDuration({ _newTwapDuration: _newTwapDuration });\\n    }\\n\\n    /// @notice The ```setMaximumUsdcUsdOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @dev Requires msg.sender to be the timelock address\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function setMaximumUsdcUsdOracleDelay(uint256 _newMaxOracleDelay) external override {\\n        _requireTimelock();\\n        _setMaximumUsdcUsdOracleDelay({ _newMaxOracleDelay: _newMaxOracleDelay });\\n    }\\n\\n    // ====================================================================\\n    // Price Functions\\n    // ====================================================================\\n\\n    /// @notice The ```getUsdPerDolaTwap``` function returns usd per Dola using the Uniswap V3 TWAP oracle & Chainlink\\n    /// @return _isBadData If the Chainlink oracle is stale\\n    // / @return _usdPerDola The USD per Dola price\\n    function getUsdPerDolaTwap() public view returns (bool _isBadData, uint256 _usdPerDola) {\\n        uint256 _dolaPerUsdc = _getUniswapV3Twap();\\n        uint256 _usdPerUsdc;\\n        (_isBadData, , _usdPerUsdc) = _getUsdcUsdChainlinkPrice();\\n        _usdPerDola = (_usdPerUsdc * ORACLE_PRECISION ** 2) / (USDC_USD_CHAINLINK_FEED_PRECISION * _dolaPerUsdc);\\n    }\\n\\n    /// @notice The ```getPricesNormalized``` function returns the normalized prices in human readable form\\n    /// @return _isBadDataNormal If the oracle is stale\\n    /// @return _priceLowNormal The normalized low price\\n    /// @return _priceHighNormal The normalized high price\\n    function getPricesNormalized()\\n        external\\n        view\\n        returns (bool _isBadDataNormal, uint256 _priceLowNormal, uint256 _priceHighNormal)\\n    {\\n        (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) = _getPrices();\\n        _isBadDataNormal = _isBadData;\\n\\n        _priceLowNormal = NORMALIZATION_0 > 0\\n            ? _priceLow * 10 ** uint256(NORMALIZATION_0)\\n            : _priceLow / 10 ** (uint256(-NORMALIZATION_0));\\n\\n        _priceHighNormal = NORMALIZATION_1 > 0\\n            ? _priceHigh * 10 ** uint256(NORMALIZATION_1)\\n            : _priceHigh / 10 ** (uint256(-NORMALIZATION_1));\\n    }\\n\\n    function _getPrices() internal view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) {\\n        (bool _isBadDataDolaOracle, , uint256 usdPerDolaOracle) = _getChainlinkPrice();\\n        (bool _badDataTwap, uint256 _usdPerDolaTwap) = getUsdPerDolaTwap();\\n        uint256 dolaPerSdola = SDOLA_ERC20.previewRedeem(1e18);\\n\\n        // Dola cannot be worth > maximumOracleBound\\n        if (usdPerDolaOracle > maximumOracleBound) usdPerDolaOracle = maximumOracleBound;\\n        if (_usdPerDolaTwap > maximumOracleBound) _usdPerDolaTwap = maximumOracleBound;\\n\\n        // Dola cannot be worth < minimumOracleBound\\n        if (usdPerDolaOracle < minimumOracleBound) usdPerDolaOracle = minimumOracleBound;\\n        if (_usdPerDolaTwap < minimumOracleBound) _usdPerDolaTwap = minimumOracleBound;\\n\\n        // sDola cannot be worth more than the maxVaultValue\\n        if (dolaPerSdola > maxVaultValue) dolaPerSdola = maxVaultValue;\\n\\n        // Scale up for by dolaPerSdola\\n        uint256 usdPersDolaPrice = (dolaPerSdola * usdPerDolaOracle) / ORACLE_PRECISION;\\n        uint256 usdPersDolaTwap = (dolaPerSdola * _usdPerDolaTwap) / ORACLE_PRECISION;\\n\\n        // Invert to sDolaPerUSD price\\n        uint256 _sdolaPerUsdOracle = 1e36 / usdPersDolaPrice;\\n        uint256 _sdolaPerUsdTwap = 1e36 / usdPersDolaTwap;\\n\\n        _isBadData = _badDataTwap || _isBadDataDolaOracle;\\n        _priceLow = _sdolaPerUsdTwap < _sdolaPerUsdOracle ? _sdolaPerUsdTwap : _sdolaPerUsdOracle;\\n        _priceHigh = _sdolaPerUsdOracle > _sdolaPerUsdTwap ? _sdolaPerUsdOracle : _sdolaPerUsdTwap;\\n    }\\n\\n    /// @notice The ```getPrices``` function is intended to return two prices from different oracles\\n    /// @return _isBadData is true when data is stale or otherwise bad\\n    /// @return _priceLow is the lower of the two prices\\n    /// @return _priceHigh is the higher of the two prices\\n    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) {\\n        return _getPrices();\\n    }\\n\\n    /// @notice Override base class for non 1e18 decimals base asset\\n    function _getUniswapV3Twap() internal view override returns (uint256 _twap) {\\n        address[] memory _pools = new address[](1);\\n        _pools[0] = UNI_V3_PAIR_ADDRESS;\\n\\n        _twap = IStaticOracle(0xB210CE856631EeEB767eFa666EC7C1C57738d438).quoteSpecificPoolsWithTimePeriod({\\n            baseAmount: 1e6,\\n            baseToken: UNISWAP_V3_TWAP_BASE_TOKEN,\\n            quoteToken: UNISWAP_V3_TWAP_QUOTE_TOKEN,\\n            pools: _pools,\\n            period: twapDuration\\n        });\\n    }\\n\\n    // ====================================================================\\n    // Events\\n    // ====================================================================\\n\\n    event MaxVaultValueSet(uint256 oldVaultValue, uint256 newVaultValue);\\n    event MaximumOracleBoundSet(uint256 oldMaximum, uint256 newMaximum);\\n    event MinimumOracleBoundSet(uint256 oldMinimum, uint256 newMinimum);\\n}\\n\"\r\n    },\r\n    \"node_modules/frax-standard-solidity/src/access-control/v1/Timelock2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity >=0.8.0;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================== Timelock2Step ===========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\n/// @title Timelock2Step\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @dev Inspired by the OpenZeppelin's Ownable2Step contract\\n/// @notice  An abstract contract which contains 2-step transfer and renounce logic for a timelock address\\nabstract contract Timelock2Step {\\n    /// @notice The pending timelock address\\n    address public pendingTimelockAddress;\\n\\n    /// @notice The current timelock address\\n    address public timelockAddress;\\n\\n    constructor() {\\n        timelockAddress = msg.sender;\\n    }\\n\\n    /// @notice Emitted when timelock is transferred\\n    error OnlyTimelock();\\n\\n    /// @notice Emitted when pending timelock is transferred\\n    error OnlyPendingTimelock();\\n\\n    /// @notice The ```TimelockTransferStarted``` event is emitted when the timelock transfer is initiated\\n    /// @param previousTimelock The address of the previous timelock\\n    /// @param newTimelock The address of the new timelock\\n    event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);\\n\\n    /// @notice The ```TimelockTransferred``` event is emitted when the timelock transfer is completed\\n    /// @param previousTimelock The address of the previous timelock\\n    /// @param newTimelock The address of the new timelock\\n    event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);\\n\\n    /// @notice The ```_isSenderTimelock``` function checks if msg.sender is current timelock address\\n    /// @return Whether or not msg.sender is current timelock address\\n    function _isSenderTimelock() internal view returns (bool) {\\n        return msg.sender == timelockAddress;\\n    }\\n\\n    /// @notice The ```_requireTimelock``` function reverts if msg.sender is not current timelock address\\n    function _requireTimelock() internal view {\\n        if (msg.sender != timelockAddress) revert OnlyTimelock();\\n    }\\n\\n    /// @notice The ```_isSenderPendingTimelock``` function checks if msg.sender is pending timelock address\\n    /// @return Whether or not msg.sender is pending timelock address\\n    function _isSenderPendingTimelock() internal view returns (bool) {\\n        return msg.sender == pendingTimelockAddress;\\n    }\\n\\n    /// @notice The ```_requirePendingTimelock``` function reverts if msg.sender is not pending timelock address\\n    function _requirePendingTimelock() internal view {\\n        if (msg.sender != pendingTimelockAddress) revert OnlyPendingTimelock();\\n    }\\n\\n    /// @notice The ```_transferTimelock``` function initiates the timelock transfer\\n    /// @dev This function is to be implemented by a public function\\n    /// @param _newTimelock The address of the nominated (pending) timelock\\n    function _transferTimelock(address _newTimelock) internal {\\n        pendingTimelockAddress = _newTimelock;\\n        emit TimelockTransferStarted(timelockAddress, _newTimelock);\\n    }\\n\\n    /// @notice The ```_acceptTransferTimelock``` function completes the timelock transfer\\n    /// @dev This function is to be implemented by a public function\\n    function _acceptTransferTimelock() internal {\\n        pendingTimelockAddress = address(0);\\n        _setTimelock(msg.sender);\\n    }\\n\\n    /// @notice The ```_setTimelock``` function sets the timelock address\\n    /// @dev This function is to be implemented by a public function\\n    /// @param _newTimelock The address of the new timelock\\n    function _setTimelock(address _newTimelock) internal {\\n        emit TimelockTransferred(timelockAddress, _newTimelock);\\n        timelockAddress = _newTimelock;\\n    }\\n\\n    /// @notice The ```transferTimelock``` function initiates the timelock transfer\\n    /// @dev Must be called by the current timelock\\n    /// @param _newTimelock The address of the nominated (pending) timelock\\n    function transferTimelock(address _newTimelock) external virtual {\\n        _requireTimelock();\\n        _transferTimelock(_newTimelock);\\n    }\\n\\n    /// @notice The ```acceptTransferTimelock``` function completes the timelock transfer\\n    /// @dev Must be called by the pending timelock\\n    function acceptTransferTimelock() external virtual {\\n        _requirePendingTimelock();\\n        _acceptTransferTimelock();\\n    }\\n\\n    /// @notice The ```renounceTimelock``` function renounces the timelock after setting pending timelock to current timelock\\n    /// @dev Pending timelock must be set to current timelock before renouncing, creating a 2-step renounce process\\n    function renounceTimelock() external virtual {\\n        _requireTimelock();\\n        _requirePendingTimelock();\\n        _transferTimelock(address(0));\\n        _setTimelock(address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/frax-standard-solidity/src/access-control/v1/interfaces/ITimelock2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface ITimelock2Step {\\n    event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);\\n    event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);\\n\\n    function acceptTransferTimelock() external;\\n\\n    function pendingTimelockAddress() external view returns (address);\\n\\n    function renounceTimelock() external;\\n\\n    function timelockAddress() external view returns (address);\\n\\n    function transferTimelock(address _newTimelock) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/DualOracleBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.20;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================== DualOracleBase ==========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// ====================================================================\\n\\nimport \\\"interfaces/IDualOracle.sol\\\";\\n\\nstruct ConstructorParams {\\n    address baseToken0;\\n    uint8 baseToken0Decimals;\\n    address quoteToken0;\\n    uint8 quoteToken0Decimals;\\n    address baseToken1;\\n    uint8 baseToken1Decimals;\\n    address quoteToken1;\\n    uint8 quoteToken1Decimals;\\n}\\n\\n/// @title DualOracleBase\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  Base Contract for Frax Dual Oracles\\nabstract contract DualOracleBase is IDualOracle {\\n    /// @notice The precision of the oracle\\n    uint256 public constant ORACLE_PRECISION = 1e18;\\n\\n    /// @notice The first quote token\\n    address public immutable QUOTE_TOKEN_0;\\n\\n    /// @notice The first quote token decimals\\n    uint256 public immutable QUOTE_TOKEN_0_DECIMALS;\\n\\n    /// @notice The second quote token\\n    address public immutable QUOTE_TOKEN_1;\\n\\n    /// @notice The second quote token decimals\\n    uint256 public immutable QUOTE_TOKEN_1_DECIMALS;\\n\\n    /// @notice The first base token\\n    address public immutable BASE_TOKEN_0;\\n\\n    /// @notice The first base token decimals\\n    uint256 public immutable BASE_TOKEN_0_DECIMALS;\\n\\n    /// @notice The second base token\\n    address public immutable BASE_TOKEN_1;\\n\\n    /// @notice The second base token decimals\\n    uint256 public immutable BASE_TOKEN_1_DECIMALS;\\n\\n    /// @notice The first normalization factor which accounts for different decimals across ERC20s\\n    /// @dev Normalization = quoteTokenDecimals - baseTokenDecimals\\n    int256 public immutable NORMALIZATION_0;\\n\\n    /// @notice The second normalization factor which accounts for different decimals across ERC20s\\n    /// @dev Normalization = quoteTokenDecimals - baseTokenDecimals\\n    int256 public immutable NORMALIZATION_1;\\n\\n    constructor(ConstructorParams memory _params) {\\n        QUOTE_TOKEN_0 = _params.quoteToken0;\\n        QUOTE_TOKEN_0_DECIMALS = _params.quoteToken0Decimals;\\n        QUOTE_TOKEN_1 = _params.quoteToken1;\\n        QUOTE_TOKEN_1_DECIMALS = _params.quoteToken1Decimals;\\n        BASE_TOKEN_0 = _params.baseToken0;\\n        BASE_TOKEN_0_DECIMALS = _params.baseToken0Decimals;\\n        BASE_TOKEN_1 = _params.baseToken1;\\n        BASE_TOKEN_1_DECIMALS = _params.baseToken1Decimals;\\n        NORMALIZATION_0 = int256(QUOTE_TOKEN_0_DECIMALS) - int256(BASE_TOKEN_0_DECIMALS);\\n        NORMALIZATION_1 = int256(QUOTE_TOKEN_1_DECIMALS) - int256(BASE_TOKEN_1_DECIMALS);\\n    }\\n\\n    // ====================================================================\\n    // View Helpers\\n    // ====================================================================\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/ICurvePoolEmaPriceOracleWithMinMax.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICurvePoolEmaPriceOracleWithMinMax is IERC165 {\\n    event SetMaximumCurvePoolEma(uint256 oldMaximum, uint256 newMaximum);\\n    event SetMinimumCurvePoolEma(uint256 oldMinimum, uint256 newMinimum);\\n\\n    function CURVE_POOL_EMA_PRICE_ORACLE() external view returns (address);\\n\\n    function CURVE_POOL_EMA_PRICE_ORACLE_PRECISION() external view returns (uint256);\\n\\n    function getCurvePoolToken1EmaPrice() external view returns (uint256 _emaPrice);\\n\\n    function maximumCurvePoolEma() external view returns (uint256);\\n\\n    function minimumCurvePoolEma() external view returns (uint256);\\n\\n    function setMaximumCurvePoolEma(uint256 _maximumPrice) external;\\n\\n    function setMinimumCurvePoolEma(uint256 _minimumPrice) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IEmaPriceOracleStableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.20;\\n\\ninterface IEmaPriceOracleStableSwap {\\n    function price_oracle() external view returns (uint256);\\n}\\n\\ninterface IEmaPriceOracleStableSwapNG {\\n    function price_oracle(uint256) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/contracts/utils/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\npragma solidity ^0.8.0;\\n\\nimport { ERC165 } from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/UniswapV3SingleTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.20;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ==================== UniswapV3SingleTwapOracle =====================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { IStaticOracle } from \\\"@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\\\";\\nimport { ERC165Storage } from \\\"src/contracts/utils/ERC165Storage.sol\\\";\\nimport { IUniswapV3SingleTwapOracle } from \\\"interfaces/oracles/abstracts/IUniswapV3SingleTwapOracle.sol\\\";\\n\\nstruct ConstructorParams {\\n    address uniswapV3PairAddress;\\n    uint32 twapDuration;\\n    address baseToken;\\n    address quoteToken;\\n}\\n\\n/// @title UniswapV3SingleTwapOracle\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An oracle for UniV3 Twap prices\\n/// @dev When Utilizing this abstract contract ensure that the call to `slot0` returns an `observationCardinality`\\n///      that is > `twapDuration`/`chainBlockTime`. If this is not the case call `increaseObservationCardinalityNext`\\n///      with a parameter which satisfies the above requirement. Failing to do so will result in the oracle\\n///      being suceptible to ddos.\\nabstract contract UniswapV3SingleTwapOracle is ERC165Storage, IUniswapV3SingleTwapOracle {\\n    /// @notice address of the Uniswap V3 pair\\n    address public immutable UNI_V3_PAIR_ADDRESS;\\n\\n    /// @notice The precision of the twap\\n    uint128 public constant TWAP_PRECISION = 1e18;\\n\\n    /// @notice The base token of the twap\\n    address public immutable UNISWAP_V3_TWAP_BASE_TOKEN;\\n\\n    /// @notice The quote token of the twap\\n    address public immutable UNISWAP_V3_TWAP_QUOTE_TOKEN;\\n\\n    /// @notice The duration of the twap\\n    uint32 public twapDuration;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IUniswapV3SingleTwapOracle).interfaceId });\\n\\n        UNI_V3_PAIR_ADDRESS = _params.uniswapV3PairAddress;\\n        twapDuration = _params.twapDuration;\\n        UNISWAP_V3_TWAP_BASE_TOKEN = _params.baseToken;\\n        UNISWAP_V3_TWAP_QUOTE_TOKEN = _params.quoteToken;\\n    }\\n\\n    /// @notice The ```_setTwapDuration``` function sets duration of the twap\\n    /// @param _newTwapDuration The new twap duration\\n    function _setTwapDuration(uint32 _newTwapDuration) internal {\\n        emit SetTwapDuration({ oldTwapDuration: twapDuration, newTwapDuration: _newTwapDuration });\\n        twapDuration = _newTwapDuration;\\n    }\\n\\n    function setTwapDuration(uint32 _newTwapDuration) external virtual;\\n\\n    /// @notice The ```_getUniswapV3Twap``` function is called to get the twap\\n    /// @return _twap The twap price\\n    function _getUniswapV3Twap() internal view virtual returns (uint256 _twap) {\\n        address[] memory _pools = new address[](1);\\n        _pools[0] = UNI_V3_PAIR_ADDRESS;\\n\\n        _twap = IStaticOracle(0xB210CE856631EeEB767eFa666EC7C1C57738d438).quoteSpecificPoolsWithTimePeriod({\\n            baseAmount: TWAP_PRECISION,\\n            baseToken: UNISWAP_V3_TWAP_BASE_TOKEN,\\n            quoteToken: UNISWAP_V3_TWAP_QUOTE_TOKEN,\\n            pools: _pools,\\n            period: twapDuration\\n        });\\n    }\\n\\n    /// @notice The ```getUniswapV3Twap``` function is called to get the twap\\n    /// @return _twap The twap price\\n    function getUniswapV3Twap() external view virtual returns (uint256 _twap) {\\n        _twap = _getUniswapV3Twap();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/ChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.20;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// =================== ChainlinkOracleWithMaxDelay ====================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { ERC165Storage } from \\\"src/contracts/utils/ERC165Storage.sol\\\";\\nimport { IChainlinkOracleWithMaxDelay } from \\\"interfaces/oracles/abstracts/IChainlinkOracleWithMaxDelay.sol\\\";\\n\\nstruct ConstructorParams {\\n    address chainlinkFeedAddress;\\n    uint256 maximumOracleDelay;\\n}\\n\\n/// @title ChainlinkOracleWithMaxDelay\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An abstract oracle for getting prices from Chainlink\\nabstract contract ChainlinkOracleWithMaxDelay is ERC165Storage, IChainlinkOracleWithMaxDelay {\\n    /// @notice Chainlink aggregator\\n    address public immutable CHAINLINK_FEED_ADDRESS;\\n\\n    /// @notice Decimals of ETH/USD chainlink feed\\n    uint8 public immutable CHAINLINK_FEED_DECIMALS;\\n\\n    /// @notice Precision of ETH/USD chainlink feed\\n    uint256 public immutable CHAINLINK_FEED_PRECISION;\\n\\n    /// @notice Maximum delay of Chainlink data, after which it is considered stale\\n    uint256 public maximumOracleDelay;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IChainlinkOracleWithMaxDelay).interfaceId });\\n\\n        CHAINLINK_FEED_ADDRESS = _params.chainlinkFeedAddress;\\n        CHAINLINK_FEED_DECIMALS = AggregatorV3Interface(CHAINLINK_FEED_ADDRESS).decimals();\\n        CHAINLINK_FEED_PRECISION = 10 ** uint256(CHAINLINK_FEED_DECIMALS);\\n        maximumOracleDelay = _params.maximumOracleDelay;\\n    }\\n\\n    /// @notice The ```SetMaximumOracleDelay``` event is emitted when the max oracle delay is set\\n    /// @param oldMaxOracleDelay The old max oracle delay\\n    /// @param newMaxOracleDelay The new max oracle delay\\n    event SetMaximumOracleDelay(uint256 oldMaxOracleDelay, uint256 newMaxOracleDelay);\\n\\n    /// @notice The ```_setMaximumOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function _setMaximumOracleDelay(uint256 _newMaxOracleDelay) internal {\\n        emit SetMaximumOracleDelay({ oldMaxOracleDelay: maximumOracleDelay, newMaxOracleDelay: _newMaxOracleDelay });\\n        maximumOracleDelay = _newMaxOracleDelay;\\n    }\\n\\n    function setMaximumOracleDelay(uint256 _newMaxOracleDelay) external virtual;\\n\\n    function _getChainlinkPrice() internal view returns (bool _isBadData, uint256 _updatedAt, uint256 _price) {\\n        (, int256 _answer, , uint256 _chainlinkUpdatedAt, ) = AggregatorV3Interface(CHAINLINK_FEED_ADDRESS)\\n            .latestRoundData();\\n\\n        // If data is stale or negative, set bad data to true and return\\n        _isBadData = _answer <= 0 || ((block.timestamp - _chainlinkUpdatedAt) > maximumOracleDelay);\\n        _updatedAt = _chainlinkUpdatedAt;\\n        _price = uint256(_answer);\\n    }\\n\\n    /// @notice The ```getChainlinkPrice``` function returns the chainlink price and the timestamp of the last update\\n    /// @dev Uses the same prevision as the chainlink feed, virtual so it can be overridden\\n    /// @return _isBadData True if the data is stale or negative\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _price The price\\n    function getChainlinkPrice() external view virtual returns (bool _isBadData, uint256 _updatedAt, uint256 _price) {\\n        return _getChainlinkPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/UsdcUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.20;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ================ UsdcUsdChainlinkOracleWithMaxDelay =================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// ====================================================================\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { ERC165Storage } from \\\"src/contracts/utils/ERC165Storage.sol\\\";\\nimport { IUsdcUsdChainlinkOracleWithMaxDelay } from \\\"interfaces/oracles/abstracts/IUsdcUsdChainlinkOracleWithMaxDelay.sol\\\";\\n\\nstruct ConstructorParams {\\n    address usdcUsdChainlinkFeedAddress;\\n    uint256 usdcUsdMaximumOracleDelay;\\n}\\n\\n/// @title UsdcUsdChainlinkOracleWithMaxDelay\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An abstract oracle for getting frax/usd prices from Chainlink\\nabstract contract UsdcUsdChainlinkOracleWithMaxDelay is ERC165Storage, IUsdcUsdChainlinkOracleWithMaxDelay {\\n    /// @notice Chainlink aggregator\\n    address public immutable USDC_USD_CHAINLINK_FEED_ADDRESS;\\n\\n    /// @notice Decimals of FRAX/USD chainlink feed\\n    uint8 public immutable USDC_USD_CHAINLINK_FEED_DECIMALS;\\n\\n    /// @notice Precision of FRAX/USD chainlink feed\\n    uint256 public immutable USDC_USD_CHAINLINK_FEED_PRECISION;\\n\\n    /// @notice Maximum delay of Chainlink data, after which it is considered stale\\n    uint256 public maximumUsdcUsdOracleDelay;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IUsdcUsdChainlinkOracleWithMaxDelay).interfaceId });\\n\\n        USDC_USD_CHAINLINK_FEED_ADDRESS = _params.usdcUsdChainlinkFeedAddress;\\n        USDC_USD_CHAINLINK_FEED_DECIMALS = AggregatorV3Interface(USDC_USD_CHAINLINK_FEED_ADDRESS).decimals();\\n        USDC_USD_CHAINLINK_FEED_PRECISION = 10 ** uint256(USDC_USD_CHAINLINK_FEED_DECIMALS);\\n        maximumUsdcUsdOracleDelay = _params.usdcUsdMaximumOracleDelay;\\n    }\\n\\n    /// @notice The ```_setMaximumFraxUsdOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function _setMaximumUsdcUsdOracleDelay(uint256 _newMaxOracleDelay) internal {\\n        emit SetMaximumUsdcUsdOracleDelay({\\n            oldMaxOracleDelay: maximumUsdcUsdOracleDelay,\\n            newMaxOracleDelay: _newMaxOracleDelay\\n        });\\n        maximumUsdcUsdOracleDelay = _newMaxOracleDelay;\\n    }\\n\\n    function setMaximumUsdcUsdOracleDelay(uint256 _newMaxOracleDelay) external virtual;\\n\\n    /// @notice The ```_getUsdcUsdChainlinkPrice``` function is called to get the frax/usd price from Chainlink\\n    /// @dev If data is stale or negative, set bad data to true and return\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerUsdc The Usdc/usd price\\n    function _getUsdcUsdChainlinkPrice()\\n        internal\\n        view\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerUsdc)\\n    {\\n        (, int256 _answer, , uint256 _usdcUsdChainlinkUpdatedAt, ) = AggregatorV3Interface(\\n            USDC_USD_CHAINLINK_FEED_ADDRESS\\n        ).latestRoundData();\\n\\n        // If data is stale or negative, set bad data to true and return\\n        _isBadData = _answer <= 0 || ((block.timestamp - _usdcUsdChainlinkUpdatedAt) > maximumUsdcUsdOracleDelay);\\n        _updatedAt = _usdcUsdChainlinkUpdatedAt;\\n        _usdPerUsdc = uint256(_answer);\\n    }\\n\\n    /// @notice The ```getFraxUsdChainlinkPrice``` function is called to get the frax/usd price from Chainlink\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerFrax The frax/usd price\\n    function getUsdcUsdChainlinkPrice()\\n        external\\n        view\\n        virtual\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerFrax)\\n    {\\n        (_isBadData, _updatedAt, _usdPerFrax) = _getUsdcUsdChainlinkPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\ninterface IERC4626 {\\n    function previewRedeem(uint256) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IDualOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IDualOracle is IERC165 {\\n    function ORACLE_PRECISION() external view returns (uint256);\\n\\n    function BASE_TOKEN_0() external view returns (address);\\n\\n    function BASE_TOKEN_0_DECIMALS() external view returns (uint256);\\n\\n    function BASE_TOKEN_1() external view returns (address);\\n\\n    function BASE_TOKEN_1_DECIMALS() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function getPricesNormalized() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);\\n\\n    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);\\n\\n    function name() external view returns (string memory);\\n\\n    function NORMALIZATION_0() external view returns (int256);\\n\\n    function NORMALIZATION_1() external view returns (int256);\\n\\n    function QUOTE_TOKEN_0() external view returns (address);\\n\\n    function QUOTE_TOKEN_0_DECIMALS() external view returns (uint256);\\n\\n    function QUOTE_TOKEN_1() external view returns (address);\\n\\n    function QUOTE_TOKEN_1_DECIMALS() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\\n\\n/// @title Uniswap V3 Static Oracle\\n/// @notice Oracle contract for calculating price quoting against Uniswap V3\\ninterface IStaticOracle {\\n  /// @notice Returns the address of the Uniswap V3 factory\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return The address of the Uniswap V3 factory\\n  function UNISWAP_V3_FACTORY() external view returns (IUniswapV3Factory);\\n\\n  /// @notice Returns how many observations are needed per minute in Uniswap V3 oracles, on the deployed chain\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return Number of observation that are needed per minute\\n  function CARDINALITY_PER_MINUTE() external view returns (uint8);\\n\\n  /// @notice Returns all supported fee tiers\\n  /// @return The supported fee tiers\\n  function supportedFeeTiers() external view returns (uint24[] memory);\\n\\n  /// @notice Returns whether a specific pair can be supported by the oracle\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return Whether the given pair can be supported by the oracle\\n  function isPairSupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /// @notice Returns all existing pools for the given pair\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return All existing pools for the given pair\\n  function getAllPoolsForPair(address tokenA, address tokenB) external view returns (address[] memory);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying all of the pair's pools\\n  /// @dev If some pools are not configured correctly for the given period, then they will be ignored\\n  /// @dev Will revert if there are no pools available/configured for the pair and period combination\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteAllAvailablePoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified fee tiers\\n  /// @dev Will revert if the pair does not have a pool for one of the given fee tiers, or if one of the pools\\n  /// is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param feeTiers The fee tiers to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteSpecificFeeTiersWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified pools\\n  /// @dev Will revert if one of the pools is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param pools The pools to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  function quoteSpecificPoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    address[] calldata pools,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount);\\n\\n  /// @notice Will initialize all existing pools for the given pair, so that they can be queried with the given period in the future\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize the pair's pools with the specified fee tiers, so that they can be queried with the given period in the future\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize all given pools, so that they can be queried with the given period in the future\\n  /// @param pools The pools to initialize\\n  /// @param period The period that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata pools, uint32 period) external;\\n\\n  /// @notice Will increase observations for all existing pools for the given pair, so they start accruing information for twap calculations\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase the pair's pools with the specified fee tiers observations, so they start accruing information for twap calculations\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase all given pools observations, so they start accruing information for twap calculations\\n  /// @param pools The pools to initialize\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithCardinality(address[] calldata pools, uint16 cardinality) external;\\n\\n  /// @notice Adds support for a new fee tier\\n  /// @dev Will revert if the given tier is invalid, or already supported\\n  /// @param feeTier The new fee tier to add\\n  function addNewFeeTier(uint24 feeTier) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IUniswapV3SingleTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IUniswapV3SingleTwapOracle is IERC165 {\\n    event SetTwapDuration(uint256 oldTwapDuration, uint256 newTwapDuration);\\n\\n    function TWAP_PRECISION() external view returns (uint128);\\n\\n    function UNISWAP_V3_TWAP_BASE_TOKEN() external view returns (address);\\n\\n    function UNISWAP_V3_TWAP_QUOTE_TOKEN() external view returns (address);\\n\\n    function UNI_V3_PAIR_ADDRESS() external view returns (address);\\n\\n    function getUniswapV3Twap() external view returns (uint256 _twap);\\n\\n    function twapDuration() external view returns (uint32);\\n\\n    function setTwapDuration(uint32 _newTwapDuration) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IChainlinkOracleWithMaxDelay is IERC165 {\\n    event SetMaximumOracleDelay(address oracle, uint256 oldMaxOracleDelay, uint256 newMaxOracleDelay);\\n\\n    function CHAINLINK_FEED_ADDRESS() external view returns (address);\\n\\n    function CHAINLINK_FEED_DECIMALS() external view returns (uint8);\\n\\n    function CHAINLINK_FEED_PRECISION() external view returns (uint256);\\n\\n    function getChainlinkPrice() external view returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerEth);\\n\\n    function maximumOracleDelay() external view returns (uint256);\\n\\n    function setMaximumOracleDelay(uint256 _newMaxOracleDelay) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IUsdcUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IUsdcUsdChainlinkOracleWithMaxDelay is IERC165 {\\n    event SetMaximumUsdcUsdOracleDelay(uint256 oldMaxOracleDelay, uint256 newMaxOracleDelay);\\n\\n    function USDC_USD_CHAINLINK_FEED_ADDRESS() external view returns (address);\\n\\n    function USDC_USD_CHAINLINK_FEED_DECIMALS() external view returns (uint8);\\n\\n    function USDC_USD_CHAINLINK_FEED_PRECISION() external view returns (uint256);\\n\\n    function maximumUsdcUsdOracleDelay() external view returns (uint256);\\n\\n    function getUsdcUsdChainlinkPrice()\\n        external\\n        view\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerUsdc);\\n\\n    function setMaximumUsdcUsdOracleDelay(uint256 _newMaxOracleDelay) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"frax-std/=node_modules/frax-standard-solidity/src/\",\r\n      \"script/=src/script/\",\r\n      \"src/=src/\",\r\n      \"test/=src/test/\",\r\n      \"interfaces/=src/contracts/interfaces/\",\r\n      \"arbitrum/=node_modules/@arbitrum/\",\r\n      \"rlp/=node_modules/solidity-rlp/contracts/\",\r\n      \"@solmate/=node_modules/@rari-capital/solmate/src/\",\r\n      \"@arbitrum/=node_modules/@arbitrum/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@mean-finance/=node_modules/@mean-finance/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@rari-capital/=node_modules/@rari-capital/\",\r\n      \"@uniswap/=node_modules/@uniswap/\",\r\n      \"dev-fraxswap/=node_modules/dev-fraxswap/\",\r\n      \"frax-standard-solidity/=node_modules/frax-standard-solidity/\",\r\n      \"prb-math/=node_modules/prb-math/\",\r\n      \"solidity-bytes-utils/=node_modules/solidity-bytes-utils/\",\r\n      \"solidity-rlp/=node_modules/solidity-rlp/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sDollaErc20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sDollaOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumOracleBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumOracleBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumVaultValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumOracleDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"timelockAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV3PairAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"dolaERC20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcERC20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcUsdChainlink\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdcUsdChainlinkMaxOracleDelay\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstructorParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyPendingTimelock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTimelock\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVaultValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVaultValue\",\"type\":\"uint256\"}],\"name\":\"MaxVaultValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaximum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaximum\",\"type\":\"uint256\"}],\"name\":\"MaximumOracleBoundSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimum\",\"type\":\"uint256\"}],\"name\":\"MinimumOracleBoundSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxOracleDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"SetMaximumOracleDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxOracleDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"SetMaximumOracleDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxOracleDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"SetMaximumUsdcUsdOracleDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTwapDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTwapDuration\",\"type\":\"uint256\"}],\"name\":\"SetTwapDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTimelock\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTimelock\",\"type\":\"address\"}],\"name\":\"TimelockTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTimelock\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTimelock\",\"type\":\"address\"}],\"name\":\"TimelockTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_0_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_1_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAINLINK_FEED_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAINLINK_FEED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAINLINK_FEED_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NORMALIZATION_0\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NORMALIZATION_1\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_0_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_1_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SDOLA_ERC20\",\"outputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWAP_PRECISION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_TWAP_BASE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_TWAP_QUOTE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNI_V3_PAIR_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_USD_CHAINLINK_FEED_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_USD_CHAINLINK_FEED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_USD_CHAINLINK_FEED_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptTransferTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHigh\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPricesNormalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadDataNormal\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLowNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHighNormal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapV3Twap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_twap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdPerDolaTwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerDola\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdcUsdChainlinkPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerFrax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxVaultValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumOracleBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumOracleDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumUsdcUsdOracleDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumOracleBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTimelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maximumPrice\",\"type\":\"uint256\"}],\"name\":\"setMaximumCurvePoolEma\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"setMaximumOracleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"setMaximumUsdcUsdOracleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumPrice\",\"type\":\"uint256\"}],\"name\":\"setMinimumCurvePoolEma\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newTwapDuration\",\"type\":\"uint32\"}],\"name\":\"setTwapDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTimelock\",\"type\":\"address\"}],\"name\":\"transferTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twapDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SDolaOracleWithBounds", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000b45ad160634c528cc3d2926d9807104fa3157305000000000000000000000000957a6f1ca411d530f03dbfada93fcfa9ca2e67bc0000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000136dcc951d8c00000000000000000000000000000000000000000000000000000000000000000f3c0000000000000000000000008412ebf45bac1b340bbe8f318b928c466c4e39ca0000000000000000000000007c082bf85e01f9bb343dbb460a14e51f67c58cfb0000000000000000000000000000000000000000000000000000000000000384000000000000000000000000865377367054516e17014ccded1e7d814edc9ce4000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000008fffffd4afb6115b954bd326cbe7b4ba576818f600000000000000000000000000000000000000000000000000000000000152ac", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}