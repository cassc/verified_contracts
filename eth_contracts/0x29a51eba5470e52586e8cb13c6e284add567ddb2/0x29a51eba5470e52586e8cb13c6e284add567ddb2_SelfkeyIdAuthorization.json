{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SafeOwn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// @author Razzor https://twitter.com/razzor_tweet\\npragma solidity 0.8.19;\\n     /**\\n     * @dev Contract defines a 2-step Access Control for the owner of the contract in order\\n     * to avoid risks. Such as accidentally transferring control to an undesired address or renouncing ownership.\\n     * The contracts mitigates these risks by using a 2-step process for ownership transfers and a time margin\\n     * to renounce ownership. The owner can propose the ownership to the new owner, and the pending owner can accept\\n     * the ownership in order to become the new owner. If an undesired address has been passed accidentally, Owner\\n     * can propose the ownership again to the new desired address, thus mitigating the risk of losing control immediately.\\n     * Also, an owner can choose to retain ownership if renounced accidentally prior to future renounce time.\\n     * The Owner can choose not to have this feature of time margin while renouncing ownership, by initialising _renounceInterval as 0.\\n     */\\nabstract contract SafeOwn{\\n    bool private isRenounced;\\n    address private _Owner;\\n    address private _pendingOwner;\\n    uint256 private _renounceTime;\\n    uint256 private _renounceInterval;\\n\\n     /**\\n     * @dev Emitted when the Ownership is transferred or renounced. AtTime may hold\\n     * a future time value, if there exists a _renounceInterval > 0 for renounceOwnership transaction.\\n     */\\n    event ownershipTransferred(address indexed currentOwner, address indexed newOwner, uint256 indexed AtTime);\\n     /**\\n     * @dev Emitted when the Ownership is retained by the current Owner.\\n     */\\n    event ownershipRetained(address indexed currentOwner, uint256 indexed At);\\n\\n     /**\\n     * @notice Initializes the Deployer as the Owner of the contract.\\n     * @param renounceInterval time in seconds after which the Owner will be removed.\\n     */\\n\\n    constructor(uint256 renounceInterval){\\n        _Owner = msg.sender;\\n        _renounceInterval = renounceInterval;\\n        emit ownershipTransferred(address(0), _Owner, block.timestamp);\\n    }\\n     /**\\n     * @notice Throws if the caller is not the Owner.\\n     */\\n\\n    modifier onlyOwner(){\\n        require(Owner() == msg.sender, \\\"SafeOwn: Caller is the not the Owner\\\");\\n        _;\\n    }\\n\\n     /**\\n     * @notice Throws if the caller is not the Pending Owner.\\n     */\\n\\n    modifier onlyPendingOwner(){\\n        require(_pendingOwner == msg.sender, \\\"SafeOwn: Caller is the not the Pending Owner\\\");\\n        _;\\n    }\\n\\n     /**\\n     * @notice Returns the current Owner.\\n     * @dev returns zero address after renounce time, if the Ownership is renounced.\\n     */\\n\\n    function Owner() public view virtual returns(address){\\n        if(block.timestamp >= _renounceTime && isRenounced){\\n            return address(0);\\n        }\\n        else{\\n            return _Owner;\\n        }\\n    }\\n     /**\\n     * @notice Returns the Pending Owner.\\n     */\\n\\n    function pendingOwner() public view virtual returns(address){\\n        return _pendingOwner;\\n    }\\n\\n     /**\\n     * @notice Returns the renounce parameters.\\n     * @return bool value determining whether Owner has called renounceOwnership or not.\\n     * @return Renounce Interval in seconds after which the Ownership will be renounced.\\n     * @return Renounce Time at which the Ownership was/will be renounced. 0 if Ownership retains.\\n     */\\n    function renounceParams() public view virtual returns(bool, uint256, uint256){\\n        return (isRenounced, _renounceInterval, _renounceTime);\\n    }\\n     /**\\n     * @notice Owner can propose ownership to a new Owner(newOwner).\\n     * @dev Owner can not propose ownership, if it has called renounceOwnership and\\n     * not retained the ownership yet.\\n     * @param newOwner address of the new owner to propose ownership to.\\n     */\\n    function proposeOwnership(address newOwner) public virtual onlyOwner{\\n        require(!isRenounced, \\\"SafeOwn: Ownership has been Renounced\\\");\\n        require(newOwner != address(0), \\\"SafeOwn: New Owner can not be a Zero Address\\\");\\n        _pendingOwner = newOwner;\\n    }\\n\\n     /**\\n     * @notice Pending Owner can accept the ownership proposal and become the new Owner.\\n     */\\n    function acceptOwnership() public virtual onlyPendingOwner{\\n        address currentOwner = _Owner;\\n        address newOwner = _pendingOwner;\\n        _Owner = _pendingOwner;\\n        _pendingOwner = address(0);\\n        emit ownershipTransferred(currentOwner, newOwner, block.timestamp);\\n    }\\n\\n     /**\\n     * @notice Owner can renounce ownership. Owner will be removed from the\\n     * contract after _renounceTime.\\n     * @dev Owner will be immediately removed if the _renounceInterval is 0.\\n     * @dev Pending Owner will be immediately removed.\\n     */\\n    function renounceOwnership() public virtual onlyOwner{\\n        require(!isRenounced, \\\"SafeOwn: Already Renounced\\\");\\n        if(_pendingOwner != address(0)){\\n             _pendingOwner = address(0);\\n        }\\n        _renounceTime = block.timestamp + _renounceInterval;\\n        isRenounced = true;\\n        emit ownershipTransferred(_Owner, address(0), _renounceTime);\\n    }\\n\\n     /**\\n     * @notice Owner can retain its ownership and cancel the renouncing(if initiated\\n     * by Owner).\\n     */\\n\\n    function retainOwnership() public virtual onlyOwner{\\n        require(isRenounced, \\\"SafeOwn: Already Retained\\\");\\n        _renounceTime = 0;\\n        isRenounced = false;\\n        emit ownershipRetained(_Owner, block.timestamp);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/SelfkeyIdAuthorization.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: proprietary\\npragma solidity 0.8.19;\\n\\nimport \\\"./SafeOwn.sol\\\";\\n\\ncontract SelfkeyIdAuthorization is SafeOwn {\\n\\n    address public authorizedSigner;\\n    mapping(bytes32 => bool) public executed;\\n\\n    event SignerChanged(address indexed _address);\\n    event PayloadAuthorized(address _from, address _to, uint256 _amount);\\n\\n    constructor(address _signer) SafeOwn(14400) {\\n        require(_signer != address(0), \\\"Invalid authorized signer\\\");\\n        authorizedSigner = _signer;\\n    }\\n\\n    function changeSignerAddress(address _signer) public onlyOwner {\\n        require(_signer != address(0), \\\"Invalid authorized signer\\\");\\n        authorizedSigner = _signer;\\n        emit SignerChanged(_signer);\\n    }\\n\\n    function authorize(address _from, address _to, uint256 _amount, string memory _scope, bytes32 _param, uint _timestamp, address _signer, bytes memory _signature) external {\\n        uint timeLimit = block.timestamp - 4 hours;\\n        require(_timestamp > timeLimit, \\\"Invalid timestamp\\\");\\n        require(_from == msg.sender, \\\"Invalid caller\\\");\\n        require(_to == tx.origin, \\\"Invalid subject\\\");\\n        require(_signer == authorizedSigner, \\\"Invalid signer\\\");\\n        require(verify(_from, _to, _amount, _scope, _param, _timestamp, _signer, _signature), \\\"Verification failed\\\");\\n\\n        bytes32 messageHash = getMessageHash(_from, _to, _amount, _scope, _param, _timestamp);\\n        require(!executed[messageHash], \\\"Payload already used\\\");\\n\\n        executed[messageHash] = true;\\n        emit PayloadAuthorized(_from, _to, _amount);\\n    }\\n\\n    function getMessageHash(address _from, address _to, uint256 _amount, string memory _scope, bytes32 _param, uint _timestamp) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_from, _to, _amount, _scope, _param, _timestamp));\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash));\\n    }\\n\\n    function verify(address _from, address _to, uint256 _amount, string memory _scope, bytes32 _param, uint _timestamp, address _signer, bytes memory signature) public pure returns (bool) {\\n        bytes32 messageHash = getMessageHash(_from, _to, _amount, _scope, _param, _timestamp);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\\n    }\\n\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig) public pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n        assembly {\\n            /*\\n            First 32 bytes stores the length of the signature\\n\\n            add(sig, 32) = pointer of sig + 32\\n            effectively, skips first 32 bytes of signature\\n\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\n            */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n        // implicitly return (r, s, v)\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PayloadAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"At\",\"type\":\"uint256\"}],\"name\":\"ownershipRetained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"AtTime\",\"type\":\"uint256\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_scope\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizedSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"changeSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_scope\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceParams\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retainOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_scope\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SelfkeyIdAuthorization", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b9a775aeef418ed43b6529fa9695daf28899156e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}