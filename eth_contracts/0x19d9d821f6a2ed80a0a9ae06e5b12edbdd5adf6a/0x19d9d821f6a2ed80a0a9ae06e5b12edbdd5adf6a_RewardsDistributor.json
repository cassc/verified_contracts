{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/yield/RewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\n/// Import from Utils /////\\nimport {sTRSY} from \\\"./sTRSY.sol\\\";\\nimport {Ownable} from \\\"src/utils/Ownable.sol\\\";\\n\\n/// Import from Interfaces /////\\nimport {IERC20} from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n///@title RewardsDistributor\\n///@notice Stake TRSY to receive yield accruing sTRSY. Send TRSY to this contract and set vesting\\n/// period to distribute yield in TRSY over time.\\n///        Activate Fyde rewards to receveive Fyde token emissions for sTRSY balance.\\ncontract RewardsDistributor is Ownable {\\n  /*//////////////////////////////////////////////////////////////\\n                            ERRORs\\n  //////////////////////////////////////////////////////////////*/\\n\\n  error ZeroAmount();\\n  error NotAllowed();\\n\\n  event RewardPaid(address indexed user, uint256 reward);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            STORAGE VAR \\n  //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice WETH interface\\n  IERC20 public immutable FYDE;\\n  IERC20 public strsy;\\n\\n  uint256 constant PRECISION = 1e30;\\n\\n  /// @notice The per-second rate at which rewardPerToken increases (1e18 is 1 point per second)\\n  uint256 public rewardRate;\\n\\n  /// @notice The last Unix timestamp (in seconds) when rewardPerTokenStored was updated\\n  uint256 public lastUpdateTime;\\n\\n  /// @notice The last stored rewardPerToken value\\n  uint256 public rewardPerTokenStored;\\n\\n  /// @notice The total tokens staked in the pool\\n  uint256 public totalSupply;\\n\\n  /// @notice The amount of tokens staked by an account\\n  mapping(address => uint256) public balanceOf;\\n\\n  /// @notice The rewardPerToken value when an account last staked/withdrew\\n  mapping(address => uint256) public userRewardPerTokenPaid;\\n\\n  /// @notice The earned() value when an account last staked/withdrew\\n  mapping(address => uint256) public rewards;\\n\\n  mapping(address => bool) public activatedEmissions;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            ADMIN FUNCTIONS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice Sets the reward rate for Fyde emissions\\n  /// @param _rewardRate The new reward rate per second\\n  function setRewardRate(uint256 _rewardRate) external onlyOwner {\\n    // update how much fyde earned so far with old rate\\n    rewardPerTokenStored = rewardPerToken();\\n    lastUpdateTime = block.timestamp;\\n    // update rate\\n    rewardRate = _rewardRate;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            USER FUNCTIONS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  constructor(address _fydeToken, address _strsy) Ownable(msg.sender) {\\n    lastUpdateTime = uint64(block.timestamp);\\n    FYDE = IERC20(_fydeToken);\\n    strsy = IERC20(_strsy);\\n  }\\n\\n  /// @notice Activate Fyde emission for your sTRSY balance\\n  /// @dev sTrsy activates for any user upon staking. If user received strsy via transfer they can\\n  /// activate for themseles and _user is ignored.\\n  function activateFydeEmissions(address _user) external {\\n    if (msg.sender != address(strsy)) _user = msg.sender;\\n    activatedEmissions[_user] = true;\\n    _updateAccounting(_user);\\n  }\\n\\n  function updateAccounting(address _user1, address _user2) public {\\n    _updateAccounting(_user1);\\n    _updateAccounting(_user2);\\n  }\\n\\n  function _updateAccounting(address _user) internal {\\n    if (!activatedEmissions[_user]) return;\\n\\n    // We load var\\n    uint256 rewardPerSTRSY = rewardPerToken();\\n\\n    // Perform state update for fyde points\\n    rewardPerTokenStored = rewardPerSTRSY;\\n    rewards[_user] = earned(_user, balanceOf[_user], rewardPerSTRSY, rewards[_user]);\\n    userRewardPerTokenPaid[_user] = rewardPerSTRSY;\\n\\n    // general\\n    lastUpdateTime = block.timestamp;\\n    totalSupply -= balanceOf[_user];\\n    balanceOf[_user] = strsy.balanceOf(_user);\\n    totalSupply += balanceOf[_user];\\n  }\\n\\n  /// @notice Withdraws all earned rewards\\n  function claimFydeEmissions() external {\\n    /// -----------------------------------------------------------------------\\n    /// Storage loads\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 accountBalance = balanceOf[msg.sender];\\n    uint256 rewardPerToken_ = rewardPerToken();\\n\\n    /// -----------------------------------------------------------------------\\n    /// State updates\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 reward = earned(msg.sender, accountBalance, rewardPerToken_, rewards[msg.sender]);\\n\\n    // accrue rewards\\n    rewardPerTokenStored = rewardPerToken_;\\n    lastUpdateTime = block.timestamp;\\n    userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n    // withdraw rewards\\n    if (reward > 0) {\\n      rewards[msg.sender] = 0;\\n\\n      /// -----------------------------------------------------------------------\\n      /// Effects\\n      /// -----------------------------------------------------------------------\\n\\n      FYDE.transfer(msg.sender, reward);\\n      emit RewardPaid(msg.sender, reward);\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            VIEW FUNCTIONS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /// @notice The amount of reward tokens each staked token has earned so far\\n  function rewardPerToken() public view returns (uint256) {\\n    return totalSupply == 0\\n      ? rewardPerTokenStored\\n      : rewardPerTokenStored\\n        + (PRECISION * (block.timestamp - lastUpdateTime) * rewardRate / totalSupply);\\n  }\\n\\n  function earned(address _user, uint256 _userBalance, uint256 _rewardPerToken, uint256 _userReward)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return\\n      _userReward + _userBalance * (_rewardPerToken - userRewardPerTokenPaid[_user]) / PRECISION;\\n  }\\n\\n  function getReward(address user) external view returns (uint256) {\\n    return earned(user, balanceOf[user], rewardPerToken(), rewards[user]);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/yield/sTRSY.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/// Utils /////\\nimport {RevenueDistributionToken} from \\\"./revenueDistributionToken/RevenueDistributionToken.sol\\\";\\nimport {IRewardsDistributor} from \\\"./IRewardsDistributor.sol\\\";\\n\\ncontract sTRSY is RevenueDistributionToken {\\n  IRewardsDistributor public distributor;\\n\\n  constructor(address _asset)\\n    RevenueDistributionToken(\\\"staked TRSY\\\", \\\"sTRSY\\\", msg.sender, _asset, 1e27)\\n  {}\\n\\n  function setRewardsDistributor(address _distributor) external {\\n    require(msg.sender == owner, \\\"RDT:SPO:NOT_OWNER\\\");\\n    distributor = IRewardsDistributor(_distributor);\\n  }\\n\\n  function _afterTokenTransfer(address from, address to, uint256) internal override {\\n    distributor.updateAccounting(from, to);\\n  }\\n\\n  function _getRewardsDistributor() internal view override returns (IRewardsDistributor) {\\n    return distributor;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\n///@title Ownable contract\\n/// @notice Simple 2step owner authorization combining solmate and OZ implementation\\nabstract contract Ownable {\\n  /*//////////////////////////////////////////////////////////////\\n                             STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Address of the owner\\n  address public owner;\\n\\n  ///@notice Address of the pending owner\\n  address public pendingOwner;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event OwnershipTransferred(address indexed user, address indexed newOner);\\n  event OwnershipTransferStarted(address indexed user, address indexed newOwner);\\n  event OwnershipTransferCanceled(address indexed pendingOwner);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 ERROR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  error Unauthorized();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  constructor(address _owner) {\\n    owner = _owner;\\n\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Transfer ownership to a new address\\n  ///@param newOwner address of the new owner\\n  ///@dev newOwner have to acceptOwnership\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(msg.sender, pendingOwner);\\n  }\\n\\n  ///@notice NewOwner accept the ownership, it transfer the ownership to newOwner\\n  function acceptOwnership() external {\\n    if (msg.sender != pendingOwner) revert Unauthorized();\\n    address oldOwner = owner;\\n    owner = pendingOwner;\\n    delete pendingOwner;\\n    emit OwnershipTransferred(oldOwner, owner);\\n  }\\n\\n  ///@notice Cancel the ownership transfer\\n  function cancelTransferOwnership() external onlyOwner {\\n    emit OwnershipTransferCanceled(pendingOwner);\\n    delete pendingOwner;\\n  }\\n\\n  modifier onlyOwner() {\\n    if (msg.sender != owner) revert Unauthorized();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/RevenueDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\nimport {ERC20Helper} from \\\"./ERC20Helper.sol\\\";\\n\\nimport {IRevenueDistributionToken} from \\\"./IRevenueDistributionToken.sol\\\";\\nimport {IRewardsDistributor} from \\\"../IRewardsDistributor.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551\\n    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d\\n*/\\n\\nabstract contract RevenueDistributionToken is IRevenueDistributionToken, ERC20 {\\n  uint256 public immutable override PRECISION; // Precision of rates, equals max deposit amounts\\n    // before rounding errors occur\\n\\n  address public override asset; // Underlying ERC-20 asset used by ERC-4626 functionality.\\n\\n  address public override owner; // Current owner of the contract, able to update the vesting\\n    // schedule.\\n  address public override pendingOwner; // Pending owner of the contract, able to accept ownership.\\n\\n  uint256 public override freeAssets; // Amount of assets unlocked regardless of time passed.\\n  uint256 public override issuanceRate; // asset/second rate dependent on aggregate vesting\\n    // schedule.\\n  uint256 public override lastUpdated; // Timestamp of when issuance equation was last updated.\\n  uint256 public override vestingPeriodFinish; // Timestamp when current vesting schedule ends.\\n\\n  uint256 private locked = 1; // Used in reentrancy check.\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Modifiers **\\n   */\\n  /**\\n   *\\n   */\\n  modifier nonReentrant() {\\n    require(locked == 1, \\\"RDT:LOCKED\\\");\\n\\n    locked = 2;\\n\\n    _;\\n\\n    locked = 1;\\n  }\\n\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    address owner_,\\n    address asset_,\\n    uint256 precision_\\n  ) ERC20(name_, symbol_, ERC20(asset_).decimals()) {\\n    require((owner = owner_) != address(0), \\\"RDT:C:OWNER_ZERO_ADDRESS\\\");\\n\\n    asset = asset_; // Don't need to check zero address as ERC20(asset_).decimals() will fail in\\n      // ERC20 constructor.\\n    PRECISION = precision_;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Administrative Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function acceptOwnership() external virtual override {\\n    require(msg.sender == pendingOwner, \\\"RDT:AO:NOT_PO\\\");\\n\\n    emit OwnershipAccepted(owner, msg.sender);\\n\\n    owner = msg.sender;\\n    pendingOwner = address(0);\\n  }\\n\\n  function setPendingOwner(address pendingOwner_) external virtual override {\\n    require(msg.sender == owner, \\\"RDT:SPO:NOT_OWNER\\\");\\n\\n    pendingOwner = pendingOwner_;\\n\\n    emit PendingOwnerSet(msg.sender, pendingOwner_);\\n  }\\n\\n  function updateVestingSchedule(uint256 vestingPeriod_)\\n    external\\n    virtual\\n    override\\n    returns (uint256 issuanceRate_, uint256 freeAssets_)\\n  {\\n    require(msg.sender == owner, \\\"RDT:UVS:NOT_OWNER\\\");\\n    require(totalSupply != 0, \\\"RDT:UVS:ZERO_SUPPLY\\\");\\n\\n    // Update \\\"y-intercept\\\" to reflect current available asset.\\n    freeAssets_ = freeAssets = totalAssets();\\n\\n    // Calculate slope.\\n    issuanceRate_ = issuanceRate =\\n      ((ERC20(asset).balanceOf(address(this)) - freeAssets_) * PRECISION) / vestingPeriod_;\\n\\n    // Update timestamp and period finish.\\n    vestingPeriodFinish = (lastUpdated = block.timestamp) + vestingPeriod_;\\n\\n    emit IssuanceParamsUpdated(freeAssets_, issuanceRate_);\\n    emit VestingScheduleUpdated(msg.sender, vestingPeriodFinish);\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Staker Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function deposit(uint256 assets_, address receiver_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 shares_)\\n  {\\n    _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\\n  }\\n\\n  function depositWithPermit(\\n    uint256 assets_,\\n    address receiver_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external virtual override nonReentrant returns (uint256 shares_) {\\n    ERC20(asset).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\\n    _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\\n  }\\n\\n  function mint(uint256 shares_, address receiver_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 assets_)\\n  {\\n    _mint(shares_, assets_ = previewMint(shares_), receiver_, msg.sender);\\n  }\\n\\n  function mintWithPermit(\\n    uint256 shares_,\\n    address receiver_,\\n    uint256 maxAssets_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external virtual override nonReentrant returns (uint256 assets_) {\\n    require((assets_ = previewMint(shares_)) <= maxAssets_, \\\"RDT:MWP:INSUFFICIENT_PERMIT\\\");\\n\\n    ERC20(asset).permit(msg.sender, address(this), maxAssets_, deadline_, v_, r_, s_);\\n    _mint(shares_, assets_, receiver_, msg.sender);\\n  }\\n\\n  function redeem(uint256 shares_, address receiver_, address owner_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 assets_)\\n  {\\n    _burn(shares_, assets_ = previewRedeem(shares_), receiver_, owner_, msg.sender);\\n  }\\n\\n  function withdraw(uint256 assets_, address receiver_, address owner_)\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    returns (uint256 shares_)\\n  {\\n    _burn(shares_ = previewWithdraw(assets_), assets_, receiver_, owner_, msg.sender);\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _mint(uint256 shares_, uint256 assets_, address receiver_, address caller_) internal {\\n    require(receiver_ != address(0), \\\"RDT:M:ZERO_RECEIVER\\\");\\n    require(shares_ != uint256(0), \\\"RDT:M:ZERO_SHARES\\\");\\n    require(assets_ != uint256(0), \\\"RDT:M:ZERO_ASSETS\\\");\\n\\n    _mint(receiver_, shares_);\\n\\n    uint256 freeAssetsCache = freeAssets = totalAssets() + assets_;\\n\\n    uint256 issuanceRate_ = _updateIssuanceParams();\\n\\n    emit Deposit(caller_, receiver_, assets_, shares_);\\n    emit IssuanceParamsUpdated(freeAssetsCache, issuanceRate_);\\n\\n    require(ERC20Helper.transferFrom(asset, caller_, address(this), assets_), \\\"RDT:M:TRANSFER_FROM\\\");\\n    _activateFydeEmissions(receiver_);\\n  }\\n\\n  function _burn(\\n    uint256 shares_,\\n    uint256 assets_,\\n    address receiver_,\\n    address owner_,\\n    address caller_\\n  ) internal {\\n    require(receiver_ != address(0), \\\"RDT:B:ZERO_RECEIVER\\\");\\n    require(shares_ != uint256(0), \\\"RDT:B:ZERO_SHARES\\\");\\n    require(assets_ != uint256(0), \\\"RDT:B:ZERO_ASSETS\\\");\\n\\n    if (caller_ != owner_) _decreaseAllowance(owner_, caller_, shares_);\\n\\n    _burn(owner_, shares_);\\n\\n    uint256 freeAssetsCache = freeAssets = totalAssets() - assets_;\\n\\n    uint256 issuanceRate_ = _updateIssuanceParams();\\n\\n    emit Withdraw(caller_, receiver_, owner_, assets_, shares_);\\n    emit IssuanceParamsUpdated(freeAssetsCache, issuanceRate_);\\n\\n    require(ERC20Helper.transfer(asset, receiver_, assets_), \\\"RDT:B:TRANSFER\\\");\\n  }\\n\\n  function _updateIssuanceParams() internal returns (uint256 issuanceRate_) {\\n    return issuanceRate = (lastUpdated = block.timestamp) > vestingPeriodFinish ? 0 : issuanceRate;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function balanceOfAssets(address account_)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256 balanceOfAssets_)\\n  {\\n    return convertToAssets(balanceOf[account_]);\\n  }\\n\\n  function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply;\\n  }\\n\\n  function convertToShares(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    shares_ = supply == 0 ? assets_ : (assets_ * supply) / totalAssets();\\n  }\\n\\n  function maxDeposit(address receiver_)\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (uint256 maxAssets_)\\n  {\\n    receiver_; // Silence warning\\n    maxAssets_ = type(uint256).max;\\n  }\\n\\n  function maxMint(address receiver_) external pure virtual override returns (uint256 maxShares_) {\\n    receiver_; // Silence warning\\n    maxShares_ = type(uint256).max;\\n  }\\n\\n  function maxRedeem(address owner_) external view virtual override returns (uint256 maxShares_) {\\n    maxShares_ = balanceOf[owner_];\\n  }\\n\\n  function maxWithdraw(address owner_) external view virtual override returns (uint256 maxAssets_) {\\n    maxAssets_ = balanceOfAssets(owner_);\\n  }\\n\\n  function previewDeposit(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round DOWN if it\u2019s calculating the amount of shares to issue to a user, given an\\n    // amount of assets provided.\\n    shares_ = convertToShares(assets_);\\n  }\\n\\n  function previewMint(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round UP if it\u2019s calculating the amount of assets a user must provide, to be\\n    // issued a given amount of shares.\\n    assets_ = supply == 0 ? shares_ : _divRoundUp(shares_ * totalAssets(), supply);\\n  }\\n\\n  function previewRedeem(uint256 shares_) public view virtual override returns (uint256 assets_) {\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round DOWN if it\u2019s calculating the amount of assets to send to a user, given\\n    // amount of shares returned.\\n    assets_ = convertToAssets(shares_);\\n  }\\n\\n  function previewWithdraw(uint256 assets_) public view virtual override returns (uint256 shares_) {\\n    uint256 supply = totalSupply; // Cache to stack.\\n\\n    // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\\n    // it should round UP if it\u2019s calculating the amount of shares a user must return, to be sent\\n    // a given amount of assets.\\n    shares_ = supply == 0 ? assets_ : _divRoundUp(assets_ * supply, totalAssets());\\n  }\\n\\n  function totalAssets() public view virtual override returns (uint256 totalManagedAssets_) {\\n    uint256 issuanceRate_ = issuanceRate;\\n\\n    if (issuanceRate_ == 0) return freeAssets;\\n\\n    uint256 vestingPeriodFinish_ = vestingPeriodFinish;\\n    uint256 lastUpdated_ = lastUpdated;\\n\\n    uint256 vestingTimePassed = block.timestamp > vestingPeriodFinish_\\n      ? vestingPeriodFinish_ - lastUpdated_\\n      : block.timestamp - lastUpdated_;\\n\\n    return ((issuanceRate_ * vestingTimePassed) / PRECISION) + freeAssets;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _divRoundUp(uint256 numerator_, uint256 divisor_)\\n    internal\\n    pure\\n    returns (uint256 result_)\\n  {\\n    return (numerator_ / divisor_) + (numerator_ % divisor_ > 0 ? 1 : 0);\\n  }\\n\\n  function _activateFydeEmissions(address _user) internal {\\n    _getRewardsDistributor().activateFydeEmissions(_user);\\n  }\\n\\n  function _getRewardsDistributor() internal view virtual returns (IRewardsDistributor);\\n}\\n\"\r\n    },\r\n    \"src/yield/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.19;\\n\\ninterface IRewardsDistributor {\\n  function updateAccounting(address _user1, address _user2) external;\\n  function activateFydeEmissions(address _user) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551          \u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551         \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\\n*/\\n\\n/**\\n *  @title Modern ERC-20 implementation.\\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\\n */\\ncontract ERC20 is IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * ERC-20 **\\n   */\\n  /**\\n   *\\n   */\\n  string public override name;\\n  string public override symbol;\\n\\n  uint8 public override decimals;\\n\\n  uint256 public override totalSupply;\\n\\n  mapping(address => uint256) public override balanceOf;\\n\\n  mapping(address => mapping(address => uint256)) public override allowance;\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * ERC-2612 **\\n   */\\n  /**\\n   *\\n   */\\n\\n  // PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256\\n  // nonce,uint256 deadline)\\\");\\n  bytes32 public constant override PERMIT_TYPEHASH =\\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  mapping(address => uint256) public override nonces;\\n\\n  /**\\n   *  @param name_     The name of the token.\\n   *  @param symbol_   The symbol of the token.\\n   *  @param decimals_ The decimal precision used by the token.\\n   */\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n    decimals = decimals_;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * External Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function approve(address spender_, uint256 amount_) external override returns (bool success_) {\\n    _approve(msg.sender, spender_, amount_);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender_, uint256 subtractedAmount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _decreaseAllowance(msg.sender, spender_, subtractedAmount_);\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender_, uint256 addedAmount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\\n    return true;\\n  }\\n\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 amount_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external override {\\n    require(deadline_ >= block.timestamp, \\\"ERC20:P:EXPIRED\\\");\\n\\n    // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf),\\n    // defines\\n    // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.\\n    require(\\n      uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0)\\n        && (v_ == 27 || v_ == 28),\\n      \\\"ERC20:P:MALLEABLE\\\"\\n    );\\n\\n    // Nonce realistically cannot overflow.\\n    unchecked {\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR(),\\n          keccak256(\\n            abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_)\\n          )\\n        )\\n      );\\n\\n      address recoveredAddress = ecrecover(digest, v_, r_, s_);\\n\\n      require(recoveredAddress == owner_ && owner_ != address(0), \\\"ERC20:P:INVALID_SIGNATURE\\\");\\n    }\\n\\n    _approve(owner_, spender_, amount_);\\n  }\\n\\n  function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\\n    _transfer(msg.sender, recipient_, amount_);\\n    return true;\\n  }\\n\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    override\\n    returns (bool success_)\\n  {\\n    _decreaseAllowance(owner_, msg.sender, amount_);\\n    _transfer(owner_, recipient_, amount_);\\n    return true;\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function DOMAIN_SEPARATOR() public view override returns (bytes32 domainSeparator_) {\\n    return keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(name)),\\n        keccak256(bytes(\\\"1\\\")),\\n        block.chainid,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function _approve(address owner_, address spender_, uint256 amount_) internal {\\n    emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\\n  }\\n\\n  function _burn(address owner_, uint256 amount_) internal {\\n    balanceOf[owner_] -= amount_;\\n\\n    // Cannot underflow because a user's balance will never be larger than the total supply.\\n    unchecked {\\n      totalSupply -= amount_;\\n    }\\n\\n    emit Transfer(owner_, address(0), amount_);\\n\\n    _afterTokenTransfer(owner_, address(0x0), amount_);\\n  }\\n\\n  function _decreaseAllowance(address owner_, address spender_, uint256 subtractedAmount_) internal {\\n    uint256 spenderAllowance = allowance[owner_][spender_]; // Cache to memory.\\n\\n    if (spenderAllowance != type(uint256).max) {\\n      _approve(owner_, spender_, spenderAllowance - subtractedAmount_);\\n    }\\n  }\\n\\n  function _mint(address recipient_, uint256 amount_) internal {\\n    totalSupply += amount_;\\n\\n    // Cannot overflow because totalSupply would first overflow in the statement above.\\n    unchecked {\\n      balanceOf[recipient_] += amount_;\\n    }\\n\\n    emit Transfer(address(0), recipient_, amount_);\\n\\n    _afterTokenTransfer(address(0x0), recipient_, amount_);\\n  }\\n\\n  function _transfer(address owner_, address recipient_, uint256 amount_) internal {\\n    balanceOf[owner_] -= amount_;\\n\\n    // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances ==\\n    // totalSupply.\\n    unchecked {\\n      balanceOf[recipient_] += amount_;\\n    }\\n\\n    emit Transfer(owner_, recipient_, amount_);\\n\\n    _afterTokenTransfer(owner_, recipient_, amount_);\\n  }\\n\\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/ERC20Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\nimport {IERC20Like} from \\\"./IERC20Like.sol\\\";\\n\\n/**\\n * @title Small Library to standardize erc20 token interactions.\\n */\\nlibrary ERC20Helper {\\n  /**\\n   *\\n   */\\n  /**\\n   * Internal Functions **\\n   */\\n  /**\\n   *\\n   */\\n  function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\\n    return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\\n  }\\n\\n  function transferFrom(address token_, address from_, address to_, uint256 amount_)\\n    internal\\n    returns (bool success_)\\n  {\\n    return\\n      _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\\n  }\\n\\n  function approve(address token_, address spender_, uint256 amount_)\\n    internal\\n    returns (bool success_)\\n  {\\n    // If setting approval to zero fails, return false.\\n    if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) {\\n      return false;\\n    }\\n\\n    // If `amount_` is zero, return true as the previous step already did this.\\n    if (amount_ == uint256(0)) return true;\\n\\n    // Return the result of setting the approval to `amount_`.\\n    return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\\n  }\\n\\n  function _call(address token_, bytes memory data_) private returns (bool success_) {\\n    if (token_.code.length == uint256(0)) return false;\\n\\n    bytes memory returnData;\\n    (success_, returnData) = token_.call(data_);\\n\\n    return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IRevenueDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\nimport {IERC4626} from \\\"./IERC4626.sol\\\";\\n\\n/// @title A token that represents ownership of future revenues distributed linearly over time.\\ninterface IRevenueDistributionToken is IERC20, IERC4626 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   Issuance parameters have been updated after a `_mint` or `_burn`.\\n   *  @param freeAssets_   Resulting `freeAssets` (y-intercept) value after accounting update.\\n   *  @param issuanceRate_ The new issuance rate of `asset` until `vestingPeriodFinish_`.\\n   */\\n  event IssuanceParamsUpdated(uint256 freeAssets_, uint256 issuanceRate_);\\n\\n  /**\\n   *  @dev   `newOwner_` has accepted the transferral of RDT ownership from `previousOwner_`.\\n   *  @param previousOwner_ The previous RDT owner.\\n   *  @param newOwner_      The new RDT owner.\\n   */\\n  event OwnershipAccepted(address indexed previousOwner_, address indexed newOwner_);\\n\\n  /**\\n   *  @dev   `owner_` has set the new pending owner of RDT to `pendingOwner_`.\\n   *  @param owner_        The current RDT owner.\\n   *  @param pendingOwner_ The new pending RDT owner.\\n   */\\n  event PendingOwnerSet(address indexed owner_, address indexed pendingOwner_);\\n\\n  /**\\n   *  @dev   `owner_` has updated the RDT vesting schedule to end at `vestingPeriodFinish_`.\\n   *  @param owner_               The current RDT owner.\\n   *  @param vestingPeriodFinish_ When the unvested balance will finish vesting.\\n   */\\n  event VestingScheduleUpdated(address indexed owner_, uint256 vestingPeriodFinish_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Variables **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev The total amount of the underlying asset that is currently unlocked and is not\\n   * time-dependent.\\n   *       Analogous to the y-intercept in a linear function.\\n   */\\n  function freeAssets() external view returns (uint256 freeAssets_);\\n\\n  /**\\n   *  @dev The rate of issuance of the vesting schedule that is currently active.\\n   *       Denominated as the amount of underlying assets vesting per second.\\n   */\\n  function issuanceRate() external view returns (uint256 issuanceRate_);\\n\\n  /**\\n   *  @dev The timestamp of when the linear function was last recalculated.\\n   *       Analogous to t0 in a linear function.\\n   */\\n  function lastUpdated() external view returns (uint256 lastUpdated_);\\n\\n  /**\\n   *  @dev The address of the account that is allowed to update the vesting schedule.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   *  @dev The next owner, nominated by the current owner.\\n   */\\n  function pendingOwner() external view returns (address pendingOwner_);\\n\\n  /**\\n   *  @dev The precision at which the issuance rate is measured.\\n   */\\n  function PRECISION() external view returns (uint256 precision_);\\n\\n  /**\\n   *  @dev The end of the current vesting schedule.\\n   */\\n  function vestingPeriodFinish() external view returns (uint256 vestingPeriodFinish_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Administrative Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev Sets the pending owner as the new owner.\\n   *       Can be called only by the pending owner, and only after their nomination by the current\\n   * owner.\\n   */\\n  function acceptOwnership() external;\\n\\n  /**\\n   *  @dev   Sets a new address as the pending owner.\\n   *  @param pendingOwner_ The address of the next potential owner.\\n   */\\n  function setPendingOwner(address pendingOwner_) external;\\n\\n  /**\\n   *  @dev    Updates the current vesting formula based on the amount of total unvested funds in the\\n   * contract and the new `vestingPeriod_`.\\n   *  @param  vestingPeriod_ The amount of time over which all currently unaccounted underlying\\n   * assets will be vested over.\\n   *  @return issuanceRate_  The new issuance rate.\\n   *  @return freeAssets_    The new amount of underlying assets that are unlocked.\\n   */\\n  function updateVestingSchedule(uint256 vestingPeriod_)\\n    external\\n    returns (uint256 issuanceRate_, uint256 freeAssets_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * Staker Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Does a ERC4626 `deposit` with a ERC-2612 `permit`.\\n   *  @param  assets_   The amount of `asset` to deposit.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @param  deadline_ The timestamp after which the `permit` signature is no longer valid.\\n   *  @param  v_        ECDSA signature v component.\\n   *  @param  r_        ECDSA signature r component.\\n   *  @param  s_        ECDSA signature s component.\\n   *  @return shares_   The amount of shares minted.\\n   */\\n  function depositWithPermit(\\n    uint256 assets_,\\n    address receiver_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Does a ERC4626 `mint` with a ERC-2612 `permit`.\\n   *  @param  shares_    The amount of `shares` to mint.\\n   *  @param  receiver_  The receiver of the shares.\\n   *  @param  maxAssets_ The maximum amount of assets that can be taken, as per the permit.\\n   *  @param  deadline_  The timestamp after which the `permit` signature is no longer valid.\\n   *  @param  v_         ECDSA signature v component.\\n   *  @param  r_         ECDSA signature r component.\\n   *  @param  s_         ECDSA signature s component.\\n   *  @return assets_    The amount of shares deposited.\\n   */\\n  function mintWithPermit(\\n    uint256 shares_,\\n    address receiver_,\\n    uint256 maxAssets_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external returns (uint256 assets_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Returns the amount of underlying assets owned by the specified account.\\n   *  @param  account_ Address of the account.\\n   *  @return assets_  Amount of assets owned.\\n   */\\n  function balanceOfAssets(address account_) external view returns (uint256 assets_);\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @title Interface of the ERC20 standard as defined in the EIP, including EIP-2612 permit\\n/// functionality.\\ninterface IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   Emitted when one account has set the allowance of another account over their tokens.\\n   *  @param owner_   Account that tokens are approved from.\\n   *  @param spender_ Account that tokens are approved for.\\n   *  @param amount_  Amount of tokens that have been approved.\\n   */\\n  event Approval(address indexed owner_, address indexed spender_, uint256 amount_);\\n\\n  /**\\n   *  @dev   Emitted when tokens have moved from one account to another.\\n   *  @param owner_     Account that tokens have moved from.\\n   *  @param recipient_ Account that tokens have moved to.\\n   *  @param amount_    Amount of tokens that have been transferred.\\n   */\\n  event Transfer(address indexed owner_, address indexed recipient_, uint256 amount_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * External Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Function that allows one account to set the allowance of another account over their\\n   * tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_ Account that tokens are approved for.\\n   *  @param  amount_  Amount of tokens that have been approved.\\n   *  @return success_ Boolean indicating whether the operation succeeded.\\n   */\\n  function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n  /**\\n   *  @dev    Function that allows one account to decrease the allowance of another account over\\n   * their tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_          Account that tokens are approved for.\\n   *  @param  subtractedAmount_ Amount to decrease approval by.\\n   *  @return success_          Boolean indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address spender_, uint256 subtractedAmount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *  @dev    Function that allows one account to increase the allowance of another account over\\n   * their tokens.\\n   *          Emits an {Approval} event.\\n   *  @param  spender_     Account that tokens are approved for.\\n   *  @param  addedAmount_ Amount to increase approval by.\\n   *  @return success_     Boolean indicating whether the operation succeeded.\\n   */\\n  function increaseAllowance(address spender_, uint256 addedAmount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *  @dev   Approve by signature.\\n   *  @param owner_    Owner address that signed the permit.\\n   *  @param spender_  Spender of the permit.\\n   *  @param amount_   Permit approval spend limit.\\n   *  @param deadline_ Deadline after which the permit is invalid.\\n   *  @param v_        ECDSA signature v component.\\n   *  @param r_        ECDSA signature r component.\\n   *  @param s_        ECDSA signature s component.\\n   */\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 amount_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n\\n  /**\\n   *  @dev    Moves an amount of tokens from `msg.sender` to a specified account.\\n   *          Emits a {Transfer} event.\\n   *  @param  recipient_ Account that receives tokens.\\n   *  @param  amount_    Amount of tokens that are transferred.\\n   *  @return success_   Boolean indicating whether the operation succeeded.\\n   */\\n  function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n  /**\\n   *  @dev    Moves a pre-approved amount of tokens from a sender to a specified account.\\n   *          Emits a {Transfer} event.\\n   *          Emits an {Approval} event.\\n   *  @param  owner_     Account that tokens are moving from.\\n   *  @param  recipient_ Account that receives tokens.\\n   *  @param  amount_    Amount of tokens that are transferred.\\n   *  @return success_   Boolean indicating whether the operation succeeded.\\n   */\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    returns (bool success_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Returns the allowance that one account has given another over their tokens.\\n   *  @param  owner_     Account that tokens are approved from.\\n   *  @param  spender_   Account that tokens are approved for.\\n   *  @return allowance_ Allowance that one account has given another over their tokens.\\n   */\\n  function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\\n\\n  /**\\n   *  @dev    Returns the amount of tokens owned by a given account.\\n   *  @param  account_ Account that owns the tokens.\\n   *  @return balance_ Amount of tokens owned by a given account.\\n   */\\n  function balanceOf(address account_) external view returns (uint256 balance_);\\n\\n  /**\\n   *  @dev    Returns the decimal precision used by the token.\\n   *  @return decimals_ The decimal precision used by the token.\\n   */\\n  function decimals() external view returns (uint8 decimals_);\\n\\n  /**\\n   *  @dev    Returns the signature domain separator.\\n   *  @return domainSeparator_ The signature domain separator.\\n   */\\n  function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator_);\\n\\n  /**\\n   *  @dev    Returns the name of the token.\\n   *  @return name_ The name of the token.\\n   */\\n  function name() external view returns (string memory name_);\\n\\n  /**\\n   *  @dev    Returns the nonce for the given owner.\\n   *  @param  owner_  The address of the owner account.\\n   *  @return nonce_ The nonce for the given owner.\\n   */\\n  function nonces(address owner_) external view returns (uint256 nonce_);\\n\\n  /**\\n   *  @dev    Returns the permit type hash.\\n   *  @return permitTypehash_ The permit type hash.\\n   */\\n  function PERMIT_TYPEHASH() external view returns (bytes32 permitTypehash_);\\n\\n  /**\\n   *  @dev    Returns the symbol of the token.\\n   *  @return symbol_ The symbol of the token.\\n   */\\n  function symbol() external view returns (string memory symbol_);\\n\\n  /**\\n   *  @dev    Returns the total amount of tokens in existence.\\n   *  @return totalSupply_ The total amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256 totalSupply_);\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC20Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\n/// @title Interface of the ERC20 standard as needed by ERC20Helper.\\ninterface IERC20Like {\\n  function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n  function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n  function transferFrom(address owner_, address recipient_, uint256 amount_)\\n    external\\n    returns (bool success_);\\n}\\n\"\r\n    },\r\n    \"src/yield/revenueDistributionToken/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/// @title A standard for tokenized Vaults with a single underlying ERC-20 token.\\ninterface IERC4626 is IERC20 {\\n  /**\\n   *\\n   */\\n  /**\\n   * Events **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev   `caller_` has exchanged `assets_` for `shares_` and transferred them to `owner_`.\\n   *         MUST be emitted when assets are deposited via the `deposit` or `mint` methods.\\n   *  @param caller_ The caller of the function that emitted the `Deposit` event.\\n   *  @param owner_  The owner of the shares.\\n   *  @param assets_ The amount of assets deposited.\\n   *  @param shares_ The amount of shares minted.\\n   */\\n  event Deposit(address indexed caller_, address indexed owner_, uint256 assets_, uint256 shares_);\\n\\n  /**\\n   *  @dev   `caller_`\u00a0has exchanged\u00a0`shares_`, owned by\u00a0`owner_`, for\u00a0`assets_`, and\\n   * transferred them\u00a0to\u00a0`receiver_`.\\n   *         MUST be emitted when assets are withdrawn via the\u00a0`withdraw`\u00a0or\u00a0`redeem`\u00a0methods.\\n   *  @param caller_   The caller of the function that emitted the `Withdraw` event.\\n   *  @param receiver_ The receiver of the assets.\\n   *  @param owner_    The owner of the shares.\\n   *  @param assets_   The amount of assets withdrawn.\\n   *  @param shares_   The amount of shares burned.\\n   */\\n  event Withdraw(\\n    address indexed caller_,\\n    address indexed receiver_,\\n    address indexed owner_,\\n    uint256 assets_,\\n    uint256 shares_\\n  );\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Variables **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    The address of the underlying asset used by the Vault.\\n   *          MUST be a contract that implements the ERC-20 standard.\\n   *          MUST NOT revert.\\n   *  @return asset_ The address of the underlying asset.\\n   */\\n  function asset() external view returns (address asset_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * State Changing Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\n   *          MUST emit the {Deposit} event.\\n   *          MUST revert if all of the assets cannot be deposited (due to insufficient approval,\\n   * deposit limits, slippage, etc).\\n   *  @param  assets_   The amount of assets to deposit.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return shares_   The amount of shares minted.\\n   */\\n  function deposit(uint256 assets_, address receiver_) external returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\n   *          MUST emit the {Deposit} event.\\n   *          MUST revert if all of shares cannot be minted (due to insufficient approval, deposit\\n   * limits, slippage, etc).\\n   *  @param  shares_   The amount of shares to mint.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return assets_   The amount of assets deposited.\\n   */\\n  function mint(uint256 shares_, address receiver_) external returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends\u00a0`assets_` to\u00a0`receiver_`.\\n   *          MUST emit the\u00a0{Withdraw}\u00a0event.\\n   *          MUST revert if all of\u00a0the shares\u00a0cannot be redeemed (due to insufficient shares,\\n   * withdrawal limits, slippage, etc).\\n   *  @param  shares_   The amount of shares to redeem.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @param  owner_    The owner of the shares.\\n   *  @return assets_   The amount of assets sent to the receiver.\\n   */\\n  function redeem(uint256 shares_, address receiver_, address owner_)\\n    external\\n    returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends `assets_`\u00a0to `receiver_`.\\n   *          MUST emit the\u00a0{Withdraw}\u00a0event.\\n   *          MUST revert if all of\u00a0the assets\u00a0cannot be withdrawn (due to insufficient assets,\\n   * withdrawal limits, slippage, etc).\\n   *  @param  assets_   The amount of assets to withdraw.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @param  owner_    The owner of the assets.\\n   *  @return shares_   The amount of shares burned from the owner.\\n   */\\n  function withdraw(uint256 assets_, address receiver_, address owner_)\\n    external\\n    returns (uint256 shares_);\\n\\n  /**\\n   *\\n   */\\n  /**\\n   * View Functions **\\n   */\\n  /**\\n   *\\n   */\\n\\n  /**\\n   *  @dev    The amount of `assets_` the `shares_` are currently equivalent to.\\n   *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   *          MUST NOT reflect slippage or other on-chain conditions when performing the actual\\n   * exchange.\\n   *          MUST NOT show any variations depending on the caller.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to convert.\\n   *  @return assets_ The amount of equivalent assets.\\n   */\\n  function convertToAssets(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    The amount of `shares_` the `assets_` are currently equivalent to.\\n   *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   *          MUST NOT reflect slippage or other on-chain conditions when performing the actual\\n   * exchange.\\n   *          MUST NOT show any variations depending on the caller.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to convert.\\n   *  @return shares_ The amount of equivalent shares.\\n   */\\n  function convertToShares(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `assets_` that can be deposited on behalf of the `receiver_` through\\n   * a `deposit` call.\\n   *          MUST return a limited value if the receiver is subject to any limits, or the maximum\\n   * value otherwise.\\n   *          MUST NOT revert.\\n   *  @param  receiver_ The receiver of the assets.\\n   *  @return assets_   The maximum amount of assets that can be deposited.\\n   */\\n  function maxDeposit(address receiver_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Maximum amount of `shares_` that can be minted on behalf of the `receiver_` through a\\n   * `mint` call.\\n   *          MUST return a limited value if the receiver is subject to any limits, or the maximum\\n   * value otherwise.\\n   *          MUST NOT revert.\\n   *  @param  receiver_ The receiver of the shares.\\n   *  @return shares_   The maximum amount of shares that can be minted.\\n   */\\n  function maxMint(address receiver_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `shares_` that can be redeemed from the\u00a0`owner_` through\\n   * a\u00a0`redeem`\u00a0call.\\n   *          MUST return a limited value if\u00a0the owner\u00a0is subject to any limits, or the total\\n   * amount of owned shares otherwise.\\n   *          MUST\u00a0NOT\u00a0revert.\\n   *  @param  owner_  The owner of the shares.\\n   *  @return shares_ The maximum amount of shares that can be redeemed.\\n   */\\n  function maxRedeem(address owner_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Maximum amount of `assets_` that can be withdrawn from the `owner_` through a\\n   * `withdraw` call.\\n   *          MUST return a limited value if the owner is subject to any limits, or the total amount\\n   * of owned assets otherwise.\\n   *          MUST NOT revert.\\n   *  @param  owner_  The owner of the assets.\\n   *  @return assets_ The maximum amount of assets that can be withdrawn.\\n   */\\n  function maxWithdraw(address owner_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their deposit at the\\n   * current block, given current on-chain conditions.\\n   *          MUST return as close to and no more than the exact amount of shares that would be\\n   * minted in a `deposit` call in the same transaction.\\n   *          MUST NOT account for deposit limits like those returned from `maxDeposit` and should\\n   * always act as though the deposit would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to deposit.\\n   *  @return shares_ The amount of shares that would be minted.\\n   */\\n  function previewDeposit(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their mint at the\\n   * current block, given current on-chain conditions.\\n   *          MUST return as close to and no fewer than the exact amount of assets that would be\\n   * deposited in a `mint` call in the same transaction.\\n   *          MUST NOT account for mint limits like those returned from `maxMint` and should always\\n   * act as though the minting would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to mint.\\n   *  @return assets_ The amount of assets that would be deposited.\\n   */\\n  function previewMint(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their redemption at\\n   * the current block, given current on-chain conditions.\\n   *          MUST return as close to and no more than the exact amount of assets that would be\\n   * withdrawn in a\u00a0`redeem`\u00a0call in the same transaction.\\n   *          MUST NOT account for redemption limits like those returned from `maxRedeem` and should\\n   * always act as though the redemption would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  shares_ The amount of shares to redeem.\\n   *  @return assets_ The amount of assets that would be withdrawn.\\n   */\\n  function previewRedeem(uint256 shares_) external view returns (uint256 assets_);\\n\\n  /**\\n   *  @dev    Allows an on-chain or off-chain user to simulate the effects of their withdrawal at\\n   * the current block, given current on-chain conditions.\\n   *          MUST return as close to and no fewer than the exact amount of shares that would be\\n   * burned in a\u00a0`withdraw`\u00a0call in the same transaction.\\n   *          MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and\\n   * should always act as though the withdrawal would be accepted.\\n   *          MUST NOT revert.\\n   *  @param  assets_ The amount of assets to withdraw.\\n   *  @return shares_ The amount of shares that would be redeemed.\\n   */\\n  function previewWithdraw(uint256 assets_) external view returns (uint256 shares_);\\n\\n  /**\\n   *  @dev    Total amount of the underlying asset that is managed by the Vault.\\n   *          SHOULD include compounding that occurs from any yields.\\n   *          MUST NOT revert.\\n   *  @return totalAssets_ The total amount of assets the Vault manages.\\n   */\\n  function totalAssets() external view returns (uint256 totalAssets_);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pendle-core-v2-public/=lib/pendle-core-v2-public/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"synthetix-v3/=lib/synthetix-v3/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fydeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strsy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FYDE\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"activateFydeEmissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activatedEmissions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFydeEmissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userReward\",\"type\":\"uint256\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strsy\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user2\",\"type\":\"address\"}],\"name\":\"updateAccounting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardsDistributor", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dde736837c7c275a952a52ee11face88adde6711000000000000000000000000e11df8c0e9b5697bd31515d0fc5f4c9bd71566b9", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}