{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: supermarket/contracts/stake.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n//import \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n\r\n\r\ninterface IMarket{\r\n    function claimTrade(uint256 epoch, uint256 amt,uint256 cp,address claimer,bytes memory signature) payable external;\r\n    function claimMeme(uint256 epoch, uint256 amt,uint256 lp,uint256 cp,bytes memory signature,address cFor) external;\r\n}\r\n\r\ncontract StakeFixedAPYDuration is Ownable {\r\n    //using SafeMath for uint256;\r\n    //using SafeERC20 for IERC20;\r\n    IERC20 public stakeToken;\r\n\r\n    uint256 public duration = 0;\r\n    uint256 public unboundingDuration = 0;\r\n    uint256 private _totalSupply;\r\n    uint256 public taxCollectedFromUnstake = 0;\r\n    uint256 public periodFinish = 0;\r\n    uint256 public constant DENOMINATOR = 10000;\r\n    uint256 public constant SECONDS_IN_YEAR = 365 days;\r\n    uint256 public constant MIN_MAT_PERIOD = 3 days; // set to 3 days.\r\n    uint256 public beforeMaturityUnstakeTaxNumerator = 500;\r\n    uint256 public totalEthReward;\r\n    uint256 private MIN_STAKE = 10000 * 10**18;\r\n    address public rewardDistribution;\r\n    address public trade;\r\n    address public memecoin;\r\n\r\n\r\n\r\n    bool public isStakingStarted = false;\r\n\r\n    // Represents a single unstake for a user. A user may have multiple.\r\n    struct Unstake {\r\n        uint256 unstakingAmount;\r\n        uint256 unstakingTime;\r\n    }\r\n\r\n    /**\r\n\tUser Data\r\n\t */\r\n    struct UserData {\r\n        uint256 stakeToken;\r\n        uint256 rewards;\r\n        uint256 lastUpdateTime;\r\n        //uint256 duration;\r\n        uint256 stakingTime;\r\n    }\r\n\r\n    mapping(address => UserData) public users;\r\n    // The collection of unstakes for each user.\r\n    mapping(address => Unstake) public userUnstake;\r\n\r\n    // Time Duration & APR\r\n    //mapping(uint256 => uint256) public monthlyAPR;\r\n    uint256 private annualAPY;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Unstaked(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    event RecoverToken(address indexed token, uint256 indexed amount);\r\n    event UnstakeAmountClaimed(address indexed user, uint256 amount);\r\n    event RewardDistributionStarted(uint256 periodFinish);\r\n    event RewardReInvested(address indexed user, uint256 reward);\r\n    event UnstakeTaxCollected(uint256 indexed amount);\r\n    modifier onlyRewardDistributor() {\r\n        require(\r\n            _msgSender() == rewardDistribution,\r\n            \"Caller is not reward distribution\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier updateReward(address account) {\r\n        if (account != address(0)) {\r\n            users[account].rewards = earned(account);\r\n        }\r\n        users[account].lastUpdateTime = lastTimeRewardApplicable();\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        IERC20 _stakeToken,\r\n        uint256 _duration,\r\n        uint256 _unboundingDuration,\r\n        address s,\r\n        address m\r\n\r\n    )  {\r\n       // require(_forwarder != address(0), \"Forwarder cannot be empty\");\r\n        stakeToken = _stakeToken;\r\n        duration = _duration;\r\n        unboundingDuration = _unboundingDuration;\r\n        //trustedForwarder = _forwarder;\r\n        trade=s;\r\n        memecoin=m;\r\n        annualAPY = 20000;//200% APY\r\n    }\r\n\r\n    // function _msgSender()\r\n    //     internal\r\n    //     view\r\n    //     virtual\r\n    //     override(BaseRelayRecipient, Context)\r\n    //     returns (address payable)\r\n    // {\r\n    //     return BaseRelayRecipient._msgSender();\r\n    // }\r\n\r\n    function versionRecipient()\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory)\r\n    {}\r\n\r\n    function getUserData(address addr)\r\n        external\r\n        view\r\n        returns (UserData memory user)\r\n    {\r\n        return users[addr];\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    function earned(address account) public view returns (uint256) {\r\n        uint256 earnedFromStakeCoin = users[account]\r\n            .stakeToken * (lastTimeRewardApplicable()-(users[account].lastUpdateTime)) * (getAnnualAPY());\r\n\r\n        return\r\n            (earnedFromStakeCoin)/(DENOMINATOR)/(SECONDS_IN_YEAR)+(\r\n                users[account].rewards\r\n            );\r\n    }\r\n\r\n    function stake(uint256 amount)\r\n        external\r\n        updateReward(_msgSender())\r\n    {\r\n        require(isStakingStarted, \"Staking is not started yet\");\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        require(block.timestamp<periodFinish,\"Staking period over\");\r\n        // require(\r\n        //     users[_msgSender()].duration <= months,\r\n        //     \"New staking duration must be greater than equal to previous staking duration\"\r\n        // );\r\n        _totalSupply += (amount);\r\n\r\n        users[_msgSender()].stakeToken = users[_msgSender()].stakeToken+(\r\n            amount\r\n        );\r\n        //users[_msgSender()].duration = months;\r\n        users[_msgSender()].stakingTime = block.timestamp;\r\n        stakeToken.transferFrom(_msgSender(), address(this), amount);\r\n        emit Staked(_msgSender(), amount);\r\n    }\r\n\r\n    function unstakeFor(address userAddress, uint256 amount, bool taxFlag)\r\n        external\r\n        onlyRewardDistributor updateReward(userAddress)\r\n    {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n        require(\r\n            users[userAddress].stakeToken >= amount,\r\n            \"User does not have sufficient balance\"\r\n        );\r\n        users[userAddress].stakeToken = users[userAddress].stakeToken -(\r\n            amount\r\n        );\r\n\r\n        if (taxFlag == true) {\r\n            uint256 beforeMaturityUnstakeTax = amount\r\n                * (beforeMaturityUnstakeTaxNumerator)\r\n                /(DENOMINATOR);\r\n            amount -= beforeMaturityUnstakeTax;\r\n            taxCollectedFromUnstake += beforeMaturityUnstakeTax;\r\n        } else {\r\n            require(\r\n                users[userAddress].stakingTime + (\r\n                     (MIN_MAT_PERIOD)\r\n                ) <= block.timestamp,\r\n                \"Cannot withdraw before maturity\"\r\n            );\r\n        }\r\n        _unstake(userAddress, amount);\r\n    }\r\n\r\n    function unstake(uint256 amount)\r\n        public\r\n        updateReward(_msgSender())\r\n    {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n        require(\r\n            users[_msgSender()].stakeToken >= amount,\r\n            \"User does not have sufficient balance\"\r\n        );\r\n        require(\r\n            users[_msgSender()].stakingTime + (\r\n                 (MIN_MAT_PERIOD)\r\n            ) <= block.timestamp,\r\n            \"Cannot withdraw before maturity\"\r\n        );\r\n        users[_msgSender()].stakeToken = users[_msgSender()].stakeToken -(\r\n            amount\r\n        );\r\n        _unstake(_msgSender(), amount);\r\n    }\r\n\r\n    function setTradeMemeAddress(address t,address m) onlyRewardDistributor public {\r\n        trade = t;\r\n        memecoin=m;\r\n    }\r\n\r\n    function _unstake(address userAddress, uint256 amount)\r\n        internal\r\n    {\r\n        uint256 myShare = amount*(DENOMINATOR)/_totalSupply;\r\n        myShare = (totalEthReward*myShare)/(DENOMINATOR);\r\n        totalEthReward=totalEthReward-myShare;\r\n        _totalSupply = _totalSupply -(amount);\r\n\r\n        getReward();\r\n\r\n        if (unboundingDuration == 0) {\r\n            stakeToken.transfer(userAddress, amount);\r\n            sendETHValue(payable(userAddress), myShare);\r\n            \r\n        } else {\r\n            uint256 unboundingPeriodFinish = block.timestamp + (\r\n                unboundingDuration\r\n            );\r\n            Unstake storage accountUnstake = userUnstake[userAddress];\r\n            accountUnstake.unstakingAmount = (accountUnstake.unstakingAmount)\r\n                +(amount);\r\n            accountUnstake.unstakingTime = unboundingPeriodFinish;\r\n        }\r\n\r\n        emit Unstaked(userAddress, amount);\r\n    }\r\n\r\n    function reinvest() external {\r\n        _reinvest(_msgSender());\r\n    }\r\n\r\n    function reinvestFor(address user) external onlyRewardDistributor {\r\n        _reinvest(user);\r\n    }\r\n\r\n    function _reinvest(address user) internal updateReward(user) {\r\n        uint256 reward = users[user].rewards;\r\n        if (reward > 0) {\r\n            users[user].rewards = 0;\r\n            users[user].stakeToken = users[user].stakeToken+(reward);\r\n            _totalSupply = _totalSupply+(reward);\r\n            emit RewardReInvested(user, reward);\r\n        }\r\n    }\r\n\r\n    function getAnnualAPY()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //uint256 months = users[account].duration;\r\n        return annualAPY;\r\n    }\r\n\r\n    function claimUnstakedAmount() external {\r\n        Unstake storage accountUnstake = userUnstake[_msgSender()];\r\n\r\n        require(\r\n            accountUnstake.unstakingAmount > 0,\r\n            \"No unstaked amount to claim\"\r\n        );\r\n        require(\r\n            block.timestamp >= accountUnstake.unstakingTime,\r\n            \"Unbounding period not finished\"\r\n        );\r\n\r\n        uint256 _totalUnstakedAmount = accountUnstake.unstakingAmount;\r\n\r\n        accountUnstake.unstakingAmount = 0;\r\n        accountUnstake.unstakingTime = 0;\r\n\r\n        stakeToken.transfer(_msgSender(), _totalUnstakedAmount);\r\n        emit UnstakeAmountClaimed(_msgSender(), _totalUnstakedAmount);\r\n    }\r\n    //earn by claims\r\n    function earnClaims(address s,uint256 epoch, uint256 amt,uint256 cp,uint256 lp,address claimer,bytes memory signature) external payable {\r\n        require(users[msg.sender].stakeToken > MIN_STAKE ,\"Min Eligiblity 10k\");\r\n        if(s == memecoin){\r\n        IMarket(s).claimMeme( epoch, amt, lp, cp, signature, claimer); \r\n        }else if(s == trade){\r\n            IMarket(s).claimTrade(epoch,amt,cp,claimer,signature);\r\n        }\r\n        return;\r\n    }\r\n\r\n    function totalUnstakedAmountReadyToClaim(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (block.timestamp >= userUnstake[user].unstakingTime) {\r\n            return userUnstake[user].unstakingAmount;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function totalUnstakedAmount(address user) external view returns (uint256) {\r\n        return userUnstake[user].unstakingAmount;\r\n    }\r\n\r\n    function getUnboundingTime(address user) external view returns (uint256) {\r\n        return userUnstake[user].unstakingTime;\r\n    }\r\n\r\n    function exit() external {\r\n        unstake(users[_msgSender()].stakeToken);\r\n        getReward();\r\n    }\r\n\r\n    function getReward() public updateReward(_msgSender()) {\r\n        uint256 reward = users[_msgSender()].rewards;\r\n        if (reward > 0) {\r\n            users[_msgSender()].rewards = 0;\r\n            stakeToken.transfer(_msgSender(), reward);\r\n            emit RewardPaid(_msgSender(), reward);\r\n        }\r\n    }\r\n    //Start Staking\r\n    function notifyRewardDistribution()\r\n        external\r\n        onlyRewardDistributor\r\n        updateReward(address(0))\r\n    {\r\n        require(!isStakingStarted, \"Staking is already started\");\r\n        isStakingStarted = true;\r\n        periodFinish = block.timestamp+(duration);\r\n        emit RewardDistributionStarted(periodFinish);\r\n    }\r\n\r\n    function setAPY( uint256 apr)\r\n        external\r\n        onlyRewardDistributor\r\n    {\r\n        require(apr > 0, \"month can not be 0\");\r\n        annualAPY = apr;\r\n    }\r\n\r\n    function setRewardDistribution(address _rewardDistribution)\r\n        external\r\n        onlyOwner\r\n    {\r\n        rewardDistribution = _rewardDistribution;\r\n    }\r\n\r\n    function setDuration(uint256 _duration) external onlyRewardDistributor {\r\n        duration = _duration;\r\n        periodFinish = block.timestamp+(duration);\r\n    }\r\n\r\n    function setUnboundingDuration(uint256 _unboundingDuration)\r\n        external\r\n        onlyRewardDistributor\r\n    {\r\n        unboundingDuration = _unboundingDuration;\r\n    }\r\n\r\n    function setBeforeMaturityUnstakeTaxNumerator(\r\n        uint256 _beforeMaturityUnstakeTaxNumerator\r\n    ) external onlyRewardDistributor {\r\n        beforeMaturityUnstakeTaxNumerator = _beforeMaturityUnstakeTaxNumerator;\r\n    }\r\n\r\n    function stopRewardDistribution() external onlyRewardDistributor {\r\n        periodFinish = block.timestamp;\r\n    }\r\n\r\n    function updateRewardFor(\r\n        address[] memory beneficiary,\r\n        uint256[] memory rewards\r\n    ) external onlyRewardDistributor {\r\n        require(beneficiary.length == rewards.length, \"Input length invalid\");\r\n        for (uint256 i = 0; i < beneficiary.length; i++) {\r\n            users[beneficiary[i]].rewards = (users[beneficiary[i]].rewards)+(\r\n                rewards[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function collectUnstakeTax() external onlyRewardDistributor {\r\n        uint256 tax = taxCollectedFromUnstake;\r\n        taxCollectedFromUnstake = 0;\r\n        IERC20(stakeToken).transfer(_msgSender(), tax);\r\n        emit UnstakeTaxCollected(tax);\r\n    }\r\n\r\n    function recoverExcessToken(address token, uint256 amount)\r\n        external\r\n        onlyRewardDistributor\r\n    {\r\n        IERC20(token).transfer(_msgSender(), amount);\r\n        emit RecoverToken(token, amount);\r\n    }\r\n    function sendETHValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    receive() payable external{\r\n        totalEthReward+=msg.value;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unboundingDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"}],\"name\":\"RewardDistributionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardReInvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeAmountClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeTaxCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_MAT_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforeMaturityUnstakeTaxNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUnstakedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectUnstakeTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"earnClaims\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAnnualAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUnboundingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeFixedAPYDuration.UserData\",\"name\":\"user\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memecoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverExcessToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"reinvestFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistribution\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"}],\"name\":\"setAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_beforeMaturityUnstakeTaxNumerator\",\"type\":\"uint256\"}],\"name\":\"setBeforeMaturityUnstakeTaxNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardDistribution\",\"type\":\"address\"}],\"name\":\"setRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"}],\"name\":\"setTradeMemeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unboundingDuration\",\"type\":\"uint256\"}],\"name\":\"setUnboundingDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxCollectedFromUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalUnstakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalUnstakedAmountReadyToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unboundingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"taxFlag\",\"type\":\"bool\"}],\"name\":\"unstakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiary\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"name\":\"updateRewardFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakingTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakeFixedAPYDuration", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006d8f7ac13e8c2944d27e0f9bc6aa0122f2ec138400000000000000000000000000000000000000000000000000000000003b538000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002184e4780ae760af1b662fb80e52cec9b5e2b8190000000000000000000000009f9c7a726d16e6e630c9500f5df8b3902b9ba2a6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8c9d4254d9fc79e4236a7d66ea0c907e8d17005ead06f123996bd33615fe7cc7"}