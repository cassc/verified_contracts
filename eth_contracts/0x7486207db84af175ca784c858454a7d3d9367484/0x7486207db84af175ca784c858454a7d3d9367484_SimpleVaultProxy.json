{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@solidstate/contracts/access/ownable/IOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\\n\\ninterface IOwnableInternal is IERC173Internal {\\n    error Ownable__NotOwner();\\n    error Ownable__NotTransitiveOwner();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal is IOwnableInternal {\\n    using AddressUtils for address;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\\n        _;\\n    }\\n\\n    modifier onlyTransitiveOwner() {\\n        if (msg.sender != _transitiveOwner())\\n            revert Ownable__NotTransitiveOwner();\\n        _;\\n    }\\n\\n    function _owner() internal view virtual returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    function _transitiveOwner() internal view virtual returns (address owner) {\\n        owner = _owner();\\n\\n        while (owner.isContract()) {\\n            try IERC173(owner).owner() returns (address transitiveOwner) {\\n                owner = transitiveOwner;\\n            } catch {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transferOwnership(address account) internal virtual {\\n        _setOwner(account);\\n    }\\n\\n    function _setOwner(address account) internal virtual {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, account);\\n        l.owner = account;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173Internal } from './IERC173Internal.sol';\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 is IERC173Internal {\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return conrtact owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC173 interface needed by internal functions\\n */\\ninterface IERC173Internal {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Diamond proxy introspection interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondReadable {\\n    struct Facet {\\n        address target;\\n        bytes4[] selectors;\\n    }\\n\\n    /**\\n     * @notice get all facets and their selectors\\n     * @return diamondFacets array of structured facet data\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /**\\n     * @notice get all selectors for given facet address\\n     * @param facet address of facet to query\\n     * @return selectors array of function selectors\\n     */\\n    function facetFunctionSelectors(\\n        address facet\\n    ) external view returns (bytes4[] memory selectors);\\n\\n    /**\\n     * @notice get addresses of all facets used by diamond\\n     * @return addresses array of facet addresses\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses);\\n\\n    /**\\n     * @notice get the address of the facet associated with given selector\\n     * @param selector function selector to query\\n     * @return facet facet address (zero address if not found)\\n     */\\n    function facetAddress(\\n        bytes4 selector\\n    ) external view returns (address facet);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IProxy {\\n    error Proxy__ImplementationIsNotContract();\\n\\n    fallback() external payable;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\nimport { IProxy } from './IProxy.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy is IProxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        if (!implementation.isContract())\\n            revert Proxy__ImplementationIsNotContract();\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/simple/ERC1155MetadataExtensionInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport { ERC1155MetadataExtensionStorage } from './ERC1155MetadataExtensionStorage.sol';\\n\\nabstract contract ERC1155MetadataExtensionInternal {\\n    /**\\n     * @notice sets a new name for ECR1155 collection\\n     * @param name name to set\\n     */\\n    function _setName(string memory name) internal {\\n        ERC1155MetadataExtensionStorage.layout().name = name;\\n    }\\n\\n    /**\\n     * @notice sets a new symbol for ECR1155 collection\\n     * @param symbol symbol to set\\n     */\\n    function _setSymbol(string memory symbol) internal {\\n        ERC1155MetadataExtensionStorage.layout().symbol = symbol;\\n    }\\n\\n    /**\\n     * @notice reads ERC1155 collcetion name\\n     * @return name ERC1155 collection name\\n     */\\n    function _name() internal view returns (string memory name) {\\n        name = ERC1155MetadataExtensionStorage.layout().name;\\n    }\\n\\n    /**\\n     * @notice reads ERC1155 collcetion symbol\\n     * @return symbol ERC1155 collection symbol\\n     */\\n    function _symbol() internal view returns (string memory symbol) {\\n        symbol = ERC1155MetadataExtensionStorage.layout().symbol;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/simple/ERC1155MetadataExtensionStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nlibrary ERC1155MetadataExtensionStorage {\\n    struct Layout {\\n        string name;\\n        string symbol;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('insrt.contracts.storage.ERC1155MetadataExtensionStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/simple/ISimpleVaultInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport { IOwnableInternal } from '@solidstate/contracts/access/ownable/IOwnableInternal.sol';\\n\\ninterface ISimpleVaultInternal is IOwnableInternal {\\n    /**\\n     * @notice indicates which lending adaptor is to be interacted with\\n     */\\n    enum LendingAdaptor {\\n        DEFAULT, //allows for passing an 'empty' adaptor argument in functions\\n        JPEGD\\n    }\\n\\n    /**\\n     * @notice indicates which staking adaptor is to be interacted with\\n     */\\n    enum StakingAdaptor {\\n        DEFAULT, //allows for passing an 'empty' adaptor argument in functions\\n        JPEGD\\n    }\\n\\n    /**\\n     * @notice encapsulates an amount of fees of a particular token\\n     */\\n    struct TokenFee {\\n        address token;\\n        uint256 fees;\\n    }\\n\\n    /**\\n     * @notice encapsulates an amount of yield of a particular token\\n     */\\n    struct TokenYield {\\n        address token;\\n        uint256 yield;\\n    }\\n\\n    /**\\n     * @notice encapsulates the cumulative amount of yield accrued of a paritcular token per shard\\n     */\\n    struct TokensPerShard {\\n        address token;\\n        uint256 cumulativeAmount;\\n    }\\n\\n    /**\\n     * @notice thrown when function called by non-protocol owner\\n     */\\n    error SimpleVault__NotProtocolOwner();\\n\\n    /**\\n     * @notice thrown when function called by account which is  non-authorized and non-protocol owner\\n     */\\n    error SimpleVault__NotAuthorized();\\n\\n    /**\\n     * @notice thrown when the deposit amount is not a multiple of shardSize\\n     */\\n    error SimpleVault__InvalidDepositAmount();\\n\\n    /**\\n     * @notice thrown when the maximum capital has been reached or vault has invested\\n     */\\n    error SimpleVault__DepositForbidden();\\n\\n    /**\\n     * @notice thrown when attempting to call a disabled function\\n     */\\n    error SimpleVault__NotEnabled();\\n\\n    /**\\n     * @notice thrown when user is attempting to deposit after owning (minting) max shards\\n     */\\n    error SimpleVault__MaxMintBalance();\\n\\n    /**\\n     * @notice thrown when attempting to act without being whitelisted\\n     */\\n    error SimpleVault__NotWhitelisted();\\n\\n    /**\\n     * @notice thrown when the maximum capital has been reached or vault has invested\\n     */\\n    error SimpleVault__WithdrawalForbidden();\\n\\n    /**\\n     * @notice thrown when setting a basis point fee value larger than 10000\\n     */\\n    error SimpleVault__BasisExceeded();\\n\\n    /**\\n     * @notice thrown when attempting to claim yield before yield claiming is initialized\\n     */\\n    error SimpleVault__YieldClaimingForbidden();\\n\\n    /**\\n     * @notice thrown when attempting to set a reserved supply larger than max supply\\n     */\\n    error SimpleVault__ExceededMaxSupply();\\n\\n    /**\\n     * @notice thrown when setting a max supply which is smaller than total supply\\n     */\\n    error SimpleVault__MaxSupplyTooSmall();\\n\\n    /**\\n     * @notice thrown when the vault does not have enough ETH to account for an ETH transfer + respective fee\\n     */\\n    error SimpleVault__InsufficientETH();\\n\\n    /**\\n     * @notice thrown when attempting to interact on a collection which is not part of the vault collections\\n     */\\n    error SimpleVault__NotCollectionOfVault();\\n\\n    /**\\n     * @notice thrown when marking a token for sale which is not in ownedTokenIds\\n     */\\n    error SimpleVault__NotOwnedToken();\\n\\n    /**\\n     * @notice thrown when attempting to sell a token  not marked for sale\\n     */\\n    error SimpleVault__TokenNotForSale();\\n\\n    /**\\n     * @notice thrown when an incorrect ETH amount is received during token sale\\n     */\\n    error SimpleVault__IncorrectETHReceived();\\n\\n    /**\\n     * @notice thrown when attempted to mark a token for sale whilst it is collateralized\\n     */\\n    error SimpleVault__TokenCollateralized();\\n\\n    /**\\n     * @notice thrown when attempting to discount yield fee with a DAWN_OF_INSRT token not\\n     * belonging to account yield fee is being discounted for\\n     */\\n    error SimpleVault__NotDawnOfInsrtTokenOwner();\\n\\n    /**\\n     * @notice thrown when attempting to add a token to collectionOwnedTokens without vault being the token owner\\n     */\\n    error SimpleVault__NotTokenOwner();\\n\\n    /**\\n     * @notice thrown when attempting to remove a token from collectionOwnedTokens with vault being the token owner\\n     */\\n    error SimpleVault__TokenStillOwned();\\n\\n    /**\\n     * @notice emitted when an ERC721 is transferred from the treasury to the vault in exchange for ETH\\n     * @param tokenId id of ERC721 asset\\n     */\\n    event ERC721AssetTransfered(uint256 tokenId);\\n\\n    /**\\n     * @notice emitted when protocol fees are withdrawn\\n     * @param tokenFees array of TokenFee structs indicating address of fee token and amount\\n     */\\n    event FeesWithdrawn(TokenFee[3] tokenFees);\\n\\n    /**\\n     * @notice emitted when an token is marked for sale\\n     * @param collection address of collection of token\\n     * @param tokenId id of token\\n     * @param price price in ETH of token\\n     */\\n    event TokenMarkedForSale(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price\\n    );\\n\\n    /**\\n     * @notice emitted when a token is sold\\n     * @param collection address of token collection\\n     * @param tokenId id of token\\n     */\\n    event TokenSold(address collection, uint256 tokenId);\\n\\n    /**\\n     * @notice emitted when whitelistEndsAt is set\\n     * @param whitelistEndsAt the new whitelistEndsAt timestamp\\n     */\\n    event WhitelistEndsAtSet(uint48 whitelistEndsAt);\\n\\n    /**\\n     * @notice emitted when reservedSupply is set\\n     * @param reservedSupply the new reservedSupply\\n     */\\n    event ReservedSupplySet(uint64 reservedSupply);\\n\\n    /**\\n     * @notice emitted when isEnabled is set\\n     * @param isEnabled the new isEnabled value\\n     */\\n    event IsEnabledSet(bool isEnabled);\\n\\n    /**\\n     * @notice emitted when maxMintBalance is set\\n     * @param maxMintBalance the new maxMintBalance\\n     */\\n    event MaxMintBalanceSet(uint64 maxMintBalance);\\n\\n    /**\\n     * @notice emitted when maxSupply is set\\n     * @param maxSupply the new maxSupply\\n     */\\n    event MaxSupplySet(uint64 maxSupply);\\n\\n    /**\\n     * @notice emitted when sale fee is set\\n     * @param feeBP the new sale fee basis points\\n     */\\n    event SaleFeeSet(uint16 feeBP);\\n\\n    /**\\n     * @notice emitted when acquisition fee is set\\n     * @param feeBP the new acquisition fee basis points\\n     */\\n    event AcquisitionFeeSet(uint16 feeBP);\\n\\n    /**\\n     * @notice emitted when yield fee is set\\n     * @param feeBP the new yield fee basis points\\n     */\\n    event YieldFeeSet(uint16 feeBP);\\n\\n    /**\\n     * @notice emitted when ltvBufferBP is set\\n     * @param bufferBP new ltvBufferBP value\\n     */\\n    event LTVBufferSet(uint16 bufferBP);\\n\\n    /**\\n     * @notice emitted when ltvDeviationBP is set\\n     * @param deviationBP new ltvDeviationBP value\\n     */\\n    event LTVDeviationSet(uint16 deviationBP);\\n\\n    /**\\n     * @notice emitted when a collection is removed from vault collections\\n     * @param collection address of removed collection\\n     */\\n    event CollectionRemoved(address collection);\\n\\n    /**\\n     * @notice emitted when a collection is added to vault collections\\n     * @param collection address of added collection\\n     */\\n    event CollectionAdded(address collection);\\n\\n    /**\\n     * @notice emitted when an owned token is added to a collection manually\\n     * @param collection collection address\\n     * @param tokenId tokenId\\n     */\\n    event OwnedTokenAddedToCollection(address collection, uint256 tokenId);\\n\\n    /**\\n     * @notice emitted when an owned token is removed from a collection manually\\n     * @param collection collection address\\n     * @param tokenId tokenId\\n     */\\n    event OwnedTokenRemovedFromCollection(address collection, uint256 tokenId);\\n\\n    /**\\n     * @notice emmitted when the 'authorized' state is granted to or revoked from an account\\n     * @param account address of account to grant/revoke 'authorized'\\n     * @param isAuthorized value of 'authorized' state\\n     */\\n    event AuthorizedSet(address account, bool isAuthorized);\\n\\n    /**\\n     * @notice emitted when an ERC721 asset is collateralized in a lending vendor\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param collection address of ERC721 collection\\n     * @param tokenId id of token\\n     */\\n    event ERC721AssetCollateralized(\\n        LendingAdaptor adaptor,\\n        address collection,\\n        uint256 tokenId\\n    );\\n\\n    /**\\n     * @notice emitted when lending vendor tokens received for collateralizing and asset\\n     *  are staked in a lending vendor\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param shares lending vendor shares received after staking, if any\\n     */\\n    event Staked(StakingAdaptor adaptor, uint256 shares);\\n\\n    /**\\n     * @notice emitted when a position in a lending vendor is unstaked and converted back\\n     * to the tokens which were initially staked\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param tokenAmount amount of tokens received for unstaking\\n     */\\n    event Unstaked(StakingAdaptor adaptor, uint256 tokenAmount);\\n\\n    /**\\n     * @notice emitted when a certain amount of the staked position in a lending vendor is\\n     * unstaked and converted to tokens to be provided as yield\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param tokenYields array of token addresses and corresponding yields provided\\n     */\\n    event YieldProvided(StakingAdaptor adaptor, TokenYield[] tokenYields);\\n\\n    /**\\n     * @notice emitted when a loan repayment is made for a collateralized position\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param paidDebt amount of debt repaid\\n     */\\n    event LoanPaymentMade(LendingAdaptor adaptor, uint256 paidDebt);\\n\\n    /**\\n     * @notice emitted when a loan is repaid in full and the position is closed\\n     * @param adaptor enum indicating which lending vendor adaptor was used\\n     * @param receivedETH amount of ETH received after closing position\\n     */\\n    event PositionClosed(LendingAdaptor adaptor, uint256 receivedETH);\\n}\\n\"\r\n    },\r\n    \"contracts/simple/SimpleVaultProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\\nimport { OwnableInternal } from '@solidstate/contracts/access/ownable/OwnableInternal.sol';\\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\\n\\nimport { ERC1155MetadataExtensionInternal } from './ERC1155MetadataExtensionInternal.sol';\\nimport { SimpleVaultStorage } from './SimpleVaultStorage.sol';\\n\\n/**\\n * @title Upgradeable proxy with externally controlled SimpleVault implementation\\n */\\ncontract SimpleVaultProxy is\\n    Proxy,\\n    OwnableInternal,\\n    ERC1155MetadataExtensionInternal\\n{\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    address private immutable SIMPLE_VAULT_DIAMOND;\\n\\n    constructor(\\n        address simpleVaultDiamond,\\n        address whitelist,\\n        uint256 shardValue,\\n        uint64 maxSupply,\\n        uint64 maxMintBalance,\\n        uint16 acquisitionFeeBP,\\n        uint16 saleFeeBP,\\n        uint16 yieldFeeBP,\\n        uint16 ltvBufferBP,\\n        uint16 ltvDeviationBP,\\n        address[] memory collections,\\n        string memory name,\\n        string memory symbol\\n    ) {\\n        SIMPLE_VAULT_DIAMOND = simpleVaultDiamond;\\n\\n        _setOwner(msg.sender);\\n\\n        _setName(name);\\n        _setSymbol(symbol);\\n\\n        SimpleVaultStorage.Layout storage l = SimpleVaultStorage.layout();\\n\\n        l.whitelist = whitelist;\\n        l.shardValue = shardValue;\\n        l.maxSupply = maxSupply;\\n        l.maxMintBalance = maxMintBalance;\\n\\n        l.acquisitionFeeBP = acquisitionFeeBP;\\n        l.saleFeeBP = saleFeeBP;\\n        l.yieldFeeBP = yieldFeeBP;\\n        l.ltvBufferBP = ltvBufferBP;\\n        l.ltvDeviationBP = ltvDeviationBP;\\n\\n        for (uint256 i; i < collections.length; ++i) {\\n            l.vaultCollections.add(collections[i]);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc Proxy\\n     * @notice fetch logic implementation address from external diamond proxy\\n     */\\n    function _getImplementation() internal view override returns (address) {\\n        return IDiamondReadable(SIMPLE_VAULT_DIAMOND).facetAddress(msg.sig);\\n    }\\n\\n    /**\\n     * @notice required in order to accept ETH in exchange for minting shards\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/simple/SimpleVaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.18;\\n\\nimport { ISimpleVaultInternal } from './ISimpleVaultInternal.sol';\\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\\n\\nlibrary SimpleVaultStorage {\\n    struct Layout {\\n        uint256 shardValue;\\n        uint256 accruedFees;\\n        //maximum tokens of MINT_TOKEN_ID which may be minted from deposits.\\n        //will be set to current totalSupply of MINT_TOKEN_ID if ERC721 asset\\n        //is purchased by vault prior to maxSupply of shards being minted\\n        uint64 maxSupply;\\n        uint16 saleFeeBP;\\n        uint16 acquisitionFeeBP;\\n        address whitelist;\\n        uint64 maxMintBalance;\\n        uint64 reservedSupply;\\n        uint48 whitelistEndsAt;\\n        bool isEnabled;\\n        bool isYieldClaiming;\\n        EnumerableSet.AddressSet vaultCollections;\\n        //registered all ids of ERC721 tokens acquired by vault - was replaced with collectionOwnedTokenIds\\n        //in order to allow for same id from different collections to be owned\\n        EnumerableSet.UintSet _deprecated_ownedtokenIds;\\n        mapping(address collection => mapping(uint256 tokenId => uint256 price)) priceOfSale;\\n        mapping(address collection => EnumerableSet.UintSet ownedTokenIds) collectionOwnedTokenIds;\\n        uint32 ownedTokenAmount;\\n        uint256 cumulativeETHPerShard;\\n        uint16 yieldFeeBP;\\n        uint16 ltvBufferBP;\\n        uint16 ltvDeviationBP;\\n        mapping(address collection => EnumerableSet.UintSet tokenIds) collateralizedTokens;\\n        mapping(address account => uint256 amount) ethDeductionsPerShard; //total amount of ETH deducted per shard, used to account for user rewards\\n        mapping(address account => uint256 amount) userETHYield;\\n        mapping(address account => bool isAuthorized) isAuthorized;\\n        mapping(ISimpleVaultInternal.StakingAdaptor adaptor => bool isActivated) activatedStakingAdaptors;\\n        mapping(ISimpleVaultInternal.LendingAdaptor adaptor => bool isActivated) activatedLendingAdaptors;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('insrt.contracts.storage.SimpleVault');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"simpleVaultDiamond\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"whitelist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shardValue\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxMintBalance\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"acquisitionFeeBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"saleFeeBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"yieldFeeBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ltvBufferBP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ltvDeviationBP\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Proxy__ImplementationIsNotContract\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SimpleVaultProxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009d781ec50967ce6bb4f0714d36b3a21b1d94596f00000000000000000000000076f017300fd3c8542a0356ed0f5ee76e65fc40d7000000000000000000000000000000000000000000000000027f7d0bdb92000000000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000495f947276749ce646f68ac8c248420045cb7b5e000000000000000000000000000000000000000000000000000000000000000c53686172645661756c74203700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005424f4e4753000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x4e77d69b6f971a16fd24c8f9ed88546f12f8e06f", "SwarmSource": ""}