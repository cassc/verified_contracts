{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Manager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n\\nabstract contract Manager is Context {\\n\\n    mapping(address => bool) private _accounts;\\n\\n    modifier onlyManager {\\n        require(isManager(), \\\"only manager\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        _accounts[_msgSender()] = true;\\n    }\\n\\n    function isManager(address one) public view returns (bool) {\\n        return _accounts[one];\\n    }\\n\\n    function isManager() public view returns (bool) {\\n        return isManager(_msgSender());\\n    }\\n\\n    function setManager(address one, bool val) public onlyManager {\\n        require(one != address(0), \\\"address is zero\\\");\\n        _accounts[one] = val;\\n    }\\n\\n    function setManagerBatch(address[] calldata list, bool val) public onlyManager {\\n        for (uint256 i = 0; i < list.length; i++) {\\n            setManager(list[i], val);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/UXContractDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.19;\\n\\n/**\\n * A contract-deploy factory which deploys contract as same address on different ETH-compatible chains (e.g. ETH, BSC, Polygon, etc.)\\n * \\n * How to generate a specific prefix for contract address (replace bytecode and constructorArgs to yours):\\n * \\n * <code>\\n * const ethUtil = require('ethereumjs-util');\\n * const prefix = \\\"Fe666\\\";\\n * \\n * // ContractFactory address:\\n * const deployContract = 'ea5837e1f89e3cf23027da7866e6492458383b59';\\n * // contract bytecode:\\n * const bytecode = '6080604052348015...';\\n * // constructor args:\\n * const constructorArgs = '0000000000000000...';\\n * \\n * // bytecode hash:\\n * let bytecodeHash = ethUtil.keccak256(new Buffer(bytecode + constructorArgs, 'hex')).toString('hex');\\n * \\n * // find salt:\\n * for (let i = 0; i< 0xfffffff; i++) {\\n *     let salt = i.toString(16).padStart(64, '0');\\n *     // payload data:\\n *     let payload = 'ff' + deployContract + salt + bytecodeHash;\\n *     // contract address:\\n *     let addr = ethUtil.bufferToHex(ethUtil.keccak256(new Buffer(payload, 'hex'))).substr(26);\\n *     // test prefix:\\n *     if (addr.startsWith(prefix)) {\\n *         console.log(salt);\\n *         console.log(addr);\\n *         break;\\n *     }\\n * }\\n * console.log('END');\\n * </code>\\n */\\nimport {Manager} from \\\"./libs/Manager.sol\\\";\\n\\ninterface IUXMANAGER {\\n    function authorizeOperator(address _operator) external;\\n    function setManager(address one, bool val) external;\\n}\\n\\ncontract UXContractDeployer is Manager{\\n\\n    event ContractDeployed(address creatorAddress, address contractAddress);\\n    uint256 public fee;\\n\\n    constructor() {\\n        setManager(msg.sender,true);\\n        fee = 0.00 ether;\\n    }\\n\\n    /**\\n     * setManager for contract\\n     */\\n    function setContractManager(address _contractAddress, address _managerAddress) public onlyManager {\\n        require(_contractAddress != address(0), \\\"Zero address\\\");\\n        require(_managerAddress != address(0), \\\"Zero address\\\");\\n        IUXMANAGER(_contractAddress).setManager(_managerAddress, true);\\n    }\\n\\n    /**\\n     * authorizeOperator for contract\\n     */\\n    function setContractOperator(address _contractAddress, address _managerAddress) public onlyManager {\\n        require(_contractAddress != address(0), \\\"Zero address\\\");\\n        require(_managerAddress != address(0), \\\"Zero address\\\");\\n        IUXMANAGER(_contractAddress).authorizeOperator(_managerAddress);\\n    }\\n\\n    function setFee(uint256 _fee) public onlyManager {\\n        fee = _fee;\\n    }\\n\\n    function withdrawFee(address payable _to) public onlyManager{\\n        require(_to != address(0), \\\"Zero address\\\");\\n        _to.transfer(address(this).balance);\\n    }\\n \\n    /**\\n     * deploy contract by salt, contract bytecode.\\n     */\\n    function deployContract(bytes32 salt, bytes memory contractBytecode) public payable {\\n        require(msg.value == fee, \\\"Invalid fee\\\");\\n        address addr;\\n        assembly {\\n            addr := create2(0, add(contractBytecode, 0x20), mload(contractBytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        emit ContractDeployed(msg.sender, addr);\\n    }\\n\\n    /**\\n     * deploy contract by salt, contract bytecode and constructor args.\\n     */\\n    function deployContractWithConstructor(bytes32 salt, bytes memory contractBytecode, bytes memory constructorArgsEncoded) public payable {\\n        require(msg.value == fee, \\\"Invalid fee\\\");\\n        // deploy contracts with constructor (address):\\n        bytes memory payload = abi.encodePacked(contractBytecode, constructorArgsEncoded);\\n        address addr;\\n        assembly {\\n            addr := create2(0, add(payload, 0x20), mload(payload), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        emit ContractDeployed(msg.sender, addr);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"contractBytecode\",\"type\":\"bytes\"}],\"name\":\"deployContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"contractBytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgsEncoded\",\"type\":\"bytes\"}],\"name\":\"deployContractWithConstructor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managerAddress\",\"type\":\"address\"}],\"name\":\"setContractManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managerAddress\",\"type\":\"address\"}],\"name\":\"setContractOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setManagerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UXContractDeployer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}