{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IDiscountCalculator.sol\": {\r\n      \"content\": \"//\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\\n//\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\n//\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\\n//\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\\n//\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\\n//\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\\n\\n\\npragma solidity 0.8.16;\\n//SPDX-License-Identifier: MIT\\n\\ninterface IDiscountCalculator {\\n\\n    function calculateAmountForMaxDiscount(uint256 totalDebtAmount) external view returns (uint256 neededAmount);\\n\\n}\"\r\n    },\r\n    \"contracts/modules/DullahanDiscountCalculator.sol\": {\r\n      \"content\": \"//\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\\n//\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\n//\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\\n//\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\\n//\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\\n//\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\\n\\npragma solidity 0.8.16;\\n//SPDX-License-Identifier: BUSL-1.1\\n\\nimport \\\"../interfaces/IDiscountCalculator.sol\\\";\\nimport {WadRayMath} from  \\\"../utils/WadRayMath.sol\\\";\\n\\n/** @title Dullahan GHO Discount Calculator Module\\n *  @author Paladin\\n *  @notice Module handling the calculation of the needed stkAAVE amount ot get the best discount for GHO interests\\n */\\ncontract DullahanDiscountCalculator is IDiscountCalculator {\\n    using WadRayMath for uint256;\\n\\n    /** @notice 1e18 scale */\\n    uint256 public constant UNIT = 1e18;\\n\\n    /**\\n     * Parameters aken from Aave's GhoDiscountRateStrategy smart contract\\n     * https://github.com/aave/gho-core/blob/main/src/contracts/facilitators/aave/interestStrategy/GhoDiscountRateStrategy.sol\\n     * to calculate correctly based on the parameters used by the Strategy\\n     */\\n    /** Start of Aave parameters zone */\\n    /**\\n     * @dev Amount of debt that is entitled to get a discount per unit of discount token\\n     * Expressed with the number of decimals of the discounted token\\n     */\\n    uint256 public constant GHO_DISCOUNTED_PER_DISCOUNT_TOKEN = 100e18;\\n\\n    /**\\n     * @dev Minimum balance amount of discount token to be entitled to a discount\\n     * Expressed with the number of decimals of the discount token\\n     */\\n    uint256 public constant MIN_DISCOUNT_TOKEN_BALANCE = 1e15;\\n\\n    /**\\n     * @dev Minimum balance amount of debt token to be entitled to a discount\\n     * Expressed with the number of decimals of the debt token\\n     */\\n    uint256 public constant MIN_DEBT_TOKEN_BALANCE = 1e18;\\n    /** End of Aave parameters zone */\\n\\n\\n    function calculateAmountForMaxDiscount(\\n        uint256 totalDebtAmount\\n    ) external pure returns (uint256 neededAmount) {\\n        if(totalDebtAmount < MIN_DEBT_TOKEN_BALANCE) return 0;\\n\\n        neededAmount = totalDebtAmount.wadDiv(GHO_DISCOUNTED_PER_DISCOUNT_TOKEN);\\n        if(neededAmount < MIN_DISCOUNT_TOKEN_BALANCE) neededAmount = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU AGPLv3\\npragma solidity ^0.8.0;\\n\\n/// @title WadRayMath.\\n/// @author Morpho Labs.\\n/// @custom:contact security@morpho.xyz\\n/// @notice Optimized version of Aave V3 math library WadRayMath to conduct wad and ray manipulations: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/math/WadRayMath.sol\\nlibrary WadRayMath {\\n    /// CONSTANTS ///\\n\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n    uint256 internal constant HALF_WAD_RAY_RATIO = 0.5e9;\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1; // Not possible to use type(uint256).max in yul.\\n    uint256 internal constant MAX_UINT256_MINUS_HALF_WAD = 2**256 - 1 - 0.5e18;\\n    uint256 internal constant MAX_UINT256_MINUS_HALF_RAY = 2**256 - 1 - 0.5e27;\\n\\n    /// INTERNAL ///\\n\\n    /// @dev Multiplies two wad, rounding half up to the nearest wad.\\n    /// @param x Wad.\\n    /// @param y Wad.\\n    /// @return z The result of x * y, in wad.\\n    function wadMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // Let y > 0\\n        // Overflow if (x * y + HALF_WAD) > type(uint256).max\\n        // <=> x * y > type(uint256).max - HALF_WAD\\n        // <=> x > (type(uint256).max - HALF_WAD) / y\\n        assembly {\\n            if mul(y, gt(x, div(MAX_UINT256_MINUS_HALF_WAD, y))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(add(mul(x, y), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /// @dev Divides two wad, rounding half up to the nearest wad.\\n    /// @param x Wad.\\n    /// @param y Wad.\\n    /// @return z The result of x / y, in wad.\\n    function wadDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // Overflow if y == 0\\n        // Overflow if (x * WAD + y / 2) > type(uint256).max\\n        // <=> x * WAD > type(uint256).max - y / 2\\n        // <=> x > (type(uint256).max - y / 2) / WAD\\n        assembly {\\n            z := div(y, 2)\\n            if iszero(mul(y, iszero(gt(x, div(sub(MAX_UINT256, z), WAD))))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(add(mul(WAD, x), z), y)\\n        }\\n    }\\n\\n    /// @dev Multiplies two ray, rounding half up to the nearest ray.\\n    /// @param x Ray.\\n    /// @param y Ray.\\n    /// @return z The result of x * y, in ray.\\n    function rayMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // Let y > 0\\n        // Overflow if (x * y + HALF_RAY) > type(uint256).max\\n        // <=> x * y > type(uint256).max - HALF_RAY\\n        // <=> x > (type(uint256).max - HALF_RAY) / y\\n        assembly {\\n            if mul(y, gt(x, div(MAX_UINT256_MINUS_HALF_RAY, y))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(add(mul(x, y), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /// @dev Divides two ray, rounding half up to the nearest ray.\\n    /// @param x Ray.\\n    /// @param y Ray.\\n    /// @return z The result of x / y, in ray.\\n    function rayDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // Overflow if y == 0\\n        // Overflow if (x * RAY + y / 2) > type(uint256).max\\n        // <=> x * RAY > type(uint256).max - y / 2\\n        // <=> x > (type(uint256).max - y / 2) / RAY\\n        assembly {\\n            z := div(y, 2)\\n            if iszero(mul(y, iszero(gt(x, div(sub(MAX_UINT256, z), RAY))))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(add(mul(RAY, x), z), y)\\n        }\\n    }\\n\\n    /// @dev Casts ray down to wad.\\n    /// @param x Ray.\\n    /// @return y = x converted to wad, rounded half up to the nearest wad.\\n    function rayToWad(uint256 x) internal pure returns (uint256 y) {\\n        assembly {\\n            // If x % WAD_RAY_RATIO >= HALF_WAD_RAY_RATIO, round up.\\n            y := add(div(x, WAD_RAY_RATIO), iszero(lt(mod(x, WAD_RAY_RATIO), HALF_WAD_RAY_RATIO)))\\n        }\\n    }\\n\\n    /// @dev Converts wad up to ray.\\n    /// @param x Wad.\\n    /// @return y = x converted in ray.\\n    function wadToRay(uint256 x) internal pure returns (uint256 y) {\\n        assembly {\\n            y := mul(WAD_RAY_RATIO, x)\\n            // Revert if y / WAD_RAY_RATIO != x\\n            if iszero(eq(div(y, WAD_RAY_RATIO), x)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"GHO_DISCOUNTED_PER_DISCOUNT_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEBT_TOKEN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DISCOUNT_TOKEN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDebtAmount\",\"type\":\"uint256\"}],\"name\":\"calculateAmountForMaxDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"neededAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DullahanDiscountCalculator", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}