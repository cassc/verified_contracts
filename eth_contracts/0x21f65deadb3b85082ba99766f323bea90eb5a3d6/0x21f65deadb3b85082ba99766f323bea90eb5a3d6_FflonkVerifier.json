{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/verifiers/FflonkVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n/*\\n    Copyright 2021 0KIMS association.\\n\\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\\n\\n    snarkJS is a free software: you can redistribute it and/or modify it\\n    under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\\n    License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract FflonkVerifier {\\n    uint32 constant n     = 16777216; // Domain size\\n\\n    // Verification Key data\\n    uint256 constant k1   = 2;   // Plonk k1 multiplicative factor to force distinct cosets of H\\n    uint256 constant k2   = 3;   // Plonk k2 multiplicative factor to force distinct cosets of H\\n\\n    // OMEGAS\\n    // Omega, Omega^{1/3}\\n    uint256 constant w1   = 5709868443893258075976348696661355716898495876243883251619397131511003808859;\\n    uint256 constant wr   = 18200100796661656210024324131237448517259556535315737226009542456080026430510;\\n    // Omega_3, Omega_3^2\\n    uint256 constant w3   = 21888242871839275217838484774961031246154997185409878258781734729429964517155;\\n    uint256 constant w3_2 = 4407920970296243842393367215006156084916469457145843978461;\\n    // Omega_4, Omega_4^2, Omega_4^3\\n    uint256 constant w4   = 21888242871839275217838484774961031246007050428528088939761107053157389710902;\\n    uint256 constant w4_2 = 21888242871839275222246405745257275088548364400416034343698204186575808495616;\\n    uint256 constant w4_3 = 4407920970296243842541313971887945403937097133418418784715;\\n    // Omega_8, Omega_8^2, Omega_8^3, Omega_8^4, Omega_8^5, Omega_8^6, Omega_8^7\\n    uint256 constant w8_1 = 19540430494807482326159819597004422086093766032135589407132600596362845576832;\\n    uint256 constant w8_2 = 21888242871839275217838484774961031246007050428528088939761107053157389710902;\\n    uint256 constant w8_3 = 13274704216607947843011480449124596415239537050559949017414504948711435969894;\\n    uint256 constant w8_4 = 21888242871839275222246405745257275088548364400416034343698204186575808495616;\\n    uint256 constant w8_5 = 2347812377031792896086586148252853002454598368280444936565603590212962918785;\\n    uint256 constant w8_6 = 4407920970296243842541313971887945403937097133418418784715;\\n    uint256 constant w8_7 = 8613538655231327379234925296132678673308827349856085326283699237864372525723;\\n\\n    // Verifier preprocessed input C_0(x)\u00b7[1]_1\\n    uint256 constant C0x  = 10330861150616913541207360924312278787207684679419670167996002791305440821704;\\n    uint256 constant C0y  = 14244524222232642134204580826860575549922689127759263461569792153452315036880;\\n\\n    // Verifier preprocessed input x\u00b7[1]_2\\n    uint256 constant X2x1 = 21831381940315734285607113342023901060522397560371972897001948545212302161822;\\n    uint256 constant X2x2 = 17231025384763736816414546592865244497437017442647097510447326538965263639101;\\n    uint256 constant X2y1 = 2388026358213174446665280700919698872609886601280537296205114254867301080648;\\n    uint256 constant X2y2 = 11507326595632554467052522095592665270651932854513688777769618397986436103170;\\n\\n    // Scalar field size\\n    uint256 constant q    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    // Base field size\\n    uint256 constant qf   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    // [1]_1\\n    uint256 constant G1x  = 1;\\n    uint256 constant G1y  = 2;\\n    // [1]_2\\n    uint256 constant G2x1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n    uint256 constant G2x2 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n    uint256 constant G2y1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\\n    uint256 constant G2y2 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\\n\\n    // Proof calldata\\n    // Byte offset of every parameter of the calldata\\n    // Polynomial commitments\\n    uint16 constant pC1       = 4 + 0;     // [C1]_1\\n    uint16 constant pC2       = 4 + 32*2;  // [C2]_1\\n    uint16 constant pW1       = 4 + 32*4;  // [W]_1\\n    uint16 constant pW2       = 4 + 32*6;  // [W']_1\\n    // Opening evaluations\\n    uint16 constant pEval_ql  = 4 + 32*8;  // q_L(xi)\\n    uint16 constant pEval_qr  = 4 + 32*9;  // q_R(xi)\\n    uint16 constant pEval_qm  = 4 + 32*10; // q_M(xi)\\n    uint16 constant pEval_qo  = 4 + 32*11; // q_O(xi)\\n    uint16 constant pEval_qc  = 4 + 32*12; // q_C(xi)\\n    uint16 constant pEval_s1  = 4 + 32*13; // S_{sigma_1}(xi)\\n    uint16 constant pEval_s2  = 4 + 32*14; // S_{sigma_2}(xi)\\n    uint16 constant pEval_s3  = 4 + 32*15; // S_{sigma_3}(xi)\\n    uint16 constant pEval_a   = 4 + 32*16; // a(xi)\\n    uint16 constant pEval_b   = 4 + 32*17; // b(xi)\\n    uint16 constant pEval_c   = 4 + 32*18; // c(xi)\\n    uint16 constant pEval_z   = 4 + 32*19; // z(xi)\\n    uint16 constant pEval_zw  = 4 + 32*20; // z_omega(xi)\\n    uint16 constant pEval_t1w = 4 + 32*21; // T_1(xi omega)\\n    uint16 constant pEval_t2w = 4 + 32*22; // T_2(xi omega)\\n    uint16 constant pEval_inv = 4 + 32*23; // inv(batch) sent by the prover to avoid any inverse calculation to save gas,\\n                                           // we check the correctness of the inv(batch) by computing batch\\n                                           // and checking inv(batch) * batch == 1\\n\\n    // Memory data\\n    // Challenges\\n    uint16 constant pAlpha   = 0;   // alpha challenge\\n    uint16 constant pBeta    = 32;  // beta challenge\\n    uint16 constant pGamma   = 64;  // gamma challenge\\n    uint16 constant pY       = 96;  // y challenge\\n    uint16 constant pXiSeed  = 128; // xi seed, from this value we compute xi = xiSeed^24\\n    uint16 constant pXiSeed2 = 160; // (xi seed)^2\\n    uint16 constant pXi      = 192; // xi challenge\\n\\n    // Roots\\n    // S_0 = roots_8(xi) = { h_0, h_0w_8, h_0w_8^2, h_0w_8^3, h_0w_8^4, h_0w_8^5, h_0w_8^6, h_0w_8^7 }\\n    uint16 constant pH0w8_0 = 224;\\n    uint16 constant pH0w8_1 = 256;\\n    uint16 constant pH0w8_2 = 288;\\n    uint16 constant pH0w8_3 = 320;\\n    uint16 constant pH0w8_4 = 352;\\n    uint16 constant pH0w8_5 = 384;\\n    uint16 constant pH0w8_6 = 416;\\n    uint16 constant pH0w8_7 = 448;\\n\\n    // S_1 = roots_4(xi) = { h_1, h_1w_4, h_1w_4^2, h_1w_4^3 }\\n    uint16 constant pH1w4_0 = 480;\\n    uint16 constant pH1w4_1 = 512;\\n    uint16 constant pH1w4_2 = 544;\\n    uint16 constant pH1w4_3 = 576;\\n\\n    // S_2 = roots_3(xi) U roots_3(xi omega)\\n    // roots_3(xi) = { h_2, h_2w_3, h_2w_3^2 }\\n    uint16 constant pH2w3_0 = 608;\\n    uint16 constant pH2w3_1 = 640;\\n    uint16 constant pH2w3_2 = 672;\\n    // roots_3(xi omega) = { h_3, h_3w_3, h_3w_3^2 }\\n    uint16 constant pH3w3_0 = 704;\\n    uint16 constant pH3w3_1 = 736;\\n    uint16 constant pH3w3_2 = 768;\\n\\n    uint16 constant pPi     = 800; // PI(xi)\\n    uint16 constant pR0     = 832; // r0(y)\\n    uint16 constant pR1     = 864; // r1(y)\\n    uint16 constant pR2     = 896; // r2(y)\\n\\n    uint16 constant pF      = 928;  // [F]_1, 64 bytes\\n    uint16 constant pE      = 992;  // [E]_1, 64 bytes\\n    uint16 constant pJ      = 1056; // [J]_1, 64 bytes\\n\\n    uint16 constant pZh     = 1184; // Z_H(xi)\\n    // From this point we write all the variables that must be computed using the Montgomery batch inversion\\n    uint16 constant pZhInv  = 1216; // 1/Z_H(xi)\\n    uint16 constant pDenH1  = 1248; // 1/( (y-h_1w_4) (y-h_1w_4^2) (y-h_1w_4^3) (y-h_1w_4^4) )\\n    uint16 constant pDenH2  = 1280; // 1/( (y-h_2w_3) (y-h_2w_3^2) (y-h_2w_3^3) (y-h_3w_3) (y-h_3w_3^2) (y-h_3w_3^3) )\\n    uint16 constant pLiS0Inv = 1312; // Reserve 8 * 32 bytes to compute r_0(X)\\n    uint16 constant pLiS1Inv = 1568; // Reserve 4 * 32 bytes to compute r_1(X)\\n    uint16 constant pLiS2Inv = 1696; // Reserve 6 * 32 bytes to compute r_2(X)\\n    // Lagrange evaluations\\n    \\n    uint16 constant pEval_l1 = 1888;\\n    \\n    \\n    uint16 constant lastMem = 1920;\\n     \\n\\n    function verifyProof(bytes32[24] calldata proof, uint256[1] calldata pubSignals) public view returns (bool) {\\n        assembly {\\n            // Computes the inverse of an array of values\\n            // See https://vitalik.ca/general/2018/07/21/starks_part_3.html in section where explain fields operations\\n            // To save the inverse to be computed on chain the prover sends the inverse as an evaluation in commits.eval_inv\\n            function inverseArray(pMem) {\\n\\n                let pAux := mload(0x40)     // Point to the next free position\\n                let acc := mload(add(pMem,pZhInv))       // Read the first element\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pDenH1)), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pDenH2)), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pLiS0Inv)), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 32))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 64))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 96))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 128))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 160))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 192))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 224))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pLiS1Inv)), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 32))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 64))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 96))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pLiS2Inv)), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 32))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 64))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 96))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 128))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 160))), q)\\n                mstore(pAux, acc)\\n\\n                pAux := add(pAux, 32)\\n                acc := mulmod(acc, mload(add(pMem, pEval_l1)), q)\\n                mstore(pAux, acc)\\n\\n\\n                let inv := calldataload(pEval_inv)\\n\\n                // Before using the inverse sent by the prover the verifier checks inv(batch) * batch === 1\\n                if iszero(eq(1, mulmod(acc, inv, q))) {\\n                    mstore(0, 0)\\n                    return(0,0x20)\\n                }\\n\\n                acc := inv\\n\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pEval_l1)), q)\\n                mstore(add(pMem, pEval_l1), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 160))), q)\\n                mstore(add(pMem, add(pLiS2Inv, 160)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 128))), q)\\n                mstore(add(pMem, add(pLiS2Inv, 128)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 96))), q)\\n                mstore(add(pMem, add(pLiS2Inv, 96)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 64))), q)\\n                mstore(add(pMem, add(pLiS2Inv, 64)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS2Inv, 32))), q)\\n                mstore(add(pMem, add(pLiS2Inv, 32)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pLiS2Inv)), q)\\n                mstore(add(pMem, pLiS2Inv), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 96))), q)\\n                mstore(add(pMem, add(pLiS1Inv, 96)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 64))), q)\\n                mstore(add(pMem, add(pLiS1Inv, 64)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS1Inv, 32))), q)\\n                mstore(add(pMem, add(pLiS1Inv, 32)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pLiS1Inv)), q)\\n                mstore(add(pMem, pLiS1Inv), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 224))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 224)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 192))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 192)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 160))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 160)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 128))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 128)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 96))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 96)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 64))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 64)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, add(pLiS0Inv, 32))), q)\\n                mstore(add(pMem, add(pLiS0Inv, 32)), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pLiS0Inv)), q)\\n                mstore(add(pMem, pLiS0Inv), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pDenH2)), q)\\n                mstore(add(pMem, pDenH2), inv)\\n                pAux := sub(pAux, 32)\\n                inv := mulmod(acc, mload(pAux), q)\\n                acc := mulmod(acc, mload(add(pMem, pDenH1)), q)\\n                mstore(add(pMem, pDenH1), inv)\\n\\n                mstore(add(pMem, pZhInv), acc)\\n            }\\n\\n            function checkField(v) {\\n                if iszero(lt(v, q)) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function checkPointBelongsToBN128Curve(p) {\\n                let x := calldataload(p)\\n                let y := calldataload(add(p, 32))\\n\\n                // Check that the point is on the curve\\n                // y^2 = x^3 + 3\\n                let x3_3 := addmod(mulmod(x, mulmod(x, x, qf), qf), 3, qf)\\n                let y2 := mulmod(y, y, qf)\\n\\n                if iszero(eq(x3_3, y2)) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }  \\n            \\n            // Validate all the evaluations sent by the prover \u2208 F\\n            function checkInput() {\\n                // Check proof commitments fullfill bn128 curve equation Y^2 = X^3 + 3\\n                checkPointBelongsToBN128Curve(pC1)\\n                checkPointBelongsToBN128Curve(pC2)\\n                checkPointBelongsToBN128Curve(pW1)\\n                checkPointBelongsToBN128Curve(pW2)\\n\\n                checkField(calldataload(pEval_ql))\\n                checkField(calldataload(pEval_qr))\\n                checkField(calldataload(pEval_qm))\\n                checkField(calldataload(pEval_qo))\\n                checkField(calldataload(pEval_qc))\\n                checkField(calldataload(pEval_s1))\\n                checkField(calldataload(pEval_s2))\\n                checkField(calldataload(pEval_s3))\\n                checkField(calldataload(pEval_a))\\n                checkField(calldataload(pEval_b))\\n                checkField(calldataload(pEval_c))\\n                checkField(calldataload(pEval_z))\\n                checkField(calldataload(pEval_zw))\\n                checkField(calldataload(pEval_t1w))\\n                checkField(calldataload(pEval_t2w))\\n                checkField(calldataload(pEval_inv))\\n\\n                // Points are checked in the point operations precompiled smart contracts\\n            }\\n\\n            function computeChallenges(pMem, pPublic) {\\n                // Compute challenge.beta & challenge.gamma\\n                mstore(add(pMem, 1920 ), C0x)\\n                mstore(add(pMem, 1952 ), C0y)\\n\\n                mstore(add(pMem, 1984), calldataload(pPublic))\\n                \\n                \\n\\n                mstore(add(pMem, 2016 ),  calldataload(pC1))\\n                mstore(add(pMem, 2048 ),  calldataload(add(pC1, 32)))\\n\\n                mstore(add(pMem, pBeta),  mod(keccak256(add(pMem, lastMem), 160), q))\\n                mstore(add(pMem, pGamma), mod(keccak256(add(pMem, pBeta), 32), q))\\n\\n                // Get xiSeed & xiSeed2\\n                mstore(add(pMem, lastMem), mload(add(pMem, pGamma)))\\n                mstore(add(pMem, 1952), calldataload(pC2))\\n                mstore(add(pMem, 1984), calldataload(add(pC2, 32)))\\n                let xiSeed := mod(keccak256(add(pMem, lastMem), 96), q)\\n\\n                mstore(add(pMem, pXiSeed), xiSeed)\\n                mstore(add(pMem, pXiSeed2), mulmod(xiSeed, xiSeed, q))\\n\\n                // Compute roots.S0.h0w8\\n                mstore(add(pMem, pH0w8_0), mulmod(mload(add(pMem, pXiSeed2)), mload(add(pMem, pXiSeed)), q))\\n                mstore(add(pMem, pH0w8_1), mulmod(mload(add(pMem, pH0w8_0)), w8_1, q))\\n                mstore(add(pMem, pH0w8_2), mulmod(mload(add(pMem, pH0w8_0)), w8_2, q))\\n                mstore(add(pMem, pH0w8_3), mulmod(mload(add(pMem, pH0w8_0)), w8_3, q))\\n                mstore(add(pMem, pH0w8_4), mulmod(mload(add(pMem, pH0w8_0)), w8_4, q))\\n                mstore(add(pMem, pH0w8_5), mulmod(mload(add(pMem, pH0w8_0)), w8_5, q))\\n                mstore(add(pMem, pH0w8_6), mulmod(mload(add(pMem, pH0w8_0)), w8_6, q))\\n                mstore(add(pMem, pH0w8_7), mulmod(mload(add(pMem, pH0w8_0)), w8_7, q))\\n\\n                // Compute roots.S1.h1w4\\n                mstore(add(pMem, pH1w4_0), mulmod(mload(add(pMem, pH0w8_0)), mload(add(pMem, pH0w8_0)), q))\\n                mstore(add(pMem, pH1w4_1), mulmod(mload(add(pMem, pH1w4_0)), w4, q))\\n                mstore(add(pMem, pH1w4_2), mulmod(mload(add(pMem, pH1w4_0)), w4_2, q))\\n                mstore(add(pMem, pH1w4_3), mulmod(mload(add(pMem, pH1w4_0)), w4_3, q))\\n\\n                // Compute roots.S2.h2w3\\n                mstore(add(pMem, pH2w3_0), mulmod(mload(add(pMem, pH1w4_0)), mload(add(pMem, pXiSeed2)), q))\\n                mstore(add(pMem, pH2w3_1), mulmod(mload(add(pMem, pH2w3_0)), w3, q))\\n                mstore(add(pMem, pH2w3_2), mulmod(mload(add(pMem, pH2w3_0)), w3_2, q))\\n\\n                // Compute roots.S2.h2w3\\n                mstore(add(pMem, pH3w3_0), mulmod(mload(add(pMem, pH2w3_0)), wr, q))\\n                mstore(add(pMem, pH3w3_1), mulmod(mload(add(pMem, pH3w3_0)), w3, q))\\n                mstore(add(pMem, pH3w3_2), mulmod(mload(add(pMem, pH3w3_0)), w3_2, q))\\n\\n                let xin := mulmod(mulmod(mload(add(pMem, pH2w3_0)), mload(add(pMem, pH2w3_0)), q), mload(add(pMem, pH2w3_0)), q)\\n                mstore(add(pMem, pXi), xin)\\n\\n                // Compute xi^n\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                xin:= mulmod(xin, xin, q)\\n                \\n                \\n                xin:= mod(add(sub(xin, 1), q), q)\\n                mstore(add(pMem, pZh), xin)\\n                mstore(add(pMem, pZhInv), xin)  // We will invert later together with lagrange pols\\n\\n                // Compute challenge.alpha\\n                mstore(add(pMem, lastMem), xiSeed)\\n\\n                calldatacopy(add(pMem, 1952), pEval_ql, 480)\\n                mstore(add(pMem, pAlpha), mod(keccak256(add(pMem, lastMem), 512), q))\\n\\n                // Compute challenge.y\\n                mstore(add(pMem, lastMem), mload(add(pMem, pAlpha)))\\n                mstore(add(pMem, 1952 ),  calldataload(pW1))\\n                mstore(add(pMem, 1984 ),  calldataload(add(pW1, 32)))\\n                mstore(add(pMem, pY), mod(keccak256(add(pMem, lastMem), 96), q))\\n            }\\n\\n            function computeLiS0(pMem) {\\n                let root0 := mload(add(pMem, pH0w8_0))\\n                let y := mload(add(pMem, pY))\\n                let den1 := 1\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                \\n                den1 := mulmod(8, den1, q)\\n\\n                let den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 0), 8), 32))))\\n                let den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(0, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 0)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 1), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(1, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 32)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 2), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(2, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 64)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 3), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(3, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 96)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 4), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(4, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 128)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 5), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(5, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 160)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 6), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(6, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 192)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH0w8_0, mul(mod(mul(7, 7), 8), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH0w8_0, mul(7, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS0Inv, 224)), mulmod(den1, mulmod(den2, den3, q), q))\\n            \\n            }\\n\\n            function computeLiS1(pMem) {\\n                let root0 := mload(add(pMem, pH1w4_0))\\n                let y := mload(add(pMem, pY))\\n                let den1 := 1\\n                den1 := mulmod(den1, root0, q)\\n                den1 := mulmod(den1, root0, q)\\n                \\n                den1 := mulmod(4, den1, q)\\n\\n                let den2 := mload(add(pMem, add(pH1w4_0, mul(mod(mul(3, 0), 4), 32))))\\n                let den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH1w4_0, mul(0, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS1Inv, 0)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH1w4_0, mul(mod(mul(3, 1), 4), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH1w4_0, mul(1, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS1Inv, 32)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH1w4_0, mul(mod(mul(3, 2), 4), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH1w4_0, mul(2, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS1Inv, 64)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH1w4_0, mul(mod(mul(3, 3), 4), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH1w4_0, mul(3, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS1Inv, 96)), mulmod(den1, mulmod(den2, den3, q), q))            \\n            }\\n\\n            function computeLiS2(pMem) {\\n\\n                let y := mload(add(pMem, pY))\\n\\n                let den1 := mulmod(mulmod(3,mload(add(pMem, pH2w3_0)),q), addmod(mload(add(pMem, pXi)) ,mod(sub(q, mulmod(mload(add(pMem, pXi)), w1 ,q)), q), q), q)\\n\\n                let den2 := mload(add(pMem, add(pH2w3_0, mul(mod(mul(2, 0), 3), 32))))\\n                let den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH2w3_0, mul(0, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 0)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH2w3_0, mul(mod(mul(2, 1), 3), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH2w3_0, mul(1, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 32)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH2w3_0, mul(mod(mul(2, 2), 3), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH2w3_0, mul(2, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 64)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den1 := mulmod(mulmod(3,mload(add(pMem, pH3w3_0)),q), addmod(mulmod(mload(add(pMem, pXi)), w1 ,q),mod(sub(q, mload(add(pMem, pXi))), q), q), q)\\n\\n                den2 := mload(add(pMem, add(pH3w3_0, mul(mod(mul(2, 0), 3), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH3w3_0, mul(0, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 96)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH3w3_0, mul(mod(mul(2, 1), 3), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH3w3_0, mul(1, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 128)), mulmod(den1, mulmod(den2, den3, q), q))\\n\\n                den2 := mload(add(pMem, add(pH3w3_0, mul(mod(mul(2, 2), 3), 32))))\\n                den3 := addmod(y, mod(sub(q, mload(add(pMem, add(pH3w3_0, mul(2, 32))))), q), q)\\n\\n                mstore(add(pMem, add(pLiS2Inv, 160)), mulmod(den1, mulmod(den2, den3, q), q))\\n            }\\n\\n            // Prepare all the denominators that must be inverted, placed them in consecutive memory addresses\\n            function computeInversions(pMem) {\\n                // 1/ZH(xi) used in steps 8 and 9 of the verifier to multiply by 1/Z_H(xi)\\n                // Value computed during computeChallenges function and stores in pMem+pZhInv\\n\\n                // 1/((y - h1) (y - h1w4) (y - h1w4_2) (y - h1w4_3))\\n                // used in steps 10 and 11 of the verifier\\n                let y := mload(add(pMem, pY))\\n                let w := addmod(y, mod(sub(q, mload(add(pMem, pH1w4_0))), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH1w4_1))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH1w4_2))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH1w4_3))), q), q), q)\\n                mstore(add(pMem, pDenH1), w)\\n\\n                // 1/((y - h2) (y - h2w3) (y - h2w3_2) (y - h3) (y - h3w3) (y - h3w3_2))\\n                w := addmod(y, mod(sub(q, mload(add(pMem, pH2w3_0))), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH2w3_1))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH2w3_2))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH3w3_0))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH3w3_1))), q), q), q)\\n                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pH3w3_2))), q), q), q)\\n                mstore(add(pMem, pDenH2), w)\\n\\n                // Denominator needed in the verifier when computing L_i^{S0}(X)\\n                computeLiS0(pMem)\\n                \\n                // Denominator needed in the verifier when computing L_i^{S1}(X)\\n                computeLiS1(pMem)\\n\\n                // Denominator needed in the verifier when computing L_i^{S2}(X)\\n                computeLiS2(pMem)\\n\\n                // L_i where i from 1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\\n                w := 1\\n                let xi := mload(add(pMem, pXi))\\n                \\n                mstore(add(pMem, pEval_l1), mulmod(n, mod(add(sub(xi, w), q), q), q))\\n                \\n\\n                // Execute Montgomery batched inversions of the previous prepared values\\n                inverseArray(pMem)            }\\n\\n            // Compute Lagrange polynomial evaluation L_i(xi)\\n            function computeLagrange(pMem) {\\n                let zh := mload(add(pMem, pZh))\\n                let w := 1\\n                \\n                    mstore(add(pMem, pEval_l1 ), mulmod(mload(add(pMem, pEval_l1 )), zh, q))\\n                    \\n            }\\n\\n            // Compute public input polynomial evaluation PI(xi)\\n            function computePi(pMem, pPub) {\\n                let pi := 0\\n                pi := mod(add(sub(pi, mulmod(mload(add(pMem, pEval_l1)), calldataload(pPub), q)), q), q)\\n                \\n                mstore(add(pMem, pPi), pi)\\n            }\\n\\n            // Compute r0(y) by interpolating the polynomial r0(X) using 8 points (x,y)\\n            // where x = {h9, h0w8, h0w8^2, h0w8^3, h0w8^4, h0w8^5, h0w8^6, h0w8^7}\\n            // and   y = {C0(h0), C0(h0w8), C0(h0w8^2), C0(h0w8^3), C0(h0w8^4), C0(h0w8^5), C0(h0w8^6), C0(h0w8^7)}\\n            // and computing C0(xi)\\n            function computeR0(pMem) {\\n                let num := 1\\n                let y := mload(add(pMem, pY))\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n\\n                num := addmod(num, mod(sub(q, mload(add(pMem, pXi))), q), q)\\n\\n                let res\\n                let h0w80\\n                let c0Value\\n                let h0w8i\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_0))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 0))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_1))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 32))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_2))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 64))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_3))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 96))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_4))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 128))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_5))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 160))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_6))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 192))), q), q), q)\\n\\n                    \\n                // Compute c0Value = ql + (h0w8i) qr + (h0w8i)^2 qo + (h0w8i)^3 qm + (h0w8i)^4 qc +\\n                //                      + (h0w8i)^5 S1 + (h0w8i)^6 S2 + (h0w8i)^7 S3\\n                h0w80 := mload(add(pMem, pH0w8_7))\\n                c0Value := addmod(calldataload(pEval_ql), mulmod(calldataload(pEval_qr), h0w80, q), q)\\n                h0w8i := mulmod(h0w80, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qo), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qm), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_qc), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s1), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s2), h0w8i, q), q)\\n                h0w8i := mulmod(h0w8i, h0w80, q)\\n                c0Value := addmod(c0Value, mulmod(calldataload(pEval_s3), h0w8i, q), q)\\n\\n                res := addmod(res, mulmod(c0Value, mulmod(num, mload(add(pMem, add(pLiS0Inv, 224))), q), q), q)\\n\\n\\n                mstore(add(pMem, pR0), res)\\n            }\\n\\n            // Compute r1(y) by interpolating the polynomial r1(X) using 4 points (x,y)\\n            // where x = {h1, h1w4, h1w4^2, h1w4^3}\\n            // and   y = {C1(h1), C1(h1w4), C1(h1w4^2), C1(h1w4^3)}\\n            // and computing T0(xi)\\n            function computeR1(pMem) {\\n                let num := 1\\n                let y := mload(add(pMem, pY))\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n                num := mulmod(num, y, q)\\n\\n                num := addmod(num, mod(sub(q, mload(add(pMem, pXi))), q), q)\\n\\n                let t0\\n                let evalA := calldataload(pEval_a)\\n                let evalB := calldataload(pEval_b)\\n                let evalC := calldataload(pEval_c)\\n\\n                t0 := mulmod(calldataload(pEval_ql), evalA, q)\\n                t0 := addmod(t0, mulmod(calldataload(pEval_qr), evalB, q) ,q)\\n                t0 := addmod(t0, mulmod(calldataload(pEval_qm), mulmod(evalA, evalB, q), q) ,q)\\n                t0 := addmod(t0, mulmod(calldataload(pEval_qo), evalC, q) ,q)\\n                t0 := addmod(t0, calldataload(pEval_qc) ,q)\\n                t0 := addmod(t0, mload(add(pMem, pPi)), q)\\n                t0 := mulmod(t0, mload(add(pMem, pZhInv)), q)\\n\\n                let res\\n                let c1Value\\n                let h1w4\\n                let square\\n                c1Value := evalA\\n                h1w4 := mload(add(pMem, pH1w4_0))\\n\\n                c1Value := addmod(c1Value, mulmod(h1w4, evalB, q), q)\\n                square := mulmod(h1w4, h1w4, q)\\n                c1Value := addmod(c1Value, mulmod(square, evalC, q), q)\\n                c1Value := addmod(c1Value, mulmod(mulmod(square, h1w4, q), t0, q), q)\\n\\n                res := addmod(res, mulmod(c1Value, mulmod(num, mload(add(pMem, add(pLiS1Inv, mul(0, 32)))), q), q), q)\\n\\n                c1Value := evalA\\n                h1w4 := mload(add(pMem, pH1w4_1))\\n\\n                c1Value := addmod(c1Value, mulmod(h1w4, evalB, q), q)\\n                square := mulmod(h1w4, h1w4, q)\\n                c1Value := addmod(c1Value, mulmod(square, evalC, q), q)\\n                c1Value := addmod(c1Value, mulmod(mulmod(square, h1w4, q), t0, q), q)\\n\\n                res := addmod(res, mulmod(c1Value, mulmod(num, mload(add(pMem, add(pLiS1Inv, mul(1, 32)))), q), q), q)\\n\\n                c1Value := evalA\\n                h1w4 := mload(add(pMem, pH1w4_2))\\n\\n                c1Value := addmod(c1Value, mulmod(h1w4, evalB, q), q)\\n                square := mulmod(h1w4, h1w4, q)\\n                c1Value := addmod(c1Value, mulmod(square, evalC, q), q)\\n                c1Value := addmod(c1Value, mulmod(mulmod(square, h1w4, q), t0, q), q)\\n\\n                res := addmod(res, mulmod(c1Value, mulmod(num, mload(add(pMem, add(pLiS1Inv, mul(2, 32)))), q), q), q)\\n\\n                c1Value := evalA\\n                h1w4 := mload(add(pMem, pH1w4_3))\\n\\n                c1Value := addmod(c1Value, mulmod(h1w4, evalB, q), q)\\n                square := mulmod(h1w4, h1w4, q)\\n                c1Value := addmod(c1Value, mulmod(square, evalC, q), q)\\n                c1Value := addmod(c1Value, mulmod(mulmod(square, h1w4, q), t0, q), q)\\n\\n                res := addmod(res, mulmod(c1Value, mulmod(num, mload(add(pMem, add(pLiS1Inv, mul(3, 32)))), q), q), q)\\n\\n\\n                mstore(add(pMem, pR1), res)\\n            }\\n\\n            // Compute r2(y) by interpolating the polynomial r2(X) using 6 points (x,y)\\n            // where x = {[h2, h2w3, h2w3^2], [h3, h3w3, h3w3^2]}\\n            // and   y = {[C2(h2), C2(h2w3), C2(h2w3^2)], [C2(h3), C2(h3w3), C2(h3w3^2)]}\\n            // and computing T1(xi) and T2(xi)\\n            function computeR2(pMem) {\\n                let y := mload(add(pMem, pY))\\n                let num := 1\\n                num := mulmod(y, num, q)\\n                num := mulmod(y, num, q)\\n                num := mulmod(y, num, q)\\n                num := mulmod(y, num, q)\\n                num := mulmod(y, num, q)\\n                num := mulmod(y, num, q)\\n\\n                let num2 := 1\\n                num2 := mulmod(y, num2, q)\\n                num2 := mulmod(y, num2, q)\\n                num2 := mulmod(y, num2, q)\\n                num2 := mulmod(num2, addmod(mulmod(mload(add(pMem, pXi)), w1 ,q), mload(add(pMem, pXi)), q), q)\\n\\n                num := addmod(num, mod(sub(q, num2), q), q)\\n\\n                num2 := mulmod(mulmod(mload(add(pMem, pXi)), w1 ,q), mload(add(pMem, pXi)), q)\\n\\n                num := addmod(num, num2, q)\\n\\n                let t1\\n                let t2\\n                let betaXi := mulmod(mload(add(pMem, pBeta)), mload(add(pMem, pXi)), q)\\n                let gamma := mload(add(pMem, pGamma))\\n\\n                t2 := addmod(calldataload( pEval_a), addmod(betaXi, gamma, q) ,q)\\n                t2 := mulmod(t2,\\n                            addmod(calldataload( pEval_b),\\n                            addmod(mulmod(betaXi, k1, q), gamma, q) ,q), q)\\n                t2 := mulmod(t2,\\n                            addmod(calldataload( pEval_c),\\n                            addmod(mulmod(betaXi, k2, q), gamma, q) ,q), q)\\n                t2 := mulmod(t2, calldataload(pEval_z), q)\\n\\n                //Let's use t1 as a temporal variable to save one local\\n                t1 := addmod(calldataload(pEval_a), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_s1), q), gamma, q) ,q)\\n                t1 := mulmod(t1,\\n                      addmod(calldataload(pEval_b), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_s2), q), gamma, q) ,q), q)\\n                t1 := mulmod(t1,\\n                      addmod(calldataload(pEval_c), addmod(mulmod(mload(add(pMem, pBeta)), calldataload(pEval_s3), q), gamma, q) ,q), q)\\n                t1 := mulmod(t1, calldataload(pEval_zw), q)\\n\\n                t2:= addmod(t2, mod(sub(q, t1), q), q)\\n                t2 := mulmod(t2, mload(add(pMem, pZhInv)), q)\\n\\n                // Compute T1(xi)\\n                t1 := sub(calldataload(pEval_z), 1)\\n                t1 := mulmod(t1, mload(add(pMem, pEval_l1)) ,q)\\n                t1 := mulmod(t1, mload(add(pMem, pZhInv)) ,q)\\n\\n                // Let's use local variable gamma to save the result\\n                gamma:=0\\n                \\n                let hw\\n                let c2Value \\n\\n                hw := mload(add(pMem, pH2w3_0))\\n                c2Value := addmod(calldataload(pEval_z), mulmod(hw, t1, q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), t2, q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(0, 32)))), q), q), q)\\n\\n                hw := mload(add(pMem, pH2w3_1))\\n                c2Value := addmod(calldataload(pEval_z), mulmod(hw, t1, q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), t2, q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(1, 32)))), q), q), q)\\n\\n                hw := mload(add(pMem, pH2w3_2))\\n                c2Value := addmod(calldataload(pEval_z), mulmod(hw, t1, q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), t2, q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(2, 32)))), q), q), q)\\n\\n                hw := mload(add(pMem, pH3w3_0))\\n                c2Value := addmod(calldataload(pEval_zw), mulmod(hw, calldataload(pEval_t1w), q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), calldataload(pEval_t2w), q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(3, 32)))), q), q), q)\\n\\n                hw := mload(add(pMem, pH3w3_1))\\n                c2Value := addmod(calldataload(pEval_zw), mulmod(hw, calldataload(pEval_t1w), q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), calldataload(pEval_t2w), q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(4, 32)))), q), q), q)\\n\\n                hw := mload(add(pMem, pH3w3_2))\\n                c2Value := addmod(calldataload(pEval_zw), mulmod(hw, calldataload(pEval_t1w), q), q)\\n                c2Value := addmod(c2Value, mulmod(mulmod(hw, hw, q), calldataload(pEval_t2w), q), q)\\n                gamma := addmod(gamma, mulmod(c2Value, mulmod(num, mload(add(pMem, add(pLiS2Inv, mul(5, 32)))), q), q), q)\\n\\n                mstore(add(pMem, pR2), gamma)\\n            }\\n\\n            // G1 function to accumulate a G1 value to an address\\n            function g1_acc(pR, pP) {\\n                let mIn := mload(0x40)\\n                mstore(mIn, mload(pR))\\n                mstore(add(mIn, 32), mload(add(pR, 32)))\\n                mstore(add(mIn, 64), mload(pP))\\n                mstore(add(mIn, 96), mload(add(pP, 32)))\\n\\n                let success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            // G1 function to multiply a G1 value to value in an address\\n            function g1_mulAcc(pR, pP, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, calldataload(pP))\\n                mstore(add(mIn, 32), calldataload(add(pP, 32)))\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n\\n                mstore(add(mIn, 64), mload(pR))\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\n\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            // G1 function to multiply a G1 value(x,y) to value in an address\\n            function g1_mulAccC(pR, x, y, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, x)\\n                mstore(add(mIn, 32), y)\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n\\n                mstore(add(mIn, 64), mload(pR))\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\n\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function computeFEJ(pMem) {\\n                // Prepare shared numerator between F, E and J to reuse it\\n                let y := mload(add(pMem, pY))\\n                let numerator := addmod(y, mod(sub(q, mload(add(pMem, pH0w8_0))), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_1))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_2))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_3))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_4))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_5))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_6))), q), q), q)\\n                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pH0w8_7))), q), q), q)\\n\\n                // Prepare shared quotient between F and E to reuse it\\n                let quotient1 := mulmod(mload(add(pMem, pAlpha)), mulmod(numerator, mload(add(pMem, pDenH1)), q), q)\\n                let quotient2 := mulmod(mulmod(mload(add(pMem, pAlpha)), mload(add(pMem, pAlpha)), q), mulmod(numerator, mload(add(pMem, pDenH2)), q), q)\\n\\n                // Compute full batched polynomial commitment [F]_1\\n                mstore(add(pMem, pF), C0x)\\n                mstore(add(pMem, add(pF, 32)), C0y)\\n                g1_mulAcc(add(pMem, pF), pC1, quotient1)\\n                g1_mulAcc(add(pMem, pF), pC2, quotient2)\\n\\n                // Compute group-encoded batch evaluation [E]_1\\n                g1_mulAccC(add(pMem, pE), G1x, G1y, addmod(mload(add(pMem, pR0)), addmod(mulmod(quotient1, mload(add(pMem, pR1)),q), mulmod(quotient2, mload(add(pMem, pR2)),q), q), q))\\n\\n                // Compute the full difference [J]_1\\n                g1_mulAcc(add(pMem, pJ), pW1, numerator)\\n            }\\n\\n            // Validate all evaluations with a pairing checking that e([F]_1 - [E]_1 - [J]_1 + y[W2]_1, [1]_2) == e([W']_1, [x]_2)\\n            function checkPairing(pMem) -> isOk {\\n                let mIn := mload(0x40)\\n\\n                // First pairing value\\n                // Compute -E\\n                mstore(add(add(pMem, pE), 32), mod(sub(qf, mload(add(add(pMem, pE), 32))), qf))\\n                // Compute -J\\n                mstore(add(add(pMem, pJ), 32), mod(sub(qf, mload(add(add(pMem, pJ), 32))), qf))\\n                // F = F - E - J + y\u00b7W2\\n                g1_acc(add(pMem, pF), add(pMem, pE))\\n                g1_acc(add(pMem, pF), add(pMem, pJ))\\n                g1_mulAcc(add(pMem, pF), pW2, mload(add(pMem, pY)))\\n\\n                mstore(mIn, mload(add(pMem, pF)))\\n                mstore(add(mIn, 32), mload(add(add(pMem, pF), 32)))\\n\\n                // Second pairing value\\n                mstore(add(mIn, 64), G2x2)\\n                mstore(add(mIn, 96), G2x1)\\n                mstore(add(mIn, 128), G2y2)\\n                mstore(add(mIn, 160), G2y1)\\n\\n                // Third pairing value\\n                // Compute -W2\\n                mstore(add(mIn, 192), calldataload(pW2))\\n                let s := calldataload(add(pW2, 32))\\n                s := mod(sub(qf, s), qf)\\n                mstore(add(mIn, 224), s)\\n\\n                // Fourth pairing value\\n                mstore(add(mIn, 256), X2x2)\\n                mstore(add(mIn, 288), X2x1)\\n                mstore(add(mIn, 320), X2y2)\\n                mstore(add(mIn, 352), X2y1)\\n\\n                let success := staticcall(sub(gas(), 2000), 8, mIn, 384, mIn, 0x20)\\n\\n                isOk := and(success, mload(mIn))\\n            }\\n\\n            let pMem := mload(0x40)\\n            mstore(0x40, add(pMem, lastMem))\\n\\n            // Validate that all evaluations \u2208 F\\n            checkInput()\\n\\n            // Compute the challenges: beta, gamma, xi, alpha and y \u2208 F, h1w4/h2w3/h3w3 roots, xiN and zh(xi)\\n            computeChallenges(pMem, pubSignals)\\n\\n            // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\\n            // The Montgomery batch inversion algorithm allow us to compute n inverses reducing to a single one inversion.\\n            // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\\n            // To avoid this single inverse computation on-chain, it has been computed in proving time and send it to the verifier.\\n            // Therefore, the verifier:\\n            //      1) Prepare all the denominators to inverse\\n            //      2) Check the inverse sent by the prover it is what it should be\\n            //      3) Compute the others inverses using the Montgomery Batched Algorithm using the inverse sent to avoid the inversion operation it does.\\n            computeInversions(pMem)\\n\\n            // Compute Lagrange polynomial evaluations Li(xi)\\n            computeLagrange(pMem)\\n\\n            // Compute public input polynomial evaluation PI(xi) = \\\\sum_i^l -public_input_i\u00b7L_i(xi)\\n            computePi(pMem, pubSignals)\\n\\n            // Computes r1(y) and r2(y)\\n            computeR0(pMem)\\n            computeR1(pMem)\\n            computeR2(pMem)\\n\\n            // Compute full batched polynomial commitment [F]_1, group-encoded batch evaluation [E]_1 and the full difference [J]_1\\n            computeFEJ(pMem)\\n\\n            // Validate all evaluations\\n            let isValid := checkPairing(pMem)\\n\\n            mstore(0, isValid)\\n            return(0, 0x20)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32[24]\",\"name\":\"proof\",\"type\":\"bytes32[24]\"},{\"internalType\":\"uint256[1]\",\"name\":\"pubSignals\",\"type\":\"uint256[1]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FflonkVerifier", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}