{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BridgePlusv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n  function _msgSender() internal view virtual returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n  function _msgData() internal view virtual returns (bytes calldata) {\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  constructor() {\\r\\n    _transferOwnership(_msgSender());\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    _checkOwner();\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function owner() public view virtual returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function _checkOwner() internal view virtual {\\r\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() public virtual onlyOwner {\\r\\n    _transferOwnership(address(0));\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner) internal virtual {\\r\\n    address oldOwner = _owner;\\r\\n    _owner = newOwner;\\r\\n    emit OwnershipTransferred(oldOwner, newOwner);\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address to, uint256 amount) external returns (bool);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n  function deposit() external payable;\\r\\n  function withdraw(uint amount) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n  uint256 private constant _NOT_ENTERED = 1;\\r\\n  uint256 private constant _ENTERED = 2;\\r\\n\\r\\n  uint256 private _status;\\r\\n\\r\\n  constructor () {\\r\\n    _status = _NOT_ENTERED;\\r\\n  }\\r\\n  \\r\\n  modifier nonReentrant() {\\r\\n    require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n    _status = _ENTERED;\\r\\n    _;\\r\\n    _status = _NOT_ENTERED;\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ISwapPlusV2 {\\r\\n  struct SwapInputType {\\r\\n    address fromToken;\\r\\n    address toToken;\\r\\n    uint256 amountIn;\\r\\n    uint256 amountOutMin;\\r\\n    address receiver;\\r\\n  }\\r\\n\\r\\n  struct SwapParamType {\\r\\n    address to;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 percent;\\r\\n    bytes param;\\r\\n  }\\r\\n\\r\\n  struct SwapLineType {\\r\\n    SwapParamType[] pools;\\r\\n  }\\r\\n\\r\\n  struct swapBlockType {\\r\\n    SwapLineType[] lines;\\r\\n  }\\r\\n\\r\\n  function swap(SwapInputType calldata inData, swapBlockType[] calldata swBlocks) external payable returns(uint256, uint256);\\r\\n}\\r\\n\\r\\ncontract BridgePlusv2 is Ownable, ReentrancyGuard {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  uint256 public chainId;\\r\\n  bool public noWrapped;\\r\\n  address public WETH;\\r\\n  address public treasury;\\r\\n  address public swapRouter;\\r\\n  address public operator;\\r\\n\\r\\n  mapping (address => bool) public noFeeWallets;\\r\\n  mapping (address => bool) public noFeeBridges;\\r\\n  mapping (address => bool) public managers;\\r\\n  mapping (address => bool) public whiteListContracts;\\r\\n  mapping (address => address) public approverContracts;\\r\\n  mapping (uint256 => uint256) public operatorFee;\\r\\n\\r\\n  uint256 public swapFee = 3000;\\r\\n  uint256 private constant coreDecimal = 1000000;\\r\\n\\r\\n  struct SwapInputType {\\r\\n    address bridge;\\r\\n    address receiver;\\r\\n    address fromToken;\\r\\n    uint256 amount;\\r\\n    uint256 value;\\r\\n    address toToken;\\r\\n    bytes param;\\r\\n    uint256 dstChainId;\\r\\n    address dstToken;\\r\\n    address receiveToken;\\r\\n  }\\r\\n\\r\\n  struct RedeemInputType {\\r\\n    address bridge;\\r\\n    address receiver;\\r\\n    address fromToken;\\r\\n    address toToken;\\r\\n    bytes param;\\r\\n  }\\r\\n\\r\\n  error DelegatecallFailed();\\r\\n  event BridgePlusFee(address token, uint256 fee, address treasury);\\r\\n  event BridgePlusSwap(address receiver, uint256 srcChainId, address srcToken, uint256 amount, uint256 dstChainId, address dstToken, address receiveToken, address bridge);\\r\\n  event BridgePlusRedeem(address receiver, address dstToken, uint256 receiveToken);\\r\\n\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"BridgePlus: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyOperator() {\\r\\n    require(operator == msg.sender, \\\"BridgePlus: !operator\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor(\\r\\n    uint256 _chainId,\\r\\n    bool _noWrapped,\\r\\n    address _WETH,\\r\\n    address _treasury,\\r\\n    address _swapRouter,\\r\\n    address[] memory _wlContracts,\\r\\n    address[] memory _noFeeBridges,\\r\\n    address[2][] memory _approver\\r\\n  ) {\\r\\n    require(_WETH != address(0), \\\"BridgePlus: Wrong WETH\\\");\\r\\n    require(_treasury != address(0), \\\"BridgePlus: Treasury\\\");\\r\\n    require(_swapRouter != address(0), \\\"BridgePlus: SwapPlus\\\");\\r\\n    \\r\\n    chainId = _chainId;\\r\\n    noWrapped = _noWrapped;\\r\\n    WETH = _WETH;\\r\\n    treasury = _treasury;\\r\\n    swapRouter = _swapRouter;\\r\\n    managers[msg.sender] = true;\\r\\n\\r\\n    for (uint256 x=0; x<_wlContracts.length; x++) {\\r\\n      require(_wlContracts[x] != address(0), \\\"BridgePlus: Wrong wl contract\\\");\\r\\n      whiteListContracts[_wlContracts[x]] = true;\\r\\n    }\\r\\n\\r\\n    for (uint256 x=0; x<_noFeeBridges.length; x++) {\\r\\n      require(_noFeeBridges[x] != address(0), \\\"BridgePlus: Wrong wl contract\\\");\\r\\n      noFeeBridges[_noFeeBridges[x]] = true;\\r\\n    }\\r\\n\\r\\n    for (uint256 x=0; x<_approver.length; x++) {\\r\\n      require(_approver[x][0] != address(0), \\\"BridgePlus: Wrong approve handler\\\");\\r\\n      require(_approver[x][1] != address(0), \\\"BridgePlus: Wrong approve contract\\\");\\r\\n      approverContracts[_approver[x][0]] = _approver[x][1];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  receive() external payable { }\\r\\n\\r\\n  function swap(SwapInputType calldata bridgeInfo, ISwapPlusV2.SwapInputType calldata inData, ISwapPlusV2.swapBlockType[] calldata swBlocks) public payable nonReentrant {\\r\\n    uint256 amount = 0;\\r\\n    uint256 value = 0;\\r\\n    if (\\r\\n      (noWrapped == false && bridgeInfo.fromToken == address(0)) ||\\r\\n      (noWrapped == true && (bridgeInfo.fromToken == WETH || bridgeInfo.fromToken == address(0)))\\r\\n    ) {\\r\\n      amount = msg.value;\\r\\n      value = inData.amountIn;\\r\\n    }\\r\\n    else {\\r\\n      amount = IERC20(bridgeInfo.fromToken).balanceOf(address(this));\\r\\n      IERC20(bridgeInfo.fromToken).safeTransferFrom(msg.sender, address(this), bridgeInfo.amount);\\r\\n      amount = IERC20(bridgeInfo.fromToken).balanceOf(address(this)) - amount;\\r\\n    }\\r\\n\\r\\n    if (noFeeWallets[msg.sender] == false && noFeeBridges[bridgeInfo.bridge] == false) {\\r\\n      amount = _cutFee(bridgeInfo.fromToken, amount);\\r\\n    }\\r\\n\\r\\n    if (noFeeBridges[bridgeInfo.bridge] == true && operatorFee[bridgeInfo.dstChainId] > 0) {\\r\\n      (bool success, ) = payable(operator).call{value: operatorFee[bridgeInfo.dstChainId]}(\\\"\\\");\\r\\n      require(success, \\\"BridgePlus: Failed send operator fee\\\");\\r\\n    }\\r\\n\\r\\n    if (swBlocks.length > 0) {\\r\\n      _approveTokenIfNeeded(bridgeInfo.fromToken, swapRouter, amount);\\r\\n      (, amount) = ISwapPlusV2(swapRouter).swap{value: value}(inData, swBlocks);\\r\\n    }\\r\\n    else if (noWrapped == false && bridgeInfo.fromToken == address(0) && bridgeInfo.toToken == WETH) {\\r\\n      IWETH(WETH).deposit{value: bridgeInfo.amount}();\\r\\n    }\\r\\n\\r\\n    require(whiteListContracts[bridgeInfo.bridge], \\\"BridgePlus: !wrong bridge\\\");\\r\\n    if (approverContracts[bridgeInfo.bridge] != address(0)) {\\r\\n      _approveTokenIfNeeded(bridgeInfo.toToken, approverContracts[bridgeInfo.bridge], amount);\\r\\n    }\\r\\n    else {\\r\\n      _approveTokenIfNeeded(bridgeInfo.toToken, bridgeInfo.bridge, amount);\\r\\n    }\\r\\n    (bool ok, ) = address(bridgeInfo.bridge).call{value: bridgeInfo.value}(bridgeInfo.param);\\r\\n    if (!ok) {\\r\\n      revert DelegatecallFailed();\\r\\n    }\\r\\n\\r\\n    emit BridgePlusSwap(bridgeInfo.receiver, chainId, bridgeInfo.fromToken, bridgeInfo.amount, bridgeInfo.dstChainId, bridgeInfo.dstToken, bridgeInfo.receiveToken, bridgeInfo.bridge);\\r\\n  }\\r\\n\\r\\n  function redeem(RedeemInputType calldata bridgeInfo, ISwapPlusV2.SwapInputType calldata inData, ISwapPlusV2.swapBlockType[] calldata swBlocks) public onlyOperator nonReentrant returns(uint256) {\\r\\n    uint256 amount = 0;\\r\\n    if (\\r\\n      (noWrapped == false && bridgeInfo.fromToken == address(0)) ||\\r\\n      (noWrapped == true && (bridgeInfo.fromToken == WETH || bridgeInfo.fromToken == address(0)))\\r\\n    ) {\\r\\n      amount = address(this).balance;\\r\\n    }\\r\\n    else {\\r\\n      amount = IERC20(bridgeInfo.fromToken).balanceOf(address(this));\\r\\n    }\\r\\n    (bool ok, ) = address(bridgeInfo.bridge).call(bridgeInfo.param);\\r\\n    if (!ok) {\\r\\n      revert DelegatecallFailed();\\r\\n    }\\r\\n    uint256 value = 0;\\r\\n    if (\\r\\n      (noWrapped == false && bridgeInfo.fromToken == address(0)) ||\\r\\n      (noWrapped == true && (bridgeInfo.fromToken == WETH || bridgeInfo.fromToken == address(0)))\\r\\n    ) {\\r\\n      amount = address(this).balance - amount;\\r\\n      value = amount;\\r\\n    }\\r\\n    else {\\r\\n      amount = IERC20(bridgeInfo.fromToken).balanceOf(address(this)) - amount;\\r\\n    }\\r\\n\\r\\n    if (swBlocks.length > 0) {\\r\\n      _approveTokenIfNeeded(bridgeInfo.fromToken, swapRouter, amount);\\r\\n      (, amount) = ISwapPlusV2(swapRouter).swap{value: value}(inData, swBlocks);\\r\\n    }\\r\\n\\r\\n    if (\\r\\n      (noWrapped == false && bridgeInfo.toToken == address(0)) ||\\r\\n      (noWrapped == true && (bridgeInfo.toToken == WETH || bridgeInfo.toToken == address(0)))\\r\\n    ) {\\r\\n      (bool success, ) = payable(bridgeInfo.receiver).call{value: amount}(\\\"\\\");\\r\\n      require(success, \\\"BridgePlus: Failed redeem\\\");\\r\\n    }\\r\\n    else {\\r\\n      IERC20(bridgeInfo.toToken).safeTransfer(bridgeInfo.receiver, amount);\\r\\n    }\\r\\n\\r\\n    emit BridgePlusRedeem(bridgeInfo.receiver, bridgeInfo.toToken, amount);\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    require(account != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setOperator(address account) public onlyOwner {\\r\\n    require(account != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    operator = account;\\r\\n  }\\r\\n\\r\\n  function setSwapRouter(address _swapRouter) public onlyOwner {\\r\\n    require(_swapRouter != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    swapRouter = _swapRouter;\\r\\n  }\\r\\n\\r\\n  function setNoFeeWallets(address account, bool access) public onlyManager {\\r\\n    require(account != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    noFeeWallets[account] = access;\\r\\n  }\\r\\n\\r\\n  function setWhiteListContracts(address account, bool access) public onlyManager {\\r\\n    require(account != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    whiteListContracts[account] = access;\\r\\n  }\\r\\n\\r\\n  function setApproverContracts(address bridge, address approver) public onlyManager {\\r\\n    require(bridge != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    approverContracts[bridge] = approver;\\r\\n  }\\r\\n\\r\\n  function setSwapFee(uint256 _swapFee) public onlyManager {\\r\\n    require(_swapFee < (coreDecimal / 100), \\\"BridgePlus: Too big fee\\\");\\r\\n    swapFee = _swapFee;\\r\\n  }\\r\\n\\r\\n  function setTreasury(address _treasury) public onlyManager {\\r\\n    require(_treasury != address(0), \\\"BridgePlus: Wrong account\\\");\\r\\n    treasury = _treasury;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) internal {\\r\\n    if (\\r\\n      (noWrapped == false && token == address(0)) ||\\r\\n      (noWrapped == true && (token == WETH || token == address(0)))\\r\\n    ) return;\\r\\n    uint256 allowance = IERC20(token).allowance(address(this), spender);\\r\\n    if (allowance < amount) {\\r\\n      if (allowance > 0) {\\r\\n        IERC20(token).safeApprove(spender, 0);\\r\\n      }\\r\\n      IERC20(token).safeApprove(spender, amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _cutFee(address _token, uint256 _amount) internal returns(uint256) {\\r\\n    if (_amount > 0) {\\r\\n      uint256 fee = _amount * swapFee / coreDecimal;\\r\\n      if (fee > 0) {\\r\\n        if (\\r\\n          (noWrapped == false && _token == address(0)) ||\\r\\n          (noWrapped == true && (_token == WETH || _token == address(0)))\\r\\n        ) {\\r\\n          (bool success, ) = payable(treasury).call{value: fee}(\\\"\\\");\\r\\n          require(success, \\\"BridgePlus: Failed cut fee\\\");\\r\\n        }\\r\\n        else {\\r\\n          IERC20(_token).safeTransfer(treasury, fee);\\r\\n        }\\r\\n      }\\r\\n      emit BridgePlusFee(_token, fee, treasury);\\r\\n      return _amount - fee;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_noWrapped\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_wlContracts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_noFeeBridges\",\"type\":\"address[]\"},{\"internalType\":\"address[2][]\",\"name\":\"_approver\",\"type\":\"address[2][]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DelegatecallFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"BridgePlusFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveToken\",\"type\":\"uint256\"}],\"name\":\"BridgePlusRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"}],\"name\":\"BridgePlusSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approverContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeBridges\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noWrapped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"param\",\"type\":\"bytes\"}],\"internalType\":\"struct BridgePlusv2.RedeemInputType\",\"name\":\"bridgeInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct ISwapPlusV2.SwapInputType\",\"name\":\"inData\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"param\",\"type\":\"bytes\"}],\"internalType\":\"struct ISwapPlusV2.SwapParamType[]\",\"name\":\"pools\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusV2.SwapLineType[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusV2.swapBlockType[]\",\"name\":\"swBlocks\",\"type\":\"tuple[]\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"setApproverContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setNoFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setWhiteListContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"param\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"}],\"internalType\":\"struct BridgePlusv2.SwapInputType\",\"name\":\"bridgeInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct ISwapPlusV2.SwapInputType\",\"name\":\"inData\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"param\",\"type\":\"bytes\"}],\"internalType\":\"struct ISwapPlusV2.SwapParamType[]\",\"name\":\"pools\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusV2.SwapLineType[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusV2.swapBlockType[]\",\"name\":\"swBlocks\",\"type\":\"tuple[]\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BridgePlusv2", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006f6076a7d753ade2c3f5b3866f264a2c8929a50d0000000000000000000000000c250f69f7b550183aadb94b78670a6ab5c4fe0f000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000ee7a4d046a99a59e2fb63d248fc13877da27b479000000000000000000000000ef4fb24ad0916217251f553c0596f8edc630eb66000000000000000000000000663dc15d3c1ac63ff12e45ab68fea3f0a883c2510000000000000000000000008731d54e9d02c286767d56ac03e8037c07e01e98000000000000000000000000f621fb08bbe51af70e7e0f4ea63496894166ff7f0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000ee7a4d046a99a59e2fb63d248fc13877da27b4790000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f621fb08bbe51af70e7e0f4ea63496894166ff7f000000000000000000000000fcef2fe72413b65d3f393d278a714cad87512bcd", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}