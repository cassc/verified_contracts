{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/renderers/CrowdfundNFTRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { LibSafeCast } from \\\"../utils/LibSafeCast.sol\\\";\\nimport { LibRenderer, Color, ColorType } from \\\"../utils/LibRenderer.sol\\\";\\nimport { Strings } from \\\"../utils/vendor/Strings.sol\\\";\\nimport { Base64 } from \\\"../utils/vendor/Base64.sol\\\";\\n\\nimport { RendererBase } from \\\"./RendererBase.sol\\\";\\nimport { RendererStorage } from \\\"./RendererStorage.sol\\\";\\nimport { Crowdfund } from \\\"../crowdfund/Crowdfund.sol\\\";\\nimport { ReraiseETHCrowdfund } from \\\"../crowdfund/ReraiseETHCrowdfund.sol\\\";\\nimport { ETHCrowdfundBase } from \\\"../crowdfund/ETHCrowdfundBase.sol\\\";\\nimport { IFont } from \\\"./fonts/IFont.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\n\\ncontract CrowdfundNFTRenderer is RendererBase {\\n    using LibSafeCast for uint256;\\n    using Strings for uint256;\\n    using Strings for address;\\n\\n    error InvalidTokenIdError();\\n\\n    enum CrowdfundStatus {\\n        LIVE,\\n        WON,\\n        LOST\\n    }\\n\\n    enum CrowdfundType {\\n        NFT,\\n        ETH\\n    }\\n\\n    uint256 constant CROWDFUND_CARD_DATA = 0;\\n\\n    constructor(\\n        IGlobals globals,\\n        RendererStorage rendererStorage,\\n        IFont font\\n    ) RendererBase(globals, rendererStorage, font) {}\\n\\n    function contractURI() external view override returns (string memory) {\\n        (bool isDarkMode, Color color) = getCustomizationChoices();\\n        (string memory image, string memory banner) = LibRenderer.getCollectionImageAndBanner(\\n            color,\\n            isDarkMode\\n        );\\n\\n        return\\n            string.concat(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    abi.encodePacked(\\n                        '{\\\"name\\\":\\\"',\\n                        generateCollectionName(),\\n                        '\\\", \\\"description\\\":\\\"',\\n                        generateCollectionDescription(),\\n                        '\\\", \\\"external_url\\\":\\\"',\\n                        generateExternalURL(),\\n                        '\\\", \\\"image\\\":\\\"',\\n                        image,\\n                        '\\\", \\\"banner\\\":\\\"',\\n                        banner,\\n                        '\\\"}'\\n                    )\\n                )\\n            );\\n    }\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        address owner = Crowdfund(address(this)).ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert InvalidTokenIdError();\\n        }\\n\\n        // Get the customization data for this crowdfund.\\n        (bool isDarkMode, Color color) = getCustomizationChoices();\\n\\n        // Construct metadata.\\n        return\\n            string.concat(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    abi.encodePacked(\\n                        '{\\\"name\\\":\\\"',\\n                        generateName(owner),\\n                        '\\\", \\\"description\\\":\\\"',\\n                        generateDescription(Crowdfund(address(this)).name(), owner),\\n                        '\\\", \\\"external_url\\\":\\\"',\\n                        generateExternalURL(),\\n                        '\\\", \\\"image\\\":\\\"',\\n                        generateSVG(\\n                            Crowdfund(address(this)).name(),\\n                            getContribution(owner),\\n                            getCrowdfundStatus(),\\n                            color,\\n                            isDarkMode\\n                        ),\\n                        '\\\"}'\\n                    )\\n                )\\n            );\\n    }\\n\\n    function generateName(address owner) private view returns (string memory) {\\n        return string.concat(getContribution(owner), \\\" ETH Contribution\\\");\\n    }\\n\\n    function generateExternalURL() private view returns (string memory) {\\n        return string.concat(\\\"https://party.app/join/\\\", address(this).toHexString());\\n    }\\n\\n    function generateDescription(\\n        string memory partyName,\\n        address owner\\n    ) private view returns (string memory) {\\n        CrowdfundStatus status = getCrowdfundStatus();\\n        string memory externalURL = generateExternalURL();\\n        string memory contribution = getContribution(owner);\\n\\n        if (status == CrowdfundStatus.WON) {\\n            return\\n                string.concat(\\n                    partyName,\\n                    \\\" has won! You can use this item to activate your membership in the Party. Head to \\\",\\n                    externalURL,\\n                    \\\" to activate.\\\"\\n                );\\n        } else if (status == CrowdfundStatus.LOST) {\\n            return\\n                string.concat(\\n                    partyName,\\n                    \\\" has lost. You can use this item to claim your ETH back from the Party. Head to \\\",\\n                    externalURL,\\n                    \\\" to claim.\\\"\\n                );\\n        } else {\\n            return\\n                string.concat(\\n                    \\\"This item represents your contribution of \\\",\\n                    contribution,\\n                    \\\" ETH to the \\\",\\n                    partyName,\\n                    \\\" crowdfund. When the crowdfund concludes, you can use this item to claim your ETH or activate your membership in the Party. During the crowdfund, this item is non-transferable. Head to \\\",\\n                    externalURL,\\n                    \\\" to see more.\\\"\\n                );\\n        }\\n    }\\n\\n    function generateCollectionName() internal view returns (string memory) {\\n        return string.concat(\\\"Party Contributions: \\\", Crowdfund(address(this)).name());\\n    }\\n\\n    function generateCollectionDescription() internal view returns (string memory) {\\n        return\\n            string.concat(\\n                \\\"Party Cards in this collection represent contributions to the \\\",\\n                Crowdfund(address(this)).name(),\\n                \\\" crowdfund. When the crowdfund concludes, Party Cards can be used to claim ETH or activate membership in the Party. During the crowdfund, Party Cards are non-transferable. Head to \\\",\\n                generateExternalURL(),\\n                \\\" to learn more about this Party.\\\"\\n            );\\n    }\\n\\n    function generateSVG(\\n        string memory partyName,\\n        string memory contributionAmount,\\n        CrowdfundStatus status,\\n        Color color,\\n        bool isDarkMode\\n    ) public view returns (string memory) {\\n        return\\n            string.concat(\\n                \\\"data:image/svg+xml;base64,\\\",\\n                Base64.encode(\\n                    abi.encodePacked(\\n                        // Split to avoid stack too deep errors\\n                        generateSVG1(color, isDarkMode),\\n                        generateSVG2(partyName, color),\\n                        generateSVG3(contributionAmount, color),\\n                        generateSVG4(status, color),\\n                        generateSVG5(partyName)\\n                    )\\n                )\\n            );\\n    }\\n\\n    function generateSVG1(Color color, bool isDarkMode) private pure returns (string memory) {\\n        return\\n            string.concat(\\n                '<svg width=\\\"540\\\" height=\\\"540\\\" viewBox=\\\"0 -10 360 560\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"><defs><linearGradient id=\\\"d\\\" x1=\\\"0\\\" x2=\\\"0\\\" y1=\\\"0\\\" y2=\\\"1\\\"><stop offset=\\\"0\\\" stop-color=\\\"',\\n                isDarkMode ? \\\"#2e3847\\\" : \\\"#ffffff\\\",\\n                '\\\"/><stop offset=\\\"1\\\" stop-color=\\\"',\\n                isDarkMode ? \\\"#000000\\\" : \\\"#e6edf5\\\",\\n                '\\\"/></linearGradient><linearGradient id=\\\"e\\\" x1=\\\"0\\\" x2=\\\"0\\\" y1=\\\"0\\\" y2=\\\"1\\\"><stop offset=\\\"0\\\" stop-color=\\\"',\\n                isDarkMode ? \\\"#8091a8\\\" : \\\"#e6edf6\\\",\\n                '\\\"/><stop offset=\\\"1\\\" stop-color=\\\"',\\n                isDarkMode ? \\\"#2e3848\\\" : \\\"#bccbdd\\\",\\n                '\\\"/></linearGradient><linearGradient id=\\\"f\\\" x1=\\\"0\\\" x2=\\\"0\\\" y1=\\\"1\\\" y2=\\\"0\\\"><stop offset=\\\"0\\\" stop-color=\\\"',\\n                LibRenderer.generateColorHex(color, ColorType.SECONDARY),\\n                '\\\"/><stop offset=\\\"1\\\" stop-color=\\\"',\\n                LibRenderer.generateColorHex(color, ColorType.PRIMARY),\\n                '\\\"/></linearGradient><linearGradient id=\\\"f2\\\" x1=\\\"0\\\" x2=\\\"0\\\" y1=\\\"-.5\\\" y2=\\\"1\\\"><stop offset=\\\"0\\\" stop-color=\\\"',\\n                LibRenderer.generateColorHex(color, ColorType.SECONDARY),\\n                '\\\"/><stop offset=\\\"1\\\" stop-color=\\\"',\\n                LibRenderer.generateColorHex(color, ColorType.PRIMARY),\\n                '\\\"/></linearGradient><linearGradient id=\\\"h\\\" x1=\\\"0\\\" x2=\\\"0\\\" y1=\\\"0\\\" y2=\\\"1\\\"><stop offset=\\\"0\\\" stop-color=\\\"',\\n                isDarkMode ? \\\"#ffffff\\\" : \\\"#3f485f\\\",\\n                '\\\"/><stop offset=\\\".5\\\"  stop-color=\\\"',\\n                isDarkMode ? \\\"#a7b8cf\\\" : \\\"#000000\\\",\\n                '\\\"/></linearGradient><radialGradient cx=\\\"1\\\" cy=\\\"-.5\\\" id=\\\"i\\\" r=\\\"2\\\"><stop offset=\\\"0\\\" stop-color=\\\"#dce5f0\\\"/><stop offset=\\\".5\\\" stop-color=\\\"#dce5f0\\\" stop-opacity=\\\"0\\\"/></radialGradient><symbol id=\\\"a\\\" viewBox=\\\"0 0 300.15 300\\\"><path class=\\\"s\\\" d=\\\"M6.08 0v300M3.07 0v300M.08 0v300m9-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300m3-300v300\\\"/></symbol>'\\n            );\\n    }\\n\\n    function generateSVG2(\\n        string memory partyName,\\n        Color color\\n    ) private view returns (string memory) {\\n        (uint256 duration, uint256 steps, uint256 delay, uint256 translateX) = LibRenderer\\n            .calcAnimationVariables(partyName);\\n        return\\n            string.concat(\\n                '<symbol id=\\\"b\\\" viewBox=\\\"0 0 300 21.15\\\"><path class=\\\"s\\\" d=\\\"M0 21.08h300m-300-3h300m-300-3h300m-300-3h300m-300-3h300m-300-3h300m-300-3h300M0 .08h300\\\"/></symbol><style>.z{animation:x ',\\n                duration.toString(),\\n                \\\"s steps(\\\",\\n                steps.toString(),\\n                \\\") infinite;}.y{animation-delay:\\\",\\n                delay.toString(),\\n                \\\"s}@keyframes x{to{transform:translateX(-\\\",\\n                translateX.toString(),\\n                \\\"px)}}.o,.p{fill:\\\",\\n                LibRenderer.generateColorHex(color, ColorType.DARK),\\n                \\\";font-family:pixeldroidConsoleRegular,Console;font-size:48px}.w{animation:W 1s steps(1, jump-end) infinite;}@keyframes W{50%{fill:\\\",\\n                LibRenderer.generateColorHex(color, ColorType.LIGHT),\\n                \\\"}}.s{fill:none;stroke:\\\",\\n                LibRenderer.generateColorHex(color, ColorType.PRIMARY),\\n                \\\";stroke-width:.15px}@font-face{font-family:pixeldroidConsoleRegular;src:url(\\\",\\n                _font.getFont(),\\n                \\\");}</style></defs>\\\"\\n            );\\n    }\\n\\n    function generateSVG3(\\n        string memory contributionAmount,\\n        Color color\\n    ) private pure returns (string memory) {\\n        return\\n            string.concat(\\n                '<rect height=\\\"539\\\" rx=\\\"29.5\\\" ry=\\\"29.5\\\" style=\\\"fill:url(#d);stroke:url(#e);\\\" width=\\\"359\\\" x=\\\".5\\\" y=\\\".5\\\"/><path d=\\\"M30 525.5c-8.55 0-15.5-6.95-15.5-15.5v-98c0-8.55 6.95-15.5 15.5-15.5h113.81a30.5 30.5 0 0 1 19.97 7.45l28.09 24.34a29.48 29.48 0 0 0 19.32 7.21H330c8.55 0 15.5 6.95 15.5 15.5v59c0 8.55-6.95 15.5-15.5 15.5H30Z\\\" style=\\\"fill:',\\n                LibRenderer.generateColorHex(color, ColorType.PRIMARY),\\n                ';stroke:url(#f)\\\"/><path d=\\\"M330 444H30v27h300v-27Zm-219-27.5v15H36v-15h75Z\\\" fill=\\\"',\\n                LibRenderer.generateColorHex(color, ColorType.LIGHT),\\n                '\\\"/><text class=\\\"p\\\" x=\\\"33\\\" y=\\\"431.5\\\">',\\n                contributionAmount,\\n                \\\"</text>\\\"\\n            );\\n    }\\n\\n    function generateSVG4(\\n        CrowdfundStatus status,\\n        Color color\\n    ) private pure returns (string memory) {\\n        string memory activeColorHex = LibRenderer.generateColorHex(color, ColorType.DARK);\\n        string memory inactiveColorHex = LibRenderer.generateColorHex(color, ColorType.LIGHT);\\n        return\\n            string.concat(\\n                '<use height=\\\"21.15\\\" transform=\\\"matrix(.3 0 0 1 30 413.42)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><use height=\\\"21.15\\\" transform=\\\"matrix(0 -.05 1 0 32.92 431.5)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><use height=\\\"21.15\\\" transform=\\\"matrix(0 -.05 1 0 56.92 431.5)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><use height=\\\"21.15\\\" transform=\\\"matrix(0 -.05 1 0 80.92 431.5)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><use height=\\\"21.15\\\" transform=\\\"matrix(0 -.05 1 0 104.92 431.5)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><clipPath id=\\\"C1\\\"><path d=\\\"M115 480H35a5 5 0 0 0-5 5v20a5 5 0 0 0 5 5h80a5 5 0 0 0 5-5v-20a5 5 0 0 0-5-5Zm-50.74 21.5h-8.4v-13h2.65v10.45h5.75v2.55Zm5.17 0h-2.65v-13h2.65v13Zm9.76 0h-3.35l-4.42-13h2.89l3.2 9.93 3.3-9.93h2.82l-4.44 13Zm14.96 0h-8.53v-13h8.41v2.5h-5.81v2.7h5.41v2.5h-5.41v2.8h5.93v2.5Z\\\" /></clipPath><g clip-path=\\\"url(#C1)\\\"><rect class=\\\"w\\\" x=\\\"30\\\" y=\\\"480\\\" width=\\\"300\\\" height=\\\"35\\\" fill=\\\"',\\n                status == CrowdfundStatus.LIVE ? activeColorHex : inactiveColorHex,\\n                '\\\"/></g><clipPath id=\\\"C2\\\"><path d=\\\"M220 480h-80a5 5 0 0 0-5 5v20a5 5 0 0 0 5 5h80a5 5 0 0 0 5-5v-20a5 5 0 0 0-5-5Zm-48.84 21.5h-3.09l-2.28-9.89-2.24 9.89h-3.09l-3.23-13h2.84l2.06 9.52 2.26-9.52h2.92l2.21 9.52 2.12-9.52h2.75l-3.23 13Zm10.8.24c-3.77 0-6.46-2.8-6.46-6.73s2.69-6.75 6.46-6.75 6.41 2.8 6.41 6.75-2.67 6.73-6.41 6.73Zm19.72-.24h-3.55l-4.9-9.91v9.91h-2.53v-13h3.57l4.9 9.91v-9.91h2.52v13Zm-16.08-6.49c0 2.55-1.39 4.18-3.64 4.18s-3.69-1.63-3.69-4.18 1.41-4.2 3.69-4.2 3.64 1.63 3.64 4.2Z\\\" /></clipPath><g clip-path=\\\"url(#C2)\\\"><rect class=\\\"w\\\" x=\\\"30\\\" y=\\\"480\\\" width=\\\"300\\\" height=\\\"35\\\" fill=\\\"',\\n                status == CrowdfundStatus.WON ? activeColorHex : inactiveColorHex,\\n                '\\\"/></g><clipPath id=\\\"C3\\\"><path d=\\\"M282.74 495.01c0 2.55-1.39 4.18-3.64 4.18s-3.69-1.63-3.69-4.18 1.41-4.2 3.69-4.2 3.64 1.63 3.64 4.2ZM330 485v20a5 5 0 0 1-5 5h-80a5 5 0 0 1-5-5v-20a5 5 0 0 1 5-5h80a5 5 0 0 1 5 5Zm-58.84 13.95h-5.75V488.5h-2.65v13h8.4v-2.55Zm14.35-3.94c0-3.94-2.67-6.75-6.41-6.75s-6.46 2.8-6.46 6.75 2.69 6.73 6.46 6.73 6.41-2.8 6.41-6.73Zm10.73 2.62c0-2.01-.95-3.11-3.16-3.72l-1.6-.48c-.94-.25-1.39-.63-1.41-1.36 0-.87.78-1.29 1.9-1.29 1.21 0 2.43.31 3.59 1.02v-2.74c-1-.54-2.26-.8-3.54-.8-2.87 0-4.69 1.5-4.69 3.86 0 1.99 1.05 3.18 3.21 3.76l1.45.41c1.02.29 1.5.61 1.5 1.44 0 .95-.71 1.5-2.04 1.5s-2.74-.48-3.94-1.38v2.8a7.38 7.38 0 0 0 4.1 1.09c2.79 0 4.64-1.56 4.64-4.11ZM308 488.5h-10.2v2.55h3.76v10.45h2.67v-10.45H308v-2.55Z\\\" /></clipPath><g clip-path=\\\"url(#C3)\\\"><rect class=\\\"w\\\" x=\\\"30\\\" y=\\\"480\\\" width=\\\"300\\\" height=\\\"35\\\" fill=\\\"',\\n                status == CrowdfundStatus.LOST ? activeColorHex : inactiveColorHex,\\n                '\\\"/></g><path d=\\\"M307.54 128.19c2.23 2.13 9.81 23.93-1.54 56.42a184.3 184.3 0 0 0-8.52-9.01c6.58-14.64 11.75-31.59 10.05-47.41Zm-59.07-68.13c19.25 52.08-33.89 116.63-48.05 132.17 2.04 5.7 3.73 10.51 5.25 15.07 28.45-30.16 75.83-100.73 42.79-147.24Zm-59.24 175.15a229.14 229.14 0 0 1-40 25.97l17.58 6.07a206.25 206.25 0 0 0 39.03-26.6 322.04 322.04 0 0 1-16.61-5.44Zm81.35 21.49a266.02 266.02 0 0 1-41.9 35.94c4.21 3.38 8.21 6.37 11.97 8.91 1.37-.91 2.72-1.83 4.07-2.78a259.48 259.48 0 0 0 35.1-32.86c-2.81-2.86-5.9-5.94-9.22-9.2Zm-133.69.23c14.84-6.44 29.13-15.2 42.38-25.55a361.48 361.48 0 0 1-14.65-6.41 205.7 205.7 0 0 1-34.06 21.06 189.9 189.9 0 0 1-10.6 5.07l16.91 5.83ZM326.25 150.6c-.06 15.08-5.71 30.79-12.03 44.27 2.35 3.22 4.47 6.41 6.3 9.55 10.53-28.27 12.04-43.96 5.71-53.81Zm-65.4-80.13c35.47 46.42-30.24 125.73-51.91 147.16 1.47 4.85 2.92 10 4.56 16.16 19.74-19.48 98.57-111.61 47.34-163.31Zm18.4 88.96c3.12 2.48 6.16 5.01 9.07 7.59 11.63-33.33 2.97-52.2.87-53.67 1.24 15.44-3.65 31.81-9.94 46.07Zm-15.09 91.04c-1.97-6.65-4.46-16.9-4.46-16.9a256.46 256.46 0 0 1-54.28 47.06 269.45 269.45 0 0 1 16.46 6.38 229.93 229.93 0 0 0 42.28-36.54Zm-6.52-29.51-3.15-19.36c-24.69 30.64-47.69 52.28-76.91 69.38l17.48 6.05c23.83-14.19 45.49-34.09 62.59-56.07Zm-78.37 93.2c8.68 5.69 25.08 8.22 36.42 2.39 11.69-7.45-1.16-16.17-15.52-19.14-19-3.93-32.58 2.36-25.98 12.03a18 18 0 0 0 5.07 4.72m-3.57.77c-6.91-4.6-13.12-13.96-.44-19.54 20.17-6.65 55.01 6.2 48.43 17.86-1.14 2.01-2.82 3.1-4.61 4.25h-.02v.02h-.03v.02h-.03v.02h-.03v.02h-.03v.02h-.02c-13.64 7.05-33.06 4.1-43.22-2.65m10.63-7.48c.48.36 4.83 3.44 9.81.96l2.61-1.44-9.07-4.62c-.95.52-1.9 1.03-2.86 1.53-.74.42-2.97 1.71-.49 3.56m-3.29 1.14c-4.56-3.05-1.5-5.06-.04-6.03 2.12-1.1 4.23-2.23 6.36-3.43 13.46 7.1 13.99 7.38 25.56 11.95l-2.67 1.58c-3.74-1.52-8.75-3.52-12.43-5.19 1.67 2.71 3.86 6.34 5.62 8.99-1.08.58-2.17 1.15-3.25 1.69-1.45-2.48-3.42-5.79-4.78-8.32-6.18 3.99-13.55-.7-14.37-1.25\\\" style=\\\"fill:url(#f2)\\\"/><path d=\\\"M309.28 103.41C279.02 48.51 232.39 31 201.68 31c-23.1 0-50.31 11.2-71.38 25.52 18.48 8.49 42.36 30.93 42.66 31.21-15.38-5.9-34.54-13.03-64.39-15.25a260.56 260.56 0 0 0-38.3 39.5c1.48 14.84 5.58 30.39 5.58 30.39-12.16-9.2-21.36-8.93-34.87 18.31-10.45 24.52-13.43 46.98-9.01 64.29 0 0 9.14 51.93 70.2 77.64-2.52-8.93-3.06-19.21-1.81-30.48a169.77 169.77 0 0 1-30.28-19.12c1.54-12.81 5.41-26.79 11.62-41.39 8.56-20.65 8.42-29.35 8.42-29.43.06.13 10.63 24.09 25.1 42.78 8.2-17.13 18.33-31.15 26.5-42.29l-7.3-13.08a279.8 279.8 0 0 1 35.24-36.34c3.96 2.08 9.28 4.78 13.24 6.94 16.83-14.09 37.29-27.21 59.21-35.44-13.57-22.26-31.04-37.34-31.04-37.34s53.67 5.31 81.42 30.4c6.31 1 11.89 2.89 16.76 5.59ZM56.32 210.27a136.81 136.81 0 0 0-5.31 24.25 108.25 108.25 0 0 1-11.99-17.13c.9-7.48 2.62-15.33 5.14-23.44 3.43-10.28 6.49-11.46 11.35-4.33v-.09c4.14 5.95 3.52 11.9.81 20.74Zm64.16-68.44-.09.09c-6.76-14.43-9.1-19.66-15.05-35.08l.27-.27c15.95 5.32 20.63 7.04 35.95 13.52a283.5 283.5 0 0 0-21.09 21.73Zm106.25-91.81a134.04 134.04 0 0 0-26.5 7.21 126.2 126.2 0 0 0-15.14-10.28 128.66 128.66 0 0 1 25.23-6.85c2.97-.36 12.07-1.54 20.01 4.69v-.09c4.77 3.69.27 4.6-3.6 5.32Z\\\" style=\\\"fill:url(#h)\\\"/>'\\n            );\\n    }\\n\\n    function generateSVG5(string memory partyName) private view returns (string memory) {\\n        return\\n            string.concat(\\n                '<clipPath id=\\\"clip\\\"><path d=\\\"M330 444H30v27h300\\\"/></clipPath><g clip-path=\\\"url(#clip)\\\"><g class=\\\"z\\\"><text class=\\\"p\\\" x=\\\"327\\\" y=\\\"465\\\">',\\n                partyName,\\n                '</text></g><g class=\\\"z y\\\"><text class=\\\"p\\\" x=\\\"327\\\" y=\\\"465\\\">',\\n                partyName,\\n                \\\"</text></g></g>\\\",\\n                _storage.readFile(CROWDFUND_CARD_DATA)\\n            );\\n    }\\n\\n    function getContribution(address owner) private view returns (string memory amount) {\\n        uint256 ethContributed;\\n        if (getCrowdfundType() == CrowdfundType.NFT) {\\n            (ethContributed, , , ) = Crowdfund(address(this)).getContributorInfo(owner);\\n        } else {\\n            uint96 votingPower = ReraiseETHCrowdfund(address(this)).pendingVotingPower(owner);\\n\\n            ethContributed = ReraiseETHCrowdfund(address(this)).convertVotingPowerToContribution(\\n                votingPower\\n            );\\n        }\\n\\n        return LibRenderer.formatAsDecimalString(ethContributed, 18, 4);\\n    }\\n\\n    function getCrowdfundStatus() private view returns (CrowdfundStatus) {\\n        if (getCrowdfundType() == CrowdfundType.NFT) {\\n            Crowdfund.CrowdfundLifecycle lifecycle = Crowdfund(payable(address(this)))\\n                .getCrowdfundLifecycle();\\n\\n            if (lifecycle == Crowdfund.CrowdfundLifecycle.Won) {\\n                return CrowdfundStatus.WON;\\n            } else if (\\n                lifecycle == Crowdfund.CrowdfundLifecycle.Lost ||\\n                lifecycle == Crowdfund.CrowdfundLifecycle.Expired\\n            ) {\\n                return CrowdfundStatus.LOST;\\n            } else {\\n                return CrowdfundStatus.LIVE;\\n            }\\n        } else {\\n            ETHCrowdfundBase.CrowdfundLifecycle lifecycle = ETHCrowdfundBase(payable(address(this)))\\n                .getCrowdfundLifecycle();\\n\\n            if (\\n                lifecycle == ETHCrowdfundBase.CrowdfundLifecycle.Won ||\\n                lifecycle == ETHCrowdfundBase.CrowdfundLifecycle.Finalized\\n            ) {\\n                return CrowdfundStatus.WON;\\n            } else if (lifecycle == ETHCrowdfundBase.CrowdfundLifecycle.Lost) {\\n                return CrowdfundStatus.LOST;\\n            } else {\\n                return CrowdfundStatus.LIVE;\\n            }\\n        }\\n    }\\n\\n    function getCrowdfundType() private view returns (CrowdfundType) {\\n        // If this function does not exist, then it is an NFT crowdfund.\\n        (bool success, bytes memory res) = address(this).staticcall(\\n            abi.encodeWithSignature(\\\"exchangeRateBps()\\\")\\n        );\\n\\n        if (success && res.length == 32) {\\n            return CrowdfundType.ETH;\\n        } else {\\n            return CrowdfundType.NFT;\\n        }\\n    }\\n\\n    function calcAnimationVariables(\\n        string memory partyName\\n    ) private pure returns (uint256 duration, uint256 steps, uint256 delay, uint256 translateX) {\\n        translateX = bytes(partyName).length * 30 + 300;\\n        duration = translateX / 56;\\n        if (duration % 2 != 0) {\\n            // Make duration even so that the animation delay is always exactly\\n            // half of the duration\\n            duration += 1;\\n        }\\n        delay = duration / 2;\\n        steps = translateX / 6;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibSafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibSafeCast {\\n    error Uint256ToUint96CastOutOfRange(uint256 v);\\n    error Uint256ToInt192CastOutOfRange(uint256 v);\\n    error Int192ToUint96CastOutOfRange(int192 i192);\\n    error Uint256ToInt128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint40CastOutOfRangeError(uint256 u256);\\n\\n    function safeCastUint256ToUint96(uint256 v) internal pure returns (uint96) {\\n        if (v > uint256(type(uint96).max)) {\\n            revert Uint256ToUint96CastOutOfRange(v);\\n        }\\n        return uint96(v);\\n    }\\n\\n    function safeCastUint256ToUint128(uint256 v) internal pure returns (uint128) {\\n        if (v > uint256(type(uint128).max)) {\\n            revert Uint256ToUint128CastOutOfRangeError(v);\\n        }\\n        return uint128(v);\\n    }\\n\\n    function safeCastUint256ToInt192(uint256 v) internal pure returns (int192) {\\n        if (v > uint256(uint192(type(int192).max))) {\\n            revert Uint256ToInt192CastOutOfRange(v);\\n        }\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastUint96ToInt192(uint96 v) internal pure returns (int192) {\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastInt192ToUint96(int192 i192) internal pure returns (uint96) {\\n        if (i192 < 0 || i192 > int192(uint192(type(uint96).max))) {\\n            revert Int192ToUint96CastOutOfRange(i192);\\n        }\\n        return uint96(uint192(i192));\\n    }\\n\\n    function safeCastUint256ToInt128(uint256 x) internal pure returns (int128) {\\n        if (x > uint256(uint128(type(int128).max))) {\\n            revert Uint256ToInt128CastOutOfRangeError(x);\\n        }\\n        return int128(uint128(x));\\n    }\\n\\n    function safeCastUint256ToUint40(uint256 x) internal pure returns (uint40) {\\n        if (x > uint256(type(uint40).max)) {\\n            revert Uint256ToUint40CastOutOfRangeError(x);\\n        }\\n        return uint40(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Strings } from \\\"../utils/vendor/Strings.sol\\\";\\n\\nenum Color {\\n    DEFAULT,\\n    GREEN,\\n    CYAN,\\n    BLUE,\\n    PURPLE,\\n    PINK,\\n    ORANGE,\\n    RED\\n}\\n\\nenum ColorType {\\n    PRIMARY,\\n    SECONDARY,\\n    LIGHT,\\n    DARK\\n}\\n\\nlibrary LibRenderer {\\n    using Strings for uint256;\\n    using Strings for string;\\n\\n    function calcAnimationVariables(\\n        string memory partyName\\n    ) external pure returns (uint256 duration, uint256 steps, uint256 delay, uint256 translateX) {\\n        translateX = bytes(partyName).length * 30 + 300;\\n        duration = translateX / 56;\\n\\n        // Make duration even so that the animation delay is always exactly\\n        // half of the duration.\\n        if (duration % 2 != 0) duration += 1;\\n\\n        delay = duration / 2;\\n        steps = translateX / 6;\\n    }\\n\\n    function formatAsDecimalString(\\n        uint256 n,\\n        uint256 decimals,\\n        uint256 maxChars\\n    ) external pure returns (string memory) {\\n        string memory str = n.toString();\\n        uint256 oneUnit = 10 ** decimals;\\n        if (n < 10 ** (decimals - 2)) {\\n            return \\\"&lt;0.01\\\";\\n        } else if (n < oneUnit) {\\n            // Preserve leading zeros for decimals.\\n            // (e.g. if 0.01, `n` will \\\"1\\\" so we need to prepend a \\\"0\\\").\\n            return\\n                string.concat(\\\"0.\\\", prependNumWithZeros(str, decimals).substring(0, maxChars - 1));\\n        } else if (n >= 1000 * oneUnit) {\\n            return str.substring(0, maxChars);\\n        } else {\\n            uint256 i = bytes((n / oneUnit).toString()).length;\\n            return string.concat(str.substring(0, i), \\\".\\\", str.substring(i, maxChars));\\n        }\\n    }\\n\\n    function prependNumWithZeros(\\n        string memory numStr,\\n        uint256 expectedLength\\n    ) public pure returns (string memory) {\\n        uint256 length = bytes(numStr).length;\\n        if (length < expectedLength) {\\n            for (uint256 i; i < expectedLength - length; ++i) {\\n                numStr = string.concat(\\\"0\\\", numStr);\\n            }\\n        }\\n\\n        return numStr;\\n    }\\n\\n    function generateColorHex(\\n        Color color,\\n        ColorType colorType\\n    ) external pure returns (string memory colorHex) {\\n        if (color == Color.DEFAULT) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#A7B8CF\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#DCE5F0\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#91A6C3\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#50586D\\\";\\n            }\\n        } else if (color == Color.GREEN) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#10B173\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#93DCB7\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#00A25A\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#005E3B\\\";\\n            }\\n        } else if (color == Color.CYAN) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#00C1FA\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#B1EFFD\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#00B4EA\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#005669\\\";\\n            }\\n        } else if (color == Color.BLUE) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#2C78F3\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#B3D4FF\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#0E70E0\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#00286A\\\";\\n            }\\n        } else if (color == Color.PURPLE) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#9B45DF\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#D2ACF2\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#832EC9\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#47196B\\\";\\n            }\\n        } else if (color == Color.PINK) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#FF6BF3\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#FFC8FB\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#E652E2\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#911A96\\\";\\n            }\\n        } else if (color == Color.ORANGE) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#FF8946\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#FFE38B\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#E47B2F\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#732700\\\";\\n            }\\n        } else if (color == Color.RED) {\\n            if (colorType == ColorType.PRIMARY) {\\n                return \\\"#EC0000\\\";\\n            } else if (colorType == ColorType.SECONDARY) {\\n                return \\\"#FFA6A6\\\";\\n            } else if (colorType == ColorType.LIGHT) {\\n                return \\\"#D70000\\\";\\n            } else if (colorType == ColorType.DARK) {\\n                return \\\"#6F0000\\\";\\n            }\\n        }\\n    }\\n\\n    function getCollectionImageAndBanner(\\n        Color color,\\n        bool isDarkMode\\n    ) external pure returns (string memory image, string memory banner) {\\n        if (isDarkMode) {\\n            if (color == Color.GREEN) {\\n                image = \\\"QmdcjXrxj7EimjuNTLQp1uKM2zYhuF1WVkVjF6TpfNNXrf\\\";\\n                banner = \\\"QmR3vqAV17SJiwksiCHV1cLQuf9TKZuar8NQu8GmKkHRXM\\\";\\n            } else if (color == Color.CYAN) {\\n                image = \\\"QmS678DTkTTzFQEDiqj3AsW6wt6bi4bNhWbKcBM29HBhhB\\\";\\n                banner = \\\"QmYSbXyPh9Lx2wmv6Z7SK8iFD9kyADxtaohV1gv6ZVKFj4\\\";\\n            } else if (color == Color.BLUE) {\\n                image = \\\"QmX2k8beAjyVhPk1ZrK6KrwbqLk3fRNPPmknRti7zEtGQa\\\";\\n                banner = \\\"QmaXN8MbcrjkHPt97Z7xeuTCx6wPkJ9xZN7ExZZwMabspy\\\";\\n            } else if (color == Color.PURPLE) {\\n                image = \\\"Qmf8SrxKH3QZQCEzcMbA3UoJGZ1j2coTLaQFptWhZZvqhg\\\";\\n                banner = \\\"QmWhpo9kN2Nf8ioWb7BKwqsCQKt3M2TduHPNqMqXz9jUK4\\\";\\n            } else if (color == Color.PINK) {\\n                image = \\\"QmV5eT9DWvU5BJa4LVSemkoDKyjJBC56adk2JLWMXYEQfn\\\";\\n                banner = \\\"QmP2NTyvMQ5yN1RY4nH1HfoTX2r6Ug6WZfN9GFf9toak8M\\\";\\n            } else if (color == Color.ORANGE) {\\n                image = \\\"QmPirB7VFaao2ZUxLtM5WTCwZhE7c9Uy2heyNZF5t9PgsS\\\";\\n                banner = \\\"QmUMgkjhrxedcLUvWt8VKrZdvrCGmjxWDSDXfm2M96nKUx\\\";\\n            } else if (color == Color.RED) {\\n                image = \\\"QmNRZ3syuEiiAkWYRFs9BpQ5M38wv8tEu17J2sYwmMdeta\\\";\\n                banner = \\\"QmQV1EjzwQsXdgi6C6ubfopZrprk6Ab9LVnggZBgJDg5C2\\\";\\n            } else {\\n                image = \\\"QmNwGtGyYwDfS6ghQbDw5a9buv7auFXz63W3rDhzmxjVhw\\\";\\n                banner = \\\"QmYUujTBgH6RTswZSiSzuy2GUojE6H9edaXeoSwwvh2T7o\\\";\\n            }\\n        } else {\\n            if (color == Color.GREEN) {\\n                image = \\\"QmR7t2g2hrkMYyzhUMEANzEGX74FQcbg3c7eTvCcQucMst\\\";\\n                banner = \\\"Qmc3zRfT6nC2G1KgoWpCvLDVjNi7x7KFgwButecj3sq9qg\\\";\\n            } else if (color == Color.CYAN) {\\n                image = \\\"QmeiBRb9muNXej3dn4usjjdtbUpgYASfA5jmWqJRshivGH\\\";\\n                banner = \\\"QmcsvMB2xiBKKMyKsBkC51TjWnyk42nNJnsudoGFsvvXCt\\\";\\n            } else if (color == Color.BLUE) {\\n                image = \\\"QmaErgGsanUTo73RMgvizMg3c7x1d1X4t76Tti22Pc1xan\\\";\\n                banner = \\\"QmSjhHF994xBd7wavV4mhj7GpZmw5euQUBxpiPbbmxExqp\\\";\\n            } else if (color == Color.PURPLE) {\\n                image = \\\"QmeVJTcUpKQFSz5aBsVpQk8quoXEEZBNPAAMo3wHvdRzHa\\\";\\n                banner = \\\"QmYx6aHYGitr6p8dHUa7n4nyew3pWy1Mfdn8fpFLejmhHC\\\";\\n            } else if (color == Color.PINK) {\\n                image = \\\"QmY4JJkBEeHVYHdfCCXPd7bWkAhNRxuKTWdf9MssGxSmCG\\\";\\n                banner = \\\"QmQH5CFf3qXG2oymGzwTDgUmPFBsaTw2Qbfhjk58VHcABd\\\";\\n            } else if (color == Color.ORANGE) {\\n                image = \\\"QmYhB3vjBLPwPTC5SBidNbZhB5oBMBMpKy4g6ejTxmGLkK\\\";\\n                banner = \\\"QmRP8cVjJyPRV7wXs5ApwbCFyTBpHXmHsDexbcN4o7aomd\\\";\\n            } else if (color == Color.RED) {\\n                image = \\\"QmfG8HPMEsKwKJ8xX3i2JhJtCskuiUjZLe8NhvXFdYyFR2\\\";\\n                banner = \\\"QmazXbqfFtQexkwFDbYkyvLF4xRSDrmEVQS4PSAs2ZtxDn\\\";\\n            } else {\\n                image = \\\"QmZKE4XkPvU7Z8CdgK2Cn7gLQ4t8CDkkfnR1j5bZ2AfRJu\\\";\\n                banner = \\\"QmTKCqLUQJt3VxGuUqLMj1jcCRRsaZwY4k757Wb7YPzmH2\\\";\\n            }\\n        }\\n\\n        image = string.concat(\\\"ipfs://\\\", image);\\n        banner = string.concat(\\\"ipfs://\\\", banner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/vendor/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8;\\n\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    function substring(\\n        string memory str,\\n        uint startIndex,\\n        uint endIndex\\n    ) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex - startIndex);\\n        for (uint i = startIndex; i < endIndex; i++) {\\n            result[i - startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/vendor/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8;\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/RendererBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Strings } from \\\"../utils/vendor/Strings.sol\\\";\\nimport { Color } from \\\"../utils/LibRenderer.sol\\\";\\nimport { Party } from \\\"contracts/party/Party.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { IFont } from \\\"./fonts/IFont.sol\\\";\\nimport { IERC721Renderer } from \\\"./IERC721Renderer.sol\\\";\\nimport { RendererStorage } from \\\"./RendererStorage.sol\\\";\\nimport { IParty1_1 } from \\\"./IParty1_1.sol\\\";\\n\\nabstract contract RendererBase is IERC721Renderer {\\n    using Strings for uint256;\\n    using Strings for string;\\n\\n    IGlobals immutable _GLOBALS;\\n    RendererStorage immutable _storage;\\n    IFont immutable _font;\\n\\n    constructor(IGlobals globals, RendererStorage rendererStorage, IFont font) {\\n        _GLOBALS = globals;\\n        _storage = rendererStorage;\\n        _font = font;\\n    }\\n\\n    function contractURI() external view virtual returns (string memory);\\n\\n    function getCustomizationChoices() internal view returns (bool isDarkMode, Color color) {\\n        // Get the customization preset ID chosen by the crowdfund or party instance.\\n        uint256 presetId = _storage.getPresetFor(address(this));\\n\\n        if (presetId == 0) {\\n            // Preset ID 0 is reserved. It is used to indicate to party instances\\n            // to use the same customization preset as the crowdfund.\\n            (bool success, bytes memory result) = address(this).staticcall(\\n                abi.encodeCall(IParty1_1.mintAuthority, ())\\n            );\\n\\n            if (success && result.length == 32) {\\n                address crowdfund = abi.decode(result, (address));\\n                // Should return the crowdfund used to create the party, if the\\n                // party was created conventionally. Use the customization\\n                // preset chosen during crowdfund initialization.\\n                presetId = _storage.getPresetFor(crowdfund);\\n                // If the preset ID is still 0 (this shouldn't happen), fallback\\n                // to the default customization options.\\n                if (presetId == 0) return (false, Color.DEFAULT);\\n            } else {\\n                // Fallback to the default customization options. May happen if\\n                // called from a non-party contract (e.g. a crowdfund contract,\\n                // although this shouldn't happen).\\n                return (false, Color.DEFAULT);\\n            }\\n        }\\n\\n        // Get the customization data for the preset chosen.\\n        bytes memory customizationData = _storage.customizationPresets(presetId);\\n        if (customizationData.length == 0) {\\n            // If the customization preset doesn't exist, fallback to the\\n            // default customization options.\\n            return (false, Color.DEFAULT);\\n        }\\n\\n        // Check version number. Fallback to default if using different version.\\n        if (abi.decode(customizationData, (uint8)) == 1) {\\n            (, isDarkMode, color) = abi.decode(customizationData, (uint8, bool, Color));\\n        } else {\\n            // Fallback to the default customization options.\\n            return (false, Color.DEFAULT);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/RendererStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"solmate/utils/SSTORE2.sol\\\";\\nimport \\\"../utils/Multicall.sol\\\";\\n\\ncontract RendererStorage is Multicall {\\n    error AlreadySetError();\\n    error NotOwnerError(address caller, address owner);\\n\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    uint256 constant CROWDFUND_CARD_DATA = 0;\\n    uint256 constant PARTY_CARD_DATA = 1;\\n\\n    /// @notice Address allowed to store new data.\\n    address public owner;\\n\\n    /// @notice Customization presets by ID, used for rendering cards. Begins at\\n    ///         1, 0 is reserved to indicate in `getPresetFor()` that a\\n    ///         party instance use the preset set by the crowdfund instance that\\n    ///         created it.\\n    mapping(uint256 => bytes) public customizationPresets;\\n    /// @notice Customization preset used by a crowdfund or party instance.\\n    mapping(address => uint256) public getPresetFor;\\n    /// @notice Addresses where URI data chunks are stored.\\n    mapping(uint256 => address) public files;\\n\\n    modifier onlyOwner() {\\n        address owner_ = owner;\\n        if (msg.sender != owner_) {\\n            revert NotOwnerError(msg.sender, owner_);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        // Set the address allowed to write new data.\\n        owner = _owner;\\n\\n        // Write URI data used by V1 of the renderers:\\n\\n        files[CROWDFUND_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                '<path class=\\\"o\\\" d=\\\"M118.4 419.5h5.82v1.73h-4.02v1.87h3.74v1.73h-3.74v1.94h4.11v1.73h-5.91v-9Zm9.93 1.76h-2.6v-1.76h7.06v1.76h-2.61v7.24h-1.85v-7.24Zm6.06-1.76h1.84v3.55h3.93v-3.55H142v9h-1.84v-3.67h-3.93v3.67h-1.84v-9Z\\\"/><path class=\\\"o\\\" d=\\\"M145 413a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H35a4 4 0 0 1-4-4v-14a4 4 0 0 1 4-4h110m0-1H35a5 5 0 0 0-5 5v14a5 5 0 0 0 5 5h110a5 5 0 0 0 5-5v-14a5 5 0 0 0-5-5Z\\\"/><path d=\\\"M239.24 399.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.48-6.8a42.14 42.14 0 0 0-.75 6.01 43.12 43.12 0 0 0 5.58 2.35 42.54 42.54 0 0 0 5.58-2.35 45.32 45.32 0 0 0-.75-6.01c-.91-.79-2.6-2.21-4.83-3.66a42.5 42.5 0 0 0-4.83 3.66Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75ZM330 391.84l-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><use height=\\\"300\\\" transform=\\\"matrix(1 0 0 .09 29.85 444)\\\" width=\\\"300.15\\\" xlink:href=\\\"#a\\\"/><use height=\\\"21.15\\\" transform=\\\"translate(30 446.92)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><g><path d=\\\"m191.54 428.67-28.09-24.34A29.98 29.98 0 0 0 143.8 397H30a15 15 0 0 0-15 15v98a15 15 0 0 0 15 15h300a15 15 0 0 0 15-15v-59a15 15 0 0 0-15-15H211.19a30 30 0 0 1-19.65-7.33Z\\\" style=\\\"fill:url(#i)\\\"/></g></svg>'\\n            )\\n        );\\n\\n        files[PARTY_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                ' d=\\\"M188 444.3h2.4l2.6 8.2 2.7-8.2h2.3l-3.7 10.7h-2.8l-3.5-10.7zm10.5 5.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm8.7-6.7h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm6.9-2.1h2.2V455h-2.2v-10.7zm4.3 0h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm10.6 5.4c0-3.4 2.3-5.6 6-5.6 1.2 0 2.3.2 3.1.6v2.3c-.9-.6-1.9-.8-3.1-.8-2.4 0-3.8 1.3-3.8 3.5 0 2.1 1.3 3.4 3.5 3.4.5 0 .9-.1 1.3-.2v-2.2h-2.2v-1.9h4.3v5.6c-1 .5-2.2.8-3.4.8-3.5 0-5.7-2.2-5.7-5.5zm15.1-5.4h4.3c2.3 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm4.8.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm5.8-8.8h2.3l1.7 7.8 1.9-7.8h2.4l1.8 7.8 1.8-7.8h2.3l-2.7 10.7h-2.5l-1.9-8.2-1.8 8.2h-2.5l-2.8-10.7zm15.4 0h6.9v2.1H287v2.2h4.5v2.1H287v2.3h4.9v2.1h-7v-10.8zm9 0h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4 0-.9-.6-1.4-1.5-1.4h-2v2.9h2zM30 444.3h4.3c3 0 5.2 2.1 5.2 5.4s-2.1 5.4-5.2 5.4H30v-10.8zm4 8.6c2.1 0 3.2-1.2 3.2-3.2s-1.2-3.3-3.2-3.3h-1.8v6.5H34zm7.7-8.6h2.2V455h-2.2v-10.7zm4.8 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12-7.9h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4H66v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm6.1-4.8h2.2V455h-2.2v-10.7zm5 0h4.5c2 0 3.2 1.1 3.2 2.8 0 1.1-.5 1.9-1.4 2.3 1.1.3 1.8 1.3 1.8 2.5 0 1.9-1.3 3.1-3.5 3.1h-4.6v-10.7zm4.2 4.4c.9 0 1.4-.5 1.4-1.3s-.5-1.3-1.4-1.3h-2.1v2.5l2.1.1zm.3 4.4c.9 0 1.5-.5 1.5-1.3s-.6-1.3-1.5-1.3h-2.4v2.6h2.4zm5.7-2.5v-6.3h2.2v6.3c0 1.6.9 2.5 2.3 2.5s2.3-.9 2.3-2.5v-6.3h2.2v6.3c0 2.9-1.7 4.6-4.5 4.6s-4.6-1.7-4.5-4.6zm14.2-4.2h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h2.2V455h-2.2v-10.7zm4.5 5.3c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.5-8.8h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm11.7 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.6-1.5-2.6-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4a9.7 9.7 0 0 1-3.4-1.1zM30 259.3h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7H30v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm6.1-5h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm5.4.5c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.6-8.8h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.6-1.5-1.6-1.5h-1.9v2.9h1.9zm5.4.4c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.3-5.3-5.5zm5.4 3.4c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.2 1.2V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12.2-10h2.8l3.7 10.7h-2.3l-.8-2.5h-4l-.8 2.5h-2.2l3.6-10.7zm2.8 6.3-1.4-4.2-1.4 4.2h2.8zm5.7-6.3h2.2v8.6h4.7v2.1h-6.9v-10.7zm9.1 10V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm-84.5-70h2.9l4 8.2v-8.2H39V210h-2.9l-4-8.2v8.2H30v-10.7zm14.7 0h2.8l3.7 10.7h-2.3l-.8-2.6h-4l-.8 2.6H41l3.7-10.7zm2.8 6.2-1.4-4.2-1.4 4.2h2.8zm5.7-6.2h3.3l2.5 8.2 2.5-8.2h3.3V210h-2v-8.6L60 210h-2.1l-2.7-8.5v8.5h-2v-10.7zm14.4 0h6.9v2.1h-4.8v2.2h4.4v2.1h-4.4v2.3h4.9v2.1h-7v-10.8z\\\" /><path d=\\\"M239.24 24.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.47-6.8c.91-.79 2.6-2.21 4.83-3.66a42.5 42.5 0 0 1 4.83 3.66c.23 1.18.62 3.36.75 6.01a43.12 43.12 0 0 1-5.58 2.35 42.54 42.54 0 0 1-5.58-2.35c.14-2.65.53-4.83.75-6.01Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75Zm-5.18-25.66-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><path d=\\\"M106.67 109.1a304.9 304.9 0 0 0-3.72-10.89c5.04-5.53 35.28-40.74 24.54-68.91 10.57 10.67 8.19 28.85 3.59 41.95-4.79 13.14-13.43 26.48-24.4 37.84Zm30.89 20.82c-5.87 6.12-20.46 17.92-21.67 18.77a99.37 99.37 0 0 0 7.94 6.02 133.26 133.26 0 0 0 20.09-18.48 353.47 353.47 0 0 0-6.36-6.31Zm-29.65-16.74a380.9 380.9 0 0 1 3.13 11.56c-4.8-1.37-8.66-2.53-12.36-3.82a123.4 123.4 0 0 1-21.16 13.21l15.84 5.47c14.83-8.23 28.13-20.82 37.81-34.68 0 0 8.56-12.55 12.42-23.68 2.62-7.48 4.46-16.57 3.49-24.89-2.21-12.27-6.95-15.84-9.32-17.66 6.16 5.72 3.25 27.8-2.79 39.89-6.08 12.16-15.73 24.27-27.05 34.59Zm59.05-37.86c-.03 7.72-3.05 15.69-6.44 22.69 1.7 2.2 3.18 4.36 4.42 6.49 7.97-16.51 3.74-26.67 2.02-29.18ZM61.18 128.51l12.5 4.3a101.45 101.45 0 0 0 21.42-13.19 163.26 163.26 0 0 1-10.61-4.51 101.28 101.28 0 0 1-23.3 13.4Zm87.78-42.73c.86.77 5.44 5.18 6.75 6.59 6.39-16.61.78-28.86-1.27-30.56.72 8.05-2.02 16.51-5.48 23.98Zm-14.29 40.62-2.47-15.18a142.42 142.42 0 0 1-35.74 29.45c6.81 2.36 12.69 4.4 15.45 5.38a115.98 115.98 0 0 0 22.75-19.66Zm-42.62 34.73c4.48 2.93 12.94 4.24 18.8 1.23 6.03-3.84-.6-8.34-8.01-9.88-9.8-2.03-16.82 1.22-13.4 6.21.41.6 1.19 1.5 2.62 2.44m-1.84.4c-3.56-2.37-6.77-7.2-.23-10.08 10.41-3.43 28.39 3.2 24.99 9.22-.58 1.04-1.46 1.6-2.38 2.19h-.03v.02h-.03v.02h-.03c-7.04 3.65-17.06 2.13-22.3-1.36m5.48-3.86a4.94 4.94 0 0 0 5.06.49l1.35-.74-4.68-2.38-1.47.79c-.38.22-1.53.88-.26 1.84m-1.7.59c-2.35-1.57-.78-2.61-.02-3.11 1.09-.57 2.19-1.15 3.28-1.77 6.95 3.67 7.22 3.81 13.19 6.17l-1.38.81c-1.93-.78-4.52-1.82-6.42-2.68.86 1.4 1.99 3.27 2.9 4.64l-1.68.87c-.75-1.28-1.76-2.99-2.47-4.29-3.19 2.06-6.99-.36-7.42-.64\\\" style=\\\"fill:url(#f2)\\\"/><path d=\\\"M159.13 52.37C143.51 24.04 119.45 15 103.6 15c-11.92 0-25.97 5.78-36.84 13.17 9.54 4.38 21.86 15.96 22.02 16.11-7.94-3.05-17.83-6.72-33.23-7.87a135.1 135.1 0 0 0-19.77 20.38c.77 7.66 2.88 15.68 2.88 15.68-6.28-4.75-11.02-4.61-18 9.45-5.4 12.66-6.93 24.25-4.65 33.18 0 0 4.72 26.8 36.23 40.07-1.3-4.61-1.58-9.91-.93-15.73a87.96 87.96 0 0 1-15.63-9.87c.79-6.61 2.79-13.82 6-21.36 4.42-10.66 4.35-15.14 4.35-15.19.03.07 5.48 12.43 12.95 22.08 4.23-8.84 9.46-16.08 13.67-21.83l-3.77-6.75a143.73 143.73 0 0 1 18.19-18.75c2.05 1.07 4.79 2.47 6.84 3.58 8.68-7.27 19.25-14.05 30.56-18.29-7-11.49-16.02-19.27-16.02-19.27s27.7 2.74 42.02 15.69a25.8 25.8 0 0 1 8.65 2.89ZM28.58 107.52a70.1 70.1 0 0 0-2.74 12.52 55.65 55.65 0 0 1-6.19-8.84 69.17 69.17 0 0 1 2.65-12.1c1.77-5.31 3.35-5.91 5.86-2.23v-.05c2.14 3.07 1.81 6.14.42 10.7ZM61.69 72.2l-.05.05a221.85 221.85 0 0 1-7.77-18.1l.14-.14a194.51 194.51 0 0 1 18.56 6.98 144.44 144.44 0 0 0-10.88 11.22Zm54.84-47.38c-4.42.7-9.02 1.95-13.67 3.72a65.03 65.03 0 0 0-7.81-5.31 66.04 66.04 0 0 1 13.02-3.54c1.53-.19 6.23-.79 10.32 2.42v-.05c2.47 1.91.14 2.37-1.86 2.75Z\\\" style=\\\"fill:url(#h)\\\"/>'\\n            )\\n        );\\n    }\\n\\n    /// @notice Transfer ownership to a new owner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    /// @notice Write data to be accessed by a given file key.\\n    /// @param key The key to access the written data.\\n    /// @param data The data to be written.\\n    function writeFile(uint256 key, string memory data) external onlyOwner {\\n        files[key] = SSTORE2.write(bytes(data));\\n    }\\n\\n    /// @notice Read data using a given file key.\\n    /// @param key The key to access the stored data.\\n    /// @return data The data stored at the given key.\\n    function readFile(uint256 key) external view returns (string memory data) {\\n        return string(SSTORE2.read(files[key]));\\n    }\\n\\n    /// @notice Create or set a customization preset for renderers to use.\\n    /// @param id The ID of the customization preset.\\n    /// @param customizationData Data decoded by renderers used to render the SVG according to the preset.\\n    function createCustomizationPreset(\\n        uint256 id,\\n        bytes memory customizationData\\n    ) external onlyOwner {\\n        customizationPresets[id] = customizationData;\\n    }\\n\\n    /// @notice For crowdfund or party instances to set the customization preset they want to use.\\n    /// @param id The ID of the customization preset.\\n    function useCustomizationPreset(uint256 id) external {\\n        getPresetFor[msg.sender] = id;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/Crowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../tokens/ERC721Receiver.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport \\\"../party/IPartyFactory.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\nimport \\\"./CrowdfundNFT.sol\\\";\\n\\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\\n// party after winning.\\nabstract contract Crowdfund is Implementation, ERC721Receiver, CrowdfundNFT {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        Invalid,\\n        Active,\\n        Expired,\\n        Busy, // Temporary. mid-settlement state\\n        Lost,\\n        Won\\n    }\\n\\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\\n    // This is a subset of PartyGovernance.GovernanceOpts.\\n    struct FixedGovernanceOpts {\\n        // The implementation of the party to be created.\\n        Party partyImpl;\\n        // The factory to use to create the party.\\n        IPartyFactory partyFactory;\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Fee bps for governance distributions.\\n        uint16 feeBps;\\n        // Fee recipeint for governance distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // Options to be passed into `_initialize()` when the crowdfund is created.\\n    struct CrowdfundOptions {\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n        address payable splitRecipient;\\n        uint16 splitBps;\\n        address initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n        FixedGovernanceOpts governanceOpts;\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    // A record of a single contribution made by a user.\\n    // Stored in `_contributionsByContributor`.\\n    struct Contribution {\\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\\n        uint96 previousTotalContributions;\\n        // How much was this contribution.\\n        uint96 amount;\\n    }\\n\\n    // A record of the refund and governance NFT owed to a contributor if it\\n    // could not be received by them from `burn()`.\\n    struct Claim {\\n        uint256 refund;\\n        uint256 governanceTokenId;\\n    }\\n\\n    error PartyAlreadyExistsError(Party party);\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error InvalidGovernanceOptionsError();\\n    error InvalidDelegateError();\\n    error InvalidContributorError();\\n    error NoPartyError();\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error SplitRecipientAlreadyBurnedError();\\n    error InvalidBpsError(uint16 bps);\\n    error ExceedsTotalContributionsError(uint96 value, uint96 totalContributions);\\n    error NothingToClaimError();\\n    error OnlyPartyHostError();\\n    error OnlyContributorError();\\n    error MissingHostsError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n\\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\\n    event Contributed(\\n        address sender,\\n        address contributor,\\n        uint256 amount,\\n        address delegate,\\n        uint256 previousTotalContributions\\n    );\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n    event EmergencyExecuteDisabled();\\n\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The party instance created by `_createParty()`, if any after a\\n    ///         successful crowdfund.\\n    Party public party;\\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\\n    uint96 public totalContributions;\\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\\n    ///         contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper strategy to use.\\n    bytes12 public gateKeeperId;\\n    /// @notice Who will receive a reserved portion of governance power when\\n    ///         the governance party is created.\\n    address payable public splitRecipient;\\n    /// @notice How much governance power to reserve for `splitRecipient`,\\n    ///         in bps, where 10,000 = 100%.\\n    uint16 public splitBps;\\n    // Whether the share for split recipient has been claimed through `burn()`.\\n    bool private _splitRecipientHasBurned;\\n    /// @notice Hash of party options passed into `initialize()`.\\n    ///         Used to check whether the options passed into `_createParty()`\\n    ///         matches.\\n    bytes32 public partyOptsHash;\\n    /// @notice Who a contributor last delegated to.\\n    mapping(address => address) public delegationsByContributor;\\n    // Array of contributions by a contributor.\\n    // One is created for every nonzero contribution made.\\n    // `internal` for testing purposes only.\\n    mapping(address => Contribution[]) internal _contributionsByContributor;\\n    /// @notice Stores the amount of ETH owed back to a contributor and governance NFT\\n    ///         that should be minted to them if it could not be transferred to\\n    ///         them with `burn()`.\\n    mapping(address => Claim) public claims;\\n    /// @notice Minimum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public minContribution;\\n    /// @notice Maximum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts, credit initial contribution (if\\n    // any), and setup gatekeeper.\\n    function _initialize(CrowdfundOptions memory opts) internal {\\n        CrowdfundNFT._initialize(opts.name, opts.symbol, opts.customizationPresetId);\\n        // Check that BPS values do not exceed the max.\\n        if (opts.governanceOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\\n        }\\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\\n        }\\n        if (opts.splitBps > 1e4) {\\n            revert InvalidBpsError(opts.splitBps);\\n        }\\n        partyOptsHash = _hashOpts(opts.governanceOpts, opts.proposalEngineOpts);\\n        splitRecipient = opts.splitRecipient;\\n        splitBps = opts.splitBps;\\n        // Set the minimum and maximum contribution amounts.\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // If the deployer passed in some ETH during deployment, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            _setDelegate(opts.initialContributor, opts.initialDelegate);\\n            // If this ETH is passed in, credit it to the `initialContributor`.\\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, 0, \\\"\\\");\\n        }\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = opts.gateKeeper;\\n        gateKeeperId = opts.gateKeeperId;\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyDelegateCall {\\n        // Must be called by the DAO.\\n        if (!_isPartyDao(msg.sender)) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    /// @param governanceOpts The fixed governance opts the crowdfund was created with.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance.\\n    /// @param hostIndex The index of the party host (caller).\\n    function disableEmergencyExecute(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external onlyDelegateCall {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !_isHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex) &&\\n            !_isPartyDao(msg.sender)\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    /// @notice Burn the participation NFT for `contributor`, potentially\\n    ///         minting voting power and/or refunding unused ETH. `contributor`\\n    ///         may also be the split recipient, regardless of whether they are\\n    ///         also a contributor or not. This can be called by anyone on a\\n    ///         contributor's behalf to unlock their voting power in the\\n    ///         governance stage ensuring delegates receive their voting\\n    ///         power and governance is not stalled.\\n    /// @param contributor The contributor whose NFT to burn for.\\n    function burn(address payable contributor) public {\\n        return _burn(contributor, getCrowdfundLifecycle(), party);\\n    }\\n\\n    /// @dev Alias for `burn()`.\\n    function activateOrRefund(address payable contributor) external {\\n        burn(contributor);\\n    }\\n\\n    /// @notice `burn()` in batch form.\\n    ///         Will not revert if any individual burn fails.\\n    /// @param contributors The contributors whose NFT to burn for.\\n    /// @param revertOnFailure If true, revert if any burn fails.\\n    function batchBurn(address payable[] calldata contributors, bool revertOnFailure) public {\\n        for (uint256 i = 0; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(\\n                abi.encodeCall(this.burn, (contributors[i]))\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @dev Alias for `batchBurn()`.\\n    function batchActivateOrRefund(\\n        address payable[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        batchBurn(contributors, revertOnFailure);\\n    }\\n\\n    /// @notice Claim a governance NFT or refund that is owed back but could not be\\n    ///         given due to error in `_burn()` (e.g. a contract that does not\\n    ///         implement `onERC721Received()` or cannot receive ETH). Only call\\n    ///         this if refund and governance NFT minting could not be returned\\n    ///         with `burn()`.\\n    /// @param receiver The address to receive the NFT or refund.\\n    function claim(address payable receiver) external {\\n        Claim memory claimInfo = claims[msg.sender];\\n        delete claims[msg.sender];\\n\\n        if (claimInfo.refund == 0 && claimInfo.governanceTokenId == 0) {\\n            revert NothingToClaimError();\\n        }\\n\\n        if (claimInfo.refund != 0) {\\n            receiver.transferEth(claimInfo.refund);\\n        }\\n\\n        if (claimInfo.governanceTokenId != 0) {\\n            party.safeTransferFrom(address(this), receiver, claimInfo.governanceTokenId);\\n        }\\n    }\\n\\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\\n    ///         governance phase should the crowdfund succeed.\\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\\n    ///         membership to the gatekeeper.\\n    /// @param delegate The address to delegate to for the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contribute(address delegate, bytes memory gateData) external payable onlyDelegateCall {\\n        _setDelegate(msg.sender, delegate);\\n\\n        _contribute(\\n            msg.sender,\\n            delegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            // We cannot use `address(this).balance - msg.value` as the previous\\n            // total contributions in case someone forces (suicides) ETH into this\\n            // contract. This wouldn't be such a big deal for open crowdfunds\\n            // but private ones (protected by a gatekeeper) could be griefed\\n            // because it would ultimately result in governance power that\\n            // is unattributed/unclaimable, meaning that party will never be\\n            // able to reach 100% consensus.\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param recipient The address to record the contribution under.\\n    /// @param initialDelegate The address to delegate to for the governance phase if recipient hasn't delegated.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contributeFor(\\n        address recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall {\\n        _setDelegate(recipient, initialDelegate);\\n\\n        _contribute(\\n            recipient,\\n            initialDelegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param recipients The addresses to record the contributions under.\\n    /// @param initialDelegates The addresses to delegate to for each recipient.\\n    /// @param values The ETH to contribute for each recipient.\\n    /// @param gateDatas Data to pass to the gatekeeper to prove eligibility.\\n    /// @param revertOnFailure If true, revert if any contribution fails.\\n    function batchContributeFor(\\n        address[] memory recipients,\\n        address[] memory initialDelegates,\\n        uint256[] memory values,\\n        bytes[] memory gateDatas,\\n        bool revertOnFailure\\n    ) external payable {\\n        for (uint256 i; i < recipients.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call{ value: values[i] }(\\n                abi.encodeCall(\\n                    this.contributeFor,\\n                    (recipients[i], initialDelegates[i], gateDatas[i])\\n                )\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(ERC721Receiver, CrowdfundNFT) returns (bool) {\\n        return\\n            ERC721Receiver.supportsInterface(interfaceId) ||\\n            CrowdfundNFT.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Retrieve info about a participant's contributions.\\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\\n    /// @param contributor The contributor to retrieve contributions for.\\n    /// @return ethContributed The total ETH contributed by `contributor`.\\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\\n    /// @return ethOwed The total ETH refunded back to `contributor`.\\n    /// @return votingPower The total voting power minted to `contributor`.\\n    function getContributorInfo(\\n        address contributor\\n    )\\n        external\\n        view\\n        returns (uint256 ethContributed, uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\\n    {\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\\n            ethContributed = ethUsed + ethOwed;\\n        } else {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                ethContributed += contributions[i].amount;\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view virtual returns (CrowdfundLifecycle lifecycle);\\n\\n    // Get the final sale price of the bought assets. This will also be the total\\n    // voting power of the governance party.\\n    function _getFinalPrice() internal view virtual returns (uint256);\\n\\n    // Assert that `who` is a host at `governanceOpts.hosts[hostIndex]` and,\\n    // if so, assert that the governance opts is the same as the crowdfund\\n    // was created with.\\n    // Return true if `governanceOpts` was validated in the process.\\n    function _assertIsHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) internal view {\\n        if (!_isHost(who, governanceOpts, proposalEngineOpts, hostIndex)) {\\n            revert OnlyPartyHostError();\\n        }\\n    }\\n\\n    // Check if `who` is a host at `hostIndex` index. Validates governance opts if so.\\n    function _isHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) private view returns (bool isHost) {\\n        if (hostIndex < governanceOpts.hosts.length && who == governanceOpts.hosts[hostIndex]) {\\n            // Validate governance opts if the host was found.\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _isPartyDao(address who) private view returns (bool isPartyDao) {\\n        return who == _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n    }\\n\\n    // Assert that `who` is a contributor to the crowdfund.\\n    function _assertIsContributor(address who) internal view {\\n        if (_contributionsByContributor[who].length == 0) {\\n            revert OnlyContributorError();\\n        }\\n    }\\n\\n    // Can be called after a party has won.\\n    // Deploys and initializes a `Party` instance via the `PartyFactory`\\n    // and transfers the bought NFT to it.\\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\\n    // with the `burn()` function.\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal returns (Party party_) {\\n        if (party != Party(payable(0))) {\\n            revert PartyAlreadyExistsError(party);\\n        }\\n        // If the governance opts haven't already been validated, make sure that\\n        // it hasn't been tampered with.\\n        if (!governanceOptsAlreadyValidated) {\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n        }\\n        // Get options used to create the party.\\n        RendererStorage rendererStorage = RendererStorage(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\\n        );\\n        address[] memory authorities = new address[](1);\\n        authorities[0] = address(this);\\n        // Create a party.\\n        party = party_ = governanceOpts.partyFactory.createParty(\\n            governanceOpts.partyImpl,\\n            authorities,\\n            Party.PartyOptions({\\n                name: name,\\n                symbol: symbol,\\n                customizationPresetId: rendererStorage.getPresetFor(address(this)),\\n                governance: PartyGovernance.GovernanceOpts({\\n                    hosts: governanceOpts.hosts,\\n                    voteDuration: governanceOpts.voteDuration,\\n                    executionDelay: governanceOpts.executionDelay,\\n                    passThresholdBps: governanceOpts.passThresholdBps,\\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\\n                    feeBps: governanceOpts.feeBps,\\n                    feeRecipient: governanceOpts.feeRecipient\\n                }),\\n                proposalEngine: proposalEngineOpts\\n            }),\\n            preciousTokens,\\n            preciousTokenIds,\\n            // Ragequit is not applicable for NFT parties which primarily own\\n            // non-fungible assets (which cannot be split) and can perform\\n            // distributions without needing a vote.\\n            DISABLE_RAGEQUIT_PERMANENTLY\\n        );\\n        // Transfer the acquired NFTs to the new party.\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\\n        }\\n    }\\n\\n    // Overloaded single token wrapper for _createParty()\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721 preciousToken,\\n        uint256 preciousTokenId\\n    ) internal returns (Party party_) {\\n        IERC721[] memory tokens = new IERC721[](1);\\n        tokens[0] = preciousToken;\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = preciousTokenId;\\n        return\\n            _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                governanceOptsAlreadyValidated,\\n                tokens,\\n                tokenIds\\n            );\\n    }\\n\\n    // Assert that the hash of `opts` matches the hash this crowdfund was initialized with.\\n    function _assertValidOpts(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) private view {\\n        bytes32 partyOptsHash_ = _hashOpts(governanceOpts, proposalEngineOpts);\\n        if (partyOptsHash_ != partyOptsHash) {\\n            revert InvalidGovernanceOptionsError();\\n        }\\n    }\\n\\n    function _hashOpts(\\n        FixedGovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) internal pure returns (bytes32 h) {\\n        return keccak256(abi.encode(govOpts, proposalEngineOpts));\\n    }\\n\\n    function _getFinalContribution(\\n        address contributor\\n    ) internal view returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) {\\n        uint256 totalEthUsed = _getFinalPrice();\\n        {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                Contribution memory c = contributions[i];\\n                if (c.previousTotalContributions >= totalEthUsed) {\\n                    // This entire contribution was not used.\\n                    ethOwed += c.amount;\\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\\n                    // This entire contribution was used.\\n                    ethUsed += c.amount;\\n                } else {\\n                    // This contribution was partially used.\\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\\n                    ethUsed += partialEthUsed;\\n                    ethOwed = c.amount - partialEthUsed;\\n                }\\n            }\\n        }\\n        // one SLOAD with optimizer on\\n        address splitRecipient_ = splitRecipient;\\n        uint256 splitBps_ = splitBps;\\n        if (splitRecipient_ == address(0)) {\\n            splitBps_ = 0;\\n        }\\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\\n        if (splitRecipient_ == contributor) {\\n            // Split recipient is also the contributor so just add the split\\n            // voting power.\\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\\n        }\\n    }\\n\\n    function _setDelegate(address contributor, address delegate) private {\\n        if (delegate == address(0)) revert InvalidDelegateError();\\n\\n        // Only need to update delegate if there was a change.\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (oldDelegate == delegate) return;\\n\\n        // Only allow setting delegate on another's behalf if the delegate is unset.\\n        if (msg.sender != contributor && oldDelegate != address(0)) return;\\n\\n        // Update delegate.\\n        delegationsByContributor[contributor] = delegate;\\n    }\\n\\n    /// @dev While it is not necessary to pass in `delegate` to this because the\\n    ///      function does not require it, it is here to emit in the\\n    ///      `Contribute` event so that the PartyBid frontend can access it more\\n    ///      easily.\\n    function _contribute(\\n        address contributor,\\n        address delegate,\\n        uint96 amount,\\n        uint96 previousTotalContributions,\\n        bytes memory gateData\\n    ) private {\\n        if (contributor == address(this)) revert InvalidContributorError();\\n\\n        if (amount == 0) return;\\n\\n        // Must not be blocked by gatekeeper.\\n        {\\n            IGateKeeper _gateKeeper = gateKeeper;\\n            if (_gateKeeper != IGateKeeper(address(0))) {\\n                if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                    revert NotAllowedByGateKeeperError(\\n                        msg.sender,\\n                        _gateKeeper,\\n                        gateKeeperId,\\n                        gateData\\n                    );\\n                }\\n            }\\n        }\\n        // Only allow contributions while the crowdfund is active.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n        // Increase total contributions.\\n        totalContributions += amount;\\n        // Create contributions entry for this contributor.\\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\\n        uint256 numContributions = contributions.length;\\n        uint96 ethContributed;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethContributed += contributions[i].amount;\\n        }\\n        // Check contribution is greater than minimum contribution.\\n        if (ethContributed + amount < minContribution) {\\n            revert BelowMinimumContributionsError(ethContributed + amount, minContribution);\\n        }\\n        // Check contribution is less than maximum contribution.\\n        if (ethContributed + amount > maxContribution) {\\n            revert AboveMaximumContributionsError(ethContributed + amount, maxContribution);\\n        }\\n\\n        emit Contributed(msg.sender, contributor, amount, delegate, previousTotalContributions);\\n\\n        // Notify third-party platforms that the crowdfund NFT metadata has updated.\\n        emit MetadataUpdate(uint256(uint160(contributor)));\\n\\n        if (numContributions >= 1) {\\n            Contribution memory lastContribution = contributions[numContributions - 1];\\n            // If no one else (other than this contributor) has contributed since,\\n            // we can just reuse this contributor's last entry.\\n            uint256 totalContributionsAmountForReuse = lastContribution.previousTotalContributions +\\n                lastContribution.amount;\\n            if (totalContributionsAmountForReuse == previousTotalContributions) {\\n                lastContribution.amount += amount;\\n                contributions[numContributions - 1] = lastContribution;\\n                return;\\n            }\\n        }\\n        // Add a new contribution entry.\\n        contributions.push(\\n            Contribution({ previousTotalContributions: previousTotalContributions, amount: amount })\\n        );\\n        // Mint a participation NFT if this is their first contribution.\\n        if (numContributions == 0) {\\n            _mint(contributor);\\n        }\\n    }\\n\\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_) private {\\n        // If the CF has won, a party must have been created prior.\\n        if (lc == CrowdfundLifecycle.Won) {\\n            if (party_ == Party(payable(0))) {\\n                revert NoPartyError();\\n            }\\n        } else if (lc != CrowdfundLifecycle.Lost) {\\n            // Otherwise it must have lost.\\n            revert WrongLifecycleError(lc);\\n        }\\n        // Split recipient can burn even if they don't have a token.\\n        {\\n            address splitRecipient_ = splitRecipient;\\n            if (contributor == splitRecipient_) {\\n                if (_splitRecipientHasBurned) {\\n                    revert SplitRecipientAlreadyBurnedError();\\n                }\\n                _splitRecipientHasBurned = true;\\n            }\\n            // Revert if already burned or does not exist.\\n            if (splitRecipient_ != contributor || _doesTokenExistFor(contributor)) {\\n                CrowdfundNFT._burn(contributor);\\n            }\\n        }\\n        // Compute the contributions used and owed to the contributor, along\\n        // with the voting power they'll have in the governance stage.\\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) = _getFinalContribution(\\n            contributor\\n        );\\n        if (votingPower > 0) {\\n            // Get the address to delegate voting power to. If null, delegate to self.\\n            address delegate = delegationsByContributor[contributor];\\n            if (delegate == address(0)) {\\n                // Delegate can be unset for the split recipient if they never\\n                // contribute. Self-delegate if this occurs.\\n                delegate = contributor;\\n            }\\n            // Mint governance NFT for the contributor.\\n            try party_.mint(contributor, votingPower, delegate) returns (uint256) {\\n                // OK\\n            } catch {\\n                // Mint to the crowdfund itself to escrow for contributor to\\n                // come claim later on.\\n                uint256 tokenId = party_.mint(address(this), votingPower, delegate);\\n                claims[contributor].governanceTokenId = tokenId;\\n            }\\n        }\\n        // Refund any ETH owed back to the contributor.\\n        (bool s, ) = contributor.call{ value: ethOwed }(\\\"\\\");\\n        if (!s) {\\n            // If the transfer fails, the contributor can still come claim it\\n            // from the crowdfund.\\n            claims[contributor].refund = ethOwed;\\n        }\\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\\n    }\\n}\\n\\nfunction _hashFixedGovernanceOpts(\\n    Crowdfund.FixedGovernanceOpts memory opts\\n) pure returns (bytes32 h) {\\n    // Hash in place.\\n    assembly {\\n        // Replace the address[] hosts field with its hash temporarily.\\n        let oldHostsFieldValue := mload(opts)\\n        mstore(opts, keccak256(add(oldHostsFieldValue, 0x20), mul(mload(oldHostsFieldValue), 32)))\\n        // Hash the entire struct.\\n        h := keccak256(opts, 0xC0)\\n        // Restore old hosts field value.\\n        mstore(opts, oldHostsFieldValue)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/ReraiseETHCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./ETHCrowdfundBase.sol\\\";\\nimport \\\"../crowdfund/CrowdfundNFT.sol\\\";\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\n/// @notice A crowdfund for raising additional funds for an existing parties.\\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    struct BatchContributeArgs {\\n        // The address to which voting power will be delegated for all contributions.\\n        address delegate;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `tokenIds`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n    }\\n\\n    struct BatchContributeForArgs {\\n        // Addresses of to credit the contributions under. Each contribution\\n        // amount in `values` corresponds to a recipient in this array.\\n        address payable[] recipients;\\n        // The delegate to set for each recipient if they have not delegated\\n        // before.\\n        address[] initialDelegates;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `recipients`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n        // Whether to revert if any individual contribution fails or continue.\\n        bool revertOnFailure;\\n    }\\n\\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\\n    event Refunded(address indexed contributor, uint256 amount);\\n\\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The amount of voting power that will be received by a\\n    ///         contributor after the crowdfund is won.\\n    mapping(address => uint96) public pendingVotingPower;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) CrowdfundNFT(globals) ETHCrowdfundBase(globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param opts The options to initialize the crowdfund with.\\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\\n        // Initialize the crowdfund.\\n        ETHCrowdfundBase._initialize(opts);\\n\\n        // Initialize the crowdfund NFT.\\n        _initialize(\\n            opts.party.name(),\\n            opts.party.symbol(),\\n            0 // Ignored. Will use customization preset from party.\\n        );\\n\\n        // If the deployer passed in some ETH during deployment, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            // If this contract has ETH, either passed in during deployment or\\n            // pre-existing, credit it to the `initialContributor`.\\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \\\"\\\");\\n        }\\n\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = opts.gateKeeper;\\n        gateKeeperId = opts.gateKeeperId;\\n    }\\n\\n    // Initialize name and symbol for crowdfund NFT.\\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\\n        name = name_;\\n        symbol = symbol_;\\n\\n        RendererStorage rendererStorage = RendererStorage(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\\n        );\\n\\n        // Use the same customization preset as the party.\\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\\n        if (customizationPresetId != 0) {\\n            rendererStorage.useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\\n    /// @param delegate The address to which voting power will be delegated to\\n    ///                 during the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        address delegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                delegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contribute()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments to pass to each `contribute()` call.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContribute(\\n        BatchContributeArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.values.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethAvailable -= args.values[i];\\n\\n            votingPowers[i] = _contribute(\\n                payable(msg.sender),\\n                args.delegate,\\n                args.values[i],\\n                args.gateDatas[i]\\n            );\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param recipient The address to record the contribution under\\n    /// @param initialDelegate The address to delegate to for the governance\\n    ///                        phase if recipient hasn't delegated\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\\n    /// @return votingPower The voting power received for the contribution\\n    function contributeFor(\\n        address payable recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments for the batched `contributeFor()` calls.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContributeFor(\\n        BatchContributeForArgs memory args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.recipients.length;\\n        votingPowers = new uint96[](numContributions);\\n\\n        uint256 ethAvailable = msg.value;\\n        for (uint256 i; i < numContributions; ++i) {\\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\\n                abi.encodeCall(\\n                    this.contributeFor,\\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\\n                )\\n            );\\n\\n            if (!s) {\\n                if (args.revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                votingPowers[i] = abi.decode(r, (uint96));\\n                ethAvailable -= args.values[i];\\n            }\\n        }\\n\\n        // Refund any unused ETH.\\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\\n    }\\n\\n    function _contribute(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount,\\n        bytes memory gateData\\n    ) private returns (uint96 votingPower) {\\n        // Require a non-null delegate.\\n        if (delegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n\\n        // Must not be blocked by gatekeeper.\\n        IGateKeeper _gateKeeper = gateKeeper;\\n        if (_gateKeeper != IGateKeeper(address(0))) {\\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                revert NotAllowedByGateKeeperError(\\n                    contributor,\\n                    _gateKeeper,\\n                    gateKeeperId,\\n                    gateData\\n                );\\n            }\\n        }\\n\\n        votingPower = _processContribution(contributor, delegate, amount);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        uint256 previousVotingPower = pendingVotingPower[contributor];\\n\\n        pendingVotingPower[contributor] += votingPower;\\n\\n        // Mint a crowdfund NFT if this is their first contribution.\\n        if (previousVotingPower == 0) _mint(contributor);\\n    }\\n\\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param contributor The contributor to claim for.\\n    function claim(address contributor) external {\\n        claim(\\n            0, // Mint a new party card.\\n            contributor\\n        );\\n    }\\n\\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\\n    ///                new card will be minted.\\n    /// @param contributor The contributor to claim for.\\n    function claim(uint256 tokenId, address contributor) public {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Finalized) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        uint96 votingPower = pendingVotingPower[contributor];\\n\\n        if (votingPower == 0) return;\\n\\n        {\\n            uint96 contribution = convertVotingPowerToContribution(votingPower);\\n            uint96 maxContribution_ = maxContribution;\\n            // Check that the contribution equivalent of total pending voting\\n            // power is not above the max contribution range. This can happen\\n            // for contributors who contributed multiple times In this case, the\\n            // `claimMultiple` function should be called instead. This is done\\n            // so parties may use the minimum and maximum contribution values to\\n            // limit the voting power of each card (e.g.  a party desiring a \\\"1\\n            // card = 1 vote\\\"-like governance system where each card has equal\\n            // voting power).\\n            if (contribution > maxContribution_) {\\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\\n            }\\n        }\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        if (tokenId == 0) {\\n            // Mint contributor a new party card.\\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\\n        } else if (disableContributingForExistingCard) {\\n            revert ContributingForExistingCardDisabledError();\\n        } else if (party.ownerOf(tokenId) == contributor) {\\n            // Increase voting power of contributor's existing party card.\\n            party.addVotingPower(tokenId, votingPower);\\n        } else {\\n            revert NotOwnerError(tokenId);\\n        }\\n\\n        emit Claimed(contributor, tokenId, votingPower);\\n    }\\n\\n    /// @notice `claim()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\\n    ///                 new card will be minted.\\n    /// @param contributors The contributors to claim for.\\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\\n    function batchClaim(\\n        uint256[] calldata tokenIds,\\n        address[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        for (uint256 i; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\\n                // because `abi.encodeCall()` doesn't support overloaded functions.\\n                abi.encodeWithSignature(\\\"claim(uint256,address)\\\", tokenIds[i], contributors[i])\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\\n    ///         to claim for self or on another's behalf.\\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\\n    ///                          total pending voting power for the contributor.\\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0,\\n    ///                 a new card will be minted.\\n    /// @param contributor The contributor to claim for.\\n    function claimMultiple(\\n        uint96[] memory votingPowerByCard,\\n        uint256[] memory tokenIds,\\n        address contributor\\n    ) external {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Finalized) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        uint256 votingPower = pendingVotingPower[contributor];\\n\\n        if (votingPower == 0) return;\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        address delegate = delegationsByContributor[contributor];\\n        uint96 minContribution_ = minContribution;\\n        uint96 maxContribution_ = maxContribution;\\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\\n            uint96 votingPowerForCard = votingPowerByCard[i];\\n\\n            if (votingPowerForCard == 0) continue;\\n\\n            // Check that the contribution equivalent of voting power is within\\n            // contribution range. This is done so parties may use the minimum\\n            // and maximum contribution values to limit the voting power of each\\n            // card (e.g. a party desiring a \\\"1 card = 1 vote\\\"-like governance\\n            // system where each card has equal voting power).\\n            uint96 contribution = convertVotingPowerToContribution(votingPowerByCard[i]);\\n            if (contribution < minContribution_) {\\n                revert BelowMinimumContributionsError(contribution, minContribution_);\\n            }\\n\\n            if (contribution > maxContribution_) {\\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\\n            }\\n\\n            votingPower -= votingPowerForCard;\\n\\n            uint256 tokenId = tokenIds[i];\\n            if (tokenId == 0) {\\n                // Mint contributor a new party card.\\n                tokenId = party.mint(contributor, votingPowerForCard, delegate);\\n            } else if (disableContributingForExistingCard) {\\n                revert ContributingForExistingCardDisabledError();\\n            } else if (party.ownerOf(tokenId) == contributor) {\\n                // Increase voting power of contributor's existing party card.\\n                party.addVotingPower(tokenId, votingPowerForCard);\\n            } else {\\n                revert NotOwnerError(tokenId);\\n            }\\n\\n            emit Claimed(contributor, tokenId, votingPowerForCard);\\n        }\\n\\n        // Requires that all voting power is claimed because the contributor is\\n        // expected to have burned their crowdfund NFT.\\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\\n    }\\n\\n    /// @notice `claimMultiple()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param votingPowerByCards The voting power for each card claimed for each\\n    ///                           contributor. Must add up to the total pending\\n    ///                           voting power for the contributor.\\n    /// @param tokenIds The IDs of the party cards to add voting power to for each\\n    ///                 contributor. If 0, a new card will be minted.\\n    /// @param contributors The contributors to claim for.\\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\\n    function batchClaimMultiple(\\n        uint96[][] calldata votingPowerByCards,\\n        uint256[][] calldata tokenIds,\\n        address[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        for (uint256 i; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(\\n                    this.claimMultiple,\\n                    (votingPowerByCards[i], tokenIds[i], contributors[i])\\n                )\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @notice Refund the owner of a party card and burn it. Only available if\\n    ///         the crowdfund lost. Can be called to refund for self or on\\n    ///         another's behalf.\\n    /// @param contributor The contributor to refund.\\n    function refund(address payable contributor) external returns (uint96 amount) {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Lost) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Get amount to refund.\\n        uint96 votingPower = pendingVotingPower[contributor];\\n        amount = convertVotingPowerToContribution(votingPower);\\n\\n        if (amount == 0) return 0;\\n\\n        // Burn the crowdfund NFT.\\n        _burn(contributor);\\n\\n        delete pendingVotingPower[contributor];\\n\\n        // Refund contributor.\\n        contributor.transferEth(amount);\\n\\n        emit Refunded(contributor, amount);\\n    }\\n\\n    /// @notice `refund()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param contributors The contributors to refund.\\n    /// @param revertOnFailure If true, revert if any refund fails.\\n    /// @return amounts The amounts of ETH refunded for each refund.\\n    function batchRefund(\\n        address payable[] calldata contributors,\\n        bool revertOnFailure\\n    ) external returns (uint96[] memory amounts) {\\n        uint256 numRefunds = contributors.length;\\n        amounts = new uint96[](numRefunds);\\n\\n        for (uint256 i; i < numRefunds; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(this.refund, (contributors[i]))\\n            );\\n\\n            if (!s) {\\n                if (revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                amounts[i] = abi.decode(r, (uint96));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/ETHCrowdfundBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\n\\ncontract ETHCrowdfundBase is Implementation {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        // In practice, this state is never used. If the crowdfund is ever in\\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\\n        Invalid,\\n        // Ready to accept contributions to reach contribution targets\\n        // until a deadline or the minimum contribution target is reached and\\n        // host finalizes.\\n        Active,\\n        // Expired and the minimum contribution target was not reached.\\n        Lost,\\n        // The crowdfund has expired and reached the minimum contribution\\n        // target. It is now ready to finalize.\\n        Won,\\n        // A won crowdfund has been finalized, with funds transferred to the\\n        // party and voting power successfully updated.\\n        Finalized\\n    }\\n\\n    // Options to be passed into `initialize()` when the crowdfund is created.\\n    struct ETHCrowdfundOptions {\\n        Party party;\\n        address payable initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        bool disableContributingForExistingCard;\\n        uint96 minTotalContributions;\\n        uint96 maxTotalContributions;\\n        uint16 exchangeRateBps;\\n        uint16 fundingSplitBps;\\n        address payable fundingSplitRecipient;\\n        uint40 duration;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n    }\\n\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error OnlyPartyHostError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error NotOwnerError(uint256 tokenId);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error InvalidDelegateError();\\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n    error InvalidExchangeRateError(uint16 exchangeRateBps);\\n    error ContributingForExistingCardDisabledError();\\n    error ZeroVotingPowerError();\\n    error FundingSplitAlreadyPaidError();\\n    error FundingSplitNotConfiguredError();\\n\\n    event Contributed(\\n        address indexed sender,\\n        address indexed contributor,\\n        uint256 amount,\\n        address delegate\\n    );\\n    event Finalized();\\n    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);\\n    event EmergencyExecuteDisabled();\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The address of the `Party` contract instance associated\\n    ///         with the crowdfund.\\n    Party public party;\\n    /// @notice The minimum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund.\\n    uint96 public minContribution;\\n    /// @notice The maximum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice A boolean flag that determines whether contributors are allowed\\n    ///         to increase the voting power of their existing party cards.\\n    bool public disableContributingForExistingCard;\\n    /// @notice Whether the funding split has been claimed by the funding split\\n    ///         recipient.\\n    bool public fundingSplitPaid;\\n    /// @notice Whether the DAO has emergency powers for this crowdfund.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice The minimum amount of total ETH contributions required for the\\n    ///         crowdfund to be considered successful.\\n    uint96 public minTotalContributions;\\n    /// @notice The maximum amount of total ETH contributions allowed for the\\n    ///         crowdfund.\\n    uint96 public maxTotalContributions;\\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\\n    uint96 public totalContributions;\\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\\n    ///         crowdfund has finalized.\\n    uint40 public expiry;\\n    /// @notice The exchange rate to use for converting ETH contributions to\\n    ///         voting power in basis points (e.g. 10000 = 1:1).\\n    uint16 public exchangeRateBps;\\n    /// @notice The portion of contributions to send to the funding recipient in\\n    ///         basis points (e.g. 100 = 1%).\\n    uint16 public fundingSplitBps;\\n    /// @notice The address to which a portion of the contributions is sent to.\\n    address payable public fundingSplitRecipient;\\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\\n    bytes12 public gateKeeperId;\\n    /// @notice The address a contributor is delegating their voting power to.\\n    mapping(address => address) public delegationsByContributor;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts, credit initial contribution (if\\n    // any), and setup gatekeeper.\\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\\n        // Set the minimum and maximum contribution amounts.\\n        if (opts.minContribution > opts.maxContribution) {\\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\\n        }\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // Set the min total contributions.\\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\\n        }\\n        minTotalContributions = opts.minTotalContributions;\\n        // Set the max total contributions.\\n        if (opts.maxTotalContributions == 0) {\\n            // Prevent this because when `maxTotalContributions` is 0 the\\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\\n            // never been initialized.\\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\\n        }\\n        maxTotalContributions = opts.maxTotalContributions;\\n        // Set the party crowdfund is for.\\n        party = opts.party;\\n        // Set the crowdfund start and end timestamps.\\n        expiry = uint40(block.timestamp + opts.duration);\\n        // Set the exchange rate.\\n        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);\\n        exchangeRateBps = opts.exchangeRateBps;\\n        // Set the funding split and its recipient.\\n        fundingSplitBps = opts.fundingSplitBps;\\n        fundingSplitRecipient = opts.fundingSplitRecipient;\\n        // Set whether to disable contributing for existing card.\\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\\n        if (maxTotalContributions == 0) {\\n            return CrowdfundLifecycle.Invalid;\\n        }\\n\\n        uint256 expiry_ = expiry;\\n        if (expiry_ == 0) {\\n            return CrowdfundLifecycle.Finalized;\\n        }\\n\\n        if (block.timestamp >= expiry_) {\\n            if (totalContributions >= minTotalContributions) {\\n                return CrowdfundLifecycle.Won;\\n            } else {\\n                return CrowdfundLifecycle.Lost;\\n            }\\n        }\\n\\n        return CrowdfundLifecycle.Active;\\n    }\\n\\n    function _processContribution(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount\\n    ) internal returns (uint96 votingPower) {\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (msg.sender == contributor || oldDelegate == address(0)) {\\n            // Update delegate.\\n            delegationsByContributor[contributor] = delegate;\\n        } else {\\n            // Prevent changing another's delegate if already delegated.\\n            delegate = oldDelegate;\\n        }\\n\\n        emit Contributed(msg.sender, contributor, amount, delegate);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        // Only allow contributions while the crowdfund is active.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Active) {\\n            revert WrongLifecycleError(lc);\\n        }\\n\\n        // Check that the contribution amount is at or below the maximum.\\n        uint96 maxContribution_ = maxContribution;\\n        if (amount > maxContribution_) {\\n            revert AboveMaximumContributionsError(amount, maxContribution_);\\n        }\\n\\n        uint96 newTotalContributions = totalContributions + amount;\\n        uint96 maxTotalContributions_ = maxTotalContributions;\\n        if (newTotalContributions >= maxTotalContributions_) {\\n            totalContributions = maxTotalContributions_;\\n\\n            // Finalize the crowdfund.\\n            // This occurs before refunding excess contribution to act as a\\n            // reentrancy guard.\\n            _finalize(maxTotalContributions_);\\n\\n            // Refund excess contribution.\\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\\n            if (refundAmount > 0) {\\n                amount -= refundAmount;\\n                payable(msg.sender).transferEth(refundAmount);\\n            }\\n        } else {\\n            totalContributions = newTotalContributions;\\n        }\\n\\n        // Check that the contribution amount is at or above the minimum. This\\n        // is done after `amount` is potentially reduced if refunding excess\\n        // contribution. There is a case where this prevents a crowdfunds from\\n        // reaching `maxTotalContributions` if the `minContribution` is greater\\n        // than the difference between `maxTotalContributions` and the current\\n        // `totalContributions`. In this scenario users will have to wait until\\n        // the crowdfund expires or a host finalizes after\\n        // `minTotalContribution` has been reached by calling `finalize()`.\\n        uint96 minContribution_ = minContribution;\\n        if (amount < minContribution_) {\\n            revert BelowMinimumContributionsError(amount, minContribution_);\\n        }\\n\\n        // Subtract fee from contribution amount if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            // Removes funding split from contribution amount in a way that\\n            // avoids rounding errors for very small contributions <1e4 wei.\\n            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\\n        }\\n\\n        // Calculate voting power.\\n        votingPower = (amount * exchangeRateBps) / 1e4;\\n\\n        if (votingPower == 0) revert ZeroVotingPowerError();\\n    }\\n\\n    /// @notice Calculate the contribution amount from the given voting power.\\n    /// @param votingPower The voting power to convert to a contribution amount.\\n    /// @return amount The contribution amount.\\n    function convertVotingPowerToContribution(\\n        uint96 votingPower\\n    ) public view returns (uint96 amount) {\\n        amount = (votingPower * 1e4) / exchangeRateBps;\\n\\n        // Add back funding split to contribution amount if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\\n        }\\n    }\\n\\n    function finalize() external {\\n        uint96 totalContributions_ = totalContributions;\\n\\n        // Check that the crowdfund is not already finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Active) {\\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\\n\\n            // Check that the crowdfund has reached its minimum goal.\\n            uint96 minTotalContributions_ = minTotalContributions;\\n            if (totalContributions_ < minTotalContributions_) {\\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\\n            }\\n        } else {\\n            // Otherwise only allow finalization if the crowdfund has expired\\n            // and been won. Can be finalized by anyone.\\n            if (lc != CrowdfundLifecycle.Won) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Finalize the crowdfund.\\n        _finalize(totalContributions_);\\n    }\\n\\n    function _finalize(uint96 totalContributions_) internal {\\n        // Finalize the crowdfund.\\n        delete expiry;\\n\\n        // Transfer funding split to recipient if applicable.\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\\n            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;\\n        }\\n\\n        // Update the party's total voting power.\\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\\n        party.increaseTotalVotingPower(newVotingPower);\\n\\n        // Transfer ETH to the party.\\n        payable(address(party)).transferEth(totalContributions_);\\n\\n        emit Finalized();\\n    }\\n\\n    /// @notice Send the funding split to the recipient if applicable.\\n    function sendFundingSplit() external returns (uint96 splitAmount) {\\n        // Check that the crowdfund is finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);\\n\\n        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();\\n\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {\\n            revert FundingSplitNotConfiguredError();\\n        }\\n\\n        fundingSplitPaid = true;\\n\\n        // Transfer funding split to recipient.\\n        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;\\n        payable(fundingSplitRecipient_).transferEth(splitAmount);\\n\\n        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable {\\n        // Must be called by the DAO.\\n        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !party.isHost(msg.sender) &&\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/fonts/IFont.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title The interface on-chain font contracts must implement to be added to the registry.\\n///\\n/// Uploading fonts to chain is open ended and up to the dev (SSTORE2 or hardcoded string or etc).\\n///\\n/// As long as the font contract implements this interface and has immutable font data, it can be added\\n/// to the registry.\\n///\\n/// @author @0x_beans\\ninterface IFont {\\n    /// @notice Address that uploaded font for credits\\n    function fontUploader() external returns (address);\\n\\n    /// @notice Format type of font (e.g. ttf, woff, otf, etc). Must be lowercase.\\n    ///         This info is necessary so projects know how to properly render the fonts.\\n    function fontFormatType() external returns (string memory);\\n\\n    /// @notice Font name (ie. 'space-grotesk'). Must be lowercase.\\n    function fontName() external returns (string memory);\\n\\n    /// @notice Weight used by the font (e.g. bold, medium, light, etc). Must be lowercase.\\n    ///         Necessary to differentiate uploaded fonts that are the same but different weights.\\n    function fontWeight() external returns (string memory);\\n\\n    /// @notice Style used by the font (e.g. lowercase normal, italic, oblique, etc). Must be lowercase.\\n    //          Necessary to differentiate uploaded fonts that are the same but different style.\\n    function fontStyle() external returns (string memory);\\n\\n    /// @notice The full base64 encoded font with data URI scheme prefix\\n    ///         (e.g. 'data:font/ttf;charset=utf-8;base64,').\\n    function getFont() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/IGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/Implementation.sol\\\";\\n\\n// Single registry of global values controlled by multisig.\\n// See `LibGlobals` for all valid keys.\\ninterface IGlobals {\\n    function multiSig() external view returns (address);\\n\\n    function getBytes32(uint256 key) external view returns (bytes32);\\n\\n    function getUint256(uint256 key) external view returns (uint256);\\n\\n    function getBool(uint256 key) external view returns (bool);\\n\\n    function getAddress(uint256 key) external view returns (address);\\n\\n    function getImplementation(uint256 key) external view returns (Implementation);\\n\\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\\n\\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\\n\\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\\n\\n    function setBytes32(uint256 key, bytes32 value) external;\\n\\n    function setUint256(uint256 key, uint256 value) external;\\n\\n    function setBool(uint256 key, bool value) external;\\n\\n    function setAddress(uint256 key, address value) external;\\n\\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\\n\\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\\n\\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\\n}\\n\"\r\n    },\r\n    \"contracts/party/Party.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nimport \\\"./PartyGovernanceNFT.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\n\\n/// @notice The governance contract that also custodies the precious NFTs. This\\n///         is also the Governance NFT 721 contract.\\ncontract Party is PartyGovernanceNFT {\\n    // Arguments used to initialize the party.\\n    struct PartyOptions {\\n        PartyGovernance.GovernanceOpts governance;\\n        ProposalStorage.ProposalEngineOpts proposalEngine;\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n    }\\n\\n    // Arguments used to initialize the `PartyGovernanceNFT`.\\n    struct PartyInitData {\\n        PartyOptions options;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n        address[] authorities;\\n        uint40 rageQuitTimestamp;\\n    }\\n\\n    /// @notice Version ID of the party implementation contract.\\n    uint16 public constant VERSION_ID = 1;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) PartyGovernanceNFT(globals) {}\\n\\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\\n    ///         revert if called outside the constructor.\\n    /// @param initData Options used to initialize the party governance.\\n    function initialize(PartyInitData memory initData) external onlyConstructor {\\n        PartyGovernanceNFT._initialize(\\n            initData.options.name,\\n            initData.options.symbol,\\n            initData.options.customizationPresetId,\\n            initData.options.governance,\\n            initData.options.proposalEngine,\\n            initData.preciousTokens,\\n            initData.preciousTokenIds,\\n            initData.authorities,\\n            initData.rageQuitTimestamp\\n        );\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IERC721Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\ninterface IERC721Renderer {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IParty1_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\ninterface IParty1_1 {\\n    enum ProposalStatus {\\n        Invalid,\\n        Voting,\\n        Defeated,\\n        Passed,\\n        Ready,\\n        InProgress,\\n        Complete,\\n        Cancelled\\n    }\\n\\n    struct ProposalStateValues {\\n        uint40 proposedTime;\\n        uint40 passedTime;\\n        uint40 executedTime;\\n        uint40 completedTime;\\n        uint96 votes;\\n    }\\n\\n    function mintAuthority() external view returns (address);\\n\\n    function getProposalStateInfo(\\n        uint256 proposalId\\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(address pointer, uint256 start, uint256 end) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(address pointer, uint256 start, uint256 size) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\nabstract contract Multicall {\\n    using LibRawResult for bytes;\\n\\n    /// @notice Perform multiple delegatecalls on ourselves.\\n    function multicall(bytes[] calldata multicallData) external {\\n        for (uint256 i; i < multicallData.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(multicallData[i]);\\n            if (!s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibAddress {\\n    error EthTransferFailed(address receiver, bytes errData);\\n\\n    // Transfer ETH with full gas stipend.\\n    function transferEth(address payable receiver, uint256 amount) internal {\\n        if (amount == 0) return;\\n\\n        (bool s, bytes memory r) = receiver.call{ value: amount }(\\\"\\\");\\n        if (!s) {\\n            revert EthTransferFailed(receiver, r);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibRawResult.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibRawResult {\\n    // Revert with the data in `b`.\\n    function rawRevert(bytes memory b) internal pure {\\n        assembly {\\n            revert(add(b, 32), mload(b))\\n        }\\n    }\\n\\n    // Return with the data in `b`.\\n    function rawReturn(bytes memory b) internal pure {\\n        assembly {\\n            return(add(b, 32), mload(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\n\\n/// @notice Mixin for contracts that want to receive ERC721 tokens.\\n/// @dev Use this instead of solmate's ERC721TokenReceiver because the\\n///      compiler has issues when overriding EIP165/IERC721Receiver functions.\\nabstract contract ERC721Receiver is IERC721Receiver, EIP165, ERC721TokenReceiver {\\n    /// @inheritdoc IERC721Receiver\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override(IERC721Receiver, ERC721TokenReceiver) returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            EIP165.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC721Receiver).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gatekeepers/IGateKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Interface for a gatekeeper contract used for private crowdfund instances.\\ninterface IGateKeeper {\\n    /// @notice Check if a participant is eligible to participate in a crowdfund.\\n    /// @param participant The address of the participant.\\n    /// @param id The ID of the gate to eligibility against.\\n    /// @param userData The data used to check eligibility.\\n    /// @return `true` if the participant is allowed to participate, `false` otherwise.\\n    function isAllowed(\\n        address participant,\\n        bytes12 id,\\n        bytes memory userData\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/party/IPartyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Party } from \\\"../party/Party.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\n\\n// Creates generic Party instances.\\ninterface IPartyFactory {\\n    event PartyCreated(\\n        Party indexed party,\\n        Party.PartyOptions opts,\\n        IERC721[] preciousTokens,\\n        uint256[] preciousTokenIds,\\n        address creator\\n    );\\n\\n    /// @notice Deploy a new party instance.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @return party The newly created `Party` instance.\\n    function createParty(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions calldata opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp\\n    ) external returns (Party party);\\n\\n    /// @notice Deploy a new party instance with custom metadata.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @param provider The metadata provider to use for the party.\\n    /// @param metadata The metadata to use for the party.\\n    /// @return party The newly created `Party` instance.\\n    function createPartyWithMetadata(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions memory opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp,\\n        MetadataProvider provider,\\n        bytes memory metadata\\n    ) external returns (Party party);\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/CrowdfundNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../utils/IERC4906.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../globals/LibGlobals.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice NFT functionality for crowdfund types. This NFT is soulbound and read-only.\\ncontract CrowdfundNFT is IERC721, IERC4906, EIP165, ReadOnlyDelegateCall {\\n    error AlreadyMintedError(address owner, uint256 tokenId);\\n    error AlreadyBurnedError(address owner, uint256 tokenId);\\n    error InvalidTokenError(uint256 tokenId);\\n    error InvalidAddressError();\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The name of the crowdfund. This will also carry over to the\\n    ///         governance party.\\n    string public name;\\n    /// @notice The token symbol for the crowdfund. This will also carry over to\\n    ///         the governance party.\\n    string public symbol;\\n\\n    mapping(uint256 => address) private _owners;\\n\\n    modifier alwaysRevert() {\\n        revert(\\\"ALWAYS FAILING\\\");\\n        _; // Compiler requires this.\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize name and symbol for crowdfund.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId\\n    ) internal virtual {\\n        name = name_;\\n        symbol = symbol_;\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function transferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function approve(address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function setApprovalForAll(address, bool) external pure alwaysRevert {}\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return null.\\n    function getApproved(uint256) external pure returns (address) {\\n        return address(0);\\n    }\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return false.\\n    function isApprovedForAll(address, address) external pure returns (bool) {\\n        return false;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            // ERC721 interface ID\\n            interfaceId == 0x80ac58cd ||\\n            // ERC4906 interface ID\\n            interfaceId == 0x49064906;\\n    }\\n\\n    /// @notice Returns a URI to render the NFT.\\n    function tokenURI(uint256) external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner) {\\n        owner = _owners[tokenId];\\n        if (owner == address(0)) {\\n            revert InvalidTokenError(tokenId);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 numTokens) {\\n        return _doesTokenExistFor(owner) ? 1 : 0;\\n    }\\n\\n    function _doesTokenExistFor(address owner) internal view returns (bool) {\\n        return _owners[uint256(uint160(owner))] != address(0);\\n    }\\n\\n    function _mint(address owner) internal returns (uint256 tokenId) {\\n        if (owner == address(0)) revert InvalidAddressError();\\n        tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] != owner) {\\n            _owners[tokenId] = owner;\\n            emit Transfer(address(0), owner, tokenId);\\n        } else {\\n            revert AlreadyMintedError(owner, tokenId);\\n        }\\n    }\\n\\n    function _burn(address owner) internal {\\n        uint256 tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] == owner) {\\n            _owners[tokenId] = address(0);\\n            emit Transfer(owner, address(0), tokenId);\\n            return;\\n        }\\n        revert AlreadyBurnedError(owner, tokenId);\\n    }\\n\\n    function _delegateToRenderer() private view returns (string memory) {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_CF_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n        return \\\"\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Base contract for all contracts intended to be delegatecalled into.\\nabstract contract Implementation {\\n    error OnlyDelegateCallError();\\n    error OnlyConstructorError();\\n\\n    address public immutable IMPL;\\n\\n    constructor() {\\n        IMPL = address(this);\\n    }\\n\\n    // Reverts if the current function context is not inside of a delegatecall.\\n    modifier onlyDelegateCall() virtual {\\n        if (address(this) == IMPL) {\\n            revert OnlyDelegateCallError();\\n        }\\n        _;\\n    }\\n\\n    // Reverts if the current function context is not inside of a constructor.\\n    modifier onlyConstructor() {\\n        if (address(this).code.length != 0) {\\n            revert OnlyConstructorError();\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC721 interface.\\ninterface IERC721 {\\n    event Transfer(address indexed owner, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed operator, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address operator, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool isApproved) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernanceNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for uint96;\\n    using LibERC20Compat for IERC20;\\n    using LibAddress for address payable;\\n\\n    error OnlyAuthorityError();\\n    error OnlySelfError();\\n    error UnauthorizedToBurnError();\\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\\n    error CannotDisableRageQuitAfterInitializationError();\\n    error InvalidTokenOrderError();\\n    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);\\n    error NothingToBurnError();\\n\\n    event AuthorityAdded(address indexed authority);\\n    event AuthorityRemoved(address indexed authority);\\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\\n    event Burn(address caller, uint256 tokenId, uint256 votingPower);\\n    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);\\n\\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\\\"ENABLE_RAGEQUIT_PERMANENTLY\\\")))\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // Token address used to indicate ETH.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and its address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The number of tokens that have been minted.\\n    uint96 public tokenCount;\\n    /// @notice The total minted voting power.\\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\\n    ///         party cards for initial crowdfund.\\n    uint96 public mintedVotingPower;\\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\\n    ///         values to enable/disable ragequit permanently.\\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\\n    ///         initialization.\\n    uint40 public rageQuitTimestamp;\\n    /// @notice The voting power of `tokenId`.\\n    mapping(uint256 => uint256) public votingPowerByTokenId;\\n    /// @notice Address with authority to mint cards and update voting power for the party.\\n    mapping(address => bool) public isAuthority;\\n\\n    modifier onlyAuthority() {\\n        if (!isAuthority[msg.sender]) {\\n            revert OnlyAuthorityError();\\n        }\\n        _;\\n    }\\n\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) {\\n            revert OnlySelfError();\\n        }\\n        _;\\n    }\\n\\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\\n    // it will be set in `_initialize()`.\\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\\\"\\\", \\\"\\\") {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId,\\n        PartyGovernance.GovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        address[] memory authorities,\\n        uint40 rageQuitTimestamp_\\n    ) internal {\\n        PartyGovernance._initialize(\\n            governanceOpts,\\n            proposalEngineOpts,\\n            preciousTokens,\\n            preciousTokenIds\\n        );\\n        name = name_;\\n        symbol = symbol_;\\n        rageQuitTimestamp = rageQuitTimestamp_;\\n        unchecked {\\n            for (uint256 i; i < authorities.length; ++i) {\\n                isAuthority[authorities[i]] = true;\\n            }\\n        }\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function ownerOf(uint256 tokenId) public view override returns (address owner) {\\n        return ERC721.ownerOf(tokenId);\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\\n        return\\n            PartyGovernance.supportsInterface(interfaceId) ||\\n            ERC721.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC2981).interfaceId;\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function tokenURI(uint256) public view override returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\\n        _delegateToRenderer();\\n        return (address(0), 0); // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Return the distribution share amount of a token. Included as an alias\\n    ///         for `votePowerByTokenId` for backwards compatibility with old\\n    ///         `TokenDistributor` implementations.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The distribution shares of `tokenId`.\\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\\n        return votingPowerByTokenId[tokenId];\\n    }\\n\\n    /// @notice Return the voting power share of a token. Denominated\\n    ///         fractions of 1e18. I.e., 1e18 = 100%.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The voting power percentage of `tokenId`.\\n    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {\\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\\n        return\\n            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\\n    }\\n\\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\\n    ///         immediately delegate voting power to `delegate.` Only callable\\n    ///         by an authority.\\n    /// @param owner The owner of the NFT.\\n    /// @param votingPower The voting power of the NFT.\\n    /// @param delegate The address to delegate voting power to.\\n    function mint(\\n        address owner,\\n        uint256 votingPower,\\n        address delegate\\n    ) external onlyAuthority returns (uint256 tokenId) {\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\\n\\n        // Cap voting power to remaining unminted voting power supply.\\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\\n        // Allow minting past total voting power if minting party cards for\\n        // initial crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\\n            unchecked {\\n                votingPower_ = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        unchecked {\\n            tokenId = ++tokenCount;\\n        }\\n        mintedVotingPower += votingPower_;\\n        votingPowerByTokenId[tokenId] = votingPower_;\\n\\n        // Use delegate from party over the one set during crowdfund.\\n        address delegate_ = delegationsByVoter[owner];\\n        if (delegate_ != address(0)) {\\n            delegate = delegate_;\\n        }\\n\\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\\n        _safeMint(owner, tokenId);\\n    }\\n\\n    /// @notice Add voting power to an existing NFT. Only callable by an\\n    ///         authority.\\n    /// @param tokenId The ID of the NFT to add voting power to.\\n    /// @param votingPower The amount of voting power to add.\\n    function addVotingPower(uint256 tokenId, uint256 votingPower) external onlyAuthority {\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\\n        // Cap voting power to remaining unminted voting power supply.\\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\\n        // Allow minting past total voting power if minting party cards for\\n        // initial crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\\n            unchecked {\\n                votingPower_ = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        mintedVotingPower += votingPower_;\\n        votingPowerByTokenId[tokenId] += votingPower_;\\n\\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\\n    }\\n\\n    /// @notice Update the total voting power of the party. Only callable by\\n    ///         an authority.\\n    /// @param newVotingPower The new total voting power to add.\\n    function increaseTotalVotingPower(uint96 newVotingPower) external onlyAuthority {\\n        _governanceValues.totalVotingPower += newVotingPower;\\n    }\\n\\n    /// @notice Burn governance NFTs and remove their voting power. Can only\\n    ///         be called by an authority before the party has started.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    function burn(uint256[] memory tokenIds) public onlyAuthority {\\n        // Authority needs to be able to burn cards during the initial\\n        // crowdfund to process refunds but not after the party has started.\\n        if (_governanceValues.totalVotingPower != 0) revert UnauthorizedToBurnError();\\n\\n        // Used to update voting power state of party at the end.\\n        _burnAndUpdateVotingPower(tokenIds, false);\\n    }\\n\\n    function _burnAndUpdateVotingPower(\\n        uint256[] memory tokenIds,\\n        bool checkIfAuthorizedToBurn\\n    ) private returns (uint96 totalVotingPowerBurned) {\\n        for (uint256 i; i < tokenIds.length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            // Check if caller is authorized to burn the token.\\n            address owner = ownerOf(tokenId);\\n            if (checkIfAuthorizedToBurn) {\\n                if (\\n                    msg.sender != owner &&\\n                    getApproved[tokenId] != msg.sender &&\\n                    !isApprovedForAll[owner][msg.sender]\\n                ) {\\n                    revert UnauthorizedToBurnError();\\n                }\\n            }\\n\\n            // Must be retrieved before updating voting power for token to be burned.\\n            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\\n\\n            totalVotingPowerBurned += votingPower;\\n\\n            // Update voting power for token to be burned.\\n            delete votingPowerByTokenId[tokenId];\\n            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\\n\\n            // Burn token.\\n            _burn(tokenId);\\n\\n            emit Burn(msg.sender, tokenId, votingPower);\\n        }\\n\\n        // Update minted voting power.\\n        mintedVotingPower -= totalVotingPowerBurned;\\n    }\\n\\n    /// @notice Burn governance NFT and remove its voting power. Can only be\\n    ///         called by an authority before the party has started.\\n    /// @param tokenId The ID of the governance NFTs to burn.\\n    function burn(uint256 tokenId) external {\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n        burn(tokenIds);\\n    }\\n\\n    /// @notice Set the timestamp until which ragequit is enabled.\\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\\n    function setRageQuit(uint40 newRageQuitTimestamp) external onlyHost {\\n        // Prevent disabling ragequit after initialization.\\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\\n            revert CannotDisableRageQuitAfterInitializationError();\\n        }\\n\\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\\n\\n        // Prevent setting timestamp if it is permanently enabled/disabled.\\n        if (\\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\\n        ) {\\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\\n        }\\n\\n        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);\\n    }\\n\\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    /// @param withdrawTokens The fungible tokens to withdraw. Specify the\\n    ///                       `ETH_ADDRESS` value to withdraw ETH.\\n    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.\\n    /// @param receiver The address to receive the withdrawn tokens.\\n    function rageQuit(\\n        uint256[] calldata tokenIds,\\n        IERC20[] calldata withdrawTokens,\\n        uint256[] calldata minWithdrawAmounts,\\n        address receiver\\n    ) external {\\n        if (tokenIds.length == 0) revert NothingToBurnError();\\n\\n        // Check if ragequit is allowed.\\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\\n        if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\\n            if (\\n                currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\\n                currentRageQuitTimestamp < block.timestamp\\n            ) {\\n                revert CannotRageQuitError(currentRageQuitTimestamp);\\n            }\\n        }\\n\\n        // Used as a reentrancy guard. Will be updated back after ragequit.\\n        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;\\n\\n        // Update last rage quit timestamp.\\n        lastRageQuitTimestamp = uint40(block.timestamp);\\n\\n        // Sum up total amount of each token to withdraw.\\n        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);\\n        {\\n            IERC20 prevToken;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                IERC20 token = withdrawTokens[i];\\n\\n                // Check if order of tokens to transfer is valid.\\n                // Prevent null and duplicate transfers.\\n                if (prevToken >= token) revert InvalidTokenOrderError();\\n\\n                prevToken = token;\\n\\n                // Check token's balance.\\n                uint256 balance = address(token) == ETH_ADDRESS\\n                    ? address(this).balance\\n                    : token.balanceOf(address(this));\\n\\n                // Add fair share of tokens from the party to total.\\n                for (uint256 j; j < tokenIds.length; ++j) {\\n                    // Must be retrieved before burning the token.\\n                    uint256 shareOfVotingPower = getVotingPowerShareOf(tokenIds[j]);\\n\\n                    withdrawAmounts[i] += (balance * shareOfVotingPower) / 1e18;\\n                }\\n            }\\n        }\\n        {\\n            // Burn caller's party cards. This will revert if caller is not the\\n            // the owner or approved for any of the card they are attempting to\\n            // burn or if there are duplicate token IDs.\\n            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, true);\\n\\n            // Update total voting power of party.\\n            _governanceValues.totalVotingPower -= totalVotingPowerBurned;\\n        }\\n        {\\n            uint16 feeBps_ = feeBps;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                IERC20 token = withdrawTokens[i];\\n                uint256 amount = withdrawAmounts[i];\\n\\n                // Take fee from amount.\\n                uint256 fee = (amount * feeBps_) / 1e4;\\n\\n                if (fee > 0) {\\n                    amount -= fee;\\n\\n                    // Transfer fee to fee recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(feeRecipient).transferEth(fee);\\n                    } else {\\n                        token.compatTransfer(feeRecipient, fee);\\n                    }\\n                }\\n\\n                if (amount > 0) {\\n                    uint256 minAmount = minWithdrawAmounts[i];\\n\\n                    // Check amount is at least minimum.\\n                    if (amount < minAmount) {\\n                        revert BelowMinWithdrawAmountError(amount, minAmount);\\n                    }\\n\\n                    // Transfer token from party to recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(receiver).transferEth(amount);\\n                    } else {\\n                        token.compatTransfer(receiver, amount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Update ragequit timestamp back to before.\\n        rageQuitTimestamp = currentRageQuitTimestamp;\\n\\n        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function transferFrom(address owner, address to, uint256 tokenId) public override {\\n        // Transfer voting along with token.\\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\\n        super.transferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(\\n        address owner,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId, data);\\n    }\\n\\n    /// @notice Add a new authority.\\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\\n    ///      authorities to prevent it from being used anywhere else.\\n    function addAuthority(address authority) external onlySelf {\\n        isAuthority[authority] = true;\\n\\n        emit AuthorityAdded(authority);\\n    }\\n\\n    /// @notice Relinquish the authority role.\\n    function abdicateAuthority() external onlyAuthority {\\n        delete isAuthority[msg.sender];\\n\\n        emit AuthorityRemoved(msg.sender);\\n    }\\n\\n    function _delegateToRenderer() private view {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../distribution/ITokenDistributor.sol\\\";\\nimport \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../tokens/IERC20.sol\\\";\\nimport \\\"../tokens/ERC721Receiver.sol\\\";\\nimport \\\"../tokens/ERC1155Receiver.sol\\\";\\nimport \\\"../utils/LibERC20Compat.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../utils/IERC4906.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../globals/LibGlobals.sol\\\";\\nimport \\\"../proposals/IProposalExecutionEngine.sol\\\";\\nimport \\\"../proposals/LibProposal.sol\\\";\\nimport \\\"../proposals/ProposalStorage.sol\\\";\\n\\nimport \\\"./Party.sol\\\";\\n\\n/// @notice Base contract for a Party encapsulating all governance functionality.\\nabstract contract PartyGovernance is\\n    ERC721Receiver,\\n    ERC1155Receiver,\\n    ProposalStorage,\\n    Implementation,\\n    IERC4906,\\n    ReadOnlyDelegateCall\\n{\\n    using LibERC20Compat for IERC20;\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for int192;\\n    using LibSafeCast for uint96;\\n\\n    // States a proposal can be in.\\n    enum ProposalStatus {\\n        // The proposal does not exist.\\n        Invalid,\\n        // The proposal has been proposed (via `propose()`), has not been vetoed\\n        // by a party host, and is within the voting window. Members can vote on\\n        // the proposal and party hosts can veto the proposal.\\n        Voting,\\n        // The proposal has either exceeded its voting window without reaching\\n        // `passThresholdBps` of votes or was vetoed by a party host.\\n        Defeated,\\n        // The proposal reached at least `passThresholdBps` of votes but is still\\n        // waiting for `executionDelay` to pass before it can be executed. Members\\n        // can continue to vote on the proposal and party hosts can veto at this time.\\n        Passed,\\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\\n        // has arrived.\\n        Ready,\\n        // The proposal has been executed at least once but has further steps to\\n        // complete so it needs to be executed again. No other proposals may be\\n        // executed while a proposal is in the `InProgress` state. No voting or\\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\\n        InProgress,\\n        // The proposal was executed and completed all its steps. No voting or\\n        // vetoing can occur and it cannot be cancelled nor executed again.\\n        Complete,\\n        // The proposal was executed at least once but did not complete before\\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\\n        Cancelled\\n    }\\n\\n    struct GovernanceOpts {\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Total voting power of governance NFTs.\\n        uint96 totalVotingPower;\\n        // Fee bps for distributions.\\n        uint16 feeBps;\\n        // Fee recipeint for distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // Subset of `GovernanceOpts` that are commonly read together for\\n    // efficiency.\\n    struct GovernanceValues {\\n        uint40 voteDuration;\\n        uint40 executionDelay;\\n        uint16 passThresholdBps;\\n        uint96 totalVotingPower;\\n    }\\n\\n    // A snapshot of voting power for a member.\\n    struct VotingPowerSnapshot {\\n        // The timestamp when the snapshot was taken.\\n        uint40 timestamp;\\n        // Voting power that was delegated to this user by others.\\n        uint96 delegatedVotingPower;\\n        // The intrinsic (not delegated from someone else) voting power of this user.\\n        uint96 intrinsicVotingPower;\\n        // Whether the user was delegated to another at this snapshot.\\n        bool isDelegated;\\n    }\\n\\n    // Proposal details chosen by proposer.\\n    struct Proposal {\\n        // Time beyond which the proposal can no longer be executed.\\n        // If the proposal has already been executed, and is still InProgress,\\n        // this value is ignored.\\n        uint40 maxExecutableTime;\\n        // The minimum seconds this proposal can remain in the InProgress status\\n        // before it can be cancelled.\\n        uint40 cancelDelay;\\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\\n        // by encoded proposal args specific to the proposal type. See\\n        // ProposalExecutionEngine for details.\\n        bytes proposalData;\\n    }\\n\\n    // Accounting and state tracking values for a proposal.\\n    struct ProposalStateValues {\\n        // When the proposal was proposed.\\n        uint40 proposedTime;\\n        // When the proposal passed the vote.\\n        uint40 passedTime;\\n        // When the proposal was first executed.\\n        uint40 executedTime;\\n        // When the proposal completed.\\n        uint40 completedTime;\\n        // Number of accept votes.\\n        uint96 votes; // -1 == vetoed\\n        // Number of total voting power at time proposal created.\\n        uint96 totalVotingPower;\\n    }\\n\\n    // Storage states for a proposal.\\n    struct ProposalState {\\n        // Accounting and state tracking values.\\n        ProposalStateValues values;\\n        // Hash of the proposal.\\n        bytes32 hash;\\n        // Whether a member has voted for (accepted) this proposal already.\\n        mapping(address => bool) hasVoted;\\n    }\\n\\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    event ProposalPassed(uint256 indexed proposalId);\\n    event ProposalVetoed(uint256 indexed proposalId, address host);\\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\\n    event ProposalCancelled(uint256 indexed proposalId);\\n    event DistributionCreated(\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    );\\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\\n    event HostStatusTransferred(address oldHost, address newHost);\\n    event EmergencyExecuteDisabled();\\n\\n    error MismatchedPreciousListLengths();\\n    error BadProposalStatusError(ProposalStatus status);\\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\\n    error OnlyPartyHostError();\\n    error OnlyActiveMemberError();\\n    error OnlyTokenDistributorOrSelfError();\\n    error InvalidDelegateError();\\n    error BadPreciousListError();\\n    error OnlyPartyDaoError(address notDao, address partyDao);\\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error OnlyWhenEnabledError();\\n    error AlreadyVotedError(address voter);\\n    error InvalidNewHostError();\\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\\n    error InvalidBpsError(uint16 bps);\\n    error DistributionsRequireVoteError();\\n    error PartyNotStartedError();\\n    error CannotRageQuitAndAcceptError();\\n\\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\\n    uint96 private constant VETO_VALUE = type(uint96).max;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice Distribution fee bps.\\n    uint16 public feeBps;\\n    /// @notice Distribution fee recipient.\\n    address payable public feeRecipient;\\n    /// @notice The timestamp of the last time `rageQuit()` was called.\\n    uint40 public lastRageQuitTimestamp;\\n    /// @notice The hash of the list of precious NFTs guarded by the party.\\n    bytes32 public preciousListHash;\\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\\n    uint256 public lastProposalId;\\n    /// @notice Whether an address is a party host.\\n    mapping(address => bool) public isHost;\\n    /// @notice The last person a voter delegated its voting power to.\\n    mapping(address => address) public delegationsByVoter;\\n    // Governance parameters for this party.\\n    GovernanceValues internal _governanceValues;\\n    // ProposalState by proposal ID.\\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\\n    // Snapshots of voting power per user, each sorted by increasing time.\\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\\n\\n    modifier onlyHost() {\\n        if (!isHost[msg.sender]) {\\n            revert OnlyPartyHostError();\\n        }\\n        _;\\n    }\\n\\n    // Caller must have voting power at the current time.\\n    modifier onlyActiveMember() {\\n        {\\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n            // Must have either delegated voting power or intrinsic voting power.\\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n                revert OnlyActiveMemberError();\\n            }\\n        }\\n        _;\\n    }\\n\\n    // Only the party DAO multisig can call.\\n    modifier onlyPartyDao() {\\n        {\\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n            if (msg.sender != partyDao) {\\n                revert OnlyPartyDaoError(msg.sender, partyDao);\\n            }\\n        }\\n        _;\\n    }\\n\\n    // Only the party DAO multisig or a party host can call.\\n    modifier onlyPartyDaoOrHost() {\\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\\n        }\\n        _;\\n    }\\n\\n    // Only if `emergencyExecuteDisabled` is not true.\\n    modifier onlyWhenEmergencyExecuteAllowed() {\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyWhenNotGloballyDisabled() {\\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\\n            revert OnlyWhenEnabledError();\\n        }\\n        _;\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\\n    function _initialize(\\n        GovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal virtual {\\n        // Check BPS are valid.\\n        if (govOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(govOpts.feeBps);\\n        }\\n        if (govOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(govOpts.passThresholdBps);\\n        }\\n        // Initialize the proposal execution engine.\\n        _initProposalImpl(\\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\\n            abi.encode(proposalEngineOpts)\\n        );\\n        // Set the governance parameters.\\n        _governanceValues = GovernanceValues({\\n            voteDuration: govOpts.voteDuration,\\n            executionDelay: govOpts.executionDelay,\\n            passThresholdBps: govOpts.passThresholdBps,\\n            totalVotingPower: govOpts.totalVotingPower\\n        });\\n        // Set fees.\\n        feeBps = govOpts.feeBps;\\n        feeRecipient = govOpts.feeRecipient;\\n        // Set the precious list.\\n        _setPreciousList(preciousTokens, preciousTokenIds);\\n        // Set the party hosts.\\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\\n            isHost[govOpts.hosts[i]] = true;\\n        }\\n    }\\n\\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\\n    ///      Initial use case is to facilitate eip-1271 signatures.\\n    fallback() external {\\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\\n    }\\n\\n    /// @inheritdoc EIP165\\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure virtual override(ERC721Receiver, ERC1155Receiver) returns (bool) {\\n        return\\n            ERC721Receiver.supportsInterface(interfaceId) ||\\n            ERC1155Receiver.supportsInterface(interfaceId) ||\\n            // ERC4906 interface ID\\n            interfaceId == 0x49064906;\\n    }\\n\\n    /// @notice Get the current `ProposalExecutionEngine` instance.\\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\\n        return _getSharedProposalStorage().engineImpl;\\n    }\\n\\n    /// @notice Get the current `ProposalEngineOpts` options.\\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\\n        return _getSharedProposalStorage().opts;\\n    }\\n\\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the voting power at.\\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\\n    function getVotingPowerAt(\\n        address voter,\\n        uint40 timestamp\\n    ) external view returns (uint96 votingPower) {\\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\\n    }\\n\\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the voting power at.\\n    /// @param snapIndex The index of the snapshot to get the voting power at.\\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\\n    function getVotingPowerAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 snapIndex\\n    ) public view returns (uint96 votingPower) {\\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\\n    }\\n\\n    /// @notice Get the state of a proposal.\\n    /// @param proposalId The ID of the proposal.\\n    /// @return status The status of the proposal.\\n    /// @return values The state of the proposal.\\n    function getProposalStateInfo(\\n        uint256 proposalId\\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\\n        values = _proposalStateByProposalId[proposalId].values;\\n        status = _getProposalStatus(values);\\n    }\\n\\n    /// @notice Retrieve fixed governance parameters.\\n    /// @return gv The governance parameters of this party.\\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\\n        return _governanceValues;\\n    }\\n\\n    /// @notice Get the hash of a proposal.\\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\\n    ///      consistency between calls.\\n    /// @param proposal The proposal to hash.\\n    /// @return proposalHash The hash of the proposal.\\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\\n        // Hash the proposal in-place. Equivalent to:\\n        // keccak256(abi.encode(\\n        //   proposal.maxExecutableTime,\\n        //   proposal.cancelDelay,\\n        //   keccak256(proposal.proposalData)\\n        // ))\\n        bytes32 dataHash = keccak256(proposal.proposalData);\\n        assembly {\\n            // Overwrite the data field with the hash of its contents and then\\n            // hash the struct.\\n            let dataPos := add(proposal, 0x40)\\n            let t := mload(dataPos)\\n            mstore(dataPos, dataHash)\\n            proposalHash := keccak256(proposal, 0x60)\\n            // Restore the data field.\\n            mstore(dataPos, t)\\n        }\\n    }\\n\\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the snapshot index at.\\n    /// @return index The index of the snapshot.\\n    function findVotingPowerSnapshotIndex(\\n        address voter,\\n        uint40 timestamp\\n    ) public view returns (uint256 index) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n\\n        // Derived from Open Zeppelin binary search\\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\\n        uint256 high = snaps.length;\\n        uint256 low = 0;\\n        while (low < high) {\\n            uint256 mid = (low + high) / 2;\\n            if (snaps[mid].timestamp > timestamp) {\\n                // Entry is too recent.\\n                high = mid;\\n            } else {\\n                // Entry is older. This is our best guess for now.\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // Return `type(uint256).max` if no valid voting snapshots found.\\n        return high == 0 ? type(uint256).max : high - 1;\\n    }\\n\\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\\n    ///         the old one (if any).\\n    /// @param delegate The address to delegating voting power to.\\n    function delegateVotingPower(address delegate) external {\\n        _adjustVotingPower(msg.sender, 0, delegate);\\n        emit VotingPowerDelegated(msg.sender, delegate);\\n    }\\n\\n    /// @notice Transfer party host status to another.\\n    /// @param newPartyHost The address of the new host.\\n    function abdicateHost(address newPartyHost) external onlyHost {\\n        // 0 is a special case burn address.\\n        if (newPartyHost != address(0)) {\\n            // Cannot transfer host status to an existing host.\\n            if (isHost[newPartyHost]) {\\n                revert InvalidNewHostError();\\n            }\\n            isHost[newPartyHost] = true;\\n        }\\n        isHost[msg.sender] = false;\\n        emit HostStatusTransferred(msg.sender, newPartyHost);\\n    }\\n\\n    /// @notice Create a token distribution by moving the party's entire balance\\n    ///         to the `TokenDistributor` contract and immediately creating a\\n    ///         distribution governed by this party.\\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\\n    ///      propagated to the distribution. Party members are entitled to a\\n    ///      share of the distribution's tokens proportionate to their relative\\n    ///      voting power in this party (less the fee).\\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\\n    /// @param tokenType The type of token to distribute.\\n    /// @param token The address of the token to distribute.\\n    /// @param tokenId The ID of the token to distribute. Currently unused but\\n    ///                may be used in the future to support other distribution types.\\n    /// @return distInfo The information about the created distribution.\\n    function distribute(\\n        uint256 amount,\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    )\\n        external\\n        onlyWhenNotGloballyDisabled\\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\\n    {\\n        // Ignore if the party is calling functions on itself, like with\\n        // `FractionalizeProposal` and `DistributionProposal`.\\n        if (msg.sender != address(this)) {\\n            // Must not require a vote to create a distribution, otherwise\\n            // distributions can only be created through a distribution\\n            // proposal.\\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\\n                revert DistributionsRequireVoteError();\\n            }\\n            // Must be an active member.\\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n                revert OnlyActiveMemberError();\\n            }\\n        }\\n        // Prevent creating a distribution if the party has not started.\\n        if (_governanceValues.totalVotingPower == 0) {\\n            revert PartyNotStartedError();\\n        }\\n        // Get the address of the token distributor.\\n        ITokenDistributor distributor = ITokenDistributor(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\\n        );\\n        emit DistributionCreated(tokenType, token, tokenId);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n        // Create a native token distribution.\\n        address payable feeRecipient_ = feeRecipient;\\n        uint16 feeBps_ = feeBps;\\n        if (tokenType == ITokenDistributor.TokenType.Native) {\\n            return\\n                distributor.createNativeDistribution{ value: amount }(\\n                    Party(payable(address(this))),\\n                    feeRecipient_,\\n                    feeBps_\\n                );\\n        }\\n        // Otherwise must be an ERC20 token distribution.\\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\\n        IERC20(token).compatTransfer(address(distributor), amount);\\n        return\\n            distributor.createErc20Distribution(\\n                IERC20(token),\\n                Party(payable(address(this))),\\n                feeRecipient_,\\n                feeBps_\\n            );\\n    }\\n\\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\\n    ///         as well.\\n    /// @dev Only an active member (has voting power) can call this.\\n    ///      Afterwards, members can vote to support it with `accept()` or a party\\n    ///      host can unilaterally reject the proposal with `veto()`.\\n    /// @param proposal The details of the proposal.\\n    /// @param latestSnapIndex The index of the caller's most recent voting power\\n    ///                        snapshot before the proposal was created. Should\\n    ///                        be retrieved off-chain and passed in.\\n    function propose(\\n        Proposal memory proposal,\\n        uint256 latestSnapIndex\\n    ) external onlyActiveMember returns (uint256 proposalId) {\\n        proposalId = ++lastProposalId;\\n        // Store the time the proposal was created and the proposal hash.\\n        (\\n            _proposalStateByProposalId[proposalId].values,\\n            _proposalStateByProposalId[proposalId].hash\\n        ) = (\\n            ProposalStateValues({\\n                proposedTime: uint40(block.timestamp),\\n                passedTime: 0,\\n                executedTime: 0,\\n                completedTime: 0,\\n                votes: 0,\\n                totalVotingPower: _governanceValues.totalVotingPower\\n            }),\\n            getProposalHash(proposal)\\n        );\\n        emit Proposed(proposalId, msg.sender, proposal);\\n        accept(proposalId, latestSnapIndex);\\n\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Vote to support a proposed proposal.\\n    /// @dev The voting power cast will be the effective voting power of the caller\\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\\n    ///      proposal will be in the `Passed` state and will be executable after\\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\\n    /// @param proposalId The ID of the proposal to accept.\\n    /// @param snapIndex The index of the caller's last voting power snapshot\\n    ///                  before the proposal was created. Should be retrieved\\n    ///                  off-chain and passed in.\\n    /// @return totalVotes The total votes cast on the proposal.\\n    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {\\n        // Get the information about the proposal.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        // Can only vote in certain proposal statuses.\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Allow voting even if the proposal is passed/ready so it can\\n            // potentially reach 100% consensus, which unlocks special\\n            // behaviors for certain proposal types.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // Prevent voting in the same block as the last rage quit timestamp.\\n        // This is to prevent an exploit where a member can rage quit to reduce\\n        // the total voting power of the party, then propose and vote in the\\n        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.\\n        // This would allow them to use the voting power snapshot just before\\n        // their card was burned to vote, potentially passing a proposal that\\n        // would have otherwise not passed.\\n        if (lastRageQuitTimestamp == block.timestamp) {\\n            revert CannotRageQuitAndAcceptError();\\n        }\\n\\n        // Cannot vote twice.\\n        if (info.hasVoted[msg.sender]) {\\n            revert AlreadyVotedError(msg.sender);\\n        }\\n        // Mark the caller as having voted.\\n        info.hasVoted[msg.sender] = true;\\n\\n        // Increase the total votes that have been cast on this proposal.\\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\\n        values.votes += votingPower;\\n        info.values = values;\\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\\n\\n        // Update the proposal status if it has reached the pass threshold.\\n        if (\\n            values.passedTime == 0 &&\\n            _areVotesPassing(\\n                values.votes,\\n                values.totalVotingPower,\\n                _governanceValues.passThresholdBps\\n            )\\n        ) {\\n            info.values.passedTime = uint40(block.timestamp);\\n            emit ProposalPassed(proposalId);\\n            // Notify third-party platforms that the governance NFT metadata has\\n            // updated for all tokens.\\n            emit BatchMetadataUpdate(0, type(uint256).max);\\n        }\\n        return values.votes;\\n    }\\n\\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\\n    ///      cannot be vetoed.\\n    /// @param proposalId The ID of the proposal to veto.\\n    function veto(uint256 proposalId) external onlyHost {\\n        // Setting `votes` to -1 indicates a veto.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Proposal must be in one of the following states.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // -1 indicates veto.\\n        info.values.votes = VETO_VALUE;\\n        emit ProposalVetoed(proposalId, msg.sender);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Executes a proposal that has passed governance.\\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\\n    ///      if the proposal has extra steps (must be executed again) to carry out,\\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\\n    ///      in order to execute a different proposal.\\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\\n    /// @param proposalId The ID of the proposal to execute.\\n    /// @param proposal The details of the proposal.\\n    /// @param preciousTokens The tokens that the party considers precious.\\n    /// @param preciousTokenIds The token IDs associated with each precious token.\\n    /// @param progressData The data returned from the last `execute()` call, if any.\\n    /// @param extraData Off-chain data a proposal might need to execute a step.\\n    function execute(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        bytes calldata progressData,\\n        bytes calldata extraData\\n    ) external payable onlyActiveMember onlyWhenNotGloballyDisabled onlyDelegateCall {\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        ProposalStatus status = _getProposalStatus(values);\\n        // The proposal must be executable or have already been executed but still\\n        // has more steps to go.\\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\\n            revert BadProposalStatusError(status);\\n        }\\n        if (status == ProposalStatus.Ready) {\\n            // If the proposal has not been executed yet, make sure it hasn't\\n            // expired. Note that proposals that have been executed\\n            // (but still have more steps) ignore `maxExecutableTime`.\\n            if (proposal.maxExecutableTime < block.timestamp) {\\n                revert ExecutionTimeExceededError(\\n                    proposal.maxExecutableTime,\\n                    uint40(block.timestamp)\\n                );\\n            }\\n            proposalState.values.executedTime = uint40(block.timestamp);\\n        }\\n        // Check that the precious list is valid.\\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\\n            revert BadPreciousListError();\\n        }\\n        // Preemptively set the proposal to completed to avoid it being executed\\n        // again in a deeper call.\\n        proposalState.values.completedTime = uint40(block.timestamp);\\n        // Execute the proposal.\\n        bool completed = _executeProposal(\\n            proposalId,\\n            proposal,\\n            preciousTokens,\\n            preciousTokenIds,\\n            _getProposalFlags(values),\\n            progressData,\\n            extraData\\n        );\\n        if (!completed) {\\n            // Proposal did not complete.\\n            proposalState.values.completedTime = 0;\\n        }\\n    }\\n\\n    /// @notice Cancel a (probably stuck) InProgress proposal.\\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\\n    ///      executed for this to be valid. The currently active proposal will\\n    ///      simply be yeeted out of existence so another proposal can execute.\\n    ///      This is intended to be a last resort and can leave the party in a\\n    ///      broken state. Whenever possible, active proposals should be\\n    ///      allowed to complete their lifecycle.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @param proposal The details of the proposal to cancel.\\n    function cancel(uint256 proposalId, Proposal calldata proposal) external onlyActiveMember {\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        {\\n            // Must be `InProgress`.\\n            ProposalStatus status = _getProposalStatus(values);\\n            if (status != ProposalStatus.InProgress) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n        {\\n            // Limit the `cancelDelay` to the global max and min cancel delay\\n            // to mitigate parties accidentally getting stuck forever by setting an\\n            // unrealistic `cancelDelay` or being reckless with too low a\\n            // cancel delay.\\n            uint256 cancelDelay = proposal.cancelDelay;\\n            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION\\n            );\\n            uint256 globalMinCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION\\n            );\\n            if (globalMaxCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay > globalMaxCancelDelay) {\\n                    cancelDelay = globalMaxCancelDelay;\\n                }\\n            }\\n            if (globalMinCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay < globalMinCancelDelay) {\\n                    cancelDelay = globalMinCancelDelay;\\n                }\\n            }\\n            uint256 cancelTime = values.executedTime + cancelDelay;\\n            // Must not be too early.\\n            if (block.timestamp < cancelTime) {\\n                revert ProposalCannotBeCancelledYetError(\\n                    uint40(block.timestamp),\\n                    uint40(cancelTime)\\n                );\\n            }\\n        }\\n        // Mark the proposal as cancelled by setting the completed time to the current\\n        // time with the high bit set.\\n        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);\\n        {\\n            // Delegatecall into the proposal engine impl to perform the cancel.\\n            (bool success, bytes memory resultData) = (\\n                address(_getSharedProposalStorage().engineImpl)\\n            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n        }\\n        emit ProposalCancelled(proposalId);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external onlyPartyDaoOrHost {\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    function _executeProposal(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint256 flags,\\n        bytes memory progressData,\\n        bytes memory extraData\\n    ) private returns (bool completed) {\\n        // Setup the arguments for the proposal execution engine.\\n        IProposalExecutionEngine.ExecuteProposalParams\\n            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({\\n                proposalId: proposalId,\\n                proposalData: proposal.proposalData,\\n                progressData: progressData,\\n                extraData: extraData,\\n                preciousTokens: preciousTokens,\\n                preciousTokenIds: preciousTokenIds,\\n                flags: flags\\n            });\\n        // Get the progress data returned after the proposal is executed.\\n        bytes memory nextProgressData;\\n        {\\n            // Execute the proposal.\\n            (bool success, bytes memory resultData) = address(\\n                _getSharedProposalStorage().engineImpl\\n            ).delegatecall(\\n                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))\\n                );\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            nextProgressData = abi.decode(resultData, (bytes));\\n        }\\n        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);\\n        // Notify third-party platforms that the governance NFT metadata has\\n        // updated for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n        // If the returned progress data is empty, then the proposal completed\\n        // and it should not be executed again.\\n        return nextProgressData.length == 0;\\n    }\\n\\n    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a \\\"hint\\\".\\n    function _getVotingPowerSnapshotAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 hintIndex\\n    ) internal view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 snapsLength = snaps.length;\\n        if (snapsLength != 0) {\\n            if (\\n                // Hint is within bounds.\\n                hintIndex < snapsLength &&\\n                // Snapshot is not too recent.\\n                snaps[hintIndex].timestamp <= timestamp &&\\n                // Snapshot is not too old.\\n                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)\\n            ) {\\n                return snaps[hintIndex];\\n            }\\n\\n            // Hint was wrong, fallback to binary search to find snapshot.\\n            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);\\n            // Check that snapshot was found.\\n            if (hintIndex != type(uint256).max) {\\n                return snaps[hintIndex];\\n            }\\n        }\\n\\n        // No snapshot found.\\n        return snap;\\n    }\\n\\n    // Transfers some voting power of `from` to `to`. The total voting power of\\n    // their respective delegates will be updated as well.\\n    function _transferVotingPower(address from, address to, uint256 power) internal {\\n        int192 powerI192 = power.safeCastUint256ToInt192();\\n        _adjustVotingPower(from, -powerI192, address(0));\\n        _adjustVotingPower(to, powerI192, address(0));\\n    }\\n\\n    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.\\n    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {\\n        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);\\n        address oldDelegate = delegationsByVoter[voter];\\n        // If `oldDelegate` is zero and `voter` never delegated, then have\\n        // `voter` delegate to themself.\\n        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;\\n        // If the new `delegate` is zero, use the current (old) delegate.\\n        delegate = delegate == address(0) ? oldDelegate : delegate;\\n\\n        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({\\n            timestamp: uint40(block.timestamp),\\n            delegatedVotingPower: oldSnap.delegatedVotingPower,\\n            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +\\n                votingPower).safeCastInt192ToUint96(),\\n            isDelegated: delegate != voter\\n        });\\n        _insertVotingPowerSnapshot(voter, newSnap);\\n        delegationsByVoter[voter] = delegate;\\n        // Handle rebalancing delegates.\\n        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);\\n    }\\n\\n    // Update the delegated voting power of the old and new delegates delegated to\\n    // by `voter` based on the snapshot change.\\n    function _rebalanceDelegates(\\n        address voter,\\n        address oldDelegate,\\n        address newDelegate,\\n        VotingPowerSnapshot memory oldSnap,\\n        VotingPowerSnapshot memory newSnap\\n    ) private {\\n        if (newDelegate == address(0) || oldDelegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n        if (oldDelegate != voter && oldDelegate != newDelegate) {\\n            // Remove past voting power from old delegate.\\n            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                oldDelegate\\n            );\\n            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -\\n                    oldSnap.intrinsicVotingPower,\\n                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,\\n                isDelegated: oldDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);\\n        }\\n        if (newDelegate != voter) {\\n            // Not delegating to self.\\n            // Add new voting power to new delegate.\\n            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                newDelegate\\n            );\\n            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +\\n                newSnap.intrinsicVotingPower;\\n            if (newDelegate == oldDelegate) {\\n                // If the old and new delegate are the same, subtract the old\\n                // intrinsic voting power of the voter, or else we will double\\n                // count a portion of it.\\n                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;\\n            }\\n            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: newDelegateDelegatedVotingPower,\\n                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,\\n                isDelegated: newDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);\\n        }\\n    }\\n\\n    // Append a new voting power snapshot, overwriting the last one if possible.\\n    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.\\n        if (n != 0) {\\n            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];\\n            if (lastSnap.timestamp == snap.timestamp) {\\n                voterSnaps[n - 1] = snap;\\n                return;\\n            }\\n        }\\n        voterSnaps.push(snap);\\n    }\\n\\n    function _getLastVotingPowerSnapshotForVoter(\\n        address voter\\n    ) private view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        if (n != 0) {\\n            snap = voterSnaps[n - 1];\\n        }\\n    }\\n\\n    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {\\n        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n            return LibProposal.PROPOSAL_FLAG_UNANIMOUS;\\n        }\\n        return 0;\\n    }\\n\\n    function _getProposalStatus(\\n        ProposalStateValues memory pv\\n    ) private view returns (ProposalStatus status) {\\n        // Never proposed.\\n        if (pv.proposedTime == 0) {\\n            return ProposalStatus.Invalid;\\n        }\\n        // Executed at least once.\\n        if (pv.executedTime != 0) {\\n            if (pv.completedTime == 0) {\\n                return ProposalStatus.InProgress;\\n            }\\n            // completedTime high bit will be set if cancelled.\\n            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {\\n                return ProposalStatus.Cancelled;\\n            }\\n            return ProposalStatus.Complete;\\n        }\\n        // Vetoed.\\n        if (pv.votes == type(uint96).max) {\\n            return ProposalStatus.Defeated;\\n        }\\n        uint40 t = uint40(block.timestamp);\\n        GovernanceValues memory gv = _governanceValues;\\n        if (pv.passedTime != 0) {\\n            // Ready.\\n            if (pv.passedTime + gv.executionDelay <= t) {\\n                return ProposalStatus.Ready;\\n            }\\n            // If unanimous, we skip the execution delay.\\n            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n                return ProposalStatus.Ready;\\n            }\\n            // Passed.\\n            return ProposalStatus.Passed;\\n        }\\n        // Voting window expired.\\n        if (pv.proposedTime + gv.voteDuration <= t) {\\n            return ProposalStatus.Defeated;\\n        }\\n        return ProposalStatus.Voting;\\n    }\\n\\n    function _isUnanimousVotes(\\n        uint96 totalVotes,\\n        uint96 totalVotingPower\\n    ) private pure returns (bool) {\\n        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;\\n        // If >= 99.99% acceptance, consider it unanimous.\\n        // The minting formula for voting power is a bit lossy, so we check\\n        // for slightly less than 100%.\\n        return acceptanceRatio >= 0.9999e4;\\n    }\\n\\n    function _areVotesPassing(\\n        uint96 voteCount,\\n        uint96 totalVotingPower,\\n        uint16 passThresholdBps\\n    ) private pure returns (bool) {\\n        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);\\n    }\\n\\n    function _setPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private {\\n        if (preciousTokens.length != preciousTokenIds.length) {\\n            revert MismatchedPreciousListLengths();\\n        }\\n        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _isPreciousListCorrect(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private view returns (bool) {\\n        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _hashPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bytes32 h) {\\n        assembly {\\n            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))\\n            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))\\n            h := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    // Assert that the hash of a proposal matches expectedHash.\\n    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {\\n        bytes32 actualHash = getProposalHash(proposal);\\n        if (expectedHash != actualHash) {\\n            revert BadProposalHashError(actualHash, expectedHash);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EIP165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nabstract contract EIP165 {\\n    /// @notice Query if a contract implements an interface.\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @return `true` if the contract implements `interfaceId` and\\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return interfaceId == this.supportsInterface.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\\n// Only modified to inherit IERC721 and EIP165.\\npragma solidity >=0.8.0;\\n\\n// NOTE: Only modified to inherit IERC20 and EIP165\\nimport \\\"../../tokens/IERC721.sol\\\";\\nimport \\\"../../utils/EIP165.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 is IERC721, EIP165 {\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id /* view */) public virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                isApprovedForAll[from][msg.sender] ||\\n                msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        // NOTE: modified from original to call super.\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\nimport { MetadataRegistry } from \\\"./MetadataRegistry.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\n\\n/// @notice A contract that provides custom metadata for Party Cards.\\ncontract MetadataProvider is IMetadataProvider, Multicall {\\n    event MetadataSet(address indexed instance, bytes metadata);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @inheritdoc IMetadataProvider\\n    bool public constant supportsRegistrars = true;\\n\\n    // The metadata for each Party instance.\\n    mapping(address instance => bytes metadata) private _metadata;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @inheritdoc IMetadataProvider\\n    function getMetadata(address instance, uint256) external view override returns (bytes memory) {\\n        return _metadata[instance];\\n    }\\n\\n    /// @notice Set the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param metadata The encoded metadata.\\n    function setMetadata(address instance, bytes memory metadata) external {\\n        if (instance != msg.sender) {\\n            MetadataRegistry registry = MetadataRegistry(\\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_METADATA_REGISTRY)\\n            );\\n\\n            // Check if the caller is authorized to set metadata for the instance.\\n            if (!registry.isRegistrar(msg.sender, instance)) {\\n                revert NotAuthorized(msg.sender, instance);\\n            }\\n        }\\n\\n        _metadata[instance] = metadata;\\n\\n        emit MetadataSet(instance, metadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReadOnlyDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibRawResult.sol\\\";\\n\\ninterface IReadOnlyDelegateCall {\\n    // Marked `view` so that `_readOnlyDelegateCall` can be `view` as well.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external view;\\n}\\n\\n// Inherited by contracts to perform read-only delegate calls.\\nabstract contract ReadOnlyDelegateCall {\\n    using LibRawResult for bytes;\\n\\n    // Delegatecall into implement and revert with the raw result.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external {\\n        // Attempt to gate to only `_readOnlyDelegateCall()` invocations.\\n        require(msg.sender == address(this));\\n        (bool s, bytes memory r) = impl.delegatecall(callData);\\n        // Revert with success status and return data.\\n        abi.encode(s, r).rawRevert();\\n    }\\n\\n    // Perform a `delegateCallAndRevert()` then return the raw result data.\\n    function _readOnlyDelegateCall(address impl, bytes memory callData) internal view {\\n        try IReadOnlyDelegateCall(address(this)).delegateCallAndRevert(impl, callData) {\\n            // Should never happen.\\n            assert(false);\\n        } catch (bytes memory r) {\\n            (bool success, bytes memory resultData) = abi.decode(r, (bool, bytes));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            resultData.rawReturn();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC4906 {\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/LibGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Valid keys in `IGlobals`. Append-only.\\nlibrary LibGlobals {\\n    // The Globals commented out below were depreciated in 1.2; factories\\n    // can now choose the implementation address to deploy and no longer\\n    // deploy the latest implementation. They will no longer be updated\\n    // in future releases.\\n    //\\n    // See https://github.com/PartyDAO/party-migrations for\\n    // implementation addresses by release.\\n\\n    uint256 internal constant GLOBAL_PARTY_IMPL = 1;\\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL = 2;\\n    // uint256 internal constant GLOBAL_PARTY_FACTORY = 3;\\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL = 4;\\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL = 5;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT = 6;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION = 7;\\n    // uint256 internal constant GLOBAL_AUCTION_CF_IMPL = 8;\\n    // uint256 internal constant GLOBAL_BUY_CF_IMPL = 9;\\n    // uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL = 10;\\n    uint256 internal constant GLOBAL_DAO_WALLET = 11;\\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR = 12;\\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY = 13;\\n    uint256 internal constant GLOBAL_OPENSEA_ZONE = 14;\\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION = 15;\\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION = 16;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION = 17;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT = 18;\\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION = 19;\\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION = 20;\\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS = 21;\\n    uint256 internal constant GLOBAL_RENDERER_STORAGE = 22;\\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION = 23;\\n    // uint256 internal constant GLOBAL_ROLLING_AUCTION_CF_IMPL = 24;\\n    // uint256 internal constant GLOBAL_COLLECTION_BATCH_BUY_CF_IMPL = 25;\\n    uint256 internal constant GLOBAL_METADATA_REGISTRY = 26;\\n    // uint256 internal constant GLOBAL_CROWDFUND_FACTORY = 27;\\n    // uint256 internal constant GLOBAL_INITIAL_ETH_CF_IMPL = 28;\\n    // uint256 internal constant GLOBAL_RERAISE_ETH_CF_IMPL = 29;\\n    uint256 internal constant GLOBAL_SEAPORT = 30;\\n    uint256 internal constant GLOBAL_CONDUIT_CONTROLLER = 31;\\n    uint256 internal constant GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR = 32;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/ITokenDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\nimport \\\"../party/Party.sol\\\";\\n\\n/// @notice Creates token distributions for parties.\\ninterface ITokenDistributor {\\n    enum TokenType {\\n        Native,\\n        Erc20\\n    }\\n\\n    // Info on a distribution, created by createDistribution().\\n    struct DistributionInfo {\\n        // Type of distribution/token.\\n        TokenType tokenType;\\n        // ID of the distribution. Assigned by createDistribution().\\n        uint256 distributionId;\\n        // The party whose members can claim the distribution.\\n        Party party;\\n        // Who can claim `fee`.\\n        address payable feeRecipient;\\n        // The token being distributed.\\n        address token;\\n        // Total amount of `token` that can be claimed by party members.\\n        uint128 memberSupply;\\n        // Amount of `token` to be redeemed by `feeRecipient`.\\n        uint128 fee;\\n        // Total shares at time distribution was created.\\n        uint96 totalShares;\\n    }\\n\\n    event DistributionCreated(Party indexed party, DistributionInfo info);\\n    event DistributionFeeClaimed(\\n        Party indexed party,\\n        address indexed feeRecipient,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amount\\n    );\\n    event DistributionClaimedByPartyToken(\\n        Party indexed party,\\n        uint256 indexed partyTokenId,\\n        address indexed owner,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amountClaimed\\n    );\\n\\n    /// @notice Create a new distribution for an outstanding native token balance\\n    ///         governed by a party.\\n    /// @dev Native tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createNativeDistribution(\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external payable returns (DistributionInfo memory info);\\n\\n    /// @notice Create a new distribution for an outstanding ERC20 token balance\\n    ///         governed by a party.\\n    /// @dev ERC20 tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param token The ERC20 token to distribute.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createErc20Distribution(\\n        IERC20 token,\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external returns (DistributionInfo memory info);\\n\\n    /// @notice Claim a portion of a distribution owed to a `partyTokenId` belonging\\n    ///         to the party that created the distribution. The caller\\n    ///         must own this token.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return amountClaimed The amount of the distribution claimed.\\n    function claim(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external returns (uint128 amountClaimed);\\n\\n    /// @notice Claim the fee for a distribution. Only a distribution's `feeRecipient`\\n    ///         can call this.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param recipient The address to send the fee to.\\n    function claimFee(DistributionInfo calldata info, address payable recipient) external;\\n\\n    /// @notice Batch version of `claim()`.\\n    /// @param infos Information on the distributions being claimed.\\n    /// @param partyTokenIds The ID of the party tokens to claim for.\\n    /// @return amountsClaimed The amount of the distributions claimed.\\n    function batchClaim(\\n        DistributionInfo[] calldata infos,\\n        uint256[] calldata partyTokenIds\\n    ) external returns (uint128[] memory amountsClaimed);\\n\\n    /// @notice Batch version of `claimFee()`.\\n    /// @param infos Information on the distributions to claim fees for.\\n    /// @param recipients The addresses to send the fees to.\\n    function batchClaimFee(\\n        DistributionInfo[] calldata infos,\\n        address payable[] calldata recipients\\n    ) external;\\n\\n    /// @notice Compute the amount of a distribution's token are owed to a party\\n    ///         member, identified by the `partyTokenId`.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return claimAmount The amount of the distribution owed to the party member.\\n    function getClaimAmount(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external view returns (uint128);\\n\\n    /// @notice Check whether the fee has been claimed for a distribution.\\n    /// @param party The party to use for checking whether the fee has been claimed.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return feeClaimed Whether the fee has been claimed.\\n    function wasFeeClaimed(Party party, uint256 distributionId) external view returns (bool);\\n\\n    /// @notice Check whether a `partyTokenId` has claimed their share of a distribution.\\n    /// @param party The party to use for checking whether the `partyTokenId` has claimed.\\n    /// @param partyTokenId The ID of the party token to check.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return hasClaimed Whether the `partyTokenId` has claimed.\\n    function hasPartyTokenIdClaimed(\\n        Party party,\\n        uint256 partyTokenId,\\n        uint256 distributionId\\n    ) external view returns (bool);\\n\\n    /// @notice Get how much unclaimed member tokens are left in a distribution.\\n    /// @param party The party to use for checking the unclaimed member tokens.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return remainingMemberSupply The amount of distribution supply remaining.\\n    function getRemainingMemberSupply(\\n        Party party,\\n        uint256 distributionId\\n    ) external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC20 interface.\\ninterface IERC20 {\\n    event Transfer(address indexed owner, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 allowance);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function approve(address spender, uint256 allowance) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\nimport \\\"../vendor/solmate/ERC1155.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\n\\nabstract contract ERC1155Receiver is EIP165, ERC1155TokenReceiverBase {\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibERC20Compat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\n// Compatibility helpers for ERC20s.\\nlibrary LibERC20Compat {\\n    error NotATokenError(IERC20 token);\\n    error TokenTransferFailedError(IERC20 token, address to, uint256 amount);\\n    error TokenApprovalFailed(IERC20 token, address spender, uint256 amount);\\n\\n    // Perform an `IERC20.transfer()` handling non-compliant implementations.\\n    function compatTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transfer, (to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    // Perform an `IERC20.transferFrom()` handling non-compliant implementations.\\n    function compatTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    function compatApprove(IERC20 token, address spender, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.approve, (spender, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenApprovalFailed(token, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/IProposalExecutionEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\n// Upgradeable proposals logic contract interface.\\ninterface IProposalExecutionEngine {\\n    struct ExecuteProposalParams {\\n        uint256 proposalId;\\n        bytes proposalData;\\n        bytes progressData;\\n        bytes extraData;\\n        uint256 flags;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n    }\\n\\n    function initialize(address oldImpl, bytes memory initData) external;\\n\\n    /// @notice Execute a proposal.\\n    /// @dev Must be delegatecalled into by PartyGovernance.\\n    ///      If the proposal is incomplete, continues its next step (if possible).\\n    ///      If another proposal is incomplete, this will fail. Only one\\n    ///      incomplete proposal is allowed at a time.\\n    /// @param params The data needed to execute the proposal.\\n    /// @return nextProgressData Bytes to be passed into the next `execute()` call,\\n    ///         if the proposal execution is incomplete. Otherwise, empty bytes\\n    ///         to indicate the proposal is complete.\\n    function executeProposal(\\n        ExecuteProposalParams memory params\\n    ) external returns (bytes memory nextProgressData);\\n\\n    /// @notice Forcibly cancel an incomplete proposal.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @dev This is intended to be a last resort as it can leave a party in a\\n    ///      broken step. Whenever possible, proposals should be allowed to\\n    ///      complete their entire lifecycle.\\n    function cancelProposal(uint256 proposalId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/LibProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nlibrary LibProposal {\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n\\n    function isTokenPrecious(\\n        IERC721 token,\\n        IERC721[] memory preciousTokens\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function isTokenIdPrecious(\\n        IERC721 token,\\n        uint256 tokenId,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i] && tokenId == preciousTokenIds[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/ProposalStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./IProposalExecutionEngine.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\n// The storage bucket shared by `PartyGovernance` and the `ProposalExecutionEngine`.\\n// Read this for more context on the pattern motivating this:\\n// https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\\nabstract contract ProposalStorage {\\n    using LibRawResult for bytes;\\n\\n    struct SharedProposalStorage {\\n        IProposalExecutionEngine engineImpl;\\n        ProposalEngineOpts opts;\\n    }\\n\\n    struct ProposalEngineOpts {\\n        // Whether the party can add new authorities with the add authority proposal.\\n        bool enableAddAuthorityProposal;\\n        // Whether the party can spend ETH from the party's balance with\\n        // arbitrary call proposals.\\n        bool allowArbCallsToSpendPartyEth;\\n        // Whether operators can be used.\\n        bool allowOperators;\\n        // Whether distributions require a vote or can be executed by any active member.\\n        bool distributionsRequireVote;\\n    }\\n\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n    uint256 private constant SHARED_STORAGE_SLOT =\\n        uint256(keccak256(\\\"ProposalStorage.SharedProposalStorage\\\"));\\n\\n    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {\\n        SharedProposalStorage storage stor = _getSharedProposalStorage();\\n        IProposalExecutionEngine oldImpl = stor.engineImpl;\\n        stor.engineImpl = impl;\\n        (bool s, bytes memory r) = address(impl).delegatecall(\\n            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))\\n        );\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n    }\\n\\n    function _getSharedProposalStorage()\\n        internal\\n        pure\\n        returns (SharedProposalStorage storage stor)\\n    {\\n        uint256 s = SHARED_STORAGE_SLOT;\\n        assembly {\\n            stor.slot := s\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\n\\n/// @notice A registry of custom metadata providers for Party Cards.\\ncontract MetadataRegistry is Multicall {\\n    event ProviderSet(address indexed instance, IMetadataProvider indexed provider);\\n    event RegistrarSet(address indexed registrar, address indexed instance, bool canSetData);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Get the metadata provider for a Party instance.\\n    mapping(address instance => IMetadataProvider provider) public getProvider;\\n\\n    /// @notice Whether or not an address is a registar that can set the\\n    ///         provider and metadata for another instance. If registrar is set\\n    ///         true for `address(1)`, the address is a universal registar and\\n    ///         can set data for any instance.\\n    /// @dev Registrars' ability to set metadata for another instance must also be\\n    ///      supported by the metadata provider used by that instance, indicated by\\n    ///      `IMetadataProvider.supportsRegistrars()`.\\n    mapping(address registrar => mapping(address instance => bool canSetData)) private _isRegistrar;\\n\\n    /// @param globals The address of the `Globals` contract.\\n    /// @param registrars The addresses of the initial universal registrars.\\n    constructor(IGlobals globals, address[] memory registrars) {\\n        _GLOBALS = globals;\\n\\n        // Set the initial universal registrars.\\n        for (uint256 i = 0; i < registrars.length; i++) {\\n            _isRegistrar[registrars[i]][address(1)] = true;\\n        }\\n    }\\n\\n    /// @notice Set the metadata provider for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param provider The address of the metadata provider.\\n    function setProvider(address instance, IMetadataProvider provider) external {\\n        // Check if the caller is authorized to set the provider for the instance.\\n        if (!isRegistrar(msg.sender, instance)) revert NotAuthorized(msg.sender, instance);\\n\\n        getProvider[instance] = provider;\\n\\n        emit ProviderSet(instance, provider);\\n    }\\n\\n    /// @notice Set whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @param canSetData Whether or not the address can set data for the instance.\\n    function setRegistrar(address registrar, address instance, bool canSetData) external {\\n        if (\\n            msg.sender != instance &&\\n            msg.sender != _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET)\\n        ) {\\n            revert NotAuthorized(msg.sender, instance);\\n        }\\n\\n        _isRegistrar[registrar][instance] = canSetData;\\n\\n        emit RegistrarSet(registrar, instance, canSetData);\\n    }\\n\\n    /// @notice Get whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @return canSetData Whether or not the address can set data for the instance.\\n    function isRegistrar(address registrar, address instance) public view returns (bool) {\\n        return\\n            registrar == instance ||\\n            _isRegistrar[registrar][address(1)] ||\\n            _isRegistrar[registrar][instance];\\n    }\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(address instance, uint256 tokenId) external view returns (bytes memory) {\\n        IMetadataProvider provider = getProvider[instance];\\n\\n        return\\n            address(provider) != address(0) ? provider.getMetadata(instance, tokenId) : bytes(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IMetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\ninterface IMetadataProvider {\\n    /// @notice Whether or not the metadata provider supports registrars that can\\n    ///         set metadata for other instances.\\n    /// @dev See `MetadataRegistry` for more information on the registrar role.\\n    function supportsRegistrars() external view returns (bool);\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(\\n        address instance,\\n        uint256 tokenId\\n    ) external view returns (bytes memory metadata);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\\n// Only modified to inherit IERC1155 and rename ERC1155TokenReceiver -> ERC1155TokenReceiverBase.\\npragma solidity ^0.8;\\n\\nimport \\\"../../tokens/IERC1155.sol\\\";\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 is IERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) public view virtual returns (uint256[] memory balances) {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    address(0),\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiverBase {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC1155 interface.\\ninterface IERC1155 {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory balances);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {\r\n      \"contracts/utils/LibRenderer.sol\": {\r\n        \"LibRenderer\": \"0x0EC569Ed2E3D2a61562Ae76539A84b1948F0c7a6\"\r\n      }\r\n    },\r\n    \"viaIR\": true\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IGlobals\",\"name\":\"globals\",\"type\":\"address\"},{\"internalType\":\"contract RendererStorage\",\"name\":\"rendererStorage\",\"type\":\"address\"},{\"internalType\":\"contract IFont\",\"name\":\"font\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidTokenIdError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"partyName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contributionAmount\",\"type\":\"string\"},{\"internalType\":\"enum CrowdfundNFTRenderer.CrowdfundStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum Color\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isDarkMode\",\"type\":\"bool\"}],\"name\":\"generateSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrowdfundNFTRenderer", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001ca20040ce6ad406bc2a6c89976388829e7fbade0000000000000000000000009a4fe89316bf81a1e4549476b219c456703c3f6200000000000000000000000052010e220e5c8ef2217d86cfa58da51da39e8ec4", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}