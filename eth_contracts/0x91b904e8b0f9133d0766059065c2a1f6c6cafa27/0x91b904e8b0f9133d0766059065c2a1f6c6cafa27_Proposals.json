{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\nimport {CommonErrors} from \\\"./Errors.sol\\\";\\n\\n/// @title Auth\\ncontract Auth {\\n    /// @dev Emitted when the Golem Foundation multisig address is set.\\n    /// @param oldValue The old Golem Foundation multisig address.\\n    /// @param newValue The new Golem Foundation multisig address.\\n    event MultisigSet(address oldValue, address newValue);\\n\\n    /// @dev Emitted when ownership transfer is initiated.\\n    /// @param previousOwner Old multisig, one that initiated the process.\\n    /// @param newOwner New multisig, one that should finalize the process.\\n    event OwnershipTransferStarted(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev The multisig address.\\n    address public multisig;\\n\\n    /// @dev Pending multisig address.\\n    address public pendingOwner;\\n\\n    /// @param _multisig The initial Golem Foundation multisig address.\\n    constructor(address _multisig) {\\n        require(_multisig != address(0), CommonErrors.INVALID_ARGUMENT);\\n        multisig = _multisig;\\n        emit MultisigSet(address(0), multisig);\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external {\\n        require(newOwner != address(0));\\n        require(msg.sender == multisig, CommonErrors.UNAUTHORIZED_CALLER);\\n        pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(multisig, newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        require(msg.sender == pendingOwner, CommonErrors.UNAUTHORIZED_CALLER);\\n        emit MultisigSet(multisig, pendingOwner);\\n        multisig = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\nlibrary DepositsErrors {\\n    /// @notice Thrown when transfer operation fails in GLM smart contract.\\n    /// @return HN:Deposits/cannot-transfer-from-sender\\n    string public constant GLM_TRANSFER_FAILED =\\n        \\\"HN:Deposits/cannot-transfer-from-sender\\\";\\n\\n    /// @notice Thrown when trying to withdraw more GLMs than are in deposit.\\n    /// @return HN:Deposits/deposit-is-smaller\\n    string public constant DEPOSIT_IS_TO_SMALL =\\n        \\\"HN:Deposits/deposit-is-smaller\\\";\\n}\\n\\nlibrary EpochsErrors {\\n    /// @notice Thrown when calling the contract before the first epoch started.\\n    /// @return HN:Epochs/not-started-yet\\n    string public constant NOT_STARTED = \\\"HN:Epochs/not-started-yet\\\";\\n\\n    /// @notice Thrown when getFinalizedEpoch function is called before any epoch has been finalized.\\n    /// @return HN:Epochs/not-finalized\\n    string public constant NOT_FINALIZED = \\\"HN:Epochs/not-finalized\\\";\\n\\n    /// @notice Thrown when getPendingEpoch function is called during closed decision window.\\n    /// @return HN:Epochs/not-pending\\n    string public constant NOT_PENDING = \\\"HN:Epochs/not-pending\\\";\\n\\n    /// @notice Thrown when updating epoch props to invalid values (decision window bigger than epoch duration.\\n    /// @return HN:Epochs/decision-window-bigger-than-duration\\n    string public constant DECISION_WINDOW_TOO_BIG =\\n        \\\"HN:Epochs/decision-window-bigger-than-duration\\\";\\n}\\n\\nlibrary ProposalsErrors {\\n    /// @notice Thrown when trying to change proposals that could already have been voted upon.\\n    /// @return HN:Proposals/only-future-proposals-changing-is-allowed\\n    string public constant CHANGING_PROPOSALS_IN_THE_PAST =\\n        \\\"HN:Proposals/only-future-proposals-changing-is-allowed\\\";\\n\\n    /// @notice Thrown when setting epochs multiple times.\\n    /// @return HN:Proposals/cannot-set-epochs-twice\\n    string public constant CANNOT_SET_EPOCHS_TWICE =\\n        \\\"HN:Proposals/cannot-set-epochs-twice\\\";\\n\\n    /// @notice Thrown when setting proposal with zero address.\\n    /// @return HN:Proposals/invalid-proposal\\n    string public constant INVALID_PROPOSAL = \\\"HN:Proposals/invalid-proposal\\\";\\n}\\n\\nlibrary VaultErrors {\\n    /// @notice Thrown when trying to set merkle root for an epoch multiple times.\\n    /// @return HN:Vault/merkle-root-already-set\\n    string public constant MERKLE_ROOT_ALREADY_SET =\\n        \\\"HN:Vault/merkle-root-already-set\\\";\\n\\n    /// @notice Thrown when trying to set invalid merkle root.\\n    /// @return HN:Vault/invalid-merkle-root\\n    string public constant INVALID_MERKLE_ROOT = \\\"HN:Vault/invalid-merkle-root\\\";\\n\\n    /// @notice Thrown when trying to withdraw without providing valid merkle proof.\\n    /// @return HN:Vault/invalid-merkle-proof\\n    string public constant INVALID_MERKLE_PROOF =\\n        \\\"HN:Vault/invalid-merkle-proof\\\";\\n\\n    /// @notice Thrown when trying to withdraw multiple times.\\n    /// @return HN:Vault/already-claimed\\n    string public constant ALREADY_CLAIMED = \\\"HN:Vault/already-claimed\\\";\\n\\n    /// @notice Thrown when trying to send empty payload list.\\n    /// @return HN:Vault/empty-payloads\\n    string public constant EMPTY_PAYLOADS = \\\"HN:Vault/empty-payloads\\\";\\n}\\n\\nlibrary CommonErrors {\\n    /// @notice Thrown when trying to call as an unauthorized account.\\n    /// @return HN:Common/unauthorized-caller\\n    string public constant UNAUTHORIZED_CALLER =\\n        \\\"HN:Common/unauthorized-caller\\\";\\n\\n    /// @notice Thrown when failed to send eth.\\n    /// @return HN:Common/failed-to-send\\n    string public constant FAILED_TO_SEND = \\\"HN:Common/failed-to-send\\\";\\n\\n    /// @notice Thrown when invalid argument provided.\\n    /// @return HN:Common/invalid-argument\\n    string public constant INVALID_ARGUMENT = \\\"HN:Common/invalid-argument\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/OctantBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\nimport {CommonErrors} from \\\"./Errors.sol\\\";\\nimport \\\"./Auth.sol\\\";\\n\\n/// @title OctantBase\\n/// @dev This is the base contract for all Octant contracts that have functions with access restricted\\n/// to deployer or the Golem Foundation multisig.\\n/// It provides functionality for setting and accessing the Golem Foundation multisig address.\\nabstract contract OctantBase {\\n    /// @dev The Auth contract instance\\n    Auth public immutable auth;\\n\\n    /// @param _auth the contract containing Octant authorities.\\n    constructor(address _auth) {\\n        require(_auth != address(0), CommonErrors.INVALID_ARGUMENT);\\n        auth = Auth(_auth);\\n    }\\n\\n    /// @dev Gets the Golem Foundation multisig address.\\n    function getMultisig() internal view returns (address) {\\n        return auth.multisig();\\n    }\\n\\n    /// @dev Modifier that allows only the Golem Foundation multisig address to call a function.\\n    modifier onlyMultisig() {\\n        require(\\n            msg.sender == auth.multisig(),\\n            CommonErrors.UNAUTHORIZED_CALLER\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Proposals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./interfaces/IProposals.sol\\\";\\nimport \\\"./interfaces/IEpochs.sol\\\";\\n\\nimport {ProposalsErrors} from \\\"./Errors.sol\\\";\\nimport \\\"./OctantBase.sol\\\";\\n\\n/// @notice Contract tracking active Octant proposals in particular epoch.\\n/// Proposals are stored in IPFS in JSON format and are maintained entirely by Golem Foundation.\\n/// In order to get proposal details from IPFS call use returned values as this:\\n/// https://<IPFS Gateway of your choice>/ipfs/<CID>/<Proposal address>\\n// example: https://ipfs.io/ipfs/Qmbm97crHWQzNYNn2LPZ5hhGu4qEv1DXRP6qS4TCehruPn/1\\ncontract Proposals is OctantBase, IProposals {\\n    /// @notice IPFS CID (Content identifier).\\n    /// Under this CID will be placed a directory with all the proposals,\\n    /// currently active and inactive.\\n    string public cid;\\n\\n    /// @notice Epochs contract address.\\n    /// If not set, than Octant is in \\\"pre-historical\\\" phase (epochs zero and one).\\n    IEpochs public epochs;\\n\\n    mapping(uint256 => address[]) private proposalAddressesByEpoch;\\n\\n    /// @notice This event is emitted when Epochs contract is deployed and Proposals is notified about it.\\n    event EpochsSet(address epochs);\\n\\n    constructor(\\n        string memory _initCID,\\n        address[] memory proposals,\\n        address _auth\\n    ) OctantBase(_auth) {\\n        cid = _initCID;\\n\\n        require(\\n            _areEpochProposalsValid(proposals),\\n            ProposalsErrors.INVALID_PROPOSAL\\n        );\\n        proposalAddressesByEpoch[0] = proposals;\\n    }\\n\\n    /// @notice sets a new IPFS CID, where proposals are stored.\\n    function setCID(string memory _newCID) external onlyMultisig {\\n        cid = _newCID;\\n    }\\n\\n    /// @notice Sets epochs contract, can be done only once.\\n    function setEpochs(address _epochs) external onlyMultisig {\\n        require(\\n            address(epochs) == address(0x0),\\n            ProposalsErrors.CANNOT_SET_EPOCHS_TWICE\\n        );\\n        epochs = IEpochs(_epochs);\\n        emit EpochsSet(_epochs);\\n    }\\n\\n    /// @notice sets proposal addresses that will be active in the particular epoch.\\n    /// Addresses should be provided as an array and will represent JSON file names stored under CID provided\\n    /// to this contract.\\n    function setProposalAddresses(\\n        uint256 _epoch,\\n        address[] calldata _proposalAddresses\\n    ) external onlyMultisig {\\n        if (address(epochs) != address(0x0)) {\\n            require(\\n                _epoch >= epochs.getCurrentEpoch(),\\n                ProposalsErrors.CHANGING_PROPOSALS_IN_THE_PAST\\n            );\\n        }\\n        require(\\n            _areEpochProposalsValid(_proposalAddresses),\\n            ProposalsErrors.INVALID_PROPOSAL\\n        );\\n        proposalAddressesByEpoch[_epoch] = _proposalAddresses;\\n    }\\n\\n    /// @return list of active proposal addresses in given epoch.\\n    function getProposalAddresses(\\n        uint256 _epoch\\n    ) external view returns (address[] memory) {\\n        for (uint256 iEpoch = _epoch; iEpoch > 0; iEpoch = iEpoch - 1) {\\n            if (proposalAddressesByEpoch[iEpoch].length > 0) {\\n                return proposalAddressesByEpoch[iEpoch];\\n            }\\n        }\\n        return proposalAddressesByEpoch[0];\\n    }\\n\\n    function _areEpochProposalsValid(\\n        address[] memory _proposals\\n    ) private pure returns (bool) {\\n        for (uint256 i = 0; i < _proposals.length; i++) {\\n            if (_proposals[i] == address(0)) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEpochs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\n/// @notice Interface that provides information about epochs\\ninterface IEpochs {\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    function getFinalizedEpoch() external view returns (uint256);\\n\\n    function getPendingEpoch() external view returns (uint256);\\n\\n    function getEpochDuration() external view returns (uint256);\\n\\n    function getDecisionWindow() external view returns (uint256);\\n\\n    function isStarted() external view returns (bool);\\n\\n    function isDecisionWindowOpen() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.18;\\n\\ninterface IProposals {\\n    function getProposalAddresses(\\n        uint256 _epoch\\n    ) external view returns (address[] memory);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_initCID\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"proposals\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_auth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"epochs\",\"type\":\"address\"}],\"name\":\"EpochsSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"contract Auth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cid\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"contract IEpochs\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"getProposalAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newCID\",\"type\":\"string\"}],\"name\":\"setCID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_epochs\",\"type\":\"address\"}],\"name\":\"setEpochs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_proposalAddresses\",\"type\":\"address[]\"}],\"name\":\"setProposalAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Proposals", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000287493f76b8a1833e9e0bf2de0d972fb16c6c8ae000000000000000000000000000000000000000000000000000000000000002e516d61736144424b50724d5454716d4a5943345455756572376d5a7a4a315a436e7a4377364d78667633367a386e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000de4b13153673bcae2616b67bf822500d325fc30000000000000000000000001c01595f9534e33d411035ae99a4317faec4f6fe00000000000000000000000002cb3c150bedca124d0ae8cccb72fefbe705c9530000000000000000000000006e8873085530406995170da467010565968c7c620000000000000000000000007dac9fc15c1db4379d75a6e3f330ae849dffce18000000000000000000000000ab6d6a37c5110d1377832c451c33e4fa16a9ba05000000000000000000000000cc7d34c76a9d08aa0109f7bae35f29c1ce35355a000000000000000000000000d165df4296c85e780509fa1eace0150d945d49fd000000000000000000000000de21f729137c5af1b01d73af1dc21effa2b8a0d6000000000000000000000000f6cbdd6ea6ec3c4359e33de0ac823701cc56c6c4", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}