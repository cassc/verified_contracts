{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/src/lib/OwnableImplement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.26;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract OwnableImplement is Context {\\n    address internal _owner;\\n    address internal _implementation;\\n    address public ownerNominee;\\n\\n    event OwnerNominated(address indexed potentialOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() external virtual onlyOwner {\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address nominee) external onlyOwner {\\n        require(nominee != address(0), \\\"!zero_address\\\");\\n        ownerNominee = nominee;\\n        emit OwnerNominated(nominee);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == ownerNominee, \\\"!nominated\\\");\\n        _acceptOwnership();\\n    }\\n\\n    function _acceptOwnership() internal virtual {\\n        address oldOwner = _owner;\\n        _owner = ownerNominee;\\n        ownerNominee = address(0);\\n        emit OwnershipTransferred(oldOwner, _owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./lib//OwnableImplement.sol\\\";\\n\\n/**\\n * @title Proxy\\n * @author naomsa <https://twitter.com/naomsa666>\\n * @notice An upgradable proxy util for function delegation following EIP-897.\\n * @dev The implementaion MUST reserve the first two storage slots to the\\n * `_owner` address and the `_implementation` address.\\n */\\ncontract Proxy is OwnableImplement {\\n\\n    /// @notice Emitted when a new implementation is set.\\n    event Upgraded(address indexed from, address indexed to);\\n\\n    constructor() {}\\n\\n    function implementation() public view returns (address) {\\n        return _implementation;\\n    }\\n\\n    /// @notice Set the new implementation.\\n    function setImplementation(address newImplementation) public onlyOwner {\\n        require(\\n            newImplementation != address(0),\\n            \\\"Proxy: upgrading to the zero address\\\"\\n        );\\n        require(\\n            newImplementation != _implementation,\\n            \\\"Proxy: upgrading to the current implementation\\\"\\n        );\\n\\n        address oldImplementation = _implementation;\\n        _implementation = newImplementation;\\n\\n        emit Upgraded(oldImplementation, newImplementation);\\n    }\\n\\n    function setImplementation(\\n        address newImplementation,\\n        bytes memory data\\n    ) public onlyOwner {\\n        require(\\n            newImplementation != address(0),\\n            \\\"Proxy: upgrading to the zero address\\\"\\n        );\\n        require(\\n            newImplementation != _implementation,\\n            \\\"Proxy: upgrading to the current implementation\\\"\\n        );\\n\\n        address oldImplementation = _implementation;\\n        _implementation = newImplementation;\\n\\n        (bool success, bytes memory returndata) = newImplementation\\n            .delegatecall(data);\\n        verifyCallResult(success, returndata, \\\"Implementation call failed\\\");\\n\\n        emit Upgraded(oldImplementation, newImplementation);\\n    }\\n\\n    /// @notice See {EIP897-proxyType}.\\n    function proxyType() external pure returns (uint256) {\\n        return 2;\\n    }\\n\\n    /**\\n     * @notice Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable {\\n        _delegate(_implementation);\\n    }\\n\\n    /**\\n     * @notice Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    receive() external payable {\\n        _delegate(_implementation);\\n    }\\n\\n    /// @notice Delegate the current call to `newImplementation`.\\n    function _delegate(address newImplementation) internal {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(\\n                gas(),\\n                newImplementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function _checkOwner() internal view {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"potentialOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerNominee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominee\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "2", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}