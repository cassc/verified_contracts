{"SourceCode": "# @version 0.3.10\r\n\r\n\"\"\"\r\n@title Zharta Renting Contract\r\n@author [Zharta](https://zharta.io/)\r\n@notice This contract manages the renting process for NFTs in the LOTM Renting Protocol.\r\n@dev This contract is the single user-facing contract for each Renting Market. It does not hold any NFTs, although it holds the rentals values and the protocol fees (payment tokens). It also manages the creation of vaults (as minimal proxies to the vault implementation) and implements the rental logic. The delegation and staking functionality are implemented in the vaults.\r\nThe information regarding listings and rentals was externalized in order to reduce the gas costs while using the protocol. That requires the state to be passed as an argument to each function and validated by matching its hash against the one stored in the contract. Conversly, changes to the state are hashed and stored, and the resulting state variables are either published as events or returned directly to the user.\r\nThe information that hold the state (`TokenContext`) consist of the token id, the owner of the NFT and the active rental (`Rental`), which are required to keep the integrity of the contract.\r\nThe listings (`SignedListing`) are required arguments for the relevant functions and must be signed by both the owner (EIP-712 type 3) and the protocol admin (EIP-712 type 0). The signature is validated by the contract and requires the signature timestamp to be within 2 minutes of the current timestamp\r\n\"\"\"\r\n\r\n\r\n# Interfaces\r\n\r\nfrom vyper.interfaces import ERC20 as IERC20\r\nfrom vyper.interfaces import ERC721 as IERC721\r\n\r\ninterface IVault:\r\n    def initialise(): nonpayable\r\n    def deposit(token_id: uint256, nft_owner: address, delegate: address): nonpayable\r\n    def withdraw(token_id: uint256, wallet: address): nonpayable\r\n    def delegate_to_wallet(delegate: address, expiration: uint256): nonpayable\r\n    def staking_deposit(sender: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4): nonpayable\r\n    def staking_withdraw(wallet: address, amount: uint256, token_id: uint256, staking_addr: address, pool_method_id: bytes4): nonpayable\r\n    def staking_claim(wallet: address, token_id: uint256, staking_addr: address, pool_method_id: bytes4): nonpayable\r\n    def staking_compound(token_id: uint256, staking_addr: address, pool_claim_method_id: bytes4, pool_deposit_method_id: bytes4): nonpayable\r\n\r\n\r\ninterface ERC721Receiver:\r\n    def onERC721Received(_operator: address, _from: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4: view\r\n\r\ninterface RentingERC721:\r\n    def initialise(): nonpayable\r\n    def mint(tokens: DynArray[TokenAndWallet, 32]): nonpayable\r\n    def burn(tokens: DynArray[TokenAndWallet, 32]): nonpayable\r\n    def ownerOf(tokenId: uint256) -> address: view\r\n    def owner_of(tokenId: uint256) -> address: view\r\n\r\n\r\n# Structs\r\n\r\nstruct TokenContext:\r\n    token_id: uint256\r\n    nft_owner: address\r\n    active_rental: Rental\r\n\r\nstruct Rental:\r\n    id: bytes32 # keccak256 of the renter, token_id, start and expiration\r\n    owner: address\r\n    renter: address\r\n    delegate: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n    protocol_fee: uint256\r\n\r\nstruct Listing:\r\n    token_id: uint256\r\n    price: uint256 # price per hour, 0 means not listed\r\n    min_duration: uint256 # min duration in hours\r\n    max_duration: uint256 # max duration in hours, 0 means unlimited\r\n    timestamp: uint256\r\n\r\nstruct Signature:\r\n    v: uint256\r\n    r: uint256\r\n    s: uint256\r\n\r\nstruct SignedListing:\r\n    listing: Listing\r\n    owner_signature: Signature\r\n    admin_signature: Signature\r\n\r\nstruct TokenContextAndListing:\r\n    token_context: TokenContext\r\n    signed_listing: SignedListing\r\n    duration: uint256\r\n\r\nstruct TokenContextAndAmount:\r\n    token_context: TokenContext\r\n    amount: uint256\r\n\r\nstruct RentalLog:\r\n    id: bytes32\r\n    vault: address\r\n    owner: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n    protocol_fee: uint256\r\n\r\nstruct RentalExtensionLog:\r\n    id: bytes32\r\n    vault: address\r\n    owner: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount_settled: uint256\r\n    extension_amount: uint256\r\n    protocol_fee: uint256\r\n\r\n\r\nstruct RewardLog:\r\n    token_id: uint256\r\n    active_rental_amount: uint256\r\n\r\nstruct WithdrawalLog:\r\n    vault: address\r\n    token_id: uint256\r\n\r\nstruct VaultLog:\r\n    vault: address\r\n    token_id: uint256\r\n\r\nstruct StakingLog:\r\n    token_id: uint256\r\n    amount: uint256\r\n\r\nstruct TokenAndWallet:\r\n    token_id: uint256\r\n    wallet: address\r\n\r\n# Events\r\n\r\nevent NftsDeposited:\r\n    owner: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n    delegate: address\r\n\r\nevent NftsWithdrawn:\r\n    owner: address\r\n    nft_contract: address\r\n    total_rewards: uint256\r\n    withdrawals: DynArray[WithdrawalLog, 32]\r\n\r\nevent DelegatedToWallet:\r\n    owner: address\r\n    delegate: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent RenterDelegatedToWallet:\r\n    renter: address\r\n    delegate: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent ListingsRevoked:\r\n    owner: address\r\n    timestamp: uint256\r\n    token_ids: DynArray[uint256, 32]\r\n\r\nevent RentalStarted:\r\n    renter: address\r\n    delegate: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RentalClosed:\r\n    renter: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RentalExtended:\r\n    renter: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalExtensionLog, 32]\r\n\r\nevent RewardsClaimed:\r\n    owner: address\r\n    nft_contract: address\r\n    amount: uint256\r\n    protocol_fee_amount: uint256\r\n    rewards: DynArray[RewardLog, 32]\r\n\r\nevent TokenOwnershipChanged:\r\n    new_owner: address\r\n    nft_contract: address\r\n    tokens: DynArray[uint256, 32]\r\n\r\nevent ProtocolFeeSet:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n    fee_wallet: address\r\n\r\nevent ProtocolWalletChanged:\r\n    old_wallet: address\r\n    new_wallet: address\r\n\r\nevent StakingAddressSet:\r\n    old_value: address\r\n    new_value: address\r\n\r\nevent AdminProposed:\r\n    admin: address\r\n    proposed_admin: address\r\n\r\nevent OwnershipTransferred:\r\n    old_admin: address\r\n    new_admin: address\r\n\r\nevent StakingDeposit:\r\n    owner: address\r\n    nft_contract: address\r\n    tokens: DynArray[StakingLog, 32]\r\n\r\nevent StakingWithdraw:\r\n    owner: address\r\n    nft_contract: address\r\n    recipient: address\r\n    tokens: DynArray[StakingLog, 32]\r\n\r\nevent StakingClaim:\r\n    owner: address\r\n    nft_contract: address\r\n    recipient: address\r\n    tokens: DynArray[uint256, 32]\r\n\r\nevent StakingCompound:\r\n    owner: address\r\n    nft_contract: address\r\n    tokens: DynArray[uint256, 32]\r\n\r\nevent FeesClaimed:\r\n    fee_wallet: address\r\n    amount: uint256\r\n\r\n\r\nevent PauseStateSet:\r\n    old_value: bool\r\n    new_value: bool\r\n\r\n\r\n# Global Variables\r\n\r\nZHARTA_DOMAIN_NAME: constant(String[6]) = \"Zharta\"\r\nZHARTA_DOMAIN_VERSION: constant(String[1]) = \"1\"\r\n\r\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\nLISTING_TYPE_HASH: constant(bytes32) = keccak256(\"Listing(uint256 token_id,uint256 price,uint256 min_duration,uint256 max_duration,uint256 timestamp)\")\r\n\r\n_COLLISION_OFFSET: constant(bytes1) = 0xFF\r\n_DEPLOYMENT_CODE: constant(bytes9) = 0x602D3D8160093D39F3\r\n_PRE: constant(bytes10) = 0x363d3d373d3d3d363d73\r\n_POST: constant(bytes15) = 0x5af43d82803e903d91602b57fd5bf3\r\n\r\nSUPPORTED_INTERFACES: constant(bytes4[2]) = [0x01ffc9a7, 0x80ac58cd] # ERC165, ERC721\r\n\r\nLISTINGS_SIGNATURE_VALID_PERIOD: constant(uint256) = 120\r\n\r\nlisting_sig_domain_separator: immutable(bytes32)\r\nvault_impl_addr: public(immutable(address))\r\npayment_token: public(immutable(IERC20))\r\nnft_contract_addr: public(immutable(address))\r\ndelegation_registry_addr: public(immutable(address))\r\nstaking_addr: public(address)\r\nrenting_erc721: public(immutable(RentingERC721))\r\nmax_protocol_fee: public(immutable(uint256))\r\n\r\nprotocol_wallet: public(address)\r\nprotocol_fee: public(uint256)\r\nprotocol_admin: public(address)\r\nproposed_admin: public(address)\r\n\r\nrental_states: public(HashMap[uint256, bytes32]) # token_id -> hash(token_context)\r\nlisting_revocations: public(HashMap[uint256, uint256]) # token_id -> timestamp\r\n\r\nunclaimed_rewards: public(HashMap[address, uint256]) # wallet -> amount\r\nprotocol_fees_amount: public(uint256)\r\npaused: public(bool)\r\n\r\n##### EXTERNAL METHODS - WRITE #####\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _vault_impl_addr: address,\r\n    _payment_token_addr: address,\r\n    _nft_contract_addr: address,\r\n    _delegation_registry_addr: address,\r\n    _renting_erc721: address,\r\n    _staking_addr: address,\r\n    _max_protocol_fee: uint256,\r\n    _protocol_fee: uint256,\r\n    _protocol_wallet: address,\r\n    _protocol_admin: address\r\n):\r\n    \"\"\"\r\n    @notice Initialize the renting contract with necessary parameters and addresses.\r\n    @dev Sets up the contract by initializing various addresses and fees.\r\n    @param _vault_impl_addr The address of the vault implementation.\r\n    @param _payment_token_addr The address of the payment token.\r\n    @param _nft_contract_addr The address of the NFT contract.\r\n    @param _delegation_registry_addr The address of the delegation registry.\r\n    @param _renting_erc721 The address of the renting ERC721 contract.\r\n    @param _max_protocol_fee The maximum protocol fee that can be set.\r\n    @param _protocol_fee The initial protocol fee.\r\n    @param _protocol_wallet The wallet to receive protocol fees.\r\n    @param _protocol_admin The administrator of the protocol.\r\n    \"\"\"\r\n\r\n    assert _vault_impl_addr != empty(address), \"vault impl is the zero addr\"\r\n    assert _payment_token_addr != empty(address), \"payment token is the zero addr\"\r\n    assert _nft_contract_addr != empty(address), \"nft contract is the zero addr\"\r\n    assert _delegation_registry_addr != empty(address), \"deleg registry is the zero addr\"\r\n    assert _renting_erc721 != empty(address), \"renting_erc721 is the zero addr\"\r\n    assert _max_protocol_fee <= 10000, \"max protocol fee > 100%\"\r\n    assert _protocol_fee <= _max_protocol_fee, \"protocol fee > max fee\"\r\n    assert _protocol_wallet != empty(address), \"protocol wallet not set\"\r\n    assert _protocol_admin != empty(address), \"admin wallet not set\"\r\n\r\n    vault_impl_addr = _vault_impl_addr\r\n    payment_token = IERC20(_payment_token_addr)\r\n    nft_contract_addr = _nft_contract_addr\r\n    delegation_registry_addr = _delegation_registry_addr\r\n    max_protocol_fee = _max_protocol_fee\r\n    renting_erc721 = RentingERC721(_renting_erc721)\r\n\r\n    self.staking_addr = _staking_addr\r\n    self.protocol_wallet = _protocol_wallet\r\n    self.protocol_fee = _protocol_fee\r\n    self.protocol_admin = _protocol_admin\r\n    self.paused = False\r\n\r\n    listing_sig_domain_separator = keccak256(\r\n        _abi_encode(\r\n            DOMAIN_TYPE_HASH,\r\n            keccak256(ZHARTA_DOMAIN_NAME),\r\n            keccak256(ZHARTA_DOMAIN_VERSION),\r\n            chain.id,\r\n            self\r\n        )\r\n    )\r\n\r\n    renting_erc721.initialise()\r\n\r\n\r\n@external\r\ndef delegate_to_wallet(token_contexts: DynArray[TokenContext, 32], delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Delegates multiple NFTs to a wallet while not rented\r\n    @dev Iterates over token contexts to delegate NFTs to a wallet\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param delegate The address to delegate the NFTs to.\r\n    \"\"\"\r\n\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert not self._is_rental_active(token_context.active_rental), \"active rental\"\r\n        assert msg.sender == token_context.nft_owner, \"not owner\"\r\n        vault: IVault = self._get_vault(token_context.token_id)\r\n\r\n        vault.delegate_to_wallet(delegate, max_value(uint256))\r\n\r\n        vault_logs.append(VaultLog({vault: vault.address, token_id: token_context.token_id}))\r\n\r\n    log DelegatedToWallet(msg.sender, delegate, nft_contract_addr, vault_logs)\r\n\r\n\r\n\r\n@external\r\ndef renter_delegate_to_wallet(token_contexts: DynArray[TokenContext, 32], delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Delegates multiple NFTs to a wallet while rented\r\n    @dev Iterates over token contexts to delegate NFTs to a wallet\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param delegate The address to delegate the NFTs to.\r\n    \"\"\"\r\n\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert self._is_rental_active(token_context.active_rental), \"no active rental\"\r\n        assert msg.sender == token_context.active_rental.renter, \"not renter\"\r\n\r\n        vault: IVault = self._get_vault(token_context.token_id)\r\n        vault.delegate_to_wallet(delegate, token_context.active_rental.expiration)\r\n\r\n        self._store_token_state(\r\n            token_context.token_id,\r\n            token_context.nft_owner,\r\n            Rental({\r\n                id: token_context.active_rental.id,\r\n                owner: token_context.active_rental.owner,\r\n                renter: token_context.active_rental.renter,\r\n                delegate: delegate,\r\n                token_id: token_context.active_rental.token_id,\r\n                start: token_context.active_rental.start,\r\n                min_expiration: token_context.active_rental.min_expiration,\r\n                expiration: token_context.active_rental.expiration,\r\n                amount: token_context.active_rental.amount,\r\n                protocol_fee: token_context.active_rental.protocol_fee,\r\n            })\r\n        )\r\n\r\n        vault_logs.append(VaultLog({vault: vault.address, token_id: token_context.token_id}))\r\n\r\n    log RenterDelegatedToWallet(msg.sender, delegate, nft_contract_addr, vault_logs)\r\n\r\n\r\n@external\r\ndef deposit(token_ids: DynArray[uint256, 32], delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Deposits a set of NFTs in vaults (creating them if needed) and sets up delegations\r\n    @dev Iterates over a list of token ids, creating vaults if not needed, transfering the NFTs to the vaults and setting the delegations\r\n    @param token_ids An array of NFT token ids to deposit.\r\n    @param delegate Address to delegate the NFT to while listed.\r\n    \"\"\"\r\n\r\n    self._check_not_paused()\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        assert self.rental_states[token_id] == empty(bytes32), \"invalid state\"\r\n        vault: IVault = self._create_vault(token_id)\r\n        vault.deposit(token_id, msg.sender, delegate)\r\n\r\n        self._store_token_state(token_id, msg.sender, empty(Rental))\r\n\r\n        vault_logs.append(VaultLog({\r\n            vault: vault.address,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log NftsDeposited(msg.sender, nft_contract_addr, vault_logs, delegate)\r\n\r\n\r\n@external\r\ndef mint(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Mints ERC721 renting tokens for a set of NFTs\r\n    @dev Iterates over a list of token contexts, creating ERC721 renting tokens with matching ids for each NFT\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    \"\"\"\r\n\r\n    tokens: DynArray[TokenAndWallet, 32] = empty(DynArray[TokenAndWallet, 32])\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n\r\n        tokens.append(TokenAndWallet({\r\n            token_id: token_context.token_id,\r\n            wallet: token_context.nft_owner\r\n        }))\r\n\r\n    renting_erc721.mint(tokens)\r\n\r\n\r\n@external\r\ndef revoke_listing(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Revokes any existing listings for a set of NFTs\r\n    @dev Iterates over a list of token contexts, revoking listings for each NFT created before the current block timestamp\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    \"\"\"\r\n\r\n    token_ids: DynArray[uint256, 32] = empty(DynArray[uint256, 32])\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert token_context.nft_owner == msg.sender, \"not owner\"\r\n        self.listing_revocations[token_context.token_id] = block.timestamp\r\n        token_ids.append(token_context.token_id)\r\n    log ListingsRevoked(msg.sender, block.timestamp, token_ids)\r\n\r\n\r\n@external\r\ndef start_rentals(token_contexts: DynArray[TokenContextAndListing, 32], delegate: address, signature_timestamp: uint256):\r\n\r\n    \"\"\"\r\n    @notice Start rentals for multiple NFTs for the specified duration and delegate them to a wallet\r\n    @dev Iterates over token contexts to begin rentals for each NFT. The rental conditions are evaluated against the matching listing, signed by the owner and the protocol admin. The rental amount is computed and transferred to the protocol wallet and the delegation is created for the given wallet.\r\n    @param token_contexts An array of token contexts, each containing the rental state and signed listing for an NFT.\r\n    @param delegate The address to delegate the NFT to during the rental period.\r\n    @param signature_timestamp The timestamp of the protocol admin signature.\r\n    \"\"\"\r\n\r\n    self._check_not_paused()\r\n\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n    rental_amounts: uint256 = 0\r\n\r\n    for context in token_contexts:\r\n        rental_amounts += self._compute_rental_amount(block.timestamp, block.timestamp + context.duration * 3600, context.signed_listing.listing.price)\r\n\r\n    self._receive_payment_token(msg.sender, rental_amounts)\r\n\r\n    for context in token_contexts:\r\n        vault: IVault = self._get_vault(context.token_context.token_id)\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n        assert not self._is_rental_active(context.token_context.active_rental), \"active rental\"\r\n        assert self._is_within_duration_range(context.signed_listing.listing, context.duration), \"duration not respected\"\r\n        assert context.signed_listing.listing.price > 0, \"listing not active\"\r\n        self._check_valid_listing(context.token_context.token_id, context.signed_listing, signature_timestamp, context.token_context.nft_owner)\r\n\r\n        expiration: uint256 = block.timestamp + context.duration * 3600\r\n        vault.delegate_to_wallet(delegate if delegate != empty(address) else msg.sender, expiration)\r\n\r\n        # store unclaimed rewards\r\n        self._consolidate_claims(context.token_context.token_id, context.token_context.nft_owner, context.token_context.active_rental)\r\n\r\n        # create rental\r\n        rental_id: bytes32 = self._compute_rental_id(msg.sender, context.token_context.token_id, block.timestamp, expiration)\r\n\r\n        new_rental: Rental = Rental({\r\n            id: rental_id,\r\n            owner: context.token_context.nft_owner,\r\n            renter: msg.sender,\r\n            delegate: delegate,\r\n            token_id: context.token_context.token_id,\r\n            start: block.timestamp,\r\n            min_expiration: block.timestamp + context.signed_listing.listing.min_duration * 3600,\r\n            expiration: expiration,\r\n            amount: self._compute_rental_amount(block.timestamp, expiration, context.signed_listing.listing.price),\r\n            protocol_fee: self.protocol_fee,\r\n        })\r\n\r\n        self._store_token_state(context.token_context.token_id, context.token_context.nft_owner, new_rental)\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: rental_id,\r\n            vault: vault.address,\r\n            owner: context.token_context.nft_owner,\r\n            token_id: context.token_context.token_id,\r\n            start: block.timestamp,\r\n            min_expiration: new_rental.min_expiration,\r\n            expiration: expiration,\r\n            amount: new_rental.amount,\r\n            protocol_fee: new_rental.protocol_fee,\r\n        }))\r\n\r\n    log RentalStarted(msg.sender, delegate, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef close_rentals(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Close rentals for multiple NFTs and claim rewards\r\n    @dev Iterates over token contexts to close rentals for each NFT. The new rental amount is computed pro-rata (considering the minimum duration) and any payback amount transferred to the renter. The protocol fee is computed and accrued and the delegation is revoked.\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    \"\"\"\r\n\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n    protocol_fees_amount: uint256 = 0\r\n    payback_amounts: uint256 = 0\r\n\r\n    for token_context in token_contexts:\r\n        vault: IVault = self._get_vault(token_context.token_id)\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert self._is_rental_active(token_context.active_rental), \"active rental does not exist\"\r\n        assert msg.sender == token_context.active_rental.renter, \"not renter of active rental\"\r\n\r\n        real_expiration_adjusted: uint256 = block.timestamp\r\n        if block.timestamp < token_context.active_rental.min_expiration:\r\n            real_expiration_adjusted = token_context.active_rental.min_expiration\r\n\r\n        pro_rata_rental_amount: uint256 = self._compute_real_rental_amount(\r\n            token_context.active_rental.expiration - token_context.active_rental.start,\r\n            real_expiration_adjusted - token_context.active_rental.start,\r\n            token_context.active_rental.amount\r\n        )\r\n        payback_amount: uint256 = token_context.active_rental.amount - pro_rata_rental_amount\r\n        payback_amounts += payback_amount\r\n\r\n        protocol_fee_amount: uint256 = pro_rata_rental_amount * token_context.active_rental.protocol_fee / 10000\r\n        protocol_fees_amount += protocol_fee_amount\r\n\r\n        # clear active rental\r\n        self._store_token_state(token_context.token_id, token_context.nft_owner, empty(Rental))\r\n\r\n        # set unclaimed rewards\r\n        self.unclaimed_rewards[token_context.nft_owner] += pro_rata_rental_amount - protocol_fee_amount\r\n\r\n        # revoke delegation\r\n        vault.delegate_to_wallet(empty(address), 0)\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: token_context.active_rental.id,\r\n            vault: vault.address,\r\n            owner: token_context.active_rental.owner,\r\n            token_id: token_context.active_rental.token_id,\r\n            start: token_context.active_rental.start,\r\n            min_expiration: token_context.active_rental.min_expiration,\r\n            expiration: block.timestamp,\r\n            amount: pro_rata_rental_amount,\r\n            protocol_fee: token_context.active_rental.protocol_fee,\r\n        }))\r\n\r\n    assert payment_token.transfer(msg.sender, payback_amounts), \"transfer failed\"\r\n\r\n    if protocol_fees_amount > 0:\r\n        self.protocol_fees_amount += protocol_fees_amount\r\n\r\n    log RentalClosed(msg.sender, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef extend_rentals(token_contexts: DynArray[TokenContextAndListing, 32], signature_timestamp: uint256):\r\n\r\n    \"\"\"\r\n    @notice Extend rentals for multiple NFTs for the specified duration\r\n    @dev Iterates over token contexts to extend rentals for each NFT. The rental amount is computed pro-rata (considering the minimum duration) and the new rental amount is computed. The difference between the new rental amount and the payback amount is transferred from / to the renter and the new rental protocol fee is computed and accrued.\r\n    @param token_contexts An array of token contexts, each containing the rental state and signed listing for an NFT.\r\n    @param signature_timestamp The timestamp of the protocol admin signature.\r\n    \"\"\"\r\n\r\n    rental_logs: DynArray[RentalExtensionLog, 32] = []\r\n    protocol_fees_amount: uint256 = 0\r\n    payback_amounts: uint256 = 0\r\n    extension_amounts: uint256 = 0\r\n\r\n    for context in token_contexts:\r\n        vault: IVault = self._get_vault(context.token_context.token_id)\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n        assert self._is_rental_active(context.token_context.active_rental), \"no active rental\"\r\n        assert msg.sender == context.token_context.active_rental.renter, \"not renter of active rental\"\r\n\r\n        assert self._is_within_duration_range(context.signed_listing.listing, context.duration), \"duration not respected\"\r\n        assert context.signed_listing.listing.price > 0, \"listing not active\"\r\n        self._check_valid_listing(context.token_context.token_id, context.signed_listing, signature_timestamp, context.token_context.nft_owner)\r\n\r\n        expiration: uint256 = block.timestamp + context.duration * 3600\r\n        real_expiration_adjusted: uint256 = block.timestamp\r\n        if block.timestamp < context.token_context.active_rental.min_expiration:\r\n            real_expiration_adjusted = context.token_context.active_rental.min_expiration\r\n\r\n        pro_rata_rental_amount: uint256 = self._compute_real_rental_amount(\r\n            context.token_context.active_rental.expiration - context.token_context.active_rental.start,\r\n            real_expiration_adjusted - context.token_context.active_rental.start,\r\n            context.token_context.active_rental.amount\r\n        )\r\n        new_rental_amount: uint256 = self._compute_rental_amount(block.timestamp, expiration, context.signed_listing.listing.price)\r\n        extension_amounts += new_rental_amount\r\n\r\n        payback_amount: uint256 = context.token_context.active_rental.amount - pro_rata_rental_amount\r\n        payback_amounts += payback_amount\r\n\r\n        protocol_fee_amount: uint256 = pro_rata_rental_amount * context.token_context.active_rental.protocol_fee / 10000\r\n        protocol_fees_amount += protocol_fee_amount\r\n\r\n        new_rental: Rental = Rental({\r\n            id: context.token_context.active_rental.id,\r\n            owner: context.token_context.nft_owner,\r\n            renter: msg.sender,\r\n            delegate: context.token_context.active_rental.delegate,\r\n            token_id: context.token_context.token_id,\r\n            start: block.timestamp,\r\n            min_expiration: block.timestamp + context.signed_listing.listing.min_duration * 3600,\r\n            expiration: expiration,\r\n            amount: new_rental_amount,\r\n            protocol_fee: self.protocol_fee,\r\n        })\r\n        # clear active rental\r\n        self._store_token_state(context.token_context.token_id, context.token_context.nft_owner, new_rental)\r\n\r\n        # set unclaimed rewards\r\n        self.unclaimed_rewards[context.token_context.nft_owner] += pro_rata_rental_amount - protocol_fee_amount\r\n\r\n        rental_logs.append(RentalExtensionLog({\r\n            id: context.token_context.active_rental.id,\r\n            vault: vault.address,\r\n            owner: context.token_context.active_rental.owner,\r\n            token_id: context.token_context.active_rental.token_id,\r\n            start: block.timestamp,\r\n            min_expiration: block.timestamp + context.signed_listing.listing.min_duration * 3600,\r\n            expiration: expiration,\r\n            amount_settled: pro_rata_rental_amount,\r\n            extension_amount: new_rental_amount,\r\n            protocol_fee: context.token_context.active_rental.protocol_fee,\r\n        }))\r\n\r\n    if payback_amounts > extension_amounts:\r\n        self._transfer_payment_token(msg.sender, payback_amounts - extension_amounts)\r\n    elif payback_amounts < extension_amounts:\r\n        self._receive_payment_token(msg.sender, extension_amounts - payback_amounts)\r\n\r\n    if protocol_fees_amount > 0:\r\n        self.protocol_fees_amount += protocol_fees_amount\r\n\r\n    log RentalExtended(msg.sender, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef withdraw(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Withdraw multiple NFTs and claim rewards\r\n    @dev Iterates over token contexts to withdraw NFTs from their vaults and claim any unclaimed rewards, while also burning the matching ERC721 renting token.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    \"\"\"\r\n\r\n\r\n    withdrawal_log: DynArray[WithdrawalLog, 32] = empty(DynArray[WithdrawalLog, 32])\r\n    tokens: DynArray[TokenAndWallet, 32] = empty(DynArray[TokenAndWallet, 32])\r\n    total_rewards: uint256 = 0\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert not self._is_rental_active(token_context.active_rental), \"active rental\"\r\n        token_owner: address = renting_erc721.owner_of(token_context.token_id)\r\n        if token_owner != empty(address):\r\n            assert msg.sender == token_owner, \"not owner\"\r\n        else:\r\n            assert msg.sender == token_context.nft_owner, \"not owner\"\r\n\r\n        vault: IVault = self._get_vault(token_context.token_id)\r\n\r\n        self._consolidate_claims(token_context.token_id, token_context.nft_owner, token_context.active_rental, False)\r\n\r\n        self._clear_token_state(token_context.token_id)\r\n\r\n        tokens.append(TokenAndWallet({\r\n            token_id: token_context.token_id,\r\n            wallet: token_context.nft_owner\r\n        }))\r\n\r\n        vault.withdraw(token_context.token_id, msg.sender)\r\n        self.listing_revocations[token_context.token_id] = block.timestamp\r\n\r\n        withdrawal_log.append(WithdrawalLog({\r\n            vault: vault.address,\r\n            token_id: token_context.token_id,\r\n        }))\r\n\r\n    renting_erc721.burn(tokens)\r\n\r\n    rewards_to_claim: uint256 = self.unclaimed_rewards[msg.sender]\r\n\r\n    # transfer reward to nft owner\r\n    if rewards_to_claim > 0:\r\n        self.unclaimed_rewards[msg.sender] = 0\r\n        self._transfer_payment_token(msg.sender, rewards_to_claim)\r\n\r\n    log NftsWithdrawn(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        rewards_to_claim,\r\n        withdrawal_log\r\n    )\r\n\r\n\r\n@external\r\ndef stake_deposit(token_contexts: DynArray[TokenContextAndAmount, 32], pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Deposit the given amounts for multiple NFTs in the configured staking pool\r\n    @dev Iterates over token contexts to deposit the given amounts for each NFT in the staking pool\r\n    @param token_contexts An array of token contexts paired with amounts, each containing the rental state for an NFT.\r\n    @param pool_method_id The method id to call on the staking pool to deposit the given amounts.\r\n    \"\"\"\r\n\r\n    self._check_not_paused()\r\n    staking_addr: address = self.staking_addr\r\n    assert staking_addr != empty(address), \"staking not supported\"\r\n\r\n    staking_log: DynArray[StakingLog, 32] = empty(DynArray[StakingLog, 32])\r\n\r\n    for context in token_contexts:\r\n        assert msg.sender == context.token_context.nft_owner, \"not owner\"\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n\r\n        vault: IVault = self._get_vault(context.token_context.token_id)\r\n        assert payment_token.transferFrom(msg.sender, vault.address, context.amount), \"transferFrom failed\"\r\n        vault.staking_deposit(msg.sender, context.amount, context.token_context.token_id, staking_addr, pool_method_id)\r\n        staking_log.append(StakingLog({\r\n            token_id: context.token_context.token_id,\r\n            amount: context.amount\r\n        }))\r\n\r\n    log StakingDeposit(msg.sender, nft_contract_addr, staking_log)\r\n\r\n\r\n@external\r\ndef stake_withdraw(token_contexts: DynArray[TokenContextAndAmount, 32], recipient: address, pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Withdraw the given amounts for multiple NFTs from the configured staking pool\r\n    @dev Iterates over token contexts to withdraw the given amounts for each NFT from the staking pool\r\n    @param token_contexts An array of token contexts paired with amounts, each containing the rental state for an NFT.\r\n    @param recipient The address to receive the withdrawn amounts.\r\n    @param pool_method_id The method id to call on the staking pool to withdraw the given amounts.\r\n    \"\"\"\r\n\r\n    staking_addr: address = self.staking_addr\r\n    assert staking_addr != empty(address), \"staking not supported\"\r\n\r\n    staking_log: DynArray[StakingLog, 32] = empty(DynArray[StakingLog, 32])\r\n\r\n    for context in token_contexts:\r\n        assert msg.sender == context.token_context.nft_owner, \"not owner\"\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n\r\n        self._get_vault(context.token_context.token_id).staking_withdraw(recipient, context.amount, context.token_context.token_id, staking_addr, pool_method_id)\r\n        staking_log.append(StakingLog({\r\n            token_id: context.token_context.token_id,\r\n            amount: context.amount\r\n        }))\r\n\r\n    log StakingWithdraw(msg.sender, nft_contract_addr, recipient, staking_log)\r\n\r\n\r\n@external\r\ndef stake_claim(token_contexts: DynArray[TokenContextAndAmount, 32], recipient: address, pool_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Claim the rewards for multiple NFTs from the configured staking pool\r\n    @dev Iterates over token contexts to claim the rewards for each NFT from the staking pool\r\n    @param token_contexts An array of token contexts paired with amounts, each containing the rental state for an NFT.\r\n    @param recipient The address to receive the claimed rewards.\r\n    @param pool_method_id The method id to call on the staking pool to claim the rewards.\r\n    \"\"\"\r\n\r\n    staking_addr: address = self.staking_addr\r\n    assert staking_addr != empty(address), \"staking not supported\"\r\n    tokens: DynArray[uint256, 32] = empty(DynArray[uint256, 32])\r\n\r\n    for context in token_contexts:\r\n        assert msg.sender == context.token_context.nft_owner, \"not owner\"\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n        self._get_vault(context.token_context.token_id).staking_claim(recipient, context.token_context.token_id, staking_addr, pool_method_id)\r\n        tokens.append(context.token_context.token_id)\r\n\r\n    log StakingClaim(msg.sender, nft_contract_addr, recipient, tokens)\r\n\r\n\r\n@external\r\ndef stake_compound(token_contexts: DynArray[TokenContextAndAmount, 32], pool_claim_method_id: bytes4, pool_deposit_method_id: bytes4):\r\n\r\n    \"\"\"\r\n    @notice Compound the rewards for multiple NFTs in the configured staking pool\r\n    @dev Iterates over token contexts to compound the rewards for each NFT in the staking pool\r\n    @param token_contexts An array of token contexts paired with amounts, each containing the rental state for an NFT.\r\n    @param pool_claim_method_id The method id to call on the staking pool to claim the rewards.\r\n    @param pool_deposit_method_id The method id to call on the staking pool to deposit the rewards.\r\n    \"\"\"\r\n\r\n    self._check_not_paused()\r\n    staking_addr: address = self.staking_addr\r\n    assert staking_addr != empty(address), \"staking not supported\"\r\n    tokens: DynArray[uint256, 32] = empty(DynArray[uint256, 32])\r\n\r\n    for context in token_contexts:\r\n        assert msg.sender == context.token_context.nft_owner, \"not owner\"\r\n        assert self._is_context_valid(context.token_context), \"invalid context\"\r\n\r\n        self._get_vault(context.token_context.token_id).staking_compound(context.token_context.token_id, staking_addr, pool_claim_method_id, pool_deposit_method_id)\r\n        tokens.append(context.token_context.token_id)\r\n\r\n    log StakingCompound(msg.sender, nft_contract_addr, tokens)\r\n\r\n\r\n@external\r\ndef claim(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Claim the rental rewards for multiple NFTs\r\n    @dev Iterates over token contexts to claim rewards for each expired rental. The rental rewards and any previous unclaimed rewards are transferred to the NFT owner and the protocol fees are accrued.\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    \"\"\"\r\n\r\n    reward_logs: DynArray[RewardLog, 32] = []\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert token_context.nft_owner == msg.sender, \"not owner\"\r\n\r\n        result_active_rental: Rental = self._consolidate_claims(token_context.token_id, token_context.nft_owner, token_context.active_rental)\r\n\r\n        reward_logs.append(RewardLog({\r\n            token_id: token_context.token_id,\r\n            active_rental_amount: result_active_rental.amount\r\n        }))\r\n\r\n    rewards_to_claim: uint256 = self.unclaimed_rewards[msg.sender]\r\n\r\n    # transfer reward to nft owner\r\n    assert rewards_to_claim > 0, \"no rewards to claim\"\r\n    assert payment_token.transfer(msg.sender, rewards_to_claim), \"transfer failed\"\r\n    self.unclaimed_rewards[msg.sender] = 0\r\n\r\n    log RewardsClaimed(msg.sender, nft_contract_addr, rewards_to_claim, self.protocol_fees_amount, reward_logs)\r\n\r\n\r\n@view\r\n@external\r\ndef claimable_rewards(nft_owner: address, token_contexts: DynArray[TokenContext, 32]) -> uint256:\r\n\r\n    \"\"\"\r\n    @notice Compute the claimable rewards for a given NFT owner\r\n    @dev Iterates over token contexts to compute the claimable rewards for each expired rental, wich are then summed up to any previous unclaimed rewards.\r\n    @param nft_owner The address of the NFT owner.\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    @return The claimable rewards for the given NFT owner.\r\n    \"\"\"\r\n\r\n    rewards: uint256 = self.unclaimed_rewards[nft_owner]\r\n    for context in token_contexts:\r\n        assert self._is_context_valid(context), \"invalid context\"\r\n        assert context.nft_owner == nft_owner, \"not owner\"\r\n        if context.active_rental.expiration < block.timestamp:\r\n            rewards += context.active_rental.amount * (10000 - context.active_rental.protocol_fee) / 10000\r\n    return rewards\r\n\r\n\r\n@external\r\ndef claim_token_ownership(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Allow the owner of rental ERC721 tokens to claim the ownership of the underlying NFTs\r\n    @dev Iterates over token contexts to claim the ownership of each NFT. The ownership is transferred to the NFT owner.\r\n    @param token_contexts An array of token contexts, each containing the rental state for an NFT.\r\n    \"\"\"\r\n\r\n    tokens: DynArray[uint256, 32] = empty(DynArray[uint256, 32])\r\n\r\n    for token_context in token_contexts:\r\n        assert self._is_context_valid(token_context), \"invalid context\"\r\n        assert renting_erc721.ownerOf(token_context.token_id) == msg.sender, \"not owner\"\r\n        self._store_token_state(token_context.token_id, msg.sender, token_context.active_rental)\r\n        tokens.append(token_context.token_id)\r\n\r\n    log TokenOwnershipChanged(msg.sender, nft_contract_addr, tokens)\r\n\r\n\r\n@external\r\ndef claim_fees():\r\n\r\n    \"\"\"\r\n    @notice Claim the accrued protocol fees\r\n    @dev Transfers the accrued protocol fees to the protocol wallet and logs the event.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not admin\"\r\n    protocol_fees_amount: uint256 = self.protocol_fees_amount\r\n    self.protocol_fees_amount = 0\r\n    self._transfer_payment_token(self.protocol_wallet, protocol_fees_amount)\r\n    log FeesClaimed(self.protocol_wallet, protocol_fees_amount)\r\n\r\n\r\n@external\r\ndef set_protocol_fee(protocol_fee: uint256):\r\n\r\n    \"\"\"\r\n    @notice Set the protocol fee\r\n    @dev Sets the protocol fee to the given value and logs the event. Admin function.\r\n    @param protocol_fee The new protocol fee.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n    assert protocol_fee <= max_protocol_fee, \"protocol fee > max fee\"\r\n\r\n    log ProtocolFeeSet(self.protocol_fee, protocol_fee, self.protocol_wallet)\r\n    self.protocol_fee = protocol_fee\r\n\r\n\r\n@external\r\ndef change_protocol_wallet(new_protocol_wallet: address):\r\n\r\n    \"\"\"\r\n    @notice Change the protocol wallet\r\n    @dev Changes the protocol wallet to the given address and logs the event. Admin function.\r\n    @param new_protocol_wallet The new protocol wallet.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n    assert new_protocol_wallet != empty(address), \"wallet is the zero address\"\r\n\r\n    log ProtocolWalletChanged(self.protocol_wallet, new_protocol_wallet)\r\n    self.protocol_wallet = new_protocol_wallet\r\n\r\n\r\n@external\r\ndef set_paused(paused: bool):\r\n\r\n    \"\"\"\r\n    @notice Pause or unpause the contract\r\n    @dev Pauses or unpauses the contract and logs the event. Admin function.\r\n    @param paused The new paused state.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n\r\n    log PauseStateSet(self.paused, paused)\r\n\r\n    self.paused = paused\r\n\r\n\r\n@external\r\ndef set_staking_addr(staking_addr: address):\r\n\r\n    \"\"\"\r\n    @notice Set the staking pool address\r\n    @dev Sets the staking pool address to the given value and logs the event. Admin function.\r\n    @param staking_addr The new staking pool address.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n    log StakingAddressSet(self.staking_addr, staking_addr)\r\n    self.staking_addr = staking_addr\r\n\r\n\r\n@external\r\ndef propose_admin(_address: address):\r\n\r\n    \"\"\"\r\n    @notice Propose a new admin\r\n    @dev Proposes a new admin and logs the event. Admin function.\r\n    @param _address The address of the proposed admin.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not the admin\"\r\n    assert _address != empty(address), \"_address is the zero address\"\r\n\r\n    log AdminProposed(self.protocol_admin, _address)\r\n    self.proposed_admin = _address\r\n\r\n\r\n@external\r\ndef claim_ownership():\r\n\r\n    \"\"\"\r\n    @notice Claim the ownership of the contract\r\n    @dev Claims the ownership of the contract and logs the event. Requires the caller to be the proposed admin.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.proposed_admin, \"not the proposed\"\r\n\r\n    log OwnershipTransferred(self.protocol_admin, self.proposed_admin)\r\n    self.protocol_admin = self.proposed_admin\r\n    self.proposed_admin = empty(address)\r\n\r\n\r\n@view\r\n@external\r\ndef tokenid_to_vault(token_id: uint256) -> address:\r\n\r\n    \"\"\"\r\n    @notice Get the vault address for a given token id\r\n    @dev Computes the vault address for the given token id and returns it.\r\n    @param token_id The token id.\r\n    @return The vault address for the given token id.\r\n    \"\"\"\r\n\r\n    return self._tokenid_to_vault(token_id)\r\n\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(interface_id: bytes4) -> bool:\r\n    \"\"\"\r\n    @notice Check if the contract supports the given interface, as defined in ERC-165\r\n    @dev Checks if the contract supports the given interface and returns true if it does.\r\n    @param interface_id The interface id.\r\n    @return True if the contract supports the given interface.\r\n    \"\"\"\r\n    return interface_id in SUPPORTED_INTERFACES\r\n\r\n\r\n@view\r\n@internal\r\ndef _tokenid_to_vault(token_id: uint256) -> address:\r\n    return self._compute_address(\r\n        convert(token_id, bytes32),\r\n        keccak256(concat(\r\n            _DEPLOYMENT_CODE,\r\n            _PRE,\r\n            convert(vault_impl_addr, bytes20),\r\n            _POST\r\n        )),\r\n        self\r\n    )\r\n\r\n\r\n@pure\r\n@internal\r\ndef _state_hash(token_id: uint256, nft_owner: address, rental: Rental) -> bytes32:\r\n    return keccak256(\r\n        concat(\r\n            convert(token_id, bytes32),\r\n            convert(nft_owner, bytes32),\r\n            rental.id,\r\n            convert(rental.owner, bytes32),\r\n            convert(rental.renter, bytes32),\r\n            convert(rental.delegate, bytes32),  #should this be part of state?\r\n            convert(rental.token_id, bytes32),\r\n            convert(rental.start, bytes32),\r\n            convert(rental.min_expiration, bytes32),\r\n            convert(rental.expiration, bytes32),\r\n            convert(rental.amount, bytes32),\r\n            convert(rental.protocol_fee, bytes32),\r\n        )\r\n    )\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_address(salt: bytes32, bytecode_hash: bytes32, deployer: address) -> address:\r\n    data: bytes32 = keccak256(concat(_COLLISION_OFFSET, convert(deployer, bytes20), salt, bytecode_hash))\r\n    return self._convert_keccak256_2_address(data)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _convert_keccak256_2_address(digest: bytes32) -> address:\r\n    return convert(convert(digest, uint256) & convert(max_value(uint160), uint256), address)\r\n\r\n\r\n@view\r\n@internal\r\ndef _is_rental_active(rental: Rental) -> bool:\r\n    return rental.expiration > block.timestamp\r\n\r\n\r\n@view\r\n@internal\r\ndef _is_context_valid(context: TokenContext) -> bool:\r\n    \"\"\" Check if the context is valid, also meaning that the token is deposited \"\"\"\r\n    return self.rental_states[context.token_id] == self._state_hash(context.token_id, context.nft_owner, context.active_rental)\r\n\r\n\r\n@internal\r\ndef _store_token_state(token_id: uint256, nft_owner: address, rental: Rental):\r\n    self.rental_states[token_id] = self._state_hash(token_id, nft_owner, rental)\r\n\r\n\r\n@internal\r\ndef _clear_token_state(token_id: uint256):\r\n    self.rental_states[token_id] = empty(bytes32)\r\n\r\n\r\n@internal\r\ndef _get_vault(token_id: uint256) -> IVault:\r\n    vault: address = self._tokenid_to_vault(token_id)\r\n    assert vault.is_contract, \"no vault exists for token_id\"\r\n    return IVault(vault)\r\n\r\n\r\n@internal\r\ndef _create_vault(token_id: uint256) -> IVault:\r\n    # only creates a vault if needed\r\n    vault: address = self._tokenid_to_vault(token_id)\r\n    if not vault.is_contract:\r\n        vault = create_minimal_proxy_to(vault_impl_addr, salt=convert(token_id, bytes32))\r\n        IVault(vault).initialise()\r\n\r\n    return IVault(vault)\r\n\r\n\r\n@internal\r\ndef _transfer_payment_token(_to: address, _amount: uint256):\r\n    assert payment_token.transfer(_to, _amount), \"transferFrom failed\"\r\n\r\n\r\n@internal\r\ndef _receive_payment_token(_from: address, _amount: uint256):\r\n    assert payment_token.transferFrom(_from, self, _amount), \"transferFrom failed\"\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_rental_id(renter: address, token_id: uint256, start: uint256, expiration: uint256) -> bytes32:\r\n    return keccak256(concat(convert(renter, bytes32), convert(token_id, bytes32), convert(start, bytes32), convert(expiration, bytes32)))\r\n\r\n@pure\r\n@internal\r\ndef _compute_rental_amount(start: uint256, expiration: uint256, price: uint256) -> uint256:\r\n    return (expiration - start) * price / 3600\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_real_rental_amount(duration: uint256, real_duration: uint256, rental_amount: uint256) -> uint256:\r\n    return rental_amount * real_duration / duration\r\n\r\n\r\n@internal\r\ndef _check_not_paused():\r\n    assert not self.paused, \"paused\"\r\n\r\n\r\n@internal\r\ndef _consolidate_claims(token_id: uint256, nft_owner: address, active_rental: Rental, store_state: bool = True) -> Rental:\r\n    if active_rental.amount == 0 or active_rental.expiration >= block.timestamp:\r\n        return active_rental\r\n    else:\r\n        protocol_fee_amount: uint256 = active_rental.amount * active_rental.protocol_fee / 10000\r\n\r\n        self.unclaimed_rewards[active_rental.owner] += active_rental.amount - protocol_fee_amount\r\n        self.protocol_fees_amount += protocol_fee_amount\r\n\r\n        new_rental: Rental = Rental({\r\n            id: active_rental.id,\r\n            owner: active_rental.owner,\r\n            renter: active_rental.renter,\r\n            delegate: active_rental.delegate,\r\n            token_id: token_id,\r\n            start: active_rental.start,\r\n            min_expiration: active_rental.min_expiration,\r\n            expiration: active_rental.expiration,\r\n            amount: 0,\r\n            protocol_fee: active_rental.protocol_fee,\r\n        })\r\n\r\n        if store_state:\r\n            self._store_token_state(token_id, nft_owner, new_rental)\r\n\r\n        return new_rental\r\n\r\n\r\n@internal\r\ndef _check_valid_listing(token_id: uint256, signed_listing: SignedListing, signature_timestamp:uint256, nft_owner: address):\r\n    assert token_id == signed_listing.listing.token_id, \"invalid token_id\"\r\n    assert self._is_listing_signed_by_owner(signed_listing, nft_owner), \"invalid owner signature\"\r\n    assert self._is_listing_signed_by_admin(signed_listing, signature_timestamp), \"invalid admin signature\"\r\n    assert signature_timestamp + LISTINGS_SIGNATURE_VALID_PERIOD > block.timestamp, \"listing expired\"\r\n    assert self.listing_revocations[signed_listing.listing.token_id] < signed_listing.listing.timestamp, \"listing revoked\"\r\n\r\n\r\n@internal\r\ndef _is_within_duration_range(listing: Listing, duration: uint256) -> bool:\r\n    return duration >= listing.min_duration and (listing.max_duration == 0 or duration <= listing.max_duration)\r\n\r\n\r\n@internal\r\ndef _is_listing_signed_by_owner(signed_listing: SignedListing, owner: address) -> bool:\r\n    return ecrecover(\r\n        keccak256(\r\n            concat(\r\n                convert(\"\\x19\\x01\", Bytes[2]),\r\n                _abi_encode(\r\n                    listing_sig_domain_separator,\r\n                    keccak256(_abi_encode(LISTING_TYPE_HASH, signed_listing.listing))\r\n                )\r\n            )\r\n        ),\r\n        signed_listing.owner_signature.v,\r\n        signed_listing.owner_signature.r,\r\n        signed_listing.owner_signature.s\r\n    ) == owner\r\n\r\n\r\n@internal\r\ndef _is_listing_signed_by_admin(signed_listing: SignedListing, signature_timestamp: uint256) -> bool:\r\n    return ecrecover(\r\n        keccak256(\r\n            concat(\r\n                convert(\"\\x19\\x00\", Bytes[2]),\r\n                convert(self, bytes20),\r\n                keccak256(_abi_encode(signed_listing.owner_signature)),\r\n                convert(signature_timestamp, bytes32)\r\n            )\r\n        ),\r\n        signed_listing.admin_signature.v,\r\n        signed_listing.admin_signature.r,\r\n        signed_listing.admin_signature.s\r\n    ) == self.protocol_admin", "ABI": "[{\"name\":\"NftsDeposited\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NftsWithdrawn\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"total_rewards\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DelegatedToWallet\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RenterDelegatedToWallet\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingsRevoked\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"timestamp\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_ids\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalStarted\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalClosed\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalExtended\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount_settled\",\"type\":\"uint256\"},{\"name\":\"extension_amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsClaimed\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"protocol_fee_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rewards\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental_amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenOwnershipChanged\",\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ProtocolFeeSet\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ProtocolWalletChanged\",\"inputs\":[{\"name\":\"old_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StakingAddressSet\",\"inputs\":[{\"name\":\"old_value\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_value\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AdminProposed\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"proposed_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"old_admin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StakingDeposit\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StakingWithdraw\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StakingClaim\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StakingCompound\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"FeesClaimed\",\"inputs\":[{\"name\":\"fee_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PauseStateSet\",\"inputs\":[{\"name\":\"old_value\",\"type\":\"bool\",\"indexed\":false},{\"name\":\"new_value\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_vault_impl_addr\",\"type\":\"address\"},{\"name\":\"_payment_token_addr\",\"type\":\"address\"},{\"name\":\"_nft_contract_addr\",\"type\":\"address\"},{\"name\":\"_delegation_registry_addr\",\"type\":\"address\"},{\"name\":\"_renting_erc721\",\"type\":\"address\"},{\"name\":\"_staking_addr\",\"type\":\"address\"},{\"name\":\"_max_protocol_fee\",\"type\":\"uint256\"},{\"name\":\"_protocol_fee\",\"type\":\"uint256\"},{\"name\":\"_protocol_wallet\",\"type\":\"address\"},{\"name\":\"_protocol_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_to_wallet\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"renter_delegate_to_wallet\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revoke_listing\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_rentals\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"signed_listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}]},{\"name\":\"owner_signature\",\"type\":\"tuple\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]},{\"name\":\"admin_signature\",\"type\":\"tuple\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"duration\",\"type\":\"uint256\"}]},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"signature_timestamp\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"close_rentals\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"extend_rentals\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"signed_listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}]},{\"name\":\"owner_signature\",\"type\":\"tuple\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]},{\"name\":\"admin_signature\",\"type\":\"tuple\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"duration\",\"type\":\"uint256\"}]},{\"name\":\"signature_timestamp\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stake_deposit\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stake_withdraw\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stake_claim\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"pool_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stake_compound\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_context\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"pool_claim_method_id\",\"type\":\"bytes4\"},{\"name\":\"pool_deposit_method_id\",\"type\":\"bytes4\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable_rewards\",\"inputs\":[{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_token_ownership\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"nft_owner\",\"type\":\"address\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_protocol_fee\",\"inputs\":[{\"name\":\"protocol_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_protocol_wallet\",\"inputs\":[{\"name\":\"new_protocol_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_paused\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_staking_addr\",\"inputs\":[{\"name\":\"staking_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"propose_admin\",\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenid_to_vault\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interface_id\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_impl_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payment_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_contract_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_registry_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"staking_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"renting_erc721\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_protocol_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proposed_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rental_states\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"listing_revocations\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"unclaimed_rewards\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_fees_amount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Zharta Renting Contract", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000094fa19545e51ea6f2c12d2c8480af5657f8a30b20000000000000000000000004d224452801aced8b2f0aebe155379bb5d5943810000000000000000000000003bdca51226202fc2a64211aa35a8d95d61c6ca99000000000000000000000000c3aa9bc72bd623168860a1e5c6a4530d3d80456c000000000000000000000000cbe9b03415175d1d410801bad7783f8ac8aba89f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007d96cc26566bfca358c61fbe7be3ca771da7ea6000000000000000000000000314ba3811129ae06fc35894a3bb62157028a9fd9", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}