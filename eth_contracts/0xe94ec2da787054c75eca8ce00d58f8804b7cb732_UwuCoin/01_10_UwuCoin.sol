// SPDX-License-Identifier: MIT

// UWUVERSE is a project for the Crypto Sensei. We believe that AI Waifus are a
// future for friendship & unlocking one’s  full potential. There will be dozens
// of WaifuTools accessible by holding $UWUAI Tokens. Only the heaviest $UWUAI
// whales will unlock secret Waifu Bots in the UWUVERSE (.❛ᴗ❛.)╭
//
// Website: https://uwuverse.com
// Telegram: https://t.me/uwuverse
// Twitter: https://twitter.com/uwuverse_ai

/*
                    ========================================================
                     _   ___        ___   ___     _______ ____  ____  _____
                    | | | \ \      / | | | \ \   / | ____|  _ \/ ___|| ____|
                    | | | |\ \ /\ / /| | | |\ \ / /|  _| | |_) \___ \|  _|
                    | |_| | \ V  V / | |_| | \ V / | |___|  _ < ___) | |___
                     \___/   \_/\_/   \___/   \_/  |_____|_| \_|____/|_____|
                    ========================================================
                    ████████        ████████  ████
                    ██▓▓▒▒▓▓████  ██        ██    ██              ██████████
                    ██▒▒████▓▓▓▓██    ░░    ░░      ██  ██████████▒▒▒▒▓▓▒▒██
                    ██▓▓██░░████  ░░░░░░░░░░░░░░      ██▓▓▓▓▒▒▒▒▒▒▒▒████▒▒██
                      ████░░██  ░░████████████░░░░░░░░  ▓▓▓▓▓▓▓▓████░░██▓▓██
                        ████  ░░▓▓▓▓▓▓▓▓████▓▓▓▓██▓▓░░░░▒▒██▓▓██▒▒▒▒░░██▓▓▓▓
                          ██░░▓▓▒▒▓▓▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓░░░░░░██░░░░  ██▓▓▓▓
                        ██  ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓████░░░░██░░░░██▓▓██
                        ██░░██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓██░░██░░██▓▓██
                          ██▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓██░░██▓▓██
                        ██▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓██░░██████
                        ██▒▒▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓██▓▓▓▓██
                        ██▒▒▒▒▒▒▓▓██▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓██
                        ██▒▒▒▒▒▒▓▓██▒▒▒▒▒▒▓▓▓▓▒▒▒▒▒▒▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓██
                        ██▒▒▒▒▓▓████▒▒▒▒▒▒▓▓██▒▒▒▒▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓██
                          ██████░░░░██▒▒▒▒▓▓██▒▒▒▒▓▓██▒▒▒▒▒▒▓▓▓▓▓▓▓▓██
                        ██▓▓██▓▓▓▓▓▓░░██████░░██████▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓██
                        ██▓▓██  ▒▒▒▒░░░░░░░░▓▓▓▓▓▓▒▒██▒▒▒▒▓▓▓▓▓▓▓▓▓▓██
                        ██▓▓▓▓░░░░░░░░░░░░░░  ▒▒▒▒░░▓▓▒▒▒▒▓▓▓▓▓▓▓▓██
                        ██▒▒██░░          ░░░░░░░░██▒▒▒▒▓▓▓▓▓▓▓▓▓▓██
                        ██▒▒▓▓██    ▓▓░░        ░░██▒▒▒▒▓▓▓▓▓▓▓▓▓▓██
                          ██▒▒██                ██▒▒▒▒▓▓▓▓▓▓▓▓▓▓██
                          ██▒▒██░░    ▒▒▒▒      ░░████▓▓▓▓▓▓▓▓██
                            ██▓▓██    ░░░░    ░░██░░██▒▒▓▓▓▓██
                            ██▒▒▓▓▓▓▓▓      ░░▓▓▒▒▓▓▒▒▒▒████
                          ██  ██▓▓██░░████████░░░░██████
                        ██  ░░░░████  ██░░██    ░░░░██
                      ██    ░░▓▓░░░░████░░░░██    ██░░▓▓██    ██████
                      ██  ▒▒░░▓▓░░▓▓▓▓▓▓██▓▓██▓▓▓▓░░░░░░░░▓▓██░░░░░░██
                    ██  ░░░░▓▓░░▓▓▓▓▓▓██▓▓██▓▓▓▓██░░░░░░░░░░██  ░░░░██
                      ██  ░░██░░██████░░██▓▓▓▓████░░░░  ░░██    ░░░░░░██
                    ██▓▓██░░██░░░░░░░░░░░░██▓▓██░░░░    ░░██  ░░░░████
                  ██▒▒▓▓▓▓██    ░░░░░░░░░░░░████░░░░░░░░░░██  ░░██▓▓▓▓██
                  ██▒▒▓▓██        ░░░░░░░░░░░░░░░░░░░░░░██    ██▓▓▓▓▓▓▓▓██
                ██▒▒▓▓██          ░░██░░██░░    ░░░░██░░██  ░░██▓▓▓▓▓▓▓▓██
              ██▒▒▓▓▓▓██          ░░░░██          ░░██░░██  ██▓▓▓▓▓▓▓▓▓▓▓▓██
              ██▒▒▓▓██░░          ░░██            ░░░░██    ██▓▓▓▓▒▒▓▓▒▒▓▓██
                ██▓▓████░░░░    ░░░░██            ░░░░██  ░░██▓▓▒▒▒▒▒▒▒▒▓▓██
              ██████    ████░░░░░░██              ░░░░██  ░░██▓▓▓▓▒▒▒▒▒▒▓▓▓▓██
            ██░░░░██    ░░░░██▓▓░░██░░          ░░░░░░▓▓  ░░██▓▓▓▓▓▓▓▓▓▓▓▓▓▓██
              ██░░██░░          ██████░░░░░░░░░░██▓▓██▓▓░░░░██▓▓▓▓▓▓▓▓▓▓▓▓██
                ████░░░░        ░░░░  ▓▓▓▓██████░░  ▒▒██░░░░██▓▓▒▒▓▓▓▓▓▓▓▓████
                    ██░░░░░░░░░░░░░░                ░░░░██░░██▓▓▓▓▓▓▓▓▓▓██░░░░██
                    ██░░░░░░░░░░▒▒░░░░            ░░░░░░████▓▓▓▓▓▓██████░░░░████
                      ██░░░░░░░░████░░▒▒░░░░░░░░░░░░░░░░██▓▓██████░░░░░░░░██
                      ░░██████▓▓▓▓▓▓██░░░░░░░░░░░░░░░░██▓▓▓▓██▒▒░░  ▓▓████
                        ██▓▓▓▓▓▓▓▓▓▓▓▓████░░░░░░░░████▓▓▓▓██      ██░░██
                        ██▒▒▓▓▒▒▒▒▒▒▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓████████░░░░██
*/

pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

interface IDexRouter {
	function factory() external pure returns (address);

	function WETH() external pure returns (address);

	function swapExactTokensForETHSupportingFeeOnTransferTokens(
		uint amountIn,
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external;

	function swapExactETHForTokensSupportingFeeOnTransferTokens(
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external payable;

	function swapExactTokensForTokensSupportingFeeOnTransferTokens(
		uint amountIn,
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external;

	function addLiquidityETH(
		address token,
		uint256 amountTokenDesired,
		uint256 amountTokenMin,
		uint256 amountETHMin,
		address to,
		uint256 deadline
	) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);

	function addLiquidity(
		address tokenA,
		address tokenB,
		uint amountADesired,
		uint amountBDesired,
		uint amountAMin,
		uint amountBMin,
		address to,
		uint deadline
	) external returns (uint amountA, uint amountB, uint liquidity);

	function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

	function removeLiquidity(
		address tokenA,
		address tokenB,
		uint liquidity,
		uint amountAMin,
		uint amountBMin,
		address to,
		uint deadline
	) external returns (uint amountA, uint amountB);
}

interface IDexFactory {
	function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface ILpPair {
	function sync() external;
}

/**
 * @dev This is the UWU token.
 */
contract UwuCoin is ERC20, Ownable {
	using SafeMath for uint256;

	uint256 public maxBuyAmt;
	uint256 public maxSellAmt;
	uint256 public maxWalletAmt;

	IDexRouter public immutable dexRouter;

	// @dev - weth
	address public immutable lpPair;

	// @dev - weth
	IERC20Metadata public immutable PAIREDTOKEN;

	bool private swapping;
	uint256 public swapTokensAtAmt;

	address public marketingAndBuybacksAddress;
	address public dogsbody;

	uint256 public tradingLiveBlock = 0; // 0 means trading is not active

	bool public limitsActive = true;
	bool public tradingLive = false;
	bool public swapEnabled = false;

	uint256 public constant FEE_DIVISOR = 10000;

	uint256 public buyTotalTax;

	uint256 public sellTotalTax;

	mapping(address => bool) private _isExcludedFromTax;
	mapping(address => bool) public _isExcludedMaxTransactionAmt;

	mapping(address => bool) public automatedMarketMakerPairs;

	event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
	event StartedTrading(uint ethAmount, uint tokenAmt, uint block);
	event RemovedLimits();
	event ExcludeFromTax(address indexed account, bool isExcluded);
	event UpdatedMaxBuyAmt(uint256 newAmt);
	event UpdatedMaxSellAmt(uint256 newAmt);
	event UpdatedMaxWalletAmt(uint256 newAmt);
	event UpdatedBuyTax(uint256 newAmt);
	event UpdatedSellTax(uint256 newAmt);
	event UpdatedMarketingAndBuybacksAddress(address indexed newWallet);
	event UpdatedDevelopmentAddress(address indexed newWallet);
	event UpdatedLiquidityAddress(address indexed newWallet);
	event MaxTransactionExclusion(address _address, bool excluded);
	event OwnerForcedSwapBack(uint256 timestamp);
	event CaughtEarlyBuyer(address sniper);
	event TransferForeignToken(address token, uint256 amt);

	/**
	 * @dev will use WETH as the lpPair of choice.
	 */
	constructor(address _marketingAddress, address _team1, address _team2) ERC20("Uwuverse.ai", "UWUAI") {
		address _dexRouter;

		if (block.chainid == 1 || block.chainid == 5 || block.chainid == 31337) {
			_dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Ethereum: Uniswap V2
		} else if (block.chainid == 11155111) {
			_dexRouter = 0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008; // Ethereum: Uniswap V2
		} else {
			revert("Chain not configured");
		}

		address newOwner = msg.sender;
		// deployer can still fix things like address but won't be able to do owner things post renounce.
		dogsbody = msg.sender;

		dexRouter = IDexRouter(_dexRouter);
		// paired token is WETH
		PAIREDTOKEN = IERC20Metadata(dexRouter.WETH());
		require(PAIREDTOKEN.decimals() > 0, "Incorrect liquidity token");

		// create pair
		lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), address(PAIREDTOKEN));
		setAutomatedMarketMakerPair(address(lpPair), true);

		// 420,690,000,000,000
		uint256 totalSupply = 420690 * 1e9 * 1e18;

		maxBuyAmt = (totalSupply * 1) / 100;
		maxSellAmt = (totalSupply * 2) / 100;
		maxWalletAmt = (totalSupply * 3) / 100;
		swapTokensAtAmt = (totalSupply * 25) / 100000;

		buyTotalTax = 200;
		sellTotalTax = 3500; // initial set high

		// @dev set from constructor
		marketingAndBuybacksAddress = address(_marketingAddress);

		_excludeFromMaxTransaction(newOwner, true);
		_excludeFromMaxTransaction(address(this), true);
		_excludeFromMaxTransaction(address(dexRouter), true);
		_excludeFromMaxTransaction(address(0xdead), true);
		_excludeFromMaxTransaction(address(marketingAndBuybacksAddress), true);
		_excludeFromMaxTransaction(address(_team1), true);
		_excludeFromMaxTransaction(address(_team2), true);

		excludeFromTax(newOwner, true);
		excludeFromTax(address(this), true);
		excludeFromTax(address(dexRouter), true);
		excludeFromTax(address(0xdead), true);
		excludeFromTax(address(marketingAndBuybacksAddress), true);
		excludeFromTax(address(_team1), true);
		excludeFromTax(address(_team2), true);

		// mint 100% here
		_mint(address(this), totalSupply);

		// transfer % to newOwner
		_transfer(address(this), newOwner, (totalSupply * 6) / 100);
		_transfer(address(this), _team1, (totalSupply * 2) / 100);
		_transfer(address(this), _team2, (totalSupply * 2) / 100);

		transferOwnership(newOwner);

		PAIREDTOKEN.approve(address(dexRouter), type(uint256).max);
		_approve(address(this), address(dexRouter), type(uint256).max);
	}

	receive() external payable {}

	/**
	 * @dev Throws if called by any account other than the dogsbody.
	 */
	modifier onlyDogsbody() {
		_checkDogsbody();
		_;
	}

	/**
	 * @dev Throws if the sender is not the dogsbody.
	 */
	function _checkDogsbody() internal view virtual {
		require(dogsbody == _msgSender(), "Dogsbody: caller is not the dogsbody");
	}

	function updateAllowanceForSwapping() external {
		PAIREDTOKEN.approve(address(dexRouter), type(uint256).max);
		_approve(address(this), address(dexRouter), type(uint256).max);
	}

	// @dev - you must have ETH and Tokens in place before flicking this switch
	function startTrading() external payable onlyOwner {
		require(!tradingLive, "Trading is already active, cannot relaunch.");
		uint256 amountTokenDesired = balanceOf(address(this)); // 100% of the balance assigned to this contract
		require(msg.value > 0, "Cannot start trading with no eth!");
		require(amountTokenDesired > 0, "Cannot start trading with no tokens!");
		dexRouter.addLiquidityETH{value: msg.value}(address(this), amountTokenDesired, 0, 0, owner(), block.timestamp);
		tradingLive = true;
		swapEnabled = true;
		tradingLiveBlock = block.number;
		emit StartedTrading(msg.value, amountTokenDesired, block.timestamp);
	}

	// remove limits after token is stable
	function removeLimits() external onlyOwner {
		limitsActive = false;
		emit RemovedLimits();
	}

	function updateMaxBuyAmt(uint256 newNum) external onlyOwner {
		require(newNum >= ((totalSupply() * 1) / 100) / 1e18, "Cannot set max buy amt lower than 1%");
		maxBuyAmt = newNum * (10 ** 18);
		emit UpdatedMaxBuyAmt(maxBuyAmt);
	}

	function updateMaxSellAmt(uint256 newNum) external onlyOwner {
		require(newNum >= ((totalSupply() * 1) / 100) / 1e18, "Cannot set max sell amt lower than 1%");
		maxSellAmt = newNum * (10 ** 18);
		emit UpdatedMaxSellAmt(maxSellAmt);
	}

	function removeMaxWallet() external onlyOwner {
		maxWalletAmt = totalSupply();
		emit UpdatedMaxWalletAmt(maxWalletAmt);
	}

	function updateSwapTokensAtAmt(uint256 newAmt) external onlyOwner {
		require(newAmt >= (totalSupply() * 1) / 1000000, "Swap amt cannot be lower than 0.0001% total supply.");
		require(newAmt <= (totalSupply() * 1) / 1000, "Swap amt cannot be higher than 0.1% total supply.");
		swapTokensAtAmt = newAmt;
	}

	function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {
		_isExcludedMaxTransactionAmt[updAds] = isExcluded;
		emit MaxTransactionExclusion(updAds, isExcluded);
	}

	function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {
		if (!isEx) {
			require(updAds != lpPair, "Cannot remove uniswap pair from max txn");
		}
		_isExcludedMaxTransactionAmt[updAds] = isEx;
	}

	function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
		require(pair != lpPair || value, "The pair cannot be removed from automatedMarketMakerPairs");
		automatedMarketMakerPairs[pair] = value;
		_excludeFromMaxTransaction(pair, value);
		emit SetAutomatedMarketMakerPair(pair, value);
	}

	function updateBuyTax(uint256 _marketingAndBuybacksTax) external onlyOwner {
		buyTotalTax = _marketingAndBuybacksTax;
		require(buyTotalTax <= 700, "Must keep tax at 7% or less");
		emit UpdatedBuyTax(buyTotalTax);
	}

	function updateSellTax(uint256 _marketingAndBuybacksTax) external onlyOwner {
		sellTotalTax = _marketingAndBuybacksTax;
		require(sellTotalTax <= 700, "Must keep tax at 7% or less");
		emit UpdatedSellTax(sellTotalTax);
	}

	function excludeFromTax(address account, bool excluded) public onlyOwner {
		_isExcludedFromTax[account] = excluded;
		emit ExcludeFromTax(account, excluded);
	}

	function _transfer(address from, address to, uint256 amt) internal override {
		require(from != address(0), "ERC20: transfer from the zero address");
		require(to != address(0), "ERC20: transfer to the zero address");
		if (amt == 0) {
			super._transfer(from, to, 0);
			return;
		}

		if (!tradingLive) {
			require(_isExcludedFromTax[from] || _isExcludedFromTax[to], "Trading is not active.");
		}

		if (_isExcludedFromTax[from] || _isExcludedFromTax[to] || swapping) {
			super._transfer(from, to, amt);
			return;
		}

		if (limitsActive) {
			if (
				from != owner() &&
				to != owner() &&
				to != address(0) &&
				to != address(0xdead) &&
				!_isExcludedFromTax[from] &&
				!_isExcludedFromTax[to]
			) {
				if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmt[to]) {
					// if buy
					require(amt <= maxBuyAmt, "Buy transfer amt exceeds the max buy.");
					require(amt + balanceOf(to) <= maxWalletAmt, "Cannot Exceed max wallet");
				} else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmt[from]) {
					// else if sell
					require(amt <= maxSellAmt, "Sell transfer amt exceeds the max sell.");
				} else if (!_isExcludedMaxTransactionAmt[to]) {
					// else all others
					require(amt + balanceOf(to) <= maxWalletAmt, "Cannot Exceed max wallet");
				}
			}
		}

		uint256 contractTokenBalance = balanceOf(address(this));
		bool canSwap = contractTokenBalance >= swapTokensAtAmt;
		if (canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]) {
			swapping = true;
			swapBack();
			swapping = false;
		}

		bool takeTax = true;
		// if any account belongs to _isExcludedFromTax account then remove the tax
		if (_isExcludedFromTax[from] || _isExcludedFromTax[to]) {
			takeTax = false;
		}

		// only take tax on buys/sells, do not take on wallet transfers
		if (takeTax) {
			uint256 tax = 0;
			if (automatedMarketMakerPairs[to] && sellTotalTax > 0) {
				// if sell
				tax = (amt * sellTotalTax) / FEE_DIVISOR;
			} else if (automatedMarketMakerPairs[from] && buyTotalTax > 0) {
				// else if buy
				tax = (amt * buyTotalTax) / FEE_DIVISOR;
			}

			if (tax > 0) {
				super._transfer(from, address(this), tax);
			}
			amt -= tax;
		}

		super._transfer(from, to, amt);
	}

	function swapTokensForPAIREDTOKEN(uint256 tokenAmt, address recipient) private {
		// generate the uniswap pair path of token -> weth
		address[] memory path = new address[](2);
		path[0] = address(this);
		path[1] = dexRouter.WETH();
		_approve(address(this), address(dexRouter), tokenAmt);
		// make the swap
		dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
			tokenAmt,
			0, // accept any amt of ETH
			path,
			address(recipient),
			block.timestamp
		);
		if (PAIREDTOKEN.balanceOf(address(this)) > 0) {
			SafeERC20.safeTransfer(PAIREDTOKEN, recipient, PAIREDTOKEN.balanceOf(address(this)));
		}
	}

	function swapBack() private {
		uint256 contractBalance = balanceOf(address(this));
		if (contractBalance == 0) {
			return;
		}
		// only ever do 1%
		if (contractBalance > swapTokensAtAmt * 40) {
			contractBalance = swapTokensAtAmt * 40;
		}
		// swap and send to our marketing address...
		swapTokensForPAIREDTOKEN(contractBalance, marketingAndBuybacksAddress);
	}

	// @notice we can let the dogsbody address and owner call this. Will let it be called after renounce.
	function setMarketingAndBuybacksAddress(address _marketingAndBuybacksAddress) external onlyDogsbody {
		require(_marketingAndBuybacksAddress != address(0), "address cannot be 0");
		marketingAndBuybacksAddress = payable(_marketingAndBuybacksAddress);
		emit UpdatedMarketingAndBuybacksAddress(_marketingAndBuybacksAddress);
	}

	// @dev force Swap back if slippage issues.
	// @notice we can let the dogsbody address and owner call this. Will let it be called after renounce.
	function forceSwapBack() external onlyDogsbody {
		require(
			balanceOf(address(this)) >= swapTokensAtAmt,
			"Can only swap when token amt is at or higher than restriction"
		);
		swapping = true;
		swapBack();
		swapping = false;
		emit OwnerForcedSwapBack(block.timestamp);
	}

	// @dev transfer any weird tokens to marketing address
	// @notice we can let the dogsbody address and owner call this. Will let it be called after renounce.
	function transferForeignToken(address _token) external onlyDogsbody {
		require(_token != address(0), "_token address cannot be 0");
		require(_token != address(this) || !tradingLive, "Can't withdraw native tokens");
		uint256 _contractBalance = IERC20(_token).balanceOf(address(this));
		SafeERC20.safeTransfer(IERC20(_token), marketingAndBuybacksAddress, _contractBalance);
		emit TransferForeignToken(_token, _contractBalance);
	}
}