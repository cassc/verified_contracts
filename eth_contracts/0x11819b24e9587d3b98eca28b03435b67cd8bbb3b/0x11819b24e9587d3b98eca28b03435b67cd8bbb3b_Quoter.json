{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src2/Quoter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"../contracts/8/interfaces/IWETH.sol\\\";\\nimport \\\"../contracts/8/interfaces/IAdapter.sol\\\";\\nimport \\\"../contracts/8/interfaces/IApproveProxy.sol\\\";\\nimport \\\"../contracts/8/interfaces/IWNativeRelayer.sol\\\";\\nimport \\\"../contracts/8/interfaces/IXBridge.sol\\\";\\n\\nimport \\\"../contracts/8/libraries/Permitable.sol\\\";\\nimport \\\"../contracts/8/libraries/PMMLib.sol\\\";\\nimport \\\"../contracts/8/libraries/CommissionLib.sol\\\";\\nimport \\\"../contracts/8/libraries/EthReceiver.sol\\\";\\nimport \\\"../contracts/8/libraries/WrapETHSwap.sol\\\";\\nimport \\\"../contracts/8/libraries/CommonUtils.sol\\\";\\nimport \\\"../contracts/8/libraries/UniversalERC20.sol\\\";\\n\\ncontract Quoter {\\n    using UniversalERC20 for IERC20;\\n\\n    struct BaseRequest {\\n        uint256 fromToken;\\n        address toToken;\\n        uint256 fromTokenAmount;\\n        uint256 minReturnAmount;\\n        uint256 deadLine;\\n    }\\n\\n    struct RouterPath {\\n        address[] mixAdapters;\\n        address[] assetTo;\\n        uint256[] rawData;\\n        bytes[] extraData;\\n        uint256 fromToken;\\n    }\\n\\n    struct PMMSwapRequest {\\n        uint256 pathIndex;\\n        address payer;\\n        address fromToken;\\n        address toToken;\\n        uint256 fromTokenAmountMax;\\n        uint256 toTokenAmountMax;\\n        uint256 salt;\\n        uint256 deadLine;\\n        bool isPushOrder;\\n        bytes extension;\\n    }\\n    // address marketMaker;\\n    // uint256 subIndex;\\n    // bytes signature;\\n    // uint256 source;  1byte type + 1byte bool\uff08reverse\uff09 + 0...0 + 20 bytes address\\n\\n    function _bytes32ToAddress(\\n        uint256 param\\n    ) private pure returns (address result) {\\n        assembly {\\n            result := and(param, _ADDRESS_MASK)\\n        }\\n    }\\n\\n    address internal constant _WETH =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    uint256 internal constant _ADDRESS_MASK =\\n        0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\\n    uint256 internal constant _REVERSE_MASK =\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 internal constant _ORDER_ID_MASK =\\n        0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\\n    uint256 internal constant _WEIGHT_MASK =\\n        0x00000000000000000000ffff0000000000000000000000000000000000000000;\\n    uint gas;\\n    function smartSwapByOrderId(\\n        uint256 orderId,\\n        BaseRequest calldata baseRequest,\\n        uint256[] calldata batchesAmount,\\n        RouterPath[][] calldata batches,\\n        PMMSwapRequest[] calldata extraData\\n    )\\n        public\\n        returns (\\n            uint256 returnAmount,\\n            uint256 estimatedGas,\\n            uint256 blockHeight\\n        )\\n    {\\n        BaseRequest memory _baseRequest = baseRequest;\\n\\n        address fromToken = _bytes32ToAddress(_baseRequest.fromToken);\\n        returnAmount = IERC20(_baseRequest.toToken).universalBalanceOf(\\n            address(this)\\n        );\\n\\n        if (fromToken == _ETH) {\\n            IWETH(_WETH).deposit{value: _baseRequest.fromTokenAmount}();\\n        }\\n        gas = gasleft();\\n        for (uint256 i = 0; i < batches.length; i++) {\\n            _exeHop(\\n                address(this),\\n                address(this),\\n                IERC20(_baseRequest.toToken).isETH(),\\n                batchesAmount[i],\\n                batches[i]\\n            );\\n        }\\n        blockHeight = block.number;\\n        estimatedGas = gas - gasleft();\\n        returnAmount =\\n            IERC20(_baseRequest.toToken).universalBalanceOf(address(this)) -\\n            returnAmount;\\n    }\\n\\n    function _exeHop(\\n        address payer,\\n        address receiver,\\n        bool isToNative,\\n        uint256 batchAmount,\\n        RouterPath[] calldata hops\\n    ) private {\\n        address fromToken = _bytes32ToAddress(hops[0].fromToken);\\n        bool toNext;\\n        bool noTransfer;\\n\\n        // execute hop\\n        uint256 hopLength = hops.length;\\n        for (uint256 i = 0; i < hopLength; ) {\\n            if (i > 0) {\\n                fromToken = _bytes32ToAddress(hops[i].fromToken);\\n                batchAmount = IERC20(fromToken).universalBalanceOf(\\n                    address(this)\\n                );\\n                payer = address(this);\\n            }\\n\\n            address to = address(this);\\n            if (i == hopLength - 1 && !isToNative) {\\n                to = receiver;\\n            } else if (i < hopLength - 1 && hops[i + 1].assetTo.length == 1) {\\n                to = hops[i + 1].assetTo[0];\\n                toNext = true;\\n            } else {\\n                toNext = false;\\n            }\\n\\n            // 3.2 execute forks\\n            _exeForks(payer, to, batchAmount, hops[i], noTransfer);\\n            noTransfer = toNext;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n    function _exeForks(\\n        address payer,\\n        address to,\\n        uint256 batchAmount,\\n        RouterPath calldata path,\\n        bool noTransfer\\n    ) private {\\n        address fromToken = _bytes32ToAddress(path.fromToken);\\n        uint256 pathLength = path.mixAdapters.length;\\n        for (uint256 i = 0; i < pathLength; ) {\\n            bytes32 rawData = bytes32(path.rawData[i]);\\n            address poolAddress;\\n            bool reserves;\\n            uint256 weight;\\n            assembly {\\n                poolAddress := and(rawData, _ADDRESS_MASK)\\n                reserves := and(rawData, _REVERSE_MASK)\\n                weight := shr(160, and(rawData, _WEIGHT_MASK))\\n            }\\n\\n            if (!noTransfer) {\\n                uint256 _fromTokenAmount = weight == 10_000\\n                    ? batchAmount\\n                    : (batchAmount * weight) / 10_000;\\n                _transferInternal(\\n                    payer,\\n                    path.assetTo[i],\\n                    fromToken,\\n                    _fromTokenAmount\\n                );\\n            }\\n\\n            if (reserves) {\\n                IAdapter(path.mixAdapters[i]).sellQuote(\\n                    to,\\n                    poolAddress,\\n                    path.extraData[i]\\n                );\\n            } else {\\n                IAdapter(path.mixAdapters[i]).sellBase(\\n                    to,\\n                    poolAddress,\\n                    path.extraData[i]\\n                );\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n    function _transferInternal(\\n        address payer,\\n        address to,\\n        address token,\\n        uint256 amount\\n    ) private {\\n        if (payer == address(this)) {\\n            SafeERC20.safeTransfer(IERC20(token), to, amount);\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IWETH {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IAdapter.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IAdapter {\\n    function sellBase(\\n        address to,\\n        address pool,\\n        bytes memory data\\n    ) external;\\n\\n    function sellQuote(\\n        address to,\\n        address pool,\\n        bytes memory data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IApproveProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IApproveProxy {\\n    function isAllowedProxy(address _proxy) external view returns (bool);\\n\\n    function claimTokens(\\n        address token,\\n        address who,\\n        address dest,\\n        uint256 amount\\n    ) external;\\n\\n    function tokenApprove() external view returns (address);\\n    function addProxy(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IWNativeRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IWNativeRelayer {\\n    function withdraw(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IXBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IXBridge {\\n    function payerReceiver() external view returns(address, address);\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/Permitable.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"./RevertReasonParser.sol\\\";\\n\\n\\n/// @title Base contract with common permit handling logics\\nabstract contract Permitable {\\n  function _permit(address token, bytes calldata permit) internal {\\n    if (permit.length > 0) {\\n      bool success;\\n      bytes memory result;\\n      if (permit.length == 32 * 7) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\\n      } else if (permit.length == 32 * 8) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\\n      } else {\\n        revert(\\\"Wrong permit length\\\");\\n      }\\n      if (!success) {\\n        revert(RevertReasonParser.parse(result, \\\"Permit failed: \\\"));\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/PMMLib.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary PMMLib {\\n\\n  // ============ Struct ============\\n  struct PMMSwapRequest {\\n      uint256 pathIndex;\\n      address payer;\\n      address fromToken;\\n      address toToken;\\n      uint256 fromTokenAmountMax;\\n      uint256 toTokenAmountMax;\\n      uint256 salt;\\n      uint256 deadLine;\\n      bool isPushOrder;\\n      bytes extension;\\n      // address marketMaker;\\n      // uint256 subIndex;\\n      // bytes signature;\\n      // uint256 source;  1byte type + 1byte bool\uff08reverse\uff09 + 0...0 + 20 bytes address\\n  }\\n\\n  struct PMMBaseRequest {\\n    uint256 fromTokenAmount;\\n    uint256 minReturnAmount;\\n    uint256 deadLine;\\n    bool fromNative;\\n    bool toNative;\\n  }\\n\\n  enum PMM_ERROR {\\n      NO_ERROR,\\n      INVALID_OPERATOR,\\n      QUOTE_EXPIRED,\\n      ORDER_CANCELLED_OR_FINALIZED,\\n      REMAINING_AMOUNT_NOT_ENOUGH,\\n      INVALID_AMOUNT_REQUEST,\\n      FROM_TOKEN_PAYER_ERROR,\\n      TO_TOKEN_PAYER_ERROR,\\n      WRONG_FROM_TOKEN\\n  }\\n\\n  event PMMSwap(\\n    uint256 pathIndex,\\n    uint256 subIndex,\\n    uint256 errorCode\\n  );\\n\\n  error PMMErrorCode(uint256 errorCode);\\n\\n}\"\r\n    },\r\n    \"contracts/8/libraries/CommissionLib.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CommonUtils.sol\\\";\\n/// @title Base contract with common permit handling logics\\n\\nabstract contract CommissionLib is CommonUtils {\\n    uint256 internal constant _COMMISSION_FEE_MASK =\\n        0x000000000000ffffffffffff0000000000000000000000000000000000000000;\\n    uint256 internal constant _COMMISSION_FLAG_MASK =\\n        0xffffffffffff0000000000000000000000000000000000000000000000000000;\\n    uint256 internal constant FROM_TOKEN_COMMISSION =\\n        0x3ca20afc2aaa0000000000000000000000000000000000000000000000000000;\\n    uint256 internal constant TO_TOKEN_COMMISSION =\\n        0x3ca20afc2bbb0000000000000000000000000000000000000000000000000000;\\n\\n    event CommissionRecord(uint256 commissionAmount, address referrerAddress);\\n\\n    // set default vaule. can change when need.\\n    uint256 public constant commissionRateLimit = 300;\\n\\n    struct CommissionInfo {\\n        bool isFromTokenCommission;\\n        bool isToTokenCommission;\\n        uint256 commissionRate;\\n        address refererAddress;\\n        address token;\\n    }\\n\\n    function _getCommissionInfo()\\n        internal\\n        pure\\n        returns (CommissionInfo memory commissionInfo)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            let freePtr := mload(0x40)\\n            mstore(0x40, add(freePtr, 0xa0))\\n            let commissionData := calldataload(sub(calldatasize(), 0x20))\\n            mstore(\\n                commissionInfo,\\n                eq(\\n                    FROM_TOKEN_COMMISSION,\\n                    and(commissionData, _COMMISSION_FLAG_MASK)\\n                )\\n            ) // isFromTokenCommission\\n            mstore(\\n                add(0x20, commissionInfo),\\n                eq(\\n                    TO_TOKEN_COMMISSION,\\n                    and(commissionData, _COMMISSION_FLAG_MASK)\\n                )\\n            )\\n            mstore(\\n                add(0x40, commissionInfo),\\n                shr(160, and(commissionData, _COMMISSION_FEE_MASK))\\n            )\\n            mstore(\\n                add(0x60, commissionInfo),\\n                and(commissionData, _ADDRESS_MASK)\\n            )\\n            mstore(\\n                add(0x80, commissionInfo),\\n                and(calldataload(sub(calldatasize(), 0x40)), _ADDRESS_MASK)\\n            )\\n        }\\n    }\\n\\n    function _getBalanceOf(\\n        address token,\\n        address user\\n    ) internal returns (uint256 amount) {\\n        assembly {\\n            function _revertWithReason(m, len) {\\n                mstore(\\n                    0,\\n                    0x08c379a000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(\\n                    0x20,\\n                    0x0000002000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(0x40, m)\\n                revert(0, len)\\n            }\\n            switch eq(token, _ETH)\\n            case 1 {\\n                amount := selfbalance()\\n            }\\n            default {\\n                let freePtr := mload(0x40)\\n                mstore(0x40, add(freePtr, 0x24))\\n                mstore(\\n                    freePtr,\\n                    0x70a0823100000000000000000000000000000000000000000000000000000000\\n                ) //balanceOf\\n                mstore(add(freePtr, 0x04), user)\\n                let success := staticcall(gas(), token, freePtr, 0x24, 0, 0x20)\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x000000146765742062616c616e63654f66206661696c65640000000000000000,\\n                        0x58\\n                    )\\n                }\\n                amount := mload(0x00)\\n            }\\n        }\\n    }\\n\\n    function _doCommissionFromToken(\\n        CommissionInfo memory commissionInfo,\\n        address receiver,\\n        uint256 inputAmount\\n    ) internal returns (address, uint256) {\\n        if (commissionInfo.isToTokenCommission) {\\n            return (\\n                address(this),\\n                _getBalanceOf(commissionInfo.token, address(this))\\n            );\\n        }\\n        if (!commissionInfo.isFromTokenCommission) {\\n            return (receiver, 0);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            function _revertWithReason(m, len) {\\n                mstore(\\n                    0,\\n                    0x08c379a000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(\\n                    0x20,\\n                    0x0000002000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(0x40, m)\\n                revert(0, len)\\n            }\\n            let rate := mload(add(commissionInfo, 0x40))\\n            if gt(rate, commissionRateLimit) {\\n                _revertWithReason(\\n                    0x0000001b6572726f7220636f6d6d697373696f6e2072617465206c696d697400,\\n                    0x5f\\n                ) //\\\"error commission rate limit\\\"\\n            }\\n            let token := mload(add(commissionInfo, 0x80))\\n            let referer := mload(add(commissionInfo, 0x60))\\n            let amount := div(mul(inputAmount, rate), sub(10000, rate))\\n            switch eq(token, _ETH)\\n            case 1 {\\n                let success := call(gas(), referer, amount, 0, 0, 0, 0)\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x0000001b636f6d6d697373696f6e2077697468206574686572206572726f7200,\\n                        0x5f\\n                    )\\n                }\\n            }\\n            default {\\n                let freePtr := mload(0x40)\\n                mstore(0x40, add(freePtr, 0x84))\\n                mstore(\\n                    freePtr,\\n                    0x0a5ea46600000000000000000000000000000000000000000000000000000000\\n                ) // claimTokens\\n                mstore(add(freePtr, 0x04), token)\\n                mstore(add(freePtr, 0x24), caller())\\n                mstore(add(freePtr, 0x44), referer)\\n                mstore(add(freePtr, 0x64), amount)\\n                let success := call(\\n                    gas(),\\n                    _APPROVE_PROXY,\\n                    0,\\n                    freePtr,\\n                    0x84,\\n                    0,\\n                    0\\n                )\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x00000013636c61696d20746f6b656e73206661696c6564000000000000000000,\\n                        0x57\\n                    )\\n                }\\n            }\\n            let freePtr := mload(0x40)\\n            mstore(0x40, add(freePtr, 0x40))\\n            mstore(freePtr, amount)\\n            mstore(add(freePtr, 0x20), referer)\\n            log1(\\n                freePtr,\\n                0x40,\\n                0xffc60ee157a42f4d8edbd1897e6581a96d9ed04e44fb2ab53a47ce1eb8f2775b\\n            ) //emit CommissionRecord(commissionAmount, refererAddress);\\n        }\\n        return (receiver, 0);\\n    }\\n\\n    function _doCommissionToToken(\\n        CommissionInfo memory commissionInfo,\\n        address receiver,\\n        uint256 balanceBefore\\n    ) internal returns (uint256 amount) {\\n        if (!commissionInfo.isToTokenCommission) {\\n            return 0;\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            function _revertWithReason(m, len) {\\n                mstore(\\n                    0,\\n                    0x08c379a000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(\\n                    0x20,\\n                    0x0000002000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(0x40, m)\\n                revert(0, len)\\n            }\\n            let rate := mload(add(commissionInfo, 0x40))\\n            if gt(rate, commissionRateLimit) {\\n                _revertWithReason(\\n                    0x0000001b6572726f7220636f6d6d697373696f6e2072617465206c696d697400,\\n                    0x5f\\n                ) //\\\"error commission rate limit\\\"\\n            }\\n            let token := mload(add(commissionInfo, 0x80))\\n            let referer := mload(add(commissionInfo, 0x60))\\n\\n            switch eq(token, _ETH)\\n            case 1 {\\n                if lt(selfbalance(), balanceBefore) {\\n                    _revertWithReason(\\n                        0x0000000a737562206661696c65640000000000000000000000000000000000000,\\n                        0x4d\\n                    ) // sub failed\\n                }\\n                let inputAmount := sub(selfbalance(), balanceBefore)\\n                amount := div(mul(inputAmount, rate), 10000)\\n                let success := call(gas(), referer, amount, 0, 0, 0, 0)\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x000000197472616e73666572206574682072656665726572206661696c000000,\\n                        0x5d\\n                    ) // transfer eth referer fail\\n                }\\n                success := call(\\n                    gas(),\\n                    receiver,\\n                    sub(inputAmount, amount),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x0000001a7472616e7366657220657468207265636569766572206661696c0000,\\n                        0x5e\\n                    ) // transfer eth receiver fail\\n                }\\n            }\\n            default {\\n                let freePtr := mload(0x40)\\n                mstore(0x40, add(freePtr, 0x48))\\n                mstore(\\n                    freePtr,\\n                    0xa9059cbba9059cbb70a082310000000000000000000000000000000000000000\\n                ) // transfer transfer balanceOf\\n                mstore(add(freePtr, 0x0c), address())\\n                let success := staticcall(\\n                    gas(),\\n                    token,\\n                    add(freePtr, 8),\\n                    36,\\n                    0,\\n                    0x20\\n                )\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x000000146765742062616c616e63654f66206661696c65640000000000000000,\\n                        0x58\\n                    )\\n                }\\n                let balanceAfter := mload(0x00)\\n                if lt(balanceAfter, balanceBefore) {\\n                    _revertWithReason(\\n                        0x0000000a737562206661696c65640000000000000000000000000000000000000,\\n                        0x4d\\n                    ) // sub failed\\n                }\\n                let inputAmount := sub(balanceAfter, balanceBefore)\\n                amount := div(mul(inputAmount, rate), 10000)\\n                mstore(add(freePtr, 0x08), referer)\\n                mstore(add(freePtr, 0x28), amount)\\n                success := call(gas(), token, 0, add(freePtr, 4), 0x44, 0, 0)\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x0000001b7472616e7366657220746f6b656e2072656665726572206661696c00,\\n                        0x5f\\n                    ) //transfer token referer fail\\n                }\\n                mstore(add(freePtr, 0x04), receiver)\\n                mstore(add(freePtr, 0x24), sub(inputAmount, amount))\\n                success := call(gas(), token, 0, freePtr, 0x44, 0, 0)\\n                if eq(success, 0) {\\n                    _revertWithReason(\\n                        0x0000001c7472616e7366657220746f6b656e207265636569766572206661696c,\\n                        0x60\\n                    ) //transfer token receiver fail\\n                }\\n            }\\n            let freePtr := mload(0x40)\\n            mstore(0x40, add(freePtr, 0x40))\\n            mstore(freePtr, amount)\\n            mstore(add(freePtr, 0x20), referer)\\n            log1(\\n                freePtr,\\n                0x40,\\n                0xffc60ee157a42f4d8edbd1897e6581a96d9ed04e44fb2ab53a47ce1eb8f2775b\\n            ) //emit CommissionRecord(commissionAmount, refererAddress);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/EthReceiver.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Base contract with common payable logics\\nabstract contract EthReceiver {\\n  receive() external payable {\\n    // solhint-disable-next-line avoid-tx-origin\\n    require(msg.sender != tx.origin, \\\"ETH deposit rejected\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/WrapETHSwap.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/CommonUtils.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IWNativeRelayer.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IApproveProxy.sol\\\";\\n\\n/// @title Base contract with common payable logics\\nabstract contract WrapETHSwap is CommonUtils {\\n\\n  uint256 private constant SWAP_AMOUNT = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n  \\n  function swapWrap(uint256 orderId, uint256 rawdata) external payable {\\n    bool reversed;\\n    uint128 amount;\\n    assembly {\\n      reversed := and(rawdata, _REVERSE_MASK)\\n      amount := and(rawdata, SWAP_AMOUNT)\\n    }\\n    require(amount > 0, \\\"amount must be > 0\\\");\\n    if (reversed) {\\n      IApproveProxy(_APPROVE_PROXY).claimTokens(_WETH, msg.sender, _WNATIVE_RELAY, amount);\\n      IWNativeRelayer(_WNATIVE_RELAY).withdraw(amount);\\n      (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n      require(success, \\\"transfer native token failed\\\");\\n    } else {\\n      require(msg.value == amount, \\\"value not equal amount\\\");\\n      IWETH(_WETH).deposit{value: amount}();\\n      SafeERC20.safeTransfer(IERC20(_WETH), msg.sender, amount);\\n    }\\n    emit SwapOrderId(orderId);\\n    emit OrderRecord(reversed ? _WETH : _ETH, reversed ? _ETH: _WETH, msg.sender, amount, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/CommonUtils.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Base contract with common permit handling logics\\nabstract contract CommonUtils {\\n\\n  address internal constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  uint256 internal constant _ADDRESS_MASK = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\\n  uint256 internal constant _REVERSE_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n  uint256 internal constant _ORDER_ID_MASK = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\\n  uint256 internal constant _WEIGHT_MASK = 0x00000000000000000000ffff0000000000000000000000000000000000000000;\\n  uint256 internal constant _CALL_GAS_LIMIT = 5000;\\n\\n  /// @dev WETH address is network-specific and needs to be changed before deployment.\\n  /// It can not be moved to immutable as immutables are not supported in assembly\\n  // ETH:     C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n  // BSC:     bb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\n  // OEC:     8f8526dbfd6e38e3d8307702ca8469bae6c56c15\\n  // LOCAL:   5FbDB2315678afecb367f032d93F642f64180aa3\\n  // LOCAL2:  02121128f1Ed0AdA5Df3a87f42752fcE4Ad63e59\\n  // POLYGON: 0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\\n  // AVAX:    B31f66AA3C1e785363F0875A1B74E27b85FD66c7\\n  // FTM:     21be370D5312f44cB42ce377BC9b8a0cEF1A4C83\\n  // ARB:     82aF49447D8a07e3bd95BD0d56f35241523fBab1\\n  // OP:      4200000000000000000000000000000000000006\\n  // CRO:     5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23\\n  // CFX:     14b2D3bC65e74DAE1030EAFd8ac30c533c976A9b\\n  // POLYZK   4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9\\n  address public constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  // address public constant _WETH = 0x5FbDB2315678afecb367f032d93F642f64180aa3;    // hardhat1\\n  // address public constant _WETH = 0x707531c9999AaeF9232C8FEfBA31FBa4cB78d84a;    // hardhat2\\n\\n\\n  // ETH:     70cBb871E8f30Fc8Ce23609E9E0Ea87B6b222F58\\n  // ETH-DEV\uff1a02D0131E5Cc86766e234EbF1eBe33444443b98a3\\n  // BSC:     d99cAE3FAC551f6b6Ba7B9f19bDD316951eeEE98\\n  // OEC:     E9BBD6eC0c9Ca71d3DcCD1282EE9de4F811E50aF\\n  // LOCAL:   e7f1725E7734CE288F8367e1Bb143E90bb3F0512\\n  // LOCAL2:  95D7fF1684a8F2e202097F28Dc2e56F773A55D02\\n  // POLYGON: 40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\\n  // AVAX:    70cBb871E8f30Fc8Ce23609E9E0Ea87B6b222F58\\n  // FTM:     E9BBD6eC0c9Ca71d3DcCD1282EE9de4F811E50aF\\n  // ARB:     E9BBD6eC0c9Ca71d3DcCD1282EE9de4F811E50aF\\n  // OP:      100F3f74125C8c724C7C0eE81E4dd5626830dD9a\\n  // CRO:     E9BBD6eC0c9Ca71d3DcCD1282EE9de4F811E50aF\\n  // CFX:     100F3f74125C8c724C7C0eE81E4dd5626830dD9a\\n  // POLYZK   1b5d39419C268b76Db06DE49e38B010fbFB5e226\\n  address public constant _APPROVE_PROXY = 0xD0f95FaFA06de1B21E79Db03C649919501e99Ea9;\\n  // address public constant _APPROVE_PROXY = 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512;    // hardhat1\\n  // address public constant _APPROVE_PROXY = 0x2538a10b7fFb1B78c890c870FC152b10be121f04;    // hardhat2\\n\\n  // ETH:     5703B683c7F928b721CA95Da988d73a3299d4757\\n  // BSC:     0B5f474ad0e3f7ef629BD10dbf9e4a8Fd60d9A48\\n  // OEC:     d99cAE3FAC551f6b6Ba7B9f19bDD316951eeEE98\\n  // LOCAL:   D49a0e9A4CD5979aE36840f542D2d7f02C4817Be\\n  // LOCAL2:  11457D5b1025D162F3d9B7dBeab6E1fBca20e043\\n  // POLYGON: f332761c673b59B21fF6dfa8adA44d78c12dEF09\\n  // AVAX:    3B86917369B83a6892f553609F3c2F439C184e31\\n  // FTM:     40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\\n  // ARB:     d99cAE3FAC551f6b6Ba7B9f19bDD316951eeEE98\\n  // OP:      40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\\n  // CRO:     40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\\n  // CFX:     40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\\n  // POLYZK   d2F0aC2012C8433F235c8e5e97F2368197DD06C7\\n  address public constant _WNATIVE_RELAY = 0x4d08a6FE192bc9059c9Db5d9e9b33B12711F7966;\\n  // address public constant _WNATIVE_RELAY = 0x0B306BF915C4d645ff596e518fAf3F9669b97016;   // hardhat1\\n  // address public constant _WNATIVE_RELAY = 0x6A47346e722937B60Df7a1149168c0E76DD6520f;   // hardhat2\\n\\n  event OrderRecord(address fromToken, address toToken, address sender, uint256 fromAmount, uint256 returnAmount);\\n  event SwapOrderId(uint256 id);\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/UniversalERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\n\\nlibrary UniversalERC20 {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 private constant ETH_ADDRESS =\\n        IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    function universalTransfer(\\n        IERC20 token,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            if (isETH(token)) {\\n                to.transfer(amount);\\n            } else {\\n                token.safeTransfer(to, amount);\\n            }\\n        }\\n    }\\n\\n    function universalTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            token.safeTransferFrom(from, to, amount);\\n        }\\n    }\\n\\n    function universalApproveMax(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), to);\\n        if (allowance < amount) {\\n            token.forceApprove(to, type(uint256).max);\\n        }\\n    }\\n\\n    function universalBalanceOf(IERC20 token, address who)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (isETH(token)) {\\n            return who.balance;\\n        } else {\\n            return token.balanceOf(who);\\n        }\\n    }\\n\\n    function tokenBalanceOf(IERC20 token, address who)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return token.balanceOf(who);\\n    }\\n\\n    function isETH(IERC20 token) internal pure returns (bool) {\\n        return token == ETH_ADDRESS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IDaiLikePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Interface for DAI-style permits\\ninterface IDaiLikePermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/RevertReasonParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Library that allows to parse unsuccessful arbitrary calls revert reasons.\\n/// See https://solidity.readthedocs.io/en/latest/control-structures.html#revert for details.\\n/// Note that we assume revert reason being abi-encoded as Error(string) so it may fail to parse reason\\n/// if structured reverts appear in the future.\\n///\\n/// All unsuccessful parsings get encoded as Unknown(data) string\\nlibrary RevertReasonParser {\\n    bytes4 private constant _PANIC_SELECTOR =\\n        bytes4(keccak256(\\\"Panic(uint256)\\\"));\\n    bytes4 private constant _ERROR_SELECTOR =\\n        bytes4(keccak256(\\\"Error(string)\\\"));\\n\\n    function parse(bytes memory data, string memory prefix)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (data.length >= 4) {\\n            bytes4 selector;\\n            assembly {\\n                // solhint-disable-line no-inline-assembly\\n                selector := mload(add(data, 0x20))\\n            }\\n\\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\\n                uint256 offset;\\n                bytes memory reason;\\n                // solhint-disable no-inline-assembly\\n                assembly {\\n                    // 36 = 32 bytes data length + 4-byte selector\\n                    offset := mload(add(data, 36))\\n                    reason := add(data, add(36, offset))\\n                }\\n                /*\\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\\n                    https://github.com/ethereum/solidity/issues/10170\\n                    because of that we can't check for equality and instead check\\n                    that offset + string length + extra 36 bytes is less than overall data length\\n                */\\n                require(\\n                    data.length >= 36 + offset + reason.length,\\n                    \\\"Invalid revert reason\\\"\\n                );\\n                return string(abi.encodePacked(prefix, \\\"Error(\\\", reason, \\\")\\\"));\\n            }\\n            // 36 = 4-byte selector + 32 bytes integer\\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\\n                uint256 code;\\n                // solhint-disable no-inline-assembly\\n                assembly {\\n                    // 36 = 32 bytes data length + 4-byte selector\\n                    code := mload(add(data, 36))\\n                }\\n                return\\n                    string(\\n                        abi.encodePacked(prefix, \\\"Panic(\\\", _toHex(code), \\\")\\\")\\n                    );\\n            }\\n        }\\n\\n        return string(abi.encodePacked(prefix, \\\"Unknown(\\\", _toHex(data), \\\")\\\"));\\n    }\\n\\n    function _toHex(uint256 value) private pure returns (string memory) {\\n        return _toHex(abi.encodePacked(value));\\n    }\\n\\n    function _toHex(bytes memory data) private pure returns (string memory) {\\n        bytes16 alphabet = 0x30313233343536373839616263646566;\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/SafeERC20.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./RevertReasonForwarder.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\n\\n// File @1inch/solidity-utils/contracts/libraries/SafeERC20.sol@v2.1.1\\n\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n\\n    // Ensures method do not revert or return boolean `true`, admits call to non-smart-contract\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 { success := gt(extcodesize(token), 0) }\\n                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    // Ensures method do not revert or return boolean `true`, admits call to non-smart-contract\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        forceApprove(token, spender, value);\\n    }\\n\\n    // If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (!_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value))\\n            {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    \\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        bool success;\\n        if (permit.length == 32 * 7) {\\n            success = _makeCalldataCall(token, IERC20Permit.permit.selector, permit);\\n        } else if (permit.length == 32 * 8) {\\n            success = _makeCalldataCall(token, IDaiLikePermit.permit.selector, permit);\\n        } else {\\n            revert SafePermitBadLength();\\n        }\\n        if (!success) RevertReasonForwarder.reRevert();\\n    }\\n\\n    function _makeCall(IERC20 token, bytes4 selector, address to, uint256 amount) private returns(bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 { success := gt(extcodesize(token), 0) }\\n                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }\\n            }\\n        }\\n    }\\n\\n    function _makeCalldataCall(IERC20 token, bytes4 selector, bytes calldata args) private returns(bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly { // solhint-disable-line no-inline-assembly\\n            let len := add(4, args.length)\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            calldatacopy(add(data, 0x04), args.offset, args.length)\\n            success := call(gas(), token, 0, data, len, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 { success := gt(extcodesize(token), 0) }\\n                default { success := and(gt(returndatasize(), 31), eq(mload(0), 1)) }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/8/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    function wad() public pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    function ray() public pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\\n        if (a > 3) {\\n            b = a;\\n            uint256 x = a / 2 + 1;\\n            while (x < b) {\\n                b = x;\\n                x = (a / x + x) / 2;\\n            }\\n        } else if (a != 0) {\\n            b = 1;\\n        }\\n    }\\n\\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / WAD;\\n    }\\n\\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / RAY;\\n    }\\n\\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, WAD), b);\\n    }\\n\\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, WAD), b / 2) / b;\\n    }\\n\\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, RAY), b);\\n    }\\n\\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, RAY), b / 2) / b;\\n    }\\n\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = WAD;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = wmul(result, x);\\n            }\\n            x = wmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = RAY;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = rmul(result, x);\\n            }\\n            x = rmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 quotient = div(a, b);\\n        uint256 remainder = a - quotient * b;\\n        if (remainder > 0) {\\n            return quotient + 1;\\n        } else {\\n            return quotient;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/Address.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account)\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(account);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/8/libraries/RevertReasonForwarder.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RevertReasonForwarder {\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        /// @solidity memory-safe-assembly\\n        assembly { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"@dex/=contracts/8/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"internalType\":\"struct Quoter.BaseRequest\",\"name\":\"baseRequest\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"batchesAmount\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"mixAdapters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rawData\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extraData\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"fromToken\",\"type\":\"uint256\"}],\"internalType\":\"struct Quoter.RouterPath[][]\",\"name\":\"batches\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmountMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmountMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPushOrder\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"}],\"internalType\":\"struct Quoter.PMMSwapRequest[]\",\"name\":\"extraData\",\"type\":\"tuple[]\"}],\"name\":\"smartSwapByOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHeight\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Quoter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}