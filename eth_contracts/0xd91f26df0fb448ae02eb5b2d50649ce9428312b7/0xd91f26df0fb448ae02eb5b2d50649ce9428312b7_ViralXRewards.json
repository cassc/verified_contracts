{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/viralxrewardcontract.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2024-02-24\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n        // Position is the index of the value in the `values` array plus 1.\\r\\n        // Position 0 is used to mean a value is not in the set.\\r\\n        mapping(bytes32 value => uint256) _positions;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._positions[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\r\\n        uint256 position = set._positions[value];\\r\\n\\r\\n        if (position != 0) {\\r\\n            // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 valueIndex = position - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            if (valueIndex != lastIndex) {\\r\\n                bytes32 lastValue = set._values[lastIndex];\\r\\n\\r\\n                // Move the lastValue to the index where the value to delete is\\r\\n                set._values[valueIndex] = lastValue;\\r\\n                // Update the tracked position of the lastValue (that was just moved)\\r\\n                set._positions[lastValue] = position;\\r\\n            }\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the tracked position for the deleted slot\\r\\n            delete set._positions[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._positions[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\r\\n        return set._values;\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        bytes32[] memory result;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        address[] memory result;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        uint256[] memory result;\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20{\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IReferralRegistry {\\r\\n    function getUserReferee(address _user) external view returns (string calldata);\\r\\n\\r\\n    function hasUserReferee(address _user) external view returns (bool);\\r\\n\\r\\n    function createReferralAnchor(address _user, string calldata _referee) external;\\r\\n}\\r\\n\\r\\ncontract ReferralRegistry is Ownable, IReferralRegistry {\\r\\n    event ReferralAnchorCreated(address indexed user, string indexed referee);\\r\\n    event ReferralAnchorUpdated(address indexed user, string indexed referee);\\r\\n    event AnchorManagerUpdated(address account, bool isManager);\\r\\n\\r\\n    // stores addresses which are allowed to create new anchors\\r\\n    mapping(address => bool) public isAnchorManager;\\r\\n\\r\\n    // stores the address that referred a given user\\r\\n    mapping(address => string) public referralAnchor;\\r\\n\\r\\n    mapping(string => address) public referralCodeAddress;\\r\\n\\r\\n    mapping(address => uint256) public referreeOwedAmount;\\r\\n\\r\\n    mapping(address => uint256) public referreeTotalRaisedAmount;\\r\\n\\r\\n    mapping(string => uint256) public walletReferralAmount;\\r\\n\\r\\n    mapping(address => bool) public hasUserReferee;\\r\\n\\r\\n    constructor(){\\r\\n        isAnchorManager[owner()] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev create a new referral anchor on the registry\\r\\n    /// @param _user address of the user\\r\\n    /// @param _referee address wich referred the user\\r\\n    function createReferralAnchor(address _user, string calldata _referee) external onlyAnchorManager {\\r\\n        require(!hasUserReferee[_user], \\\"ReferralRegistry: ANCHOR_EXISTS\\\");\\r\\n        require(referralCodeAddress[_referee] != address(0), \\\"ReferralRegistry: Referral code invalid\\\");\\r\\n        referralAnchor[_user] = _referee;\\r\\n        emit ReferralAnchorCreated(_user, _referee);\\r\\n    }\\r\\n\\r\\n    /// @dev allows admin to overwrite anchor\\r\\n    /// @param _user address of the user\\r\\n    /// @param _referee address wich referred the user\\r\\n    function updateReferralAnchor(address _user, string calldata _referee) external onlyOwner {\\r\\n        referralAnchor[_user] = _referee;\\r\\n        emit ReferralAnchorUpdated(_user, _referee);\\r\\n    }\\r\\n\\r\\n    /// @dev allows admin to grant/remove anchor priviliges\\r\\n    /// @param _anchorManager address of the anchor manager\\r\\n    /// @param _isManager add or remove privileges\\r\\n    function updateAnchorManager(address _anchorManager, bool _isManager) external onlyOwner {\\r\\n        isAnchorManager[_anchorManager] = _isManager;\\r\\n        emit AnchorManagerUpdated(_anchorManager, _isManager);\\r\\n    }\\r\\n\\r\\n    function getUserReferee(address _user) external view returns (string memory) {\\r\\n        return referralAnchor[_user];\\r\\n    }\\r\\n\\r\\n    function setUserHasReferee(address _user) external onlyAnchorManager {\\r\\n        hasUserReferee[_user] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyAnchorManager() {\\r\\n        require(isAnchorManager[msg.sender], \\\"ReferralRegistry: FORBIDDEN\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function allocateForReferree(string calldata _referralCode) external payable {\\r\\n        referreeOwedAmount[referralCodeAddress[_referralCode]] += msg.value;\\r\\n        referreeTotalRaisedAmount[referralCodeAddress[_referralCode]] += msg.value;\\r\\n    }\\r\\n\\r\\n    function referreeWithdraw() external {\\r\\n        uint256 amountOwed = referreeOwedAmount[msg.sender];\\r\\n        referreeOwedAmount[msg.sender] = 0;\\r\\n        bool success;\\r\\n        (success, ) = address(msg.sender).call{value: amountOwed}(\\\"\\\");\\r\\n    }\\r\\n\\r\\n    function fetchReferralAddress(string calldata _referralCode) external view returns (address){\\r\\n        return referralCodeAddress[_referralCode];\\r\\n    }\\r\\n\\r\\n    function createReferralCode(string calldata _referralCode, address _refereeAddress) external onlyOwner {\\r\\n        require(referralCodeAddress[_referralCode] == address(0), \\\"referral code already used\\\");\\r\\n        referralCodeAddress[_referralCode] = _refereeAddress;\\r\\n    }\\r\\n\\r\\n    function incrementReferralAmount(string calldata _referralCode) external onlyAnchorManager {\\r\\n        walletReferralAmount[_referralCode] += 1;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract ViralXRewards is Ownable {\\r\\n\\r\\n    using EnumerableSet for EnumerableSet.UintSet;\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\r\\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\r\\n    event RewardDistributed(\\r\\n        address indexed from,\\r\\n        uint256 weiAmount\\r\\n    );\\r\\n    event RewardWithdrawn(\\r\\n        address indexed to,\\r\\n        uint256 weiAmount\\r\\n    );\\r\\n\\r\\n    event PoolCreated(PoolInfo pool);\\r\\n\\r\\n    mapping (address => bool) public authorized;\\r\\n    bool public publicCreationAllowed;\\r\\n    \\r\\n    uint256 public feePercent;\\r\\n    address public feeReceiverEth;\\r\\n    address public feeReceiverTokens;\\r\\n    uint256 public poolCreationFee;\\r\\n    uint256 public poolAdditionalWeekCost;\\r\\n    \\r\\n    ReferralRegistry public referralRegistry;\\r\\n    uint256 public referralDiscount = 10; // 10% discount\\r\\n    uint256 public referralCommission = 20; // 20% discount\\r\\n    \\r\\n    PoolInfo[] public poolsInfo;\\r\\n    \\r\\n    mapping (address => mapping(uint256 => uint256)) public userOwedAmount;\\r\\n    mapping (address => mapping(uint256 => uint256)) public userClaimedAmount;\\r\\n\\r\\n    mapping (address => EnumerableSet.UintSet) private userClaimablePools;\\r\\n    mapping (address => EnumerableSet.UintSet) private userClaimedPools;\\r\\n    mapping (uint256 => EnumerableSet.AddressSet) private poolRewardRecipients;\\r\\n\\r\\n    struct PoolInfo {\\r\\n        uint256 poolId;\\r\\n        string projectName;\\r\\n        uint64 poolStartTime;\\r\\n        uint48 poolDuration;\\r\\n        bool payoutIsEth;\\r\\n        address rewardAddress;\\r\\n        uint256 amountForReward;\\r\\n        uint256 amountDistributed;\\r\\n        uint8 amountOfPeopleToPay;\\r\\n    }\\r\\n\\r\\n    constructor(){\\r\\n        authorized[msg.sender] = true;\\r\\n        poolCreationFee = 0.4 ether;\\r\\n        poolAdditionalWeekCost = 0.1 ether;\\r\\n        feePercent = 10;\\r\\n        feeReceiverEth = address(msg.sender);\\r\\n        feeReceiverTokens = address(msg.sender);\\r\\n        referralRegistry = new ReferralRegistry();\\r\\n        referralRegistry.createReferralCode(\\\"\\\", address(this));\\r\\n    }\\r\\n\\r\\n    // @dev used to create pools.  If public creation is not allowed, only authorized addresses can create pools.  If public creation is allowed, a value must be passed in the amount of the creation fee.\\r\\n\\r\\n    function createPool(string memory _poolName, uint64 _poolStartTime, uint48 _poolDuration, bool _payoutIsEth, address _rewardAddress, uint8 _amountOfPeopleToPay, string memory _referralCode) external payable {\\r\\n        \\r\\n        if(!authorized[msg.sender]){\\r\\n            uint256 amountForReferral;\\r\\n            bool success;\\r\\n            require(publicCreationAllowed, \\\"Public creation not allowed\\\");\\r\\n            require(_poolStartTime >= block.timestamp, \\\"Pool must start in the future\\\");\\r\\n            require(_poolDuration >= 1 weeks, \\\"Pool must last at least 1 week\\\");\\r\\n            require(_poolDuration % 1 weeks == 0, \\\"Pool duration must be divisible evenly by 1 week\\\");\\r\\n            uint256 poolDurationCost = (_poolDuration / 1 weeks - 1) * poolAdditionalWeekCost;\\r\\n            uint256 owedFee = poolCreationFee + poolDurationCost;\\r\\n            \\r\\n            // create referrral anchor and take referral fees\\r\\n            if(!referralRegistry.hasUserReferee(msg.sender)){\\r\\n                referralRegistry.createReferralAnchor(msg.sender, _referralCode);\\r\\n                referralRegistry.setUserHasReferee(msg.sender);\\r\\n            }\\r\\n            address userReferee = referralRegistry.fetchReferralAddress(referralRegistry.getUserReferee(msg.sender));\\r\\n            string memory userRefereeString = referralRegistry.getUserReferee(msg.sender);\\r\\n\\r\\n            if(userReferee != address(this) && userReferee != address(0)){\\r\\n                owedFee -= (owedFee * referralDiscount / 100);\\r\\n                referralRegistry.incrementReferralAmount(userRefereeString);\\r\\n\\r\\n                amountForReferral = owedFee * referralCommission / 100;\\r\\n\\r\\n                if(amountForReferral > 0){\\r\\n                    (success, ) = referralRegistry.referralCodeAddress(userRefereeString).call{value: amountForReferral}(\\\"\\\");\\r\\n                    require(success, \\\"Distribution failed\\\");\\r\\n                }\\r\\n            }\\r\\n            require(msg.value >= owedFee, \\\"Must pay fee\\\");\\r\\n            (success,) = feeReceiverEth.call{value: msg.value - amountForReferral}(\\\"\\\");\\r\\n        }\\r\\n        PoolInfo memory poolInfoMem;\\r\\n        poolInfoMem.poolId = poolsInfo.length;\\r\\n        poolInfoMem.projectName = _poolName;\\r\\n        poolInfoMem.poolDuration = _poolDuration;\\r\\n        poolInfoMem.poolStartTime = _poolStartTime;\\r\\n        poolInfoMem.payoutIsEth = _payoutIsEth;\\r\\n        if(!_payoutIsEth){\\r\\n            poolInfoMem.rewardAddress = _rewardAddress;\\r\\n        } else {\\r\\n            poolInfoMem.rewardAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n        }\\r\\n        poolInfoMem.amountOfPeopleToPay = _amountOfPeopleToPay;\\r\\n        emit PoolCreated(poolInfoMem);\\r\\n        poolsInfo.push(poolInfoMem);\\r\\n    }\\r\\n\\r\\n    // @dev allows anyone to deposit tokens or ETH to an existing pool.\\r\\n\\r\\n    function deposit(uint256 poolId, uint256 amount) external payable {\\r\\n        PoolInfo memory poolInfoMem = poolsInfo[poolId];\\r\\n        if(poolInfoMem.payoutIsEth){\\r\\n            uint256 amountForFee = msg.value * feePercent / 100;\\r\\n            if(amountForFee > 0){\\r\\n                (bool success,) = feeReceiverEth.call{value: amountForFee}(\\\"\\\");\\r\\n                require(success, \\\"Distribution failed\\\");\\r\\n            }\\r\\n            poolInfoMem.amountForReward += msg.value - amountForFee;\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"Don't send a value for token deposits\\\");\\r\\n            uint256 amountForFee = amount * feePercent / 100;\\r\\n            SafeERC20.safeTransferFrom(IERC20(poolInfoMem.rewardAddress), msg.sender, address(this), amount);\\r\\n            if(amountForFee > 0){\\r\\n                SafeERC20.safeTransfer(IERC20(poolInfoMem.rewardAddress), feeReceiverTokens, amountForFee);\\r\\n            }\\r\\n            poolInfoMem.amountForReward += amount - amountForFee;\\r\\n        }\\r\\n        poolsInfo[poolId] = poolInfoMem;\\r\\n    }\\r\\n\\r\\n    // @dev Used by team to set rewards for individual pools for distribution\\r\\n\\r\\n    function setRewards(uint256 poolId, uint256[] calldata amounts, address[] calldata wallets) external onlyAuthorized {\\r\\n        uint256 amountToDistributeTotal;\\r\\n        uint256 amount;\\r\\n        address wallet;\\r\\n        PoolInfo memory poolInfoMem = poolsInfo[poolId];\\r\\n        require(amounts.length == wallets.length, \\\"Array length mismatch\\\");\\r\\n        for(uint256 i = 0; i < amounts.length; i++){\\r\\n            amount = amounts[i];\\r\\n            wallet = wallets[i];\\r\\n            amountToDistributeTotal += amount;\\r\\n            userOwedAmount[wallet][poolId] += amount;\\r\\n            if(!userClaimablePools[wallet].contains(poolId)){\\r\\n                userClaimablePools[wallet].add(poolId);\\r\\n            }\\r\\n            if(!poolRewardRecipients[poolId].contains(wallet)){\\r\\n                poolRewardRecipients[poolId].add(wallet);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        poolInfoMem.amountDistributed += amountToDistributeTotal;\\r\\n        require(poolInfoMem.amountDistributed <= poolInfoMem.amountForReward, \\\"Too many rewards distributed\\\");\\r\\n        poolsInfo[poolId] = poolInfoMem;\\r\\n    }\\r\\n\\r\\n    // @dev allows user to claim from a single pool\\r\\n\\r\\n    function claimByPool(uint256 poolId) public {\\r\\n        PoolInfo memory poolInfoMem = poolsInfo[poolId];\\r\\n        require(userClaimablePools[msg.sender].contains(poolId), \\\"Invalid pool to claim from\\\");\\r\\n        uint256 amountOwed = userOwedAmount[msg.sender][poolId] - userClaimedAmount[msg.sender][poolId];\\r\\n        require(amountOwed > 0, \\\"Nothing to claim\\\");\\r\\n        userClaimedAmount[msg.sender][poolId] += amountOwed;\\r\\n        userClaimablePools[msg.sender].remove(poolId);\\r\\n        userClaimedPools[msg.sender].add(poolId); \\r\\n        if(poolInfoMem.payoutIsEth){\\r\\n            (bool success,) = msg.sender.call{value: amountOwed}(\\\"\\\");\\r\\n            require(success, \\\"Distribution failed\\\");\\r\\n        } else {\\r\\n            SafeERC20.safeTransfer(IERC20(poolInfoMem.rewardAddress), msg.sender, amountOwed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // @dev allows user to claim from all pools\\r\\n\\r\\n    function claimAll() external {\\r\\n        uint256[] memory poolsToClaim = getUserClaimablePools(msg.sender);\\r\\n        for(uint256 i = 0; i < poolsToClaim.length; i++){\\r\\n            claimByPool(poolsToClaim[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier onlyAuthorized(){\\r\\n        require(authorized[msg.sender] || msg.sender == owner(), \\\"Not Authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Views\\r\\n\\r\\n\\r\\n    function getUserClaimablePools(address user) public view returns (uint256[] memory){\\r\\n        return userClaimablePools[user].values();\\r\\n    }\\r\\n\\r\\n    function getUserClaimedPools(address user) external view returns (uint256[] memory){\\r\\n        return userClaimedPools[user].values();\\r\\n    }\\r\\n\\r\\n    function getPoolRewardRecipients(uint256 pool) external view returns (address[] memory){\\r\\n        return poolRewardRecipients[pool].values();\\r\\n    }\\r\\n\\r\\n    \\r\\n    function poolLength() external view returns (uint256) {\\r\\n        return poolsInfo.length;\\r\\n    }\\r\\n\\r\\n    // Owner functions\\r\\n    \\r\\n    function setAuthorized(address _wallet, bool _authorized) external onlyOwner {\\r\\n        authorized[_wallet] = _authorized;\\r\\n    }\\r\\n\\r\\n    function updateFeeReceiverEth(address _feeReceiver) external onlyOwner {\\r\\n        require(_feeReceiver != address(0), \\\"Zero address\\\");\\r\\n        feeReceiverEth = _feeReceiver;\\r\\n    }\\r\\n\\r\\n    function updateFeeReceiverTokens(address _feeReceiver) external onlyOwner {\\r\\n        require(_feeReceiver != address(0), \\\"Zero address\\\");\\r\\n        feeReceiverTokens = _feeReceiver;\\r\\n    }\\r\\n\\r\\n    function updateFee(uint256 _feePercent) external onlyOwner {\\r\\n        require(_feePercent < 20, \\\"Cannot set fee higher than 20%\\\");\\r\\n        feePercent = _feePercent;\\r\\n    }\\r\\n\\r\\n    function updatePoolCreationFees(uint256 _poolCreationFee, uint256 _poolAdditionalWeekCost) external onlyOwner {\\r\\n        poolCreationFee = _poolCreationFee;\\r\\n        poolAdditionalWeekCost = _poolAdditionalWeekCost;\\r\\n    }\\r\\n\\r\\n    function updatePublicCreationAllowed(bool _publicCreationAllowed) external onlyOwner {\\r\\n        publicCreationAllowed = _publicCreationAllowed;\\r\\n    }\\r\\n\\r\\n\\r\\n    // referral functions \\r\\n\\r\\n    function updateReferralDiscount(uint256 _newDiscountPerc) external onlyOwner {\\r\\n        require(_newDiscountPerc <= 50, \\\"Cannot do discount higher than 50%\\\");\\r\\n        referralDiscount = _newDiscountPerc;\\r\\n    }\\r\\n\\r\\n    function updateReferralCommission(uint256 _newCommissionPerc) external onlyOwner {\\r\\n        require(_newCommissionPerc <= 50, \\\"Cannot do commission higher than 50%\\\");\\r\\n        referralCommission = _newCommissionPerc;\\r\\n    }\\r\\n\\r\\n    function checkReferralCodeAvailable(string calldata _referralCode) external view returns (bool){\\r\\n        return (referralRegistry.fetchReferralAddress(_referralCode) != address(0));\\r\\n    }\\r\\n\\r\\n    function createReferralCode(string calldata _referralCode) external {\\r\\n        require(referralRegistry.fetchReferralAddress(_referralCode) == address(0), \\\"Code already used\\\");\\r\\n        referralRegistry.createReferralCode(_referralCode, msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @dev allows admin to overwrite anchor (only use in specific circumstances)\\r\\n    /// @param _user address of the user\\r\\n    /// @param _referee address wich referred the user\\r\\n    function updateReferralAnchor(address _user, string calldata _referee) external onlyOwner {\\r\\n        referralRegistry.updateReferralAnchor(_user, _referee);\\r\\n    }\\r\\n\\r\\n    /// @dev allows admin to grant/remove anchor privileges (to add new contracts if needed)\\r\\n    /// @param _anchorManager address of the anchor manager\\r\\n    /// @param _isManager add or remove privileges\\r\\n    function updateAnchorManager(address _anchorManager, bool _isManager) external onlyOwner {\\r\\n        referralRegistry.updateAnchorManager(_anchorManager, _isManager);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"projectName\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"poolStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"poolDuration\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"payoutIsEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountForReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"amountOfPeopleToPay\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct ViralXRewards.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"RewardDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_referralCode\",\"type\":\"string\"}],\"name\":\"checkReferralCodeAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"claimByPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_poolName\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"_poolStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"_poolDuration\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"_payoutIsEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_amountOfPeopleToPay\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_referralCode\",\"type\":\"string\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_referralCode\",\"type\":\"string\"}],\"name\":\"createReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiverEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiverTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"getPoolRewardRecipients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserClaimablePools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserClaimedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAdditionalWeekCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCreationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolsInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"projectName\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"poolStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"poolDuration\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"payoutIsEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountForReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"amountOfPeopleToPay\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicCreationAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralRegistry\",\"outputs\":[{\"internalType\":\"contract ReferralRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"}],\"name\":\"setAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_anchorManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isManager\",\"type\":\"bool\"}],\"name\":\"updateAnchorManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeReceiverEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeReceiverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolCreationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolAdditionalWeekCost\",\"type\":\"uint256\"}],\"name\":\"updatePoolCreationFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_publicCreationAllowed\",\"type\":\"bool\"}],\"name\":\"updatePublicCreationAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_referee\",\"type\":\"string\"}],\"name\":\"updateReferralAnchor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCommissionPerc\",\"type\":\"uint256\"}],\"name\":\"updateReferralCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDiscountPerc\",\"type\":\"uint256\"}],\"name\":\"updateReferralDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOwedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ViralXRewards", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}