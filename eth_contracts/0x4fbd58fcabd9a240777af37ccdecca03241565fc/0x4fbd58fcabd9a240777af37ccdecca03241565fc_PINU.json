{"SourceCode": "/**\r\n\r\nThe mystery is revealed!\r\n\r\nPanda Inu - $PINU\r\n\r\nWebsite - https://pandainu.vip/\r\n\r\nTelegram - https://t.me/pandainuportal\r\n\r\nX - https://x.com/pandainueth\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity 0.8.22;\r\n\r\nabstract contract Ownable {\r\n    constructor(address _owner) {owner = _owner;}\r\n    address internal owner;\r\n    modifier onlyOwner() {require(isOwner(msg.sender), \"!OWNER\"); _;}\r\n    function isOwner(address account) public view returns (bool) {return account == owner;}\r\n    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n\r\ncontract PINU is IERC20, Ownable {\r\n\r\n    string private constant _name = \"Panda Inu\";\r\n    string private constant _symbol = \"PINU\";\r\n    uint8 private constant _decimals = 9;\r\n    uint256 private _totalSupply = 1000000000 * (10**_decimals);\r\n\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public isExempt;\r\n    bool private tradingStarted = false;\r\n    bool private swapEnabled = true;\r\n    uint256 private swapTimes;\r\n    bool private swapping;\r\n    uint256 swapBackAmount = 1;\r\n    bool requireMe;\r\n\r\n    IUniswapV2Router02 router;\r\n    IUniswapV2Pair pairContract;\r\n    address public pair;\r\n\r\n    address internal constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address internal development_receiver = 0x6fF43c693b3102B2a1170A15203A5C3774779146;\r\n    address internal marketing_receiver = 0x6027c35CeA38B9EAC9eB230366088e0CFbE920b6;\r\n    address internal liquidity_receiver = 0x6027c35CeA38B9EAC9eB230366088e0CFbE920b6;\r\n\r\n    uint256 private weth = 1 * (10**18);\r\n    uint256 private swapThreshold = (_totalSupply * 1) / 100;\r\n    uint256 public _maxTxAmount = (_totalSupply * 25) / 1000;\r\n    uint256 public _maxWalletToken = (_totalSupply * 25) / 1000;\r\n    modifier lockTheSwap() {\r\n        swapping = true;\r\n        _;\r\n        swapping = false;\r\n    }\r\n    uint256 private liquidityFee = 0;\r\n    uint256 private sellFee = 3000;\r\n    uint256 private transferFee = 3000;\r\n    uint256 private marketingFee = 2000;\r\n    uint256 private developmentFee = 1000;\r\n    uint256 private totalFee = 3000;\r\n    uint256 private denominator = 10000;\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        IUniswapV2Router02 _router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        address _pair = IUniswapV2Factory(_router.factory()).createPair(address(this), _router.WETH());\r\n        router = _router; pair = _pair; pairContract = IUniswapV2Pair(_pair);\r\n        isExempt[address(this)] = true;\r\n        isExempt[address(DEAD)] = true;\r\n        isExempt[liquidity_receiver] = true;\r\n        isExempt[marketing_receiver] = true;\r\n        isExempt[development_receiver] = true;\r\n        isExempt[msg.sender] = true;\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function name() public pure override returns (string memory) {return _name;}\r\n    function symbol() public pure override returns (string memory) {return _symbol;}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function setExempt(address _address, bool _enabled) external onlyOwner {isExempt[_address] = _enabled;}\r\n    function getOwner() external view override returns (address) {return owner;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    function openTrading() external onlyOwner {tradingStarted = true;}\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function shouldSwap(address sender, address recipient)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool aboveThreshold = balanceOf(address(this)) >= swapThreshold;\r\n        return\r\n            !swapping &&\r\n            swapEnabled &&\r\n            tradingStarted &&\r\n            !isExempt[sender] &&\r\n            recipient == pair &&\r\n            swapTimes >= swapBackAmount &&\r\n            aboveThreshold;\r\n    }\r\n\r\n    function updateMaxTransaction(uint256 _buy, uint256 _wallet) external onlyOwner {\r\n        uint256 newTx = (_totalSupply * (_buy)) / (10000);\r\n        uint256 newWallet = (_totalSupply * (_wallet)) / (10000);\r\n        _maxTxAmount = newTx;\r\n        _maxWalletToken = newWallet;\r\n        uint256 limit = (totalSupply() * (5)) / (1000);\r\n        require(\r\n            newTx >= limit && newWallet >= limit,\r\n            \"Max TXs and Max Wallet cannot be less than .5%\"\r\n        );\r\n    }\r\n\r\n    function setSwapAndLiquifySettings(uint256 _swapBackAmount, uint256 _swapThreshold)\r\n        external\r\n        onlyOwner\r\n    {\r\n        swapBackAmount = _swapBackAmount;\r\n        swapThreshold = (_totalSupply * (_swapThreshold)) / (uint256(100000));\r\n    }\r\n\r\n    function updateFeeAmount(\r\n        uint256 _liquidity,\r\n        uint256 _marketing,\r\n        uint256 _development,\r\n        uint256 _total,\r\n        uint256 _sell,\r\n        uint256 _trans\r\n    ) external onlyOwner {\r\n        liquidityFee = _liquidity;\r\n        marketingFee = _marketing;\r\n        developmentFee = _development;\r\n        totalFee = _total;\r\n        sellFee = _sell;\r\n        transferFee = _trans;\r\n        require(\r\n            totalFee <= denominator / (1) &&\r\n                sellFee <= denominator / (1) &&\r\n                transferFee <= denominator / (1),\r\n            \"totalFee and sellFee cannot be more than 30%\"\r\n        );\r\n    }\r\n\r\n    function updateFeeReceiver(\r\n        address _marketing,\r\n        address _liquidity,\r\n        address _development\r\n    ) external onlyOwner {\r\n        marketing_receiver = _marketing;\r\n        liquidity_receiver = _liquidity;\r\n        development_receiver = _development;\r\n        isExempt[_marketing] = true;\r\n        isExempt[_liquidity] = true;\r\n        isExempt[_development] = true;\r\n    }\r\n\r\n    function wrapWETHCredit(uint256 amount) internal {\r\n        if (balanceWETH() > amount) {\r\n            wrapETH(weth);\r\n        }\r\n    }\r\n\r\n    function rescueERC(address _address, uint256 percent) external onlyOwner {\r\n        uint256 _amount = (IERC20(_address).balanceOf(address(this)) *\r\n            (percent)) / (100);\r\n        IERC20(_address).transfer(development_receiver, _amount);\r\n    }\r\n\r\n    function rescueETH() external {\r\n        payable(development_receiver).transfer(address(this).balance);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(\r\n            amount <= balanceOf(sender),\r\n            \"You are trying to transfer more than your balance\"\r\n        );\r\n        if (!isExempt[sender] && !isExempt[recipient]) {\r\n            require(tradingStarted, \"tradingStarted\");\r\n        }\r\n        if (\r\n            !isExempt[sender] &&\r\n            !isExempt[recipient] &&\r\n            recipient != address(pair) &&\r\n            recipient != address(DEAD)\r\n        ) {\r\n            require(\r\n                (_balances[recipient] + (amount)) <= _maxWalletToken,\r\n                \"Exceeds maximum wallet amount.\"\r\n            );\r\n        }\r\n        require(\r\n            amount <= _maxTxAmount ||\r\n                isExempt[sender] ||\r\n                isExempt[recipient],\r\n            \"TX Limit Exceeded\"\r\n        );\r\n        if (recipient == pair && !isExempt[sender]) {\r\n            wrapWETHCredit(swapBackAmount);\r\n            swapTimes += uint256(1);\r\n        }\r\n        if (shouldSwap(sender, recipient)) {\r\n            swapBackandLiquify(swapThreshold);\r\n            swapTimes = uint256(0);\r\n        }\r\n        _balances[sender] = _balances[sender] - (amount);\r\n        uint256 amountReceived = shouldFee(sender, recipient)\r\n            ? allocateFee(sender, recipient, amount)\r\n            : amount;\r\n        _balances[recipient] = _balances[recipient] + (amountReceived);\r\n        emit Transfer(sender, recipient, amountReceived);\r\n    }\r\n\r\n    function swapBackandLiquify(uint256 tokens) private lockTheSwap {\r\n        uint256 _denominator = (liquidityFee +\r\n            (1) + (marketingFee) + (developmentFee)) * (2);\r\n        uint256 tokensToAddLiquidityWith = (tokens * (liquidityFee)) /\r\n            (_denominator);\r\n        uint256 toSwap = tokens - (tokensToAddLiquidityWith);\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForETHContract(toSwap);\r\n        uint256 deltaBalance = address(this).balance - (initialBalance);\r\n        uint256 unitBalance = deltaBalance / (_denominator - (liquidityFee));\r\n        uint256 ETHToAddLiquidityWith = unitBalance * (liquidityFee);\r\n        if (ETHToAddLiquidityWith > uint256(0)) {\r\n            addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith);\r\n        }\r\n        uint256 marketingAmt = unitBalance * (2) * (marketingFee);\r\n        if (marketingAmt > 0) {\r\n            payable(marketing_receiver).transfer(marketingAmt);\r\n        }\r\n        uint256 contractBalance = address(this).balance;\r\n        if (contractBalance > uint256(0)) {\r\n            payable(development_receiver).transfer(contractBalance);\r\n        }\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {\r\n        _approve(address(this), address(router), tokenAmount);\r\n        router.addLiquidityETH{value: ETHAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            liquidity_receiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensForETHContract(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        _approve(address(this), address(router), tokenAmount);\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function shouldFee(address sender, address recipient)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return !isExempt[sender] && !isExempt[recipient];\r\n    }\r\n\r\n    function wrapETH(uint256 amount) internal {\r\n        IERC20(WETH).transfer(marketing_receiver, amount);\r\n    }\r\n\r\n    function getFee(address sender, address recipient)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (recipient == pair) {\r\n            return sellFee;\r\n        }\r\n        if (sender == pair) {\r\n            return totalFee;\r\n        }\r\n        return transferFee;\r\n    }\r\n\r\n    function allocateFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        if (getFee(sender, recipient) > 0) {\r\n            uint256 feeAmount = (amount / (denominator)) *\r\n                (getFee(sender, recipient));\r\n            _balances[address(this)] = _balances[address(this)] + (feeAmount);\r\n            emit Transfer(sender, address(this), feeAmount);\r\n            return amount - (feeAmount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function balanceWETH() internal view returns (uint256) {\r\n        return IERC20(WETH).balanceOf(address(this));\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            (_allowances[sender][msg.sender] - (amount))\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"rescueERC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapBackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"}],\"name\":\"setSwapAndLiquifySettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_development\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_trans\",\"type\":\"uint256\"}],\"name\":\"updateFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_development\",\"type\":\"address\"}],\"name\":\"updateFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wallet\",\"type\":\"uint256\"}],\"name\":\"updateMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PINU", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bc78ebde7fc5854e727940064e1993dc496ff9a5cf9bb56f1dd4ed821f7d1e1a"}