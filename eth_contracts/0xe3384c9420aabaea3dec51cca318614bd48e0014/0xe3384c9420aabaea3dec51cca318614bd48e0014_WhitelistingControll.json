{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/accountAbstraction/compliance/libraries/ProtocolsRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    ProtocolIsNotSupported,\\n    ProtocolIsSuspended,\\n    Status\\n} from \\\"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\\\";\\n\\nlibrary StringTruncatedHash {\\n    function truncatedHash(string memory _self) internal pure returns (bytes31) {\\n        return bytes31(keccak256(bytes(_self)));\\n    }\\n}\\n\\nlibrary ProtocolsRepository {\\n    using StringTruncatedHash for string;\\n\\n    struct Protocol {\\n        address evaluator;\\n        Status status;\\n    }\\n\\n    struct Operator {\\n        bytes31 protocolNameHash;\\n        Status status;\\n    }\\n\\n    struct Storage {\\n        mapping(bytes31 protocolNameHash => Protocol) protocols;\\n        mapping(address externalOperator => Operator) operators;\\n    }\\n\\n    bytes32 private constant STORAGE_SLOT = keccak256(\\\"Supported Protocols repository slot V1\\\");\\n\\n    error ProtocolMustNotBeEmptyString();\\n\\n    /// @dev We mark protocol as memory here to make unit testing easier\\n    function updateProtocolSupport(\\n        string memory _protocol,\\n        address _adapterEvaluator,\\n        bool _supported\\n    ) internal returns (bool storageModified_) {\\n        if (bytes(_protocol).length == 0) revert ProtocolMustNotBeEmptyString();\\n        Protocol storage prot = protocol(_protocol);\\n        if (\\n            _supported && (prot.status != Status.Supported || prot.evaluator != _adapterEvaluator)\\n        ) {\\n            prot.status = Status.Supported;\\n            prot.evaluator = _adapterEvaluator;\\n            storageModified_ = true;\\n        } else if (!_supported && prot.status == Status.Supported) {\\n            prot.status = Status.Suspended;\\n            storageModified_ = true;\\n        }\\n    }\\n\\n    /// @dev We mark protocol as memory here to make unit testing easier\\n    function updateOperatorSupport(\\n        string memory _protocol,\\n        address _source,\\n        bool _supported\\n    ) internal returns (bool storageModified_) {\\n        if (bytes(_protocol).length == 0) revert ProtocolMustNotBeEmptyString();\\n        Operator storage op = operator(_source);\\n        bytes31 protHash = _protocol.truncatedHash();\\n\\n        if (_supported && (op.status != Status.Supported || op.protocolNameHash != protHash)) {\\n            op.protocolNameHash = protHash;\\n            op.status = Status.Supported;\\n            storageModified_ = true;\\n        } else if (!_supported && op.status == Status.Supported) {\\n            op.status = Status.Suspended;\\n            storageModified_ = true;\\n        }\\n    }\\n\\n    function enforceProtocolSupported(string calldata _protocol) internal view {\\n        Status status = getProtocolStatus(_protocol);\\n        if (status != Status.Supported) {\\n            if (status == Status.Suspended) revert ProtocolIsSuspended(_protocol);\\n            else revert ProtocolIsNotSupported(_protocol);\\n        }\\n    }\\n\\n    function enforceProtocolSupportedOrSuspended(string calldata _protocol) internal view {\\n        Status status = getProtocolStatus(_protocol);\\n        if (status == Status.Undefined) revert ProtocolIsNotSupported(_protocol);\\n    }\\n\\n    function getProtocolStatus(string calldata _protocol) internal view returns (Status) {\\n        return protocol(_protocol).status;\\n    }\\n\\n    function getProtocolEvaluator(string calldata _protocol) internal view returns (address) {\\n        return protocol(_protocol).evaluator;\\n    }\\n\\n    function getOperatorStatus(\\n        address _source\\n    ) internal view returns (Status operator_, Status protocol_) {\\n        operator_ = operator(_source).status;\\n        protocol_ = _storage().protocols[operator(_source).protocolNameHash].status;\\n    }\\n\\n    function protocol(string memory _name) private view returns (Protocol storage) {\\n        return _storage().protocols[_name.truncatedHash()];\\n    }\\n\\n    function operator(address _source) private view returns (Operator storage) {\\n        return _storage().operators[_source];\\n    }\\n\\n    function _storage() private pure returns (Storage storage) {\\n        bytes32 storageSlot = STORAGE_SLOT;\\n        Storage storage state;\\n        assembly {\\n            state.slot := storageSlot\\n        }\\n        return state;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/compliance/libraries/TokensRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    Status,\\n    TokenIsNotSupported,\\n    TokenIsSuspended,\\n    TokenLevelInsufficient,\\n    TokenPermission\\n} from \\\"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\\\";\\n\\nlibrary TokensRepository {\\n    struct Token {\\n        Status status;\\n        TokenPermission perm;\\n    }\\n\\n    struct Storage {\\n        mapping(address source => Token) tokens;\\n    }\\n\\n    bytes32 private constant STORAGE_SLOT = keccak256(\\\"Supported Tokens repository slot V1\\\");\\n\\n    error CannotRecognizeTokenPermission(TokenPermission);\\n    /// @dev We can suspend token, but it's permission will never fall\\n    /// to None. None reserved for undefined case just because it would\\n    /// be strange to return TradeOnly permission for undefined tokens.\\n    error CannotSetPermissionToNone(address);\\n\\n    function updateTokenSupport(\\n        address token,\\n        bool supported,\\n        TokenPermission perm\\n    ) internal returns (bool storageModified) {\\n        bool s = updateTokenStatus(token, supported);\\n        bool p = updateTokenPerm(token, perm);\\n        storageModified = s || p;\\n    }\\n\\n    function enforceTokenSupported(address token) internal view {\\n        Status status = getTokenStatus(token);\\n        if (status != Status.Supported) {\\n            if (status == Status.Suspended) revert TokenIsSuspended(token);\\n            else revert TokenIsNotSupported(token);\\n        }\\n    }\\n\\n    function enforceTokenSupportedOrSuspended(address token) internal view {\\n        Status status = getTokenStatus(token);\\n        if (status == Status.Undefined) revert TokenIsNotSupported(token);\\n    }\\n\\n    function enforceTokenHasPermission(address token, TokenPermission required) internal view {\\n        TokenPermission current = getTokenPerm(token);\\n        if (current == required) return;\\n        // if not matched then we check levels\\n        if (getPermLevel(current) > getPermLevel(required)) return;\\n        // at this point we know that niether permissions matched\\n        // nor the current one is higher than required, so\\n        // it's either current is lower than the required (bad)\\n        // or equal to it which is only possible for level 2\\n        // which is not compatible (Collateral != Leverage)\\n        revert TokenLevelInsufficient(token, required, current);\\n    }\\n\\n    function getTokenStatus(address token) internal view returns (Status) {\\n        return _storage()[token].status;\\n    }\\n\\n    function getTokenPerm(address token) internal view returns (TokenPermission) {\\n        return _storage()[token].perm;\\n    }\\n\\n    function updateTokenStatus(\\n        address token,\\n        bool supported\\n    ) private returns (bool storageModified) {\\n        Status current = getTokenStatus(token);\\n        if (supported && current != Status.Supported) {\\n            _storage()[token].status = Status.Supported;\\n            storageModified = true;\\n        } else if (!supported && current == Status.Supported) {\\n            _storage()[token].status = Status.Suspended;\\n            storageModified = true;\\n        }\\n    }\\n\\n    function updateTokenPerm(\\n        address token,\\n        TokenPermission perm\\n    ) private returns (bool storageModified) {\\n        if (perm == TokenPermission.None) revert CannotSetPermissionToNone(token);\\n\\n        if (getTokenPerm(token) != perm) {\\n            _storage()[token].perm = perm;\\n            storageModified = true;\\n        }\\n    }\\n\\n    function _storage() private view returns (mapping(address => Token) storage) {\\n        bytes32 storageSlot = STORAGE_SLOT;\\n        Storage storage state;\\n        assembly {\\n            state.slot := storageSlot\\n        }\\n        return state.tokens;\\n    }\\n\\n    function getPermLevel(TokenPermission perm) private pure returns (uint256) {\\n        if (perm == TokenPermission.None) return 0;\\n        if (perm == TokenPermission.TradeOnly) return 1;\\n        if (perm == TokenPermission.Collateral) return 2;\\n        if (perm == TokenPermission.Leverage) return 2;\\n        if (perm == TokenPermission.FullAccess) return 3;\\n        revert CannotRecognizeTokenPermission(perm);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/compliance/WhitelistingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    IWhitelistingController,\\n    Status,\\n    TokenPermission,\\n    WhitelistingAddressRecord,\\n    WhitelistingTokenRecord\\n} from \\\"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\\\";\\nimport {AlreadyUpToDate} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\n\\nimport {OwnableReadonlyDS} from \\\"contracts/base/auth/OwnableReadonlyDS.sol\\\";\\n\\nimport {ProtocolsRepository} from \\\"./libraries/ProtocolsRepository.sol\\\";\\nimport {TokensRepository} from \\\"./libraries/TokensRepository.sol\\\";\\n\\ncontract WhitelistingController is IWhitelistingController, OwnableReadonlyDS {\\n    using ProtocolsRepository for string;\\n    using ProtocolsRepository for address;\\n    using TokensRepository for address;\\n\\n    function updateTokensSupport(\\n        WhitelistingTokenRecord[] calldata tokens\\n    ) external override onlyOwner {\\n        bool stateModified;\\n        for (uint256 i; i < tokens.length; i++) {\\n            WhitelistingTokenRecord calldata t = tokens[i];\\n            if (t.source.updateTokenSupport(t.supported, t.permission)) {\\n                stateModified = true;\\n                emit TokenSupportChanged(t.source, t.supported, t.permission);\\n            }\\n        }\\n        if (!stateModified) revert AlreadyUpToDate();\\n    }\\n\\n    function updateProtocolSupport(\\n        string calldata protocol,\\n        address adapter,\\n        bool supported\\n    ) external override onlyOwner {\\n        if (protocol.updateProtocolSupport(adapter, supported)) {\\n            emit ProtocolSupportChanged(protocol, supported);\\n        } else {\\n            revert AlreadyUpToDate();\\n        }\\n    }\\n\\n    function updateOperatorsSupport(\\n        string calldata protocol,\\n        WhitelistingAddressRecord[] calldata operators\\n    ) external override onlyOwner {\\n        bool stateModified;\\n        for (uint256 i; i < operators.length; i++) {\\n            if (protocol.updateOperatorSupport(operators[i].source, operators[i].supported)) {\\n                stateModified = true;\\n                emit OperatorSupportChanged(protocol, operators[i].source, operators[i].supported);\\n            }\\n        }\\n        if (!stateModified) revert AlreadyUpToDate();\\n    }\\n\\n    function enforceTokenHasPermission(address token, TokenPermission perm) external view override {\\n        token.enforceTokenHasPermission(perm);\\n    }\\n\\n    function getTokenSupport(\\n        address token\\n    ) external view override returns (Status, TokenPermission) {\\n        return (token.getTokenStatus(), token.getTokenPerm());\\n    }\\n\\n    function getProtocolStatus(string calldata protocol) external view override returns (Status) {\\n        return protocol.getProtocolStatus();\\n    }\\n\\n    function getProtocolEvaluator(\\n        string calldata protocol\\n    ) external view override returns (address) {\\n        return protocol.getProtocolEvaluator();\\n    }\\n\\n    function getOperatorStatus(\\n        address operator\\n    ) external view override returns (Status operatorStatus, Status protocolStatus) {\\n        return operator.getOperatorStatus();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/auth/OwnableReadonly.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {UnauthorizedAccount} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\nimport {Address} from \\\"contracts/libraries/Address.sol\\\";\\n\\n/**\\n * @dev We intentionally do not expose \\\"owner()\\\" publicly\\n * due to possible conflicts with \\\"OwnershipFacet\\\"\\n * https://github.com/mudgen/diamond-3-hardhat/blob/main/contracts/facets/OwnershipFacet.sol\\n */\\nabstract contract OwnableReadonly {\\n    using Address for bytes32;\\n\\n    modifier onlyOwner() {\\n        enforceIsContractOwner();\\n        _;\\n    }\\n\\n    function _owner() internal view returns (address) {\\n        return _ownerSlot().get();\\n    }\\n\\n    function _ownerSlot() internal pure virtual returns (bytes32);\\n\\n    function enforceIsContractOwner() private view {\\n        if (msg.sender != _owner()) revert UnauthorizedAccount(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/auth/OwnableReadonlyDS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {DiamondLibrary} from \\\"contracts/libraries/DiamondLibrary.sol\\\";\\nimport {OwnableReadonly} from \\\"./OwnableReadonly.sol\\\";\\n\\n/**\\n * @notice Use DiamondStorage's owner slot for OwnableReadonly\\n */\\nabstract contract OwnableReadonlyDS is OwnableReadonly {\\n    function _ownerSlot() internal pure override returns (bytes32 slot_) {\\n        DiamondLibrary.DiamondStorage storage ds = DiamondLibrary.diamondStorage();\\n        assembly {\\n            // DiamondLib will not change so it's safe to hardcode owner offset here\\n            let ownerOffsetInDiamondStorage := 4\\n            slot_ := add(ds.slot, ownerOffsetInDiamondStorage)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title Status\\n * @notice Enum representing status of a record (e.g., token, protocol, operator)\\n *  used for operation validation.\\n * @notice Validators must adhere to the following rules for different operations and contexts:\\n *  1) For exchanges: `operator`, `pool`, and `input token` *MAY* be either supported or suspended, but the `output token` *MUST* be supported.\\n *  2) For deposits: `operator`, `pool`, and every `token` in the `pool` *MUST* be supported.\\n *  3) For withdrawals: `operator`, `pool`, and each `token` *MAY* be either supported or suspended.\\n *\\n * @dev **Note** that deposit denotes **all** ways of aquiring liquidity such\\n * as token deposit, LP tokens stake, NFT mint etc.\\n */\\nenum Status {\\n    Undefined,\\n    Supported,\\n    Suspended\\n}\\n\\n/**\\n * @title WhitelistingAddressRecord\\n * @notice A struct to store an address and its support status.\\n * @dev This struct stores an address and its support status.\\n * @dev `source`: The address to be stored.\\n * @dev `supported`: Indicates whether the address is supported or not.\\n */\\nstruct WhitelistingAddressRecord {\\n    address source;\\n    bool supported;\\n}\\n\\n/**\\n * @title TokenPermission\\n * @notice This enum represents different levels of permission for a token, including trading, collateral, leverage, and full access.\\n * @dev `None`: Represents no permissions granted for the token.\\n * @dev `TradeOnly`: Represents the lowest permission level where you can only trade the token.\\n * @dev `Collateral`: Allows you to use the token as collateral.\\n * @dev `Leverage`: Allows you to leverage the token.\\n * @dev `FullAccess`: Represents the highest permission level where you have full access to trade, use as collateral, and leverage the token.\\n */\\nenum TokenPermission {\\n    None,\\n    TradeOnly,\\n    Collateral,\\n    Leverage,\\n    FullAccess\\n}\\n\\n/**\\n * @title WhitelistingTokenRecord\\n * @notice This struct stores an address and its support status for whitelisting, collateral and leverage.\\n * @dev `source`: The address of the token.\\n * @dev `supported`: Whether the token can be received from a protocol trades.\\n * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n */\\nstruct WhitelistingTokenRecord {\\n    address source;\\n    bool supported;\\n    TokenPermission permission;\\n}\\n\\n/**\\n * @notice An error indicating that a token is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported token is used.\\n * @dev `token`: The address of the unsupported token.\\n */\\nerror TokenIsNotSupported(address token);\\n\\n/**\\n * @notice An error indicating that a token is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended token is used.\\n * @dev `token`: The address of the suspended token.\\n */\\nerror TokenIsSuspended(address token);\\n\\n/**\\n * @notice An error indicating that the token's permission level is insufficient for the requested action.\\n * @dev This can be thrown at [`IWhitelistingController.enforceTokenHasPermission()`](./interface.IWhitelistingController.html#enforcetokenhaspermission)\\n * @param token The address of the token that has insufficient permissions.\\n * @param required The required permission level for the action.\\n * @param actual The actual permission level of the token.\\n */\\nerror TokenLevelInsufficient(address token, TokenPermission required, TokenPermission actual);\\n\\n/**\\n * @notice An error indicating that an operator is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported operator is used.\\n * @dev `operator`: The address of the unsupported operator.\\n */\\nerror OperatorIsNotSupported(address operator);\\n\\n/**\\n * @notice An error indicating that an operator is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended operator is used.\\n * @dev `operator`: The address of the suspended operator.\\n */\\nerror OperatorIsSuspended(address operator);\\n\\n/**\\n * @notice An error indicating that a protocol is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsNotSupported(string protocol);\\n\\n/**\\n * @notice An error indicating that a protocol is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsSuspended(string protocol);\\n\\n/**\\n * @title IWhitelistingController\\n * @notice Interface for managing whitelisting of tokens, protocols, and operators.\\n */\\ninterface IWhitelistingController {\\n    /**\\n     * @dev Emitted when the support status of a protocol changes.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `supported`: Whether the protocol is supported or not.\\n     */\\n    event ProtocolSupportChanged(string indexed protocol, bool supported);\\n\\n    /**\\n     * @dev Emitted when the support status of a token changes.\\n     * @dev `token`: The address of the token.\\n     * @dev `supported`: Whether the token is supported or not.\\n     * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n     */\\n    event TokenSupportChanged(address indexed token, bool supported, TokenPermission permission);\\n\\n    /**\\n     * @dev Emitted when the support status of an operator changes for a specific protocol.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `operator`: The address of the operator.\\n     * @dev `supported`: Whether the operator is supported or not.\\n     */\\n    event OperatorSupportChanged(string indexed protocol, address indexed operator, bool supported);\\n\\n    /**\\n     * @notice Update the support status of multiple tokens.\\n     * @dev Emits a [`TokenSupportChanged()`](#tokensupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no token status changed.\\n     * @param _tokens An array of [`WhitelistingTokenRecord`](./struct.WhitelistingTokenRecord.html)\\n     * structs containing token addresses, support statuses and permissions.\\n     */\\n    function updateTokensSupport(WhitelistingTokenRecord[] calldata _tokens) external;\\n\\n    /**\\n     * @notice Update the support status of a protocol.\\n     * @dev Emits a [`ProtocolSupportChanged()`](#protocolsupportchanged) event.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if protocol status is up to date.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _adapterEvaluator The address of the adapter evaluator for the protocol.\\n     * @param _supported Whether the protocol is supported or not.\\n     */\\n    function updateProtocolSupport(\\n        string calldata _protocol,\\n        address _adapterEvaluator,\\n        bool _supported\\n    ) external;\\n\\n    /**\\n     * @notice Update the support status of multiple operators for a specific protocol.\\n     * @dev Emits a [`OperatorSupportChanged()`](#operatorsupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no operator status changed.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _operators An array of `WhitelistingAddressRecord` structs containing operator addresses and support statuses.\\n     */\\n    function updateOperatorsSupport(\\n        string calldata _protocol,\\n        WhitelistingAddressRecord[] calldata _operators\\n    ) external;\\n\\n    /**\\n     * @notice Ensures that a token has the specified permission level.\\n     * @dev This check does not enforce exact match, but only that level is sufficient.\\n     *  So if `permission` is TokenPermission.TradeOnly and the token has TokenPermission.Collateral\\n     *  then it assumes that level is sufficient since Collateral level includes both\\n     *  TradeOnly and Collateral levels.\\n     * @param token The address of the token to check for permission.\\n     * @param permission The required [`TokenPermission`](TokenPermission) to be enforced.\\n     */\\n    function enforceTokenHasPermission(address token, TokenPermission permission) external view;\\n\\n    /**\\n     * @notice Returns the support status of a token as well as it's permissions.\\n     * @param _token The address of the token.\\n     * @return The [`Status`](./enum.Status.html)\\n     * of the token.\\n     * @return The [`TokenPermission`](./enum.TokenPermission.html)\\n     * of the token.\\n     */\\n    function getTokenSupport(address _token) external view returns (Status, TokenPermission);\\n\\n    /**\\n     * @notice Returns the support status of a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getProtocolStatus(string calldata _protocol) external view returns (Status);\\n\\n    /**\\n     * @notice Returns the address of the adapter evaluator for a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The address of the adapter evaluator for the protocol.\\n     */\\n    function getProtocolEvaluator(string calldata _protocol) external view returns (address);\\n\\n    /**\\n     * @notice Returns the support status of an operator for a specific protocol.\\n     * @param _operator The address of the operator.\\n     * @return operatorStatus_ The [`Status`](./enum.Status.html)\\n     *  of the operator.\\n     * @return protocolStatus_ The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getOperatorStatus(\\n        address _operator\\n    ) external view returns (Status operatorStatus_, Status protocolStatus_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/base/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @notice An error indicating that the amount for the specified token is zero.\\n * @param token The address of the token with a zero amount.\\n */\\nerror AmountMustNotBeZero(address token);\\n\\n/**\\n * @notice An error indicating that an address must not be zero.\\n */\\nerror AddressMustNotBeZero();\\n\\n/**\\n * @notice An error indicating that an array must not be empty.\\n */\\nerror ArrayMustNotBeEmpty();\\n\\n/**\\n * @notice An error indicating storage is already up to date and doesn't need further processing.\\n * @dev This error is thrown when attempting to update an entity(s) that is(are) already up to date.\\n */\\nerror AlreadyUpToDate();\\n\\n/**\\n * @notice An error indicating that an action is unauthorized for the specified account.\\n * @param account The address of the unauthorized account.\\n */\\nerror UnauthorizedAccount(address account);\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Address {\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    function set(bytes32 _slot, address _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    function get(bytes32 _slot) internal view returns (address result_) {\\n        assembly {\\n            result_ := sload(_slot)\\n        }\\n    }\\n\\n    function isEth(address _token) internal pure returns (bool) {\\n        return _token == ETH || _token == address(0);\\n    }\\n\\n    function sort(address _a, address _b) internal pure returns (address, address) {\\n        return _a < _b ? (_a, _b) : (_b, _a);\\n    }\\n\\n    function sort(address[4] memory _array) internal pure returns (address[4] memory _sorted) {\\n        // Sorting network for the array of length 4\\n        (_sorted[0], _sorted[1]) = sort(_array[0], _array[1]);\\n        (_sorted[2], _sorted[3]) = sort(_array[2], _array[3]);\\n\\n        (_sorted[0], _sorted[2]) = sort(_sorted[0], _sorted[2]);\\n        (_sorted[1], _sorted[3]) = sort(_sorted[1], _sorted[3]);\\n        (_sorted[1], _sorted[2]) = sort(_sorted[1], _sorted[2]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DiamondLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary DiamondLibrary {\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    bytes32 private constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds_) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds_.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyUpToDate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum TokenPermission\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"CannotRecognizeTokenPermission\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"CannotSetPermissionToNone\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolMustNotBeEmptyString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"enum TokenPermission\",\"name\":\"required\",\"type\":\"uint8\"},{\"internalType\":\"enum TokenPermission\",\"name\":\"actual\",\"type\":\"uint8\"}],\"name\":\"TokenLevelInsufficient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"name\":\"OperatorSupportChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"name\":\"ProtocolSupportChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"enum TokenPermission\",\"name\":\"permission\",\"type\":\"uint8\"}],\"name\":\"TokenSupportChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"enum TokenPermission\",\"name\":\"perm\",\"type\":\"uint8\"}],\"name\":\"enforceTokenHasPermission\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getOperatorStatus\",\"outputs\":[{\"internalType\":\"enum Status\",\"name\":\"operatorStatus\",\"type\":\"uint8\"},{\"internalType\":\"enum Status\",\"name\":\"protocolStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"}],\"name\":\"getProtocolEvaluator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"}],\"name\":\"getProtocolStatus\",\"outputs\":[{\"internalType\":\"enum Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenSupport\",\"outputs\":[{\"internalType\":\"enum Status\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum TokenPermission\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"internalType\":\"struct WhitelistingAddressRecord[]\",\"name\":\"operators\",\"type\":\"tuple[]\"}],\"name\":\"updateOperatorsSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"name\":\"updateProtocolSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"},{\"internalType\":\"enum TokenPermission\",\"name\":\"permission\",\"type\":\"uint8\"}],\"internalType\":\"struct WhitelistingTokenRecord[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"name\":\"updateTokensSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WhitelistingController", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}