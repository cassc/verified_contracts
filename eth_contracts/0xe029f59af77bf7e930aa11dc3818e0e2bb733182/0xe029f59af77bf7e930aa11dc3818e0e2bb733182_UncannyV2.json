{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Uncanny.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/*\\n!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!!!!7!!!!!!!!!!!!!!!!!!!!~~!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!~!!!!~~!!!!!!!!!!!!!!!!!!!~G?~!!!!!!~!!!!!!!!!~~?7~!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~?J~~!!!!!!!!!~~!!!!!~!BY~!!!!!~!!!!!!!!!~!5G!~!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~7GG7~~!!!!!!~JJ~!!!!~!#G~!!!!~7B7~!!!!!~7GB!~!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~!5#Y!~!!!!!~?&J~!!!~!G5~!!!!~YP!~!!!!~?BB!~!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~~J#B?~!!!!!~YY~~~~~~~~~~~~~~!!~~~~!~?#B7~!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!~~!!!!~~7GB7~!!!~~~~!777??????777!!!777!!~?Y!~!!!~~~!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!~77!~~!!!~~!!!~~!7?JJ?77!~~~~~~~!77?J?!7?J?!~~!!!~!YJ~!!!!!!!!~~~!!!!!!!!!!!\\n!!!!!!!!!!!!!!!~~~!!!!!!~75PY!~!!~~~~!7JJ7~:................::::~^~J7~!!!~55!~!!!!!~~~7J5J!!!!!!!!!!\\n!!!!!!!!!!!!!~!J?7!~~~~!!~~7Y?~!!!~~7J7^........................7^^?J!~~!!!~~!!!~~~7JPPY7~!!!!!!!!!!\\n!!!!!!!!~~!!!!!7J5P5Y?!~~~~~~~~~~~~J?:..........................~^..~??!~!!!!!~~!JPB5?!~~!!!!!!!!!!!\\n!!!!!!~!!!!!!!!~~~!?5GBGY?????????JJ:...........................~^....~J?~~!!~?PBGJ!~~!!!!!!!!!~!!!!\\n!!!!!!!!!!!!!!!!~!7?JJJJ?777!!!!777!!!!!!~~^^:..................~:.....:?J~!!~Y57~~~!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!~7Y7~^:...............:::^^~!!!!!~^::...........:~........?J~!!~~~~~~~~!!!!!!!!!!!!!!\\n!!!!!!!!!!!!~!!!Y:............................:^~!!!!~^:.......~..........J7~!!~~!7?Y?!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!J.................^~7?JYYYYJJ?7!^^^^~~!!~^:...^:..........^Y~!~7PGPY?!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!~7?:............:?PB#&&&&&&&&&&&##BG5Y?7!~~~~^:.............J7~~!?7~~~!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!~7?!:.........^B&&###############&&&&&#BPY?!~~:............77~!~~~!!!!!!!!!!!!!!!!!!\\n~!!!!!!!!!!!!!!!!~~7?7~:......?&#######################&&&##P?7~...........77~!!!!!!!!!!!!!!!!!!!!!!\\n~!!!!!!!!!!!!!!!!!!~~!7?7!^:. J&############################&&#GY^.........?!~!!!~!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!~!!!!!!~~~!77?7!5&###############################&&BY^......:J~!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!~~~~!!P&#################################&&#GG5?^.?7~!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~~G&####################################&&&&BY?~!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~!B&########################################&#7~!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~7##########################################&B!~!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~?########################################&&G7~!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!~!!!!!!!~?###################################&&&##GJ!~!!!!!!!!!!!!!!!!!!~!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!~7###&#############################&#5??7!~~~!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~Y&###&&&&&&&&&&#################&B?~~~~~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!~!!!!!!!!!!!!~~Y#&############################B7~~~!!!!!!!!!!!!!!!!!!!!!!~!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!!~~~~~~!!~~75B&&&#######################&?~!77!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!!!!!!!!!~!7JJ7!~!!!~~!JPB#&&&&&&&#############&&#^..:~?!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!!~~~~~~!~?G#&&#B?~!!!!~~~!7?Y5GGPPB########&&&#B5?:....~J!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!!!!~!?YJ?!~7#&####&B!~~~~~~~!!7?!^. ~B&###&&&#GY7~:.......~???~~!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!!!~~~?B&&&#BYJ&#####&BJJ7!77??JJ~:..^!GBB#&&BY7^...........~?7!?J!~~~!!!!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!!~~!77G&####&&###B###G55PPJY5Y??:...~J?777JB7:............^7?777!?J7!!~~~!!!!!!!!!!!!!!!!!!!!!\\n!!!!!!~!5B#####&&#BPY7^:^^!PGB###&&#B?...:?7?7!7!?~..........:~7?7!7777!Y?????!!~!~!!!!!!!!!!!~!!!!!\\n!!!!!!~P&#####BP?~:.... .^?#&#######&B:..^?!J?77!J!.......^!7??777777!!?Y7!777?J7~~!!!!!!!!!!!!!~!!!\\n!!!!!!~P&#####BGP?....^7P#&######&&#G5!...77YY!77!.....^!??777!!!!777?JJ777777!7?J!~!!!!!!!!!!!!!!!!\\n!!!!!!~!YB####B55#J:75#&&######&#PY?77!~~~?7777~~:...^7?7777777????J??7!77777777!?J~!!!!!!!!!!!!!!!!\\n!!!!!!!~~5&#######BB&&#########57!!!77...!?77!?~.~^^7?7!77777!YY7777!777777777777!J7~!!!!!!!!~!!!!!!\\n!!!!!!!!~5&########&#########&G!!77777..!?!?7777..!J7!7777777!?J!7777777777777777!J?~!!~!!!!!!!!!!!!\\n!!!!!!!!~Y&##################&P77777?!.7?!?7777J.!?!77777777!7JJ!77777777777777777J?~!!!!!!!!!!!!!!!\\n!!!!!!!!~!B&################&BYJ!7777???!7?777!JJ?!7777777!7JJ?!77777777777777777!J7~!!!!!!!!!!!!!!!\\n!!!!!!!!!~7G&###############BJJY?!77757!77?7777J?!77777!77JJ7!7J7777777777777777777J~!!!!!!!!!!!!!!!\\n!!!!!!!!!!~!Y##############B7?J7Y?!7!J?!777777??!7777!7?J?7!77!JJ!7777777777777777!Y7~!!!!!!!!!!!!!!\\n!!!!!!!!!!!~~P&###########&P!J?!7Y?77?Y!777777?!77777JJ?7!7777!?Y!7777777777777777!J?~!!!!!!!!!!!!!!\\n\\nContract by @backseats_eth\\n*/\\n\\nimport \\\"@limitbreak/creator-token-contracts/contracts/examples/erc721c/ERC721CWithBasicRoyalties.sol\\\";\\nimport { console2 } from \\\"forge-std/Test.sol\\\"; // DEPLOY\\n\\ninterface IUncanny {\\n    function mint(address _to) external;\\n    function paidMint(address _to, uint _amount) external;\\n}\\n\\n// ERC721CWithBasicRoyalties contains OwnableBasic\\ncontract UncannyV2 is IUncanny, ERC721CWithBasicRoyalties {\\n\\n    // The address of the minting contract\\n    address public uncannyMinter;\\n\\n    address public teamWallet = 0x7AA0F5c54c1c52745E1ddc34DB82ee7FA816B6C3;\\n\\n    // The base URI for the token\\n    string public baseTokenURI;\\n\\n    // The total supply of the collection\\n    uint public totalSupply;\\n\\n    // The next token id to mint\\n    uint public nextTokenId;\\n\\n    // The max supply of the collection\\n    uint public constant MAX_SUPPLY = 2_462;\\n\\n    /// Errors\\n\\n    error ArrayEmpty();\\n    error CantMintThatMany();\\n    error LengthsDontMatch();\\n    error OnlyMinter();\\n\\n    /// Modifier\\n\\n    // Only the minter contract can mint\\n    modifier onlyMinter() {\\n        if (msg.sender != uncannyMinter) revert OnlyMinter();\\n        _;\\n    }\\n\\n    /// Constructor\\n\\n    constructor(address _royaltyReceiver, uint96 _royaltyFeeNumerator)\\n    ERC721CWithBasicRoyalties(_royaltyReceiver, _royaltyFeeNumerator, \\\"Uncanny\\\", \\\"UCC\\\") {\\n        // V1 had a bug with the counter, 616 have been minted to date. First one minted here will be 617.\\n        // https://www.contractreader.io/contract/mainnet/0x3eab42f5bf2f775e00b535ceab6555eb8a20a837\\n\\n        // Mint missing commons between 1 and 616\\n        _mint(teamWallet, 1);\\n        _mint(teamWallet, 43);\\n        _mint(teamWallet, 150);\\n        _mint(teamWallet, 262);\\n        _mint(teamWallet, 513);\\n        _mint(teamWallet, 606);\\n        _mint(teamWallet, 609);\\n\\n        // Mint all the 1/1s to the team wallet\\n        for(uint i = 2383; i <= 2462;) {\\n            _mint(teamWallet, i);\\n            unchecked { ++i; }\\n        }\\n\\n        totalSupply = 87;\\n        nextTokenId = 618;\\n    }\\n\\n    /// Minting\\n\\n    function mint(address _to) public onlyMinter() {\\n        if (totalSupply + 1 > MAX_SUPPLY) revert CantMintThatMany();\\n\\n        _regularMint(_to);\\n    }\\n\\n    function paidMint(address _to, uint _amount) public onlyMinter() {\\n        if (totalSupply + _amount > MAX_SUPPLY) revert CantMintThatMany();\\n\\n        for (uint i; i < _amount;) {\\n            _regularMint(_to);\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    function _regularMint(address _to) internal {\\n        uint nextIndex = nextTokenId;\\n\\n        _mint(_to, nextIndex);\\n\\n        unchecked {\\n            ++totalSupply;\\n            nextTokenId = nextIndex + 1;\\n        }\\n    }\\n\\n    // Airdrop\\n\\n    /// @dev Example input data: [0xabc123, 0xdef456, 0xghi789], [[1,2,3], [4,5], [9]]\\n    function airdrop(address[] calldata _addresses, uint[][] calldata _tokenIds) external onlyOwner {\\n        if (_addresses.length != _tokenIds.length) revert LengthsDontMatch();\\n        uint length = _addresses.length;\\n\\n        for (uint i; i < length;) {\\n            for (uint n; n < _tokenIds[i].length;) {\\n                _mint(_addresses[i], _tokenIds[i][n]);\\n                unchecked { ++n; }\\n            }\\n\\n            unchecked {\\n                totalSupply += _tokenIds[i].length;\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// Virtual\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseTokenURI;\\n    }\\n\\n    /// Setters\\n\\n    function setMinterAddress(address _newMinter) external onlyOwner {\\n        uncannyMinter = _newMinter;\\n    }\\n\\n    // Sets the location of the metadata\\n    function setBaseURI(string calldata _uri) external onlyOwner {\\n        baseTokenURI = _uri;\\n    }\\n\\n    // Changes the mint address that can call this contract\\n    function changeMinterAddress(address _newMinter) external onlyOwner {\\n        uncannyMinter = _newMinter;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/examples/erc721c/ERC721CWithBasicRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../access/OwnableBasic.sol\\\";\\nimport \\\"../../erc721c/ERC721C.sol\\\";\\nimport \\\"../../programmable-royalties/BasicRoyalties.sol\\\";\\n\\n/**\\n * @title ERC721CWithBasicRoyalties\\n * @author Limit Break, Inc.\\n * @notice Extension of ERC721C that adds basic royalties support.\\n * @dev These contracts are intended for example use and are not intended for production deployments as-is.\\n */\\ncontract ERC721CWithBasicRoyalties is OwnableBasic, ERC721C, BasicRoyalties {\\n\\n    constructor(\\n        address royaltyReceiver_,\\n        uint96 royaltyFeeNumerator_,\\n        string memory name_,\\n        string memory symbol_) \\n        ERC721OpenZeppelin(name_, symbol_) \\n        BasicRoyalties(royaltyReceiver_, royaltyFeeNumerator_) {\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721C, ERC2981) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function mint(address to, uint256 tokenId) external {\\n        _mint(to, tokenId);\\n    }\\n\\n    function safeMint(address to, uint256 tokenId) external {\\n        _safeMint(to, tokenId);\\n    }\\n\\n    function burn(uint256 tokenId) external {\\n        _burn(tokenId);\\n    }\\n\\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) public {\\n        _requireCallerIsContractOwner();\\n        _setDefaultRoyalty(receiver, feeNumerator);\\n    }\\n\\n    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) public {\\n        _requireCallerIsContractOwner();\\n        _setTokenRoyalty(tokenId, receiver, feeNumerator);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// \ud83d\udcac ABOUT\\n// Forge Std's default Test.\\n\\n// \ud83e\udde9 MODULES\\nimport {console} from \\\"./console.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {safeconsole} from \\\"./safeconsole.sol\\\";\\nimport {StdAssertions} from \\\"./StdAssertions.sol\\\";\\nimport {StdChains} from \\\"./StdChains.sol\\\";\\nimport {StdCheats} from \\\"./StdCheats.sol\\\";\\nimport {stdError} from \\\"./StdError.sol\\\";\\nimport {StdInvariant} from \\\"./StdInvariant.sol\\\";\\nimport {stdJson} from \\\"./StdJson.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {StdStyle} from \\\"./StdStyle.sol\\\";\\nimport {StdUtils} from \\\"./StdUtils.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\n// \ud83d\udce6 BOILERPLATE\\nimport {TestBase} from \\\"./Base.sol\\\";\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\n\\n// \u2b50\ufe0f TEST\\nabstract contract Test is TestBase, DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\\n// Note: IS_TEST() must return true.\\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/access/OwnableBasic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./OwnablePermissions.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nabstract contract OwnableBasic is OwnablePermissions, Ownable {\\n    function _requireCallerIsContractOwner() internal view virtual override {\\n        _checkOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/erc721c/ERC721C.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/CreatorTokenBase.sol\\\";\\nimport \\\"../token/erc721/ERC721OpenZeppelin.sol\\\";\\n\\n/**\\n * @title ERC721C\\n * @author Limit Break, Inc.\\n * @notice Extends OpenZeppelin's ERC721 implementation with Creator Token functionality, which\\n *         allows the contract owner to update the transfer validation logic by managing a security policy in\\n *         an external transfer validation security policy registry.  See {CreatorTokenTransferValidator}.\\n */\\nabstract contract ERC721C is ERC721OpenZeppelin, CreatorTokenBase {\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(ICreatorToken).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @dev Ties the open-zeppelin _beforeTokenTransfer hook to more granular transfer validation logic\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize) internal virtual override {\\n        for (uint256 i = 0; i < batchSize;) {\\n            _validateBeforeTransfer(from, to, firstTokenId + i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Ties the open-zeppelin _afterTokenTransfer hook to more granular transfer validation logic\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize) internal virtual override {\\n        for (uint256 i = 0; i < batchSize;) {\\n            _validateAfterTransfer(from, to, firstTokenId + i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @title ERC721CInitializable\\n * @author Limit Break, Inc.\\n * @notice Initializable implementation of ERC721C to allow for EIP-1167 proxy clones.\\n */\\nabstract contract ERC721CInitializable is ERC721OpenZeppelinInitializable, CreatorTokenBase {\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(ICreatorToken).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @dev Ties the open-zeppelin _beforeTokenTransfer hook to more granular transfer validation logic\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize) internal virtual override {\\n        for (uint256 i = 0; i < batchSize;) {\\n            _validateBeforeTransfer(from, to, firstTokenId + i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Ties the open-zeppelin _afterTokenTransfer hook to more granular transfer validation logic\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize) internal virtual override {\\n        for (uint256 i = 0; i < batchSize;) {\\n            _validateAfterTransfer(from, to, firstTokenId + i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/programmable-royalties/BasicRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\n\\n/**\\n * @title BasicRoyaltiesBase\\n * @author Limit Break, Inc.\\n * @dev Base functionality of an NFT mix-in contract implementing the most basic form of programmable royalties.\\n */\\nabstract contract BasicRoyaltiesBase is ERC2981 {\\n\\n    event DefaultRoyaltySet(address indexed receiver, uint96 feeNumerator);\\n    event TokenRoyaltySet(uint256 indexed tokenId, address indexed receiver, uint96 feeNumerator);\\n\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual override {\\n        super._setDefaultRoyalty(receiver, feeNumerator);\\n        emit DefaultRoyaltySet(receiver, feeNumerator);\\n    }\\n\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual override {\\n        super._setTokenRoyalty(tokenId, receiver, feeNumerator);\\n        emit TokenRoyaltySet(tokenId, receiver, feeNumerator);\\n    }\\n}\\n\\n/**\\n * @title BasicRoyalties\\n * @author Limit Break, Inc.\\n * @notice Constructable BasicRoyalties Contract implementation.\\n */\\nabstract contract BasicRoyalties is BasicRoyaltiesBase {\\n    constructor(address receiver, uint96 feeNumerator) {\\n        _setDefaultRoyalty(receiver, feeNumerator);\\n    }\\n}\\n\\n/**\\n * @title BasicRoyaltiesInitializable\\n * @author Limit Break, Inc.\\n * @notice Initializable BasicRoyalties Contract implementation to allow for EIP-1167 clones. \\n */\\nabstract contract BasicRoyaltiesInitializable is BasicRoyaltiesBase {}\"\r\n    },\r\n    \"lib/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/forge-std/src/console2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\\nlibrary console2 {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _castLogPayloadViewToPure(\\n        function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/forge-std/src/safeconsole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @author philogy <https://github.com/philogy>\\n/// @dev Code generated automatically by script.\\nlibrary safeconsole {\\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\\n    // for the view-to-pure log trick.\\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\\n        function(uint256, uint256) internal pure pureSendLogPayload;\\n        assembly {\\n            pureSendLogPayload := fnIn\\n        }\\n        pureSendLogPayload(offset, size);\\n    }\\n\\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\\n        assembly {\\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\\n        }\\n    }\\n\\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\\n        assembly {\\n            pureMemcopy := fnIn\\n        }\\n        pureMemcopy(fromOffset, toOffset, length);\\n    }\\n\\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\\n        assembly {\\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\\n        }\\n    }\\n\\n    function logMemory(uint256 offset, uint256 length) internal pure {\\n        if (offset >= 0x60) {\\n            // Sufficient memory before slice to prepare call header.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            assembly {\\n                m0 := mload(sub(offset, 0x60))\\n                m1 := mload(sub(offset, 0x40))\\n                m2 := mload(sub(offset, 0x20))\\n                // Selector of `logBytes(bytes)`.\\n                mstore(sub(offset, 0x60), 0xe17bf956)\\n                mstore(sub(offset, 0x40), 0x20)\\n                mstore(sub(offset, 0x20), length)\\n            }\\n            _sendLogPayload(offset - 0x44, length + 0x44);\\n            assembly {\\n                mstore(sub(offset, 0x60), m0)\\n                mstore(sub(offset, 0x40), m1)\\n                mstore(sub(offset, 0x20), m2)\\n            }\\n        } else {\\n            // Insufficient space, so copy slice forward, add header and reverse.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            uint256 endOffset = offset + length;\\n            assembly {\\n                m0 := mload(add(endOffset, 0x00))\\n                m1 := mload(add(endOffset, 0x20))\\n                m2 := mload(add(endOffset, 0x40))\\n            }\\n            _memcopy(offset, offset + 0x60, length);\\n            assembly {\\n                // Selector of `logBytes(bytes)`.\\n                mstore(add(offset, 0x00), 0xe17bf956)\\n                mstore(add(offset, 0x20), 0x20)\\n                mstore(add(offset, 0x40), length)\\n            }\\n            _sendLogPayload(offset + 0x1c, length + 0x44);\\n            _memcopy(offset + 0x60, offset, length);\\n            assembly {\\n                mstore(add(endOffset, 0x00), m0)\\n                mstore(add(endOffset, 0x20), m1)\\n                mstore(add(endOffset, 0x40), m2)\\n            }\\n        }\\n    }\\n\\n    function log(address p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(address)`.\\n            mstore(0x00, 0x2c2ecbc2)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bool p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(bool)`.\\n            mstore(0x00, 0x32458eed)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(uint256)`.\\n            mstore(0x00, 0xf82c50f1)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bytes32 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(string)`.\\n            mstore(0x00, 0x41304fac)\\n            mstore(0x20, 0x20)\\n            writeString(0x40, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,address)`.\\n            mstore(0x00, 0xdaf0d4aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,bool)`.\\n            mstore(0x00, 0x75b605d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,uint256)`.\\n            mstore(0x00, 0x8309e8a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,string)`.\\n            mstore(0x00, 0x759f86bb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,address)`.\\n            mstore(0x00, 0x853c4849)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,bool)`.\\n            mstore(0x00, 0x2a110e83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,uint256)`.\\n            mstore(0x00, 0x399174d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,string)`.\\n            mstore(0x00, 0x8feac525)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,address)`.\\n            mstore(0x00, 0x69276c86)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,bool)`.\\n            mstore(0x00, 0x1c9d7eb3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,uint256)`.\\n            mstore(0x00, 0xf666715a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,string)`.\\n            mstore(0x00, 0x643fd0df)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,address)`.\\n            mstore(0x00, 0x319af333)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,bool)`.\\n            mstore(0x00, 0xc3b55635)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,uint256)`.\\n            mstore(0x00, 0xb60e72cc)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,string)`.\\n            mstore(0x00, 0x4b5c4277)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, 0x80)\\n            writeString(0x60, p0)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,address)`.\\n            mstore(0x00, 0x018c84c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,bool)`.\\n            mstore(0x00, 0xf2a66286)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,uint256)`.\\n            mstore(0x00, 0x17fe6185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,address,string)`.\\n            mstore(0x00, 0x007150be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,address)`.\\n            mstore(0x00, 0xf11699ed)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,bool)`.\\n            mstore(0x00, 0xeb830c92)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,uint256)`.\\n            mstore(0x00, 0x9c4f99fb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,bool,string)`.\\n            mstore(0x00, 0x212255cc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,address)`.\\n            mstore(0x00, 0x7bc0d848)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,bool)`.\\n            mstore(0x00, 0x678209a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,uint256)`.\\n            mstore(0x00, 0xb69bcaf6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,uint256,string)`.\\n            mstore(0x00, 0xa1f2e8aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,address)`.\\n            mstore(0x00, 0xf08744e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,bool)`.\\n            mstore(0x00, 0xcf020fb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,uint256)`.\\n            mstore(0x00, 0x67dd6ff1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(address,string,string)`.\\n            mstore(0x00, 0xfb772265)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,address)`.\\n            mstore(0x00, 0xd2763667)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,bool)`.\\n            mstore(0x00, 0x18c9c746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,uint256)`.\\n            mstore(0x00, 0x5f7b9afb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,address,string)`.\\n            mstore(0x00, 0xde9a9270)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,address)`.\\n            mstore(0x00, 0x1078f68d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,bool)`.\\n            mstore(0x00, 0x50709698)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,uint256)`.\\n            mstore(0x00, 0x12f21602)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,bool,string)`.\\n            mstore(0x00, 0x2555fa46)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,address)`.\\n            mstore(0x00, 0x088ef9d2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,bool)`.\\n            mstore(0x00, 0xe8defba9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,uint256)`.\\n            mstore(0x00, 0x37103367)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,uint256,string)`.\\n            mstore(0x00, 0xc3fc3970)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,address)`.\\n            mstore(0x00, 0x9591b953)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,bool)`.\\n            mstore(0x00, 0xdbb4c247)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,uint256)`.\\n            mstore(0x00, 0x1093ee11)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(bool,string,string)`.\\n            mstore(0x00, 0xb076847f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,address)`.\\n            mstore(0x00, 0xbcfd9be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,bool)`.\\n            mstore(0x00, 0x9b6ec042)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,uint256)`.\\n            mstore(0x00, 0x5a9b5ed5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,address,string)`.\\n            mstore(0x00, 0x63cb41f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,address)`.\\n            mstore(0x00, 0x35085f7b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,bool)`.\\n            mstore(0x00, 0x20718650)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,uint256)`.\\n            mstore(0x00, 0x20098014)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,bool,string)`.\\n            mstore(0x00, 0x85775021)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,address)`.\\n            mstore(0x00, 0x5c96b331)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,bool)`.\\n            mstore(0x00, 0x4766da72)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,uint256)`.\\n            mstore(0x00, 0xd1ed7a3c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,uint256,string)`.\\n            mstore(0x00, 0x71d04af2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,address)`.\\n            mstore(0x00, 0x7afac959)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,bool)`.\\n            mstore(0x00, 0x4ceda75a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,uint256)`.\\n            mstore(0x00, 0x37aa7d4c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(uint256,string,string)`.\\n            mstore(0x00, 0xb115611f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,address)`.\\n            mstore(0x00, 0xfcec75e0)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,bool)`.\\n            mstore(0x00, 0xc91d5ed4)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,uint256)`.\\n            mstore(0x00, 0x0d26b925)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,address,string)`.\\n            mstore(0x00, 0xe0e9ad4f)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,address)`.\\n            mstore(0x00, 0x932bbb38)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,bool)`.\\n            mstore(0x00, 0x850b7ad6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,uint256)`.\\n            mstore(0x00, 0xc95958d6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,bool,string)`.\\n            mstore(0x00, 0xe298f47d)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,address)`.\\n            mstore(0x00, 0x1c7ec448)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,bool)`.\\n            mstore(0x00, 0xca7733b1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,uint256)`.\\n            mstore(0x00, 0xca47c4eb)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,uint256,string)`.\\n            mstore(0x00, 0x5970e089)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,address)`.\\n            mstore(0x00, 0x95ed0195)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,bool)`.\\n            mstore(0x00, 0xb0e0f9b5)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,uint256)`.\\n            mstore(0x00, 0x5821efa1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            // Selector of `log(string,string,string)`.\\n            mstore(0x00, 0x2ced7cef)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, 0xe0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n            writeString(0x100, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x124);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,address)`.\\n            mstore(0x00, 0x665bf134)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,bool)`.\\n            mstore(0x00, 0x0e378994)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,uint256)`.\\n            mstore(0x00, 0x94250d77)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,address,string)`.\\n            mstore(0x00, 0xf808da20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,address)`.\\n            mstore(0x00, 0x9f1bc36e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,bool)`.\\n            mstore(0x00, 0x2cd4134a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,uint256)`.\\n            mstore(0x00, 0x3971e78c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,bool,string)`.\\n            mstore(0x00, 0xaa6540c8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,address)`.\\n            mstore(0x00, 0x8da6def5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,bool)`.\\n            mstore(0x00, 0x9b4254e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,uint256)`.\\n            mstore(0x00, 0xbe553481)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,uint256,string)`.\\n            mstore(0x00, 0xfdb4f990)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,address)`.\\n            mstore(0x00, 0x8f736d16)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,bool)`.\\n            mstore(0x00, 0x6f1a594e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,uint256)`.\\n            mstore(0x00, 0xef1cefe7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,address,string,string)`.\\n            mstore(0x00, 0x21bdaf25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,address)`.\\n            mstore(0x00, 0x660375dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,bool)`.\\n            mstore(0x00, 0xa6f50b0f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,uint256)`.\\n            mstore(0x00, 0xa75c59de)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,address,string)`.\\n            mstore(0x00, 0x2dd778e6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,address)`.\\n            mstore(0x00, 0xcf394485)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,bool)`.\\n            mstore(0x00, 0xcac43479)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,uint256)`.\\n            mstore(0x00, 0x8c4e5de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,bool,string)`.\\n            mstore(0x00, 0xdfc4a2e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,address)`.\\n            mstore(0x00, 0xccf790a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,bool)`.\\n            mstore(0x00, 0xc4643e20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,uint256)`.\\n            mstore(0x00, 0x386ff5f4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,uint256,string)`.\\n            mstore(0x00, 0x0aa6cfad)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,address)`.\\n            mstore(0x00, 0x19fd4956)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,bool)`.\\n            mstore(0x00, 0x50ad461d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,uint256)`.\\n            mstore(0x00, 0x80e6a20b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,bool,string,string)`.\\n            mstore(0x00, 0x475c5c33)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,address)`.\\n            mstore(0x00, 0x478d1c62)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,bool)`.\\n            mstore(0x00, 0xa1bcc9b3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,uint256)`.\\n            mstore(0x00, 0x100f650e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,address,string)`.\\n            mstore(0x00, 0x1da986ea)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,address)`.\\n            mstore(0x00, 0xa31bfdcc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,bool)`.\\n            mstore(0x00, 0x3bf5e537)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,uint256)`.\\n            mstore(0x00, 0x22f6b999)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,bool,string)`.\\n            mstore(0x00, 0xc5ad85f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,address)`.\\n            mstore(0x00, 0x20e3984d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,bool)`.\\n            mstore(0x00, 0x66f1bc67)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x34f0e636)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,uint256,string)`.\\n            mstore(0x00, 0x4a28c017)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,address)`.\\n            mstore(0x00, 0x5c430d47)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,bool)`.\\n            mstore(0x00, 0xcf18105c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,uint256)`.\\n            mstore(0x00, 0xbf01f891)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,uint256,string,string)`.\\n            mstore(0x00, 0x88a8c406)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,address)`.\\n            mstore(0x00, 0x0d36fa20)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,bool)`.\\n            mstore(0x00, 0x0df12b76)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,uint256)`.\\n            mstore(0x00, 0x457fe3cf)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,address,string)`.\\n            mstore(0x00, 0xf7e36245)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,address)`.\\n            mstore(0x00, 0x205871c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,bool)`.\\n            mstore(0x00, 0x5f1d5c9f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,uint256)`.\\n            mstore(0x00, 0x515e38b6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,bool,string)`.\\n            mstore(0x00, 0xbc0b61fe)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,address)`.\\n            mstore(0x00, 0x63183678)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,bool)`.\\n            mstore(0x00, 0x0ef7e050)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,uint256)`.\\n            mstore(0x00, 0x1dc8e1b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,uint256,string)`.\\n            mstore(0x00, 0x448830a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,address)`.\\n            mstore(0x00, 0xa04e2f87)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,bool)`.\\n            mstore(0x00, 0x35a5071f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,uint256)`.\\n            mstore(0x00, 0x159f8927)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(address,string,string,string)`.\\n            mstore(0x00, 0x5d02c50b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,address)`.\\n            mstore(0x00, 0x1d14d001)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,bool)`.\\n            mstore(0x00, 0x46600be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,uint256)`.\\n            mstore(0x00, 0x0c66d1be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,address,string)`.\\n            mstore(0x00, 0xd812a167)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,address)`.\\n            mstore(0x00, 0x1c41a336)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,bool)`.\\n            mstore(0x00, 0x6a9c478b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,uint256)`.\\n            mstore(0x00, 0x07831502)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,bool,string)`.\\n            mstore(0x00, 0x4a66cb34)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,address)`.\\n            mstore(0x00, 0x136b05dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,bool)`.\\n            mstore(0x00, 0xd6019f1c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,uint256)`.\\n            mstore(0x00, 0x7bf181a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,uint256,string)`.\\n            mstore(0x00, 0x51f09ff8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,address)`.\\n            mstore(0x00, 0x6f7c603e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,bool)`.\\n            mstore(0x00, 0xe2bfd60b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,uint256)`.\\n            mstore(0x00, 0xc21f64c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,address,string,string)`.\\n            mstore(0x00, 0xa73c1db6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,address)`.\\n            mstore(0x00, 0xf4880ea4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,bool)`.\\n            mstore(0x00, 0xc0a302d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,uint256)`.\\n            mstore(0x00, 0x4c123d57)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,address,string)`.\\n            mstore(0x00, 0xa0a47963)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,address)`.\\n            mstore(0x00, 0x8c329b1a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,bool)`.\\n            mstore(0x00, 0x3b2a5ce0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,uint256)`.\\n            mstore(0x00, 0x6d7045c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,bool,string)`.\\n            mstore(0x00, 0x2ae408d4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,address)`.\\n            mstore(0x00, 0x54a7a9a0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,bool)`.\\n            mstore(0x00, 0x619e4d0e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,uint256)`.\\n            mstore(0x00, 0x0bb00eab)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,uint256,string)`.\\n            mstore(0x00, 0x7dd4d0e0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,address)`.\\n            mstore(0x00, 0xf9ad2b89)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,bool)`.\\n            mstore(0x00, 0xb857163a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,uint256)`.\\n            mstore(0x00, 0xe3a9ca2f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,bool,string,string)`.\\n            mstore(0x00, 0x6d1e8751)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,address)`.\\n            mstore(0x00, 0x26f560a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,bool)`.\\n            mstore(0x00, 0xb4c314ff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,uint256)`.\\n            mstore(0x00, 0x1537dc87)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,address,string)`.\\n            mstore(0x00, 0x1bb3b09a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,address)`.\\n            mstore(0x00, 0x9acd3616)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,bool)`.\\n            mstore(0x00, 0xceb5f4d7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,uint256)`.\\n            mstore(0x00, 0x7f9bbca2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,bool,string)`.\\n            mstore(0x00, 0x9143dbb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,address)`.\\n            mstore(0x00, 0x00dd87b9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,bool)`.\\n            mstore(0x00, 0xbe984353)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x374bb4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,uint256,string)`.\\n            mstore(0x00, 0x8e69fb5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,address)`.\\n            mstore(0x00, 0xfedd1fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,bool)`.\\n            mstore(0x00, 0xe5e70b2b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,uint256)`.\\n            mstore(0x00, 0x6a1199e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,uint256,string,string)`.\\n            mstore(0x00, 0xf5bc2249)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,address)`.\\n            mstore(0x00, 0x2b2b18dc)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,bool)`.\\n            mstore(0x00, 0x6dd434ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,uint256)`.\\n            mstore(0x00, 0xa5cada94)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,address,string)`.\\n            mstore(0x00, 0x12d6c788)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,address)`.\\n            mstore(0x00, 0x538e06ab)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,bool)`.\\n            mstore(0x00, 0xdc5e935b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,uint256)`.\\n            mstore(0x00, 0x1606a393)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,bool,string)`.\\n            mstore(0x00, 0x483d0416)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,address)`.\\n            mstore(0x00, 0x1596a1ce)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,bool)`.\\n            mstore(0x00, 0x6b0e5d53)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,uint256)`.\\n            mstore(0x00, 0x28863fcb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,uint256,string)`.\\n            mstore(0x00, 0x1ad96de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,address)`.\\n            mstore(0x00, 0x97d394d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,bool)`.\\n            mstore(0x00, 0x1e4b87e5)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,uint256)`.\\n            mstore(0x00, 0x7be0c3eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(bool,string,string,string)`.\\n            mstore(0x00, 0x1762e32a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,address)`.\\n            mstore(0x00, 0x2488b414)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,bool)`.\\n            mstore(0x00, 0x091ffaf5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,uint256)`.\\n            mstore(0x00, 0x736efbb6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,address,string)`.\\n            mstore(0x00, 0x031c6f73)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,address)`.\\n            mstore(0x00, 0xef72c513)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,bool)`.\\n            mstore(0x00, 0xe351140f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,uint256)`.\\n            mstore(0x00, 0x5abd992a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,bool,string)`.\\n            mstore(0x00, 0x90fb06aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,address)`.\\n            mstore(0x00, 0x15c127b5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,bool)`.\\n            mstore(0x00, 0x5f743a7c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,uint256)`.\\n            mstore(0x00, 0x0c9cd9c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,uint256,string)`.\\n            mstore(0x00, 0xddb06521)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,address)`.\\n            mstore(0x00, 0x9cba8fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,bool)`.\\n            mstore(0x00, 0xcc32ab07)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,uint256)`.\\n            mstore(0x00, 0x46826b5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,address,string,string)`.\\n            mstore(0x00, 0x3e128ca3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,address)`.\\n            mstore(0x00, 0xa1ef4cbb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,bool)`.\\n            mstore(0x00, 0x454d54a5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,uint256)`.\\n            mstore(0x00, 0x078287f5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,address,string)`.\\n            mstore(0x00, 0xade052c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,address)`.\\n            mstore(0x00, 0x69640b59)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,bool)`.\\n            mstore(0x00, 0xb6f577a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,uint256)`.\\n            mstore(0x00, 0x7464ce23)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,bool,string)`.\\n            mstore(0x00, 0xdddb9561)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,address)`.\\n            mstore(0x00, 0x88cb6041)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,bool)`.\\n            mstore(0x00, 0x91a02e2a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,uint256)`.\\n            mstore(0x00, 0xc6acc7a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,uint256,string)`.\\n            mstore(0x00, 0xde03e774)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,address)`.\\n            mstore(0x00, 0xef529018)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,bool)`.\\n            mstore(0x00, 0xeb928d7f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,uint256)`.\\n            mstore(0x00, 0x2c1d0746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,bool,string,string)`.\\n            mstore(0x00, 0x68c8b8bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,address)`.\\n            mstore(0x00, 0x56a5d1b1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,bool)`.\\n            mstore(0x00, 0x15cac476)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,uint256)`.\\n            mstore(0x00, 0x88f6e4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,address,string)`.\\n            mstore(0x00, 0x6cde40b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,address)`.\\n            mstore(0x00, 0x9a816a83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,bool)`.\\n            mstore(0x00, 0xab085ae6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,uint256)`.\\n            mstore(0x00, 0xeb7f6fd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,bool,string)`.\\n            mstore(0x00, 0xa5b4fc99)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,address)`.\\n            mstore(0x00, 0xfa8185af)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,bool)`.\\n            mstore(0x00, 0xc598d185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x193fb800)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,uint256,string)`.\\n            mstore(0x00, 0x59cfcbe3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,address)`.\\n            mstore(0x00, 0x42d21db7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,bool)`.\\n            mstore(0x00, 0x7af6ab25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,uint256)`.\\n            mstore(0x00, 0x5da297eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,uint256,string,string)`.\\n            mstore(0x00, 0x27d8afd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,address)`.\\n            mstore(0x00, 0x6168ed61)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,bool)`.\\n            mstore(0x00, 0x90c30a56)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,uint256)`.\\n            mstore(0x00, 0xe8d3018d)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,address,string)`.\\n            mstore(0x00, 0x9c3adfa1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,address)`.\\n            mstore(0x00, 0xae2ec581)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,bool)`.\\n            mstore(0x00, 0xba535d9c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,uint256)`.\\n            mstore(0x00, 0xcf009880)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,bool,string)`.\\n            mstore(0x00, 0xd2d423cd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,address)`.\\n            mstore(0x00, 0x3b2279b4)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,bool)`.\\n            mstore(0x00, 0x691a8f74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,uint256)`.\\n            mstore(0x00, 0x82c25b74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,uint256,string)`.\\n            mstore(0x00, 0xb7b914ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,address)`.\\n            mstore(0x00, 0xd583c602)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,bool)`.\\n            mstore(0x00, 0xb3a6b6bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,uint256)`.\\n            mstore(0x00, 0xb028c9bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(uint256,string,string,string)`.\\n            mstore(0x00, 0x21ad0683)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,address)`.\\n            mstore(0x00, 0xed8f28f6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,bool)`.\\n            mstore(0x00, 0xb59dbd60)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,uint256)`.\\n            mstore(0x00, 0x8ef3f399)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,address,string)`.\\n            mstore(0x00, 0x800a1c67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,address)`.\\n            mstore(0x00, 0x223603bd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,bool)`.\\n            mstore(0x00, 0x79884c2b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,uint256)`.\\n            mstore(0x00, 0x3e9f866a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,bool,string)`.\\n            mstore(0x00, 0x0454c079)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,address)`.\\n            mstore(0x00, 0x63fb8bc5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,bool)`.\\n            mstore(0x00, 0xfc4845f0)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,uint256)`.\\n            mstore(0x00, 0xf8f51b1e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,uint256,string)`.\\n            mstore(0x00, 0x5a477632)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,address)`.\\n            mstore(0x00, 0xaabc9a31)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,bool)`.\\n            mstore(0x00, 0x5f15d28c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,uint256)`.\\n            mstore(0x00, 0x91d1112e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,address,string,string)`.\\n            mstore(0x00, 0x245986f2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,address)`.\\n            mstore(0x00, 0x33e9dd1d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,bool)`.\\n            mstore(0x00, 0x958c28c6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,uint256)`.\\n            mstore(0x00, 0x5d08bb05)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,address,string)`.\\n            mstore(0x00, 0x2d8e33a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,address)`.\\n            mstore(0x00, 0x7190a529)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,bool)`.\\n            mstore(0x00, 0x895af8c5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,uint256)`.\\n            mstore(0x00, 0x8e3f78a9)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,bool,string)`.\\n            mstore(0x00, 0x9d22d5dd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,address)`.\\n            mstore(0x00, 0x935e09bf)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,bool)`.\\n            mstore(0x00, 0x8af7cf8a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,uint256)`.\\n            mstore(0x00, 0x64b5bb67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,uint256,string)`.\\n            mstore(0x00, 0x742d6ee7)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,address)`.\\n            mstore(0x00, 0xe0625b29)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,bool)`.\\n            mstore(0x00, 0x3f8a701d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,uint256)`.\\n            mstore(0x00, 0x24f91465)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,bool,string,string)`.\\n            mstore(0x00, 0xa826caeb)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,address)`.\\n            mstore(0x00, 0x5ea2b7ae)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,bool)`.\\n            mstore(0x00, 0x82112a42)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,uint256)`.\\n            mstore(0x00, 0x4f04fdc6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,address,string)`.\\n            mstore(0x00, 0x9ffb2f93)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,address)`.\\n            mstore(0x00, 0xe0e95b98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,bool)`.\\n            mstore(0x00, 0x354c36d6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,uint256)`.\\n            mstore(0x00, 0xe41b6f6f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,bool,string)`.\\n            mstore(0x00, 0xabf73a98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,address)`.\\n            mstore(0x00, 0xe21de278)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,bool)`.\\n            mstore(0x00, 0x7626db92)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,uint256)`.\\n            mstore(0x00, 0xa7a87853)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,uint256,string)`.\\n            mstore(0x00, 0x854b3496)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,address)`.\\n            mstore(0x00, 0x7c4632a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,bool)`.\\n            mstore(0x00, 0x7d24491d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,uint256)`.\\n            mstore(0x00, 0xc67ea9d1)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,uint256,string,string)`.\\n            mstore(0x00, 0x5ab84e1f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,address)`.\\n            mstore(0x00, 0x439c7bef)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,bool)`.\\n            mstore(0x00, 0x5ccd4e37)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,uint256)`.\\n            mstore(0x00, 0x7cc3c607)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,address,string)`.\\n            mstore(0x00, 0xeb1bff80)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,address)`.\\n            mstore(0x00, 0xc371c7db)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,bool)`.\\n            mstore(0x00, 0x40785869)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,uint256)`.\\n            mstore(0x00, 0xd6aefad2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,bool,string)`.\\n            mstore(0x00, 0x5e84b0ea)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,address)`.\\n            mstore(0x00, 0x1023f7b2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,bool)`.\\n            mstore(0x00, 0xc3a8a654)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,uint256)`.\\n            mstore(0x00, 0xf45d7d2c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,uint256,string)`.\\n            mstore(0x00, 0x5d1a971a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,address)`.\\n            mstore(0x00, 0x6d572f44)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,bool)`.\\n            mstore(0x00, 0x2c1754ed)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,uint256)`.\\n            mstore(0x00, 0x8eafb02b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        bytes32 m11;\\n        bytes32 m12;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            m11 := mload(0x160)\\n            m12 := mload(0x180)\\n            // Selector of `log(string,string,string,string)`.\\n            mstore(0x00, 0xde68f20a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, 0x140)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n            writeString(0x160, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x184);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n            mstore(0x160, m11)\\n            mstore(0x180, m12)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdAssertions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\n\\nabstract contract StdAssertions is DSTest {\\n    event log_array(uint256[] val);\\n    event log_array(int256[] val);\\n    event log_array(address[] val);\\n    event log_named_array(string key, uint256[] val);\\n    event log_named_array(string key, int256[] val);\\n    event log_named_array(string key, address[] val);\\n\\n    function fail(string memory err) internal virtual {\\n        emit log_named_string(\\\"Error\\\", err);\\n        fail();\\n    }\\n\\n    function assertFalse(bool data) internal virtual {\\n        assertTrue(!data);\\n    }\\n\\n    function assertFalse(bool data, string memory err) internal virtual {\\n        assertTrue(!data, err);\\n    }\\n\\n    function assertEq(bool a, bool b) internal virtual {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bool]\\\");\\n            emit log_named_string(\\\"      Left\\\", a ? \\\"true\\\" : \\\"false\\\");\\n            emit log_named_string(\\\"     Right\\\", b ? \\\"true\\\" : \\\"false\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(bool a, bool b, string memory err) internal virtual {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\\n        assertEq0(a, b);\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\\n        assertEq0(a, b, err);\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [uint[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [int[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [address[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    // Legacy helper\\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\\n        assertEq(uint256(a), uint256(b));\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"       Left\\\", a);\\n            emit log_named_int(\\\"      Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"        Left\\\", a);\\n            emit log_named_uint(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals,\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"        Left\\\", a);\\n            emit log_named_int(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\\n        assertEqCall(target, callDataA, target, callDataB, true);\\n    }\\n\\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\\n    }\\n\\n    function assertEqCall(\\n        address targetA,\\n        bytes memory callDataA,\\n        address targetB,\\n        bytes memory callDataB,\\n        bool strictRevertData\\n    ) internal virtual {\\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\\n\\n        if (successA && successB) {\\n            assertEq(returnDataA, returnDataB, \\\"Call return data does not match\\\");\\n        }\\n\\n        if (!successA && !successB && strictRevertData) {\\n            assertEq(returnDataA, returnDataB, \\\"Call revert data does not match\\\");\\n        }\\n\\n        if (!successA && successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call revert data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call return data\\\", returnDataB);\\n            fail();\\n        }\\n\\n        if (successA && !successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call return data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call revert data\\\", returnDataB);\\n            fail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdChains.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n/**\\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\\n * alias used in this contract, which can be found as the first argument to the\\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\\n *\\n * There are two main ways to use this contract:\\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\\n *      `setChain(string memory chainAlias, Chain memory chain)`\\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\\n *\\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\\n * `defaultRpcUrls`.\\n *\\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\\n *\\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\\n * we want to retrieve the RPC URL for `mainnet`:\\n *   - If you have specified data with `setChain`, it will return that.\\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\\n *   - If neither of the above conditions is met, the default data is returned.\\n *\\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\\n */\\nabstract contract StdChains {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    bool private stdChainsInitialized;\\n\\n    struct ChainData {\\n        string name;\\n        uint256 chainId;\\n        string rpcUrl;\\n    }\\n\\n    struct Chain {\\n        // The chain name.\\n        string name;\\n        // The chain's Chain ID.\\n        uint256 chainId;\\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\\n        string chainAlias;\\n        // A default RPC endpoint for this chain.\\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\\n        string rpcUrl;\\n    }\\n\\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\\n    mapping(string => Chain) private chains;\\n    // Maps from the chain's alias to it's default RPC URL.\\n    mapping(string => string) private defaultRpcUrls;\\n    // Maps from a chain ID to it's alias.\\n    mapping(uint256 => string) private idToAlias;\\n\\n    bool private fallbackToDefaultRpcUrls = true;\\n\\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\\n        require(bytes(chainAlias).length != 0, \\\"StdChains getChain(string): Chain alias cannot be the empty string.\\\");\\n\\n        initializeStdChains();\\n        chain = chains[chainAlias];\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(string): Chain with alias \\\\\\\"\\\", chainAlias, \\\"\\\\\\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\\n        require(chainId != 0, \\\"StdChains getChain(uint256): Chain ID cannot be 0.\\\");\\n        initializeStdChains();\\n        string memory chainAlias = idToAlias[chainId];\\n\\n        chain = chains[chainAlias];\\n\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(uint256): Chain with ID \\\", vm.toString(chainId), \\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\\n        require(\\n            bytes(chainAlias).length != 0,\\n            \\\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\\\"\\n        );\\n\\n        require(chain.chainId != 0, \\\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\\\");\\n\\n        initializeStdChains();\\n        string memory foundAlias = idToAlias[chain.chainId];\\n\\n        require(\\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\\n            string(\\n                abi.encodePacked(\\n                    \\\"StdChains setChain(string,ChainData): Chain ID \\\",\\n                    vm.toString(chain.chainId),\\n                    \\\" already used by \\\\\\\"\\\",\\n                    foundAlias,\\n                    \\\"\\\\\\\".\\\"\\n                )\\n            )\\n        );\\n\\n        uint256 oldChainId = chains[chainAlias].chainId;\\n        delete idToAlias[oldChainId];\\n\\n        chains[chainAlias] =\\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\\n        idToAlias[chain.chainId] = chainAlias;\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\\n    }\\n\\n    function _toUpper(string memory str) private pure returns (string memory) {\\n        bytes memory strb = bytes(str);\\n        bytes memory copy = new bytes(strb.length);\\n        for (uint256 i = 0; i < strb.length; i++) {\\n            bytes1 b = strb[i];\\n            if (b >= 0x61 && b <= 0x7A) {\\n                copy[i] = bytes1(uint8(b) - 32);\\n            } else {\\n                copy[i] = b;\\n            }\\n        }\\n        return string(copy);\\n    }\\n\\n    // lookup rpcUrl, in descending order of priority:\\n    // current -> config (foundry.toml) -> environment variable -> default\\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\\n        private\\n        view\\n        returns (Chain memory)\\n    {\\n        if (bytes(chain.rpcUrl).length == 0) {\\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\\n                chain.rpcUrl = configRpcUrl;\\n            } catch (bytes memory err) {\\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \\\"_RPC_URL\\\"));\\n                if (fallbackToDefaultRpcUrls) {\\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\\n                } else {\\n                    chain.rpcUrl = vm.envString(envName);\\n                }\\n                // Distinguish 'not found' from 'cannot read'\\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\\n                bytes memory oldNotFoundError =\\n                    abi.encodeWithSignature(\\\"CheatCodeError\\\", string(abi.encodePacked(\\\"invalid rpc url \\\", chainAlias)));\\n                bytes memory newNotFoundError = abi.encodeWithSignature(\\n                    \\\"CheatcodeError(string)\\\", string(abi.encodePacked(\\\"invalid rpc url: \\\", chainAlias))\\n                );\\n                bytes32 errHash = keccak256(err);\\n                if (\\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\\n                        || bytes(chain.rpcUrl).length == 0\\n                ) {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, err), mload(err))\\n                    }\\n                }\\n            }\\n        }\\n        return chain;\\n    }\\n\\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\\n        fallbackToDefaultRpcUrls = useDefault;\\n    }\\n\\n    function initializeStdChains() private {\\n        if (stdChainsInitialized) return;\\n\\n        stdChainsInitialized = true;\\n\\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\\n        setChainWithDefaultRpcUrl(\\\"anvil\\\", ChainData(\\\"Anvil\\\", 31337, \\\"http://127.0.0.1:8545\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"mainnet\\\", ChainData(\\\"Mainnet\\\", 1, \\\"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"goerli\\\", ChainData(\\\"Goerli\\\", 5, \\\"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"sepolia\\\", ChainData(\\\"Sepolia\\\", 11155111, \\\"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"optimism\\\", ChainData(\\\"Optimism\\\", 10, \\\"https://mainnet.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"optimism_goerli\\\", ChainData(\\\"Optimism Goerli\\\", 420, \\\"https://goerli.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_one\\\", ChainData(\\\"Arbitrum One\\\", 42161, \\\"https://arb1.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"arbitrum_one_goerli\\\", ChainData(\\\"Arbitrum One Goerli\\\", 421613, \\\"https://goerli-rollup.arbitrum.io/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_nova\\\", ChainData(\\\"Arbitrum Nova\\\", 42170, \\\"https://nova.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\\"polygon\\\", ChainData(\\\"Polygon\\\", 137, \\\"https://polygon-rpc.com\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"polygon_mumbai\\\", ChainData(\\\"Polygon Mumbai\\\", 80001, \\\"https://rpc-mumbai.maticvigil.com\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"avalanche\\\", ChainData(\\\"Avalanche\\\", 43114, \\\"https://api.avax.network/ext/bc/C/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"avalanche_fuji\\\", ChainData(\\\"Avalanche Fuji\\\", 43113, \\\"https://api.avax-test.network/ext/bc/C/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain\\\", ChainData(\\\"BNB Smart Chain\\\", 56, \\\"https://bsc-dataseed1.binance.org\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain_testnet\\\",\\n            ChainData(\\\"BNB Smart Chain Testnet\\\", 97, \\\"https://rpc.ankr.com/bsc_testnet_chapel\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"gnosis_chain\\\", ChainData(\\\"Gnosis Chain\\\", 100, \\\"https://rpc.gnosischain.com\\\"));\\n        setChainWithDefaultRpcUrl(\\\"moonbeam\\\", ChainData(\\\"Moonbeam\\\", 1284, \\\"https://rpc.api.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"moonriver\\\", ChainData(\\\"Moonriver\\\", 1285, \\\"https://rpc.api.moonriver.moonbeam.network\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"moonbase\\\", ChainData(\\\"Moonbase\\\", 1287, \\\"https://rpc.testnet.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base_goerli\\\", ChainData(\\\"Base Goerli\\\", 84531, \\\"https://goerli.base.org\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base\\\", ChainData(\\\"Base\\\", 8453, \\\"https://mainnet.base.org\\\"));\\n    }\\n\\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\\n        string memory rpcUrl = chain.rpcUrl;\\n        defaultRpcUrls[chainAlias] = rpcUrl;\\n        chain.rpcUrl = \\\"\\\";\\n        setChain(chainAlias, chain);\\n        chain.rpcUrl = rpcUrl; // restore argument\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdCheats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdCheatsSafe {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    bool private gasMeteringOff;\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawTx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        // json value name = function\\n        string functionSig;\\n        bytes32 hash;\\n        // json value name = tx\\n        RawTx1559Detail txDetail;\\n        // json value name = type\\n        string opcode;\\n    }\\n\\n    struct RawTx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        bytes gas;\\n        bytes nonce;\\n        address to;\\n        bytes txType;\\n        bytes value;\\n    }\\n\\n    struct Tx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        bytes32 hash;\\n        Tx1559Detail txDetail;\\n        string opcode;\\n    }\\n\\n    struct Tx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 nonce;\\n        address to;\\n        uint256 txType;\\n        uint256 value;\\n    }\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct TxLegacy {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        string hash;\\n        string opcode;\\n        TxDetailLegacy transaction;\\n    }\\n\\n    struct TxDetailLegacy {\\n        AccessList[] accessList;\\n        uint256 chainId;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        bytes32 hash;\\n        uint256 nonce;\\n        bytes1 opcode;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 txType;\\n        address to;\\n        uint8 v;\\n        uint256 value;\\n    }\\n\\n    struct AccessList {\\n        address accessAddress;\\n        bytes32[] storageKeys;\\n    }\\n\\n    // Data structures to parse Receipt objects from the broadcast artifact.\\n    // The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawReceipt {\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        address contractAddress;\\n        bytes cumulativeGasUsed;\\n        bytes effectiveGasPrice;\\n        address from;\\n        bytes gasUsed;\\n        RawReceiptLog[] logs;\\n        bytes logsBloom;\\n        bytes status;\\n        address to;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n    }\\n\\n    struct Receipt {\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        address contractAddress;\\n        uint256 cumulativeGasUsed;\\n        uint256 effectiveGasPrice;\\n        address from;\\n        uint256 gasUsed;\\n        ReceiptLog[] logs;\\n        bytes logsBloom;\\n        uint256 status;\\n        address to;\\n        bytes32 transactionHash;\\n        uint256 transactionIndex;\\n    }\\n\\n    // Data structures to parse the entire broadcast artifact, assuming the\\n    // transactions conform to EIP1559.\\n\\n    struct EIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        Receipt[] receipts;\\n        uint256 timestamp;\\n        Tx1559[] transactions;\\n        TxReturn[] txReturns;\\n    }\\n\\n    struct RawEIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        RawReceipt[] receipts;\\n        TxReturn[] txReturns;\\n        uint256 timestamp;\\n        RawTx1559[] transactions;\\n    }\\n\\n    struct RawReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        bytes data;\\n        bytes logIndex;\\n        bool removed;\\n        bytes32[] topics;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n        bytes transactionLogIndex;\\n    }\\n\\n    struct ReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        bytes data;\\n        uint256 logIndex;\\n        bytes32[] topics;\\n        uint256 transactionIndex;\\n        uint256 transactionLogIndex;\\n        bool removed;\\n    }\\n\\n    struct TxReturn {\\n        string internalType;\\n        string value;\\n    }\\n\\n    struct Account {\\n        address addr;\\n        uint256 key;\\n    }\\n\\n    enum AddressType {\\n        Payable,\\n        NonPayable,\\n        ZeroAddress,\\n        Precompile,\\n        ForgeAddress\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\\n        // Nothing to check if `token` is not a contract.\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\\\");\\n\\n        bool success;\\n        bytes memory returnData;\\n\\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n\\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\\n    // backwards compatibility, since this name was used in the original PR which has already has\\n    // a release. This function can be removed in a future release once we want a breaking change.\\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\\n        assumeNotBlacklisted(token, addr);\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\\n        if (addressType == AddressType.Payable) {\\n            assumeNotPayable(addr);\\n        } else if (addressType == AddressType.NonPayable) {\\n            assumePayable(addr);\\n        } else if (addressType == AddressType.ZeroAddress) {\\n            assumeNotZeroAddress(addr);\\n        } else if (addressType == AddressType.Precompile) {\\n            assumeNotPrecompile(addr);\\n        } else if (addressType == AddressType.ForgeAddress) {\\n            assumeNotForgeAddress(addr);\\n        }\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3,\\n        AddressType addressType4\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n        assumeAddressIsNot(addr, addressType4);\\n    }\\n\\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\\n    // `addr` and checking the `success` return value.\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used.\\n    function _isPayable(address addr) private returns (bool) {\\n        require(\\n            addr.balance < UINT256_MAX,\\n            \\\"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\\\"\\n        );\\n        uint256 origBalanceTest = address(this).balance;\\n        uint256 origBalanceAddr = address(addr).balance;\\n\\n        vm.deal(address(this), 1);\\n        (bool success,) = payable(addr).call{value: 1}(\\\"\\\");\\n\\n        // reset balances\\n        vm.deal(address(this), origBalanceTest);\\n        vm.deal(addr, origBalanceAddr);\\n\\n        return success;\\n    }\\n\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used. See the\\n    // `_isPayable` method for more information.\\n    function assumePayable(address addr) internal virtual {\\n        vm.assume(_isPayable(addr));\\n    }\\n\\n    function assumeNotPayable(address addr) internal virtual {\\n        vm.assume(!_isPayable(addr));\\n    }\\n\\n    function assumeNotZeroAddress(address addr) internal pure virtual {\\n        vm.assume(addr != address(0));\\n    }\\n\\n    function assumeNotPrecompile(address addr) internal pure virtual {\\n        assumeNotPrecompile(addr, _pureChainId());\\n    }\\n\\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\\n        // address), but the same rationale for excluding them applies so we include those too.\\n\\n        // These should be present on all EVM-compatible chains.\\n        vm.assume(addr < address(0x1) || addr > address(0x9));\\n\\n        // forgefmt: disable-start\\n        if (chainId == 10 || chainId == 420) {\\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\\n        } else if (chainId == 42161 || chainId == 421613) {\\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\\n        } else if (chainId == 43114 || chainId == 43113) {\\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\\n        }\\n        // forgefmt: disable-end\\n    }\\n\\n    function assumeNotForgeAddress(address addr) internal pure virtual {\\n        // vm, console, and Create2Deployer addresses\\n        vm.assume(\\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\\n        );\\n    }\\n\\n    function readEIP1559ScriptArtifact(string memory path)\\n        internal\\n        view\\n        virtual\\n        returns (EIP1559ScriptArtifact memory)\\n    {\\n        string memory data = vm.readFile(path);\\n        bytes memory parsedData = vm.parseJson(data);\\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\\n        EIP1559ScriptArtifact memory artifact;\\n        artifact.libraries = rawArtifact.libraries;\\n        artifact.path = rawArtifact.path;\\n        artifact.timestamp = rawArtifact.timestamp;\\n        artifact.pending = rawArtifact.pending;\\n        artifact.txReturns = rawArtifact.txReturns;\\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\\n        return artifact;\\n    }\\n\\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\\n        for (uint256 i; i < rawTxs.length; i++) {\\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\\n        }\\n        return txs;\\n    }\\n\\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\\n        Tx1559 memory transaction;\\n        transaction.arguments = rawTx.arguments;\\n        transaction.contractName = rawTx.contractName;\\n        transaction.functionSig = rawTx.functionSig;\\n        transaction.hash = rawTx.hash;\\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\\n        transaction.opcode = rawTx.opcode;\\n        return transaction;\\n    }\\n\\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\\n        internal\\n        pure\\n        virtual\\n        returns (Tx1559Detail memory)\\n    {\\n        Tx1559Detail memory txDetail;\\n        txDetail.data = rawDetail.data;\\n        txDetail.from = rawDetail.from;\\n        txDetail.to = rawDetail.to;\\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\\n        txDetail.txType = _bytesToUint(rawDetail.txType);\\n        txDetail.value = _bytesToUint(rawDetail.value);\\n        txDetail.gas = _bytesToUint(rawDetail.gas);\\n        txDetail.accessList = rawDetail.accessList;\\n        return txDetail;\\n    }\\n\\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".transactions\\\");\\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\\n        return rawToConvertedEIPTx1559s(rawTxs);\\n    }\\n\\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".transactions[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\\n        return rawToConvertedEIPTx1559(rawTx);\\n    }\\n\\n    // Analogous to readTransactions, but for receipts.\\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".receipts\\\");\\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\\n        return rawToConvertedReceipts(rawReceipts);\\n    }\\n\\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".receipts[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\\n        return rawToConvertedReceipt(rawReceipt);\\n    }\\n\\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\\n        for (uint256 i; i < rawReceipts.length; i++) {\\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\\n        }\\n        return receipts;\\n    }\\n\\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\\n        Receipt memory receipt;\\n        receipt.blockHash = rawReceipt.blockHash;\\n        receipt.to = rawReceipt.to;\\n        receipt.from = rawReceipt.from;\\n        receipt.contractAddress = rawReceipt.contractAddress;\\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\\n        receipt.status = _bytesToUint(rawReceipt.status);\\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\\n        receipt.logsBloom = rawReceipt.logsBloom;\\n        receipt.transactionHash = rawReceipt.transactionHash;\\n        return receipt;\\n    }\\n\\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\\n        internal\\n        pure\\n        virtual\\n        returns (ReceiptLog[] memory)\\n    {\\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\\n        for (uint256 i; i < rawLogs.length; i++) {\\n            logs[i].logAddress = rawLogs[i].logAddress;\\n            logs[i].blockHash = rawLogs[i].blockHash;\\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\\n            logs[i].data = rawLogs[i].data;\\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\\n            logs[i].topics = rawLogs[i].topics;\\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\\n            logs[i].removed = rawLogs[i].removed;\\n        }\\n        return logs;\\n    }\\n\\n    // Deploy a contract by fetching the contract bytecode from\\n    // the artifacts directory\\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string): Deployment failed.\\\");\\n    }\\n\\n    /// @dev deploy contract with value on construction\\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes,uint256): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,uint256): Deployment failed.\\\");\\n    }\\n\\n    // creates a labeled address and the corresponding private key\\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\\n        addr = vm.addr(privateKey);\\n        vm.label(addr, name);\\n    }\\n\\n    // creates a labeled address\\n    function makeAddr(string memory name) internal virtual returns (address addr) {\\n        (addr,) = makeAddrAndKey(name);\\n    }\\n\\n    // Destroys an account immediately, sending the balance to beneficiary.\\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\\n    // only after tx ends, this will run immediately.\\n    function destroyAccount(address who, address beneficiary) internal virtual {\\n        uint256 currBalance = who.balance;\\n        vm.etch(who, abi.encode());\\n        vm.deal(who, 0);\\n        vm.resetNonce(who);\\n\\n        uint256 beneficiaryBalance = beneficiary.balance;\\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\\n    }\\n\\n    // creates a struct containing both a labeled address and the corresponding private key\\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\\n        (account.addr, account.key) = makeAddrAndKey(name);\\n    }\\n\\n    function deriveRememberKey(string memory mnemonic, uint32 index)\\n        internal\\n        virtual\\n        returns (address who, uint256 privateKey)\\n    {\\n        privateKey = vm.deriveKey(mnemonic, index);\\n        who = vm.rememberKey(privateKey);\\n    }\\n\\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\\n        require(b.length <= 32, \\\"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    function isFork() internal view virtual returns (bool status) {\\n        try vm.activeFork() {\\n            status = true;\\n        } catch (bytes memory) {}\\n    }\\n\\n    modifier skipWhenForking() {\\n        if (!isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier skipWhenNotForking() {\\n        if (isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier noGasMetering() {\\n        vm.pauseGasMetering();\\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\\n        // it back on until we exit the top level function that used the modifier\\n        //\\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\\n        // so we only turn metering back on at the end of the funcA\\n        bool gasStartedOff = gasMeteringOff;\\n        gasMeteringOff = true;\\n\\n        _;\\n\\n        // if gas metering was on when this modifier was called, turn it back on at the end\\n        if (!gasStartedOff) {\\n            gasMeteringOff = false;\\n            vm.resumeGasMetering();\\n        }\\n    }\\n\\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\\n    // Checker changed `chainid` from pure to view in 0.8.0.\\n    function _viewChainId() private view returns (uint256 chainId) {\\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        address(this); // Silence warnings in older Solc versions.\\n    }\\n\\n    function _pureChainId() private pure returns (uint256 chainId) {\\n        function() internal view returns (uint256) fnIn = _viewChainId;\\n        function() internal pure returns (uint256) pureChainId;\\n        assembly {\\n            pureChainId := fnIn\\n        }\\n        chainId = pureChainId();\\n    }\\n}\\n\\n// Wrappers around cheatcodes to avoid footguns\\nabstract contract StdCheats is StdCheatsSafe {\\n    using stdStorage for StdStorage;\\n\\n    StdStorage private stdstore;\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Skip forward or rewind time by the specified number of seconds\\n    function skip(uint256 time) internal virtual {\\n        vm.warp(block.timestamp + time);\\n    }\\n\\n    function rewind(uint256 time) internal virtual {\\n        vm.warp(block.timestamp - time);\\n    }\\n\\n    // Setup a prank from an address that has some ether\\n    function hoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    function startHoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function startHoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    // tx.origin is set to the origin parameter\\n    function startHoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function changePrank(address msgSender) internal virtual {\\n        console2_log_StdCheats(\\\"changePrank is deprecated. Please use vm.startPrank instead.\\\");\\n        vm.stopPrank();\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function changePrank(address msgSender, address txOrigin) internal virtual {\\n        vm.stopPrank();\\n        vm.startPrank(msgSender, txOrigin);\\n    }\\n\\n    // The same as Vm's `deal`\\n    // Use the alternative signature for ERC20 tokens\\n    function deal(address to, uint256 give) internal virtual {\\n        vm.deal(to, give);\\n    }\\n\\n    // Set the balance of an account for any ERC20 token\\n    // Use the alternative signature to update `totalSupply`\\n    function deal(address token, address to, uint256 give) internal virtual {\\n        deal(token, to, give, false);\\n    }\\n\\n    // Set the balance of an account for any ERC1155 token\\n    // Use the alternative signature to update `totalSupply`\\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\\n        dealERC1155(token, to, id, give, false);\\n    }\\n\\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\\n            require(\\n                totSupData.length != 0,\\n                \\\"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\\\"\\n            );\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC721(address token, address to, uint256 id) internal virtual {\\n        // check if token id is already minted and the actual owner.\\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\\n        require(successMinted, \\\"StdCheats deal(address,address,uint,bool): id not minted.\\\");\\n\\n        // get owner current balance\\n        (, bytes memory fromBalData) =\\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\\n\\n        // get new user current balance\\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\\n\\n        // update balances\\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\\n\\n        // update owner\\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\\n    }\\n\\n    function deployCodeTo(string memory what, address where) internal virtual {\\n        deployCodeTo(what, \\\"\\\", 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\\n        deployCodeTo(what, args, 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\\n        bytes memory creationCode = vm.getCode(what);\\n        vm.etch(where, abi.encodePacked(creationCode, args));\\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\\\"\\\");\\n        require(success, \\\"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\\\");\\n        vm.etch(where, runtimeBytecode);\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n    function console2_log_StdCheats(string memory p0) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n        status;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdError {\\n    bytes public constant assertionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x01);\\n    bytes public constant arithmeticError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11);\\n    bytes public constant divisionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x12);\\n    bytes public constant enumConversionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x21);\\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x22);\\n    bytes public constant popError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x31);\\n    bytes public constant indexOOBError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x32);\\n    bytes public constant memOverflowError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x41);\\n    bytes public constant zeroVarError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x51);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdInvariant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nabstract contract StdInvariant {\\n    struct FuzzSelector {\\n        address addr;\\n        bytes4[] selectors;\\n    }\\n\\n    struct FuzzInterface {\\n        address addr;\\n        string[] artifacts;\\n    }\\n\\n    address[] private _excludedContracts;\\n    address[] private _excludedSenders;\\n    address[] private _targetedContracts;\\n    address[] private _targetedSenders;\\n\\n    string[] private _excludedArtifacts;\\n    string[] private _targetedArtifacts;\\n\\n    FuzzSelector[] private _targetedArtifactSelectors;\\n    FuzzSelector[] private _targetedSelectors;\\n\\n    FuzzInterface[] private _targetedInterfaces;\\n\\n    // Functions for users:\\n    // These are intended to be called in tests.\\n\\n    function excludeContract(address newExcludedContract_) internal {\\n        _excludedContracts.push(newExcludedContract_);\\n    }\\n\\n    function excludeSender(address newExcludedSender_) internal {\\n        _excludedSenders.push(newExcludedSender_);\\n    }\\n\\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\\n        _excludedArtifacts.push(newExcludedArtifact_);\\n    }\\n\\n    function targetArtifact(string memory newTargetedArtifact_) internal {\\n        _targetedArtifacts.push(newTargetedArtifact_);\\n    }\\n\\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\\n    }\\n\\n    function targetContract(address newTargetedContract_) internal {\\n        _targetedContracts.push(newTargetedContract_);\\n    }\\n\\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\\n        _targetedSelectors.push(newTargetedSelector_);\\n    }\\n\\n    function targetSender(address newTargetedSender_) internal {\\n        _targetedSenders.push(newTargetedSender_);\\n    }\\n\\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\\n        _targetedInterfaces.push(newTargetedInterface_);\\n    }\\n\\n    // Functions for forge:\\n    // These are called by forge to run invariant tests and don't need to be called in tests.\\n\\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\\n        excludedArtifacts_ = _excludedArtifacts;\\n    }\\n\\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\\n        excludedContracts_ = _excludedContracts;\\n    }\\n\\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\\n        excludedSenders_ = _excludedSenders;\\n    }\\n\\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\\n        targetedArtifacts_ = _targetedArtifacts;\\n    }\\n\\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\\n    }\\n\\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\\n        targetedContracts_ = _targetedContracts;\\n    }\\n\\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\\n        targetedSelectors_ = _targetedSelectors;\\n    }\\n\\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\\n        targetedSenders_ = _targetedSenders;\\n    }\\n\\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\\n        targetedInterfaces_ = _targetedInterfaces;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdJson.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n// Helpers for parsing and writing JSON files\\n// To parse:\\n// ```\\n// using stdJson for string;\\n// string memory json = vm.readFile(\\\"some_path\\\");\\n// json.parseUint(\\\"<json_path>\\\");\\n// ```\\n// To write:\\n// ```\\n// using stdJson for string;\\n// string memory json = \\\"deploymentArtifact\\\";\\n// Contract contract = new Contract();\\n// json.serialize(\\\"contractAddress\\\", address(contract));\\n// json = json.serialize(\\\"deploymentTimes\\\", uint(1));\\n// // store the stringified JSON to the 'json' variable we have been using as a key\\n// // as we won't need it any longer\\n// string memory json2 = \\\"finalArtifact\\\";\\n// string memory final = json2.serialize(\\\"depArtifact\\\", json);\\n// final.write(\\\"<some_path>\\\");\\n// ```\\n\\nlibrary stdJson {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJson(json, key);\\n    }\\n\\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\\n        return vm.parseJsonUint(json, key);\\n    }\\n\\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\\n        return vm.parseJsonUintArray(json, key);\\n    }\\n\\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\\n        return vm.parseJsonInt(json, key);\\n    }\\n\\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\\n        return vm.parseJsonIntArray(json, key);\\n    }\\n\\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\\n        return vm.parseJsonBytes32(json, key);\\n    }\\n\\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\\n        return vm.parseJsonBytes32Array(json, key);\\n    }\\n\\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\\n        return vm.parseJsonString(json, key);\\n    }\\n\\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\\n        return vm.parseJsonStringArray(json, key);\\n    }\\n\\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\\n        return vm.parseJsonAddress(json, key);\\n    }\\n\\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\\n        return vm.parseJsonAddressArray(json, key);\\n    }\\n\\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\\n        return vm.parseJsonBool(json, key);\\n    }\\n\\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\\n        return vm.parseJsonBoolArray(json, key);\\n    }\\n\\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJsonBytes(json, key);\\n    }\\n\\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\\n        return vm.parseJsonBytesArray(json, key);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\\n        return vm.serializeJson(jsonKey, rootObject);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function write(string memory jsonKey, string memory path) internal {\\n        vm.writeJson(jsonKey, path);\\n    }\\n\\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\\n        vm.writeJson(jsonKey, path, valueKey);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdMath {\\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        // Required or it will fail when `a = type(int256).min`\\n        if (a == INT256_MIN) {\\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n        }\\n\\n        return uint256(a > 0 ? a : -a);\\n    }\\n\\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a - b : b - a;\\n    }\\n\\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\\n        // a and b are of the same sign\\n        // this works thanks to two's complement, the left-most bit is the sign bit\\n        if ((a ^ b) > -1) {\\n            return delta(abs(a), abs(b));\\n        }\\n\\n        // a and b are of opposite signs\\n        return abs(a) + abs(b);\\n    }\\n\\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n\\n        return absDelta * 1e18 / b;\\n    }\\n\\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n        uint256 absB = abs(b);\\n\\n        return absDelta * 1e18 / absB;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nstruct StdStorage {\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\\n    bytes32[] _keys;\\n    bytes4 _sig;\\n    uint256 _depth;\\n    address _target;\\n    bytes32 _set;\\n}\\n\\nlibrary stdStorageSafe {\\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\\n    event WARNING_UninitedSlot(address who, uint256 slot);\\n\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(sigStr)));\\n    }\\n\\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\\n    // slot complexity:\\n    //  if flat, will be bytes32(uint256(uint));\\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        // calldata to test against\\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n        }\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        vm.record();\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n\\n        (bytes32[] memory reads,) = vm.accesses(address(who));\\n        if (reads.length == 1) {\\n            bytes32 curr = vm.load(who, reads[0]);\\n            if (curr == bytes32(0)) {\\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\\n            }\\n            if (fdat != curr) {\\n                require(\\n                    false,\\n                    \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n                );\\n            }\\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n        } else if (reads.length > 1) {\\n            for (uint256 i = 0; i < reads.length; i++) {\\n                bytes32 prev = vm.load(who, reads[i]);\\n                if (prev == bytes32(0)) {\\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\\n                }\\n                if (prev != fdat) {\\n                    continue;\\n                }\\n                bytes32 new_val = ~prev;\\n                // store\\n                vm.store(who, reads[i], new_val);\\n                bool success;\\n                {\\n                    bytes memory rdat;\\n                    (success, rdat) = who.staticcall(cald);\\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\\n                }\\n\\n                if (success && fdat == new_val) {\\n                    // we found which of the slots is the actual one\\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n                    vm.store(who, reads[i], prev);\\n                    break;\\n                }\\n                vm.store(who, reads[i], prev);\\n            }\\n        } else {\\n            revert(\\\"stdStorage find(StdStorage): No storage use detected for target.\\\");\\n        }\\n\\n        require(\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\\n            \\\"stdStorage find(StdStorage): Slot(s) not found.\\\"\\n        );\\n\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n\\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        self._target = _target;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        self._sig = _sig;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        self._sig = sigs(_sig);\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(uint256(uint160(who))));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(amt));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        self._keys.push(key);\\n        return self;\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        self._depth = _depth;\\n        return self;\\n    }\\n\\n    function read(StdStorage storage self) private returns (bytes memory) {\\n        address t = self._target;\\n        uint256 s = find(self);\\n        return abi.encode(vm.load(t, bytes32(s)));\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return abi.decode(read(self), (bytes32));\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        int256 v = read_int(self);\\n        if (v == 0) return false;\\n        if (v == 1) return true;\\n        revert(\\\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\\\");\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return abi.decode(read(self), (address));\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return abi.decode(read(self), (uint256));\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return abi.decode(read(self), (int256));\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        return (uint256(parent_slot), key);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        bool found;\\n        bytes32 root_slot;\\n        bytes32 parent_slot;\\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        while (found) {\\n            root_slot = parent_slot;\\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\\n        }\\n        return uint256(root_slot);\\n    }\\n\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nlibrary stdStorage {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return stdStorageSafe.sigs(sigStr);\\n    }\\n\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.find(self);\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        return stdStorageSafe.target(self, _target);\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, who);\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, amt);\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, key);\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        return stdStorageSafe.depth(self, _depth);\\n    }\\n\\n    function checked_write(StdStorage storage self, address who) internal {\\n        checked_write(self, bytes32(uint256(uint160(who))));\\n    }\\n\\n    function checked_write(StdStorage storage self, uint256 amt) internal {\\n        checked_write(self, bytes32(amt));\\n    }\\n\\n    function checked_write_int(StdStorage storage self, int256 val) internal {\\n        checked_write(self, bytes32(uint256(val)));\\n    }\\n\\n    function checked_write(StdStorage storage self, bool write) internal {\\n        bytes32 t;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            t := write\\n        }\\n        checked_write(self, t);\\n    }\\n\\n    function checked_write(StdStorage storage self, bytes32 set) internal {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            find(self);\\n        }\\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\\n\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n        bytes32 curr = vm.load(who, slot);\\n\\n        if (fdat != curr) {\\n            require(\\n                false,\\n                \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n            );\\n        }\\n        vm.store(who, slot, set);\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return stdStorageSafe.read_bytes32(self);\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        return stdStorageSafe.read_bool(self);\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return stdStorageSafe.read_address(self);\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.read_uint(self);\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return stdStorageSafe.read_int(self);\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        return stdStorageSafe.parent(self);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.root(self);\\n    }\\n\\n    // Private function so needs to be copied over\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    // Private function so needs to be copied over\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdStyle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nlibrary StdStyle {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    string constant RED = \\\"\\\\u001b[91m\\\";\\n    string constant GREEN = \\\"\\\\u001b[92m\\\";\\n    string constant YELLOW = \\\"\\\\u001b[93m\\\";\\n    string constant BLUE = \\\"\\\\u001b[94m\\\";\\n    string constant MAGENTA = \\\"\\\\u001b[95m\\\";\\n    string constant CYAN = \\\"\\\\u001b[96m\\\";\\n    string constant BOLD = \\\"\\\\u001b[1m\\\";\\n    string constant DIM = \\\"\\\\u001b[2m\\\";\\n    string constant ITALIC = \\\"\\\\u001b[3m\\\";\\n    string constant UNDERLINE = \\\"\\\\u001b[4m\\\";\\n    string constant INVERSE = \\\"\\\\u001b[7m\\\";\\n    string constant RESET = \\\"\\\\u001b[0m\\\";\\n\\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\\n        return string(abi.encodePacked(style, self, RESET));\\n    }\\n\\n    function red(string memory self) internal pure returns (string memory) {\\n        return styleConcat(RED, self);\\n    }\\n\\n    function red(uint256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(int256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(address self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(bool self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes(bytes memory self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function green(string memory self) internal pure returns (string memory) {\\n        return styleConcat(GREEN, self);\\n    }\\n\\n    function green(uint256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(int256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(address self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(bool self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function yellow(string memory self) internal pure returns (string memory) {\\n        return styleConcat(YELLOW, self);\\n    }\\n\\n    function yellow(uint256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(int256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(address self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(bool self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function blue(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BLUE, self);\\n    }\\n\\n    function blue(uint256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(int256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(address self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(bool self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function magenta(string memory self) internal pure returns (string memory) {\\n        return styleConcat(MAGENTA, self);\\n    }\\n\\n    function magenta(uint256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(int256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(address self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(bool self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function cyan(string memory self) internal pure returns (string memory) {\\n        return styleConcat(CYAN, self);\\n    }\\n\\n    function cyan(uint256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(int256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(address self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(bool self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function bold(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BOLD, self);\\n    }\\n\\n    function bold(uint256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(int256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(address self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(bool self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function dim(string memory self) internal pure returns (string memory) {\\n        return styleConcat(DIM, self);\\n    }\\n\\n    function dim(uint256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(int256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(address self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(bool self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function italic(string memory self) internal pure returns (string memory) {\\n        return styleConcat(ITALIC, self);\\n    }\\n\\n    function italic(uint256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(int256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(address self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(bool self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function underline(string memory self) internal pure returns (string memory) {\\n        return styleConcat(UNDERLINE, self);\\n    }\\n\\n    function underline(uint256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(int256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(address self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(bool self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function inverse(string memory self) internal pure returns (string memory) {\\n        return styleConcat(INVERSE, self);\\n    }\\n\\n    function inverse(uint256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(int256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(address self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(bool self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IMulticall3} from \\\"./interfaces/IMulticall3.sol\\\";\\nimport {MockERC20} from \\\"./mocks/MockERC20.sol\\\";\\nimport {MockERC721} from \\\"./mocks/MockERC721.sol\\\";\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdUtils {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    uint256 private constant INT256_MIN_ABS =\\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    uint256 private constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\\n        require(min <= max, \\\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\\\");\\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\\n        if (x >= min && x <= max) return x;\\n\\n        uint256 size = max - min + 1;\\n\\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\\n        // This helps ensure coverage of the min/max values.\\n        if (x <= 3 && size > x) return min + x;\\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\\n\\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\\n        if (x > max) {\\n            uint256 diff = x - max;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return max;\\n            result = min + rem - 1;\\n        } else if (x < min) {\\n            uint256 diff = min - x;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return min;\\n            result = max - rem + 1;\\n        }\\n    }\\n\\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\\n        result = _bound(x, min, max);\\n        console2_log_StdUtils(\\\"Bound Result\\\", result);\\n    }\\n\\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\\n        require(min <= max, \\\"StdUtils bound(int256,int256,int256): Max is less than min.\\\");\\n\\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\\n        // int256 : -(2**255) ~ (2**255 - 1)\\n        // uint256:     0     ~ (2**256 - 1)\\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\\n        //\\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\\n        // So, use `~uint256(x) + 1` instead.\\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\\n\\n        uint256 y = _bound(_x, _min, _max);\\n\\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\\n    }\\n\\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\\n        result = _bound(x, min, max);\\n        console2_log_StdUtils(\\\"Bound result\\\", vm.toString(result));\\n    }\\n\\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\\n    }\\n\\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\\n        require(b.length <= 32, \\\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\\n        console2_log_StdUtils(\\\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\\\");\\n        return vm.computeCreateAddress(deployer, nonce);\\n    }\\n\\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\\n        internal\\n        pure\\n        virtual\\n        returns (address)\\n    {\\n        console2_log_StdUtils(\\\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\\\");\\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\\n    }\\n\\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\\n        console2_log_StdUtils(\\\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\\\");\\n        return vm.computeCreate2Address(salt, initCodeHash);\\n    }\\n\\n    /// @dev returns an initialized mock ERC20 contract\\n    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)\\n        internal\\n        returns (MockERC20 mock)\\n    {\\n        mock = new MockERC20();\\n        mock.initialize(name, symbol, decimals);\\n    }\\n\\n    /// @dev returns an initialized mock ERC721 contract\\n    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {\\n        mock = new MockERC721();\\n        mock.initialize(name, symbol);\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\\n        return hashInitCode(creationCode, \\\"\\\");\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    /// @param args the ABI-encoded arguments to the constructor of C\\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(creationCode, args));\\n    }\\n\\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\\n    function getTokenBalances(address token, address[] memory addresses)\\n        internal\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\\\");\\n\\n        // ABI encode the aggregate call to Multicall3.\\n        uint256 length = addresses.length;\\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            // 0x70a08231 = bytes4(\\\"balanceOf(address)\\\"))\\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\\n        }\\n\\n        // Make the aggregate call.\\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\\n\\n        // ABI decode the return data and return the balances.\\n        balances = new uint256[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            balances[i] = abi.decode(returnData[i], (uint256));\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 PRIVATE FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\\n    // any breaking changes to function signatures.\\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\\n        internal\\n        pure\\n        returns (function(bytes memory) internal pure fnOut)\\n    {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE2_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function console2_log_StdUtils(string memory p0) private pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Vm.sol\": {\r\n      \"content\": \"// Automatically @generated by scripts/vm.py. Do not modify manually.\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.2 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\\n/// these cheats in scripts.\\ninterface VmSafe {\\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\\n    enum CallerMode {\\n        // No caller modification is currently active.\\n        None,\\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\\n        Broadcast,\\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\\n        RecurrentBroadcast,\\n        // A one time prank triggered by a `vm.prank()` call is currently active.\\n        Prank,\\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\\n        RecurrentPrank\\n    }\\n\\n    /// The kind of account access that occurred.\\n    enum AccountAccessKind {\\n        // The account was called.\\n        Call,\\n        // The account was called via delegatecall.\\n        DelegateCall,\\n        // The account was called via callcode.\\n        CallCode,\\n        // The account was called via staticcall.\\n        StaticCall,\\n        // The account was created.\\n        Create,\\n        // The account was selfdestructed.\\n        SelfDestruct,\\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\\n        Resume,\\n        // The account's balance was read.\\n        Balance,\\n        // The account's codesize was read.\\n        Extcodesize,\\n        // The account's codehash was read.\\n        Extcodehash,\\n        // The account's code was copied.\\n        Extcodecopy\\n    }\\n\\n    /// An Ethereum log. Returned by `getRecordedLogs`.\\n    struct Log {\\n        // The topics of the log, including the signature, if any.\\n        bytes32[] topics;\\n        // The raw data of the log.\\n        bytes data;\\n        // The address of the log's emitter.\\n        address emitter;\\n    }\\n\\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\\n    struct Rpc {\\n        // The alias of the RPC URL.\\n        string key;\\n        // The RPC URL.\\n        string url;\\n    }\\n\\n    /// An RPC log object. Returned by `eth_getLogs`.\\n    struct EthGetLogs {\\n        // The address of the log's emitter.\\n        address emitter;\\n        // The topics of the log, including the signature, if any.\\n        bytes32[] topics;\\n        // The raw data of the log.\\n        bytes data;\\n        // The block hash.\\n        bytes32 blockHash;\\n        // The block number.\\n        uint64 blockNumber;\\n        // The transaction hash.\\n        bytes32 transactionHash;\\n        // The transaction index in the block.\\n        uint64 transactionIndex;\\n        // The log index.\\n        uint256 logIndex;\\n        // Whether the log was removed.\\n        bool removed;\\n    }\\n\\n    /// A single entry in a directory listing. Returned by `readDir`.\\n    struct DirEntry {\\n        // The error message, if any.\\n        string errorMessage;\\n        // The path of the entry.\\n        string path;\\n        // The depth of the entry.\\n        uint64 depth;\\n        // Whether the entry is a directory.\\n        bool isDir;\\n        // Whether the entry is a symlink.\\n        bool isSymlink;\\n    }\\n\\n    /// Metadata information about a file.\\n    /// This structure is returned from the `fsMetadata` function and represents known\\n    /// metadata about a file such as its permissions, size, modification\\n    /// times, etc.\\n    struct FsMetadata {\\n        // True if this metadata is for a directory.\\n        bool isDir;\\n        // True if this metadata is for a symlink.\\n        bool isSymlink;\\n        // The size of the file, in bytes, this metadata is for.\\n        uint256 length;\\n        // True if this metadata is for a readonly (unwritable) file.\\n        bool readOnly;\\n        // The last modification time listed in this metadata.\\n        uint256 modified;\\n        // The last access time of this metadata.\\n        uint256 accessed;\\n        // The creation time listed in this metadata.\\n        uint256 created;\\n    }\\n\\n    /// A wallet with a public and private key.\\n    struct Wallet {\\n        // The wallet's address.\\n        address addr;\\n        // The wallet's public key `X`.\\n        uint256 publicKeyX;\\n        // The wallet's public key `Y`.\\n        uint256 publicKeyY;\\n        // The wallet's private key.\\n        uint256 privateKey;\\n    }\\n\\n    /// The result of a `tryFfi` call.\\n    struct FfiResult {\\n        // The exit code of the call.\\n        int32 exitCode;\\n        // The optionally hex-decoded `stdout` data.\\n        bytes stdout;\\n        // The `stderr` data.\\n        bytes stderr;\\n    }\\n\\n    /// Information on the chain and fork.\\n    struct ChainInfo {\\n        // The fork identifier. Set to zero if no fork is active.\\n        uint256 forkId;\\n        // The chain ID of the current fork.\\n        uint256 chainId;\\n    }\\n\\n    /// The result of a `stopAndReturnStateDiff` call.\\n    struct AccountAccess {\\n        // The chain and fork the access occurred.\\n        ChainInfo chainInfo;\\n        // The kind of account access that determines what the account is.\\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\\n        // If kind is Create, then the account is the newly created account.\\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\\n        // If kind is a Resume, then account represents a account context that has resumed.\\n        AccountAccessKind kind;\\n        // The account that was accessed.\\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\\n        address account;\\n        // What accessed the account.\\n        address accessor;\\n        // If the account was initialized or empty prior to the access.\\n        // An account is considered initialized if it has code, a\\n        // non-zero nonce, or a non-zero balance.\\n        bool initialized;\\n        // The previous balance of the accessed account.\\n        uint256 oldBalance;\\n        // The potential new balance of the accessed account.\\n        // That is, all balance changes are recorded here, even if reverts occurred.\\n        uint256 newBalance;\\n        // Code of the account deployed by CREATE.\\n        bytes deployedCode;\\n        // Value passed along with the account access\\n        uint256 value;\\n        // Input data provided to the CREATE or CALL\\n        bytes data;\\n        // If this access reverted in either the current or parent context.\\n        bool reverted;\\n        // An ordered list of storage accesses made during an account access operation.\\n        StorageAccess[] storageAccesses;\\n    }\\n\\n    /// The storage accessed during an `AccountAccess`.\\n    struct StorageAccess {\\n        // The account whose storage was accessed.\\n        address account;\\n        // The slot that was accessed.\\n        bytes32 slot;\\n        // If the access was a write.\\n        bool isWrite;\\n        // The previous value of the slot.\\n        bytes32 previousValue;\\n        // The new value of the slot.\\n        bytes32 newValue;\\n        // If the access was reverted.\\n        bool reverted;\\n    }\\n\\n    // ======== Environment ========\\n\\n    /// Gets the environment variable `name` and parses it as `address`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envAddress(string calldata name) external view returns (address value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `bool`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBool(string calldata name) external view returns (bool value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `bytes32`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBytes32(string calldata name) external view returns (bytes32 value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `bytes`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBytes(string calldata name) external view returns (bytes memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `int256`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envInt(string calldata name) external view returns (int256 value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `bool`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\\n\\n    /// Gets the environment variable `name` and parses it as `uint256`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\\n        external\\n        view\\n        returns (address[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\\n        external\\n        view\\n        returns (bytes32[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\\n        external\\n        view\\n        returns (string[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\\n        external\\n        view\\n        returns (bytes[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `int256`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\\n\\n    /// Gets the environment variable `name` and parses it as `address`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\\n\\n    /// Gets the environment variable `name` and parses it as `bytes32`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\\n\\n    /// Gets the environment variable `name` and parses it as `string`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `bytes`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\\n        external\\n        view\\n        returns (bool[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\\n        external\\n        view\\n        returns (uint256[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\\n    /// Reverts if the variable could not be parsed.\\n    /// Returns `defaultValue` if the variable was not found.\\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\\n        external\\n        view\\n        returns (int256[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `string`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envString(string calldata name) external view returns (string memory value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\\n\\n    /// Gets the environment variable `name` and parses it as `uint256`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envUint(string calldata name) external view returns (uint256 value);\\n\\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\\n    /// Reverts if the variable was not found or could not be parsed.\\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\\n\\n    /// Sets environment variables.\\n    function setEnv(string calldata name, string calldata value) external;\\n\\n    // ======== EVM ========\\n\\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\\n\\n    /// Gets the address for a given private key.\\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\\n\\n    /// Gets all the logs according to specified filter.\\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\\n        external\\n        returns (EthGetLogs[] memory logs);\\n\\n    /// Gets the current `block.number`.\\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\\n    /// and as a result will get optimized out by the compiler.\\n    /// See https://github.com/foundry-rs/foundry/issues/6180\\n    function getBlockNumber() external view returns (uint256 height);\\n\\n    /// Gets the current `block.timestamp`.\\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\\n    /// and as a result will get optimized out by the compiler.\\n    /// See https://github.com/foundry-rs/foundry/issues/6180\\n    function getBlockTimestamp() external view returns (uint256 timestamp);\\n\\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\\n        external\\n        returns (bool found, bytes32 key, bytes32 parent);\\n\\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\\n\\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\\n\\n    /// Gets the nonce of an account.\\n    function getNonce(address account) external view returns (uint64 nonce);\\n\\n    /// Gets all the recorded logs.\\n    function getRecordedLogs() external returns (Log[] memory logs);\\n\\n    /// Loads a storage slot from an address.\\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\\n\\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\\n    function pauseGasMetering() external;\\n\\n    /// Records all storage reads and writes.\\n    function record() external;\\n\\n    /// Record all the transaction logs.\\n    function recordLogs() external;\\n\\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\\n    function resumeGasMetering() external;\\n\\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\\n\\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\\n\\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\\n\\n    /// Starts recording all map SSTOREs for later retrieval.\\n    function startMappingRecording() external;\\n\\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\\n    /// along with the context of the calls\\n    function startStateDiffRecording() external;\\n\\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\\n\\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\\n    function stopMappingRecording() external;\\n\\n    // ======== Filesystem ========\\n\\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\\n    /// `path` is relative to the project root.\\n    function closeFile(string calldata path) external;\\n\\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\\n    /// Both `from` and `to` are relative to the project root.\\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\\n\\n    /// Creates a new, empty directory at the provided path.\\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    /// - User lacks permissions to modify `path`.\\n    /// - A parent of the given path doesn't exist and `recursive` is false.\\n    /// - `path` already exists and `recursive` is false.\\n    /// `path` is relative to the project root.\\n    function createDir(string calldata path, bool recursive) external;\\n\\n    /// Returns true if the given path points to an existing entity, else returns false.\\n    function exists(string calldata path) external returns (bool result);\\n\\n    /// Performs a foreign function call via the terminal.\\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\\n\\n    /// Given a path, query the file system to get information about a file, directory, etc.\\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\\n\\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file.\\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\\n\\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file.\\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\\n\\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\\n    function isDir(string calldata path) external returns (bool result);\\n\\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\\n    function isFile(string calldata path) external returns (bool result);\\n\\n    /// Get the path of the current project root.\\n    function projectRoot() external view returns (string memory path);\\n\\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\\n    /// Follows symbolic links if `followLinks` is true.\\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\\n\\n    /// See `readDir(string)`.\\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\\n\\n    /// See `readDir(string)`.\\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\\n        external\\n        view\\n        returns (DirEntry[] memory entries);\\n\\n    /// Reads the entire content of file to string. `path` is relative to the project root.\\n    function readFile(string calldata path) external view returns (string memory data);\\n\\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\\n\\n    /// Reads next line of file to string.\\n    function readLine(string calldata path) external view returns (string memory line);\\n\\n    /// Reads a symbolic link, returning the path that the link points to.\\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    /// - `path` is not a symbolic link.\\n    /// - `path` does not exist.\\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\\n\\n    /// Removes a directory at the provided path.\\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    /// - `path` doesn't exist.\\n    /// - `path` isn't a directory.\\n    /// - User lacks permissions to modify `path`.\\n    /// - The directory is not empty and `recursive` is false.\\n    /// `path` is relative to the project root.\\n    function removeDir(string calldata path, bool recursive) external;\\n\\n    /// Removes a file from the filesystem.\\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    /// - `path` points to a directory.\\n    /// - The file doesn't exist.\\n    /// - The user lacks permissions to remove the file.\\n    /// `path` is relative to the project root.\\n    function removeFile(string calldata path) external;\\n\\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\\n\\n    /// Returns the time since unix epoch in milliseconds.\\n    function unixTime() external returns (uint256 milliseconds);\\n\\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    /// `path` is relative to the project root.\\n    function writeFile(string calldata path, string calldata data) external;\\n\\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    /// `path` is relative to the project root.\\n    function writeFileBinary(string calldata path, bytes calldata data) external;\\n\\n    /// Writes line to file, creating a file if it does not exist.\\n    /// `path` is relative to the project root.\\n    function writeLine(string calldata path, string calldata data) external;\\n\\n    // ======== JSON ========\\n\\n    /// Checks if `key` exists in a JSON object.\\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\\n    function parseJsonAddressArray(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (address[] memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\\n    function parseJsonBytes32Array(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (bytes32[] memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\\n\\n    /// Returns an array of all the keys in a JSON object.\\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\\n\\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\\n\\n    /// ABI-encodes a JSON object.\\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\\n\\n    /// ABI-encodes a JSON object at `key`.\\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\\n\\n    /// See `serializeJson`.\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\\n    /// Returns the stringified version of the specific JSON file up to that moment.\\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\\n        external\\n        returns (string memory json);\\n\\n    /// See `serializeJson`.\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\\n    function writeJson(string calldata json, string calldata path) external;\\n\\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\\n\\n    // ======== Scripting ========\\n\\n    /// Using the address that calls the test contract, has the next call (at this call depth only)\\n    /// create a transaction that can later be signed and sent onchain.\\n    function broadcast() external;\\n\\n    /// Has the next call (at this call depth only) create a transaction with the address provided\\n    /// as the sender that can later be signed and sent onchain.\\n    function broadcast(address signer) external;\\n\\n    /// Has the next call (at this call depth only) create a transaction with the private key\\n    /// provided as the sender that can later be signed and sent onchain.\\n    function broadcast(uint256 privateKey) external;\\n\\n    /// Using the address that calls the test contract, has all subsequent calls\\n    /// (at this call depth only) create transactions that can later be signed and sent onchain.\\n    function startBroadcast() external;\\n\\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\\n    /// provided that can later be signed and sent onchain.\\n    function startBroadcast(address signer) external;\\n\\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\\n    /// provided that can later be signed and sent onchain.\\n    function startBroadcast(uint256 privateKey) external;\\n\\n    /// Stops collecting onchain transactions.\\n    function stopBroadcast() external;\\n\\n    // ======== String ========\\n\\n    /// Parses the given `string` into an `address`.\\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\\n\\n    /// Parses the given `string` into a `bool`.\\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\\n\\n    /// Parses the given `string` into `bytes`.\\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\\n\\n    /// Parses the given `string` into a `bytes32`.\\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\\n\\n    /// Parses the given `string` into a `int256`.\\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\\n\\n    /// Parses the given `string` into a `uint256`.\\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(address value) external pure returns (string memory stringifiedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(bool value) external pure returns (string memory stringifiedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\\n\\n    /// Converts the given value to a `string`.\\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\\n\\n    // ======== Testing ========\\n\\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\\n    function assume(bool condition) external pure;\\n\\n    /// Writes a breakpoint to jump to in the debugger.\\n    function breakpoint(string calldata char) external;\\n\\n    /// Writes a conditional breakpoint to jump to in the debugger.\\n    function breakpoint(string calldata char, bool value) external;\\n\\n    /// Returns the RPC url for the given alias.\\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\\n\\n    /// Returns all rpc urls and their aliases as structs.\\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\\n\\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\\n    function rpcUrls() external view returns (string[2][] memory urls);\\n\\n    /// Suspends execution of the main thread for `duration` milliseconds.\\n    function sleep(uint256 duration) external;\\n\\n    // ======== Utilities ========\\n\\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\\n        external\\n        pure\\n        returns (address);\\n\\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\\n\\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\\n\\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\\n\\n    /// Generates a wallet from the private key and returns the wallet.\\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\\n\\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\\n\\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\\n\\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\\n    /// at `{derivationPath}{index}`.\\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n\\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n\\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\\n    /// at `{derivationPath}{index}`.\\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n\\n    /// Gets the label for the specified address.\\n    function getLabel(address account) external view returns (string memory currentLabel);\\n\\n    /// Get a `Wallet`'s nonce.\\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\\n\\n    /// Labels an address in call traces.\\n    function label(address account, string calldata newLabel) external;\\n\\n    /// Adds a private key to the local forge wallet and returns the address.\\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\\n\\n    /// Signs data with a `Wallet`.\\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\\n\\n    /// Encodes a `bytes` value to a base64url string.\\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\\n\\n    /// Encodes a `string` value to a base64url string.\\n    function toBase64URL(string calldata data) external pure returns (string memory);\\n\\n    /// Encodes a `bytes` value to a base64 string.\\n    function toBase64(bytes calldata data) external pure returns (string memory);\\n\\n    /// Encodes a `string` value to a base64 string.\\n    function toBase64(string calldata data) external pure returns (string memory);\\n}\\n\\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\\n/// in tests, but it is not recommended to use these cheats in scripts.\\ninterface Vm is VmSafe {\\n    // ======== EVM ========\\n\\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\\n    function activeFork() external view returns (uint256 forkId);\\n\\n    /// In forking mode, explicitly grant the given address cheatcode access.\\n    function allowCheatcodes(address account) external;\\n\\n    /// Sets `block.chainid`.\\n    function chainId(uint256 newChainId) external;\\n\\n    /// Clears all mocked calls.\\n    function clearMockedCalls() external;\\n\\n    /// Sets `block.coinbase`.\\n    function coinbase(address newCoinbase) external;\\n\\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n\\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n\\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n\\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n\\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n\\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n\\n    /// Sets an address' balance.\\n    function deal(address account, uint256 newBalance) external;\\n\\n    /// Removes the snapshot with the given ID created by `snapshot`.\\n    /// Takes the snapshot ID to delete.\\n    /// Returns `true` if the snapshot was successfully deleted.\\n    /// Returns `false` if the snapshot does not exist.\\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\\n\\n    /// Removes _all_ snapshots previously created by `snapshot`.\\n    function deleteSnapshots() external;\\n\\n    /// Sets `block.difficulty`.\\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\\n    /// Reverts if used on unsupported EVM versions.\\n    function difficulty(uint256 newDifficulty) external;\\n\\n    /// Dump a genesis JSON file's `allocs` to disk.\\n    function dumpState(string calldata pathToStateJson) external;\\n\\n    /// Sets an address' code.\\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\\n\\n    /// Sets `block.basefee`.\\n    function fee(uint256 newBasefee) external;\\n\\n    /// Returns true if the account is marked as persistent.\\n    function isPersistent(address account) external view returns (bool persistent);\\n\\n    /// Load a genesis JSON file's `allocs` into the in-memory revm state.\\n    function loadAllocs(string calldata pathToAllocsJson) external;\\n\\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\\n    function makePersistent(address account) external;\\n\\n    /// See `makePersistent(address)`.\\n    function makePersistent(address account0, address account1) external;\\n\\n    /// See `makePersistent(address)`.\\n    function makePersistent(address account0, address account1, address account2) external;\\n\\n    /// See `makePersistent(address)`.\\n    function makePersistent(address[] calldata accounts) external;\\n\\n    /// Reverts a call to an address with specified revert data.\\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\\n\\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\\n        external;\\n\\n    /// Mocks a call to an address, returning specified data.\\n    /// Calldata can either be strict or a partial match, e.g. if you only\\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\\n    /// function will be mocked.\\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\\n\\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\\n\\n    /// Sets the *next* call's `msg.sender` to be the input address.\\n    function prank(address msgSender) external;\\n\\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\\n    function prank(address msgSender, address txOrigin) external;\\n\\n    /// Sets `block.prevrandao`.\\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\\n    /// If used on unsupported EVM versions it will revert.\\n    function prevrandao(bytes32 newPrevrandao) external;\\n\\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\\n\\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\\n    function resetNonce(address account) external;\\n\\n    /// Revert the state of the EVM to a previous snapshot\\n    /// Takes the snapshot ID to revert to.\\n    /// Returns `true` if the snapshot was successfully reverted.\\n    /// Returns `false` if the snapshot does not exist.\\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.\\n    function revertTo(uint256 snapshotId) external returns (bool success);\\n\\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\\n    /// Takes the snapshot ID to revert to.\\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\\n    /// Returns `false` if the snapshot does not exist.\\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\\n\\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\\n    function revokePersistent(address account) external;\\n\\n    /// See `revokePersistent(address)`.\\n    function revokePersistent(address[] calldata accounts) external;\\n\\n    /// Sets `block.height`.\\n    function roll(uint256 newHeight) external;\\n\\n    /// Updates the currently active fork to given block number\\n    /// This is similar to `roll` but for the currently active fork.\\n    function rollFork(uint256 blockNumber) external;\\n\\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\\n    function rollFork(bytes32 txHash) external;\\n\\n    /// Updates the given fork to given block number.\\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\\n\\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\\n    function rollFork(uint256 forkId, bytes32 txHash) external;\\n\\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\\n    function selectFork(uint256 forkId) external;\\n\\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\\n    function setNonce(address account, uint64 newNonce) external;\\n\\n    /// Sets the nonce of an account to an arbitrary value.\\n    function setNonceUnsafe(address account, uint64 newNonce) external;\\n\\n    /// Snapshot the current state of the evm.\\n    /// Returns the ID of the snapshot that was created.\\n    /// To revert a snapshot use `revertTo`.\\n    function snapshot() external returns (uint256 snapshotId);\\n\\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\\n    function startPrank(address msgSender) external;\\n\\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\\n    function startPrank(address msgSender, address txOrigin) external;\\n\\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\\n    function stopPrank() external;\\n\\n    /// Stores a value to an address' storage slot.\\n    function store(address target, bytes32 slot, bytes32 value) external;\\n\\n    /// Fetches the given transaction from the active fork and executes it on the current state.\\n    function transact(bytes32 txHash) external;\\n\\n    /// Fetches the given transaction from the given fork and executes it on the current state.\\n    function transact(uint256 forkId, bytes32 txHash) external;\\n\\n    /// Sets `tx.gasprice`.\\n    function txGasPrice(uint256 newGasPrice) external;\\n\\n    /// Sets `block.timestamp`.\\n    function warp(uint256 newTimestamp) external;\\n\\n    // ======== Testing ========\\n\\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\\n\\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\\n        external;\\n\\n    /// Expects a call to an address with the specified calldata.\\n    /// Calldata can either be a strict or a partial match.\\n    function expectCall(address callee, bytes calldata data) external;\\n\\n    /// Expects given number of calls to an address with the specified calldata.\\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\\n\\n    /// Expects a call to an address with the specified `msg.value` and calldata.\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\\n\\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\\n\\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\\n\\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\\n\\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\\n\\n    /// Same as the previous method, but also checks supplied address against emitting contract.\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\\n        external;\\n\\n    /// Prepare an expected log with all topic and data checks enabled.\\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    /// logs were emitted in the expected order with the expected topics and data.\\n    function expectEmit() external;\\n\\n    /// Same as the previous method, but also checks supplied address against emitting contract.\\n    function expectEmit(address emitter) external;\\n\\n    /// Expects an error on next call with any revert data.\\n    function expectRevert() external;\\n\\n    /// Expects an error on next call that starts with the revert data.\\n    function expectRevert(bytes4 revertData) external;\\n\\n    /// Expects an error on next call that exactly matches the revert data.\\n    function expectRevert(bytes calldata revertData) external;\\n\\n    /// Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the current subcontext. If any other\\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\\n    function expectSafeMemory(uint64 min, uint64 max) external;\\n\\n    /// Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the next created subcontext.\\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\\n    /// to the set.\\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\\n\\n    /// Marks a test as skipped. Must be called at the top of the test.\\n    function skip(bool skipTest) external;\\n\\n    /// Stops all safe memory expectation in the current subcontext.\\n    function stopExpectSafeMemory() external;\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {StdStorage} from \\\"./StdStorage.sol\\\";\\nimport {Vm, VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract CommonBase {\\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\\\"hevm cheat code\\\"))));\\n    // console.sol and console2.sol work by executing a staticcall to this address.\\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\\\"foundry default caller\\\"))));\\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\\n    // Deterministic deployment address of the Multicall3 contract.\\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\\n    // The order of the secp256k1 curve.\\n    uint256 internal constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n\\n    uint256 internal constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    Vm internal constant vm = Vm(VM_ADDRESS);\\n    StdStorage internal stdstore;\\n}\\n\\nabstract contract TestBase is CommonBase {}\\n\\nabstract contract ScriptBase is CommonBase {\\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/lib/ds-test/src/test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.5.0;\\n\\ncontract DSTest {\\n    event log                    (string);\\n    event logs                   (bytes);\\n\\n    event log_address            (address);\\n    event log_bytes32            (bytes32);\\n    event log_int                (int);\\n    event log_uint               (uint);\\n    event log_bytes              (bytes);\\n    event log_string             (string);\\n\\n    event log_named_address      (string key, address val);\\n    event log_named_bytes32      (string key, bytes32 val);\\n    event log_named_decimal_int  (string key, int val, uint decimals);\\n    event log_named_decimal_uint (string key, uint val, uint decimals);\\n    event log_named_int          (string key, int val);\\n    event log_named_uint         (string key, uint val);\\n    event log_named_bytes        (string key, bytes val);\\n    event log_named_string       (string key, string val);\\n\\n    bool public IS_TEST = true;\\n    bool private _failed;\\n\\n    address constant HEVM_ADDRESS =\\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    modifier mayRevert() { _; }\\n    modifier testopts(string memory) { _; }\\n\\n    function failed() public returns (bool) {\\n        if (_failed) {\\n            return _failed;\\n        } else {\\n            bool globalFailed = false;\\n            if (hasHEVMContext()) {\\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\\n                    abi.encodePacked(\\n                        bytes4(keccak256(\\\"load(address,bytes32)\\\")),\\n                        abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"))\\n                    )\\n                );\\n                globalFailed = abi.decode(retdata, (bool));\\n            }\\n            return globalFailed;\\n        }\\n    }\\n\\n    function fail() internal virtual {\\n        if (hasHEVMContext()) {\\n            (bool status, ) = HEVM_ADDRESS.call(\\n                abi.encodePacked(\\n                    bytes4(keccak256(\\\"store(address,bytes32,bytes32)\\\")),\\n                    abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"), bytes32(uint256(0x01)))\\n                )\\n            );\\n            status; // Silence compiler warnings\\n        }\\n        _failed = true;\\n    }\\n\\n    function hasHEVMContext() internal view returns (bool) {\\n        uint256 hevmCodeSize = 0;\\n        assembly {\\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\\n        }\\n        return hevmCodeSize > 0;\\n    }\\n\\n    modifier logs_gas() {\\n        uint startGas = gasleft();\\n        _;\\n        uint endGas = gasleft();\\n        emit log_named_uint(\\\"gas\\\", startGas - endGas);\\n    }\\n\\n    function assertTrue(bool condition) internal {\\n        if (!condition) {\\n            emit log(\\\"Error: Assertion Failed\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertTrue(bool condition, string memory err) internal {\\n        if (!condition) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertTrue(condition);\\n        }\\n    }\\n\\n    function assertEq(address a, address b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(address a, address b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes32 a, bytes32 b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq32(bytes32 a, bytes32 b) internal {\\n        assertEq(a, b);\\n    }\\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertEq(a, b, err);\\n    }\\n\\n    function assertEq(int a, int b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(int a, int b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq(uint a, uint b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(uint a, uint b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertNotEq(address a, address b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(address a, address b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(bytes32 a, bytes32 b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\\n        assertNotEq(a, b);\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertNotEq(a, b, err);\\n    }\\n\\n    function assertNotEq(int a, int b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(int a, int b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq(uint a, uint b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(uint a, uint b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGt(uint a, uint b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(uint a, uint b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGt(int a, int b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(int a, int b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGe(uint a, uint b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(uint a, uint b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGe(int a, int b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(int a, int b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLt(uint a, uint b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(uint a, uint b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLt(int a, int b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(int a, int b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLe(uint a, uint b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(uint a, uint b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLe(int a, int b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(int a, int b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a == b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a != b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\\n        ok = true;\\n        if (a.length == b.length) {\\n            for (uint i = 0; i < a.length; i++) {\\n                if (a[i] != b[i]) {\\n                    ok = false;\\n                }\\n            }\\n        } else {\\n            ok = false;\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log(\\\"Error: a == b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq0(a, b);\\n        }\\n    }\\n\\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\\n        if (checkEq0(a, b)) {\\n            emit log(\\\"Error: a != b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq0(a, b);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/access/OwnablePermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nabstract contract OwnablePermissions is Context {\\n    function _requireCallerIsContractOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/utils/CreatorTokenBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../access/OwnablePermissions.sol\\\";\\nimport \\\"../interfaces/ICreatorToken.sol\\\";\\nimport \\\"../interfaces/ICreatorTokenTransferValidator.sol\\\";\\nimport \\\"../utils/TransferValidation.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\n/**\\n * @title CreatorTokenBase\\n * @author Limit Break, Inc.\\n * @notice CreatorTokenBase is an abstract contract that provides basic functionality for managing token \\n * transfer policies through an implementation of ICreatorTokenTransferValidator. This contract is intended to be used\\n * as a base for creator-specific token contracts, enabling customizable transfer restrictions and security policies.\\n *\\n * <h4>Features:</h4>\\n * <ul>Ownable: This contract can have an owner who can set and update the transfer validator.</ul>\\n * <ul>TransferValidation: Implements the basic token transfer validation interface.</ul>\\n * <ul>ICreatorToken: Implements the interface for creator tokens, providing view functions for token security policies.</ul>\\n *\\n * <h4>Benefits:</h4>\\n * <ul>Provides a flexible and modular way to implement custom token transfer restrictions and security policies.</ul>\\n * <ul>Allows creators to enforce policies such as whitelisted operators and permitted contract receivers.</ul>\\n * <ul>Can be easily integrated into other token contracts as a base contract.</ul>\\n *\\n * <h4>Intended Usage:</h4>\\n * <ul>Use as a base contract for creator token implementations that require advanced transfer restrictions and \\n *   security policies.</ul>\\n * <ul>Set and update the ICreatorTokenTransferValidator implementation contract to enforce desired policies for the \\n *   creator token.</ul>\\n */\\nabstract contract CreatorTokenBase is OwnablePermissions, TransferValidation, ICreatorToken {\\n    \\n    error CreatorTokenBase__InvalidTransferValidatorContract();\\n    error CreatorTokenBase__SetTransferValidatorFirst();\\n\\n    address public constant DEFAULT_TRANSFER_VALIDATOR = address(0x0000721C310194CcfC01E523fc93C9cCcFa2A0Ac);\\n    TransferSecurityLevels public constant DEFAULT_TRANSFER_SECURITY_LEVEL = TransferSecurityLevels.One;\\n    uint120 public constant DEFAULT_OPERATOR_WHITELIST_ID = uint120(1);\\n\\n    ICreatorTokenTransferValidator private transferValidator;\\n\\n    /**\\n     * @notice Allows the contract owner to set the transfer validator to the official validator contract\\n     *         and set the security policy to the recommended default settings.\\n     * @dev    May be overridden to change the default behavior of an individual collection.\\n     */\\n    function setToDefaultSecurityPolicy() public virtual {\\n        _requireCallerIsContractOwner();\\n        setTransferValidator(DEFAULT_TRANSFER_VALIDATOR);\\n        ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setTransferSecurityLevelOfCollection(address(this), DEFAULT_TRANSFER_SECURITY_LEVEL);\\n        ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setOperatorWhitelistOfCollection(address(this), DEFAULT_OPERATOR_WHITELIST_ID);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the transfer validator to a custom validator contract\\n     *         and set the security policy to their own custom settings.\\n     */\\n    function setToCustomValidatorAndSecurityPolicy(\\n        address validator, \\n        TransferSecurityLevels level, \\n        uint120 operatorWhitelistId, \\n        uint120 permittedContractReceiversAllowlistId) public {\\n        _requireCallerIsContractOwner();\\n\\n        setTransferValidator(validator);\\n\\n        ICreatorTokenTransferValidator(validator).\\n            setTransferSecurityLevelOfCollection(address(this), level);\\n\\n        ICreatorTokenTransferValidator(validator).\\n            setOperatorWhitelistOfCollection(address(this), operatorWhitelistId);\\n\\n        ICreatorTokenTransferValidator(validator).\\n            setPermittedContractReceiverAllowlistOfCollection(address(this), permittedContractReceiversAllowlistId);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set the security policy to their own custom settings.\\n     * @dev    Reverts if the transfer validator has not been set.\\n     */\\n    function setToCustomSecurityPolicy(\\n        TransferSecurityLevels level, \\n        uint120 operatorWhitelistId, \\n        uint120 permittedContractReceiversAllowlistId) public {\\n        _requireCallerIsContractOwner();\\n\\n        ICreatorTokenTransferValidator validator = getTransferValidator();\\n        if (address(validator) == address(0)) {\\n            revert CreatorTokenBase__SetTransferValidatorFirst();\\n        }\\n\\n        validator.setTransferSecurityLevelOfCollection(address(this), level);\\n        validator.setOperatorWhitelistOfCollection(address(this), operatorWhitelistId);\\n        validator.setPermittedContractReceiverAllowlistOfCollection(address(this), permittedContractReceiversAllowlistId);\\n    }\\n\\n    /**\\n     * @notice Sets the transfer validator for the token contract.\\n     *\\n     * @dev    Throws when provided validator contract is not the zero address and doesn't support \\n     *         the ICreatorTokenTransferValidator interface. \\n     * @dev    Throws when the caller is not the contract owner.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     *         1. The transferValidator address is updated.\\n     *         2. The `TransferValidatorUpdated` event is emitted.\\n     *\\n     * @param transferValidator_ The address of the transfer validator contract.\\n     */\\n    function setTransferValidator(address transferValidator_) public {\\n        _requireCallerIsContractOwner();\\n\\n        bool isValidTransferValidator = false;\\n\\n        if(transferValidator_.code.length > 0) {\\n            try IERC165(transferValidator_).supportsInterface(type(ICreatorTokenTransferValidator).interfaceId) \\n                returns (bool supportsInterface) {\\n                isValidTransferValidator = supportsInterface;\\n            } catch {}\\n        }\\n\\n        if(transferValidator_ != address(0) && !isValidTransferValidator) {\\n            revert CreatorTokenBase__InvalidTransferValidatorContract();\\n        }\\n\\n        emit TransferValidatorUpdated(address(transferValidator), transferValidator_);\\n\\n        transferValidator = ICreatorTokenTransferValidator(transferValidator_);\\n    }\\n\\n    /**\\n     * @notice Returns the transfer validator contract address for this token contract.\\n     */\\n    function getTransferValidator() public view override returns (ICreatorTokenTransferValidator) {\\n        return transferValidator;\\n    }\\n\\n    /**\\n     * @notice Returns the security policy for this token contract, which includes:\\n     *         Transfer security level, operator whitelist id, permitted contract receiver allowlist id.\\n     */\\n    function getSecurityPolicy() public view override returns (CollectionSecurityPolicy memory) {\\n        if (address(transferValidator) != address(0)) {\\n            return transferValidator.getCollectionSecurityPolicy(address(this));\\n        }\\n\\n        return CollectionSecurityPolicy({\\n            transferSecurityLevel: TransferSecurityLevels.Zero,\\n            operatorWhitelistId: 0,\\n            permittedContractReceiversId: 0\\n        });\\n    }\\n\\n    /**\\n     * @notice Returns the list of all whitelisted operators for this token contract.\\n     * @dev    This can be an expensive call and should only be used in view-only functions.\\n     */\\n    function getWhitelistedOperators() public view override returns (address[] memory) {\\n        if (address(transferValidator) != address(0)) {\\n            return transferValidator.getWhitelistedOperators(\\n                transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId);\\n        }\\n\\n        return new address[](0);\\n    }\\n\\n    /**\\n     * @notice Returns the list of permitted contract receivers for this token contract.\\n     * @dev    This can be an expensive call and should only be used in view-only functions.\\n     */\\n    function getPermittedContractReceivers() public view override returns (address[] memory) {\\n        if (address(transferValidator) != address(0)) {\\n            return transferValidator.getPermittedContractReceivers(\\n                transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId);\\n        }\\n\\n        return new address[](0);\\n    }\\n\\n    /**\\n     * @notice Checks if an operator is whitelisted for this token contract.\\n     * @param operator The address of the operator to check.\\n     */\\n    function isOperatorWhitelisted(address operator) public view override returns (bool) {\\n        if (address(transferValidator) != address(0)) {\\n            return transferValidator.isOperatorWhitelisted(\\n                transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId, operator);\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Checks if a contract receiver is permitted for this token contract.\\n     * @param receiver The address of the receiver to check.\\n     */\\n    function isContractReceiverPermitted(address receiver) public view override returns (bool) {\\n        if (address(transferValidator) != address(0)) {\\n            return transferValidator.isContractReceiverPermitted(\\n                transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId, receiver);\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Determines if a transfer is allowed based on the token contract's security policy.  Use this function\\n     *         to simulate whether or not a transfer made by the specified `caller` from the `from` address to the `to`\\n     *         address would be allowed by this token's security policy.\\n     *\\n     * @notice This function only checks the security policy restrictions and does not check whether token ownership\\n     *         or approvals are in place. \\n     *\\n     * @param caller The address of the simulated caller.\\n     * @param from   The address of the sender.\\n     * @param to     The address of the receiver.\\n     * @return       True if the transfer is allowed, false otherwise.\\n     */\\n    function isTransferAllowed(address caller, address from, address to) public view override returns (bool) {\\n        if (address(transferValidator) != address(0)) {\\n            try transferValidator.applyCollectionTransferPolicy(caller, from, to) {\\n                return true;\\n            } catch {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Pre-validates a token transfer, reverting if the transfer is not allowed by this token's security policy.\\n     *      Inheriting contracts are responsible for overriding the _beforeTokenTransfer function, or its equivalent\\n     *      and calling _validateBeforeTransfer so that checks can be properly applied during token transfers.\\n     *\\n     * @dev Throws when the transfer doesn't comply with the collection's transfer policy, if the transferValidator is\\n     *      set to a non-zero address.\\n     *\\n     * @param caller  The address of the caller.\\n     * @param from    The address of the sender.\\n     * @param to      The address of the receiver.\\n     */\\n    function _preValidateTransfer(\\n        address caller, \\n        address from, \\n        address to, \\n        uint256 /*tokenId*/, \\n        uint256 /*value*/) internal virtual override {\\n        if (address(transferValidator) != address(0)) {\\n            transferValidator.applyCollectionTransferPolicy(caller, from, to);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/token/erc721/ERC721OpenZeppelin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../access/OwnablePermissions.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\nabstract contract ERC721OpenZeppelinBase is ERC721 {\\n\\n    // Token name\\n    string internal _contractName;\\n\\n    // Token symbol\\n    string internal _contractSymbol;\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _contractName;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _contractSymbol;\\n    }\\n\\n    function _setNameAndSymbol(string memory name_, string memory symbol_) internal {\\n        _contractName = name_;\\n        _contractSymbol = symbol_;\\n    }\\n}\\n\\nabstract contract ERC721OpenZeppelin is ERC721OpenZeppelinBase {\\n    constructor(string memory name_, string memory symbol_) ERC721(\\\"\\\", \\\"\\\") {\\n        _setNameAndSymbol(name_, symbol_);\\n    }\\n}\\n\\nabstract contract ERC721OpenZeppelinInitializable is OwnablePermissions, ERC721OpenZeppelinBase {\\n\\n    error ERC721OpenZeppelinInitializable__AlreadyInitializedERC721();\\n\\n    /// @notice Specifies whether or not the contract is initialized\\n    bool private _erc721Initialized;\\n\\n    /// @dev Initializes parameters of ERC721 tokens.\\n    /// These cannot be set in the constructor because this contract is optionally compatible with EIP-1167.\\n    function initializeERC721(string memory name_, string memory symbol_) public {\\n        _requireCallerIsContractOwner();\\n\\n        if(_erc721Initialized) {\\n            revert ERC721OpenZeppelinInitializable__AlreadyInitializedERC721();\\n        }\\n\\n        _erc721Initialized = true;\\n\\n        _setNameAndSymbol(name_, symbol_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/interfaces/IMulticall3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IMulticall3 {\\n    struct Call {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    struct Call3 {\\n        address target;\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Call3Value {\\n        address target;\\n        bool allowFailure;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function aggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes[] memory returnData);\\n\\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function blockAndAggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n\\n    function getBasefee() external view returns (uint256 basefee);\\n\\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\\n\\n    function getBlockNumber() external view returns (uint256 blockNumber);\\n\\n    function getChainId() external view returns (uint256 chainid);\\n\\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\\n\\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\\n\\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\\n\\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\\n\\n    function getEthBalance(address addr) external view returns (uint256 balance);\\n\\n    function getLastBlockHash() external view returns (bytes32 blockHash);\\n\\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (Result[] memory returnData);\\n\\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/mocks/MockERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.\\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol\\ncontract MockERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal INITIAL_CHAIN_ID;\\n\\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               INITIALIZE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev A bool to track whether the contract has been initialized.\\n    bool private initialized;\\n\\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\\n    /// syntaxes, we add an initialization function that can be called only once.\\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals) public {\\n        require(!initialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = _pureChainId();\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n\\n        initialized = true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] = _sub(balanceOf[msg.sender], amount);\\n        balanceOf[to] = _add(balanceOf[to], amount);\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != ~uint256(0)) allowance[from][msg.sender] = _sub(allowed, amount);\\n\\n        balanceOf[from] = _sub(balanceOf[from], amount);\\n        balanceOf[to] = _add(balanceOf[to], amount);\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        public\\n        virtual\\n    {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        address recoveredAddress = ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(\\n                        abi.encode(\\n                            keccak256(\\n                                \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                            ),\\n                            owner,\\n                            spender,\\n                            value,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            ),\\n            v,\\n            r,\\n            s\\n        );\\n\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n        allowance[recoveredAddress][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"1\\\"),\\n                _pureChainId(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply = _add(totalSupply, amount);\\n        balanceOf[to] = _add(balanceOf[to], amount);\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] = _sub(balanceOf[from], amount);\\n        totalSupply = _sub(totalSupply, amount);\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MATH LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ERC20: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(a >= b, \\\"ERC20: subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                HELPERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\\n    // Checker changed `chainid` from pure to view in 0.8.0.\\n    function _viewChainId() private view returns (uint256 chainId) {\\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        address(this); // Silence warnings in older Solc versions.\\n    }\\n\\n    function _pureChainId() private pure returns (uint256 chainId) {\\n        function() internal view returns (uint256) fnIn = _viewChainId;\\n        function() internal pure returns (uint256) pureChainId;\\n        assembly {\\n            pureChainId := fnIn\\n        }\\n        chainId = pureChainId();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/mocks/MockERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.\\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol\\ncontract MockERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory) {}\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               INITIALIZE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev A bool to track whether the contract has been initialized.\\n    bool private initialized;\\n\\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\\n    /// syntaxes, we add an initialization function that can be called only once.\\n    function initialize(string memory _name, string memory _symbol) public {\\n        require(!initialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        name = _name;\\n        symbol = _symbol;\\n\\n        initialized = true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id], \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        _balanceOf[from]--;\\n\\n        _balanceOf[to]++;\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            !_isContract(to)\\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\")\\n                    == IERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            !_isContract(to)\\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\\n                    == IERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n\\n        _balanceOf[to]++;\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        _balanceOf[owner]--;\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            !_isContract(to)\\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\")\\n                    == IERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            !_isContract(to)\\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)\\n                    == IERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                HELPERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _isContract(address _addr) private view returns (bool) {\\n        uint256 codeLength;\\n\\n        // Assembly required for versions < 0.8.0 to check extcodesize.\\n        assembly {\\n            codeLength := extcodesize(_addr)\\n        }\\n\\n        return codeLength > 0;\\n    }\\n}\\n\\ninterface IERC721TokenReceiver {\\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/interfaces/ICreatorToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ICreatorTokenTransferValidator.sol\\\";\\n\\ninterface ICreatorToken {\\n    event TransferValidatorUpdated(address oldValidator, address newValidator);\\n\\n    function getTransferValidator() external view returns (ICreatorTokenTransferValidator);\\n    function getSecurityPolicy() external view returns (CollectionSecurityPolicy memory);\\n    function getWhitelistedOperators() external view returns (address[] memory);\\n    function getPermittedContractReceivers() external view returns (address[] memory);\\n    function isOperatorWhitelisted(address operator) external view returns (bool);\\n    function isContractReceiverPermitted(address receiver) external view returns (bool);\\n    function isTransferAllowed(address caller, address from, address to) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/interfaces/ICreatorTokenTransferValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IEOARegistry.sol\\\";\\nimport \\\"./ITransferSecurityRegistry.sol\\\";\\nimport \\\"./ITransferValidator.sol\\\";\\n\\ninterface ICreatorTokenTransferValidator is ITransferSecurityRegistry, ITransferValidator, IEOARegistry {}\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/utils/TransferValidation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @title TransferValidation\\n * @author Limit Break, Inc.\\n * @notice A mix-in that can be combined with ERC-721 contracts to provide more granular hooks.\\n * Openzeppelin's ERC721 contract only provides hooks for before and after transfer.  This allows\\n * developers to validate or customize transfers within the context of a mint, a burn, or a transfer.\\n */\\nabstract contract TransferValidation is Context {\\n    \\n    error ShouldNotMintToBurnAddress();\\n\\n    /// @dev Inheriting contracts should call this function in the _beforeTokenTransfer function to get more granular hooks.\\n    function _validateBeforeTransfer(address from, address to, uint256 tokenId) internal virtual {\\n        bool fromZeroAddress = from == address(0);\\n        bool toZeroAddress = to == address(0);\\n\\n        if(fromZeroAddress && toZeroAddress) {\\n            revert ShouldNotMintToBurnAddress();\\n        } else if(fromZeroAddress) {\\n            _preValidateMint(_msgSender(), to, tokenId, msg.value);\\n        } else if(toZeroAddress) {\\n            _preValidateBurn(_msgSender(), from, tokenId, msg.value);\\n        } else {\\n            _preValidateTransfer(_msgSender(), from, to, tokenId, msg.value);\\n        }\\n    }\\n\\n    /// @dev Inheriting contracts should call this function in the _afterTokenTransfer function to get more granular hooks.\\n    function _validateAfterTransfer(address from, address to, uint256 tokenId) internal virtual {\\n        bool fromZeroAddress = from == address(0);\\n        bool toZeroAddress = to == address(0);\\n\\n        if(fromZeroAddress && toZeroAddress) {\\n            revert ShouldNotMintToBurnAddress();\\n        } else if(fromZeroAddress) {\\n            _postValidateMint(_msgSender(), to, tokenId, msg.value);\\n        } else if(toZeroAddress) {\\n            _postValidateBurn(_msgSender(), from, tokenId, msg.value);\\n        } else {\\n            _postValidateTransfer(_msgSender(), from, to, tokenId, msg.value);\\n        }\\n    }\\n\\n    /// @dev Optional validation hook that fires before a mint\\n    function _preValidateMint(address caller, address to, uint256 tokenId, uint256 value) internal virtual {}\\n\\n    /// @dev Optional validation hook that fires after a mint\\n    function _postValidateMint(address caller, address to, uint256 tokenId, uint256 value) internal virtual {}\\n\\n    /// @dev Optional validation hook that fires before a burn\\n    function _preValidateBurn(address caller, address from, uint256 tokenId, uint256 value) internal virtual {}\\n\\n    /// @dev Optional validation hook that fires after a burn\\n    function _postValidateBurn(address caller, address from, uint256 tokenId, uint256 value) internal virtual {}\\n\\n    /// @dev Optional validation hook that fires before a transfer\\n    function _preValidateTransfer(address caller, address from, address to, uint256 tokenId, uint256 value) internal virtual {}\\n\\n    /// @dev Optional validation hook that fires after a transfer\\n    function _postValidateTransfer(address caller, address from, address to, uint256 tokenId, uint256 value) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/interfaces/IEOARegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IEOARegistry is IERC165 {\\n    function isVerifiedEOA(address account) external view returns (bool);\\n}\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/interfaces/ITransferSecurityRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/TransferPolicy.sol\\\";\\n\\ninterface ITransferSecurityRegistry {\\n    event AddedToAllowlist(AllowlistTypes indexed kind, uint256 indexed id, address indexed account);\\n    event CreatedAllowlist(AllowlistTypes indexed kind, uint256 indexed id, string indexed name);\\n    event ReassignedAllowlistOwnership(AllowlistTypes indexed kind, uint256 indexed id, address indexed newOwner);\\n    event RemovedFromAllowlist(AllowlistTypes indexed kind, uint256 indexed id, address indexed account);\\n    event SetAllowlist(AllowlistTypes indexed kind, address indexed collection, uint120 indexed id);\\n    event SetTransferSecurityLevel(address indexed collection, TransferSecurityLevels level);\\n\\n    function createOperatorWhitelist(string calldata name) external returns (uint120);\\n    function createPermittedContractReceiverAllowlist(string calldata name) external returns (uint120);\\n    function reassignOwnershipOfOperatorWhitelist(uint120 id, address newOwner) external;\\n    function reassignOwnershipOfPermittedContractReceiverAllowlist(uint120 id, address newOwner) external;\\n    function renounceOwnershipOfOperatorWhitelist(uint120 id) external;\\n    function renounceOwnershipOfPermittedContractReceiverAllowlist(uint120 id) external;\\n    function setTransferSecurityLevelOfCollection(address collection, TransferSecurityLevels level) external;\\n    function setOperatorWhitelistOfCollection(address collection, uint120 id) external;\\n    function setPermittedContractReceiverAllowlistOfCollection(address collection, uint120 id) external;\\n    function addOperatorToWhitelist(uint120 id, address operator) external;\\n    function addPermittedContractReceiverToAllowlist(uint120 id, address receiver) external;\\n    function removeOperatorFromWhitelist(uint120 id, address operator) external;\\n    function removePermittedContractReceiverFromAllowlist(uint120 id, address receiver) external;\\n    function getCollectionSecurityPolicy(address collection) external view returns (CollectionSecurityPolicy memory);\\n    function getWhitelistedOperators(uint120 id) external view returns (address[] memory);\\n    function getPermittedContractReceivers(uint120 id) external view returns (address[] memory);\\n    function isOperatorWhitelisted(uint120 id, address operator) external view returns (bool);\\n    function isContractReceiverPermitted(uint120 id, address receiver) external view returns (bool);\\n}\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/interfaces/ITransferValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/TransferPolicy.sol\\\";\\n\\ninterface ITransferValidator {\\n    function applyCollectionTransferPolicy(address caller, address from, address to) external view;\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/creator-token-contracts/contracts/utils/TransferPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nenum AllowlistTypes {\\n    Operators,\\n    PermittedContractReceivers\\n}\\n\\nenum ReceiverConstraints {\\n    None,\\n    NoCode,\\n    EOA\\n}\\n\\nenum CallerConstraints {\\n    None,\\n    OperatorWhitelistEnableOTC,\\n    OperatorWhitelistDisableOTC\\n}\\n\\nenum StakerConstraints {\\n    None,\\n    CallerIsTxOrigin,\\n    EOA\\n}\\n\\nenum TransferSecurityLevels {\\n    Zero,\\n    One,\\n    Two,\\n    Three,\\n    Four,\\n    Five,\\n    Six\\n}\\n\\nstruct TransferSecurityPolicy {\\n    CallerConstraints callerConstraints;\\n    ReceiverConstraints receiverConstraints;\\n}\\n\\nstruct CollectionSecurityPolicy {\\n    TransferSecurityLevels transferSecurityLevel;\\n    uint120 operatorWhitelistId;\\n    uint120 permittedContractReceiversId;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@limitbreak/creator-token-contracts/=lib/creator-token-contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@ensdomains/=lib/creator-token-contracts/node_modules/@ensdomains/\",\r\n      \"creator-token-contracts/=lib/creator-token-contracts/contracts/\",\r\n      \"erc721a/=lib/creator-token-contracts/node_modules/erc721a/\",\r\n      \"eth-gas-reporter/=lib/creator-token-contracts/node_modules/eth-gas-reporter/\",\r\n      \"hardhat/=lib/creator-token-contracts/node_modules/hardhat/\",\r\n      \"murky/=lib/creator-token-contracts/lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_royaltyFeeNumerator\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantMintThatMany\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreatorTokenBase__InvalidTransferValidatorContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreatorTokenBase__SetTransferValidatorFirst\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthsDontMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyMinter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShouldNotMintToBurnAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"DefaultRoyaltySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"TokenRoyaltySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"TransferValidatorUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_OPERATOR_WHITELIST_ID\",\"outputs\":[{\"internalType\":\"uint120\",\"name\":\"\",\"type\":\"uint120\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_TRANSFER_SECURITY_LEVEL\",\"outputs\":[{\"internalType\":\"enum TransferSecurityLevels\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_TRANSFER_VALIDATOR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"changeMinterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPermittedContractReceivers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecurityPolicy\",\"outputs\":[{\"components\":[{\"internalType\":\"enum TransferSecurityLevels\",\"name\":\"transferSecurityLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint120\",\"name\":\"operatorWhitelistId\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"permittedContractReceiversId\",\"type\":\"uint120\"}],\"internalType\":\"struct CollectionSecurityPolicy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferValidator\",\"outputs\":[{\"internalType\":\"contract ICreatorTokenTransferValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistedOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"isContractReceiverPermitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isOperatorWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"paidMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"setMinterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum TransferSecurityLevels\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint120\",\"name\":\"operatorWhitelistId\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"permittedContractReceiversAllowlistId\",\"type\":\"uint120\"}],\"name\":\"setToCustomSecurityPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"enum TransferSecurityLevels\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint120\",\"name\":\"operatorWhitelistId\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"permittedContractReceiversAllowlistId\",\"type\":\"uint120\"}],\"name\":\"setToCustomValidatorAndSecurityPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setToDefaultSecurityPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setTokenRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferValidator_\",\"type\":\"address\"}],\"name\":\"setTransferValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uncannyMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UncannyV2", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007aa0f5c54c1c52745e1ddc34db82ee7fa816b6c300000000000000000000000000000000000000000000000000000000000002bc", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d1f89577df81193b53973f58db2b6efab69c9c8b2ec5f7417e875705c0b9c22e"}