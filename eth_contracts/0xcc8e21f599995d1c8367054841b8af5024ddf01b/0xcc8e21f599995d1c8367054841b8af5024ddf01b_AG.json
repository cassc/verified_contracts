{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AlphaGardeners.sol\": {\r\n      \"content\": \"/**\\r\\n * @title Alpha Gardeners - The Ultimate Degen Trading Toolkit\\r\\n *\\r\\n *      Join us on Telegram: https://t.me/alphagardeners_lounge\\r\\n *      Follow us on Twitter: https://twitter.com/alpha_gardeners\\r\\n *\\r\\n */\\r\\n// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./Pausable.sol\\\";\\r\\nimport \\\"./IUniswap.sol\\\";\\r\\n\\r\\ncontract AG is Ownable, Pausable {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    // ERC20 events.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    // This token specific events.\\r\\n    event BlacklistStatusUpdated(address wallet, bool isBlacklisted);\\r\\n    event MarketPairUpdated(address pair, bool isMarketPair);\\r\\n    event ExcludedFromFeesUpdated(address wallet, bool isExcluded);\\r\\n    event TaxRecipientUpdated(address recipient);\\r\\n    event TaxesUpdated(uint256 buyTax, uint256 sellTax, uint256 transferTax);\\r\\n    event LimitsUpdated(uint256 maxBuy, uint256 maxSell, uint256 maxWallet);\\r\\n    event NumTokensToSwapUpdated(uint256 amount);\\r\\n    event ContractSwapEnabledUpdated(bool autoEnabled, bool manualEnabled);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public constant decimals = 18;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    // No mint or burn means we can just use a constant.\\r\\n    // Total supply must fit in uint128.\\r\\n    uint256 public constant totalSupply = 8_000_000_000 * 10**decimals;\\r\\n\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              TOKEN-SPECIFIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    address public taxRecipient;\\r\\n\\r\\n    uint256 public numTokensToSwap = 2_500_000 * 10**decimals;\\r\\n    bool public contractSwapEnabled = false;\\r\\n    bool public manualSwapEnabled = false;\\r\\n    bool private inSwap;\\r\\n\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    // IUniswapV2Pair public uniswapV2Pair;\\r\\n    address private WETH;\\r\\n    event UniswapRouterUpdated(address newRouter);\\r\\n\\r\\n    // When accessing the buy tax, we also access buy limit, and the same applies for\\r\\n    // sell tax and limit. We pack them into a struct to save on gas.\\r\\n    struct taxAndLimit {\\r\\n        uint128 tax;\\r\\n        uint128 limit;\\r\\n    }\\r\\n\\r\\n    taxAndLimit public buyTaxAndLimit = taxAndLimit({\\r\\n        tax: 0,\\r\\n        limit: uint128(totalSupply)\\r\\n    });\\r\\n    taxAndLimit public sellTaxAndLimit = taxAndLimit({\\r\\n        tax: 0,\\r\\n        limit: uint128(totalSupply)\\r\\n    });\\r\\n\\r\\n    uint256 public transferTax = 0;\\r\\n    uint256 public maxWallet = totalSupply;\\r\\n\\r\\n    /// @dev totalSupply * maxTax cannot exceed uint256.\\r\\n    /// @dev maxTax cannot exceed taxDenominator.\\r\\n    uint256 private constant maxTax = 1_000; // 10%, same limit applies to all taxes.\\r\\n    uint256 private constant taxDenominator = 10_000; // 500/10000 = 5%\\r\\n\\r\\n    // Pack it into a struct instead of individual mappings to save on gas.\\r\\n    struct walletState {\\r\\n        bool isBlacklisted;\\r\\n        bool isMarketPair;\\r\\n        bool isExcludedFromFees;\\r\\n    }\\r\\n    mapping (address => walletState) public _walletState;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\r\\n\\r\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\r\\n\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    // Start paused.\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        address _taxRecipient,\\r\\n        address routerAddress\\r\\n    ) Ownable(msg.sender) Pausable(true) {\\r\\n        // Require supply to be less than the max uint128 value.\\r\\n        require(totalSupply < type(uint128).max, \\\"TOTAL_SUPPLY_EXCEEDS_MAX\\\");\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        taxRecipient = _taxRecipient;\\r\\n\\r\\n        // Setup the Uniswap router used for swapping fees.\\r\\n        uniswapV2Router = IUniswapV2Router02(routerAddress);\\r\\n        _approve(address(this), routerAddress, type(uint256).max);\\r\\n        WETH = uniswapV2Router.WETH();\\r\\n\\r\\n        // Setup for EIP-2612.\\r\\n        INITIAL_CHAIN_ID = block.chainid;\\r\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\r\\n\\r\\n        // Exclude owner and the contract from fees.\\r\\n        _walletState[msg.sender] = walletState({\\r\\n            isBlacklisted: false,\\r\\n            isMarketPair: false,\\r\\n            isExcludedFromFees: true\\r\\n        });\\r\\n        emit ExcludedFromFeesUpdated(msg.sender, true);\\r\\n        _walletState[address(this)] = walletState({\\r\\n            isBlacklisted: false,\\r\\n            isMarketPair: false,\\r\\n            isExcludedFromFees: true\\r\\n        });\\r\\n        emit ExcludedFromFeesUpdated(address(this), true);\\r\\n\\r\\n        // Mint the initial supply.\\r\\n        unchecked {\\r\\n            balanceOf[msg.sender] += totalSupply;\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), msg.sender, totalSupply);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = msg.sender;\\r\\n        _approve(owner, spender, allowance[owner][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = msg.sender;\\r\\n        uint256 currentAllowance = allowance[owner][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        allowance[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function transfer(address to, uint256 amount) public whenNotPaused returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public whenNotPaused returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender];\\r\\n        if (allowed != type(uint256).max) {\\r\\n            require(allowed >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            // Won't overflow since allowed >= amount.\\r\\n            unchecked {\\r\\n                allowance[from][msg.sender] = allowed - amount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _buyTransfer(address to, uint256 amount) internal view returns (uint256) {\\r\\n        // balanceOf[to]+amount can't exceed uint256 as it can't exceed totalSupply.\\r\\n        // Taxes are capped at 10k and totalSupply is <= uint(128).max, overflow is impossible.\\r\\n        unchecked {\\r\\n            taxAndLimit memory buyConfig = buyTaxAndLimit;\\r\\n            uint256 fees = (amount * buyConfig.tax) / taxDenominator;\\r\\n\\r\\n            require(amount <= buyConfig.limit, \\\"transfer exceeds max buy\\\");\\r\\n            require(balanceOf[to] + amount <= maxWallet, \\\"balance exceeds max wallet\\\");\\r\\n\\r\\n            return fees;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sellTransfer(uint256 amount) internal view returns (uint256) {\\r\\n        unchecked {\\r\\n            taxAndLimit memory sellConfig = sellTaxAndLimit;\\r\\n            uint256 fees = (amount * sellConfig.tax) / taxDenominator;\\r\\n\\r\\n            require(amount <= sellConfig.limit, \\\"transfer exceeds max sell\\\");\\r\\n            // Do not check max wallet as market pairs are allowed to exceed it.\\r\\n\\r\\n            return fees;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _baseTransfer(address to, uint256 amount) internal view returns (uint256) {\\r\\n        unchecked {\\r\\n            require(balanceOf[to] + amount <= maxWallet, \\\"balance exceeds max wallet\\\");\\r\\n\\r\\n            return (amount * transferTax) / taxDenominator;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swapTokens() internal {\\r\\n        // Only try to swap fees during a sell transaction.\\r\\n        uint256 numTokens = numTokensToSwap;\\r\\n        bool overMinTokenBalance = balanceOf[address(this)] >= numTokens;\\r\\n        if (\\r\\n            overMinTokenBalance &&\\r\\n            !inSwap &&\\r\\n            contractSwapEnabled\\r\\n        ) {\\r\\n            // Try to swap the fees and send them to the tax recipient.\\r\\n            // If this fails, still allow the transfer to go through.\\r\\n            try this.swapFeesAndSend(numTokens, 0) {} catch {}\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calcFees(address to, uint256 amount, bool isBuy, bool isSell) internal view returns (uint256) {\\r\\n        if(isBuy) {\\r\\n            return _buyTransfer(to, amount);\\r\\n        }\\r\\n        if(isSell) {\\r\\n            return _sellTransfer(amount);\\r\\n        }\\r\\n        return _baseTransfer(to, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 balance = balanceOf[from];\\r\\n        require(balance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            balanceOf[from] = balance - amount;\\r\\n        }\\r\\n\\r\\n        walletState memory fromWalletState = _walletState[from];\\r\\n        walletState memory toWalletState = _walletState[to];\\r\\n\\r\\n        // Don't allow blacklisted wallets to receive or send tokens.\\r\\n        require(!fromWalletState.isBlacklisted && !toWalletState.isBlacklisted, \\\"blacklisted\\\");\\r\\n\\r\\n        uint256 fees = 0;\\r\\n        bool takeFee = !fromWalletState.isExcludedFromFees && !toWalletState.isExcludedFromFees;\\r\\n\\r\\n        // Tax and enforce limits appriopriately.\\r\\n        if(takeFee) {\\r\\n            bool isBuy = fromWalletState.isMarketPair;\\r\\n            bool isSell = toWalletState.isMarketPair;\\r\\n\\r\\n            fees = _calcFees(to, amount, isBuy, isSell);\\r\\n\\r\\n            if(isSell && !isBuy) {\\r\\n                _swapTokens();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Add the amount minus fees to the receiver.\\r\\n        uint256 amountMinusFees;\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        // fees is less than amount, so it can't overflow.\\r\\n        unchecked {\\r\\n            amountMinusFees = amount - fees;\\r\\n            balanceOf[to] += amountMinusFees;\\r\\n        }\\r\\n        emit Transfer(from, to, amountMinusFees);\\r\\n\\r\\n        // Add any fees collected to the contract.\\r\\n        if(fees > 0) {\\r\\n            emit Transfer(from, address(this), fees);\\r\\n            unchecked {\\r\\n                balanceOf[address(this)] += fees;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               SWAP LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    modifier lockTheSwap {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    function swapFeesAndSend(uint256 tokenAmount, uint256 minOut) external lockTheSwap {\\r\\n        if(msg.sender != address(this)) {\\r\\n            require(manualSwapEnabled || msg.sender == owner(), \\\"manual swap disabled\\\");\\r\\n        }\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            minOut,\\r\\n            path,\\r\\n            taxRecipient, // Send ETH directly to the tax recipient.\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             OWNER-ONLY\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function setBlacklisted(address account, bool value) external onlyOwner {\\r\\n        require(account != address(this), \\\"cant change contract\\\");\\r\\n        _walletState[account].isBlacklisted = value;\\r\\n        emit BlacklistStatusUpdated(account, value);\\r\\n    }\\r\\n\\r\\n    function setMarketPair(address account, bool value) external onlyOwner {\\r\\n        require(account != address(this), \\\"cant change contract\\\");\\r\\n        _walletState[account].isMarketPair = value;\\r\\n        emit MarketPairUpdated(account, value);\\r\\n    }\\r\\n\\r\\n    function setExcludedFromFees(address account, bool value) external onlyOwner {\\r\\n        require(account != address(this), \\\"cant change contract\\\");\\r\\n        _walletState[account].isExcludedFromFees = value;\\r\\n        emit ExcludedFromFeesUpdated(account, value);\\r\\n    }\\r\\n\\r\\n    function setTaxRecipient(address account) external onlyOwner {\\r\\n        taxRecipient = account;\\r\\n        emit TaxRecipientUpdated(account);\\r\\n    }\\r\\n\\r\\n    function setTaxes(uint256 _buyTax, uint256 _sellTax, uint256 _transferTax) public onlyOwner {\\r\\n        // Cap any of the taxes to 10% max.\\r\\n        require(_buyTax <= maxTax, \\\"buy is too high\\\");\\r\\n        require(_sellTax <= maxTax, \\\"sell is too high\\\");\\r\\n        require(_transferTax <= maxTax, \\\"transfer is too high\\\");\\r\\n\\r\\n        buyTaxAndLimit.tax = uint128(_buyTax);\\r\\n        sellTaxAndLimit.tax = uint128(_sellTax);\\r\\n        transferTax = _transferTax;\\r\\n\\r\\n        emit TaxesUpdated(_buyTax, _sellTax, _transferTax);\\r\\n    }\\r\\n\\r\\n    // setLimits are in wad of tokens. 1e18 = 1 token.\\r\\n    function setLimits(uint256 _maxBuyWad, uint256 _maxSellWad, uint256 _maxWalletWad) public onlyOwner {\\r\\n        require(_maxBuyWad >= 20_000_000, \\\"buy is too low\\\");\\r\\n        require(_maxSellWad >= 20_000_000, \\\"sell is too low\\\");\\r\\n        require(_maxWalletWad >= 20_000_000, \\\"wallet is too low\\\");\\r\\n\\r\\n        buyTaxAndLimit.limit = uint128(_maxBuyWad * 10**decimals);\\r\\n        sellTaxAndLimit.limit = uint128(_maxSellWad * 10**decimals);\\r\\n        maxWallet = _maxWalletWad * 10**decimals;\\r\\n\\r\\n        emit LimitsUpdated(_maxBuyWad * 10**decimals, _maxSellWad * 10**decimals, _maxWalletWad * 10**decimals);\\r\\n    }\\r\\n\\r\\n    // setNumTokensToSwap is in wad of tokens. 1e18 = 1 token.\\r\\n    function setNumTokensToSwap(uint256 amountWad) external onlyOwner {\\r\\n        require(amountWad > 0, \\\"amount cant be zero\\\");\\r\\n        numTokensToSwap = amountWad * 10**decimals;\\r\\n\\r\\n        emit NumTokensToSwapUpdated(amountWad * 10**decimals);\\r\\n    }\\r\\n\\r\\n    function setContractSwapEnabled(bool _contractSwapEnabled, bool _manualSwapEnabled) public onlyOwner {\\r\\n        contractSwapEnabled = _contractSwapEnabled;\\r\\n        manualSwapEnabled = _manualSwapEnabled;\\r\\n        emit ContractSwapEnabledUpdated(_contractSwapEnabled, _manualSwapEnabled);\\r\\n    }\\r\\n\\r\\n    function Unpause() external onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function Pause() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function updateUniswapRouter(address newRouter) external onlyOwner {\\r\\n        address oldRouterAddress = address(uniswapV2Router);\\r\\n        require(oldRouterAddress != newRouter, \\\"can't set the same router address\\\");\\r\\n\\r\\n        uniswapV2Router = IUniswapV2Router02(newRouter);\\r\\n        WETH = uniswapV2Router.WETH();\\r\\n\\r\\n        // Approve the new router to spend contract's tokens.\\r\\n        _approve(address(this), newRouter, type(uint256).max);\\r\\n\\r\\n        // Reset approval on old router.\\r\\n        _approve(address(this), oldRouterAddress, 0);\\r\\n\\r\\n        emit UniswapRouterUpdated(newRouter);\\r\\n    }\\r\\n\\r\\n    function openTrading() external onlyOwner {\\r\\n        // Start with manual swap disabled.\\r\\n        setContractSwapEnabled(true, false);\\r\\n        setLimits(\\r\\n            20_000_000,\\r\\n            20_000_000,\\r\\n            60_000_000\\r\\n        );\\r\\n        setTaxes(1000, 1000, 0);\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function skimETH(address to, uint256 amount) external onlyOwner {\\r\\n        (bool success,) = to.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"ETH transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n    function skimTokens(address tokenAddress, address to, uint256 amount) external onlyOwner {\\r\\n        safeTransfer(tokenAddress, to, amount);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             PAUSABLE OVERRIDES\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    // Override the requireNotPaused implementation to allow the owner\\r\\n    // to interact with the contract while it is paused. This allows the\\r\\n    // owner to airdrop tokens or add liquidity while in a paused state.\\r\\n    function _requireNotPaused() internal view override{\\r\\n        if(paused()) {\\r\\n            if(tx.origin != owner() && msg.sender != owner()) {\\r\\n                revert EnforcedPause();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public {\\r\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\r\\n\\r\\n        // Unchecked because the only math done is incrementing\\r\\n        // the owner's nonce which cannot realistically overflow.\\r\\n        unchecked {\\r\\n            address recoveredAddress = ecrecover(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"\\\\x19\\\\x01\\\",\\r\\n                        DOMAIN_SEPARATOR(),\\r\\n                        keccak256(\\r\\n                            abi.encode(\\r\\n                                keccak256(\\r\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n                                ),\\r\\n                                owner,\\r\\n                                spender,\\r\\n                                value,\\r\\n                                nonces[owner]++,\\r\\n                                deadline\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n\\r\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\r\\n\\r\\n            allowance[recoveredAddress][spender] = value;\\r\\n        }\\r\\n\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\r\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    function computeDomainSeparator() internal view returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n                    keccak256(bytes(name)),\\r\\n                    keccak256(\\\"1\\\"),\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"IUniswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\n/// @dev edits: pass initial pause state in constructor and removed context dependency.\\r\\n/// @author OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\\r\\nabstract contract Pausable {\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The operation failed because the contract is paused.\\r\\n     */\\r\\n    error EnforcedPause();\\r\\n\\r\\n    /**\\r\\n     * @dev The operation failed because the contract is not paused.\\r\\n     */\\r\\n    error ExpectedPause();\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor(bool initialPaused) {\\r\\n        _paused = initialPaused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _requirePaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is paused.\\r\\n     */\\r\\n    function _requireNotPaused() internal view virtual {\\r\\n        if (paused()) {\\r\\n            revert EnforcedPause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is not paused.\\r\\n     */\\r\\n    function _requirePaused() internal view virtual {\\r\\n        if (!paused()) {\\r\\n            revert ExpectedPause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n/// @dev removed context dependency.\\r\\n/// @author OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != msg.sender) {\\r\\n            revert OwnableUnauthorizedAccount(msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_taxRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"BlacklistStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"autoEnabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"manualEnabled\",\"type\":\"bool\"}],\"name\":\"ContractSwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"}],\"name\":\"LimitsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isMarketPair\",\"type\":\"bool\"}],\"name\":\"MarketPairUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NumTokensToSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TaxRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"}],\"name\":\"TaxesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"UniswapRouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_walletState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMarketPair\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExcludedFromFees\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxAndLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"tax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxAndLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"tax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setBlacklisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_contractSwapEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_manualSwapEnabled\",\"type\":\"bool\"}],\"name\":\"setContractSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBuyWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSellWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxWalletWad\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setMarketPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWad\",\"type\":\"uint256\"}],\"name\":\"setNumTokensToSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setTaxRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferTax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"skimETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"skimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"swapFeesAndSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateUniswapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AG", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000fe73dba49b8531c639dcddee764dcaf49d91066b0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000000000f416c7068612047617264656e657273000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024147000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}