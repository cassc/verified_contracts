{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n///@title Koto ERC20 Token\r\n///@author Izanagi Dev\r\n///@notice A stripped down ERC20 tax token that implements automated and continious monetary policy decisions.\r\n///@dev Bonds are the ERC20 token in exchange for Ether. Unsold bonds with automatically carry over to the next day.\r\n/// The bonding schedule is set to attempt to sell all of the tokens held within the contract in 1 day intervals. Taking a snapshot\r\n/// of the amount currently held within the contract at the start of the next internal period, using this amount as the capcipty to be sold.\r\n\r\n/// Socials\r\n/// Telegram: https://t.me/IzanangiPortal\r\n\r\npragma solidity =0.8.22;\r\n\r\nlibrary PricingLibrary {\r\n    // 1 Slot\r\n    struct Data {\r\n        uint48 lastTune;\r\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\r\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\r\n        uint48 depositInterval; // target frequency of deposits\r\n        uint48 tuneInterval; // frequency of tuning\r\n    }\r\n\r\n    // 2 Storage slots\r\n    struct Market {\r\n        uint96 capacity; // capacity remaining\r\n        uint96 totalDebt; // total debt from market\r\n        uint96 maxPayout; // max tokens in/out\r\n        uint96 sold; // Koto out\r\n        uint96 purchased; // Eth in\r\n    }\r\n\r\n    // 1 Storage Slot\r\n    struct Adjustment {\r\n        uint128 change;\r\n        uint48 lastAdjustment;\r\n        uint48 timeToAdjusted;\r\n        bool active;\r\n    }\r\n\r\n    // 2 Storage slots\r\n    struct Term {\r\n        uint48 conclusion; // timestamp when the current market will end\r\n        uint256 controlVariable; // scaling variable for price\r\n    }\r\n\r\n    function decay(Data memory data, Market memory market, Term memory terms, Adjustment memory adjustments)\r\n        internal\r\n        view\r\n        returns (Market memory, Data memory, Term memory, Adjustment memory)\r\n    {\r\n        uint48 time = uint48(block.timestamp);\r\n        market.totalDebt -= debtDecay(data, market);\r\n        data.lastDecay = time;\r\n\r\n        if (adjustments.active) {\r\n            (uint128 adjustby, uint48 dt, bool stillActive) = controlDecay(adjustments);\r\n            terms.controlVariable -= adjustby;\r\n            if (stillActive) {\r\n                adjustments.change -= adjustby;\r\n                adjustments.timeToAdjusted -= dt;\r\n                adjustments.lastAdjustment = time;\r\n            } else {\r\n                adjustments.active = false;\r\n            }\r\n        }\r\n        return (market, data, terms, adjustments);\r\n    }\r\n\r\n    function controlDecay(Adjustment memory info) internal view returns (uint128, uint48, bool) {\r\n        if (!info.active) return (0, 0, false);\r\n\r\n        uint48 secondsSince = uint48(block.timestamp) - info.lastAdjustment;\r\n        bool active = secondsSince < info.timeToAdjusted;\r\n        uint128 _decay = active ? (info.change * secondsSince) / info.timeToAdjusted : info.change;\r\n        return (_decay, secondsSince, active);\r\n    }\r\n\r\n    function marketPrice(uint256 _controlVariable, uint256 _totalDebt, uint256 _totalSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return ((_controlVariable * debtRatio(_totalDebt, _totalSupply)) / 1e18);\r\n    }\r\n\r\n    function debtRatio(uint256 _totalDebt, uint256 _totalSupply) internal pure returns (uint256) {\r\n        return ((_totalDebt * 1e18) / _totalSupply);\r\n    }\r\n\r\n    function debtDecay(Data memory data, Market memory market) internal view returns (uint64) {\r\n        uint256 secondsSince = block.timestamp - data.lastDecay;\r\n        return uint64((market.totalDebt * secondsSince) / data.length);\r\n    }\r\n\r\n    struct TuneCache {\r\n        uint256 remaining;\r\n        uint256 price;\r\n        uint256 capacity;\r\n        uint256 targetDebt;\r\n        uint256 ncv;\r\n    }\r\n\r\n    function tune(\r\n        uint48 time,\r\n        Market memory market,\r\n        Term memory term,\r\n        Data memory data,\r\n        Adjustment memory adjustment,\r\n        uint256 _totalSupply\r\n    ) internal pure returns (Market memory, Term memory, Data memory, Adjustment memory) {\r\n        TuneCache memory cache;\r\n        if (time >= data.lastTune + data.tuneInterval) {\r\n            cache.remaining = term.conclusion - time;\r\n            cache.price = marketPrice(term.controlVariable, market.totalDebt, _totalSupply);\r\n            cache.capacity = market.capacity; //Is this even necessary?\r\n            market.maxPayout = uint96((cache.capacity * data.depositInterval / cache.remaining));\r\n            cache.targetDebt = cache.capacity * data.length / cache.remaining;\r\n            cache.ncv = (cache.price * _totalSupply) / cache.targetDebt;\r\n\r\n            if (cache.ncv < term.controlVariable) {\r\n                term.controlVariable = cache.ncv;\r\n            } else {\r\n                uint128 change = uint128(term.controlVariable - cache.ncv);\r\n                adjustment = Adjustment(change, time, data.tuneInterval, true);\r\n            }\r\n            data.lastTune = time;\r\n        }\r\n        return (market, term, data, adjustment);\r\n    }\r\n}\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n\r\ncontract Koto {\r\n    struct Limits {\r\n        uint96 maxWallet;\r\n        uint96 maxTransactions;\r\n        bool limits;\r\n    }\r\n    // ========================== STORAGE ========================== \\\\\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) private _excluded;\r\n    mapping(address => bool) private _amms;\r\n    uint256 private _totalSupply;\r\n\r\n    PricingLibrary.Adjustment private adjustment;\r\n    PricingLibrary.Data private data;\r\n    PricingLibrary.Market private market;\r\n    PricingLibrary.Term private term;\r\n    Limits private limits;\r\n    uint8 private locked;\r\n    bool private launched;\r\n\r\n    // =================== CONSTANTS / IMMUTABLES =================== \\\\\r\n\r\n    string private constant NAME = \"Koto\";\r\n    string private constant SYMBOL = \"KOTO\";\r\n    uint8 private constant DECIMALS = 18;\r\n    ///@dev flat 5% tax for buys and sells\r\n    uint8 private constant FEE = 50;\r\n    bool private immutable zeroForOne;\r\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address private constant OWNER = 0x0688578EC7273458785591d3AfFD120E664900C2;\r\n    address private constant BOND_DEPOSITORY = 0x0e58bD5557C4e0a0Abf0e8d4df24177Ae714452D;\r\n    address private immutable pair;\r\n    address private immutable token0;\r\n    address private immutable token1;\r\n    uint256 private constant INTERVAL = 86400; // 1 day in seconds\r\n\r\n    // ========================== MODIFIERS ========================== \\\\\r\n\r\n    modifier lock() {\r\n        if (locked == 2) revert Reentrancy();\r\n        locked = 2;\r\n        _;\r\n        locked = 1;\r\n    }\r\n\r\n    // ========================= CONTRUCTOR ========================= \\\\\r\n\r\n    constructor() {\r\n        pair = _createUniswapV2Pair(address(this), WETH);\r\n        _excluded[OWNER] = true;\r\n        _excluded[BOND_DEPOSITORY] = true;\r\n        _excluded[address(this)] = true;\r\n        _amms[pair] = true;\r\n        _mint(address(this), 7_000_000e18);\r\n        _mint(OWNER, 2_000_000e18);\r\n        _mint(BOND_DEPOSITORY, 1_000_000e18);\r\n        limits = Limits({maxWallet: 100_000e18, maxTransactions: 100_000e18, limits: true});\r\n        (token0, token1) = _getTokens(pair);\r\n        zeroForOne = address(this) == token0 ? true : false;\r\n        _allowances[address(this)][UNISWAP_V2_ROUTER] = type(uint256).max;\r\n        ///@dev set term conclusion to type uint48 max to prevent bonds being created before opening them to the public\r\n        term.conclusion = type(uint48).max;\r\n    }\r\n\r\n    // ==================== EXTERNAL FUNCTIONS ===================== \\\\\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (_to == address(0) || _value == 0) revert InvalidTransfer();\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (_to == address(0) || _value == 0) revert InvalidTransfer();\r\n        if (_from != msg.sender) {\r\n            if (_allowances[_from][msg.sender] < _value) revert InsufficentAllowance();\r\n            _allowances[_from][msg.sender] -= _value;\r\n        }\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        address owner = msg.sender;\r\n        _allowances[owner][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    ///@notice exchange ETH for Koto tokens at the current bonding price\r\n    ///@dev bonds are set on 1 day intervals with 4 hour deposit intervals and 30 minute tune intervals.\r\n    function bond() public payable lock returns (uint256 payout) {\r\n        // If the previous market has ended create a new market.\r\n        if (block.timestamp > term.conclusion) {\r\n            _create();\r\n        }\r\n        if (market.capacity != 0) {\r\n            // Cache variables for later use to minimize storage calls\r\n            PricingLibrary.Market memory _market = market;\r\n            PricingLibrary.Term memory _term = term;\r\n            PricingLibrary.Data memory _data = data;\r\n            PricingLibrary.Adjustment memory adjustments = adjustment;\r\n            uint256 _supply = _totalSupply;\r\n            uint48 time = uint48(block.timestamp);\r\n\r\n            // Cache variables that are updated prior to marketprice call to reduce storage retreivals\r\n            uint256 cachedControlVariable = _term.controlVariable;\r\n            uint256 cachedTotalDebt = _market.totalDebt;\r\n\r\n            // Can pass in structs here as nothing has been updated yet\r\n            (_market, _data, _term, adjustments) = PricingLibrary.decay(data, _market, _term, adjustments);\r\n\r\n            uint256 price = PricingLibrary.marketPrice(cachedControlVariable, cachedTotalDebt, _supply);\r\n\r\n            payout = (msg.value * 1e18 / price);\r\n            if (payout > market.maxPayout) revert MaxPayout();\r\n\r\n            // Update market variables\r\n            _market.capacity -= uint96(payout);\r\n            _market.purchased += uint96(msg.value);\r\n            _market.sold += uint96(payout);\r\n            _market.totalDebt += uint96(payout);\r\n\r\n            bool success = _bond(msg.sender, payout);\r\n            if (!success) revert BondFailed();\r\n            emit Bond(msg.sender, payout, price);\r\n\r\n            //Touches market, data, terms, and adjustments\r\n            (_market, _term, _data, adjustments) =\r\n                PricingLibrary.tune(time, _market, _term, _data, adjustments, _supply);\r\n\r\n            // Write changes to storage.\r\n            market = _market;\r\n            term = _term;\r\n            data = _data;\r\n            adjustment = adjustments;\r\n        } else {\r\n            //If bonds are not available refund the eth sent to the contract\r\n            SafeTransferLib.safeTransferETH(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    ///@notice burn Koto tokens in exchange for a piece of the underlying reserves\r\n    ///@param amount The amount of Koto tokens to redeem\r\n    ///@return payout The amount of ETH received in exchange for the Koto tokens\r\n    function redeem(uint256 amount) external returns (uint256 payout) {\r\n        // Underlying reserves per token\r\n        uint256 price = (address(this).balance * 1e18) / _totalSupply;\r\n        payout = (price * amount) / 1e18;\r\n        _burn(msg.sender, amount);\r\n        SafeTransferLib.safeTransferETH(msg.sender, payout);\r\n        emit Redeem(msg.sender, amount, payout, price);\r\n    }\r\n\r\n    ///@notice burn Koto tokens, without redemption\r\n    ///@param amount the amount of Koto to burn\r\n    function burn(uint256 amount) external returns (bool success) {\r\n        _burn(msg.sender, amount);\r\n        success = true;\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    // ==================== EXTERNAL VIEW FUNCTIONS ===================== \\\\\r\n\r\n    ///@notice get the tokens name\r\n    function name() public pure returns (string memory) {\r\n        return NAME;\r\n    }\r\n\r\n    ///@notice get the tokens symbol\r\n    function symbol() public pure returns (string memory) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    ///@notice get the tokens decimals\r\n    function decimals() public pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    ///@notice get the tokens total supply\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    ///@notice get the current balance of a user\r\n    ///@param _owner the user whos balance you want to check\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    ///@notice get current approved amount for transfer from another party\r\n    ///@param owner the current owner of the tokens\r\n    ///@param spender the user who has approval (or not) to spend the owners tokens\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    ///@notice return the Uniswap V2 Pair address\r\n    function pool() external view returns (address) {\r\n        return pair;\r\n    }\r\n\r\n    ///@notice get the owner of the contract\r\n    ///@dev ownership is nontransferable and limited to opening trade, exclusion / inclusion,s and increasing liquidity\r\n    function ownership() external pure returns (address) {\r\n        return OWNER;\r\n    }\r\n\r\n    ///@notice the current price a bond\r\n    function bondPrice() external view returns (uint256) {\r\n        return PricingLibrary.marketPrice(term.controlVariable, market.totalDebt, _totalSupply);\r\n    }\r\n\r\n    ///@notice return the current redemption price for 1 uint of Koto.\r\n    function redemptionPrice() external view returns (uint256) {\r\n        return ((address(this).balance * 1e18) / _totalSupply);\r\n    }\r\n\r\n    function marketInfo()\r\n        external\r\n        view\r\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory)\r\n    {\r\n        return (market, term, data);\r\n    }\r\n\r\n    function depository() external pure returns (address) {\r\n        return BOND_DEPOSITORY;\r\n    }\r\n\r\n    // ========================= ADMIN FUNCTIONS ========================= \\\\\r\n\r\n    ///@notice increase the liquidity of the uniswap v2 pair\r\n    ///@param tokenAmount the amount of tokens to add to the LP pool\r\n    ///@param ethAmount the amount of eth to add to the pool\r\n    ///@dev both the eth and the tokens must already be held within the contract\r\n    function increaseLiquidity(uint256 tokenAmount, uint256 ethAmount) external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        _addLiquidity(tokenAmount, ethAmount);\r\n        emit IncreaseLiquidity(tokenAmount, ethAmount);\r\n    }\r\n\r\n    ///@notice remove a given address from fees and limits\r\n    ///@param user the user to exclude from fees\r\n    ///@dev this is a one way street so once a user has been excluded they can not then be removed\r\n    function exclude(address user) external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        _excluded[user] = true;\r\n        emit UserExcluded(user);\r\n    }\r\n\r\n    ///@notice remove trading and wallet limits\r\n    function removeLimits() external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        limits.limits = false;\r\n        emit LimitsRemoved(block.timestamp);\r\n    }\r\n\r\n    ///@notice add a amm pool / pair\r\n    ///@param _pool the address of the pool / pair to add\r\n    function addAmm(address _pool) external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        _amms[_pool] = true;\r\n        emit AmmAdded(_pool);\r\n    }\r\n\r\n    ///@notice seed the initial liquidity from this contract.\r\n    function launch() external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        if (launched) revert AlreadyLaunched();\r\n        _addInitialLiquidity();\r\n        launched = true;\r\n        emit Launched(block.timestamp);\r\n    }\r\n\r\n    ///@notice opens the bond market\r\n    ///@dev the liquidity pool must already be launched and initialized. As well as tokens sent to this contract from\r\n    /// the bond depository.\r\n    function open() external {\r\n        if (msg.sender != OWNER) revert OnlyOwner();\r\n        _create();\r\n        emit OpenBondMarket(block.timestamp);\r\n    }\r\n\r\n    // ========================= INTERNAL FUNCTIONS ========================= \\\\\r\n\r\n    ///@notice create the Uniswap V2 Pair\r\n    ///@param _token0 token 0 of the pair\r\n    ///@param _token1 token 1 of the pair\r\n    ///@return _pair the pair address\r\n    function _createUniswapV2Pair(address _token0, address _token1) private returns (address _pair) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0xc9c6539600000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(ptr, 4), and(_token0, 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(ptr, 36), and(_token1, 0xffffffffffffffffffffffffffffffffffffffff))\r\n            let result := call(gas(), UNISWAP_V2_FACTORY, 0, ptr, 68, 0, 32)\r\n            if iszero(result) { revert(0, 0) }\r\n            _pair := mload(0x00)\r\n        }\r\n    }\r\n\r\n    ///@notice increase the liquidity of the Uniswap V2 Pair\r\n    ///@param tokenAmount the amount of tokens to add to the pool\r\n    ///@param ethAmount the amount of ETH to add to the pool\r\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0xf305d71900000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(ptr, 4), and(address(), 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(ptr, 36), tokenAmount)\r\n            mstore(add(ptr, 68), 0)\r\n            mstore(add(ptr, 100), 0)\r\n            mstore(add(ptr, 132), BOND_DEPOSITORY)\r\n            mstore(add(ptr, 164), timestamp())\r\n            let result := call(gas(), UNISWAP_V2_ROUTER, ethAmount, ptr, 196, 0, 0)\r\n            if iszero(result) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    function _addInitialLiquidity() private {\r\n        uint256 tokenAmount = _balances[address(this)];\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0xf305d71900000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(ptr, 4), and(address(), 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(ptr, 36), tokenAmount)\r\n            mstore(add(ptr, 68), 0)\r\n            mstore(add(ptr, 100), 0)\r\n            mstore(add(ptr, 132), BOND_DEPOSITORY)\r\n            mstore(add(ptr, 164), timestamp())\r\n            let result := call(gas(), UNISWAP_V2_ROUTER, balance(address()), ptr, 196, 0, 0)\r\n            if iszero(result) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    ///@notice create the next bond market information\r\n    ///@dev this is done automatically if the previous market conclusion has passed\r\n    /// time check must be done elsewhere as the initial conclusion is set to uint48 max,\r\n    /// tokens must also already be held within the contract or else the call will revert\r\n    function _create() private {\r\n        // Set the initial price to the current market price\r\n        uint256 initialPrice = _getPrice();\r\n        uint96 targetDebt = uint96(_balances[address(this)]);\r\n        uint96 capacity = targetDebt;\r\n        uint96 maxPayout = uint96(targetDebt * 14400 / INTERVAL);\r\n        uint256 controlVariable = initialPrice * _totalSupply / targetDebt;\r\n        bool policy = _policy(capacity, initialPrice);\r\n        uint48 conclusion = uint48(block.timestamp + INTERVAL);\r\n\r\n        if (policy) {\r\n            market = PricingLibrary.Market(capacity, targetDebt, maxPayout, 0, 0);\r\n            term = PricingLibrary.Term(conclusion, controlVariable);\r\n            data = PricingLibrary.Data(uint48(block.timestamp), uint48(block.timestamp), uint48(INTERVAL), 14400, 1800);\r\n            emit CreateMarket(capacity, block.timestamp, conclusion);\r\n        } else {\r\n            _burn(address(this), capacity);\r\n            // Set the markets so that they will be closed for the next interval. Important step to make sure\r\n            // that if anyone accidently tries to buy a bond they get refunded their eth.\r\n            term.conclusion = uint48(block.timestamp + INTERVAL);\r\n            market.capacity = 0;\r\n        }\r\n    }\r\n\r\n    ///@notice determines if to sell the tokens available as bonds or to burn them instead\r\n    ///@param capacity the amount of tokens that will be available within the next bonding cycle\r\n    ///@param price the starting price of the bonds to sell\r\n    ///@return decision the decision reached determining which is more valuable to sell the bonds (true) or to burn them (false)\r\n    ///@dev the decision is made optimistically using the initial price as the selling price for the deicison. If selling the tokens all at the starting\r\n    /// price does not increase relative reserves more than burning the tokens then they are burned. If they are equivilant burning wins out.\r\n    function _policy(uint256 capacity, uint256 price) private view returns (bool decision) {\r\n        uint256 supply = _totalSupply;\r\n        uint256 burnRelative = (address(this).balance * 1e18) / (supply - capacity);\r\n        uint256 bondRelative = ((address(this).balance * 1e18) + ((capacity * price))) / supply;\r\n        decision = burnRelative >= bondRelative ? false : true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 _value) private {\r\n        if (_value > _balances[from]) revert InsufficentBalance();\r\n        bool fees;\r\n        if (_amms[to] || _amms[from]) {\r\n            if (_excluded[to] || _excluded[from]) {\r\n                fees = false;\r\n            } else {\r\n                fees = true;\r\n            }\r\n        }\r\n        if (checkLimits(from, to, _value)) revert LimitsReached();\r\n        if (fees) {\r\n            uint256 fee = (_value * FEE) / 1000;\r\n\r\n            unchecked {\r\n                _balances[from] -= _value;\r\n                _balances[BOND_DEPOSITORY] += fee;\r\n            }\r\n            _value -= fee;\r\n            unchecked {\r\n                _balances[to] += _value;\r\n            }\r\n        } else {\r\n            unchecked {\r\n                _balances[from] -= _value;\r\n                _balances[to] += _value;\r\n            }\r\n        }\r\n        emit Transfer(from, to, _value);\r\n    }\r\n\r\n    ///@notice mint new koto tokens\r\n    ///@param to the user who will receive the tokens\r\n    ///@param value the amount of tokens to mint\r\n    ///@dev this function is used once, during the creation of the contract and is then\r\n    /// not callable\r\n    function _mint(address to, uint256 value) private {\r\n        unchecked {\r\n            _balances[to] += value;\r\n            _totalSupply += value;\r\n        }\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    ///@notice burn koto tokens\r\n    ///@param from the user to burn the tokens from\r\n    ///@param value the amount of koto tokens to burn\r\n    function _burn(address from, uint256 value) private {\r\n        if (_balances[from] < value) revert InsufficentBalance();\r\n        unchecked {\r\n            _balances[from] -= value;\r\n            _totalSupply -= value;\r\n        }\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    ///@notice send the user the correct amount of tokens after the have bought a bond\r\n    ///@param to the user to send the tokens to\r\n    ///@param value the amount of koto tokens to send\r\n    ///@dev bonds are not subject to taxes\r\n    function _bond(address to, uint256 value) private returns (bool success) {\r\n        if (value > _balances[address(this)]) revert InsufficentBondsAvailable();\r\n        unchecked {\r\n            _balances[to] += value;\r\n            _balances[address(this)] -= value;\r\n        }\r\n        success = true;\r\n        emit Transfer(address(this), to, value);\r\n    }\r\n\r\n    ///@notice calculate the current market price based on the reserves of the Uniswap Pair\r\n    ///@dev price is returned as the amount of ETH you would get back for 1 full (1e18) Koto tokens\r\n    function _getPrice() public view returns (uint256 price) {\r\n        address _pair = pair;\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\r\n            let success := staticcall(gas(), _pair, ptr, 4, 0, 0)\r\n            if iszero(success) { revert(0, 0) }\r\n            returndatacopy(0x00, 0, 32)\r\n            returndatacopy(0x20, 0x20, 32)\r\n            reserve0 := mload(0x00)\r\n            reserve1 := mload(0x20)\r\n        }\r\n\r\n        if (zeroForOne) {\r\n            price = (uint256(reserve1) * 1e18) / uint256(reserve0);\r\n        } else {\r\n            price = (uint256(reserve0) * 1e18) / uint256(reserve1);\r\n        }\r\n    }\r\n\r\n    function _getTokens(address _pair) public view returns (address _token0, address _token1) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x0dfe168100000000000000000000000000000000000000000000000000000000)\r\n            let resultToken0 := staticcall(gas(), _pair, ptr, 4, 0, 32)\r\n            mstore(add(ptr, 4), 0xd21220a700000000000000000000000000000000000000000000000000000000)\r\n            let resultToken1 := staticcall(gas(), _pair, add(ptr, 4), 4, 32, 32)\r\n            if or(iszero(resultToken0), iszero(resultToken1)) { revert(0, 0) }\r\n            _token0 := mload(0x00)\r\n            _token1 := mload(0x20)\r\n        }\r\n    }\r\n\r\n    ///@notice check to see if a transaction is within the limits if limits are still enforced\r\n    ///@param to the user who is either initiating the transaction or the user receiving the tokens\r\n    ///@param value the amount of koto tokens within the transaction\r\n    ///@return limited if the user has broken limits (true) or if they are okay to continue (false)\r\n    ///@dev the case were limits are no longer in place is checked first to help save gas once they are turned off\r\n    function checkLimits(address from, address to, uint256 value) private view returns (bool limited) {\r\n        Limits memory _limits = limits;\r\n        if (!_limits.limits) {\r\n            limited = false;\r\n        } else if (from == address(this) && to == pair) {\r\n            limited = false;\r\n        } else {\r\n            if (\r\n                (!_excluded[to] && !_excluded[from])\r\n                    && (_limits.maxTransactions < value || _limits.maxWallet < (_balances[to] + value))\r\n            ) {\r\n                limited = true;\r\n            } else {\r\n                limited = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ========================= EVENTS ========================= \\\\\r\n\r\n    event AmmAdded(address poolAdded);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Bond(address indexed buyer, uint256 amount, uint256 bondPrice);\r\n    event CreateMarket(uint256 bonds, uint256 start, uint48 end);\r\n    event IncreaseLiquidity(uint256 kotoAdded, uint256 ethAdded);\r\n    event Launched(uint256 time);\r\n    event LimitsRemoved(uint256 time);\r\n    event OpenBondMarket(uint256 openingTime);\r\n    event Redeem(address indexed sender, uint256 burned, uint256 payout, uint256 floorPrice);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event UserExcluded(address indexed userToExclude);\r\n\r\n    // ========================= ERRORS ========================= \\\\\r\n\r\n    error AlreadyLaunched();\r\n    error BondFailed();\r\n    error InsufficentAllowance();\r\n    error InsufficentBalance();\r\n    error InsufficentBondsAvailable();\r\n    error InvalidTransfer();\r\n    error LimitsReached();\r\n    error MarketClosed();\r\n    error MaxPayout();\r\n    error OnlyOwner();\r\n    error RedeemFailed();\r\n    error Reentrancy();\r\n\r\n    receive() external payable {\r\n        if (msg.sender != OWNER && msg.sender != UNISWAP_V2_ROUTER) {\r\n            bond();\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyLaunched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentBondsAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxPayout\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolAdded\",\"type\":\"address\"}],\"name\":\"AmmAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondPrice\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"end\",\"type\":\"uint48\"}],\"name\":\"CreateMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"}],\"name\":\"IncreaseLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LimitsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"}],\"name\":\"OpenBondMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userToExclude\",\"type\":\"address\"}],\"name\":\"UserExcluded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"_getTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"addAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depository\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"exclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"increaseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"totalDebt\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxPayout\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"sold\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"purchased\",\"type\":\"uint96\"}],\"internalType\":\"struct PricingLibrary.Market\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"}],\"internalType\":\"struct PricingLibrary.Term\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"lastTune\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastDecay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"length\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"depositInterval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"tuneInterval\",\"type\":\"uint48\"}],\"internalType\":\"struct PricingLibrary.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Koto", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://952dd1b4658b6d3f405f63247e685c1618b447b5d264129126792547927be72b"}