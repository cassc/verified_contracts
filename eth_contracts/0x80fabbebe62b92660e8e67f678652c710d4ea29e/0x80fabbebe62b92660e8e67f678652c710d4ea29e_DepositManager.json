{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/managers/DepositManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/utils/math/SafeCast.sol\\\";\\nimport \\\"../interfaces/IAction.sol\\\";\\nimport \\\"../interfaces/IAssetGroupRegistry.sol\\\";\\nimport \\\"../interfaces/IDepositManager.sol\\\";\\nimport \\\"../interfaces/IGuardManager.sol\\\";\\nimport \\\"../interfaces/IMasterWallet.sol\\\";\\nimport \\\"../interfaces/IRiskManager.sol\\\";\\nimport \\\"../interfaces/ISmartVault.sol\\\";\\nimport \\\"../interfaces/ISmartVaultManager.sol\\\";\\nimport \\\"../interfaces/IStrategy.sol\\\";\\nimport \\\"../interfaces/IStrategyRegistry.sol\\\";\\nimport \\\"../interfaces/IUsdPriceFeedManager.sol\\\";\\nimport \\\"../interfaces/Constants.sol\\\";\\nimport \\\"../interfaces/RequestType.sol\\\";\\nimport \\\"../access/SpoolAccessControllable.sol\\\";\\nimport \\\"../libraries/ArrayMapping.sol\\\";\\nimport \\\"../libraries/SpoolUtils.sol\\\";\\nimport \\\"../libraries/uint128a2Lib.sol\\\";\\n\\n/**\\n * @notice Used when deposit is not made in correct asset ratio.\\n */\\nerror IncorrectDepositRatio();\\n\\n/**\\n * @notice Used when normalization for flush factors is zero.\\n */\\nerror InvalidNormalization();\\n\\n/**\\n * @notice Used when trying to burn deposit NFT that was not synced yet.\\n * @param id ID of the NFT.\\n */\\nerror DepositNftNotSyncedYet(uint256 id);\\n\\n/**\\n * @notice Used when initial locked smart vault shares are already minted and vault usd value is zero.\\n */\\nerror SmartVaultWorthIsZero();\\n\\n/**\\n * @notice Contains parameters for distributeDeposit call.\\n * @custom:member deposit Amounts deposited.\\n * @custom:member exchangeRates Asset -> USD exchange rates.\\n * @custom:member allocation Required allocation of value between different strategies.\\n * @custom:member strategyRatios Required ratios between assets for each strategy.\\n */\\nstruct DepositQueryBag1 {\\n    uint256[] deposit;\\n    uint256[] exchangeRates;\\n    uint16a16 allocation;\\n    uint256[][] strategyRatios;\\n}\\n\\nstruct ClaimTokensLocalBag {\\n    bytes[] metadata;\\n    uint256 mintedSVTs;\\n    DepositMetadata data;\\n}\\n\\nstruct SyncDepositsSimulateLocalBag {\\n    int256 totalPlatformFees;\\n    uint256 svtSupply;\\n}\\n\\n/**\\n * @dev Requires roles:\\n * - ROLE_MASTER_WALLET_MANAGER\\n * - ROLE_SMART_VAULT_MANAGER\\n */\\ncontract DepositManager is SpoolAccessControllable, IDepositManager {\\n    using SafeERC20 for IERC20;\\n    using uint16a16Lib for uint16a16;\\n    using uint128a2Lib for uint128a2;\\n    using ArrayMappingUint256 for mapping(uint256 => uint256);\\n\\n    /**\\n     * @dev Precission multiplier for internal calculations.\\n     */\\n    uint256 constant PRECISION_MULTIPLIER = 10 ** 42;\\n\\n    /**\\n     * @dev Relative tolerance for deposit ratio compared to ideal ratio.\\n     * Equals to 0.5%/\\n     */\\n    uint256 constant DEPOSIT_TOLERANCE = 50;\\n\\n    /// @notice Strategy registry\\n    IStrategyRegistry private immutable _strategyRegistry;\\n\\n    /// @notice Price feed manager\\n    IUsdPriceFeedManager private immutable _priceFeedManager;\\n\\n    /// @notice Guard manager\\n    IGuardManager internal immutable _guardManager;\\n\\n    /// @notice Action manager\\n    IActionManager internal immutable _actionManager;\\n\\n    /// @notice Master wallet\\n    IMasterWallet private immutable _masterWallet;\\n\\n    /// @notice Ghost strategy\\n    address private immutable _ghostStrategy;\\n\\n    /**\\n     * @notice Exchange rates for vault, at given flush index\\n     * @dev smart vault => flush index => exchange rates\\n     */\\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal _flushExchangeRates;\\n\\n    /**\\n     * @notice Flushed deposits for vault, at given flush index\\n     * @dev smart vault => flush index => strategy => assets deposited\\n     */\\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) internal\\n        _vaultFlushedDeposits;\\n\\n    /**\\n     * @dev smart vault => flush index => mintedVaultShares\\n     */\\n    mapping(address => mapping(uint256 => uint256)) internal _mintedVaultShares;\\n\\n    /**\\n     * @notice Vault deposits at given flush index\\n     * @dev smart vault => flush index => assets deposited\\n     */\\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal _vaultDeposits;\\n\\n    constructor(\\n        IStrategyRegistry strategyRegistry_,\\n        IUsdPriceFeedManager priceFeedManager_,\\n        IGuardManager guardManager_,\\n        IActionManager actionManager_,\\n        ISpoolAccessControl accessControl_,\\n        IMasterWallet masterWallet_,\\n        address ghostStrategy\\n    ) SpoolAccessControllable(accessControl_) {\\n        if (address(guardManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(actionManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(strategyRegistry_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(priceFeedManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(masterWallet_) == address(0)) revert ConfigurationAddressZero();\\n        if (ghostStrategy == address(0)) revert ConfigurationAddressZero();\\n\\n        _guardManager = guardManager_;\\n        _actionManager = actionManager_;\\n        _strategyRegistry = strategyRegistry_;\\n        _priceFeedManager = priceFeedManager_;\\n        _masterWallet = masterWallet_;\\n        _ghostStrategy = ghostStrategy;\\n    }\\n\\n    function smartVaultDeposits(address smartVault, uint256 flushIdx, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return _vaultDeposits[smartVault][flushIdx].toArray(assetGroupLength);\\n    }\\n\\n    function claimSmartVaultTokens(\\n        address smartVault,\\n        uint256[] calldata nftIds,\\n        uint256[] calldata nftAmounts,\\n        address[] calldata tokens,\\n        address owner,\\n        address executor,\\n        uint256 flushIndexToSync\\n    ) external returns (uint256) {\\n        _checkRole(ROLE_SMART_VAULT_MANAGER, msg.sender);\\n\\n        if (nftIds.length != nftAmounts.length) {\\n            revert InvalidNftArrayLength();\\n        }\\n\\n        // NOTE:\\n        // - here we are passing ids into the request context instead of amounts\\n        // - here we passing empty array as tokens\\n        _guardManager.runGuards(\\n            smartVault,\\n            RequestContext({\\n                receiver: owner,\\n                executor: executor,\\n                owner: owner,\\n                requestType: RequestType.BurnNFT,\\n                assets: nftIds,\\n                tokens: new address[](0)\\n            })\\n        );\\n\\n        ClaimTokensLocalBag memory bag;\\n        bag.metadata = ISmartVault(smartVault).burnNFTs(owner, nftIds, nftAmounts);\\n\\n        uint256 claimedVaultTokens = 0;\\n        for (uint256 i; i < nftIds.length; ++i) {\\n            if (nftIds[i] > MAXIMAL_DEPOSIT_ID) {\\n                revert InvalidDepositNftId(nftIds[i]);\\n            }\\n\\n            // we can pass empty strategy array and empty DHW index array,\\n            // because vault should already be synced and mintedVaultShares values available\\n            bag.data = abi.decode(bag.metadata[i], (DepositMetadata));\\n            if (bag.data.flushIndex >= flushIndexToSync) {\\n                revert DepositNftNotSyncedYet(nftIds[i]);\\n            }\\n\\n            bag.mintedSVTs = _mintedVaultShares[smartVault][bag.data.flushIndex];\\n\\n            claimedVaultTokens +=\\n                getClaimedVaultTokensPreview(smartVault, bag.data, nftAmounts[i], bag.mintedSVTs, tokens);\\n        }\\n\\n        // there will be some dust after all users claim SVTs\\n        ISmartVault(smartVault).claimShares(owner, claimedVaultTokens);\\n\\n        emit SmartVaultTokensClaimed(smartVault, owner, claimedVaultTokens, nftIds, nftAmounts);\\n\\n        return claimedVaultTokens;\\n    }\\n\\n    function flushSmartVault(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        uint16a16 allocation,\\n        address[] calldata tokens\\n    ) external returns (uint16a16) {\\n        _checkRole(ROLE_SMART_VAULT_MANAGER, msg.sender);\\n\\n        uint256[] memory deposits = new uint256[](tokens.length);\\n        {\\n            uint256 totalDeposits;\\n            for (uint256 i; i < tokens.length; ++i) {\\n                deposits[i] = _vaultDeposits[smartVault][flushIndex][i];\\n                totalDeposits += deposits[i];\\n            }\\n\\n            // check if there was a deposit made\\n            if (totalDeposits == 0) {\\n                return uint16a16.wrap(0);\\n            }\\n        }\\n\\n        // handle deposits\\n        uint256[] memory exchangeRates = SpoolUtils.getExchangeRates(tokens, _priceFeedManager);\\n        _flushExchangeRates[smartVault][flushIndex].setValues(exchangeRates);\\n\\n        uint256[][] memory distribution = distributeDeposit(\\n            DepositQueryBag1({\\n                deposit: deposits,\\n                exchangeRates: exchangeRates,\\n                allocation: allocation,\\n                strategyRatios: SpoolUtils.getStrategyRatiosAtLastDhw(strategies, _strategyRegistry)\\n            })\\n        );\\n\\n        for (uint256 i; i < strategies.length; ++i) {\\n            if (distribution[i].length > 0) {\\n                _vaultFlushedDeposits[smartVault][flushIndex][strategies[i]].setValues(distribution[i]);\\n            }\\n        }\\n\\n        return _strategyRegistry.addDeposits(strategies, distribution);\\n    }\\n\\n    function syncDeposits(\\n        address smartVault,\\n        uint256[2] calldata bag,\\n        // uint256 flushIndex,\\n        // uint256 lastDhwSyncedTimestamp\\n        address[] calldata strategies,\\n        uint16a16[2] calldata dhwIndexes,\\n        address[] calldata assetGroup,\\n        SmartVaultFees calldata fees\\n    ) external returns (DepositSyncResult memory) {\\n        _checkRole(ROLE_SMART_VAULT_MANAGER, msg.sender);\\n        // mint SVTs based on USD value of claimed SSTs\\n        DepositSyncResult memory syncResult = syncDepositsSimulate(\\n            SimulateDepositParams(smartVault, bag, strategies, assetGroup, dhwIndexes[0], dhwIndexes[1], fees)\\n        );\\n\\n        if (syncResult.mintedSVTs > 0) {\\n            // Vault shares should not exceed uint128\\n            _mintedVaultShares[smartVault][bag[0]] = SafeCast.toUint128(syncResult.mintedSVTs);\\n            for (uint256 i; i < strategies.length; ++i) {\\n                if (syncResult.sstShares[i] > 0) {\\n                    IStrategy(strategies[i]).claimShares(smartVault, syncResult.sstShares[i]);\\n                }\\n            }\\n        }\\n\\n        if (syncResult.initialLockedSVTs > 0) {\\n            ISmartVault(smartVault).mintVaultShares(INITIAL_LOCKED_SHARES_ADDRESS, syncResult.initialLockedSVTs);\\n        }\\n\\n        if (syncResult.mintedSVTs > 0) {\\n            ISmartVault(smartVault).mintVaultShares(smartVault, syncResult.mintedSVTs);\\n        }\\n\\n        if (syncResult.feeSVTs > 0) {\\n            address vaultOwner = _accessControl.smartVaultOwner(smartVault);\\n            ISmartVault(smartVault).mintVaultShares(vaultOwner, syncResult.feeSVTs);\\n        }\\n\\n        emit SmartVaultFeesMinted(smartVault, syncResult.feesCollected);\\n\\n        return syncResult;\\n    }\\n\\n    function syncDepositsSimulate(SimulateDepositParams memory parameters)\\n        public\\n        view\\n        returns (DepositSyncResult memory result)\\n    {\\n        bool depositsMade;\\n        {\\n            uint256[] memory dhwTimestamps =\\n                _strategyRegistry.dhwTimestamps(parameters.strategies, parameters.dhwIndexes);\\n\\n            result.dhwTimestamp = parameters.bag[1];\\n            result.sstShares = new uint256[](parameters.strategies.length);\\n\\n            // find last DHW timestamp of this flush index cycle\\n            for (uint256 i; i < parameters.strategies.length; ++i) {\\n                if (dhwTimestamps[i] > result.dhwTimestamp) {\\n                    result.dhwTimestamp = dhwTimestamps[i];\\n                }\\n            }\\n\\n            for (uint256 i; i < parameters.assetGroup.length; ++i) {\\n                // check if there was any amount deposited\\n                depositsMade = _vaultDeposits[parameters.smartVault][parameters.bag[0]][i] > 0;\\n\\n                if (depositsMade) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        uint256[2] memory totalUsd;\\n        // totalUsd[0]: total USD value of deposits\\n        // totalUsd[1]: total USD value of the smart vault\\n        int256 totalYieldUsd;\\n\\n        StrategyAtIndex[] memory strategyDhwStates = _strategyRegistry.strategyAtIndexBatch(\\n            parameters.strategies, parameters.dhwIndexes, parameters.assetGroup.length\\n        );\\n\\n        // get previous yield for each strategy\\n        int256[] memory previousYields;\\n        if (parameters.fees.performanceFeePct > 0 && uint16a16.unwrap(parameters.dhwIndexesOld) > 0) {\\n            previousYields = _strategyRegistry.getDhwYield(parameters.strategies, parameters.dhwIndexesOld);\\n        }\\n\\n        SyncDepositsSimulateLocalBag memory localVariables = SyncDepositsSimulateLocalBag({\\n            totalPlatformFees: _getTotalPlatformFees(),\\n            svtSupply: ISmartVault(parameters.smartVault).totalSupply()\\n        });\\n        // calculate\\n        // - amount of SSTs to claim from each strategy\\n        // - USD value of yield belonging to this smart vault\\n        for (uint256 i; i < parameters.strategies.length; ++i) {\\n            StrategyAtIndex memory atDhw = strategyDhwStates[i];\\n\\n            if (depositsMade && atDhw.sharesMinted > 0) {\\n                uint256[2] memory depositedUsd;\\n                // depositedUsd[0]: (vault) USD value deposited in the strategy by the smart vault\\n                // depositedUsd[1]: (strategy) USD value deposited in the strategy\\n                depositedUsd[0] = _getVaultDepositsValue(\\n                    parameters.smartVault,\\n                    parameters.bag[0],\\n                    parameters.strategies[i],\\n                    atDhw.exchangeRates,\\n                    parameters.assetGroup\\n                );\\n\\n                if (depositedUsd[0] > 0) {\\n                    // can skip this if no value was deposited\\n                    depositedUsd[1] = _priceFeedManager.assetToUsdCustomPriceBulk(\\n                        parameters.assetGroup, atDhw.assetsDeposited, atDhw.exchangeRates\\n                    );\\n\\n                    // get value of deposits\\n                    result.sstShares[i] = atDhw.sharesMinted * depositedUsd[0] / depositedUsd[1];\\n                    totalUsd[0] += result.sstShares[i] * atDhw.totalStrategyValue / atDhw.totalSSTs;\\n                }\\n            }\\n\\n            if (atDhw.totalStrategyValue == 0) {\\n                // this also covers scenario where `atDhw.totalSSTs` is 0\\n                continue;\\n            }\\n\\n            // get value of the smart vault\\n            uint256 strategyUsd = atDhw.totalStrategyValue\\n                * IStrategy(parameters.strategies[i]).balanceOf(parameters.smartVault) / atDhw.totalSSTs;\\n            totalUsd[1] += strategyUsd;\\n\\n            // get yield\\n            if (parameters.fees.performanceFeePct > 0 && previousYields.length > 0) {\\n                // dhwYield = prevYield + trueYield + prevYield * trueYield\\n                // => interimYield = (dhwYield - prevYield) / (1 + prevYield)\\n                int256 interimYieldPct = YIELD_FULL_PERCENT_INT * (atDhw.dhwYields - previousYields[i])\\n                    / (YIELD_FULL_PERCENT_INT + previousYields[i]);\\n                // strategyUsd = strategyUsdBefore * (1 + yieldPct * (1 - platformFeesPct))\\n                // totalStrategyYieldUsd = (strategyUsd - strategyUsd / (1 + yieldPct * (1 - platformFeesPct))) / (1 - platformFeesPct)\\n                //   = strategyUsd * (yieldPct * (1 - platformFeesPct) / 1 + yieldPct * (1 - platformFeesPct)) / (1 - platformFeesPct)\\n                //   = strategyUsdBefore * (1 + yieldPct * (1 - platformFeesPct)) * yieldPct / (1 + yieldPct * (1 - platformFeesPct))\\n                //   = strategyUsdBefore * yieldPct\\n                // totalStrategyYieldUsd = strategyUsd * yieldPct / (1 + yieldPct * (1 - platformFeesPct))\\n                totalYieldUsd += int256(strategyUsd) * interimYieldPct\\n                    / (\\n                        YIELD_FULL_PERCENT_INT\\n                            + interimYieldPct * (FULL_PERCENT_INT - localVariables.totalPlatformFees) / FULL_PERCENT_INT\\n                    );\\n            }\\n        }\\n\\n        // calculate amount of SVTs to mint\\n        if (localVariables.svtSupply < INITIAL_LOCKED_SHARES) {\\n            result.mintedSVTs = totalUsd[0] * INITIAL_SHARE_MULTIPLIER;\\n\\n            unchecked {\\n                result.initialLockedSVTs = INITIAL_LOCKED_SHARES - localVariables.svtSupply;\\n\\n                if (result.mintedSVTs < result.initialLockedSVTs) {\\n                    result.initialLockedSVTs = result.mintedSVTs;\\n                }\\n\\n                result.mintedSVTs -= result.initialLockedSVTs;\\n            }\\n        } else if (totalUsd[1] > 0) {\\n            uint256 fees;\\n            uint256 mgmtFees;\\n            // management fees\\n            if (parameters.fees.managementFeePct > 0) {\\n                // take percentage of whole vault\\n                mgmtFees = totalUsd[1] * parameters.fees.managementFeePct * (result.dhwTimestamp - parameters.bag[1])\\n                    / SECONDS_IN_YEAR / FULL_PERCENT;\\n                fees = mgmtFees;\\n            }\\n            // performance fees\\n            if (parameters.fees.performanceFeePct > 0 && totalYieldUsd > 0) {\\n                // take percentage of yield\\n                fees += uint256(totalYieldUsd) * parameters.fees.performanceFeePct / FULL_PERCENT;\\n            }\\n            if (fees > 0) {\\n                // dilute shares to collect fees\\n                // current amount represents all value minus fees\\n                //   svtSupply ... totalUsd[1] - fees\\n                // amount of fee shares represent fees\\n                //   feeSVTs ... fees\\n                // => feeSVTs = svtSupply * fees / (totalUsd[1] - fees)\\n\\n                // limit dilution to factor 100 (100 fee shares for each share)\\n                // fee / (totalUsd[1] - fees) <= 100\\n                // => fee_limit = totalUsd[1] * 100 / 101\\n\\n                if (fees < totalUsd[1] * 100 / 101) {\\n                    result.feeSVTs = localVariables.svtSupply * fees / (totalUsd[1] - fees);\\n                } else {\\n                    result.feeSVTs = localVariables.svtSupply * 100;\\n                }\\n\\n                // calculate the minted SVTs for the specific fees\\n                result.feesCollected.managementFees = result.feeSVTs * mgmtFees / fees;\\n                unchecked {\\n                    result.feesCollected.performanceFees = result.feeSVTs - result.feesCollected.managementFees;\\n                }\\n            }\\n\\n            // deposits\\n            result.mintedSVTs = (localVariables.svtSupply + result.feeSVTs) * totalUsd[0] / totalUsd[1];\\n        } else {\\n            revert SmartVaultWorthIsZero();\\n        }\\n\\n        // deposit fees\\n        if (parameters.fees.depositFeePct > 0 && result.mintedSVTs > 0) {\\n            // take smart vault shares to collect deposit fees\\n            result.feesCollected.depositFees = result.mintedSVTs * parameters.fees.depositFeePct / FULL_PERCENT;\\n            unchecked {\\n                result.feeSVTs += result.feesCollected.depositFees;\\n                result.mintedSVTs -= result.feesCollected.depositFees;\\n            }\\n        }\\n    }\\n\\n    function _getTotalPlatformFees() private view returns (int256) {\\n        PlatformFees memory fees = _strategyRegistry.platformFees();\\n\\n        return int256(uint256(fees.ecosystemFeePct)) + int256(uint256(fees.treasuryFeePct));\\n    }\\n\\n    function _getVaultDepositsValue(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address strategy,\\n        uint256[] memory exchangeRates,\\n        address[] memory assetGroup\\n    ) private view returns (uint256) {\\n        return _priceFeedManager.assetToUsdCustomPriceBulk(\\n            assetGroup,\\n            _vaultFlushedDeposits[smartVault][flushIndex][strategy].toArray(assetGroup.length),\\n            exchangeRates\\n        );\\n    }\\n\\n    function depositAssets(DepositBag calldata bag, DepositExtras calldata bag2)\\n        external\\n        onlyRole(ROLE_SMART_VAULT_MANAGER, msg.sender)\\n        returns (uint256)\\n    {\\n        if (bag2.tokens.length != bag.assets.length) {\\n            revert InvalidAssetLengths();\\n        }\\n\\n        // run guards and actions\\n        _guardManager.runGuards(\\n            bag.smartVault,\\n            RequestContext({\\n                receiver: bag.receiver,\\n                executor: bag2.depositor,\\n                owner: bag2.depositor,\\n                requestType: RequestType.Deposit,\\n                tokens: bag2.tokens,\\n                assets: bag.assets\\n            })\\n        );\\n\\n        _actionManager.runActions(\\n            ActionContext({\\n                smartVault: bag.smartVault,\\n                recipient: bag.receiver,\\n                executor: bag2.depositor,\\n                owner: bag2.depositor,\\n                requestType: RequestType.Deposit,\\n                tokens: bag2.tokens,\\n                amounts: bag.assets\\n            })\\n        );\\n\\n        // check if assets are in correct ratio\\n        checkDepositRatio(\\n            bag.assets,\\n            SpoolUtils.getExchangeRates(bag2.tokens, _priceFeedManager),\\n            bag2.allocations,\\n            SpoolUtils.getStrategyRatiosAtLastDhw(bag2.strategies, _strategyRegistry)\\n        );\\n\\n        // update vaults total deposited amounts with current deposit\\n        // and check if there is something to deposit\\n        uint256 cumulativeDepositAmount;\\n        for (uint256 i; i < bag2.tokens.length; ++i) {\\n            _vaultDeposits[bag.smartVault][bag2.flushIndex][i] += bag.assets[i];\\n            cumulativeDepositAmount += bag.assets[i];\\n        }\\n        if (cumulativeDepositAmount == 0) {\\n            // this is mainly done to prevent misconfiguration of swaps\\n            revert NothingToDeposit();\\n        }\\n\\n        // mint deposit NFT\\n        DepositMetadata memory metadata = DepositMetadata(bag.assets, block.timestamp, bag2.flushIndex);\\n        uint256 depositId = ISmartVault(bag.smartVault).mintDepositNFT(bag.receiver, metadata);\\n\\n        emit DepositInitiated(\\n            bag.smartVault, bag.receiver, depositId, bag2.flushIndex, bag.assets, bag2.depositor, bag.referral\\n        );\\n\\n        return depositId;\\n    }\\n\\n    /**\\n     * @notice Calculates fair distribution of deposit among strategies.\\n     * @param bag Parameter bag.\\n     * @return Distribution of deposits, with first index running over strategies and second index running over assets.\\n     */\\n    function distributeDeposit(DepositQueryBag1 memory bag) public pure returns (uint256[][] memory) {\\n        if (bag.deposit.length == 1) {\\n            return _distributeDepositSingleAsset(bag);\\n        } else {\\n            return _distributeDepositMultipleAssets(bag);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if deposit is made in correct ratio.\\n     * @dev Reverts with IncorrectDepositRatio if the check fails.\\n     * @param deposit Amounts deposited.\\n     * @param exchangeRates Asset -> USD exchange rates.\\n     * @param allocation Required allocation of value between different strategies.\\n     * @param strategyRatios Required ratios between assets for each strategy.\\n     */\\n    function checkDepositRatio(\\n        uint256[] memory deposit,\\n        uint256[] memory exchangeRates,\\n        uint16a16 allocation,\\n        uint256[][] memory strategyRatios\\n    ) public pure {\\n        if (deposit.length == 1) {\\n            return;\\n        }\\n\\n        uint256[] memory idealDeposit = calculateDepositRatio(exchangeRates, allocation, strategyRatios);\\n        // find first asset that has non-zero ideal weight and use it as a reference\\n        uint256 ref;\\n        for (uint256 i; i < idealDeposit.length; ++i) {\\n            if (idealDeposit[i] > 0) {\\n                ref = i;\\n\\n                break;\\n            }\\n        }\\n        // all weights cannot be zero, since calculateDepositRatio would revert in that case\\n\\n        // loop over assets\\n        for (uint256 i; i < deposit.length; ++i) {\\n            if (i == ref) {\\n                continue;\\n            }\\n\\n            uint256 valueA = deposit[i] * idealDeposit[ref];\\n            uint256 valueB = deposit[ref] * idealDeposit[i];\\n\\n            if ( // check if valueA is within DEPOSIT_TOLERANCE of valueB\\n                valueA < (valueB * (FULL_PERCENT - DEPOSIT_TOLERANCE) / FULL_PERCENT)\\n                    || valueA > (valueB * (FULL_PERCENT + DEPOSIT_TOLERANCE) / FULL_PERCENT)\\n            ) {\\n                revert IncorrectDepositRatio();\\n            }\\n        }\\n    }\\n\\n    function getDepositRatio(address[] memory tokens, uint16a16 allocations, address[] memory strategies)\\n        external\\n        view\\n        returns (uint256[] memory ratio)\\n    {\\n        return calculateDepositRatio(\\n            SpoolUtils.getExchangeRates(tokens, _priceFeedManager),\\n            allocations,\\n            SpoolUtils.getStrategyRatiosAtLastDhw(strategies, _strategyRegistry)\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculates ideal deposit ratio for a smart vault.\\n     * @param exchangeRates Asset -> USD exchange rates.\\n     * @param allocation Required allocation of value between different strategies.\\n     * @param strategyRatios Required ratios between assets for each strategy.\\n     * @return Ideal deposit ratio.\\n     */\\n    function calculateDepositRatio(\\n        uint256[] memory exchangeRates,\\n        uint16a16 allocation,\\n        uint256[][] memory strategyRatios\\n    ) public pure returns (uint256[] memory) {\\n        if (exchangeRates.length == 1) {\\n            uint256[] memory ratio = new uint256[](1);\\n            ratio[0] = 1;\\n\\n            return ratio;\\n        }\\n\\n        return _calculateDepositRatioFromFlushFactors(calculateFlushFactors(exchangeRates, allocation, strategyRatios));\\n    }\\n\\n    /**\\n     * @dev Calculate flush factors - intermediate result.\\n     * @param exchangeRates Asset -> USD exchange rates.\\n     * @param allocation Required allocation of value between different strategies.\\n     * @param strategyRatios Required ratios between assets for each strategy.\\n     * @return Flush factors, with first index running over strategies and second index running over assets.\\n     */\\n    function calculateFlushFactors(\\n        uint256[] memory exchangeRates,\\n        uint16a16 allocation,\\n        uint256[][] memory strategyRatios\\n    ) public pure returns (uint256[][] memory) {\\n        uint256[][] memory flushFactors = new uint256[][](strategyRatios.length);\\n\\n        // loop over strategies\\n        for (uint256 i; i < strategyRatios.length; ++i) {\\n            flushFactors[i] = new uint256[](exchangeRates.length);\\n\\n            if (allocation.get(i) == 0) {\\n                // ghost strategy\\n                // - flush factors should be set to 0, which are already by default\\n                continue;\\n            }\\n\\n            uint256 normalization = 0;\\n            // loop over assets\\n            for (uint256 j = 0; j < exchangeRates.length; ++j) {\\n                normalization += strategyRatios[i][j] * exchangeRates[j];\\n            }\\n\\n            if (normalization == 0) {\\n                revert InvalidNormalization();\\n            }\\n\\n            // loop over assets\\n            for (uint256 j = 0; j < exchangeRates.length; ++j) {\\n                flushFactors[i][j] = allocation.get(i) * strategyRatios[i][j] * PRECISION_MULTIPLIER / normalization;\\n            }\\n        }\\n\\n        return flushFactors;\\n    }\\n\\n    /**\\n     * @notice Calculates the SVT balance that is available to be claimed\\n     */\\n    function getClaimedVaultTokensPreview(\\n        address smartVaultAddress,\\n        DepositMetadata memory data,\\n        uint256 nftShares,\\n        uint256 mintedSVTs,\\n        address[] calldata tokens\\n    ) public view returns (uint256) {\\n        uint256[] memory totalDepositedAssets;\\n        uint256[] memory exchangeRates;\\n        uint256 depositedUsd;\\n        uint256 totalDepositedUsd;\\n        totalDepositedAssets = _vaultDeposits[smartVaultAddress][data.flushIndex].toArray(data.assets.length);\\n        exchangeRates = _flushExchangeRates[smartVaultAddress][data.flushIndex].toArray(data.assets.length);\\n\\n        if (mintedSVTs == 0) {\\n            mintedSVTs = _mintedVaultShares[smartVaultAddress][data.flushIndex];\\n        }\\n\\n        for (uint256 i; i < data.assets.length; ++i) {\\n            depositedUsd += _priceFeedManager.assetToUsdCustomPrice(tokens[i], data.assets[i], exchangeRates[i]);\\n            totalDepositedUsd +=\\n                _priceFeedManager.assetToUsdCustomPrice(tokens[i], totalDepositedAssets[i], exchangeRates[i]);\\n        }\\n\\n        if (depositedUsd == 0) {\\n            return 0;\\n        }\\n        uint256 claimedVaultTokens = mintedSVTs * depositedUsd / totalDepositedUsd;\\n\\n        return claimedVaultTokens * nftShares / NFT_MINTED_SHARES;\\n    }\\n\\n    /**\\n     * @dev Calculated deposit ratio from flush factors.\\n     * @param flushFactors Flush factors.\\n     * @return Deposit ratio, with first index running over strategies (same length as flush factors) and second index running over assets.\\n     */\\n    function _calculateDepositRatioFromFlushFactors(uint256[][] memory flushFactors)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory depositRatio = new uint256[](flushFactors[0].length);\\n\\n        // loop over strategies\\n        for (uint256 i; i < flushFactors.length; ++i) {\\n            // loop over assets\\n            for (uint256 j = 0; j < flushFactors[i].length; ++j) {\\n                depositRatio[j] += flushFactors[i][j];\\n            }\\n        }\\n\\n        return depositRatio;\\n    }\\n\\n    /**\\n     * @dev Calculates fair distribution of single asset among strategies.\\n     * @param bag Parameter bag.\\n     * @return Distribution of deposits, with first index running over strategies and second index running over assets.\\n     */\\n    function _distributeDepositSingleAsset(DepositQueryBag1 memory bag) private pure returns (uint256[][] memory) {\\n        uint256 distributed;\\n        uint256[][] memory distribution = new uint256[][](bag.strategyRatios.length);\\n\\n        uint256 totalAllocation;\\n        for (uint256 i; i < bag.strategyRatios.length; ++i) {\\n            totalAllocation += bag.allocation.get(i);\\n        }\\n\\n        // loop over strategies\\n        for (uint256 i; i < bag.strategyRatios.length; ++i) {\\n            distribution[i] = new uint256[](1);\\n\\n            distribution[i][0] = bag.deposit[0] * bag.allocation.get(i) / totalAllocation;\\n            distributed += distribution[i][0];\\n        }\\n\\n        // handle dust\\n        if (bag.deposit[0] > distributed) {\\n            // We cannot just assign the dust to an arbitrary strategy (like first or last one)\\n            // in case it is ghost strategy. So we need to find a strategy that was already\\n            // allocated some assets and assign dust to that one instead.\\n            for (uint256 i; i < bag.strategyRatios.length; ++i) {\\n                if (distribution[i][0] > 0) {\\n                    distribution[i][0] += bag.deposit[0] - distributed;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return distribution;\\n    }\\n\\n    /**\\n     * @dev Calculates fair distribution of multiple assets among strategies.\\n     * @param bag Parameter bag.\\n     * @return Distribution of deposits, with first index running over strategies and second index running over assets.\\n     */\\n    function _distributeDepositMultipleAssets(DepositQueryBag1 memory bag) private pure returns (uint256[][] memory) {\\n        uint256[][] memory flushFactors = calculateFlushFactors(bag.exchangeRates, bag.allocation, bag.strategyRatios);\\n        uint256[] memory idealDepositRatio = _calculateDepositRatioFromFlushFactors(flushFactors);\\n\\n        uint256[] memory distributed = new uint256[](bag.deposit.length);\\n        uint256[][] memory distribution = new uint256[][](bag.strategyRatios.length);\\n\\n        // loop over strategies\\n        for (uint256 i; i < bag.strategyRatios.length; ++i) {\\n            distribution[i] = new uint256[](bag.exchangeRates.length);\\n\\n            // loop over assets\\n            for (uint256 j = 0; j < bag.exchangeRates.length; j++) {\\n                if (flushFactors[i][j] == 0) {\\n                    // mitigate division by zero\\n                    continue;\\n                }\\n                distribution[i][j] = bag.deposit[j] * flushFactors[i][j] / idealDepositRatio[j];\\n                distributed[j] += distribution[i][j];\\n            }\\n        }\\n\\n        // handle dust\\n        for (uint256 j = 0; j < bag.exchangeRates.length; j++) {\\n            // We cannot just assign the dust to an arbitrary strategy (like first or last one)\\n            // in case it is ghost strategy. So we need to find a strategy that was already\\n            // allocated some assets and assign dust to that one instead.\\n            for (uint256 i; i < bag.strategyRatios.length; ++i) {\\n                if (distribution[i][j] > 0) {\\n                    distribution[i][j] += bag.deposit[j] - distributed[j];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return distribution;\\n    }\\n\\n    function recoverPendingDeposits(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        address[] calldata tokens,\\n        address emergencyWallet\\n    ) external {\\n        _checkRole(ROLE_SMART_VAULT_MANAGER, msg.sender);\\n\\n        for (uint256 i; i < strategies.length; ++i) {\\n            if (strategies[i] != _ghostStrategy) {\\n                revert NotGhostVault();\\n            }\\n        }\\n\\n        uint256 totalRecovered;\\n        uint256[] memory recoveredAssets = new uint256[](tokens.length);\\n\\n        for (uint256 i; i < tokens.length; ++i) {\\n            recoveredAssets[i] = _vaultDeposits[smartVault][flushIndex][i];\\n            totalRecovered += recoveredAssets[i];\\n\\n            _vaultDeposits[smartVault][flushIndex][i] = 0;\\n\\n            _masterWallet.transfer(IERC20(tokens[i]), emergencyWallet, recoveredAssets[i]);\\n        }\\n\\n        if (totalRecovered == 0) {\\n            revert NoDepositsToRecover();\\n        }\\n\\n        emit PendingDepositsRecovered(smartVault, recoveredAssets);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * The default value of {decimals} is 18. To change this, you should override\\r\\n * this function so it returns a different value.\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the default value returned by this function, unless\\r\\n     * it's overridden.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\r\\nimport \\\"../../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Down, // Toward negative infinity\\r\\n        Up, // Toward infinity\\r\\n        Zero // Toward zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds up instead\\r\\n     * of rounding down.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\r\\n     * with further edits by Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod0 := mul(x, y)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n            // See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n            uint256 twos = denominator & (~denominator + 1);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n *\\r\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\r\\n * all math on `uint256` and `int256` and then downcasting.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\r\\n        return int256(value);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./RequestType.sol\\\";\\n\\n/**\\n * @notice Used when trying to set an invalid action for a smart vault.\\n * @param address_ Address of the invalid action.\\n */\\nerror InvalidAction(address address_);\\n\\n/**\\n * @notice Used when trying to whitelist already whitelisted action.\\n */\\nerror ActionStatusAlreadySet();\\n\\n/**\\n * @notice Used when trying to set actions for smart vault that already has actions set.\\n */\\nerror ActionsAlreadyInitialized(address smartVault);\\n\\n/**\\n * @notice Too many actions have been passed when creating a vault.\\n */\\nerror TooManyActions();\\n\\n/**\\n * @notice Used when wrong request type is set for an action.\\n * @param requestType Wrong request type.\\n */\\nerror WrongActionRequestType(RequestType requestType);\\n\\n/**\\n * @notice Represents a context that is sent to actions.\\n * @custom:member smartVault Smart vault address\\n * @custom:member recipient In case of deposit, recipient of deposit NFT; in case of withdrawal, recipient of assets.\\n * @custom:member executor In case of deposit, executor of deposit action; in case of withdrawal, executor of claimWithdrawal action.\\n * @custom:member owner In case of deposit, owner of assets; in case of withdrawal, owner of withdrawal NFT.\\n * @custom:member requestType Request type that triggered the action.\\n * @custom:member tokens Tokens involved.\\n * @custom:member amount Amount of tokens.\\n */\\nstruct ActionContext {\\n    address smartVault;\\n    address recipient;\\n    address executor;\\n    address owner;\\n    RequestType requestType;\\n    address[] tokens;\\n    uint256[] amounts;\\n}\\n\\ninterface IAction {\\n    /**\\n     * @notice Executes the action.\\n     * @param actionCtx Context for action execution.\\n     */\\n    function executeAction(ActionContext calldata actionCtx) external;\\n}\\n\\ninterface IActionManager {\\n    /**\\n     * @notice Sets actions for a smart vault.\\n     * @dev Requirements:\\n     * - caller needs role ROLE_SMART_VAULT_INTEGRATOR\\n     * @param smartVault Smart vault for which the actions will be set.\\n     * @param actions Actions to set.\\n     * @param requestTypes Specifies for each action, which request type triggers that action.\\n     */\\n    function setActions(address smartVault, IAction[] calldata actions, RequestType[] calldata requestTypes) external;\\n\\n    /**\\n     * @notice Runs actions for a smart vault.\\n     * @dev Requirements:\\n     * - caller needs role ROLE_SMART_VAULT_MANAGER\\n     * @param actionCtx Execution context for the actions.\\n     */\\n    function runActions(ActionContext calldata actionCtx) external;\\n\\n    /**\\n     * @notice Adds or removes an action from the whitelist.\\n     * @dev Requirements:\\n     * - caller needs role ROLE_SPOOL_ADMIN\\n     * @param action Address of an action to add or remove from the whitelist.\\n     * @param whitelist If true, action will be added to the whitelist, if false, it will be removed from it.\\n     */\\n    function whitelistAction(address action, bool whitelist) external;\\n\\n    /**\\n     * @notice Emitted when an action is added or removed from the whitelist.\\n     * @param action Address of the action that was added or removed from the whitelist.\\n     * @param whitelisted True if it was added, false if it was removed from the whitelist.\\n     */\\n    event ActionListed(address indexed action, bool whitelisted);\\n\\n    /**\\n     * @notice Emitted when an action is set for a vault\\n     * @param smartVault Address of the smart vault\\n     * @param action Address of the action that was added\\n     * @param requestType Trigger for executing the action\\n     */\\n    event ActionSet(address indexed smartVault, address indexed action, RequestType requestType);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAssetGroupRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when invalid ID for asset group is provided.\\n * @param assetGroupId Invalid ID for asset group.\\n */\\nerror InvalidAssetGroup(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when no assets are provided for an asset group.\\n */\\nerror NoAssetsProvided();\\n\\n/**\\n * @notice Used when token is not allowed to be used as an asset.\\n * @param token Address of the token that is not allowed.\\n */\\nerror TokenNotAllowed(address token);\\n\\n/**\\n * @notice Used when asset group already exists.\\n * @param assetGroupId ID of the already existing asset group.\\n */\\nerror AssetGroupAlreadyExists(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when given array is unsorted.\\n */\\nerror UnsortedArray();\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IAssetGroupRegistry {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when token is allowed to be used as an asset.\\n     * @param token Address of newly allowed token.\\n     */\\n    event TokenAllowed(address indexed token);\\n\\n    /**\\n     * @notice Emitted when asset group is registered.\\n     * @param assetGroupId ID of the newly registered asset group.\\n     */\\n    event AssetGroupRegistered(uint256 indexed assetGroupId);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if token is allowed to be used as an asset.\\n     * @param token Address of token to check.\\n     * @return isAllowed True if token is allowed, false otherwise.\\n     */\\n    function isTokenAllowed(address token) external view returns (bool isAllowed);\\n\\n    /**\\n     * @notice Gets number of registered asset groups.\\n     * @return count Number of registered asset groups.\\n     */\\n    function numberOfAssetGroups() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Gets asset group by its ID.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return assets Array of assets in the asset group.\\n     */\\n    function listAssetGroup(uint256 assetGroupId) external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets asset group length.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return length\\n     */\\n    function assetGroupLength(uint256 assetGroupId) external view returns (uint256 length);\\n\\n    /**\\n     * @notice Validates that provided ID represents an asset group.\\n     * @dev Function reverts when ID does not represent an asset group.\\n     * @param assetGroupId ID to validate.\\n     */\\n    function validateAssetGroup(uint256 assetGroupId) external view;\\n\\n    /**\\n     * @notice Checks if asset group composed of assets already exists.\\n     * Will revert if provided assets cannot form an asset group.\\n     * @param assets Assets composing the asset group.\\n     * @return Asset group ID if such asset group exists, 0 otherwise.\\n     */\\n    function checkAssetGroupExists(address[] calldata assets) external view returns (uint256);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Allows a token to be used as an asset.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param token Address of token to be allowed.\\n     */\\n    function allowToken(address token) external;\\n\\n    /**\\n     * @notice Allows tokens to be used as assets.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param tokens Addresses of tokens to be allowed.\\n     */\\n    function allowTokenBatch(address[] calldata tokens) external;\\n\\n    /**\\n     * @notice Registers a new asset group.\\n     * @dev Requirements:\\n     * - must provide at least one asset\\n     * - all assets must be allowed\\n     * - assets must be sorted\\n     * - such asset group should not exist yet\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param assets Array of assets in the asset group.\\n     * @return id Sequential ID assigned to the asset group.\\n     */\\n    function registerAssetGroup(address[] calldata assets) external returns (uint256 id);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDepositManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISmartVault.sol\\\";\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/**\\n * @notice Used when deposited assets are not the same length as underlying assets.\\n */\\nerror InvalidAssetLengths();\\n\\n/**\\n * @notice Used when lengths of NFT id and amount arrays when claiming NFTs don't match.\\n */\\nerror InvalidNftArrayLength();\\n\\n/**\\n * @notice Used when trying to deposit zero assets into a smart vault.\\n */\\nerror NothingToDeposit();\\n\\n/**\\n * @notice Used when there are no pending deposits to recover.\\n * E.g., they were already recovered or flushed.\\n */\\nerror NoDepositsToRecover();\\n\\n/**\\n * @notice Used when trying to recover pending deposits from a smart vault that has non-ghost strategies.\\n */\\nerror NotGhostVault();\\n\\n/**\\n * @notice Gathers input for depositing assets.\\n * @custom:member smartVault Smart vault for which the deposit is made.\\n * @custom:member assets Amounts of assets being deposited.\\n * @custom:member receiver Receiver of the deposit NFT.\\n * @custom:member referral Referral address.\\n * @custom:member doFlush If true, the smart vault will be flushed after the deposit as part of same transaction.\\n */\\nstruct DepositBag {\\n    address smartVault;\\n    uint256[] assets;\\n    address receiver;\\n    address referral;\\n    bool doFlush;\\n}\\n\\n/**\\n * @notice Gathers extra input for depositing assets.\\n * @custom:member depositor Address making the deposit.\\n * @custom:member tokens Tokens of the smart vault.\\n * @custom:member strategies Strategies of the smart vault.\\n * @custom:member allocations Set allocation of funds between strategies.\\n * @custom:member flushIndex Current flush index of the smart vault.\\n */\\nstruct DepositExtras {\\n    address depositor;\\n    address[] tokens;\\n    address[] strategies;\\n    uint16a16 allocations;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Gathers minted SVTs for a specific fee type.\\n * @custom:member depositFees Minted SVTs for deposit fees.\\n * @custom:member performanceFees Minted SVTs for performance fees.\\n * @custom:member managementFees Minted SVTs for management fees.\\n */\\nstruct SmartVaultFeesCollected {\\n    uint256 depositFees;\\n    uint256 performanceFees;\\n    uint256 managementFees;\\n}\\n\\n/**\\n * @notice Gathers return values of syncing deposits.\\n * @custom:member mintedSVTs Amount of SVTs minted.\\n * @custom:member dhwTimestamp Timestamp of the last DHW synced.\\n * @custom:member feeSVTs Amount of SVTs minted as fees.\\n * @custom:member feesCollected Breakdown of amount of SVTs minted as fees.\\n * @custom:member initialLockedSVTs Amount of initial locked SVTs.\\n * @custom:member sstShares Amount of SSTs claimed for each strategy.\\n */\\nstruct DepositSyncResult {\\n    uint256 mintedSVTs;\\n    uint256 dhwTimestamp;\\n    uint256 feeSVTs;\\n    SmartVaultFeesCollected feesCollected;\\n    uint256 initialLockedSVTs;\\n    uint256[] sstShares;\\n}\\n\\n/**\\n * @custom:member smartVault Smart Vault address\\n * @custom:member bag flush index, lastDhwSyncedTimestamp\\n * @custom:member strategies strategy addresses\\n * @custom:member assetGroup vault asset group token addresses\\n * @custom:member dhwIndexes DHW Indexes for given flush index\\n * @custom:member dhwIndexesOld DHW Indexes for previous flush index\\n * @custom:member fees smart vault fee configuration\\n * @return syncResult Result of the smart vault sync.\\n */\\nstruct SimulateDepositParams {\\n    address smartVault;\\n    // bag[0]: flushIndex,\\n    // bag[1]: lastDhwSyncedTimestamp,\\n    uint256[2] bag;\\n    address[] strategies;\\n    address[] assetGroup;\\n    uint16a16 dhwIndexes;\\n    uint16a16 dhwIndexesOld;\\n    SmartVaultFees fees;\\n}\\n\\ninterface IDepositManager {\\n    /**\\n     * @notice User redeemed deposit NFTs for SVTs\\n     * @param smartVault Smart vault address\\n     * @param claimer Claimer address\\n     * @param claimedVaultTokens Amount of SVTs claimed\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     */\\n    event SmartVaultTokensClaimed(\\n        address indexed smartVault,\\n        address indexed claimer,\\n        uint256 claimedVaultTokens,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param receiver Beneficiary of the deposit\\n     * @param depositId Deposit NFT ID for this deposit\\n     * @param flushIndex Flush index the deposit was scheduled for\\n     * @param assets Amount of assets to deposit\\n     * @param depositor Address that initiated the deposit\\n     * @param referral Referral address\\n     */\\n    event DepositInitiated(\\n        address indexed smartVault,\\n        address indexed receiver,\\n        uint256 indexed depositId,\\n        uint256 flushIndex,\\n        uint256[] assets,\\n        address depositor,\\n        address referral\\n    );\\n\\n    /**\\n     * @notice Pending deposits were recovered.\\n     * @param smartVault Smart vault address.\\n     * @param recoveredAssets Amount of assets recovered.\\n     */\\n    event PendingDepositsRecovered(address indexed smartVault, uint256[] recoveredAssets);\\n\\n    /**\\n     * @notice Smart vault fees collected.\\n     * @param smartVault Smart vault address.\\n     * @param smartVaultFeesCollected Collected smart vault fee amounts.\\n     */\\n    event SmartVaultFeesMinted(address indexed smartVault, SmartVaultFeesCollected smartVaultFeesCollected);\\n\\n    /**\\n     * @notice Simulate vault synchronization (i.e. DHW was completed, but vault wasn't synced yet)\\n     */\\n    function syncDepositsSimulate(SimulateDepositParams calldata parameters)\\n        external\\n        view\\n        returns (DepositSyncResult memory syncResult);\\n\\n    /**\\n     * @notice Synchronize vault deposits for completed DHW runs\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param bag flushIndex, lastDhwSyncedTimestamp\\n     * @param strategies vault strategy addresses\\n     * @param dhwIndexes dhw indexes for given and previous flushIndex\\n     * @param assetGroup vault asset group token addresses\\n     * @param fees smart vault fee configuration\\n     * @return syncResult Result of the smart vault sync.\\n     */\\n    function syncDeposits(\\n        address smartVault,\\n        uint256[2] calldata bag,\\n        // uint256 flushIndex,\\n        // uint256 lastDhwSyncedTimestamp\\n        address[] calldata strategies,\\n        uint16a16[2] calldata dhwIndexes,\\n        address[] calldata assetGroup,\\n        SmartVaultFees calldata fees\\n    ) external returns (DepositSyncResult memory syncResult);\\n\\n    /**\\n     * @notice Adds deposits for the next flush cycle.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param bag Deposit parameters.\\n     * @param bag2 Extra parameters.\\n     * @return nftId ID of the deposit NFT.\\n     */\\n    function depositAssets(DepositBag calldata bag, DepositExtras calldata bag2) external returns (uint256 nftId);\\n\\n    /**\\n     * @notice Mark deposits ready to be processed in the next DHW cycle\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param flushIndex index to flush\\n     * @param strategies vault strategy addresses\\n     * @param allocations vault strategy allocations\\n     * @param tokens vault asset group token addresses\\n     * @return dhwIndexes DHW indexes in which the deposits will be included\\n     */\\n    function flushSmartVault(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        uint16a16 allocations,\\n        address[] calldata tokens\\n    ) external returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Get the number of SVTs that are available, but haven't been claimed yet, for the given NFT\\n     * @param smartVaultAddress Smart Vault address\\n     * @param data NFT deposit NFT metadata\\n     * @param nftShares amount of NFT shares to burn for SVTs\\n     * @param mintedSVTs amount of SVTs minted for this flush\\n     * @param tokens vault asset group addresses\\n     */\\n    function getClaimedVaultTokensPreview(\\n        address smartVaultAddress,\\n        DepositMetadata memory data,\\n        uint256 nftShares,\\n        uint256 mintedSVTs,\\n        address[] calldata tokens\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Fetch assets deposited in a given vault flush\\n     */\\n    function smartVaultDeposits(address smartVault, uint256 flushIdx, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice Claim SVTs by burning deposit NFTs.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param nftIds NFT ids to burn\\n     * @param nftAmounts NFT amounts to burn (support for partial burn)\\n     * @param tokens vault asset group token addresses\\n     * @param owner address owning NFTs\\n     * @param executor address executing the claim transaction\\n     * @param flushIndexToSync next flush index to sync for the smart vault\\n     * @return claimedTokens Amount of smart vault tokens claimed.\\n     */\\n    function claimSmartVaultTokens(\\n        address smartVault,\\n        uint256[] calldata nftIds,\\n        uint256[] calldata nftAmounts,\\n        address[] calldata tokens,\\n        address owner,\\n        address executor,\\n        uint256 flushIndexToSync\\n    ) external returns (uint256 claimedTokens);\\n\\n    /**\\n     * @notice Recovers pending deposits from smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault from which to recover pending deposits.\\n     * @param flushIndex Flush index for which to recover pending deposits.\\n     * @param strategies Addresses of smart vault's strategies.\\n     * @param tokens Asset group token addresses.\\n     * @param emergencyWallet Address of emergency withdraw wallet.\\n     */\\n    function recoverPendingDeposits(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        address[] calldata tokens,\\n        address emergencyWallet\\n    ) external;\\n\\n    /**\\n     * @notice Gets current required deposit ratio of a smart vault.\\n     * @param tokens Asset tokens of the smart vault.\\n     * @param allocations Allocation between strategies of the smart vault.\\n     * @param strategies Strategies of the smart vault.\\n     * @return ratio Required deposit ratio of the smart vault.\\n     */\\n    function getDepositRatio(address[] memory tokens, uint16a16 allocations, address[] memory strategies)\\n        external\\n        view\\n        returns (uint256[] memory ratio);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGuardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISmartVault.sol\\\";\\nimport \\\"./RequestType.sol\\\";\\n\\nerror GuardsAlreadyInitialized();\\nerror GuardsNotInitialized();\\nerror GuardError();\\n\\n/**\\n * @notice Used when a guard fails.\\n * @param guardNum Sequential number of the guard that failed.\\n */\\nerror GuardFailed(uint256 guardNum);\\n\\nerror InvalidGuardParamType(uint256 paramType);\\n\\n/**\\n * @notice Too many guard definitions have been passed when creating a vault.\\n */\\nerror TooManyGuards();\\n\\n/**\\n * @notice The guard definition does not have all required inputs\\n */\\nerror IncompleteGuardDefinition();\\n\\n/**\\n * @custom:member VaultAddress Address of the smart vault.\\n * @custom:member Executor In case of deposit, executor of deposit action; in case of withdrawal, executor of redeem action.\\n * @custom:member Receiver Receiver of receipt NFT.\\n * @custom:member Owner In case of deposit, owner of assets; in case of withdrawal, owner of vault shares.\\n * @custom:member Assets Amounts of assets involved.\\n * @custom:member Tokens Addresses of assets involved.\\n * @custom:member AssetGroup Asset group of the smart vault.\\n * @custom:member CustomValue Custom value.\\n * @custom:member DynamicCustomValue Dynamic custom value.\\n */\\nenum GuardParamType {\\n    VaultAddress,\\n    Executor,\\n    Receiver,\\n    Owner,\\n    Assets,\\n    Tokens,\\n    AssetGroup,\\n    CustomValue,\\n    DynamicCustomValue\\n}\\n\\n/**\\n * @custom:member methodSignature Signature of the method to invoke\\n * @custom:member contractAddress Address of the contract to invoke\\n * @custom:member operator The operator to use when comparing expectedValue to guard's function result.\\n * @custom:member expectedValue Value to use when comparing with the guard function result.\\n * - System only supports guards with return values that can be cast to uint256.\\n * @custom:member methodParamTypes Types of parameters that the guard function is expecting.\\n * @custom:member methodParamValues Parameter values that will be passed into the guard function call.\\n * - This array should only include fixed/static values. Parameters that are resolved at runtime should be omitted.\\n * - All values should be encoded using \\\"abi.encode\\\" before passing them to the GuardManager contract.\\n * - We assume that all static types are encoded to 32 bytes. Fixed-size static arrays and structs with only static\\n *      type members are not supported.\\n * - If empty, system will assume the expected value is bool(true).\\n */\\nstruct GuardDefinition {\\n    string methodSignature;\\n    address contractAddress;\\n    bytes2 operator;\\n    uint256 expectedValue;\\n    GuardParamType[] methodParamTypes;\\n    bytes[] methodParamValues;\\n}\\n\\n/**\\n * @custom:member receiver Receiver of receipt NFT.\\n * @custom:member executor In case of deposit, executor of deposit action; in case of withdrawal, executor of redeem action.\\n * @custom:member owner In case of deposit, owner of assets; in case of withdrawal, owner of vault shares.\\n * @custom:member requestType Request type for which the guard is run.\\n * @custom:member assets Amounts of assets involved.\\n * @custom:member tokens Addresses of tokens involved.\\n */\\nstruct RequestContext {\\n    address receiver;\\n    address executor;\\n    address owner;\\n    RequestType requestType;\\n    uint256[] assets;\\n    address[] tokens;\\n}\\n\\ninterface IGuardManager {\\n    /**\\n     * @notice Runs guards for a smart vault.\\n     * @dev Reverts if any guard fails.\\n     * The context.methodParamValues array should only include fixed/static values.\\n     * Parameters that are resolved at runtime should be omitted. All values should be encoded using \\\"abi.encode\\\" before\\n     * passing them to the GuardManager contract. We assume that all static types are encoded to 32 bytes. Fixed-size\\n     * static arrays and structs with only static type members are not supported.\\n     * @param smartVault Smart vault for which to run the guards.\\n     * @param context Context for running the guards.\\n     */\\n    function runGuards(address smartVault, RequestContext calldata context) external view;\\n\\n    /**\\n     * @notice Gets guards for smart vault and request type.\\n     * @param smartVault Smart vault for which to get guards.\\n     * @param requestType Request type for which to get guards.\\n     * @return guards Guards for the smart vault and request type.\\n     */\\n    function readGuards(address smartVault, RequestType requestType)\\n        external\\n        view\\n        returns (GuardDefinition[] memory guards);\\n\\n    /**\\n     * @notice Sets guards for the smart vault.\\n     * @dev\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - guards should not have been already set for the smart vault\\n     * @param smartVault Smart vault for which to set the guards.\\n     * @param guards Guards to set. Grouped by the request types.\\n     * @param requestTypes Request types for groups of guards.\\n     */\\n    function setGuards(address smartVault, GuardDefinition[][] calldata guards, RequestType[] calldata requestTypes)\\n        external;\\n\\n    /**\\n     * @notice Emitted when guards are set for a smart vault.\\n     * @param smartVault Smart vault for which guards were set.\\n     * @param guards Guard definitions\\n     * @param requestTypes Guard triggers\\n     */\\n    event GuardsInitialized(address indexed smartVault, GuardDefinition[][] guards, RequestType[] requestTypes);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMasterWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMasterWallet {\\n    /**\\n     * @notice Transfers amount of token to the recipient.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_MASTER_WALLET_MANAGER\\n     * @param token Token to transfer.\\n     * @param recipient Target of the transfer.\\n     * @param amount Amount to transfer.\\n     */\\n    function transfer(IERC20 token, address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\nerror InvalidRiskInputLength();\\nerror RiskScoreValueOutOfBounds(uint8 value);\\nerror RiskToleranceValueOutOfBounds(int8 value);\\nerror CannotSetRiskScoreForGhostStrategy(uint8 riskScore);\\nerror InvalidAllocationSum(uint256 allocationsSum);\\nerror InvalidRiskScores(address riskProvider, address strategy);\\n\\ninterface IRiskManager {\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Calculates allocation between strategies based on\\n     * - risk scores of strategies\\n     * - risk appetite\\n     * @param smartVault Smart vault address.\\n     * @param strategies Strategies.\\n     * @return allocation Calculated allocation.\\n     */\\n    function calculateAllocation(address smartVault, address[] calldata strategies)\\n        external\\n        view\\n        returns (uint16a16 allocation);\\n\\n    /**\\n     * @notice Gets risk scores for strategies.\\n     * @param riskProvider Requested risk provider.\\n     * @param strategy Strategies.\\n     * @return riskScores Risk scores for strategies.\\n     */\\n    function getRiskScores(address riskProvider, address[] memory strategy)\\n        external\\n        view\\n        returns (uint8[] memory riskScores);\\n\\n    /**\\n     * @notice Gets configured risk provider for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return riskProvider Risk provider for the smart vault.\\n     */\\n    function getRiskProvider(address smartVault) external view returns (address riskProvider);\\n\\n    /**\\n     * @notice Gets configured allocation provider for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return allocationProvider Allocation provider for the smart vault.\\n     */\\n    function getAllocationProvider(address smartVault) external view returns (address allocationProvider);\\n\\n    /**\\n     * @notice Gets configured risk tolerance for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return riskTolerance Risk tolerance for the smart vault.\\n     */\\n    function getRiskTolerance(address smartVault) external view returns (int8 riskTolerance);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Sets risk provider for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - risk provider must have role ROLE_RISK_PROVIDER\\n     * @param smartVault Smart vault.\\n     * @param riskProvider_ Risk provider to set.\\n     */\\n    function setRiskProvider(address smartVault, address riskProvider_) external;\\n\\n    /**\\n     * @notice Sets allocation provider for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - allocation provider must have role ROLE_ALLOCATION_PROVIDER\\n     * @param smartVault Smart vault.\\n     * @param allocationProvider Allocation provider to set.\\n     */\\n    function setAllocationProvider(address smartVault, address allocationProvider) external;\\n\\n    /**\\n     * @notice Sets risk scores for strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_RISK_PROVIDER\\n     * @param riskScores Risk scores to set for strategies.\\n     * @param strategies Strategies for which to set risk scores.\\n     */\\n    function setRiskScores(uint8[] calldata riskScores, address[] calldata strategies) external;\\n\\n    /**\\n     * @notice Sets risk tolerance for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - risk tolerance must be within valid bounds\\n     * @param smartVault Smart vault.\\n     * @param riskTolerance Risk tolerance to set.\\n     */\\n    function setRiskTolerance(address smartVault, int8 riskTolerance) external;\\n\\n    /**\\n     * @notice Risk scores updated\\n     * @param riskProvider risk provider address\\n     * @param strategies strategy addresses\\n     * @param riskScores risk score values\\n     */\\n    event RiskScoresUpdated(address indexed riskProvider, address[] strategies, uint8[] riskScores);\\n\\n    /**\\n     * @notice Smart vault risk provider set\\n     * @param smartVault Smart vault address\\n     * @param riskProvider New risk provider address\\n     */\\n    event RiskProviderSet(address indexed smartVault, address indexed riskProvider);\\n\\n    /**\\n     * @notice Smart vault allocation provider set\\n     * @param smartVault Smart vault address\\n     * @param allocationProvider New allocation provider address\\n     */\\n    event AllocationProviderSet(address indexed smartVault, address indexed allocationProvider);\\n\\n    /**\\n     * @notice Smart vault risk appetite\\n     * @param smartVault Smart vault address\\n     * @param riskTolerance risk appetite value\\n     */\\n    event RiskToleranceSet(address indexed smartVault, int8 riskTolerance);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./RequestType.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when the ID for deposit NFTs overflows.\\n * @dev Should never happen.\\n */\\nerror DepositIdOverflow();\\n\\n/**\\n * @notice Used when the ID for withdrawal NFTs overflows.\\n * @dev Should never happen.\\n */\\nerror WithdrawalIdOverflow();\\n\\n/**\\n * @notice Used when ID does not represent a deposit NFT.\\n * @param depositNftId Invalid ID for deposit NFT.\\n */\\nerror InvalidDepositNftId(uint256 depositNftId);\\n\\n/**\\n * @notice Used when ID does not represent a withdrawal NFT.\\n * @param withdrawalNftId Invalid ID for withdrawal NFT.\\n */\\nerror InvalidWithdrawalNftId(uint256 withdrawalNftId);\\n\\n/**\\n * @notice Used when balance of the NFT is invalid.\\n * @param balance Actual balance of the NFT.\\n */\\nerror InvalidNftBalance(uint256 balance);\\n\\n/**\\n * @notice Used when someone wants to transfer invalid NFT shares amount.\\n * @param transferAmount Amount of shares requested to be transferred.\\n */\\nerror InvalidNftTransferAmount(uint256 transferAmount);\\n\\n/**\\n * @notice Used when user tries to send tokens to himself.\\n */\\nerror SenderEqualsRecipient();\\n\\n/* ========== STRUCTS ========== */\\n\\nstruct DepositMetadata {\\n    uint256[] assets;\\n    uint256 initiated;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Holds metadata detailing the withdrawal behind the NFT.\\n * @custom:member vaultShares Vault shares withdrawn.\\n * @custom:member flushIndex Flush index into which withdrawal is included.\\n */\\nstruct WithdrawalMetadata {\\n    uint256 vaultShares;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Holds all smart vault fee percentages.\\n * @custom:member managementFeePct Management fee of the smart vault.\\n * @custom:member depositFeePct Deposit fee of the smart vault.\\n * @custom:member performanceFeePct Performance fee of the smart vault.\\n */\\nstruct SmartVaultFees {\\n    uint16 managementFeePct;\\n    uint16 depositFeePct;\\n    uint16 performanceFeePct;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISmartVault is IERC20Upgradeable, IERC1155MetadataURIUpgradeable {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Fractional balance of a NFT (0 - NFT_MINTED_SHARES).\\n     * @param account Account to check the balance for.\\n     * @param id ID of the NFT to check.\\n     * @return fractionalBalance Fractional balance of account for the NFT.\\n     */\\n    function balanceOfFractional(address account, uint256 id) external view returns (uint256 fractionalBalance);\\n\\n    /**\\n     * @notice Fractional balance of a NFTs (0 - NFT_MINTED_SHARES).\\n     * @param account Account to check the balance for.\\n     * @param ids IDs of the NFTs to check.\\n     * @return fractionalBalances Fractional balances of account for each requested NFT.\\n     */\\n    function balanceOfFractionalBatch(address account, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory fractionalBalances);\\n    /**\\n     * @notice Gets the asset group used by the smart vault.\\n     * @return id ID of the asset group.\\n     */\\n    function assetGroupId() external view returns (uint256 id);\\n\\n    /**\\n     * @notice Gets the name of the smart vault.\\n     * @return name Name of the vault.\\n     */\\n    function vaultName() external view returns (string memory name);\\n\\n    /**\\n     * @notice Gets metadata for NFTs.\\n     * @param nftIds IDs of NFTs.\\n     * @return metadata Metadata for each requested NFT.\\n     */\\n    function getMetadata(uint256[] calldata nftIds) external view returns (bytes[] memory metadata);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Set a new base URI for ERC1155 metadata.\\n     * @param uri_ new base URI value\\n     */\\n    function setBaseURI(string memory uri_) external;\\n\\n    /**\\n     * @notice Mints smart vault tokens for receiver.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver REceiver of minted tokens.\\n     * @param vaultShares Amount of tokens to mint.\\n     */\\n    function mintVaultShares(address receiver, uint256 vaultShares) external;\\n\\n    /**\\n     * @notice Burns smart vault tokens and releases strategy shares back to strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param owner Address for which to burn the tokens.\\n     * @param vaultShares Amount of tokens to burn.\\n     * @param strategies Strategies for which to release the strategy shares.\\n     * @param shares Amounts of strategy shares to release.\\n     */\\n    function burnVaultShares(\\n        address owner,\\n        uint256 vaultShares,\\n        address[] calldata strategies,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    /**\\n     * @notice Mints a new withdrawal NFT.\\n     * @dev Supply of minted NFT is NFT_MINTED_SHARES (for partial burning).\\n     * Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver Address that will receive the NFT.\\n     * @param metadata Metadata to store for minted NFT.\\n     * @return id ID of the minted NFT.\\n     */\\n    function mintWithdrawalNFT(address receiver, WithdrawalMetadata calldata metadata) external returns (uint256 id);\\n\\n    /**\\n     * @notice Mints a new deposit NFT.\\n     * @dev Supply of minted NFT is NFT_MINTED_SHARES (for partial burning).\\n     * Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver Address that will receive the NFT.\\n     * @param metadata Metadata to store for minted NFT.\\n     * @return id ID of the minted NFT.\\n     */\\n    function mintDepositNFT(address receiver, DepositMetadata calldata metadata) external returns (uint256 id);\\n\\n    /**\\n     * @notice Burns NFTs and returns their metadata.\\n     * Allows for partial burning.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param owner Owner of NFTs to burn.\\n     * @param nftIds IDs of NFTs to burn.\\n     * @param nftAmounts NFT shares to burn (partial burn).\\n     * @return metadata Metadata for each burned NFT.\\n     */\\n    function burnNFTs(address owner, uint256[] calldata nftIds, uint256[] calldata nftAmounts)\\n        external\\n        returns (bytes[] memory metadata);\\n\\n    /**\\n     * @notice Transfers smart vault tokens.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param from Spender and owner of tokens.\\n     * @param to Address to which tokens will be transferred.\\n     * @param amount Amount of tokens to transfer.\\n     * @return success True if transfer was successful.\\n     */\\n    function transferFromSpender(address from, address to, uint256 amount) external returns (bool success);\\n\\n    /**\\n     * @notice Transfers unclaimed shares to claimer.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param claimer Address that claims the shares.\\n     * @param amount Amount of shares to transfer.\\n     */\\n    function claimShares(address claimer, uint256 amount) external;\\n\\n    /// @notice Emitted when base URI is changed.\\n    event BaseURIChanged(string baseUri);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISmartVaultManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./IDepositManager.sol\\\";\\nimport \\\"./ISmartVault.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IWithdrawalManager.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when user has insufficient balance for redeemal of shares.\\n */\\nerror InsufficientBalance(uint256 available, uint256 required);\\n\\n/**\\n * @notice Used when there is nothing to flush.\\n */\\nerror NothingToFlush();\\n\\n/**\\n * @notice Used when trying to register a smart vault that was already registered.\\n */\\nerror SmartVaultAlreadyRegistered();\\n\\n/**\\n * @notice Used when trying to perform an action for smart vault that was not registered yet.\\n */\\nerror SmartVaultNotRegisteredYet();\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large management fee.\\n */\\nerror ManagementFeeTooLarge(uint256 mgmtFeePct);\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large performance fee.\\n */\\nerror PerformanceFeeTooLarge(uint256 performanceFeePct);\\n\\n/**\\n * @notice Used when smart vault in reallocation has statically set allocation.\\n */\\nerror StaticAllocationSmartVault();\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large deposit fee.\\n */\\nerror DepositFeeTooLarge(uint256 depositFeePct);\\n\\n/**\\n * @notice Used when user tries redeem on behalf of another user, but the vault does not support it\\n */\\nerror RedeemForNotAllowed();\\n\\n/**\\n * @notice Used when trying to flush a vault that still needs to be synced.\\n */\\nerror VaultNotSynced();\\n\\n/**\\n * @notice Used when trying to deposit into, redeem from, or flush a smart vault that has only ghost strategies.\\n */\\nerror GhostVault();\\n\\n/**\\n * @notice Used when reallocation is called with expired parameters.\\n */\\nerror ReallocationParametersExpired();\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Struct holding all data for registration of smart vault.\\n * @custom:member assetGroupId Underlying asset group of the smart vault.\\n * @custom:member strategies Strategies used by the smart vault.\\n * @custom:member strategyAllocation Optional. If empty array, values will be calculated on the spot.\\n * @custom:member managementFeePct Management fee of the smart vault.\\n * @custom:member depositFeePct Deposit fee of the smart vault.\\n * @custom:member performanceFeePct Performance fee of the smart vault.\\n */\\nstruct SmartVaultRegistrationForm {\\n    uint256 assetGroupId;\\n    address[] strategies;\\n    uint16a16 strategyAllocation;\\n    uint16 managementFeePct;\\n    uint16 depositFeePct;\\n    uint16 performanceFeePct;\\n}\\n\\n/**\\n * @notice Parameters for reallocation.\\n * @custom:member smartVaults Smart vaults to reallocate.\\n * @custom:member strategies Set of strategies involved in the reallocation. Should not include ghost strategy, even if some smart vault uses it.\\n * @custom:member swapInfo Information for swapping assets before depositing into the protocol.\\n * @custom:member depositSlippages Slippages used to constrain depositing into the protocol.\\n * @custom:member withdrawalSlippages Slippages used to contrain withdrawal from the protocol.\\n * @custom:member exchangeRateSlippages Slippages used to constratrain exchange rates for asset tokens.\\n * @custom:member validUntil Sets the maximum timestamp the user is willing to wait to start executing reallocation.\\n */\\nstruct ReallocateParamBag {\\n    address[] smartVaults;\\n    address[] strategies;\\n    SwapInfo[][] swapInfo;\\n    uint256[][] depositSlippages;\\n    uint256[][] withdrawalSlippages;\\n    uint256[2][] exchangeRateSlippages;\\n    uint256 validUntil;\\n}\\n\\nstruct FlushIndex {\\n    uint128 current;\\n    uint128 toSync;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISmartVaultRegistry {\\n    /**\\n     * @notice Registers smart vault into the Spool protocol.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * @param smartVault Smart vault to register.\\n     * @param registrationForm Form with information for registration.\\n     */\\n    function registerSmartVault(address smartVault, SmartVaultRegistrationForm calldata registrationForm) external;\\n}\\n\\ninterface ISmartVaultManager is ISmartVaultRegistry {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets do-hard-work indexes.\\n     * @param smartVault Smart vault.\\n     * @param flushIndex Flush index.\\n     * @return dhwIndexes Do-hard-work indexes for flush index of the smart vault.\\n     */\\n    function dhwIndexes(address smartVault, uint256 flushIndex) external view returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Gets latest flush index for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return flushIndex Latest flush index for the smart vault.\\n     */\\n    function getLatestFlushIndex(address smartVault) external view returns (uint256 flushIndex);\\n\\n    /**\\n     * @notice Gets strategy allocation for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return allocation Strategy allocation for the smart vault.\\n     */\\n    function allocations(address smartVault) external view returns (uint16a16 allocation);\\n\\n    /**\\n     * @notice Gets strategies used by a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return strategies Strategies for the smart vault.\\n     */\\n    function strategies(address smartVault) external view returns (address[] memory strategies);\\n\\n    /**\\n     * @notice Gets asest group used by a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return assetGroupId ID of the asset group used by the smart vault.\\n     */\\n    function assetGroupId(address smartVault) external view returns (uint256 assetGroupId);\\n\\n    /**\\n     * @notice Gets required deposit ratio for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return ratio Required deposit ratio for the smart vault.\\n     */\\n    function depositRatio(address smartVault) external view returns (uint256[] memory ratio);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Flushes deposits and withdrawal for the next do-hard-work.\\n     * @param smartVault Smart vault to flush.\\n     */\\n    function flushSmartVault(address smartVault) external;\\n\\n    /**\\n     * @notice Reallocates smart vaults.\\n     * @dev Requirements:\\n     * - caller must have a ROLE_REALLOCATOR role\\n     * - smart vaults must be registered\\n     * - smart vaults must use same asset group\\n     * - strategies must represent a set of strategies used by smart vaults\\n     * @param reallocateParams Paramaters for reallocation.\\n     */\\n    function reallocate(ReallocateParamBag calldata reallocateParams) external;\\n\\n    /**\\n     * @notice Removes strategy from vaults, and optionally removes it from the system as well.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * - the strategy has to be active (requires ROLE_STRATEGY)\\n     * @param strategy Strategy address to remove.\\n     * @param vaults Array of vaults from which to remove the strategy\\n     * @param disableStrategy Also disable the strategy across the system\\n     */\\n    function removeStrategyFromVaults(address strategy, address[] calldata vaults, bool disableStrategy) external;\\n\\n    /**\\n     * @notice Syncs smart vault with strategies.\\n     * @param smartVault Smart vault to sync.\\n     * @param revertIfError If true, sync will revert if every flush index cannot be synced; if false it will sync all flush indexes it can.\\n     */\\n    function syncSmartVault(address smartVault, bool revertIfError) external;\\n\\n    /**\\n     * @dev Calculate number of SVTs that haven't been synced yet after DHW runs\\n     * DHW has minted strategy shares, but vaults haven't claimed them yet.\\n     * Includes management fees (percentage of assets under management, distributed throughout a year) and deposit fees .\\n     * Invariants:\\n     * - There can't be more than once un-synced flush index per vault at any given time.\\n     * - Flush index can't be synced, if all DHWs haven't been completed yet.\\n     *\\n     * Can be used to retrieve the number of SSTs the vault would claim during sync.\\n     * @param smartVault SmartVault address\\n     * @return oldTotalSVTs Amount of SVTs before sync\\n     * @return mintedSVTs Amount of SVTs minted during sync\\n     * @return feeSVTs Amount of SVTs pertaining to fees\\n     * @return sstShares Amount of SSTs claimed per strategy\\n     */\\n    function simulateSync(address smartVault)\\n        external\\n        view\\n        returns (uint256 oldTotalSVTs, uint256 mintedSVTs, uint256 feeSVTs, uint256[] calldata sstShares);\\n\\n    /**\\n     * @dev Simulate sync when burning dNFTs and return their svts value.\\n     *\\n     * @param smartVault SmartVault address\\n     * @param userAddress User address that owns dNFTs\\n     * @param nftIds Ids of dNFTs\\n     * @return svts Amount of svts user would get if he burns dNFTs\\n     */\\n    function simulateSyncWithBurn(address smartVault, address userAddress, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256 svts);\\n\\n    /**\\n     * @notice Instantly redeems smart vault shares for assets.\\n     * @param bag Parameters for fast redeemal.\\n     * @param withdrawalSlippages Slippages guarding redeemal.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemBag calldata bag, uint256[][] calldata withdrawalSlippages)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Simulates redeem fast of smart vault shares.\\n     * @dev Should only be run by address zero to simulate the redeemal and parse logs.\\n     * @param bag Parameters for fast redeemal.\\n     * @param withdrawalSlippages Slippages guarding redeemal.\\n     * @param redeemer Address of a user to simulate redeem for.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFastView(RedeemBag calldata bag, uint256[][] calldata withdrawalSlippages, address redeemer)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Claims withdrawal of assets by burning withdrawal NFT.\\n     * @dev Requirements:\\n     * - withdrawal NFT must be valid\\n     * @param smartVault Address of the smart vault that issued the withdrawal NFT.\\n     * @param nftIds ID of withdrawal NFT to burn.\\n     * @param nftAmounts amounts\\n     * @param receiver Receiver of claimed assets.\\n     * @return assetAmounts Amounts of assets claimed.\\n     * @return assetGroupId ID of the asset group.\\n     */\\n    function claimWithdrawal(\\n        address smartVault,\\n        uint256[] calldata nftIds,\\n        uint256[] calldata nftAmounts,\\n        address receiver\\n    ) external returns (uint256[] memory assetAmounts, uint256 assetGroupId);\\n\\n    /**\\n     * @notice Claims smart vault tokens by burning the deposit NFT.\\n     * @dev Requirements:\\n     * - deposit NFT must be valid\\n     * - flush must be synced\\n     * @param smartVaultAddress Address of the smart vault that issued the deposit NFT.\\n     * @param nftIds ID of the deposit NFT to burn.\\n     * @param nftAmounts amounts\\n     * @return claimedAmount Amount of smart vault tokens claimed.\\n     */\\n    function claimSmartVaultTokens(address smartVaultAddress, uint256[] calldata nftIds, uint256[] calldata nftAmounts)\\n        external\\n        returns (uint256 claimedAmount);\\n\\n    /**\\n     * @notice Initiates a withdrawal process and mints a withdrawal NFT. Once all DHWs are executed, user can\\n     * use the withdrawal NFT to claim the assets.\\n     * Optionally, caller can pass a list of deposit NFTs to unwrap.\\n     * @param bag smart vault address, amount of shares to redeem, nft ids and amounts to burn\\n     * @param receiver address that will receive the withdrawal NFT\\n     * @param doFlush optionally flush the smart vault\\n     * @return receipt ID of the receipt withdrawal NFT.\\n     */\\n    function redeem(RedeemBag calldata bag, address receiver, bool doFlush) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Initiates a withdrawal process and mints a withdrawal NFT. Once all DHWs are executed, user can\\n     * use the withdrawal NFT to claim the assets.\\n     * Optionally, caller can pass a list of deposit NFTs to unwrap.\\n     * @param bag smart vault address, amount of shares to redeem, nft ids and amounts to burn\\n     * @param owner address that owns the shares to be redeemed and will receive the withdrawal NFT\\n     * @param doFlush optionally flush the smart vault\\n     * @return receipt ID of the receipt withdrawal NFT.\\n     */\\n    function redeemFor(RedeemBag calldata bag, address owner, bool doFlush) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Initiated a deposit and mints a deposit NFT. Once all DHWs are executed, user can\\n     * unwrap the deposit NDF and claim his SVTs.\\n     * @param bag smartVault address, assets, NFT receiver address, referral address, doFlush\\n     * @return receipt ID of the receipt deposit NFT.\\n     */\\n    function deposit(DepositBag calldata bag) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Recovers pending deposits from smart vault to emergency wallet.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * - all strategies of the smart vault need to be ghost strategies\\n     * @param smartVault Smart vault from which to recover pending deposits.\\n     */\\n    function recoverPendingDeposits(address smartVault) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Smart vault has been flushed\\n     * @param smartVault Smart vault address\\n     * @param flushIndex Flush index\\n     */\\n    event SmartVaultFlushed(address indexed smartVault, uint256 flushIndex);\\n\\n    /**\\n     * @notice Smart vault has been synced\\n     * @param smartVault Smart vault address\\n     * @param flushIndex Flush index\\n     */\\n    event SmartVaultSynced(address indexed smartVault, uint256 flushIndex);\\n\\n    /**\\n     * @notice Smart vault has been registered\\n     * @param smartVault Smart vault address\\n     * @param registrationForm Smart vault configuration\\n     */\\n    event SmartVaultRegistered(address indexed smartVault, SmartVaultRegistrationForm registrationForm);\\n\\n    /**\\n     * @notice Strategy was removed from the vault\\n     * @param strategy Strategy address\\n     * @param vault Vault to remove the strategy from\\n     */\\n    event StrategyRemovedFromVault(address indexed strategy, address indexed vault);\\n\\n    /**\\n     * @notice Vault was reallocation executed\\n     * @param smartVault Smart vault address\\n     * @param newAllocations new vault strategy allocations\\n     */\\n    event SmartVaultReallocated(address indexed smartVault, uint16a16 newAllocations);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {PlatformFees} from \\\"./IStrategyRegistry.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IUsdPriceFeedManager.sol\\\";\\n\\n/**\\n * @notice Struct holding information how to swap the assets.\\n * @custom:member slippage minumum output amount\\n * @custom:member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\n */\\nstruct SwapData {\\n    uint256 slippage; // min amount out\\n    bytes path; // 1st byte is action, then path\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work on strategy.\\n * @custom:member swapInfo Information for swapping assets before depositing into the protocol.\\n * @custom:member swapInfo Information for swapping rewards before depositing them back into the protocol.\\n * @custom:member slippages Slippages used to constrain depositing and withdrawing from the protocol.\\n * @custom:member assetGroup Asset group of the strategy.\\n * @custom:member exchangeRates Exchange rates for assets.\\n * @custom:member withdrawnShares Strategy shares withdrawn by smart vault.\\n * @custom:member masterWallet Master wallet.\\n * @custom:member priceFeedManager Price feed manager.\\n * @custom:member baseYield Base yield value, manual input for specific strategies.\\n * @custom:member platformFees Platform fees info.\\n */\\nstruct StrategyDhwParameterBag {\\n    SwapInfo[] swapInfo;\\n    SwapInfo[] compoundSwapInfo;\\n    uint256[] slippages;\\n    address[] assetGroup;\\n    uint256[] exchangeRates;\\n    uint256 withdrawnShares;\\n    address masterWallet;\\n    IUsdPriceFeedManager priceFeedManager;\\n    int256 baseYield;\\n    PlatformFees platformFees;\\n}\\n\\n/**\\n * @notice Information about results of the do hard work.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member assetsWithdrawn Amount of assets withdrawn.\\n * @custom:member yieldPercentage Yield percentage from the previous DHW.\\n * @custom:member valueAtDhw Value of the strategy at the end of DHW.\\n * @custom:member totalSstsAtDhw Total SSTs at the end of DHW.\\n */\\nstruct DhwInfo {\\n    uint256 sharesMinted;\\n    uint256[] assetsWithdrawn;\\n    int256 yieldPercentage;\\n    uint256 valueAtDhw;\\n    uint256 totalSstsAtDhw;\\n}\\n\\n/**\\n * @notice Used when ghost strategy is called.\\n */\\nerror IsGhostStrategy();\\n\\n/**\\n * @notice Used when user is not allowed to redeem fast.\\n * @param user User that tried to redeem fast.\\n */\\nerror NotFastRedeemer(address user);\\n\\n/**\\n * @notice Used when asset group ID is not correctly initialized.\\n */\\nerror InvalidAssetGroupIdInitialization();\\n\\ninterface IStrategy is IERC20Upgradeable {\\n    /* ========== EVENTS ========== */\\n\\n    event Deposited(\\n        uint256 mintedShares, uint256 usdWorthDeposited, uint256[] assetsBeforeSwap, uint256[] assetsDeposited\\n    );\\n\\n    event Withdrawn(uint256 withdrawnShares, uint256 usdWorthWithdrawn, uint256[] withdrawnAssets);\\n\\n    event PlatformFeesCollected(address indexed strategy, uint256 sharesMinted);\\n\\n    event Slippages(bool isDeposit, uint256 slippage, bytes data);\\n\\n    event BeforeDepositCheckSlippages(uint256[] amounts);\\n\\n    event BeforeRedeemalCheckSlippages(uint256 ssts);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets strategy name.\\n     * @return name Name of the strategy.\\n     */\\n    function strategyName() external view returns (string memory name);\\n\\n    /**\\n     * @notice Gets required ratio between underlying assets.\\n     * @return ratio Required asset ratio for the strategy.\\n     */\\n    function assetRatio() external view returns (uint256[] memory ratio);\\n\\n    /**\\n     * @notice Gets asset group used by the strategy.\\n     * @return id ID of the asset group.\\n     */\\n    function assetGroupId() external view returns (uint256 id);\\n\\n    /**\\n     * @notice Gets underlying assets for the strategy.\\n     * @return assets Addresses of the underlying assets.\\n     */\\n    function assets() external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets underlying asset amounts for the strategy.\\n     * @return amounts Amounts of the underlying assets.\\n     */\\n    function getUnderlyingAssetAmounts() external view returns (uint256[] memory amounts);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Performs slippages check before depositing.\\n     * @param amounts Amounts to be deposited.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeDepositCheck(uint256[] memory amounts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @dev Performs slippages check before redeemal.\\n     * @param ssts Amount of strategy tokens to be redeemed.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeRedeemalCheck(uint256 ssts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @notice Does hard work:\\n     * - compounds rewards\\n     * - deposits into the protocol\\n     * - withdraws from the protocol\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param dhwParams Parameters for the do hard work.\\n     * @return info Information about do the performed hard work.\\n     */\\n    function doHardWork(StrategyDhwParameterBag calldata dhwParams) external returns (DhwInfo memory info);\\n\\n    /**\\n     * @notice Claims strategy shares after do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault claiming shares.\\n     * @param amount Amount of strategy shares to claim.\\n     */\\n    function claimShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Releases shares back to strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault releasing shares.\\n     * @param amount Amount of strategy shares to release.\\n     */\\n    function releaseShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SMART_VAULT_MANAGER or role ROLE_STRATEGY_REGISTRY\\n     * @param shares Amount of shares to redeem.\\n     * @param masterWallet Address of the master wallet.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemFast(\\n        uint256 shares,\\n        address masterWallet,\\n        address[] calldata assetGroup,\\n        uint256[] calldata slippages\\n    ) external returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @param shares Amount of shares to redeem.\\n     * @param redeemer Address of he redeemer, owner of SSTs.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemShares(uint256 shares, address redeemer, address[] calldata assetGroup, uint256[] calldata slippages)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly deposits into the protocol.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param assetGroup Asset group of the strategy.\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     * @param slippages Slippages to guard depositing.\\n     * @param swapInfo Information for swapping assets before depositing into the protocol.\\n     * @return sstsMinted Amount of SSTs minted.\\n     */\\n    function depositFast(\\n        address[] calldata assetGroup,\\n        uint256[] calldata exchangeRates,\\n        IUsdPriceFeedManager priceFeedManager,\\n        uint256[] calldata slippages,\\n        SwapInfo[] calldata swapInfo\\n    ) external returns (uint256 sstsMinted);\\n\\n    /**\\n     * @notice Instantly withdraws assets, bypassing shares mechanism.\\n     * Transfers withdrawn assets to the emergency withdrawal wallet.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param slippages Slippages to guard redeeming.\\n     * @param recipient Recipient address\\n     */\\n    function emergencyWithdraw(uint256[] calldata slippages, address recipient) external;\\n\\n    /**\\n     * @notice Gets USD worth of the strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     */\\n    function getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        external\\n        returns (uint256 usdWorth);\\n\\n    /**\\n     * @notice Gets protocol rewards.\\n     * @dev Requirements:\\n     * - can only be called in view-execution mode.\\n     * @return tokens Addresses of reward tokens.\\n     * @return amounts Amount of reward tokens available.\\n     */\\n    function getProtocolRewards() external returns (address[] memory tokens, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISwapper.sol\\\";\\nimport {DhwInfo} from \\\"./IStrategy.sol\\\";\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to register an already registered strategy.\\n * @param address_ Address of already registered strategy.\\n */\\nerror StrategyAlreadyRegistered(address address_);\\n\\n/**\\n * @notice Used when DHW was not run yet for a strategy index.\\n * @param strategy Address of the strategy.\\n * @param strategyIndex Index of the strategy.\\n */\\nerror DhwNotRunYetForIndex(address strategy, uint256 strategyIndex);\\n\\n/**\\n * @notice Used when provided token list is invalid.\\n */\\nerror InvalidTokenList();\\n\\n/**\\n * @notice Used when ghost strategy is used.\\n */\\nerror GhostStrategyUsed();\\n\\n/**\\n * @notice Used when syncing vault that is already fully synced.\\n */\\nerror NothingToSync();\\n\\n/**\\n * @notice Used when system tries to configure a too large ecosystem fee.\\n * @param ecosystemFeePct Requested ecosystem fee.\\n */\\nerror EcosystemFeeTooLarge(uint256 ecosystemFeePct);\\n\\n/**\\n * @notice Used when system tries to configure a too large treasury fee.\\n * @param treasuryFeePct Requested treasury fee.\\n */\\nerror TreasuryFeeTooLarge(uint256 treasuryFeePct);\\n\\n/**\\n * @notice Used when user tries to re-add a strategy that was previously removed from the system.\\n * @param strategy Strategy address\\n */\\nerror StrategyPreviouslyRemoved(address strategy);\\n\\n/**\\n * @notice Represents change of state for a strategy during a DHW.\\n * @custom:member exchangeRates Exchange rates between assets and USD.\\n * @custom:member assetsDeposited Amount of assets deposited into the strategy.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member totalSSTs Amount of strategy shares at the end of the DHW.\\n * @custom:member totalStrategyValue Total strategy value at the end of the DHW.\\n * @custom:member dhwYields DHW yield percentage from the previous DHW.\\n */\\nstruct StrategyAtIndex {\\n    uint256[] exchangeRates;\\n    uint256[] assetsDeposited;\\n    uint256 sharesMinted;\\n    uint256 totalSSTs;\\n    uint256 totalStrategyValue;\\n    int256 dhwYields;\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work.\\n * @custom:member strategies Strategies to do-hard-worked upon, grouped by their asset group.\\n * @custom:member swapInfo Information for swapping assets before depositing into protocol. SwapInfo[] per each strategy.\\n * @custom:member compoundSwapInfo Information for swapping rewards before depositing them back into the protocol. SwapInfo[] per each strategy.\\n * @custom:member strategySlippages Slippages used to constrain depositing into and withdrawing from the protocol. uint256[] per strategy.\\n * @custom:member baseYields Base yield percentage the strategy created in the DHW period (applicable only for some strategies).\\n * @custom:member tokens List of all asset tokens involved in the do hard work.\\n * @custom:member exchangeRateSlippages Slippages used to constrain exchange rates for asset tokens. uint256[2] for each token.\\n * @custom:member validUntil Sets the maximum timestamp the user is willing to wait to start executing 'do hard work'.\\n */\\nstruct DoHardWorkParameterBag {\\n    address[][] strategies;\\n    SwapInfo[][][] swapInfo;\\n    SwapInfo[][][] compoundSwapInfo;\\n    uint256[][][] strategySlippages;\\n    int256[][] baseYields;\\n    address[] tokens;\\n    uint256[2][] exchangeRateSlippages;\\n    uint256 validUntil;\\n}\\n\\n/**\\n * @notice Parameters for calling redeem fast.\\n * @custom:member strategies Addresses of strategies.\\n * @custom:member strategyShares Amount of shares to redeem.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member slippages Slippages to guard withdrawal.\\n */\\nstruct RedeemFastParameterBag {\\n    address[] strategies;\\n    uint256[] strategyShares;\\n    address[] assetGroup;\\n    uint256[][] withdrawalSlippages;\\n}\\n\\n/**\\n * @notice Group of platform fees.\\n * @custom:member ecosystemFeeReciever Receiver of the ecosystem fees.\\n * @custom:member ecosystemFeePct Ecosystem fees. Expressed in FULL_PERCENT.\\n * @custom:member treasuryFeeReciever Receiver of the treasury fees.\\n * @custom:member treasuryFeePct Treasury fees. Expressed in FULL_PERCENT.\\n */\\nstruct PlatformFees {\\n    address ecosystemFeeReceiver;\\n    uint96 ecosystemFeePct;\\n    address treasuryFeeReceiver;\\n    uint96 treasuryFeePct;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IStrategyRegistry {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Returns address of emergency withdrawal wallet.\\n     * @return emergencyWithdrawalWallet Address of the emergency withdrawal wallet.\\n     */\\n    function emergencyWithdrawalWallet() external view returns (address emergencyWithdrawalWallet);\\n\\n    /**\\n     * @notice Returns current do-hard-work indexes for strategies.\\n     * @param strategies Strategies.\\n     * @return dhwIndexes Current do-hard-work indexes for strategies.\\n     */\\n    function currentIndex(address[] calldata strategies) external view returns (uint256[] memory dhwIndexes);\\n\\n    /**\\n     * @notice Returns current strategy APYs.\\n     * @param strategies Strategies.\\n     */\\n    function strategyAPYs(address[] calldata strategies) external view returns (int256[] memory apys);\\n\\n    /**\\n     * @notice Returns assets deposited into a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return assets Assets deposited into the do-hard-work index for the strategy.\\n     */\\n    function depositedAssets(address strategy, uint256 dhwIndex) external view returns (uint256[] memory assets);\\n\\n    /**\\n     * @notice Returns shares redeemed in a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return shares Shares redeemed in a do-hard-work index for the strategy.\\n     */\\n    function sharesRedeemed(address strategy, uint256 dhwIndex) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Gets timestamps when do-hard-works were performed.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return timestamps Timestamp for each pair of strategies and do-hard-work indexes.\\n     */\\n    function dhwTimestamps(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (uint256[] memory timestamps);\\n\\n    function getDhwYield(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (int256[] memory yields);\\n\\n    /**\\n     * @notice Returns state of strategies at do-hard-work indexes.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return states State of each strategy at corresponding do-hard-work index.\\n     */\\n    function strategyAtIndexBatch(address[] calldata strategies, uint16a16 dhwIndexes, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (StrategyAtIndex[] memory states);\\n\\n    /**\\n     * @notice Gets required asset ratio for strategy at last DHW.\\n     * @param strategy Address of the strategy.\\n     * @return assetRatio Asset ratio.\\n     */\\n    function assetRatioAtLastDhw(address strategy) external view returns (uint256[] memory assetRatio);\\n\\n    /**\\n     * @notice Gets set platform fees.\\n     * @return fees Set platform fees.\\n     */\\n    function platformFees() external view returns (PlatformFees memory fees);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Registers a strategy into the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param strategy Address of strategy to register.\\n     * @param apy Apy of the strategy at the time of the registration.\\n     */\\n    function registerStrategy(address strategy, int256 apy) external;\\n\\n    /**\\n     * @notice Removes strategy from the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategy Strategy to remove.\\n     */\\n    function removeStrategy(address strategy) external;\\n\\n    /**\\n     * @notice Sets ecosystem fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeePct Ecosystem fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setEcosystemFee(uint96 ecosystemFeePct) external;\\n\\n    /**\\n     * @notice Sets receiver of the ecosystem fees.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeeReceiver Receiver to set.\\n     */\\n    function setEcosystemFeeReceiver(address ecosystemFeeReceiver) external;\\n\\n    /**\\n     * @notice Sets treasury fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeePct Treasury fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setTreasuryFee(uint96 treasuryFeePct) external;\\n\\n    /**\\n     * @notice Sets treasury fee receiver.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeeReceiver Receiver to set.\\n     */\\n    function setTreasuryFeeReceiver(address treasuryFeeReceiver) external;\\n\\n    /**\\n     * @notice Does hard work on multiple strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_DO_HARD_WORKER\\n     * @param dhwParams Parameters for do hard work.\\n     */\\n    function doHardWork(DoHardWorkParameterBag calldata dhwParams) external;\\n\\n    /**\\n     * @notice Adds deposits to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add deposit.\\n     * @param amounts Amounts of assets to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addDeposits(address[] calldata strategies, uint256[][] calldata amounts)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Adds withdrawals to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add withdrawal.\\n     * @param strategyShares Amounts of strategy shares to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addWithdrawals(address[] calldata strategies, uint256[] calldata strategyShares)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param redeemFastParams Parameters for fast redeem.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemFastParameterBag calldata redeemFastParams)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Claims withdrawals from the strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * - DHWs must be run for withdrawal indexes.\\n     * @param strategies Addresses if strategies from which to claim withdrawal.\\n     * @param dhwIndexes Indexes of strategies when withdrawal was made.\\n     * @param strategyShares Amount of strategy shares that was withdrawn.\\n     * @return assetsWithdrawn Amount of assets withdrawn from strategies.\\n     */\\n    function claimWithdrawals(address[] calldata strategies, uint16a16 dhwIndexes, uint256[] calldata strategyShares)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Redeems strategy shares.\\n     * Used by recipients of platform fees.\\n     * @param strategies Strategies from which to redeem.\\n     * @param shares Amount of shares to redeem from each strategy.\\n     * @param withdrawalSlippages Slippages to guard redeemal process.\\n     */\\n    function redeemStrategyShares(\\n        address[] calldata strategies,\\n        uint256[] calldata shares,\\n        uint256[][] calldata withdrawalSlippages\\n    ) external;\\n\\n    /**\\n     * @notice Strategy was registered\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRegistered(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy was removed\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRemoved(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy DHW was executed\\n     * @param strategy Strategy address\\n     * @param dhwIndex DHW index\\n     * @param dhwInfo DHW info\\n     */\\n    event StrategyDhw(address indexed strategy, uint256 dhwIndex, DhwInfo dhwInfo);\\n\\n    /**\\n     * @notice Ecosystem fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event EcosystemFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Ecosystem fee receiver was changed\\n     * @param ecosystemFeeReceiver Receiver address\\n     */\\n    event EcosystemFeeReceiverSet(address indexed ecosystemFeeReceiver);\\n\\n    /**\\n     * @notice Treasury fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event TreasuryFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Treasury fee receiver was changed\\n     * @param treasuryFeeReceiver Receiver address\\n     */\\n    event TreasuryFeeReceiverSet(address indexed treasuryFeeReceiver);\\n\\n    /**\\n     * @notice Emergency withdrawal wallet changed\\n     * @param wallet Emergency withdrawal wallet address\\n     */\\n    event EmergencyWithdrawalWalletSet(address indexed wallet);\\n\\n    /**\\n     * @notice Strategy shares have been redeemed\\n     * @param strategy Strategy address\\n     * @param owner Address that owns the shares\\n     * @param recipient Address that received the withdrawn funds\\n     * @param shares Amount of shares that were redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesRedeemed(\\n        address indexed strategy,\\n        address indexed owner,\\n        address indexed recipient,\\n        uint256 shares,\\n        uint256[] assetsWithdrawn\\n    );\\n\\n    /**\\n     * @notice Strategy shares were fast redeemed\\n     * @param strategy Strategy address\\n     * @param shares Amount of shares redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesFastRedeemed(address indexed strategy, uint256 shares, uint256[] assetsWithdrawn);\\n\\n    /**\\n     * @notice Strategy APY value was updated\\n     * @param strategy Strategy address\\n     * @param apy New APY value\\n     */\\n    event StrategyApyUpdated(address indexed strategy, int256 apy);\\n}\\n\\ninterface IEmergencyWithdrawal {\\n    /**\\n     * @notice Emitted when a strategy is emergency withdrawn from.\\n     * @param strategy Strategy that was emergency withdrawn from.\\n     */\\n    event StrategyEmergencyWithdrawn(address indexed strategy);\\n\\n    /**\\n     * @notice Set a new address that will receive assets withdrawn if emergency withdrawal is executed.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param wallet Address to set as the emergency withdrawal wallet.\\n     */\\n    function setEmergencyWithdrawalWallet(address wallet) external;\\n\\n    /**\\n     * @notice Instantly withdraws assets from a strategy, bypassing shares mechanism.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR\\n     * @param strategies Addresses of strategies.\\n     * @param withdrawalSlippages Slippages to guard withdrawal.\\n     * @param removeStrategies Whether to remove strategies from the system after withdrawal.\\n     */\\n    function emergencyWithdraw(\\n        address[] calldata strategies,\\n        uint256[][] calldata withdrawalSlippages,\\n        bool removeStrategies\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUsdPriceFeedManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of decimals used for USD values.\\nuint256 constant USD_DECIMALS = 18;\\n\\n/**\\n * @notice Emitted when asset is invalid.\\n * @param asset Invalid asset.\\n */\\nerror InvalidAsset(address asset);\\n\\n/**\\n * @notice Emitted when price returned by price aggregator is negative or zero.\\n * @param price Actual price returned by price aggregator.\\n */\\nerror NonPositivePrice(int256 price);\\n\\n/**\\n * @notice Emitted when pricing data returned by price aggregator is not from the current\\n * round or the round hasn't finished.\\n */\\nerror StalePriceData();\\n\\ninterface IUsdPriceFeedManager {\\n    /**\\n     * @notice Gets number of decimals for an asset.\\n     * @param asset Address of the asset.\\n     * @return assetDecimals Number of decimals for the asset.\\n     */\\n    function assetDecimals(address asset) external view returns (uint256 assetDecimals);\\n\\n    /**\\n     * @notice Gets number of decimals for USD.\\n     * @return usdDecimals Number of decimals for USD.\\n     */\\n    function usdDecimals() external view returns (uint256 usdDecimals);\\n\\n    /**\\n     * @notice Calculates asset value in USD using current price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsd(address asset, uint256 assetAmount) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using current price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAsset(address asset, uint256 usdAmount) external view returns (uint256 assetValue);\\n\\n    /**\\n     * @notice Calculates asset value in USD using provided price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @param price Price of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPrice(address asset, uint256 assetAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates assets value in USD using provided prices.\\n     * @param assets Addresses of assets.\\n     * @param assetAmounts Amounts of assets in asset decimals.\\n     * @param prices Prices of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPriceBulk(\\n        address[] calldata assets,\\n        uint256[] calldata assetAmounts,\\n        uint256[] calldata prices\\n    ) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using provided price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @param price Price of asset in USD.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAssetCustomPrice(address asset, uint256 usdAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 assetValue);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of seconds in an average year.\\nuint256 constant SECONDS_IN_YEAR = 31_556_926;\\n\\n/// @dev Number of seconds in an average year.\\nint256 constant SECONDS_IN_YEAR_INT = 31_556_926;\\n\\n/// @dev Represents 100%.\\nuint256 constant FULL_PERCENT = 100_00;\\n\\n/// @dev Represents 100%.\\nint256 constant FULL_PERCENT_INT = 100_00;\\n\\n/// @dev Represents 100% for yield.\\nint256 constant YIELD_FULL_PERCENT_INT = 10 ** 12;\\n\\n/// @dev Represents 100% for yield.\\nuint256 constant YIELD_FULL_PERCENT = uint256(YIELD_FULL_PERCENT_INT);\\n\\n/// @dev Maximal management fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant MANAGEMENT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal deposit fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant DEPOSIT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal smart vault performance fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant SV_PERFORMANCE_FEE_MAX = 20_00;\\n\\n/// @dev Maximal ecosystem fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant ECOSYSTEM_FEE_MAX = 20_00;\\n\\n/// @dev Maximal treasury fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant TREASURY_FEE_MAX = 10_00;\\n\\n/// @dev Maximal risk score a strategy can be assigned.\\nuint8 constant MAX_RISK_SCORE = 10_0;\\n\\n/// @dev Minimal risk score a strategy can be assigned.\\nuint8 constant MIN_RISK_SCORE = 1;\\n\\n/// @dev Maximal value for risk tolerance a smart vautl can have.\\nint8 constant MAX_RISK_TOLERANCE = 10;\\n\\n/// @dev Minimal value for risk tolerance a smart vault can have.\\nint8 constant MIN_RISK_TOLERANCE = -10;\\n\\n/// @dev If set as risk provider, system will return fixed risk score values\\naddress constant STATIC_RISK_PROVIDER = address(0xaaa);\\n\\n/// @dev Fixed values to use if risk provider is set to STATIC_RISK_PROVIDER\\nuint8 constant STATIC_RISK_SCORE = 1;\\n\\n/// @dev Maximal value of deposit NFT ID.\\nuint256 constant MAXIMAL_DEPOSIT_ID = 2 ** 255;\\n\\n/// @dev Maximal value of withdrawal NFT ID.\\nuint256 constant MAXIMAL_WITHDRAWAL_ID = 2 ** 256 - 1;\\n\\n/// @dev How many shares will be minted with a NFT\\nuint256 constant NFT_MINTED_SHARES = 10 ** 6;\\n\\n/// @dev Each smart vault can have up to STRATEGY_COUNT_CAP strategies.\\nuint256 constant STRATEGY_COUNT_CAP = 16;\\n\\n/// @dev Maximal DHW base yield. Expressed in terms of FULL_PERCENT.\\nuint256 constant MAX_DHW_BASE_YIELD_LIMIT = 10_00;\\n\\n/// @dev Smart vault and strategy share multiplier at first deposit.\\nuint256 constant INITIAL_SHARE_MULTIPLIER = 1000;\\n\\n/// @dev Strategy initial locked shares. These shares will never be unlocked.\\nuint256 constant INITIAL_LOCKED_SHARES = 10 ** 12;\\n\\n/// @dev Strategy initial locked shares address.\\naddress constant INITIAL_LOCKED_SHARES_ADDRESS = address(0xdead);\\n\\n/// @dev Maximum number of guards a smart vault can be configured with\\nuint256 constant MAX_GUARD_COUNT = 10;\\n\\n/// @dev Maximum number of actions a smart vault can be configured with\\nuint256 constant MAX_ACTION_COUNT = 10;\\n\\n/// @dev ID of null asset group. Should not be used by any strategy or smart vault.\\nuint256 constant NULL_ASSET_GROUP_ID = 0;\\n\"\r\n    },\r\n    \"src/interfaces/RequestType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Different request types for guards and actions.\\n * @custom:member Deposit User is depositing into a smart vault.\\n * @custom:member Withdrawal User is requesting withdrawal from a smart vault.\\n * @custom:member TransferNFT User is transfering deposit or withdrawal NFT.\\n * @custom:member BurnNFT User is burning deposit or withdrawal NFT.\\n * @custom:member TransferSVTs User is transferring smart vault tokens.\\n */\\nenum RequestType {\\n    Deposit,\\n    Withdrawal,\\n    TransferNFT,\\n    BurnNFT,\\n    TransferSVTs\\n}\\n\"\r\n    },\r\n    \"src/access/SpoolAccessControllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/ISpoolAccessControl.sol\\\";\\nimport \\\"../interfaces/CommonErrors.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @notice Account access role verification middleware\\n */\\nabstract contract SpoolAccessControllable {\\n    /* ========== CONSTANTS ========== */\\n\\n    /**\\n     * @dev Spool access control manager.\\n     */\\n    ISpoolAccessControl internal immutable _accessControl;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    /**\\n     * @param accessControl_ Spool access control manager.\\n     */\\n    constructor(ISpoolAccessControl accessControl_) {\\n        if (address(accessControl_) == address(0)) revert ConfigurationAddressZero();\\n\\n        _accessControl = accessControl_;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Reverts if an account is missing a role.\\\\\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_accessControl.hasRole(role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revert if an account is missing a role for a smartVault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkSmartVaultRole(address smartVault, bytes32 role, address account) internal view {\\n        if (!_accessControl.hasSmartVaultRole(smartVault, role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (_accessControl.paused()) {\\n            revert SystemPaused();\\n        }\\n    }\\n\\n    function _checkNonReentrant() internal view {\\n        _accessControl.checkNonReentrant();\\n    }\\n\\n    function _nonReentrantBefore() internal {\\n        _accessControl.nonReentrantBefore();\\n    }\\n\\n    function _nonReentrantAfter() internal {\\n        _accessControl.nonReentrantAfter();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /**\\n     * @notice Only allows accounts with granted role.\\n     * @dev Reverts when the account fails check.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlyRole(bytes32 role, address account) {\\n        _checkRole(role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts with granted role for a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlySmartVaultRole(address smartVault, bytes32 role, address account) {\\n        _checkSmartVaultRole(smartVault, role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts that are Spool admins or admins of a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param account Account to check.\\n     */\\n    modifier onlyAdminOrVaultAdmin(address smartVault, address account) {\\n        _accessControl.checkIsAdminOrVaultAdmin(smartVault, account);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, or other contracts using this modifier.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    /**\\n     * @dev Check if a system has already entered in the non-reentrant state.\\n     */\\n    modifier checkNonReentrant() {\\n        _checkNonReentrant();\\n        _;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArrayMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nlibrary ArrayMappingUint256 {\\n    /**\\n     * @notice Map mapping(uint256 => uint256)) values to an array.\\n     */\\n    function toArray(mapping(uint256 => uint256) storage _self, uint256 length)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory arrayOut = new uint256[](length);\\n        for (uint256 i; i < length; ++i) {\\n            arrayOut[i] = _self[i];\\n        }\\n        return arrayOut;\\n    }\\n\\n    /**\\n     * @notice Set array values to mapping slots.\\n     */\\n    function setValues(mapping(uint256 => uint256) storage _self, uint256[] calldata values) external {\\n        for (uint256 i; i < values.length; ++i) {\\n            _self[i] = values[i];\\n        }\\n    }\\n}\\n\\nlibrary ArrayMappingAddress {\\n    /**\\n     * @notice Map mapping(uint256 => address)) values to an array.\\n     */\\n    function toArray(mapping(uint256 => address) storage _self, uint256 length)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory arrayOut = new address[](length);\\n        for (uint256 i; i < length; ++i) {\\n            arrayOut[i] = _self[i];\\n        }\\n        return arrayOut;\\n    }\\n\\n    /**\\n     * @notice Set array values to mapping slots.\\n     */\\n    function setValues(mapping(uint256 => address) storage _self, address[] calldata values) external {\\n        for (uint256 i; i < values.length; ++i) {\\n            _self[i] = values[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SpoolUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/utils/math/Math.sol\\\";\\nimport \\\"../interfaces/IMasterWallet.sol\\\";\\nimport \\\"../interfaces/IStrategy.sol\\\";\\nimport \\\"../interfaces/IStrategyRegistry.sol\\\";\\nimport \\\"../interfaces/IUsdPriceFeedManager.sol\\\";\\n\\n/**\\n * @title Spool utility functions.\\n * @notice This library gathers various utility functions.\\n */\\nlibrary SpoolUtils {\\n    /**\\n     * @notice Gets asset ratios for strategies as recorded at their last DHW.\\n     * Asset ratios are ordered according to each strategies asset group.\\n     * @param strategies_ Addresses of strategies.\\n     * @param strategyRegistry_ Strategy registry.\\n     * @return strategyRatios Required asset ratio for strategies.\\n     */\\n    function getStrategyRatiosAtLastDhw(address[] calldata strategies_, IStrategyRegistry strategyRegistry_)\\n        public\\n        view\\n        returns (uint256[][] memory)\\n    {\\n        uint256[][] memory strategyRatios = new uint256[][](strategies_.length);\\n\\n        for (uint256 i; i < strategies_.length; ++i) {\\n            strategyRatios[i] = strategyRegistry_.assetRatioAtLastDhw(strategies_[i]);\\n        }\\n\\n        return strategyRatios;\\n    }\\n\\n    /**\\n     * @notice Gets USD exchange rates for tokens.\\n     * The exchange rate is represented as a USD price for one token.\\n     * @param tokens_ Addresses of tokens.\\n     * @param priceFeedManager_ USD price feed mananger.\\n     * @return exchangeRates Exchange rates for tokens.\\n     */\\n    function getExchangeRates(address[] calldata tokens_, IUsdPriceFeedManager priceFeedManager_)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory exchangeRates = new uint256[](tokens_.length);\\n        for (uint256 i; i < tokens_.length; ++i) {\\n            exchangeRates[i] =\\n                priceFeedManager_.assetToUsd(tokens_[i], 10 ** priceFeedManager_.assetDecimals(tokens_[i]));\\n        }\\n\\n        return exchangeRates;\\n    }\\n\\n    /**\\n     * @dev Gets revert message when a low-level call reverts, so that it can\\n     * be bubbled-up to caller.\\n     * @param returnData_ Data returned from reverted low-level call.\\n     * @return revertMsg Original revert message if available, or default message otherwise.\\n     */\\n    function getRevertMsg(bytes memory returnData_) public pure returns (string memory) {\\n        // if the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (returnData_.length < 68) {\\n            return \\\"SpoolUtils::_getRevertMsg: Transaction reverted silently.\\\";\\n        }\\n\\n        assembly {\\n            // slice the sig hash\\n            returnData_ := add(returnData_, 0x04)\\n        }\\n\\n        return abi.decode(returnData_, (string)); // all that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/uint128a2Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ntype uint128a2 is uint256;\\n\\n/**\\n * @notice This library enables packing of sixteen uint16 elements into one uint256 word.\\n */\\nlibrary uint128a2Lib {\\n    /// @notice Number of bits per stored element.\\n    uint256 constant bits = 128;\\n\\n    /// @notice Maximal number of elements stored.\\n    uint256 constant elements = 2;\\n\\n    // must ensure that bits * elements <= 256\\n\\n    /// @notice Range covered by stored element.\\n    uint256 constant range = 1 << bits;\\n\\n    /// @notice Maximal value of stored element.\\n    uint256 constant max = range - 1;\\n\\n    /**\\n     * @notice Gets element from packed array.\\n     * @param va Packed array.\\n     * @param index Index of element to get.\\n     * @return element Element of va stored in index index.\\n     */\\n    function get(uint128a2 va, uint256 index) internal pure returns (uint256) {\\n        require(index < elements);\\n\\n        return (uint128a2.unwrap(va) >> (bits * index)) & max;\\n    }\\n\\n    /**\\n     * @notice Sets element to packed array.\\n     * @param va Packed array.\\n     * @param index Index under which to store the element\\n     * @param ev Element to store.\\n     * @return va Packed array with stored element.\\n     */\\n    function set(uint128a2 va, uint256 index, uint256 ev) internal pure returns (uint128a2) {\\n        require(index < elements);\\n        require(ev < range);\\n        index *= bits;\\n        return uint128a2.wrap((uint128a2.unwrap(va) & ~(max << index)) | (ev << index));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/libraries/uint16a16Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ntype uint16a16 is uint256;\\n\\n/**\\n * @notice This library enables packing of sixteen uint16 elements into one uint256 word.\\n */\\nlibrary uint16a16Lib {\\n    /// @notice Number of bits per stored element.\\n    uint256 constant bits = 16;\\n\\n    /// @notice Maximal number of elements stored.\\n    uint256 constant elements = 16;\\n\\n    // must ensure that bits * elements <= 256\\n\\n    /// @notice Range covered by stored element.\\n    uint256 constant range = 1 << bits;\\n\\n    /// @notice Maximal value of stored element.\\n    uint256 constant max = range - 1;\\n\\n    /**\\n     * @notice Gets element from packed array.\\n     * @param va Packed array.\\n     * @param index Index of element to get.\\n     * @return element Element of va stored in index index.\\n     */\\n    function get(uint16a16 va, uint256 index) internal pure returns (uint256) {\\n        require(index < elements);\\n        return (uint16a16.unwrap(va) >> (bits * index)) & max;\\n    }\\n\\n    /**\\n     * @notice Sets element to packed array.\\n     * @param va Packed array.\\n     * @param index Index under which to store the element\\n     * @param ev Element to store.\\n     * @return va Packed array with stored element.\\n     */\\n    function set(uint16a16 va, uint256 index, uint256 ev) internal pure returns (uint16a16) {\\n        require(index < elements);\\n        require(ev < range);\\n        index *= bits;\\n        return uint16a16.wrap((uint16a16.unwrap(va) & ~(max << index)) | (ev << index));\\n    }\\n\\n    /**\\n     * @notice Sets elements to packed array.\\n     * Elements are stored continuously from index 0 onwards.\\n     * @param va Packed array.\\n     * @param ev Elements to store.\\n     * @return va Packed array with stored elements.\\n     */\\n    function set(uint16a16 va, uint256[] memory ev) internal pure returns (uint16a16) {\\n        for (uint256 i; i < ev.length; ++i) {\\n            va = set(va, i, ev[i]);\\n        }\\n\\n        return va;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Information needed to make a swap of assets.\\n * @custom:member swapTarget Contract executing the swap.\\n * @custom:member token Token to be swapped.\\n * @custom:member swapCallData Calldata describing the swap itself.\\n */\\nstruct SwapInfo {\\n    address swapTarget;\\n    address token;\\n    bytes swapCallData;\\n}\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to do a swap via an exchange that is not allowed to execute a swap.\\n * @param exchange Exchange used.\\n */\\nerror ExchangeNotAllowed(address exchange);\\n\\n/**\\n * @notice Used when trying to execute a swap but are not authorized.\\n * @param caller Caller of the swap method.\\n */\\nerror NotSwapper(address caller);\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISwapper {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when the exchange allowlist is updated.\\n     * @param exchange Exchange that was updated.\\n     * @param isAllowed Whether the exchange is allowed to be used in a swap or not after the update.\\n     */\\n    event ExchangeAllowlistUpdated(address indexed exchange, bool isAllowed);\\n\\n    event Swapped(\\n        address indexed receiver, address[] tokensIn, address[] tokensOut, uint256[] amountsIn, uint256[] amountsOut\\n    );\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Performs a swap of tokens with external contracts.\\n     * - deposit tokens into the swapper contract\\n     * - swapper will swap tokens based on swap info provided\\n     * - swapper will return unswapped tokens to the receiver\\n     * @param tokensIn Addresses of tokens available for the swap.\\n     * @param swapInfo Information needed to perform the swap.\\n     * @param tokensOut Addresses of tokens to swap to.\\n     * @param receiver Receiver of unswapped tokens.\\n     * @return amountsOut Amounts of `tokensOut` sent from the swapper to the receiver.\\n     */\\n    function swap(\\n        address[] calldata tokensIn,\\n        SwapInfo[] calldata swapInfo,\\n        address[] calldata tokensOut,\\n        address receiver\\n    ) external returns (uint256[] memory amountsOut);\\n\\n    /**\\n     * @notice Updates list of exchanges that can be used in a swap.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SPOOL_ADMIN\\n     *   - exchanges and allowed arrays need to be of same length\\n     * @param exchanges Addresses of exchanges.\\n     * @param allowed Whether an exchange is allowed to be used in a swap.\\n     */\\n    function updateExchangeAllowlist(address[] calldata exchanges, bool[] calldata allowed) external;\\n\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if an exchange is allowed to be used in a swap.\\n     * @param exchange Exchange to check.\\n     * @return isAllowed True if the exchange is allowed to be used in a swap, false otherwise.\\n     */\\n    function isExchangeAllowed(address exchange) external view returns (bool isAllowed);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWithdrawalManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/**\\n * @notice Used when trying to burn withdrawal NFT that was not synced yet.\\n * @param id ID of the NFT.\\n */\\nerror WithdrawalNftNotSyncedYet(uint256 id);\\n\\n/**\\n * @notice Base information for redeemal.\\n * @custom:member smartVault Smart vault from which to redeem.\\n * @custom:member shares Amount of smart vault shares to redeem.\\n * @custom:member nftIds IDs of deposit NFTs to burn before redeemal.\\n * @custom:member nftAmounts Amounts of NFT shares to burn.\\n */\\nstruct RedeemBag {\\n    address smartVault;\\n    uint256 shares;\\n    uint256[] nftIds;\\n    uint256[] nftAmounts;\\n}\\n\\n/**\\n * @notice Extra information for fast redeemal.\\n * @custom:member strategies Strategies of the smart vault.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member assetGroupId ID of the asset group of the smart vault.\\n * @custom:member redeemer Address that initiated the redeemal.\\n * @custom:member withdrawalSlippages Slippages used to guard redeemal.\\n */\\nstruct RedeemFastExtras {\\n    address[] strategies;\\n    address[] assetGroup;\\n    uint256 assetGroupId;\\n    address redeemer;\\n    uint256[][] withdrawalSlippages;\\n}\\n\\n/**\\n * @notice Extra information for redeemal.\\n * @custom:member receiver Receiver of the withdraw NFT.\\n * @custom:member owner Address that owns the shares being redeemed.\\n * @custom:member executor Address that initiated the redeemal.\\n * @custom:member flushIndex Current flush index of the smart vault.\\n */\\nstruct RedeemExtras {\\n    address receiver;\\n    address owner;\\n    address executor;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Information used to claim withdrawal.\\n * @custom:member smartVault Smart vault from which to claim withdrawal.\\n * @custom:member nftIds Withdrawal NFTs to burn while claiming withdrawal.\\n * @custom:member nftAmounts Amounts of NFT shares to burn.\\n * @custom:member receiver Receiver of withdrawn assets.\\n * @custom:member executor Address that initiated the withdrawal claim.\\n * @custom:member assetGroupId ID of the asset group of the smart vault.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member flushIndexToSync Next flush index to sync for the smart vault.\\n */\\nstruct WithdrawalClaimBag {\\n    address smartVault;\\n    uint256[] nftIds;\\n    uint256[] nftAmounts;\\n    address receiver;\\n    address executor;\\n    uint256 assetGroupId;\\n    address[] assetGroup;\\n    uint256 flushIndexToSync;\\n}\\n\\ninterface IWithdrawalManager {\\n    /**\\n     * @notice User redeemed withdrawal NFTs for underlying assets\\n     * @param smartVault Smart vault address\\n     * @param claimer Claimer address\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     * @param withdrawnAssets Amount of underlying assets withdrawn\\n     */\\n    event WithdrawalClaimed(\\n        address indexed smartVault,\\n        address indexed claimer,\\n        uint256 assetGroupId,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts,\\n        uint256[] withdrawnAssets\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param owner Owner of shares to be redeemed\\n     * @param redeemId Withdrawal NFT ID for this redeemal\\n     * @param flushIndex Flush index the redeem was scheduled for\\n     * @param shares Amount of vault shares to redeem\\n     * @param receiver Beneficiary that will be able to claim the underlying assets\\n     */\\n    event RedeemInitiated(\\n        address indexed smartVault,\\n        address indexed owner,\\n        uint256 indexed redeemId,\\n        uint256 flushIndex,\\n        uint256 shares,\\n        address receiver\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param redeemer Redeem initiator and owner of shares\\n     * @param shares Amount of vault shares to redeem\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     * @param assetsWithdrawn Amount of underlying assets withdrawn\\n     */\\n    event FastRedeemInitiated(\\n        address indexed smartVault,\\n        address indexed redeemer,\\n        uint256 shares,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts,\\n        uint256[] assetsWithdrawn\\n    );\\n\\n    /**\\n     * @notice Flushes smart vaults deposits and withdrawals to the strategies.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault to flush.\\n     * @param flushIndex Current flush index of the smart vault.\\n     * @param strategies Strategies of the smart vault.\\n     * @return dhwIndexes current do-hard-work indexes of the strategies.\\n     */\\n    function flushSmartVault(address smartVault, uint256 flushIndex, address[] calldata strategies)\\n        external\\n        returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Claims withdrawal.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Parameters for claiming withdrawal.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     * @return assetGroupId ID of the asset group.\\n     */\\n    function claimWithdrawal(WithdrawalClaimBag calldata bag)\\n        external\\n        returns (uint256[] memory withdrawnAssets, uint256 assetGroupId);\\n\\n    /**\\n     * @notice Syncs withdrawals between strategies and smart vault after do-hard-works.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault to sync.\\n     * @param flushIndex Smart vault's flush index to sync.\\n     * @param strategies Strategies of the smart vault.\\n     * @param dhwIndexes_ Strategies' do-hard-work indexes to sync.\\n     */\\n    function syncWithdrawals(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        uint16a16 dhwIndexes_\\n    ) external;\\n\\n    /**\\n     * @notice Redeems smart vault shares.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Base information for redeemal.\\n     * @param bag2 Extra information for redeemal.\\n     * @return nftId ID of the withdrawal NFT.\\n     */\\n    function redeem(RedeemBag calldata bag, RedeemExtras calldata bag2) external returns (uint256 nftId);\\n\\n    /**\\n     * @notice Instantly redeems smart vault shares.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Base information for redeemal.\\n     * @param bag Extra information for fast redeemal.\\n     * @return assets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemBag calldata bag, RedeemFastExtras memory bag2)\\n        external\\n        returns (uint256[] memory assets);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISpoolAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @notice Used when an account is missing a required role.\\n * @param role Required role.\\n * @param account Account missing the required role.\\n */\\nerror MissingRole(bytes32 role, address account);\\n\\n/**\\n * @notice Used when interacting with Spool when the system is paused.\\n */\\nerror SystemPaused();\\n\\n/**\\n * @notice Used when setting smart vault owner\\n */\\nerror SmartVaultOwnerAlreadySet(address smartVault);\\n\\n/**\\n * @notice Used when a contract tries to enter in a non-reentrant state.\\n */\\nerror ReentrantCall();\\n\\n/**\\n * @notice Used when a contract tries to call in a non-reentrant function and doesn't have the correct role.\\n */\\nerror NoReentrantRole();\\n\\n/**\\n * @notice thrown if unauthorized account tries to perform ownership transfer\\n */\\nerror OwnableUnauthorizedAccount(address account);\\n\\ninterface ISpoolAccessControl is IAccessControlUpgradeable {\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets owner of a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return owner Owner of the smart vault.\\n     */\\n    function smartVaultOwner(address smartVault) external view returns (address owner);\\n\\n    /**\\n     * @notice Looks if an account has a role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to look for.\\n     * @param account Account to check.\\n     * @return hasRole True if account has the role for the smart vault, false otherwise.\\n     */\\n    function hasSmartVaultRole(address smartVault, bytes32 role, address account)\\n        external\\n        view\\n        returns (bool hasRole);\\n\\n    /**\\n     * @notice Checks if an account is either Spool admin or admin for a smart vault.\\n     * @dev The function reverts if account is neither.\\n     * @param smartVault Address of the smart vault.\\n     * @param account to check.\\n     */\\n    function checkIsAdminOrVaultAdmin(address smartVault, address account) external view;\\n\\n    /**\\n     * @notice Checks if system is paused or not.\\n     * @return isPaused True if system is paused, false otherwise.\\n     */\\n    function paused() external view returns (bool isPaused);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Pauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_PAUSER\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_UNPAUSER\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @notice Grants role to an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to grant.\\n     * @param account Account to grant the role to.\\n     */\\n    function grantSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Revokes role from an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to revoke.\\n     * @param account Account to revoke the role from.\\n     */\\n    function revokeSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Renounce role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to renounce.\\n     */\\n    function renounceSmartVaultRole(address smartVault, bytes32 role) external;\\n\\n    /**\\n     * @notice Grant ownership to smart vault and assigns admin role.\\n     * @dev Ownership can only be granted once and it should be done at vault creation time.\\n     * @param smartVault Address of the smart vault.\\n     * @param owner address to which grant ownership to\\n     */\\n    function grantSmartVaultOwnership(address smartVault, address owner) external;\\n\\n    /**\\n     * @notice Checks and reverts if a system has already entered in the non-reentrant state.\\n     */\\n    function checkNonReentrant() external view;\\n\\n    /**\\n     * @notice Sets the entered flag to true when entering for the first time.\\n     * @dev Reverts if a system has already entered before.\\n     */\\n    function nonReentrantBefore() external;\\n\\n    /**\\n     * @notice Resets the entered flag after the call is finished.\\n     */\\n    function nonReentrantAfter() external;\\n\\n    /**\\n     * @notice Emitted when ownership of a smart vault is granted to an address\\n     * @param smartVault Smart vault address\\n     * @param address_ Address of the new smart vault owner\\n     */\\n    event SmartVaultOwnershipGranted(address indexed smartVault, address indexed address_);\\n\\n    /**\\n     * @notice Smart vault specific role was granted\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account to which the role was granted\\n     */\\n    event SmartVaultRoleGranted(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was revoked\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account for which the role was revoked\\n     */\\n    event SmartVaultRoleRevoked(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was renounced\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account that renounced the role\\n     */\\n    event SmartVaultRoleRenounced(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice SmartVault owner initiated transfer\\n     * @param previousOwner address\\n     * @param newOwner address\\n     */\\n    event SmartVaultOwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Ownership transfer is finalized\\n     * @param previousOwner address\\n     * @param newOwner address\\n     */\\n    event SmartVaultOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Used when an array has invalid length.\\n */\\nerror InvalidArrayLength();\\n\\n/**\\n * @notice Used when group of smart vaults or strategies do not have same asset group.\\n */\\nerror NotSameAssetGroup();\\n\\n/**\\n * @notice Used when configuring an address with a zero address.\\n */\\nerror ConfigurationAddressZero();\\n\\n/**\\n * @notice Used when constructor or intializer parameters are invalid.\\n */\\nerror InvalidConfiguration();\\n\\n/**\\n * @notice Used when fetched exchange rate is out of slippage range.\\n */\\nerror ExchangeRateOutOfSlippages();\\n\\n/**\\n * @notice Used when an invalid strategy is provided.\\n * @param address_ Address of the invalid strategy.\\n */\\nerror InvalidStrategy(address address_);\\n\\n/**\\n * @notice Used when doing low-level call on an address that is not a contract.\\n * @param address_ Address of the contract\\n */\\nerror AddressNotContract(address address_);\\n\\n/**\\n * @notice Used when invoking an only view execution and tx.origin is not address zero.\\n * @param address_ Address of the tx.origin\\n */\\nerror OnlyViewExecution(address address_);\\n\"\r\n    },\r\n    \"src/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Grants permission to:\\n * - acts as a default admin for other roles,\\n * - can whitelist an action with action manager,\\n * - can manage asset group registry.\\n *\\n * Is granted to the deployer of the SpoolAccessControl contract.\\n *\\n * Equals to the DEFAULT_ADMIN_ROLE of the OpenZeppelin AccessControl.\\n */\\nbytes32 constant ROLE_SPOOL_ADMIN = 0x00;\\n\\n/**\\n * @dev Grants permission to integrate a new smart vault into the Spool ecosystem.\\n *\\n * Should be granted to smart vault factory contracts.\\n */\\nbytes32 constant ROLE_SMART_VAULT_INTEGRATOR = keccak256(\\\"SMART_VAULT_INTEGRATOR\\\");\\n\\n/**\\n * @dev Grants permission to\\n * - manage rewards on smart vaults,\\n * - manage roles on smart vaults,\\n * - redeem for another user of a smart vault.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ADMIN = keccak256(\\\"SMART_VAULT_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to manage allowlists with AllowlistGuard for a smart vault.\\n *\\n * Should be granted to whoever is in charge of maintaining allowlists with AllowlistGuard for a smart vault.\\n */\\nbytes32 constant ROLE_GUARD_ALLOWLIST_MANAGER = keccak256(\\\"GUARD_ALLOWLIST_MANAGER\\\");\\n\\n/**\\n * @dev Grants permission to manage assets on master wallet.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the StrategyRegistry contract,\\n * - the DepositManager contract,\\n * - the WithdrawalManager contract.\\n */\\nbytes32 constant ROLE_MASTER_WALLET_MANAGER = keccak256(\\\"MASTER_WALLET_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a smart vault manager.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the DepositManager contract.\\n */\\nbytes32 constant ROLE_SMART_VAULT_MANAGER = keccak256(\\\"SMART_VAULT_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a strategy registry.\\n *\\n * Should be granted to the StrategyRegistry contract.\\n */\\nbytes32 constant ROLE_STRATEGY_REGISTRY = keccak256(\\\"STRATEGY_REGISTRY\\\");\\n\\n/**\\n * @dev Grants permission to act as a risk provider.\\n *\\n * Should be granted to whoever is allowed to provide risk scores.\\n */\\nbytes32 constant ROLE_RISK_PROVIDER = keccak256(\\\"RISK_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to act as an allocation provider.\\n *\\n * Should be granted to contracts that are allowed to calculate allocations.\\n */\\nbytes32 constant ROLE_ALLOCATION_PROVIDER = keccak256(\\\"ALLOCATION_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to pause the system.\\n */\\nbytes32 constant ROLE_PAUSER = keccak256(\\\"SYSTEM_PAUSER\\\");\\n\\n/**\\n * @dev Grants permission to unpause the system.\\n */\\nbytes32 constant ROLE_UNPAUSER = keccak256(\\\"SYSTEM_UNPAUSER\\\");\\n\\n/**\\n * @dev Grants permission to manage rewards payment pool.\\n */\\nbytes32 constant ROLE_REWARD_POOL_ADMIN = keccak256(\\\"REWARD_POOL_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to reallocate smart vaults.\\n */\\nbytes32 constant ROLE_REALLOCATOR = keccak256(\\\"REALLOCATOR\\\");\\n\\n/**\\n * @dev Grants permission to be used as a strategy.\\n */\\nbytes32 constant ROLE_STRATEGY = keccak256(\\\"STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission to manually set strategy apy.\\n */\\nbytes32 constant ROLE_STRATEGY_APY_SETTER = keccak256(\\\"STRATEGY_APY_SETTER\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_STRATEGY.\\n */\\nbytes32 constant ADMIN_ROLE_STRATEGY = keccak256(\\\"ADMIN_STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission vault admins to allow redeem on behalf of other users.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_SMART_VAULT_ALLOW_REDEEM.\\n */\\nbytes32 constant ADMIN_ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"ADMIN_SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to run do hard work.\\n */\\nbytes32 constant ROLE_DO_HARD_WORKER = keccak256(\\\"DO_HARD_WORKER\\\");\\n\\n/**\\n * @dev Grants permission to immediately withdraw assets in case of emergency.\\n */\\nbytes32 constant ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR = keccak256(\\\"EMERGENCY_WITHDRAWAL_EXECUTOR\\\");\\n\\n/**\\n * @dev Grants permission to swap with swapper.\\n *\\n * Should be granted to the DepositSwap contract.\\n */\\nbytes32 constant ROLE_SWAPPER = keccak256(\\\"SWAPPER\\\");\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\r\\n */\\r\\ninterface IAccessControlUpgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"script/helper/ArraysHelper.sol\": {\r\n        \"ArraysHelper\": \"0x7dF191D01252D2C0BABf77c725c63D69fe6EAA1a\"\r\n      },\r\n      \"src/libraries/ArrayMapping.sol\": {\r\n        \"ArrayMappingUint256\": \"0xB6B08a9ed9282c695ddFbfA81d9ebF208b4c1De0\"\r\n      },\r\n      \"src/libraries/ReallocationLib.sol\": {\r\n        \"ReallocationLib\": \"0x49CE6640EB2D89F80395C1a3695cc3a01b5C7bc1\"\r\n      },\r\n      \"src/libraries/SpoolUtils.sol\": {\r\n        \"SpoolUtils\": \"0xCB3fECd1D5eabB1b18383604A28352c17Bdfef89\"\r\n      },\r\n      \"src/strategies/libraries/EthFrxEthAssetGroupAdapter.sol\": {\r\n        \"EthFrxEthAssetGroupAdapter\": \"0xE23681bAA697EF5054E2D8C397ae59145027625D\"\r\n      },\r\n      \"src/strategies/libraries/EthStEthAssetGroupAdapter.sol\": {\r\n        \"EthStEthAssetGroupAdapter\": \"0x1516eb3a54377168b6b184326200f4258C3529dF\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStrategyRegistry\",\"name\":\"strategyRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"priceFeedManager_\",\"type\":\"address\"},{\"internalType\":\"contract IGuardManager\",\"name\":\"guardManager_\",\"type\":\"address\"},{\"internalType\":\"contract IActionManager\",\"name\":\"actionManager_\",\"type\":\"address\"},{\"internalType\":\"contract ISpoolAccessControl\",\"name\":\"accessControl_\",\"type\":\"address\"},{\"internalType\":\"contract IMasterWallet\",\"name\":\"masterWallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ghostStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ConfigurationAddressZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"DepositNftNotSyncedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectDepositRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAssetLengths\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositNftId\",\"type\":\"uint256\"}],\"name\":\"InvalidDepositNftId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNftArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNormalization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MissingRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoDepositsToRecover\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGhostVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SmartVaultWorthIsZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flushIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"assets\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"DepositInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"recoveredAssets\",\"type\":\"uint256[]\"}],\"name\":\"PendingDepositsRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"depositFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managementFees\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SmartVaultFeesCollected\",\"name\":\"smartVaultFeesCollected\",\"type\":\"tuple\"}],\"name\":\"SmartVaultFeesMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedVaultTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftAmounts\",\"type\":\"uint256[]\"}],\"name\":\"SmartVaultTokensClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"strategyRatios\",\"type\":\"uint256[][]\"}],\"name\":\"calculateDepositRatio\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"strategyRatios\",\"type\":\"uint256[][]\"}],\"name\":\"calculateFlushFactors\",\"outputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"deposit\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"strategyRatios\",\"type\":\"uint256[][]\"}],\"name\":\"checkDepositRatio\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flushIndexToSync\",\"type\":\"uint256\"}],\"name\":\"claimSmartVaultTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"assets\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"doFlush\",\"type\":\"bool\"}],\"internalType\":\"struct DepositBag\",\"name\":\"bag\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flushIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositExtras\",\"name\":\"bag2\",\"type\":\"tuple\"}],\"name\":\"depositAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"deposit\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"strategyRatios\",\"type\":\"uint256[][]\"}],\"internalType\":\"struct DepositQueryBag1\",\"name\":\"bag\",\"type\":\"tuple\"}],\"name\":\"distributeDeposit\",\"outputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flushIndex\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"flushSmartVault\",\"outputs\":[{\"internalType\":\"uint16a16\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVaultAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"assets\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"initiated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flushIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositMetadata\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nftShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedSVTs\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getClaimedVaultTokensPreview\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint16a16\",\"name\":\"allocations\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"getDepositRatio\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flushIndex\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"emergencyWallet\",\"type\":\"address\"}],\"name\":\"recoverPendingDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flushIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetGroupLength\",\"type\":\"uint256\"}],\"name\":\"smartVaultDeposits\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"bag\",\"type\":\"uint256[2]\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint16a16[2]\",\"name\":\"dhwIndexes\",\"type\":\"uint256[2]\"},{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"managementFeePct\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"depositFeePct\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"performanceFeePct\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartVaultFees\",\"name\":\"fees\",\"type\":\"tuple\"}],\"name\":\"syncDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mintedSVTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dhwTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeSVTs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"depositFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managementFees\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartVaultFeesCollected\",\"name\":\"feesCollected\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"initialLockedSVTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"sstShares\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DepositSyncResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"bag\",\"type\":\"uint256[2]\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"internalType\":\"uint16a16\",\"name\":\"dhwIndexes\",\"type\":\"uint256\"},{\"internalType\":\"uint16a16\",\"name\":\"dhwIndexesOld\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"managementFeePct\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"depositFeePct\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"performanceFeePct\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartVaultFees\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct SimulateDepositParams\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"syncDepositsSimulate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mintedSVTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dhwTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeSVTs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"depositFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managementFees\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartVaultFeesCollected\",\"name\":\"feesCollected\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"initialLockedSVTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"sstShares\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DepositSyncResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DepositManager", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "000000000000000000000000554c6bcb54656390aca0a0af38ca954dbe653f1500000000000000000000000038f1a78ad8956b45b48837657bd0884ba7ab485a000000000000000000000000b8c204e858aa420eb5a57599da86ffd6375da6a80000000000000000000000004c6ee6ed4127a0067b9eb3b425dfcea95ac80cae0000000000000000000000007b533e72e0cdc63aacd8cdb926ac402b846fbd13000000000000000000000000f5dcf1f6e4c661cb28c27fff88adde3522cfbe91000000000000000000000000c65c1df280ac96535e56b0e7ac12fe0860b19411", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}