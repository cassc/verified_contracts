{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ShieldPad.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT                                                                               \\n                                                    \\npragma solidity 0.8.17;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() external virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}                                                                       \\n                                                    \\ncontract ERC20 is Context, IERC20 {\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\\ninterface IDexRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IDexFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface ILpPair {\\n    function sync() external;\\n}\\n\\ncontract ShieldPad is ERC20, Ownable {\\n\\n    uint256 public maxBuyAmount;\\n    uint256 public maxSellAmount;\\n    uint256 public maxWallet;\\n\\n    IDexRouter public immutable dexRouter;\\n    address public immutable lpPair;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n\\n    mapping(address => uint256) private _holderLastTransferTimestamp;\\n    bool public transferDelayEnabled = true;\\n    \\n    address public marketingAdress;\\n    address public operationsAddress;\\n\\n    bool public limitsInEffect = true;\\n    bool public tradingActive = false;\\n    bool public swapEnabled = false;\\n    \\n    uint256 public buyTotalFees;\\n    uint256 public sellTotalFees;\\n\\n    uint256 constant FEE_DIVISOR = 10000;\\n    \\n    mapping (address => bool) private _isExcludedFromFees;\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\n\\n    mapping (address => bool) public automatedMarketMakerPairs;\\n\\n    mapping (address => bool) public addressVerified;\\n    address private adminAddress;\\n    bool private needVerify = true;\\n\\n    bytes32 private secret;\\n\\n    event VestingTokens(address indexed wallet, uint256 amount);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event EnabledTrading();\\n    event RemovedLimits();\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdatedMaxBuyAmount(uint256 newAmount);\\n    event UpdatedMaxSellAmount(uint256 newAmount);\\n    event UpdatedMaxWalletAmount(uint256 newAmount);\\n    event UpdatedBuyFee(uint256 newAmount);\\n    event UpdatedSellFee(uint256 newAmount);\\n    event UpdatedmarketingAdress(address indexed newWallet);\\n    event MaxTransactionExclusion(address _address, bool excluded);\\n    event OwnerForcedSwapBack(uint256 timestamp);\\n    event CaughtEarlyBuyer(address sniper);\\n    event TransferForeignToken(address token, uint256 amount);\\n\\n    constructor(bytes32 _secret) ERC20(\\\"ShieldPad\\\", \\\"Spad\\\") {\\n\\n        secret = _secret;\\n        address newOwner = msg.sender;\\n        adminAddress = msg.sender;\\n        address _dexRouter;\\n\\n        _dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n        dexRouter = IDexRouter(_dexRouter);\\n\\n        lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), dexRouter.WETH());\\n        setAutomatedMarketMakerPair(address(lpPair), true);\\n\\n        uint256 totalSupply = 10 * 1e6 * 1e18;\\n        \\n        maxBuyAmount = totalSupply * 50 / 10000; // 0.5%\\n        maxSellAmount = totalSupply * 50 / 10000; // 0.5%\\n        maxWallet = totalSupply * 10 / 1000; // 1%\\n        swapTokensAtAmount = totalSupply * 2 / 10000; // 0.02%\\n\\n        buyTotalFees = 0;\\n        sellTotalFees = 0;\\n\\n        marketingAdress = 0x8aED9522aFb7Cb474aA263634957c09E8d04A7b0;\\n\\n        _excludeFromMaxTransaction(newOwner, true);\\n        _excludeFromMaxTransaction(address(this), true);\\n        _excludeFromMaxTransaction(address(0xdead), true);\\n        _excludeFromMaxTransaction(address(marketingAdress), true);\\n\\n        excludeFromFees(newOwner, true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(address(0xdead), true);\\n        excludeFromFees(address(marketingAdress), true);\\n\\n        _createInitialSupply(address(newOwner), totalSupply);\\n        transferOwnership(newOwner);\\n    }\\n\\n    receive() external payable {}\\n\\n    function setRules(address _adminAddress, bool _needVerify) external onlyOwner {\\n        require(_adminAddress != address(0), \\\"invalid address\\\");\\n        adminAddress = _adminAddress;\\n        needVerify = _needVerify;\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(tradingActive == false, \\\"Trading is already active, cannot relaunch.\\\");\\n        tradingActive = true;\\n        swapEnabled = true;\\n        emit EnabledTrading();\\n    }\\n\\n    function disableTransferDelay() external onlyOwner {\\n        transferDelayEnabled = false;\\n    }\\n\\n    function removeLimits() external onlyOwner {\\n        limitsInEffect = false;\\n        maxBuyAmount = totalSupply();\\n        maxSellAmount = totalSupply();\\n        maxWallet = totalSupply();\\n        transferDelayEnabled = false;\\n        emit RemovedLimits();\\n    }\\n\\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \\\"Cannot set max buy amount lower than 0.1%\\\");\\n        maxBuyAmount = newNum * (10**18);\\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\\n    }\\n    \\n    function updateMaxSellAmount(uint256 newNum) external onlyOwner {\\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \\\"Cannot set max sell amount lower than 0.1%\\\");\\n        maxSellAmount = newNum * (10**18);\\n        emit UpdatedMaxSellAmount(maxSellAmount);\\n    }\\n\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\n        require(newNum >= (totalSupply() * 1 / 100) / (10 ** decimals()), \\\"Cannot set max wallet larger than 1%\\\");\\n        maxWallet = newNum * (10 ** decimals());\\n        emit UpdatedMaxWalletAmount(maxWallet);\\n    }\\n\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\\n  \\t    require(newAmount >= totalSupply() * 2 / 10000000, \\\"Swap amount cannot be lower than 0.00002% total supply.\\\");\\n  \\t    require(newAmount <= totalSupply() * 2 / 1000, \\\"Swap amount cannot be higher than 0.2% total supply.\\\");\\n  \\t    swapTokensAtAmount = newAmount;\\n  \\t}\\n    \\n    function transferForeignToken(address _token, address _to) external onlyOwner returns (bool _sent) {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_token != address(this) || !tradingActive, \\\"Can't withdraw native tokens while trading is active\\\");\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\n        emit TransferForeignToken(_token, _contractBalance);\\n    }\\n\\n    function setMarketingAdress(address _marketingAdress) external onlyOwner {\\n        require(_marketingAdress != address(0), \\\"address cannot be 0\\\");\\n        marketingAdress = payable(_marketingAdress);\\n        emit UpdatedmarketingAdress(_marketingAdress);\\n    }\\n\\n    function forceSwapBack() external onlyOwner {\\n        require(balanceOf(address(this)) >= swapTokensAtAmount, \\\"Can only swap when token amount is at or higher than restriction\\\");\\n        swapping = true;\\n        swapBack();\\n        swapping = false;\\n        emit OwnerForcedSwapBack(block.timestamp);\\n    }\\n    \\n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\\n        if(!isEx){\\n            require(updAds != lpPair, \\\"Cannot remove uniswap pair from max txn\\\");\\n        }\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\n        require(pair != lpPair || value, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n        _excludeFromMaxTransaction(pair, value);\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function updateBuyFees(uint256 _maketingFee) external onlyOwner {\\n        buyTotalFees = _maketingFee;\\n        require(buyTotalFees <= 2100, \\\"Must keep fees at 21% or less\\\");\\n        emit UpdatedBuyFee(buyTotalFees);\\n    }\\n\\n    function updateSellFees(uint256 _maketingFee) external onlyOwner {\\n        sellTotalFees = _maketingFee;\\n        require(sellTotalFees <= 3100, \\\"Must keep fees at 31% or less\\\");\\n        emit UpdatedSellFee(sellTotalFees);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function verifyHuman(uint8 _v, bytes32 _r, bytes32 _s) public {\\n        require(tradingActive, \\\"trading not active\\\");\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _msgSender(), secret));\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\\n        address signer = ecrecover(prefixedHash, _v, _r, _s);\\n        require(signer == adminAddress, \\\"Fail\\\");\\n        addressVerified[_msgSender()] = true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal override {\\n\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if(amount == 0){\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]){ \\n            super._transfer(from, to, amount);\\n            return;\\n        }\\n        \\n        if(!tradingActive){\\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\n        }\\n\\n        if(limitsInEffect){\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\\n                \\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \\n                if (transferDelayEnabled){\\n                    if (to != address(dexRouter) && to != address(lpPair)){\\n                        require(_holderLastTransferTimestamp[tx.origin] + 4 <= block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per 3 blocks allowed.\\\");\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\n                    }\\n                }\\n                //on buy\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\n                    if (needVerify) {\\n                        require(addressVerified[to] == true,\\\"Verify you are human first\\\");\\n                    }\\n                    require(amount <= maxBuyAmount, \\\"Buy transfer amount exceeds the max buy.\\\");\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\n                } \\n                //on sell\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\n                    require(amount <= maxSellAmount, \\\"Sell transfer amount exceeds the max sell.\\\");\\n                }\\n                else if (!_isExcludedMaxTransactionAmount[to]){\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        \\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if(canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]) {\\n            swapping = true;\\n            swapBack();\\n            swapping = false;\\n        }\\n\\n        bool takeFee = true;\\n\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n        \\n        uint256 fees = 0;\\n\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if(takeFee){\\n            // on sell\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\n                fees = amount * sellTotalFees / FEE_DIVISOR;\\n            }\\n\\n            // on buy\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\n        \\t    fees = amount * buyTotalFees / FEE_DIVISOR;\\n            }\\n            \\n            if(fees > 0){    \\n                super._transfer(from, address(this), fees);\\n            }\\n        \\t\\n        \\tamount -= fees;\\n        }\\n\\n        super._transfer(from, to, amount);\\n    }\\n\\n    function swapBack() private {\\n        bool success;\\n\\n        uint256 contractBalance = balanceOf(address(this));\\n        \\n        if(contractBalance == 0) {return;}\\n\\n        if(contractBalance > swapTokensAtAmount * 60){\\n            contractBalance = swapTokensAtAmount * 60;\\n        }\\n\\n        swapTokensForEth(contractBalance);\\n        \\n        if(address(this).balance > 0){\\n            (success, ) = marketingAdress.call{value: address(this).balance}(\\\"\\\");\\n        }\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = dexRouter.WETH();\\n\\n        _approve(address(this), address(dexRouter), tokenAmount);\\n\\n        // make the swap\\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\\n    }\\n\\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\\n        emit MaxTransactionExclusion(updAds, isExcluded);\\n    }\\n\\n    function getBlockNumber() external view returns (uint256){\\n        return block.number;\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns(bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"CaughtEarlyBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnabledTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"MaxTransactionExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerForcedSwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemovedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferForeignToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedBuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxBuyAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxSellAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxWalletAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedSellFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedmarketingAdress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAdress\",\"type\":\"address\"}],\"name\":\"setMarketingAdress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_needVerify\",\"type\":\"bool\"}],\"name\":\"setRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maketingFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxSellAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maketingFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifyHuman\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ShieldPad", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "536869656c64506164202d2041205361666572204f7074696f6e204b65792020", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}