{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.19;\r\n\r\n/// @notice Library for reading contract metadata robustly.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\r\nlibrary MetadataReaderLib {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Default gas stipend for contract reads. High enough for most practical use cases\r\n    /// (able to SLOAD about 1000 bytes of data), but low enough to prevent griefing.\r\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\r\n\r\n    /// @dev Default string byte length limit.\r\n    uint256 internal constant STRING_LIMIT_DEFAULT = 1000;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                METADATA READING OPERATIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // Best-effort string reading operations.\r\n    // Should NOT revert as long as sufficient gas is provided.\r\n    //\r\n    // Performs the following in order:\r\n    // 1. Returns the empty string for the following cases:\r\n    //     - Reverts.\r\n    //     - No returndata (e.g. function returns nothing, EOA).\r\n    //     - Returns empty string.\r\n    // 2. Attempts to `abi.decode` the returndata into a string.\r\n    // 3. With any remaining gas, scans the returndata from start to end for the\r\n    //    null byte '\\0', to interpret the returndata as a null-terminated string.\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"))`.\r\n    function readName(address target) internal view returns (string memory) {\r\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit)`.\r\n    function readName(address target, uint256 limit) internal view returns (string memory) {\r\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit, gasStipend)`.\r\n    function readName(address target, uint256 limit, uint256 gasStipend)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\r\n    }\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"))`.\r\n    function readSymbol(address target) internal view returns (string memory) {\r\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit)`.\r\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\r\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit, gasStipend)`.\r\n    function readSymbol(address target, uint256 limit, uint256 gasStipend)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\r\n    }\r\n\r\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\r\n    /// The string will be truncated to `STRING_LIMIT_DEFAULT` (1000) bytes.\r\n    function readString(address target, bytes memory data) internal view returns (string memory) {\r\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\r\n    /// The string will be truncated to `limit` bytes.\r\n    function readString(address target, bytes memory data, uint256 limit)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\r\n    /// The string will be truncated to `limit` bytes.\r\n    function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _string(target, _ptr(data), limit, gasStipend);\r\n    }\r\n\r\n    // Best-effort unsigned integer reading operations.\r\n    // Should NOT revert as long as sufficient gas is provided.\r\n    //\r\n    // Performs the following in order:\r\n    // 1. Attempts to `abi.decode` the result into a uint256\r\n    //    (equivalent across all Solidity uint types, downcast as needed).\r\n    // 2. Returns zero for the following cases:\r\n    //     - Reverts.\r\n    //     - No returndata (e.g. function returns nothing, EOA).\r\n    //     - Returns zero.\r\n    //     - `abi.decode` failure.\r\n\r\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\")))`.\r\n    function readDecimals(address target) internal view returns (uint8) {\r\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\r\n    }\r\n\r\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\"), gasStipend))`.\r\n    function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\r\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\r\n    }\r\n\r\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\r\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\r\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\r\n    }\r\n\r\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\r\n    function readUint(address target, bytes memory data, uint256 gasStipend)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _uint(target, _ptr(data), gasStipend);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Attempts to read and return a string at `target`.\r\n    function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\r\n        private\r\n        view\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            function min(x_, y_) -> _z {\r\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\r\n            }\r\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\r\n                let m := mload(0x40) // Grab the free memory pointer.\r\n                let s := add(0x20, m) // Start of the string's bytes in memory.\r\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\r\n                if iszero(lt(returndatasize(), 0x40)) {\r\n                    let o := mload(0x00) // Load the string's offset in the returndata.\r\n                    // If the string's offset is within bounds.\r\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\r\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\r\n                        // If the full string's end is within bounds.\r\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\r\n                        // for compliance purposes, regardless if the truncated string can fit.\r\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\r\n                            let n := min(mload(m), limit) // Truncate if needed.\r\n                            mstore(m, n) // Overwrite the length.\r\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\r\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\r\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\r\n                            result := m\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                // Try interpreting as a null-terminated string.\r\n                let n := min(returndatasize(), limit) // Truncate if needed.\r\n                returndatacopy(s, 0, n) // Copy the string's bytes.\r\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\r\n                let i := s // Pointer to the next byte to scan.\r\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\r\n                mstore(m, sub(i, s)) // Store the string's length.\r\n                mstore(i, 0) // Zeroize the slot after the string.\r\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\r\n                result := m\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Attempts to read and return a uint at `target`.\r\n    function _uint(address target, bytes32 ptr, uint256 gasStipend)\r\n        private\r\n        view\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result :=\r\n                mul(\r\n                    mload(0x20),\r\n                    and( // The arguments of `and` are evaluated from right to left.\r\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\r\n                    )\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Casts the function selector `s` into a pointer.\r\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Layout the calldata in the scratch space for temporary usage.\r\n            mstore(0x04, s) // Store the function selector.\r\n            mstore(result, 4) // Store the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Casts the `data` into a pointer.\r\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := data\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Onchain price and balance checker.\r\ncontract BalanceChecker {\r\n    using MetadataReaderLib for address;\r\n\r\n    event Registered(address indexed asset);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n\r\n    address constant WETH_USDC_POOL = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;\r\n    address constant WBTC_USDC_POOL = 0x99ac8cA7087fA4A2A1FB6357269965A2014ABc35;\r\n\r\n    address public owner;\r\n    address[] public registered;\r\n    mapping(address asset => Asset) public assets;\r\n\r\n    struct Asset {\r\n        string name;\r\n        string symbol;\r\n        uint8 decimals;\r\n        address pricePool;\r\n    }\r\n\r\n    constructor(address _owner) payable {\r\n        assets[ETH] = Asset(\"Ether\", \"ETH\", 18, WETH_USDC_POOL);\r\n        assets[WETH] = Asset(\"Wrapped Ether\", \"WETH\", 18, WETH_USDC_POOL);\r\n        assets[WBTC] = Asset(\"Wrapped BTC\", \"WBTC\", 8, WBTC_USDC_POOL);\r\n        registered.push(ETH);\r\n        emit Registered(ETH);\r\n        registered.push(WETH);\r\n        emit Registered(WETH);\r\n        registered.push(WBTC);\r\n        emit Registered(WBTC);\r\n        emit OwnershipTransferred(address(0), owner = _owner);\r\n    }\r\n\r\n    function ethPrice() public view returns (string memory) {\r\n        unchecked {\r\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3PoolState(WETH_USDC_POOL).slot0();\r\n            uint256 priceX192 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);\r\n            uint256 usdcPerWeth = priceX192 / (2 ** 192);\r\n            uint256 wethPerUsdc = 1e18 / usdcPerWeth;\r\n            return _convertWeiToString(wethPerUsdc, 6);\r\n        }\r\n    }\r\n\r\n    function btcPrice() public view returns (string memory) {\r\n        unchecked {\r\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3PoolState(WBTC_USDC_POOL).slot0();\r\n            uint256 price = (uint256(sqrtPriceX96) ** 2 * 1e8) >> (96 * 2);\r\n            return _convertWeiToString(price, 6);\r\n        }\r\n    }\r\n\r\n    function getPrices() public view returns (string memory _ethPrice, string memory _btcPrice) {\r\n        (_ethPrice, _btcPrice) = (ethPrice(), btcPrice());\r\n    }\r\n\r\n    function register(address asset, address pricePool) public payable onlyOwner {\r\n        assets[asset] = Asset(asset.readName(), asset.readSymbol(), asset.readDecimals(), pricePool);\r\n        registered.push(asset);\r\n        emit Registered(asset);\r\n    }\r\n\r\n    function balancesOfRaw(address user) public view returns (uint256[] memory balances) {\r\n        address asset;\r\n        balances = new uint256[](registered.length);\r\n        for (uint256 i; i != registered.length; ++i) {\r\n            asset = registered[i];\r\n            balances[i] = asset == ETH ? user.balance : IBalanceOf(asset).balanceOf(user);\r\n        }\r\n    }\r\n\r\n    struct Balance {\r\n        string symbol;\r\n        string balance;\r\n        string price;\r\n        string usd;\r\n    }\r\n\r\n    function balancesOf(address user)\r\n        public\r\n        view\r\n        returns (Balance[] memory balances)\r\n    {\r\n        uint256[] memory bals = balancesOfRaw(user);\r\n        balances = new Balance[](bals.length);\r\n\r\n        address asset;\r\n        uint8 decimals;\r\n\r\n        for (uint256 i; i != bals.length; ++i) {\r\n            asset = registered[i];\r\n            decimals = assets[asset].decimals;\r\n            balances[i].balance = _convertWeiToString(bals[i], decimals);\r\n        }\r\n\r\n        address pool;\r\n\r\n        for (uint256 i; i != bals.length; ++i) {\r\n            asset = registered[i];\r\n            pool = assets[asset].pricePool;\r\n            balances[i].symbol = assets[asset].symbol;\r\n            if (pool != address(0) && asset != WBTC) {\r\n                unchecked {\r\n                    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3PoolState(pool).slot0();\r\n                    uint256 priceX192 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);\r\n                    uint256 usdcPer = priceX192 / (2 ** 192);\r\n                    uint256 wethPer = 1e18 / usdcPer;\r\n                    balances[i].price = _convertWeiToString(wethPer, 6);\r\n                    balances[i].usd = _convertWeiToString(wethPer * bals[i] / 1e18, 6);\r\n                }\r\n            } else if (asset == WBTC) {\r\n                unchecked {\r\n                    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3PoolState(pool).slot0();\r\n                    uint256 price = (uint256(sqrtPriceX96) ** 2 * 1e8) >> (96 * 2);\r\n                    balances[i].price = _convertWeiToString(price, 6);\r\n                    balances[i].usd = _convertWeiToString(price * bals[i] / 1e8, 6);\r\n                }\r\n            } else {\r\n                balances[i].price = \"1.00\";\r\n                balances[i].usd = balances[i].balance;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _convertWeiToString(uint256 weiAmount, uint256 decimals)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        unchecked {\r\n            uint256 scalingFactor = 10 ** decimals;\r\n\r\n            string memory wholeNumberStr = _toString(weiAmount / scalingFactor);\r\n            string memory decimalPartStr = _toString(weiAmount % scalingFactor);\r\n\r\n            while (bytes(decimalPartStr).length != decimals) {\r\n                decimalPartStr = string(abi.encodePacked(\"0\", decimalPartStr));\r\n            }\r\n\r\n            decimalPartStr = _removeTrailingZeros(decimalPartStr);\r\n\r\n            if (bytes(decimalPartStr).length == 0) {\r\n                return wholeNumberStr;\r\n            }\r\n\r\n            return string(abi.encodePacked(wholeNumberStr, \".\", decimalPartStr));\r\n        }\r\n    }\r\n\r\n    function _removeTrailingZeros(string memory str) internal pure returns (string memory) {\r\n        unchecked {\r\n            bytes memory strBytes = bytes(str);\r\n            uint256 end = strBytes.length;\r\n\r\n            while (end != 0 && strBytes[end - 1] == \"0\") {\r\n                --end;\r\n            }\r\n\r\n            bytes memory trimmedBytes = new bytes(end);\r\n            for (uint256 i; i != end; ++i) {\r\n                trimmedBytes[i] = strBytes[i];\r\n            }\r\n\r\n            return string(trimmedBytes);\r\n        }\r\n    }\r\n\r\n    function _toString(uint256 value) internal pure returns (string memory str) {\r\n        assembly (\"memory-safe\") {\r\n            str := add(mload(0x40), 0x80)\r\n            mstore(0x40, add(str, 0x20))\r\n            mstore(str, 0)\r\n            let end := str\r\n            let w := not(0)\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w)\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n            let length := sub(end, str)\r\n            str := sub(str, 0x20)\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    function transferOwnership(address to) public payable onlyOwner {\r\n        emit OwnershipTransferred(msg.sender, owner = to);\r\n    }\r\n\r\n    error Unauthorized();\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert Unauthorized();\r\n        _;\r\n    }\r\n}\r\n\r\ninterface IBalanceOf {\r\n    function balanceOf(address) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV3PoolState {\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pricePool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balancesOf\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"balance\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"usd\",\"type\":\"string\"}],\"internalType\":\"struct BalanceChecker.Balance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balancesOfRaw\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btcPrice\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPrice\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_ethPrice\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_btcPrice\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pricePool\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registered\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "BalanceChecker", "CompilerVersion": "v0.8.26+commit.8a97fa7a", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "000000000000000000000000999657a41753b8e69c66e7b1a8e37d513cb44e1c", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://79f296e3bbe83aa8760d57b453e8239c009eaadb1123f1e08efe6167f6bf720b"}