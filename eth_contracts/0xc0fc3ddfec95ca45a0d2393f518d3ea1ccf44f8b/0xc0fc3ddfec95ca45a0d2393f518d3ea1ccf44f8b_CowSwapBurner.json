{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title CowSwapBurner\r\n@license MIT\r\n@author Curve Finance\r\n@notice Exchange tokens using CowSwap\r\n\"\"\"\r\n\r\n\r\ninterface ERC20:\r\n    def approve(_to: address, _value: uint256): nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n\r\n\r\nstruct Transfer:\r\n    coin: ERC20\r\n    to: address\r\n    amount: uint256  # 2^256-1 for the whole balance\r\n\r\nenum Epoch:\r\n    SLEEP  # 1\r\n    COLLECT  # 2\r\n    EXCHANGE  # 4\r\n    FORWARD  # 8\r\n\r\ninterface FeeCollector:\r\n    def fee(_epoch: Epoch=empty(Epoch), _ts: uint256=block.timestamp) -> uint256: view\r\n    def target() -> ERC20: view\r\n    def owner() -> address: view\r\n    def emergency_owner() -> address: view\r\n    def epoch_time_frame(epoch: Epoch, ts: uint256=block.timestamp) -> (uint256, uint256): view\r\n    def can_exchange(_coins: DynArray[ERC20, MAX_COINS_LEN]) -> bool: view\r\n    def transfer(_transfers: DynArray[Transfer, MAX_COINS_LEN]): nonpayable\r\n\r\nMAX_COINS_LEN: constant(uint256) = 64\r\nONE: constant(uint256) = 10 ** 18  # Precision\r\nfee_collector: public(immutable(FeeCollector))\r\n\r\n\r\nstruct GPv2Order_Data:\r\n    sellToken: ERC20  # token to sell\r\n    buyToken: ERC20  # token to buy\r\n    receiver: address  # receiver of the token to buy\r\n    sellAmount: uint256\r\n    buyAmount: uint256\r\n    validTo: uint32  # timestamp until order is valid\r\n    appData: bytes32  # extra info about the order\r\n    feeAmount: uint256  # amount of fees in sellToken\r\n    kind: bytes32  # buy or sell\r\n    partiallyFillable: bool  # partially fillable (True) or fill-or-kill (False)\r\n    sellTokenBalance: bytes32  # From where the sellToken balance is withdrawn\r\n    buyTokenBalance: bytes32  # Where the buyToken is deposited\r\n\r\nstruct ConditionalOrderParams:\r\n    # The contract implementing the conditional order logic\r\n    handler: address  # self\r\n    # Allows for multiple conditional orders of the same type and data\r\n    salt: bytes32  # Not used for now\r\n    # Data available to ALL discrete orders created by the conditional order\r\n    staticData: Bytes[STATIC_DATA_LEN]  # Using coin address\r\n\r\nstruct PayloadStruct:\r\n    proof: DynArray[bytes32, 32]\r\n    params: ConditionalOrderParams\r\n    offchainInput: Bytes[OFFCHAIN_DATA_LEN]\r\n\r\ninterface ComposableCow:\r\n    def create(params: ConditionalOrderParams, dispatch: bool): nonpayable\r\n    def domainSeparator() -> bytes32: view\r\n    def isValidSafeSignature(\r\n        safe: address, sender: address, _hash: bytes32, _domainSeparator: bytes32, typeHash: bytes32,\r\n        encodeData: Bytes[15 * 32],\r\n        payload: Bytes[(32 + 3 + 1 + 8) * 32],\r\n    ) -> bytes4: view\r\n\r\nSTATIC_DATA_LEN: constant(uint256) = 20\r\nOFFCHAIN_DATA_LEN: constant(uint256) = 1\r\n\r\nvault_relayer: public(immutable(address))\r\ncomposable_cow: public(immutable(ComposableCow))\r\nADD_DATA: public(constant(bytes32)) = 0x058315b749613051abcbf50cf2d605b4fa4a41554ec35d73fd058fc530da559f\r\nSELL_KIND: constant(bytes32) = keccak256(\"sell\")  # Surpluss in target coin\r\nTOKEN_BALANCE: constant(bytes32) = keccak256(\"erc20\")\r\n\r\n\r\n# SignatureVerifierMuxer at\r\n# https://github.com/rndlabs/safe-contracts/blob/11273c1f08eda18ed8ff49ec1d4abec5e451ff21/contracts/handler/extensible/SignatureVerifierMuxer.sol:\r\n# method_id(\"domainVerifiers(address,bytes32)\") == \"0x51cad5ee\"\r\n# method_id(\"setDomainVerifier(bytes32,address)\") == \"0x3365582c\"\r\nSIGNATURE_VERIFIER_MUXER_INTERFACE: constant(bytes4) = 0x62af8dc2\r\nERC1271_MAGIC_VALUE: constant(bytes4) = 0x1626ba7e\r\nSUPPORTED_INTERFACES: constant(bytes4[4]) = [\r\n    # ERC165: method_id(\"supportsInterface(bytes4)\") == 0x01ffc9a7\r\n    0x01ffc9a7,\r\n    # Burner:\r\n    #   method_id(\"burn(address[],address)\") == 0x72a436a8\r\n    #   method_id(\"push_target()\") == 0x2eb078cd\r\n    #   method_id(\"VERSION()\") == 0xffa1ad74\r\n    0xa3b5e311,\r\n    # Interface corresponding to IConditionalOrderGenerator:\r\n    #   method_id(\"getTradeableOrder(address,address,bytes32,bytes,bytes)\") == 0xb8296fc4\r\n    0xb8296fc4,\r\n    # ERC1271 interface:\r\n    #   method_id(\"isValidSignature(bytes32,bytes)\") == 0x1626ba7e\r\n    ERC1271_MAGIC_VALUE,\r\n]\r\nVERSION: public(constant(String[20])) = \"CowSwap\"\r\n\r\ncreated: public(HashMap[ERC20, bool])\r\n\r\ntarget_threshold: public(uint256)  # min amount to exchange\r\n\r\n\r\n@external\r\ndef __init__(_fee_collector: FeeCollector,\r\n    _composable_cow: ComposableCow, _vault_relayer: address, _target_threshold: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _fee_collector FeeCollector to anchor to\r\n    @param _composable_cow Address of ComposableCow contract\r\n    @param _vault_relayer CowSwap's VaultRelayer contract address, all approves go there\r\n    @param _target_threshold Minimum amount of target to buy per order\r\n    \"\"\"\r\n    fee_collector = _fee_collector\r\n    vault_relayer = _vault_relayer\r\n    composable_cow = _composable_cow\r\n\r\n    assert _target_threshold > 0, \"Bad target threshold\"\r\n    self.target_threshold = _target_threshold\r\n\r\n\r\n@external\r\ndef burn(_coins: DynArray[ERC20, MAX_COINS_LEN], _receiver: address):\r\n    \"\"\"\r\n    @notice Post hook after collect to register coins for burn\r\n    @dev Registers new orders in ComposableCow\r\n    @param _coins Which coins to burn\r\n    @param _receiver Receiver of profit\r\n    \"\"\"\r\n    assert msg.sender == fee_collector.address, \"Only FeeCollector\"\r\n\r\n    fee: uint256 = fee_collector.fee(Epoch.COLLECT)\r\n    fee_payouts: DynArray[Transfer, MAX_COINS_LEN] = []\r\n    self_transfers: DynArray[Transfer, MAX_COINS_LEN] = []\r\n    for coin in _coins:\r\n        if not self.created[coin]:\r\n            composable_cow.create(ConditionalOrderParams({\r\n                handler: self,\r\n                salt: empty(bytes32),\r\n                staticData: concat(b\"\", convert(coin.address, bytes20)),\r\n            }), True)\r\n            coin.approve(vault_relayer, max_value(uint256))\r\n            self.created[coin] = True\r\n        amount: uint256 = coin.balanceOf(fee_collector.address) * fee / ONE\r\n        fee_payouts.append(Transfer({coin: coin, to: _receiver, amount: amount}))\r\n        self_transfers.append(Transfer({coin: coin, to: self, amount: max_value(uint256)}))\r\n\r\n    fee_collector.transfer(fee_payouts)\r\n    fee_collector.transfer(self_transfers)\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_order(sell_token: ERC20) -> GPv2Order_Data:\r\n    buy_token: ERC20 = fee_collector.target()\r\n    return GPv2Order_Data({\r\n        sellToken: sell_token,  # token to sell\r\n        buyToken: buy_token,  # token to buy\r\n        receiver: fee_collector.address,  # receiver of the token to buy\r\n        sellAmount: 0,  # Set later\r\n        buyAmount: self.target_threshold,\r\n        validTo: convert(fee_collector.epoch_time_frame(Epoch.EXCHANGE)[1], uint32),  # timestamp until order is valid\r\n        appData: ADD_DATA,  # extra info about the order\r\n        feeAmount: 0,  # amount of fees in sellToken\r\n        kind: SELL_KIND,  # buy or sell\r\n        partiallyFillable: True,  # partially fillable (True) or fill-or-kill (False)\r\n        sellTokenBalance: TOKEN_BALANCE,  # From where the sellToken balance is withdrawn\r\n        buyTokenBalance: TOKEN_BALANCE,  # Where the buyToken is deposited\r\n    })\r\n\r\n\r\n@view\r\n@external\r\ndef get_current_order(sell_token: address=empty(address)) -> GPv2Order_Data:\r\n    \"\"\"\r\n    @notice Get current order parameters\r\n    @param sell_token Address of possible sell token\r\n    @return Order parameters\r\n    \"\"\"\r\n    return self._get_order(ERC20(sell_token))\r\n\r\n\r\n@view\r\n@external\r\ndef getTradeableOrder(_owner: address, _sender: address, _ctx: bytes32, _static_input: Bytes[STATIC_DATA_LEN], _offchain_input: Bytes[OFFCHAIN_DATA_LEN]) -> GPv2Order_Data:\r\n    \"\"\"\r\n    @notice Generate order for WatchTower\r\n    @dev _owner, _sender, _ctx, _offchain_input are ignored\r\n    @param _owner Owner of order (self)\r\n    @param _sender `msg.sender` context calling `isValidSignature`\r\n    @param _ctx Execution context\r\n    @param _static_input sellToken encoded as bytes(Bytes[20])\r\n    @param _offchain_input Not used, zero-length bytes\r\n    @return Order parameters\r\n    \"\"\"\r\n    sell_token: ERC20 = ERC20(convert(convert(_static_input, bytes20), address))\r\n    order: GPv2Order_Data = self._get_order(sell_token)\r\n    order.sellAmount = sell_token.balanceOf(self)\r\n\r\n    if order.sellAmount == 0 or not fee_collector.can_exchange([sell_token]):\r\n        start: uint256 = 0\r\n        end: uint256 = 0\r\n        start, end = fee_collector.epoch_time_frame(Epoch.EXCHANGE)\r\n        if block.timestamp >= start:\r\n            start, end = fee_collector.epoch_time_frame(Epoch.EXCHANGE, block.timestamp + 7 * 24 * 3600)\r\n        reason: String[11] = \"ZeroBalance\"\r\n        if order.sellAmount != 0:  # FeeCollector reject\r\n            reason = \"NotAllowed\"\r\n        raw_revert(_abi_encode(start, reason, method_id=method_id(\"PollTryAtEpoch(uint256,string)\")))\r\n\r\n    return order\r\n\r\n\r\n@view\r\n@external\r\ndef verify(\r\n    _owner: address,\r\n    _sender: address,\r\n    _hash: bytes32,\r\n    _domain_separator: bytes32,\r\n    _ctx: bytes32,\r\n    _static_input: Bytes[STATIC_DATA_LEN],\r\n    _offchain_input: Bytes[OFFCHAIN_DATA_LEN],\r\n    _order: GPv2Order_Data,\r\n):\r\n    \"\"\"\r\n    @notice Verify order\r\n    @dev Called from ComposableCow. _owner, _sender, _hash, _domain_separator, _ctx are ignored.\r\n    @param _owner Owner of conditional order (self)\r\n    @param _sender `msg.sender` context calling `isValidSignature`\r\n    @param _hash `EIP-712` order digest\r\n    @param _domain_separator `EIP-712` domain separator\r\n    @param _ctx Execution context\r\n    @param _static_input ConditionalOrder's staticData (coin address)\r\n    @param _offchain_input Conditional order type-specific data NOT known at time of creation for a specific discrete order (or zero-length bytes if not applicable)\r\n    @param _order The proposed discrete order's `GPv2Order.Data` struct\r\n    \"\"\"\r\n    sell_token: ERC20 = ERC20(convert(convert(_static_input, bytes20), address))\r\n    if not fee_collector.can_exchange([sell_token]):\r\n        raw_revert(_abi_encode(\"NotAllowed\", method_id=method_id(\"OrderNotValid(string)\")))\r\n    if _offchain_input != b\"\":\r\n        raw_revert(_abi_encode(\"NonZeroOffchainInput\", method_id=method_id(\"OrderNotValid(string)\")))\r\n    order: GPv2Order_Data = self._get_order(sell_token)\r\n    order.sellAmount = _order.sellAmount  # Any amount allowed\r\n    order.buyAmount = max(_order.buyAmount, order.buyAmount)  # Price is discovered within CowSwap competition\r\n    if _abi_encode(order) != _abi_encode(_order):\r\n        raw_revert(_abi_encode(\"BadOrder\", method_id=method_id(\"OrderNotValid(string)\")))\r\n\r\n\r\n@view\r\n@external\r\ndef isValidSignature(_hash: bytes32, signature: Bytes[1792]) -> bytes4:\r\n    \"\"\"\r\n    @notice ERC1271 signature verifier method\r\n    @dev Forwards query to ComposableCow\r\n    @param _hash Hash of signed object. Ignored here\r\n    @param signature Signature for the object. (GPv2Order.Data, PayloadStruct) here\r\n    @return `ERC1271_MAGIC_VALUE` if signature is OK\r\n    \"\"\"\r\n    order: GPv2Order_Data = empty(GPv2Order_Data)\r\n    payload: PayloadStruct = empty(PayloadStruct)\r\n    order, payload = _abi_decode(signature, (GPv2Order_Data, PayloadStruct))\r\n\r\n    return composable_cow.isValidSafeSignature(self, msg.sender, _hash, composable_cow.domainSeparator(), empty(bytes32),\r\n        _abi_encode(order),\r\n        _abi_encode(payload),\r\n    )\r\n\r\n\r\n@external\r\ndef push_target() -> uint256:\r\n    \"\"\"\r\n    @notice In case target coin is left in contract can be pushed to forward\r\n    @return Amount of coin pushed further\r\n    \"\"\"\r\n    target: ERC20 = fee_collector.target()\r\n    amount: uint256 = target.balanceOf(self)\r\n    if amount > 0:\r\n        target.transfer(fee_collector.address, amount)\r\n    return amount\r\n\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(_interface_id: bytes4) -> bool:\r\n    \"\"\"\r\n    @dev Interface identification is specified in ERC-165.\r\n    Fails on SignatureVerifierMuxer for compatability with ComposableCow.\r\n    @param _interface_id Id of the interface\r\n    @return True if contract supports given interface\r\n    \"\"\"\r\n    assert _interface_id != SIGNATURE_VERIFIER_MUXER_INTERFACE\r\n    return _interface_id in SUPPORTED_INTERFACES\r\n\r\n\r\n@external\r\ndef set_target_threshold(_target_threshold: uint256):\r\n    \"\"\"\r\n    @dev Callable only by owner\r\n    @param _target_threshold Minimum amount of target to receive, with base=10**18\r\n    \"\"\"\r\n    assert msg.sender == fee_collector.owner(), \"Only owner\"\r\n    assert _target_threshold > 0, \"Bad target threshold\"\r\n\r\n    self.target_threshold = _target_threshold\r\n\r\n\r\n@external\r\ndef recover(_coins: DynArray[ERC20, MAX_COINS_LEN]):\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens or Ether from this contract\r\n    @dev Callable only by owner and emergency owner\r\n    @param _coins Token addresses\r\n    \"\"\"\r\n    assert msg.sender in [fee_collector.owner(), fee_collector.emergency_owner()], \"Only owner\"\r\n\r\n    for coin in _coins:\r\n        if coin.address == ETH_ADDRESS:\r\n            raw_call(fee_collector.address, b\"\", value=self.balance)\r\n        else:\r\n            coin.transfer(fee_collector.address, coin.balanceOf(self))  # do not need safe transfer", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_fee_collector\",\"type\":\"address\"},{\"name\":\"_composable_cow\",\"type\":\"address\"},{\"name\":\"_vault_relayer\",\"type\":\"address\"},{\"name\":\"_target_threshold\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_current_order\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"name\":\"validTo\",\"type\":\"uint32\"},{\"name\":\"appData\",\"type\":\"bytes32\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"kind\",\"type\":\"bytes32\"},{\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_current_order\",\"inputs\":[{\"name\":\"sell_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"name\":\"validTo\",\"type\":\"uint32\"},{\"name\":\"appData\",\"type\":\"bytes32\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"kind\",\"type\":\"bytes32\"},{\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getTradeableOrder\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_ctx\",\"type\":\"bytes32\"},{\"name\":\"_static_input\",\"type\":\"bytes\"},{\"name\":\"_offchain_input\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"name\":\"validTo\",\"type\":\"uint32\"},{\"name\":\"appData\",\"type\":\"bytes32\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"kind\",\"type\":\"bytes32\"},{\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"verify\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_domain_separator\",\"type\":\"bytes32\"},{\"name\":\"_ctx\",\"type\":\"bytes32\"},{\"name\":\"_static_input\",\"type\":\"bytes\"},{\"name\":\"_offchain_input\",\"type\":\"bytes\"},{\"name\":\"_order\",\"type\":\"tuple\",\"components\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"name\":\"validTo\",\"type\":\"uint32\"},{\"name\":\"appData\",\"type\":\"bytes32\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"kind\",\"type\":\"bytes32\"},{\"name\":\"partiallyFillable\",\"type\":\"bool\"},{\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}]}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isValidSignature\",\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"push_target\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"_interface_id\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_target_threshold\",\"inputs\":[{\"name\":\"_target_threshold\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_collector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_relayer\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"composable_cow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ADD_DATA\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"VERSION\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"created\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"target_threshold\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "CowSwapBurner", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000a2bcd1a4efbd04b63cd03f5aff2561106ebcce00000000000000000000000000fdafc9d1902f4e0b84f65f49f244b32b31013b74000000000000000000000000c92e8bdf79f0507f65a392b0ab4667716bfe0110000000000000000000000000000000000000000000000002b5e3af16b1880000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}