{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CrossChainLiquidityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {OwnableOperable} from \\\"./ownership/OwnableOperable.sol\\\";\\n\\nimport {CCIPReceiver} from \\\"@ccip/applications/CCIPReceiver.sol\\\";\\nimport {Client} from \\\"@ccip/libraries/Client.sol\\\";\\nimport {IRouterClient} from \\\"@ccip/interfaces/IRouterClient.sol\\\";\\nimport {IARM} from \\\"@ccip/interfaces/IARM.sol\\\";\\n\\nimport {IERC20, ICCIPRouter} from \\\"./Interfaces.sol\\\";\\n\\ncontract CrossChainLiquidityManager is OwnableOperable, CCIPReceiver {\\n    uint256 public traderate;\\n\\n    uint256 public pendingFee;\\n    address public feeRecipient;\\n\\n    bool internal initialized;\\n\\n    mapping(bytes32 => bool) public messageProcessed;\\n\\n    mapping(address => uint256) public pendingUserBalance;\\n\\n    uint256 public additionalLiquidityNeeded;\\n\\n    uint64 public immutable otherChainSelector;\\n    address public immutable otherChainLiquidityManager;\\n\\n    address public constant token0 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant token1 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n \\n    event FeeRecipientChanged(address oldRecipient, address newRecipient);\\n    event FeeCollected(address recipient, uint256 fee);\\n    event TradeRateChanged(uint256 oldRate, uint256 newRate);\\n    event PendingBalanceClaimed(address recipient, uint256 amount);\\n    event TransferInitiated(bytes32 messageId);\\n    event TransferCompleted(bytes32 messageId);\\n    event PendingBalanceUpdated(address recipient, uint256 balance);\\n    event LiquidityUpdated();\\n\\n    error ETHTransferFailed();\\n    error NoFeeRecipientSet();\\n    error UnsupportedFromToken();\\n    error UnsupportedToToken();\\n    error SlippageError();\\n    error InvalidAmountIn();\\n    error CCIPRouterIsCursed();\\n    error InvalidSourceChainSelector();\\n    error CallerIsNotOtherChainLiquidityManager();\\n    error InsufficientLiquidity();\\n    error CCIPMessageReplay();\\n    error AlreadyInitialized();\\n\\n    /**\\n     * @dev Reverts if CCIP's Risk Management contract (ARM) is cursed\\n     */\\n    modifier onlyIfNotCursed() {\\n        IARM arm = IARM(ICCIPRouter(this.getRouter()).getArmProxy());\\n\\n        if (arm.isCursed()) {\\n            revert CCIPRouterIsCursed();\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyOtherChainLiquidityManager(uint64 chainSelector, address sender) {\\n        if (chainSelector != otherChainSelector) {\\n            // Ensure it's from mainnet\\n            revert InvalidSourceChainSelector();\\n        }\\n\\n        if (sender != otherChainLiquidityManager) {\\n            // Ensure it's from the other chain's pool manager\\n            revert CallerIsNotOtherChainLiquidityManager();\\n        }\\n\\n        _;\\n    }\\n\\n    constructor (address _l2Router, uint64 _otherChainSelector, address _otherChainLiquidityManager) CCIPReceiver(_l2Router) {\\n        // Make sure nobody owns the implementation\\n        _setOwner(address(0));\\n\\n        otherChainSelector = _otherChainSelector;\\n        otherChainLiquidityManager = _otherChainLiquidityManager;\\n    }\\n\\n    function initialize(address _feeRecipient, uint256 _traderate) external onlyOwner {\\n        if (initialized) {\\n            revert AlreadyInitialized();\\n        }\\n        initialized = false;\\n        _setFeeRecipient(_feeRecipient);\\n        _setTradeRate(_traderate);\\n    }\\n\\n    function _setFeeRecipient(address _feeRecipient) internal {\\n        emit FeeRecipientChanged(feeRecipient, _feeRecipient);\\n        feeRecipient = _feeRecipient;\\n    }\\n\\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\\n        _setFeeRecipient(_feeRecipient);\\n    }\\n\\n    function _setTradeRate(uint256 _traderate) internal {\\n        // TODO: Set lower and upper bounds\\n        // Make sure it also accounts for CCIP and redemption fees\\n        emit TradeRateChanged(traderate, _traderate);\\n        traderate = _traderate;\\n    }\\n\\n    function setTradeRate(uint256 _traderate) external onlyOperatorOrOwner {\\n        _setTradeRate(_traderate);\\n    }\\n\\n    function _transferEth(address receiver, uint256 amount) internal {\\n        (bool success,) = receiver.call{value: amount}(new bytes(0));\\n        if (!success) {\\n            revert ETHTransferFailed();\\n        }\\n    }\\n\\n    function collectFees() external {\\n        address _recipient = feeRecipient;\\n        if (_recipient == address(0)) {\\n            revert NoFeeRecipientSet();\\n        }\\n\\n        uint256 _fee = pendingFee;\\n        if (_fee > 0) {\\n            pendingFee = 0;\\n            _transferEth(_recipient, _fee);\\n            emit FeeCollected(_recipient, _fee);\\n        }\\n    }\\n\\n    function swapExactTokensForTokens(\\n        address inToken,\\n        address outToken,\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address to\\n    ) external payable returns (bytes32 messageId) {\\n        if (inToken != token0) {\\n            revert UnsupportedToToken();\\n        }\\n\\n        if (outToken != token1) {\\n            revert UnsupportedToToken();\\n        }\\n\\n        if (msg.value != amountIn) {\\n            revert InvalidAmountIn();\\n        }\\n\\n        // TODO: Account for CCIP Fees\\n        uint256 amountOut = (traderate * amountIn) / 1 ether;\\n\\n        if (amountOut < amountOutMin) {\\n            revert SlippageError();\\n        }\\n\\n        // Calc profit (assuming 1:1 peg)\\n        uint256 estimatedFeeEarned = amountIn - amountOut;\\n        pendingFee += estimatedFeeEarned;\\n\\n        // Build CCIP message\\n        IRouterClient router = IRouterClient(this.getRouter());\\n\\n        bytes memory extraArgs = hex\\\"\\\";\\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](0);\\n\\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\\n            receiver: abi.encode(otherChainLiquidityManager),\\n            data: abi.encode(to, amountOut),\\n            tokenAmounts: tokenAmounts,\\n            extraArgs: extraArgs,\\n            feeToken: address(0)\\n        });\\n\\n        uint256 ccipFees = router.getFee(otherChainSelector, message);\\n\\n        // TODO: ccipFee not accounted for\\n        // if (estimatedFeeEarned < ccipFees) {\\n        //     revert NonProfitableTrade();\\n        // }\\n\\n        // Send message to other chain\\n        messageId = router.ccipSend{ value: ccipFees }(\\n            otherChainSelector,\\n            message\\n        );\\n\\n        emit TransferInitiated(messageId);\\n    }\\n\\n    function _ccipReceive(Client.Any2EVMMessage memory message)\\n        internal\\n        override\\n        onlyOtherChainLiquidityManager(\\n            message.sourceChainSelector,\\n            abi.decode(message.sender, (address))\\n        )\\n        onlyIfNotCursed\\n    {\\n        if (messageProcessed[message.messageId]) {\\n            revert CCIPMessageReplay();\\n        }\\n        messageProcessed[message.messageId] = true;\\n\\n        (address recipient, uint256 amount) = abi.decode(message.data, (address, uint256));\\n\\n        if (amount <= address(this).balance) {\\n            // Transfer if there's enough liquidity\\n            _transferEth(recipient, amount);\\n            emit TransferCompleted(message.messageId);\\n        } else {\\n            // Make it claimable if liquidity is insufficient\\n            uint256 currBalance = pendingUserBalance[recipient];\\n            pendingUserBalance[recipient] = currBalance + amount;\\n            additionalLiquidityNeeded += amount;\\n            emit PendingBalanceUpdated(recipient, currBalance + amount);\\n        }\\n    }\\n\\n    function claimPendingBalance() external {\\n        uint256 amount = pendingUserBalance[msg.sender];\\n\\n        if (amount > address(this).balance) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        emit PendingBalanceClaimed(msg.sender, amount);\\n        pendingUserBalance[msg.sender] = 0;\\n        _transferEth(msg.sender, amount);\\n    }\\n\\n    function addLiquidity() public payable {\\n        uint256 _liquidityNeeded = additionalLiquidityNeeded;\\n        // Accept all ETH sent to this address as liquidity\\n        if (_liquidityNeeded >= msg.value) {\\n            additionalLiquidityNeeded = _liquidityNeeded - msg.value;\\n        }  else if (_liquidityNeeded != 0) {\\n            additionalLiquidityNeeded = 0;\\n        }\\n\\n        emit LiquidityUpdated();\\n    }\\n\\n    receive() external payable {\\n        addLiquidity();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ownership/OwnableOperable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\ncontract OwnableOperable is Ownable {\\n    // keccak256(\u201ceip1967.proxy.operator\u201d) - 1, inspired by EIP 1967\\n    bytes32 internal constant OPERATOR_SLOT = 0x14cc265c8475c78633f4e341e72b9f4f0d55277c8def4ad52d79e69580f31482;\\n\\n    event OperatorChanged(address previousAdmin, address newAdmin);\\n\\n    constructor() {\\n        assert(OPERATOR_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.operator\\\")) - 1));\\n    }\\n\\n    function operator() external view returns (address) {\\n        return _operator();\\n    }\\n\\n    function setOperator(address newOperator) external onlyOwner {\\n        _setOperator(newOperator);\\n    }\\n\\n    function _operator() internal view returns (address operatorOut) {\\n        bytes32 position = OPERATOR_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            operatorOut := sload(position)\\n        }\\n    }\\n\\n    function _setOperator(address newOperator) internal {\\n        emit OperatorChanged(_operator(), newOperator);\\n        bytes32 position = OPERATOR_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newOperator)\\n        }\\n    }\\n\\n    modifier onlyOperatorOrOwner() {\\n        require(\\n            msg.sender == _operator() || msg.sender == _owner(), \\\"OSwap: Only operator or owner can call this function.\\\"\\n        );\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"../interfaces/IAny2EVMMessageReceiver.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\nimport {IERC165} from \\\"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\\n  address internal immutable i_ccipRouter;\\n\\n  constructor(address router) {\\n    if (router == address(0)) revert InvalidRouter(address(0));\\n    i_ccipRouter = router;\\n  }\\n\\n  /// @notice IERC165 supports an interfaceId\\n  /// @param interfaceId The interfaceId to check\\n  /// @return true if the interfaceId is supported\\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\\n  /// This allows CCIP to check if ccipReceive is available before calling it.\\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\\n  /// Additionally, if the receiver address does not have code associated with\\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc IAny2EVMMessageReceiver\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\\n    _ccipReceive(message);\\n  }\\n\\n  /// @notice Override this function in your implementation.\\n  /// @param message Any2EVMMessage\\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  // Plumbing\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Return the current router\\n  /// @return CCIP router address\\n  function getRouter() public view returns (address) {\\n    return address(i_ccipRouter);\\n  }\\n\\n  error InvalidRouter(address router);\\n\\n  /// @dev only calls from the set router are accepted.\\n  modifier onlyRouter() {\\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param chainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\\n\\n  /// @notice Gets a list of all supported tokens which can be sent or received\\n  /// to/from a given chain id.\\n  /// @param chainSelector The chainSelector.\\n  /// @return tokens The addresses of all tokens that are supported.\\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\\n\\n  /// @param destinationChainSelector The destination chainSelector\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return fee returns execution fee for the message\\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain\\n  /// @param destinationChainSelector The destination chain ID\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return messageId The message ID\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\\n  /// the overpayment with no refund.\\n  /// @dev Reverts with appropriate reason upon invalid message.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IARM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only ARM-related functions that might be used on-chain by other CCIP contracts.\\ninterface IARM {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(TaggedRoot calldata taggedRoot) external view returns (bool);\\n\\n  /// @notice When the ARM is \\\"cursed\\\", CCIP pauses until the curse is lifted.\\n  function isCursed() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface ICCIPRouter {\\n    function getArmProxy() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/ownership/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\ncontract Ownable {\\n    // keccak256(\u201ceip1967.proxy.admin\u201d) - per EIP 1967\\n    bytes32 internal constant OWNER_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    constructor() {\\n        assert(OWNER_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setOwner(msg.sender);\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner();\\n    }\\n\\n    function setOwner(address newOwner) external onlyOwner {\\n        _setOwner(newOwner);\\n    }\\n\\n    function _owner() internal view returns (address ownerOut) {\\n        bytes32 position = OWNER_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ownerOut := sload(position)\\n        }\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        emit AdminChanged(_owner(), newOwner);\\n        bytes32 position = OWNER_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newOwner)\\n        }\\n    }\\n\\n    function _onlyOwner() internal view {\\n        require(msg.sender == _owner(), \\\"OSwap: Only owner can call this function.\\\");\\n    }\\n\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from\\n/// the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message.\\n  /// If this reverts, any token transfers also revert. The message\\n  /// will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ccip/=node_modules/@chainlink/contracts-ccip/src/v0.8/ccip/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2Router\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_otherChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_otherChainLiquidityManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCIPMessageReplay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCIPRouterIsCursed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOtherChainLiquidityManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ETHTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmountIn\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSourceChainSelector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoFeeRecipientSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlippageError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedFromToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedToToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"FeeRecipientChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LiquidityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PendingBalanceClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"PendingBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"TradeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"TransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"TransferInitiated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"additionalLiquidityNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPendingBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_traderate\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"messageProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherChainLiquidityManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_traderate\",\"type\":\"uint256\"}],\"name\":\"setTradeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traderate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CrossChainLiquidityManager", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000080226fc0ee2b096224eeac085bb9a8cba1146f7d00000000000000000000000000000000000000000000000044ae84d8e9a37444000000000000000000000000a6774b8a0c61e724bda845b22b0acb42c4f5c100", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}