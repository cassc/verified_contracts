{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Miner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./Bank.sol\\\";\\n\\ncontract Miner is ReentrancyGuard {\\n    address public owner;\\n\\n    uint256 public apy;\\n\\n    address private bank;\\n\\n    uint256 public transaction_fee;\\n\\n    uint256 public referral_fee;\\n\\n    uint256 public penalty_fee;\\n\\n    uint256 public minDuration;\\n\\n    uint256 public minDeposit = 0.01 ether;\\n\\n    address private transactionFeeWallet;\\n\\n    address private penaltyFeeWallet;\\n\\n    struct User {\\n        address user;\\n        uint256 amount;\\n        uint256 roi;\\n        address referee;\\n        address[] referrals;\\n        uint256 referralBalance;\\n        uint256 lastDeposited;\\n        uint256 lastClaimed;\\n        bool claimed;\\n    }\\n\\n    User[] public users;\\n\\n    mapping (address => User) public user;\\n\\n    event User_Created(address indexed user);\\n\\n    event Mine(address indexed user, uint256 amount);\\n\\n    event ReMine(address indexed user, uint256 amount);\\n\\n    event Claim(address indexed user, uint256 amount);\\n\\n    event Withdraw(address indexed user, uint256 amount);\\n\\n    constructor(uint256 _apy, uint256 tFee, uint256 rFee, uint256 pFee, uint256 _duration, address _bank, address wallet1, address wallet2) {\\n        owner = msg.sender;\\n\\n        apy = _apy;\\n\\n        require(tFee <= 5, \\\"Transaction fee cannot exceed 5%\\\");\\n\\n        require(rFee <= 5, \\\"Referral fee cannot exceed 5%\\\");\\n\\n        require(pFee <= 50, \\\"Penalty fee cannot exceed 50%\\\");\\n\\n        transaction_fee = tFee;\\n\\n        referral_fee = rFee;\\n\\n        penalty_fee = pFee;\\n\\n        minDuration = _duration * 86400;\\n\\n        require(_bank != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        require(wallet1 != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        require(wallet2 != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        bank = _bank;\\n\\n        transactionFeeWallet = wallet1;\\n\\n        penaltyFeeWallet = wallet2;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    function changeAPY(uint256 _apy) public onlyOwner {\\n        apy = _apy;\\n    }\\n\\n    function changeTransactionFee(uint256 tFee) public onlyOwner {\\n        require(tFee <= 5, \\\"Transaction fee cannot exceed 5%\\\");\\n\\n        transaction_fee = tFee;\\n    }\\n\\n    function changeReferralFee(uint256 rFee) public onlyOwner {\\n        require(rFee <= 5, \\\"Referral fee cannot exceed 5%\\\");\\n\\n        referral_fee = rFee;\\n    }\\n\\n    function changePenaltyFee(uint256 pFee) public onlyOwner {\\n        require(pFee <= 50, \\\"Penalty fee cannot exceed 50%\\\");\\n        \\n        penalty_fee = pFee;\\n    }\\n\\n    function changeMinDeposit(uint256 _deposit) public onlyOwner {\\n        minDeposit = _deposit;\\n    }\\n\\n    function changeMinDuration(uint256 _duration) public onlyOwner {\\n        minDuration = _duration * 86400;\\n    }\\n\\n    function changeTFeeWallet(address tFeeWallet) public onlyOwner {\\n        require(tFeeWallet != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        transactionFeeWallet = tFeeWallet;\\n    }\\n\\n    function changePFeeWallet(address pFeeWallet) public onlyOwner {\\n        require(pFeeWallet != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        penaltyFeeWallet = pFeeWallet;\\n    }\\n\\n    function changeBank(address _bank) public onlyOwner {\\n        require(_bank != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        bank = _bank;\\n    }\\n\\n    function userExists(address _user) internal view returns (bool) {\\n        bool user_exist = false;\\n\\n        for(uint256 i = 0; i < users.length; i++) {\\n            if(users[i].user == _user) {\\n                user_exist = true;\\n\\n                break;\\n            }\\n        }\\n\\n        return user_exist;\\n    }\\n\\n    function createUser(address user_, uint256 _amount, uint256 _roi, address _referee) internal {\\n        address[] memory _referrals;\\n\\n\\n        User memory _user = User({\\n            user: user_,\\n            amount: _amount,\\n            roi: _roi,\\n            referee: _referee,\\n            referrals: _referrals,\\n            referralBalance: 0,\\n            lastDeposited: block.timestamp,\\n            lastClaimed: 0,\\n            claimed: false\\n        });\\n\\n        users.push(_user);\\n\\n        user[user_] = _user;\\n\\n        emit User_Created(user_);\\n    }\\n\\n    function mine(address _referee) public payable {\\n        require(msg.value >= minDeposit, \\\"Insufficent deposit amount.\\\");\\n\\n        uint256 tFee = (transaction_fee * msg.value) / 100;\\n\\n        uint256 amount = msg.value - tFee;\\n\\n        if(userExists(msg.sender)) {\\n            User storage _user = user[msg.sender];\\n            uint256 total = amount + _user.amount;\\n            uint256 _roi = (apy * total) / 100;\\n\\n            _user.amount = total;\\n            _user.roi = _roi;\\n            _user.lastDeposited = block.timestamp;\\n        } else {\\n            uint256 _roi = (apy * amount) / 100;\\n\\n            createUser(msg.sender, amount, _roi, _referee);\\n\\n            if(_referee != address(0)) {\\n                User storage referee = user[_referee];\\n                referee.referrals.push(msg.sender);\\n            }\\n        }\\n\\n        (bool os, ) = payable(bank).call{value: amount}(\\\"\\\");\\n        require(os, \\\"Bank transfer failed.\\\");\\n\\n        (bool os1, ) = payable(transactionFeeWallet).call{value: tFee}(\\\"\\\");\\n        require(os1, \\\"Transaction fee transfer failed.\\\");\\n\\n        emit Mine(msg.sender, amount);\\n    }\\n\\n    function re_mine() public {\\n        require(userExists(msg.sender), \\\"No user account detected.\\\");\\n\\n        User storage _user = user[msg.sender];\\n        \\n        uint256 duration;\\n\\n        if(_user.lastDeposited >= _user.lastClaimed) {\\n            duration = block.timestamp - _user.lastDeposited;\\n        } else {\\n            duration = block.timestamp - _user.lastClaimed;\\n        }\\n\\n        uint256 roi_mined;\\n\\n        if(duration >= minDuration) {\\n            roi_mined = (_user.roi * minDuration) / (365 * 86400);\\n        } else {\\n            roi_mined = (_user.roi * duration) / (365 * 86400);\\n        }\\n        \\n        uint256 total = _user.amount + roi_mined;\\n        uint256 _roi = (apy * total) / 100;\\n\\n        _user.amount = total;\\n        _user.roi = _roi;\\n        _user.lastDeposited = block.timestamp;\\n\\n        emit ReMine(msg.sender, _roi);\\n    }\\n\\n    function calculateRewards() internal view  returns (uint256) {\\n        require(userExists(msg.sender), \\\"No user account detected.\\\");\\n\\n        User storage _user = user[msg.sender];\\n        \\n        uint256 duration;\\n\\n        if(_user.lastDeposited >= _user.lastClaimed) {\\n            duration = block.timestamp - _user.lastDeposited;\\n        } else {\\n            duration = block.timestamp - _user.lastClaimed;\\n        }\\n\\n        uint256 amount;\\n\\n        if(duration >= minDuration) {\\n            uint256 roi_mined = (_user.roi * minDuration) / (365 * 86400);\\n\\n            amount = roi_mined;\\n        } else {\\n            uint256 roi_mined = (_user.roi * duration) / (365 * 86400);\\n\\n            amount = roi_mined;\\n        }\\n\\n        return  amount;\\n    }\\n\\n    function claimRewards() public nonReentrant {\\n        require(userExists(msg.sender), \\\"No user account detected.\\\");\\n\\n        uint256 rewards = calculateRewards();\\n\\n        uint256 tFee = (transaction_fee * rewards) / 100;\\n\\n        Bank _bank = Bank(payable(bank));\\n\\n        User storage _user = user[msg.sender];\\n        \\n        uint256 duration;\\n\\n        if(_user.lastDeposited >= _user.lastClaimed) {\\n            duration = block.timestamp - _user.lastDeposited;\\n        } else {\\n            duration = block.timestamp - _user.lastClaimed;\\n        }\\n\\n        uint256 amount;\\n\\n        if(duration >= minDuration) {\\n            uint256 rTax = 0;\\n\\n            if(_user.referee != address(0)) {\\n                rTax = (referral_fee * rewards) / 100;\\n\\n                User storage referee = user[_user.referee];\\n                referee.referralBalance += rTax;\\n            }\\n\\n            amount = rewards - (rTax + tFee);\\n        } else {\\n            uint256 rTax = 0;\\n            uint256 pTax = 0;\\n\\n            if(_user.claimed) {\\n                pTax = (penalty_fee * rewards) / 100;\\n            }\\n\\n            if(_user.referee != address(0)) {\\n                rTax = (referral_fee * rewards) / 100;\\n\\n                User storage referee = user[_user.referee];\\n                referee.referralBalance += rTax;\\n            }\\n\\n            amount = rewards - (rTax + pTax + tFee);\\n\\n            _bank.transfer(penaltyFeeWallet, pTax);\\n        }\\n\\n        _bank.transfer(msg.sender, amount);\\n\\n        _user.lastClaimed = block.timestamp;\\n\\n        _user.claimed = true;\\n\\n        _bank.transfer(transactionFeeWallet, tFee);\\n\\n        emit Claim(msg.sender, amount);\\n    }\\n\\n    function withdraw() public nonReentrant {\\n        require(userExists(msg.sender), \\\"No user account detected.\\\");\\n\\n        uint256 rewards = calculateRewards();\\n        \\n        uint256 tFee = (transaction_fee * rewards) / 100;\\n\\n        Bank _bank = Bank(payable(bank));\\n\\n        User storage _user = user[msg.sender];\\n        \\n        uint256 duration;\\n\\n        if(_user.lastDeposited >= _user.lastClaimed) {\\n            duration = block.timestamp - _user.lastDeposited;\\n        } else {\\n            duration = block.timestamp - _user.lastClaimed;\\n        }\\n\\n        uint256 amount;\\n\\n        if(duration >= minDuration) {\\n            uint256 rTax = 0;\\n\\n            if(_user.referee != address(0)) {\\n                rTax = (referral_fee * rewards) / 100;\\n\\n                User storage referee = user[_user.referee];\\n                referee.referralBalance += rTax;\\n            }\\n\\n            amount = (_user.amount + _user.referralBalance + rewards) - (rTax + tFee);\\n        } else {\\n            uint256 rTax = 0;\\n            uint256 pTax = (penalty_fee * (_user.amount + rewards)) / 100;\\n\\n            if(_user.referee != address(0)) {\\n                rTax = (referral_fee * rewards) / 100;\\n\\n                User storage referee = user[_user.referee];\\n                referee.referralBalance += rTax;\\n            }\\n\\n            amount = (_user.amount + _user.referralBalance + rewards) - (rTax + pTax + tFee);\\n\\n            _bank.transfer(penaltyFeeWallet, pTax);\\n        }\\n\\n        _bank.transfer(msg.sender, amount);\\n\\n        _user.amount = 0;\\n\\n        _user.roi = 0;\\n\\n        _user.referralBalance = 0;\\n\\n        _user.lastClaimed = block.timestamp;\\n\\n        _bank.transfer(transactionFeeWallet, tFee);\\n\\n        emit Withdraw(msg.sender, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Bank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\ncontract Bank {\\n    address public owner;\\n\\n    address public admin;\\n\\n    event Transfer(address indexed user, uint256 amount);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n    \\n    receive() external payable {}\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin {\\n        require(msg.sender == admin, \\\"Only admin can call this function.\\\");\\n        _;\\n    }\\n\\n    function setAdmin(address _admin) public onlyOwner {\\n        require(_admin != address(0), \\\"Do not pass a zero address.\\\");\\n\\n        admin = _admin;\\n    }\\n\\n    function transfer(address user, uint256 amount) public onlyAdmin {\\n        require(address(this).balance > amount, \\\"Insufficent funds.\\\");\\n\\n        (bool os, ) = payable(user).call{value: amount}(\\\"\\\");\\n        require(os);\\n\\n        emit Transfer(user, amount);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bank\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReMine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"User_Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"apy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"}],\"name\":\"changeAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bank\",\"type\":\"address\"}],\"name\":\"changeBank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"changeMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"changeMinDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pFeeWallet\",\"type\":\"address\"}],\"name\":\"changePFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pFee\",\"type\":\"uint256\"}],\"name\":\"changePenaltyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rFee\",\"type\":\"uint256\"}],\"name\":\"changeReferralFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tFeeWallet\",\"type\":\"address\"}],\"name\":\"changeTFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tFee\",\"type\":\"uint256\"}],\"name\":\"changeTransactionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referee\",\"type\":\"address\"}],\"name\":\"mine\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penalty_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"re_mine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referral_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transaction_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Miner", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000062a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000007000000000000000000000000b22e6273d66f1fb4f96ce9a9ee64af43f7c42b5c000000000000000000000000f2146f252be61d3afcaeea11ad2dc452c1f933cd000000000000000000000000757e90d7d03fba12a3076818ac03b1e8be494e75", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}