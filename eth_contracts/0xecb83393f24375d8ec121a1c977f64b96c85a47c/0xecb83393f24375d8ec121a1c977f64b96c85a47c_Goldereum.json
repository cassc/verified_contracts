{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Goldereum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity >=0.8.10 >=0.8.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\nTotalSupply: 1_000_000\\nTelegram: https://t.me/Goldereum\\nTwitter:  https://twitter.com/GoldereumERC\\nWebsite:  https://www.goldereum.net/\\n*/\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\n/* pragma solidity ^0.8.0; */\\n\\ninterface IERC20 {\\n \\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n////// lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\n/* pragma solidity ^0.8.0; */\\n\\n/* import \\\"../IERC20.sol\\\"; */\\ninterface IERC20Metadata is IERC20 {\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\n////// lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\\n\\n/* pragma solidity ^0.8.0; */\\n\\n/* import \\\"./IERC20.sol\\\"; */\\n/* import \\\"./extensions/IERC20Metadata.sol\\\"; */\\n/* import \\\"../../utils/Context.sol\\\"; */\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n \\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n \\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0x000000000000000000000000000000000000dEaD), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\\n////// lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\\n\\n/* pragma solidity ^0.8.0; */\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\nlibrary SafeMath {\\n\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n \\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n \\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\\n////// src/IUniswapV2Pair.sol\\n/* pragma solidity 0.8.10; */\\n/* pragma experimental ABIEncoderV2; */\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\n////// src/IUniswapV2Router02.sol\\n/* pragma solidity 0.8.10; */\\n/* pragma experimental ABIEncoderV2; */\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ncontract  Goldereum is ERC20, Ownable {\\n\\n    IUniswapV2Router02 public immutable _interfaceUniswapV2Router;\\n    address public immutable _interfaceUniswapV2Pair;\\n    address public constant destroyAddress = address(0xdead);\\n\\n    using SafeMath for uint256;\\n    bool private _flagSwapping;\\n    bool public _flagLpBurnEnabled = false;\\n    bool public flaglimitsInUse = true;\\n    bool public flagTradingsLive = false;\\n    bool public flgaSwapEnabled = false;\\n    bool public flagTransferDelayEnabled = false;\\n\\n\\n    address public marketingAddress;\\n    address public devAddress;\\n\\n    uint256 public maxAmountInOneTransaction;\\n    uint256 public maxSwapTokensAtAmount;\\n    uint256 public maxAmountInSingleAddress;\\n\\n    uint256 public percentageForLPBurn = 1; // 25 = .25%\\n    uint256 public lpBurnDuration = 3000 seconds;\\n    uint256 public lastLpBurnedTime;\\n\\n    uint256 public manualLpBurnedDuration = 60 minutes;\\n    uint256 public lastManualLpBurnTime;\\n    uint256 public buyTotalFees;\\n    uint256 public buyMarketingFee;\\n    uint256 public buyLiquidityFee;\\n    uint256 public buyDevFee;\\n\\n    uint256 public sellTotalFees;\\n    uint256 public sellMarketingFee;\\n    uint256 public sellLiquidityFee;\\n    uint256 public sellDevFee;\\n\\n    uint256 public amountTokensForMarketing;\\n    uint256 public amountTokensForLiquidity;\\n    uint256 public amountTokensForDev;\\n\\n    mapping(address => uint256) private _holdDoorForLastTransferTimestamp; // to hold last Transfers temporarily during launch\\n    mapping(address => bool) private _isExcludedAddressFromFees;\\n    mapping(address => bool) public _isExcludedAddressMaxTransactionAmount;\\n    mapping(address => bool) public mapForAutomatedMarketMakerPairs;\\n\\n\\n    event ExcludeAddressFromFees(address indexed account, bool isExcluded);\\n\\n    event SetupForAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n\\n    event MarketingAddressUpdated(\\n        address indexed newWallet,\\n        address indexed oldWallet\\n    );\\n\\n    event devAddressUpdated(\\n        address indexed newWallet,\\n        address indexed oldWallet\\n    );\\n\\n    event AddSwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiquidity\\n    );\\n\\n    event AutoSyncLP();\\n\\n    event ManualAddNukeLP();\\n    constructor() ERC20(\\\"Goldereum\\\", \\\"Goldereum\\\") {\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n        );\\n\\n        excludeAddressFromMaxTransaction(address(_uniswapV2Router), true);\\n        _interfaceUniswapV2Router = _uniswapV2Router;\\n\\n        _interfaceUniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());(address(_interfaceUniswapV2Pair), true);\\n        _updateAndSetAutomatedMarketMakerPair(address(_interfaceUniswapV2Pair), true);\\n\\n        uint256 _buyMarketingFee = 5;\\n        uint256 _buyLiquidityFee = 0;\\n        uint256 _buydevfee = 0;\\n\\n        uint256 _sellMarketingFee = 5;  \\n        uint256 _sellLiquidityFee = 0;\\n        uint256 _selldevfee = 0;\\n\\n     \\n        uint256 totalSupply = 1_000_000 * 1e18;\\n\\n        maxAmountInOneTransaction =  50_000 * 1e18; // 5% from total supply maxTransactionAmountTxn\\n        maxAmountInSingleAddress = 100_000 * 1e18; // 10% from total supply maxAmountInSingleAddress\\n        maxSwapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05% swap wallet\\n\\n        buyMarketingFee = _buyMarketingFee;\\n        buyLiquidityFee = _buyLiquidityFee;\\n        buyDevFee = _buydevfee;\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\n\\n        sellMarketingFee = _sellMarketingFee;\\n        sellLiquidityFee = _sellLiquidityFee;\\n        sellDevFee = _selldevfee;\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\n\\n        marketingAddress = address(0x7e8C364aF8E6af1E1Ef96FE0a20F4e20d7Cc633f); \\n        devAddress = address(0x7e8C364aF8E6af1E1Ef96FE0a20F4e20d7Cc633f); \\n        \\n        // exclude from paying fees or having max transaction amount\\n        excludeAddressFromFees(owner(), true);\\n        excludeAddressFromFees(address(this), true);\\n        excludeAddressFromFees(address(0xdead), true);\\n       \\n\\n        excludeAddressFromMaxTransaction(owner(), true);\\n        excludeAddressFromMaxTransaction(address(this), true);\\n        excludeAddressFromMaxTransaction(address(0xdead), true);\\n        _mint(msg.sender, totalSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    // once enabled, can never be turned off\\n    function enableTrading() external onlyOwner {\\n        flgaSwapEnabled = true;\\n        flagTradingsLive = true;\\n        lastLpBurnedTime = block.timestamp;\\n    }\\n\\n    // disable Transfer delay - cannot be reenabled\\n    function UnableTransferDelay() external onlyOwner returns (bool) {\\n        flagTransferDelayEnabled = false;\\n        return true;\\n    }\\n\\n    // change the minimum amount of tokens to sell from fees\\n    function changeSwapTokensAtAmount(uint256 newAmount)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        require(\\n            newAmount >= (totalSupply() * 1) / 10000,\\n            \\\"Swap amount cannot be lower than 0.001% total supply.\\\"\\n        );\\n        require(\\n            newAmount <= (totalSupply() * 5) / 1000,\\n            \\\"Swap amount cannot be higher than 0.5% total supply.\\\"\\n        );\\n        maxSwapTokensAtAmount = newAmount;\\n        return true;\\n    }\\n\\n    function updateAndSetMaxTxnAmt(uint256 newNum) external onlyOwner {\\n        require(\\n            newNum >= ((totalSupply() * 1) / 1000) / 1e18,\\n            \\\"Cannot change maxAmountInOneTransaction lower than 0.2%\\\"\\n        );\\n        maxAmountInOneTransaction = newNum * (10**18);\\n    }\\n\\n    function updateAndSetMaxWalletSize(uint256 newNum) external onlyOwner {\\n        require(\\n            newNum >= ((totalSupply() * 2) / 1000) / 1e18,\\n            \\\"Cannot change maxAmountInSingleAddress lower than 1%\\\"\\n        );\\n        maxAmountInSingleAddress = newNum * (10**18);\\n    }\\n\\n    function removeLimits() external onlyOwner{ // removeLimit and change  fees to floor \\n        maxAmountInOneTransaction = totalSupply();\\n        maxAmountInSingleAddress = totalSupply();\\n    }\\n\\n    function excludeAddressFromMaxTransaction(address updAds, bool isEx)\\n        public\\n        onlyOwner\\n    {\\n        _isExcludedAddressMaxTransactionAmount[updAds] = isEx;\\n    }\\n\\n    function updateFeesBuy(\\n        uint256 _marketingFee,\\n        uint256 _liquidityFee,\\n        uint256 _devFee\\n    ) external onlyOwner {\\n        buyMarketingFee = _marketingFee;\\n        buyLiquidityFee = _liquidityFee;\\n        buyDevFee = _devFee;\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\n        require(buyTotalFees <= 40, \\\"Must keep fees at 35% or less\\\");\\n    }\\n\\n    function updateFeesSell(\\n        uint256 _marketingFee,\\n        uint256 _liquidityFee,\\n        uint256 _devFee\\n    ) external onlyOwner {\\n        sellMarketingFee = _marketingFee;\\n        sellLiquidityFee = _liquidityFee;\\n        sellDevFee = _devFee;\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\n        require(sellTotalFees <= 99, \\\"Must keep fees at 99% or less\\\");\\n    }\\n\\n    function excludeAddressFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedAddressFromFees[account] = excluded;\\n        emit ExcludeAddressFromFees(account, excluded);\\n    }\\n\\n    function updateAndSetAutomatedMarketMakerPair(address pair, bool value)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            pair != _interfaceUniswapV2Pair,\\n            \\\"The pair cannot be removed from mapForAutomatedMarketMakerPairs\\\"\\n        );\\n\\n        _updateAndSetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function _updateAndSetAutomatedMarketMakerPair(address pair, bool value) private {\\n        mapForAutomatedMarketMakerPairs[pair] = value;\\n\\n        emit SetupForAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function updateMarketingAddress(address newMarketingWallet)\\n        external\\n        onlyOwner\\n    {\\n        emit MarketingAddressUpdated(newMarketingWallet, marketingAddress);\\n        marketingAddress = newMarketingWallet;\\n    }\\n\\n    function updateAndSetDevAddress(address newWallet) external onlyOwner {\\n        emit devAddressUpdated(newWallet, devAddress);\\n        devAddress = newWallet;\\n    }\\n\\n    function checkIsExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedAddressFromFees[account];\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        if (flaglimitsInUse) {\\n            if (\\n                from != owner() &&\\n                to != owner() &&\\n                to != address(0) &&\\n                to != address(0xdead) &&\\n                !_flagSwapping\\n            ) {\\n                if (!flagTradingsLive) {\\n                    require(\\n                        _isExcludedAddressFromFees[from] || _isExcludedAddressFromFees[to],\\n                        \\\"Trading is not active.\\\"\\n                    );\\n                }\\n\\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.\\n                if (flagTransferDelayEnabled) {\\n                    if (\\n                        to != owner() &&\\n                        to != address(_interfaceUniswapV2Router) &&\\n                        to != address(_interfaceUniswapV2Pair)\\n                    ) {\\n                        require(\\n                            _holdDoorForLastTransferTimestamp[tx.origin] <\\n                                block.number,\\n                            \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\"\\n                        );\\n                        _holdDoorForLastTransferTimestamp[tx.origin] = block.number;\\n                    }\\n                }\\n\\n                //when buy\\n                if (\\n                    mapForAutomatedMarketMakerPairs[from] &&\\n                    !_isExcludedAddressMaxTransactionAmount[to]\\n                ) {\\n                    require(\\n                        amount <= maxAmountInOneTransaction,\\n                        \\\"Buy transfer amount exceeds the maxAmountInOneTransaction.\\\"\\n                    );\\n                    require(\\n                        amount + balanceOf(to) <= maxAmountInSingleAddress,\\n                        \\\"Max wallet exceeded\\\"\\n                    );\\n                }\\n                //when sell\\n                else if (\\n                    mapForAutomatedMarketMakerPairs[to] &&\\n                    !_isExcludedAddressMaxTransactionAmount[from]\\n                ) {\\n                    require(\\n                        amount <= maxAmountInOneTransaction,\\n                        \\\"Sell transfer amount exceeds the maxAmountInOneTransaction.\\\"\\n                    );\\n                } else if (!_isExcludedAddressMaxTransactionAmount[to]) {\\n                    require(\\n                        amount + balanceOf(to) <= maxAmountInSingleAddress,\\n                        \\\"Max wallet exceeded\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= maxSwapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            flgaSwapEnabled &&\\n            !_flagSwapping &&\\n            !mapForAutomatedMarketMakerPairs[from] &&\\n            !_isExcludedAddressFromFees[from] &&\\n            !_isExcludedAddressFromFees[to]\\n        ) {\\n            _flagSwapping = true;\\n\\n            swapBack();\\n\\n            _flagSwapping = false;\\n        }\\n\\n        if (\\n            !_flagSwapping &&\\n            mapForAutomatedMarketMakerPairs[to] &&\\n            _flagLpBurnEnabled &&\\n            block.timestamp >= lastLpBurnedTime + lpBurnDuration &&\\n            !_isExcludedAddressFromFees[from]\\n        ) {\\n            automaticallyBurnLiquidityPairTokens();\\n        }\\n\\n        bool takeFee = !_flagSwapping;\\n\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedAddressFromFees[from] || _isExcludedAddressFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        uint256 fees = 0;\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if (takeFee) {\\n            // on sell\\n            if (mapForAutomatedMarketMakerPairs[to] && sellTotalFees > 0) {\\n                fees = amount.mul(sellTotalFees).div(100);\\n                amountTokensForLiquidity += (fees * sellLiquidityFee) / sellTotalFees;\\n                amountTokensForDev += (fees * sellDevFee) / sellTotalFees;\\n                amountTokensForMarketing += (fees * sellMarketingFee) / sellTotalFees;\\n            }\\n            // on buy\\n            else if (mapForAutomatedMarketMakerPairs[from] && buyTotalFees > 0) {\\n                fees = amount.mul(buyTotalFees).div(100);\\n                amountTokensForLiquidity += (fees * buyLiquidityFee) / buyTotalFees;\\n                amountTokensForDev += (fees * buyDevFee) / buyTotalFees;\\n                amountTokensForMarketing += (fees * buyMarketingFee) / buyTotalFees;\\n            }\\n\\n            if (fees > 0) {\\n                super._transfer(from, address(this), fees);\\n            }\\n\\n            amount -= fees;\\n        }\\n\\n        super._transfer(from, to, amount);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _interfaceUniswapV2Router.WETH();\\n\\n        _approve(address(this), address(_interfaceUniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        _interfaceUniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(_interfaceUniswapV2Router), tokenAmount);\\n\\n        // add the liquidity\\n        _interfaceUniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            destroyAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() private {\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 totalTokensToSwap = amountTokensForLiquidity +\\n            amountTokensForMarketing +\\n            amountTokensForDev;\\n        bool success;\\n\\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\\n            return;\\n        }\\n\\n        if (contractBalance > maxSwapTokensAtAmount * 20) {\\n            contractBalance = maxSwapTokensAtAmount * 20;\\n        }\\n\\n        // Halve the amount of liquidity tokens\\n        uint256 liquidityTokens = (contractBalance * amountTokensForLiquidity) /\\n            totalTokensToSwap /\\n            2;\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\n\\n        uint256 initialETHBalance = address(this).balance;\\n\\n        swapTokensForEth(amountToSwapForETH);\\n\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\n\\n        uint256 ethForMarketing = ethBalance.mul(amountTokensForMarketing).div(\\n            totalTokensToSwap\\n        );\\n        uint256 ethForDev = ethBalance.mul(amountTokensForDev).div(totalTokensToSwap);\\n\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\\n\\n        amountTokensForLiquidity = 0;\\n        amountTokensForMarketing = 0;\\n        amountTokensForDev = 0;\\n\\n        (success, ) = address(devAddress).call{value: ethForDev}(\\\"\\\");\\n\\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\n            emit AddSwapAndLiquify(\\n                amountToSwapForETH,\\n                ethForLiquidity,\\n                amountTokensForLiquidity\\n            );\\n        }\\n\\n        (success, ) = address(marketingAddress).call{\\n            value: address(this).balance\\n        }(\\\"\\\");\\n    }\\n\\n    function updateAndSetAutoLPBurnSettings(\\n        uint256 _frequencyInSeconds,\\n        uint256 _percent,\\n        bool _Enabled\\n    ) external onlyOwner {\\n        require(\\n            _frequencyInSeconds >= 600,\\n            \\\"cannot set buyback more often than every 10 minutes\\\"\\n        );\\n        require(\\n            _percent <= 1000 && _percent >= 0,\\n            \\\"Must set auto LP burn percent between 0% and 10%\\\"\\n        );\\n        lpBurnDuration = _frequencyInSeconds;\\n        percentageForLPBurn = _percent;\\n        _flagLpBurnEnabled = _Enabled;\\n    }\\n\\n    function automaticallyBurnLiquidityPairTokens() internal returns (bool) {\\n        lastLpBurnedTime = block.timestamp;\\n\\n        // get balance of liquidity pair\\n        uint256 liquidityPairBalance = this.balanceOf(_interfaceUniswapV2Pair);\\n\\n        // calculate amount to burn\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentageForLPBurn).div(\\n            10000\\n        );\\n\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\n        if (amountToBurn > 0) {\\n            super._transfer(_interfaceUniswapV2Pair, address(0xdead), amountToBurn);\\n        }\\n\\n        //sync price since this is not in a swap transaction!\\n        IUniswapV2Pair pair = IUniswapV2Pair(_interfaceUniswapV2Pair);\\n        pair.sync();\\n        emit AutoSyncLP();\\n        return true;\\n    }\\n\\n    function manualBurnLiquidityPairTokens(uint256 percent)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        require(\\n            block.timestamp > lastManualLpBurnTime + manualLpBurnedDuration,\\n            \\\"Must wait for cooldown to finish\\\"\\n        );\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\n        lastManualLpBurnTime = block.timestamp;\\n\\n        // get balance of liquidity pair\\n        uint256 liquidityPairBalance = this.balanceOf(_interfaceUniswapV2Pair);\\n\\n        // calculate amount to burn\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\n\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\n        if (amountToBurn > 0) {\\n            super._transfer(_interfaceUniswapV2Pair, address(0xdead), amountToBurn);\\n        }\\n\\n        //sync price since this is not in a swap transaction!\\n        IUniswapV2Pair pair = IUniswapV2Pair(_interfaceUniswapV2Pair);\\n        pair.sync();\\n        emit ManualAddNukeLP();\\n        return true;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"AddSwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AutoSyncLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeAddressFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManualAddNukeLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"MarketingAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetupForAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"devAddressUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UnableTransferDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_flagLpBurnEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_interfaceUniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_interfaceUniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedAddressMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountTokensForDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountTokensForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountTokensForMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDevFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"changeSwapTokensAtAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkIsExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeAddressFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeAddressFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flagTradingsLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flagTransferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flaglimitsInUse\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flgaSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLpBurnedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastManualLpBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBurnDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"manualBurnLiquidityPairTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualLpBurnedDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapForAutomatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmountInOneTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmountInSingleAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageForLPBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDevFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_frequencyInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_Enabled\",\"type\":\"bool\"}],\"name\":\"updateAndSetAutoLPBurnSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updateAndSetAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateAndSetDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateAndSetMaxTxnAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateAndSetMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"}],\"name\":\"updateFeesBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"}],\"name\":\"updateFeesSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Goldereum", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}