{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n// optimize 200\r\n/// Standard IERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function owner() external view returns(address);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function symbol() external view returns(string memory);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/// Transfer Helper to ensure the correct transfer of the tokens or ETH\r\nlibrary SafeTransfer {\r\n    using Address for address;\r\n    function safeApprove(IERC20 token, address spender, uint256 value) \r\n    internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require(\r\n        (value == 0) || (token.allowance(address(this), spender) == 0),\r\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(token, \r\n    abi.encodeWithSelector(token.approve.selector, spender, value));\r\n}\r\n    /** Safe Transfer asset from one wallet with approval of the wallet\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param from: the wallet to take from\r\n    * @param amount: the amount to take from the wallet\r\n    **/\r\n    function _pullUnderlying(IERC20 erc20, address from, uint amount) internal\r\n    {\r\n        safeTransferFrom(erc20,from,address(this),amount);\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /** Safe Transfer asset to one wallet from within the contract\r\n    * @param erc20: the contract address of the erc20 token\r\n    * @param to: the wallet to send to\r\n    * @param amount: the amount to send from the contract\r\n    **/\r\n    function _pushUnderlying(IERC20 erc20, address to, uint amount) internal\r\n    {\r\n        safeTransfer(erc20,to,amount);\r\n    }\r\n\r\n    /** Safe Transfer ETH to one wallet from within the contract\r\n    * @param to: the wallet to send to\r\n    * @param value: the amount to send from the contract\r\n    **/\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface dr {\r\n    function superAdmin(address addy) external view returns(bool);\r\n    function isAdmin(address addy) external view returns(bool);\r\n    function bridgeDep() external view returns(address);\r\n    function isBridge(address addy) external view returns(bool);\r\n    function setBridgeSD(address who, address addy) external;\r\n    function wETH() external view returns(address);\r\n    function bridgeSD(address sd) external view returns(address);\r\n    function sdDepAddy() external view returns(address);\r\n    function creatorOfSD(address creator) external view returns(address);\r\n    function SDOfCreator(address sd) external view returns(address);\r\n\r\n}\r\n\r\ninterface warp {    \r\n    function sendPayloadToEvm(uint16 targetChain,address targetAddress,bytes memory payload,uint256 receiverValue,uint256 gasLimit,uint16 refundChain,address refundAddress) external payable returns (uint64 sequence);\r\n}\r\n\r\ninterface dep {\r\n    function relayDeposit(uint256 cost, uint16 toChain, bytes calldata payload, uint16 toChain0, address fund) external payable;\r\n    function relayWithdrawal(uint256 cost, uint16 toChain, bytes calldata payload, uint16 toChain0, address fund) external payable;\r\n    function registerWithdraw(address ad, uint256 amount, uint16 sourceChain, uint256 depositID) external;\r\n    function registerBridge(uint256 depositID) external;\r\n    function fund() external view returns(address);\r\n    function gas0() external view returns(uint256);\r\n    function gas1() external view returns(uint256);\r\n    function recoveryFee() external view returns(uint256);\r\n    function donation() external view returns(uint256);\r\n    function quoteEVMDeliveryPrice(uint16 targetChain, uint256 receiverValue, uint256 gasLimit) external view returns (uint256 nativePriceQuote, uint256);\r\n    function quoteDeposit(uint16 target, uint256 rv) external view returns (uint256 npq);\r\n    function quoteWithdraw(uint16 target, uint256 rv) external view returns (uint256 npq);\r\n    function deposit() external payable;\r\n    function deploy(address sd, address owner) external returns(address bridge);\r\n    function tokenOnChain(address sd, uint16 chain) external view returns(address);\r\n    function coolDown() external view returns(uint256);\r\n}\r\n\r\ncontract SmartBridge {\r\n    address public relayer = 0x3A3709b8c67270A84Fe96291B7E384044160C6b1;\r\n    address public SD;\r\n    address public dataread = 0xdAE383661587232FBd254b05a395CB8e35E6e7B6;\r\n    mapping(address => uint256) public lastUse;\r\n    mapping(address => uint256[]) public myDepositIDs;\r\n    mapping(address => uint256[]) public myWithdrawIDs;\r\n    mapping(address => uint256[]) public myClaimedWithdrawIDs;\r\n    mapping(address => uint256[]) public myDisputeIDs;\r\n    mapping(address => mapping(uint256 => bool)) public confirmed;\r\n    mapping(address => bool) public admin;\r\n    mapping(address => uint256) public balance;\r\n    address public owner;\r\n    uint256 public openDisputes;\r\n    uint256 public maxTx;\r\n    Deposit[] public deposit;\r\n    Dispute[] public dispute;\r\n    Withdraw[] public wd;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    event Bridged(address to, uint256 amt, uint256 id);\r\n    event RecoverDeposit(address to, uint256 amt, uint256 depositID);\r\n    event RaiseDispute(address to, uint256 amt, uint256 depositID);\r\n    event Withdrawal(address user, uint256 amount, uint256 chainID, uint256 depositID);\r\n    /* ChainID's Current List\r\n    uint16 constant CHAIN_ID_ETHEREUM = 2;\r\n    uint16 constant CHAIN_ID_BSC = 4;\r\n    uint16 constant CHAIN_ID_POLYGON = 5;\r\n    uint16 constant CHAIN_ID_AVALANCHE = 6;\r\n    uint16 constant CHAIN_ID_FANTOM = 10;\r\n    uint16 constant CHAIN_ID_NEON = 17;\r\n    uint16 constant CHAIN_ID_APTOS = 22;\r\n    uint16 constant CHAIN_ID_ARBITRUM = 23;\r\n    uint16 constant CHAIN_ID_OPTIMISM = 24;\r\n    uint16 constant CHAIN_ID_GNOSIS = 25;\r\n    uint16 constant CHAIN_ID_BASE = 30;\r\n    */\r\n    constructor(address sd, address _owner) {\r\n        SD = sd;\r\n        admin[_owner] = true;\r\n        owner = _owner;\r\n        maxTx = IERC20(SD).totalSupply() / 1000;\r\n        deposit.push();\r\n        dispute.push();\r\n        wd.push();\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    struct Deposit {\r\n        address user;\r\n        uint256 amount;\r\n        uint16 toChainId;\r\n        uint256 depositTime;\r\n        uint256 expireTime;\r\n        uint256 withdrawTime;\r\n        uint256 cost;\r\n        uint256 disputeID;\r\n        bool refunded;\r\n        bool completed;\r\n        bytes payload;\r\n    }\r\n\r\n    struct Dispute {\r\n        address user;\r\n        uint256 depositID;\r\n        uint256 amount;\r\n        uint16 toChain;\r\n        uint256 confirms;\r\n        bool refunded;\r\n        bool closed;\r\n    }\r\n\r\n    struct Withdraw {\r\n        address user;\r\n        uint256 amount;\r\n        uint16 fromChain;\r\n        uint256 depositID;\r\n        uint256 expireTime;\r\n        bool complete;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function deployer() public view returns(address) {\r\n        return dr(dataread).bridgeDep();\r\n    }\r\n\r\n    function setAdmin(address addy, bool _bool) external {\r\n        require(msg.sender == owner, \"not 1\");\r\n        admin[addy] = _bool;\r\n    }\r\n\r\n    function raiseDispute(uint256 depositID) external nonReentrant {\r\n        require(!deposit[depositID].refunded, \"already\");\r\n        require(!deposit[depositID].completed, \"already Complete\");\r\n        require(block.timestamp <= deposit[depositID].expireTime, \"expired\");\r\n        require(block.timestamp >= deposit[depositID].depositTime + 4 hours, \"not mature\");\r\n        require(deposit[depositID].user == msg.sender, \"not user\");\r\n        dispute.push();\r\n        myDisputeIDs[msg.sender].push(dispute.length - 1);\r\n        dispute[dispute.length - 1].user = deposit[depositID].user;\r\n        dispute[dispute.length - 1].depositID = depositID;\r\n        dispute[dispute.length - 1].toChain = deposit[depositID].toChainId;\r\n        dispute[dispute.length - 1].amount = deposit[depositID].amount;\r\n        deposit[depositID].disputeID = dispute.length - 1;\r\n        openDisputes += 1;\r\n        emit RaiseDispute(msg.sender, deposit[depositID].amount, depositID);\r\n    }\r\n\r\n    function confirmDispute(uint256 disputeID, bool _bool) external nonReentrant {\r\n        require(admin[msg.sender], \"not admin\");\r\n        require(dispute[disputeID].confirms < 2, \"already 2\");\r\n        require(!dispute[disputeID].refunded, \"already\");\r\n        require(block.timestamp <= deposit[dispute[disputeID].depositID].expireTime, \"expired\");\r\n        require(!confirmed[msg.sender][disputeID], \"already disputed\");\r\n        confirmed[msg.sender][disputeID] = true;\r\n        dispute[disputeID].confirms += 1;\r\n        if(_bool) {\r\n        dispute[disputeID].closed = true;\r\n        }\r\n    }\r\n\r\n    function recoverDeposit(uint256 depositID) external nonReentrant {\r\n        require(!deposit[depositID].refunded, \"already\");\r\n        require(!deposit[depositID].completed, \"already Complete\");\r\n        require(deposit[depositID].user == msg.sender, \"not user\");\r\n        uint256 dID = deposit[depositID].disputeID;\r\n        require(dispute[dID].confirms >= 2, \"not confirmed\");\r\n        require(!dispute[dID].closed, \"closed\");\r\n        uint256 amt = dispute[dID].amount;\r\n        uint256 fee;\r\n        address d = deployer();\r\n        uint256 rf = dep(d).recoveryFee();\r\n        if(rf > 0) {\r\n        fee = amt * rf / 100;\r\n        amt -= fee;\r\n        SafeTransfer._pushUnderlying(IERC20(SD), dep(d).fund(), fee);\r\n        }\r\n        dispute[dID].refunded = true;\r\n        deposit[depositID].refunded = true;\r\n        openDisputes = openDisputes > 1 ? openDisputes - 1 : 0;\r\n        SafeTransfer._pushUnderlying(IERC20(SD), msg.sender, amt);\r\n        emit RecoverDeposit(msg.sender, amt, depositID);\r\n    }\r\n\r\n    function setMaxTx(uint256 max) external {\r\n        require(dr(dataread).superAdmin(msg.sender) || admin[msg.sender], \"not admin\");\r\n        require(max >= IERC20(SD).totalSupply() / 100000, \">0.0001%\");\r\n        maxTx = max;\r\n    }\r\n\r\n    function getad(address creator, address user, uint256 amount, uint256 tac, uint256 depositID) public pure returns(bytes memory data) {\r\n        data = abi.encode(creator, user, amount, tac, depositID);\r\n    }\r\n\r\n    function costBridge(uint16 toChain) public view returns(uint256,uint256) {\r\n        address d = deployer();\r\n        uint256 a = dep(relayer).quoteDeposit(toChain, 0);\r\n        uint256 b = dep(d).donation();\r\n        return (a + b,  b);\r\n    }\r\n\r\n    function costWithdraw(uint16 fromChain) public view returns(uint256,uint256) {\r\n        address d = deployer();\r\n        uint256 a = dep(relayer).quoteWithdraw(fromChain, 0);\r\n        uint256 b = dep(d).donation();\r\n        return (a + b,  b);\r\n    }\r\n\r\n    function coolDown() public view returns(uint256) {\r\n        return dep(deployer()).coolDown();\r\n    }\r\n\r\n    function bridge(uint16 toChain, uint256 amount, address user) external payable nonReentrant{\r\n        if(!admin[msg.sender]) {\r\n        uint256 cd = coolDown();\r\n        if(cd > 0) {\r\n        require(block.timestamp > lastUse[user] + cd, \"cool down\");\r\n        }\r\n        require(amount <= maxTx, \"over max tx\");\r\n        }\r\n        lastUse[user] = block.timestamp;\r\n        (uint256 cost, uint256 don) = costBridge(toChain);\r\n        require(msg.value >= cost, \"insufficient fee\");\r\n        address sdep = dr(dataread).sdDepAddy();\r\n        address creator = dr(sdep).creatorOfSD(SD);\r\n        if(!dr(dataread).superAdmin(msg.sender)) {      \r\n        require(!dr(dataread).superAdmin(user), \"user cannot be admin\");\r\n        }\r\n        bytes memory payload = getad(creator, user, amount, 0, deposit.length);\r\n        SafeTransfer.safeTransferFrom(IERC20(SD), msg.sender, address(this), amount);\r\n        myDepositIDs[user].push(deposit.length);\r\n        deposit.push(Deposit(user, amount, toChain, block.timestamp, block.timestamp + 30 days, 0, cost, 0, false, false, payload)); // 30 day expire time\r\n        address d = deployer();\r\n        dep(relayer).relayDeposit{value: cost}(don,toChain,payload,toChain,dep(d).fund());\r\n        emit Bridged(user, amount, toChain);\r\n    }\r\n\r\n    function registerWithdraw(address ad, uint256 amount, uint16 sourceChain, uint256 id) external nonReentrant {     \r\n        require(msg.sender == relayer, \"not relayer\");   \r\n        myWithdrawIDs[ad].push(wd.length);\r\n        wd.push(Withdraw(ad, amount, sourceChain, id, block.timestamp + 30 days, false)); // 30 day expire time\r\n        balance[ad] += amount;\r\n        emit Withdrawal(ad, amount, sourceChain, id);\r\n    }\r\n\r\n    function registerBridge(uint256 id) external nonReentrant {\r\n        require(msg.sender == relayer, \"not relayer\");   \r\n        deposit[id].completed = true;\r\n        deposit[id].withdrawTime = block.timestamp;\r\n    }\r\n\r\n    function allMyWithdrawIDs(address user) external view returns(uint256[] memory ids) {\r\n        ids = new uint256[](myWithdrawIDs[user].length);\r\n        for(uint256 i = 0; i < myWithdrawIDs[user].length; i++) {\r\n        ids[i] = myWithdrawIDs[user][i];\r\n        }\r\n    }\r\n\r\n    function allMyDepositIDs(address user) external view returns(uint256[] memory ids) {\r\n        ids = new uint256[](myDepositIDs[user].length);\r\n        for(uint256 i = 0; i < myDepositIDs[user].length; i++) {\r\n        ids[i] = myDepositIDs[user][i];\r\n        }\r\n    }\r\n\r\n    function allMyClaimedWithdrawIDs(address user) external view returns(uint256[] memory ids) {\r\n        ids = new uint256[](myWithdrawIDs[user].length);\r\n        for(uint256 i = 0; i < myWithdrawIDs[user].length; i++) {\r\n        ids[i] = myClaimedWithdrawIDs[user][i];\r\n        }\r\n    }\r\n\r\n    function allMyOpenWithdrawIDs(address user) external view returns(uint256[] memory oids) {\r\n        uint256[] memory ids = new uint256[](myWithdrawIDs[user].length);\r\n        for(uint256 i = 0; i < myWithdrawIDs[user].length; i++) {\r\n        ids[i] = myWithdrawIDs[user][i];\r\n        }\r\n        uint256 a = myWithdrawIDs[user].length - myClaimedWithdrawIDs[user].length;\r\n        oids = new uint256[](a);\r\n        for(uint256 i = 0; i < myWithdrawIDs[user].length; i++) {\r\n        if(!wd[myWithdrawIDs[user][i]].complete && block.timestamp <= wd[myWithdrawIDs[user][i]].expireTime) {\r\n        oids[i] = myWithdrawIDs[user][i];\r\n        }\r\n        }\r\n    }\r\n\r\n    function withdraw(address to, uint256 withdrawID) external payable nonReentrant {\r\n        uint256 tot;\r\n        uint256 totCost;\r\n        require(balance[msg.sender] > 0, \"no balance\");\r\n        require(wd[withdrawID].user == msg.sender, \"not user\");\r\n        require(!wd[withdrawID].complete, \"completed\");\r\n        require(block.timestamp <= wd[withdrawID].expireTime, \"expired\");\r\n        tot += wd[withdrawID].amount;\r\n        uint256 w = withdrawID;\r\n        balance[msg.sender] -= wd[w].amount;\r\n        wd[w].complete = true;\r\n        myClaimedWithdrawIDs[msg.sender].push(w);\r\n        address sdep = dr(dataread).sdDepAddy();\r\n        address creator = dr(sdep).creatorOfSD(SD);\r\n        bytes memory payload = getad(creator, msg.sender, wd[w].amount, 1, wd[withdrawID].depositID);\r\n        (uint256 cost, uint256 don) = costWithdraw(wd[w].fromChain);\r\n        totCost += cost;\r\n        address d = deployer();\r\n        dep(relayer).relayWithdrawal{value: cost}(don, wd[w].fromChain, payload, wd[w].fromChain, dep(d).fund());\r\n        require(msg.value >= totCost, \"insufficient fee\");        \r\n        SafeTransfer.safeTransfer(IERC20(SD), to, tot);\r\n    }\r\n    \r\n    function saveTokens(address token) public {\r\n        require(token != SD, \"cannot remove SD\");\r\n        uint256 a = IERC20(token).balanceOf(address(this));\r\n        address d = deployer();\r\n        if(a > 0) {\r\n        SafeTransfer._pushUnderlying(IERC20(token), dep(d).fund(), a);\r\n        }\r\n        if(address(this).balance > 0) {\r\n        SafeTransfer.safeTransferETH(dep(d).fund(), address(this).balance);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Bridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"RaiseDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"RecoverDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"allMyClaimedWithdrawIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"allMyDepositIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"allMyOpenWithdrawIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"oids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"allMyWithdrawIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"confirmDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"confirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coolDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"}],\"name\":\"costBridge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"fromChain\",\"type\":\"uint16\"}],\"name\":\"costWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataread\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"toChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dispute\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"confirms\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"closed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tac\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"getad\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myClaimedWithdrawIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myDepositIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myDisputeIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myWithdrawIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openDisputes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"raiseDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"}],\"name\":\"recoverDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"registerBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"registerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"saveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"fromChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SmartBridge", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f3c7cecf8cbc3066f9a87b310cebe198d00479ac0000000000000000000000008d5e1cd48b17d807e81dbfbe6c591cb7fab63971", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6a95b83b3cda36d5e2e5ef3ed7568db260e8a324b3a09c2eb8a654d28396a2f8"}