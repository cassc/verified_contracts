{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/compliance/libraries/ProtocolsRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    ProtocolIsNotSupported,\\n    ProtocolIsSuspended,\\n    Status\\n} from \\\"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\\\";\\n\\nlibrary StringTruncatedHash {\\n    function truncatedHash(string memory _self) internal pure returns (bytes31) {\\n        return bytes31(keccak256(bytes(_self)));\\n    }\\n}\\n\\nlibrary ProtocolsRepository {\\n    using StringTruncatedHash for string;\\n\\n    struct Protocol {\\n        address evaluator;\\n        Status status;\\n    }\\n\\n    struct Operator {\\n        bytes31 protocolNameHash;\\n        Status status;\\n    }\\n\\n    struct Storage {\\n        mapping(bytes31 protocolNameHash => Protocol) protocols;\\n        mapping(address externalOperator => Operator) operators;\\n    }\\n\\n    bytes32 private constant STORAGE_SLOT = keccak256(\\\"Supported Protocols repository slot V1\\\");\\n\\n    error ProtocolMustNotBeEmptyString();\\n\\n    /// @dev We mark protocol as memory here to make unit testing easier\\n    function updateProtocolSupport(\\n        string memory _protocol,\\n        address _adapterEvaluator,\\n        bool _supported\\n    ) internal returns (bool storageModified_) {\\n        if (bytes(_protocol).length == 0) revert ProtocolMustNotBeEmptyString();\\n        Protocol storage prot = protocol(_protocol);\\n        if (\\n            _supported && (prot.status != Status.Supported || prot.evaluator != _adapterEvaluator)\\n        ) {\\n            prot.status = Status.Supported;\\n            prot.evaluator = _adapterEvaluator;\\n            storageModified_ = true;\\n        } else if (!_supported && prot.status == Status.Supported) {\\n            prot.status = Status.Suspended;\\n            storageModified_ = true;\\n        }\\n    }\\n\\n    /// @dev We mark protocol as memory here to make unit testing easier\\n    function updateOperatorSupport(\\n        string memory _protocol,\\n        address _source,\\n        bool _supported\\n    ) internal returns (bool storageModified_) {\\n        if (bytes(_protocol).length == 0) revert ProtocolMustNotBeEmptyString();\\n        Operator storage op = operator(_source);\\n        bytes31 protHash = _protocol.truncatedHash();\\n\\n        if (_supported && (op.status != Status.Supported || op.protocolNameHash != protHash)) {\\n            op.protocolNameHash = protHash;\\n            op.status = Status.Supported;\\n            storageModified_ = true;\\n        } else if (!_supported && op.status == Status.Supported) {\\n            op.status = Status.Suspended;\\n            storageModified_ = true;\\n        }\\n    }\\n\\n    function enforceProtocolSupported(string calldata _protocol) internal view {\\n        Status status = getProtocolStatus(_protocol);\\n        if (status != Status.Supported) {\\n            if (status == Status.Suspended) revert ProtocolIsSuspended(_protocol);\\n            else revert ProtocolIsNotSupported(_protocol);\\n        }\\n    }\\n\\n    function enforceProtocolSupportedOrSuspended(string calldata _protocol) internal view {\\n        Status status = getProtocolStatus(_protocol);\\n        if (status == Status.Undefined) revert ProtocolIsNotSupported(_protocol);\\n    }\\n\\n    function getProtocolStatus(string calldata _protocol) internal view returns (Status) {\\n        return protocol(_protocol).status;\\n    }\\n\\n    function getProtocolEvaluator(string calldata _protocol) internal view returns (address) {\\n        return protocol(_protocol).evaluator;\\n    }\\n\\n    function getOperatorStatus(\\n        address _source\\n    ) internal view returns (Status operator_, Status protocol_) {\\n        operator_ = operator(_source).status;\\n        protocol_ = _storage().protocols[operator(_source).protocolNameHash].status;\\n    }\\n\\n    function protocol(string memory _name) private view returns (Protocol storage) {\\n        return _storage().protocols[_name.truncatedHash()];\\n    }\\n\\n    function operator(address _source) private view returns (Operator storage) {\\n        return _storage().operators[_source];\\n    }\\n\\n    function _storage() private pure returns (Storage storage) {\\n        bytes32 storageSlot = STORAGE_SLOT;\\n        Storage storage state;\\n        assembly {\\n            state.slot := storageSlot\\n        }\\n        return state;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/JitCompiler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {\\n    IDecreasePositionEvaluator,\\n    IExchangeEvaluator,\\n    IIncreasePositionEvaluator,\\n    IJitCompiler\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/IJitCompiler.sol\\\";\\n\\nimport {\\n    ProtocolsRepository\\n} from \\\"contracts/accountAbstraction/compliance/libraries/ProtocolsRepository.sol\\\";\\nimport {Address} from \\\"contracts/libraries/Address.sol\\\";\\nimport {Command, CommandLibrary, SafeCall} from \\\"contracts/libraries/CommandLibrary.sol\\\";\\n\\nimport {Path} from \\\"./libraries/Path.sol\\\";\\nimport {Script, ScriptCompiler} from \\\"./libraries/ScriptCompiler.sol\\\";\\n\\ncontract JitCompiler is IJitCompiler {\\n    using ProtocolsRepository for string;\\n    using Address for address;\\n    using SafeCall for address;\\n    using CommandLibrary for Command[];\\n    using Path for bytes;\\n    using ScriptCompiler for Script;\\n\\n    function compile(Script calldata script) external override returns (Command[] memory result) {\\n        result = new Command[](0);\\n        for (uint256 index; index < script.sequence.length; index++) {\\n            Command[] memory cmds = script.compileAt(\\n                index,\\n                compileIncreasePositionInstruction,\\n                compileDecreasePositionInstruction,\\n                compileExchangeInstruction,\\n                compileExchangeAllInstruction\\n            );\\n            result = result.append(cmds);\\n        }\\n    }\\n\\n    function compileIncreasePositionInstruction(\\n        IncreasePositionInstruction calldata _instruction\\n    ) public virtual override returns (Command[] memory) {\\n        _instruction.protocol.enforceProtocolSupported();\\n        address adapter = _instruction.protocol.getProtocolEvaluator();\\n\\n        bytes memory result = adapter.safeDelegateCall(\\n            abi.encodeCall(IIncreasePositionEvaluator.evaluate, (msg.sender, _instruction.request))\\n        );\\n        return abi.decode(result, (Command[]));\\n    }\\n\\n    function compileDecreasePositionInstruction(\\n        DecreasePositionInstruction calldata _instruction\\n    ) public virtual override returns (Command[] memory) {\\n        _instruction.protocol.enforceProtocolSupportedOrSuspended();\\n        address adapter = _instruction.protocol.getProtocolEvaluator();\\n\\n        bytes memory result = adapter.safeDelegateCall(\\n            abi.encodeCall(IDecreasePositionEvaluator.evaluate, (msg.sender, _instruction.request))\\n        );\\n        return abi.decode(result, (Command[]));\\n    }\\n\\n    function compileExchangeInstruction(\\n        ExchangeInstruction calldata _instruction\\n    ) public virtual override returns (Command[] memory) {\\n        _instruction.protocol.enforceProtocolSupportedOrSuspended();\\n        address adapter = _instruction.protocol.getProtocolEvaluator();\\n\\n        bytes memory result = adapter.safeDelegateCall(\\n            abi.encodeCall(IExchangeEvaluator.evaluate, (msg.sender, _instruction.request))\\n        );\\n        return abi.decode(result, (Command[]));\\n    }\\n\\n    function compileExchangeAllInstruction(\\n        ExchangeAllInstruction calldata _instruction\\n    ) public virtual override returns (Command[] memory) {\\n        _instruction.protocol.enforceProtocolSupportedOrSuspended();\\n        address adapter = _instruction.protocol.getProtocolEvaluator();\\n\\n        IExchangeEvaluator.ExchangeRequest memory req = _instruction.request;\\n        address tokenIn = _instruction.request.path.extractTokenIn();\\n\\n        req.amountIn = tokenIn.isEth() ? msg.sender.balance : IERC20(tokenIn).balanceOf(msg.sender);\\n\\n        bytes memory result = adapter.safeDelegateCall(\\n            abi.encodeCall(IExchangeEvaluator.evaluate, (msg.sender, req))\\n        );\\n        return abi.decode(result, (Command[]));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/libraries/Path.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Path {\\n    using Path for bytes;\\n\\n    uint256 internal constant ADDRESS_LEN = 20;\\n    uint256 internal constant POOL_ID_LEN = 4;\\n    uint256 internal constant NEXT_OFFSET = ADDRESS_LEN + POOL_ID_LEN;\\n\\n    error InvalidPathLength(uint256);\\n\\n    function extractTokenIn(bytes calldata _path) internal pure returns (address tokenIn_) {\\n        _path.ensureValid();\\n        tokenIn_ = _path.extractTokenInUnsafe();\\n    }\\n\\n    function extractTokenInUnsafe(bytes calldata _path) internal pure returns (address tokenIn_) {\\n        tokenIn_ = address(bytes20(_path[0:ADDRESS_LEN]));\\n    }\\n\\n    function extractTokenOut(bytes calldata _path) internal pure returns (address tokenOut_) {\\n        _path.ensureValid();\\n        tokenOut_ = _path.extractTokenOutUnsafe();\\n    }\\n\\n    function extractTokenOutUnsafe(bytes calldata _path) internal pure returns (address tokenOut_) {\\n        uint256 len = _path.length;\\n        tokenOut_ = address(bytes20(_path[len - ADDRESS_LEN:len]));\\n    }\\n\\n    /* solhint-disable var-name-mixedcase */\\n    function extractPool(\\n        bytes calldata _path,\\n        uint256 _poolNumber\\n    ) internal pure returns (address tokenIn__, address tokenOut_, uint32 poolId_____) {\\n        /* solhint-enable var-name-mixedcase */\\n        _path.ensureValid();\\n        uint256 ptr = _poolNumber * NEXT_OFFSET;\\n\\n        tokenIn__ = address(bytes20(_path[ptr:(ptr = ptr + ADDRESS_LEN)]));\\n        poolId_____ = uint32(bytes4(_path[ptr:(ptr = ptr + POOL_ID_LEN)]));\\n        tokenOut_ = address(bytes20(_path[ptr:(ptr = ptr + ADDRESS_LEN)]));\\n    }\\n\\n    function getNumberOfPools(bytes calldata _path) internal pure returns (uint256) {\\n        _path.ensureValid();\\n        return (_path.length - ADDRESS_LEN) / NEXT_OFFSET;\\n    }\\n\\n    function ensureValid(bytes calldata _path) internal pure {\\n        if (!isValid(_path)) revert InvalidPathLength(_path.length);\\n    }\\n\\n    function isValid(bytes calldata _path) private pure returns (bool) {\\n        if (_path.length < ADDRESS_LEN) return false;\\n        return (_path.length - ADDRESS_LEN) % NEXT_OFFSET == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accountAbstraction/interpreter/libraries/ScriptCompiler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {\\n    Command,\\n    IJitCompiler,\\n    Script\\n} from \\\"contracts/interfaces/accountAbstraction/interpreter/IJitCompiler.sol\\\";\\n\\nlibrary ScriptCompiler {\\n    error InvalidSequenceAtIndex(uint256 index);\\n\\n    // TODO: refactor this as soon as https://github.com/ethereum/solidity/issues/13776 closed\\n    function compileAt(\\n        Script calldata self,\\n        uint256 index,\\n        function(IJitCompiler.IncreasePositionInstruction calldata)\\n            returns (Command[] memory) evalIPI,\\n        function(IJitCompiler.DecreasePositionInstruction calldata)\\n            returns (Command[] memory) evalDPI,\\n        function(IJitCompiler.ExchangeInstruction calldata) returns (Command[] memory) evalEI,\\n        function(IJitCompiler.ExchangeAllInstruction calldata) returns (Command[] memory) evalEAI\\n    ) internal returns (Command[] memory) {\\n        uint256 ipLen = self.increasePositionInstructions.length;\\n        uint256 dpLen = self.decreasePositionInstructions.length;\\n        uint256 exLen = self.exchangeInstructions.length;\\n        uint256 eaLen = self.exchangeAllInstructions.length;\\n\\n        uint256 idx = self.sequence[index];\\n        uint256 maxIdx;\\n\\n        if (idx < (maxIdx = ipLen)) {\\n            return evalIPI(self.increasePositionInstructions[idx]);\\n        } else if (idx < (maxIdx += dpLen)) {\\n            return evalDPI(self.decreasePositionInstructions[idx - (maxIdx - dpLen)]);\\n        } else if (idx < (maxIdx += exLen)) {\\n            return evalEI(self.exchangeInstructions[idx - (maxIdx - exLen)]);\\n        } else if (idx < (maxIdx += eaLen)) {\\n            return evalEAI(self.exchangeAllInstructions[idx - (maxIdx - eaLen)]);\\n        } else {\\n            revert InvalidSequenceAtIndex(index);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/compliance/Asset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {AssetLibrary} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\n\\n/**\\n * @title Asset\\n * @dev Represents an asset with its token address and the amount.\\n * @param token The address of the asset's token.\\n * @param amount The amount of the asset.\\n */\\nstruct Asset {\\n    address token;\\n    uint256 amount;\\n}\\n\\nusing AssetLibrary for Asset global;\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/compliance/IWhitelistingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @title Status\\n * @notice Enum representing status of a record (e.g., token, protocol, operator)\\n *  used for operation validation.\\n * @notice Validators must adhere to the following rules for different operations and contexts:\\n *  1) For exchanges: `operator`, `pool`, and `input token` *MAY* be either supported or suspended, but the `output token` *MUST* be supported.\\n *  2) For deposits: `operator`, `pool`, and every `token` in the `pool` *MUST* be supported.\\n *  3) For withdrawals: `operator`, `pool`, and each `token` *MAY* be either supported or suspended.\\n *\\n * @dev **Note** that deposit denotes **all** ways of aquiring liquidity such\\n * as token deposit, LP tokens stake, NFT mint etc.\\n */\\nenum Status {\\n    Undefined,\\n    Supported,\\n    Suspended\\n}\\n\\n/**\\n * @title WhitelistingAddressRecord\\n * @notice A struct to store an address and its support status.\\n * @dev This struct stores an address and its support status.\\n * @dev `source`: The address to be stored.\\n * @dev `supported`: Indicates whether the address is supported or not.\\n */\\nstruct WhitelistingAddressRecord {\\n    address source;\\n    bool supported;\\n}\\n\\n/**\\n * @title TokenPermission\\n * @notice This enum represents different levels of permission for a token, including trading, collateral, leverage, and full access.\\n * @dev `None`: Represents no permissions granted for the token.\\n * @dev `TradeOnly`: Represents the lowest permission level where you can only trade the token.\\n * @dev `Collateral`: Allows you to use the token as collateral.\\n * @dev `Leverage`: Allows you to leverage the token.\\n * @dev `FullAccess`: Represents the highest permission level where you have full access to trade, use as collateral, and leverage the token.\\n */\\nenum TokenPermission {\\n    None,\\n    TradeOnly,\\n    Collateral,\\n    Leverage,\\n    FullAccess\\n}\\n\\n/**\\n * @title WhitelistingTokenRecord\\n * @notice This struct stores an address and its support status for whitelisting, collateral and leverage.\\n * @dev `source`: The address of the token.\\n * @dev `supported`: Whether the token can be received from a protocol trades.\\n * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n */\\nstruct WhitelistingTokenRecord {\\n    address source;\\n    bool supported;\\n    TokenPermission permission;\\n}\\n\\n/**\\n * @notice An error indicating that a token is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported token is used.\\n * @dev `token`: The address of the unsupported token.\\n */\\nerror TokenIsNotSupported(address token);\\n\\n/**\\n * @notice An error indicating that a token is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended token is used.\\n * @dev `token`: The address of the suspended token.\\n */\\nerror TokenIsSuspended(address token);\\n\\n/**\\n * @notice An error indicating that the token's permission level is insufficient for the requested action.\\n * @dev This can be thrown at [`IWhitelistingController.enforceTokenHasPermission()`](./interface.IWhitelistingController.html#enforcetokenhaspermission)\\n * @param token The address of the token that has insufficient permissions.\\n * @param required The required permission level for the action.\\n * @param actual The actual permission level of the token.\\n */\\nerror TokenLevelInsufficient(address token, TokenPermission required, TokenPermission actual);\\n\\n/**\\n * @notice An error indicating that an operator is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported operator is used.\\n * @dev `operator`: The address of the unsupported operator.\\n */\\nerror OperatorIsNotSupported(address operator);\\n\\n/**\\n * @notice An error indicating that an operator is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended operator is used.\\n * @dev `operator`: The address of the suspended operator.\\n */\\nerror OperatorIsSuspended(address operator);\\n\\n/**\\n * @notice An error indicating that a protocol is not supported by the whitelisting controller.\\n * @dev This error is thrown when an unsupported protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsNotSupported(string protocol);\\n\\n/**\\n * @notice An error indicating that a protocol is suspended by the whitelisting controller.\\n * @dev This error is thrown when a suspended protocol is used.\\n * @dev `protocol`: The identification string of the unsupported protocol.\\n */\\nerror ProtocolIsSuspended(string protocol);\\n\\n/**\\n * @title IWhitelistingController\\n * @notice Interface for managing whitelisting of tokens, protocols, and operators.\\n */\\ninterface IWhitelistingController {\\n    /**\\n     * @dev Emitted when the support status of a protocol changes.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `supported`: Whether the protocol is supported or not.\\n     */\\n    event ProtocolSupportChanged(string indexed protocol, bool supported);\\n\\n    /**\\n     * @dev Emitted when the support status of a token changes.\\n     * @dev `token`: The address of the token.\\n     * @dev `supported`: Whether the token is supported or not.\\n     * @dev `permission`: Level of [`TokenPermission`](./enum.TokenPermission.html).\\n     */\\n    event TokenSupportChanged(address indexed token, bool supported, TokenPermission permission);\\n\\n    /**\\n     * @dev Emitted when the support status of an operator changes for a specific protocol.\\n     * @dev `protocol`: The identification string of the protocol.\\n     * @dev `operator`: The address of the operator.\\n     * @dev `supported`: Whether the operator is supported or not.\\n     */\\n    event OperatorSupportChanged(string indexed protocol, address indexed operator, bool supported);\\n\\n    /**\\n     * @notice Update the support status of multiple tokens.\\n     * @dev Emits a [`TokenSupportChanged()`](#tokensupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no token status changed.\\n     * @param _tokens An array of [`WhitelistingTokenRecord`](./struct.WhitelistingTokenRecord.html)\\n     * structs containing token addresses, support statuses and permissions.\\n     */\\n    function updateTokensSupport(WhitelistingTokenRecord[] calldata _tokens) external;\\n\\n    /**\\n     * @notice Update the support status of a protocol.\\n     * @dev Emits a [`ProtocolSupportChanged()`](#protocolsupportchanged) event.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if protocol status is up to date.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _adapterEvaluator The address of the adapter evaluator for the protocol.\\n     * @param _supported Whether the protocol is supported or not.\\n     */\\n    function updateProtocolSupport(\\n        string calldata _protocol,\\n        address _adapterEvaluator,\\n        bool _supported\\n    ) external;\\n\\n    /**\\n     * @notice Update the support status of multiple operators for a specific protocol.\\n     * @dev Emits a [`OperatorSupportChanged()`](#operatorsupportchanged) event for each token whose status changed.\\n     * @dev Reverts with an [`AlreadyUpToDate()`](/interfaces/base/CommonErrors.sol/error.AlreadyUpToDate.html)\\n     *  error if no operator status changed.\\n     * @param _protocol The identification string of the protocol.\\n     * @param _operators An array of `WhitelistingAddressRecord` structs containing operator addresses and support statuses.\\n     */\\n    function updateOperatorsSupport(\\n        string calldata _protocol,\\n        WhitelistingAddressRecord[] calldata _operators\\n    ) external;\\n\\n    /**\\n     * @notice Ensures that a token has the specified permission level.\\n     * @dev This check does not enforce exact match, but only that level is sufficient.\\n     *  So if `permission` is TokenPermission.TradeOnly and the token has TokenPermission.Collateral\\n     *  then it assumes that level is sufficient since Collateral level includes both\\n     *  TradeOnly and Collateral levels.\\n     * @param token The address of the token to check for permission.\\n     * @param permission The required [`TokenPermission`](TokenPermission) to be enforced.\\n     */\\n    function enforceTokenHasPermission(address token, TokenPermission permission) external view;\\n\\n    /**\\n     * @notice Returns the support status of a token as well as it's permissions.\\n     * @param _token The address of the token.\\n     * @return The [`Status`](./enum.Status.html)\\n     * of the token.\\n     * @return The [`TokenPermission`](./enum.TokenPermission.html)\\n     * of the token.\\n     */\\n    function getTokenSupport(address _token) external view returns (Status, TokenPermission);\\n\\n    /**\\n     * @notice Returns the support status of a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getProtocolStatus(string calldata _protocol) external view returns (Status);\\n\\n    /**\\n     * @notice Returns the address of the adapter evaluator for a protocol.\\n     * @param _protocol The identification string of the protocol.\\n     * @return The address of the adapter evaluator for the protocol.\\n     */\\n    function getProtocolEvaluator(string calldata _protocol) external view returns (address);\\n\\n    /**\\n     * @notice Returns the support status of an operator for a specific protocol.\\n     * @param _operator The address of the operator.\\n     * @return operatorStatus_ The [`Status`](./enum.Status.html)\\n     *  of the operator.\\n     * @return protocolStatus_ The [`Status`](./enum.Status.html)\\n     *  of the protocol.\\n     */\\n    function getOperatorStatus(\\n        address _operator\\n    ) external view returns (Status operatorStatus_, Status protocolStatus_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IDecreasePositionEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Asset} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\nimport {Command} from \\\"../Command.sol\\\";\\nimport {PositionDescriptor} from \\\"./PositionDescriptor.sol\\\";\\n\\ninterface IDecreasePositionEvaluator {\\n    /**\\n     * @notice Request structure for decreasing a position.\\n     * @dev `descriptor`: The [`PositionDescriptor`](/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol/struct.PositionDescriptor.html)\\n     *  struct.\\n     * @dev `liquidity`: Abstract amount that can be interpreted differently in different protocols (e.g., amount of LP tokens to burn).\\n     * @dev `minOutput`: [`Asset`](/interfaces/accountAbstraction/compliance/Asset.sol/struct.Asset.html) array with minimum amounts that must be retrieved from the position.\\n     */\\n    struct DecreasePositionRequest {\\n        PositionDescriptor descriptor;\\n        uint256 liquidity;\\n        Asset[] minOutput;\\n    }\\n\\n    /**\\n     * @notice Evaluate a decrease position request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`DecreasePositionRequest`](#decreasepositionrequest) struct containing decrease position details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        DecreasePositionRequest calldata _request\\n    ) external returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IExchangeEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Command} from \\\"../Command.sol\\\";\\n\\n/**\\n * @title IExchangeEvaluator\\n * @notice Interface for compiling commands for token exchanges for different protocols.\\n */\\ninterface IExchangeEvaluator {\\n    /**\\n     * @notice Structure for an exchange token request.\\n     * @dev `path`: Encoded path of tokens to follow in the exchange, including pool identifiers.\\n     * 20 bytes(tokenA) + 4 byte(poolId_A_B) + 20 bytes(tokenB) + ...\\n     * ... + 4 byte(poolId_N-1_N) + 20 bytes(tokenN).\\n     * @dev `extraData`: Additional data specific to a particular protocol, such as the response from a 1Inch Exchange API.\\n     * @dev `amountIn`: The amount of tokenA to spend.\\n     * @dev `minAmountOut`: The minimum amount of tokenN to receive.\\n     * @dev `recipient`: The recipient of tokenN.\\n     */\\n    struct ExchangeRequest {\\n        bytes path;\\n        bytes extraData;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        address recipient;\\n    }\\n\\n    /**\\n     * @notice Constructs an exchange token request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`ExchangeRequest`](#exchangerequest) struct containing exchange token details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        ExchangeRequest calldata _request\\n    ) external view returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/IIncreasePositionEvaluator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Asset} from \\\"contracts/libraries/AssetLibrary.sol\\\";\\nimport {Command} from \\\"../Command.sol\\\";\\nimport {PositionDescriptor} from \\\"./PositionDescriptor.sol\\\";\\n\\ninterface IIncreasePositionEvaluator {\\n    /**\\n     * @notice Structure for an increase position request.\\n     * @dev `descriptor`: The [`PositionDescriptor`](/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol/struct.PositionDescriptor.html)\\n     *  struct.\\n     * @dev `input`: An array of [`Asset`](/interfaces/accountAbstraction/compliance/Asset.sol/struct.Asset.html) representing the token-amounts that will be added to the position.\\n     * @dev `minLiquidityOut`: An abstract amount that can be interpreted differently in different protocols (e.g., minimum amount of LP tokens to receive).\\n     */\\n    struct IncreasePositionRequest {\\n        PositionDescriptor descriptor;\\n        Asset[] input;\\n        uint256 minLiquidityOut;\\n    }\\n\\n    /**\\n     * @notice Evaluate a increase position request.\\n     * @param _operator Address which initiated the request\\n     * @param _request The [`IncreasePositionRequest`](#increasepositionrequest) struct containing increase position details.\\n     * @return cmds_ An array of [`Command`](../../Command.sol/struct.Command.html) to execute the request.\\n     */\\n    function evaluate(\\n        address _operator,\\n        IncreasePositionRequest calldata _request\\n    ) external returns (Command[] memory cmds_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/adapters/PositionDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// TODO CRYPTO-145: Possibly move into appropriate interface?\\n/**\\n * @notice Used to determine the required position for an operation.\\n * @dev `poolId`: An identifier that is unique within a single protocol.\\n * @dev `extraData`: Additional data used to specify the position, for example\\n * this is used in OneInchV5Evaluator to pass swap tx generated via 1inch API.\\n */\\nstruct PositionDescriptor {\\n    uint256 poolId;\\n    bytes extraData;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/Command.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {CommandLibrary} from \\\"contracts/libraries/CommandLibrary.sol\\\";\\n\\n/**\\n * @title Command\\n * @notice Contains arguments for a low-level call.\\n * @dev This struct allows deferring the call's execution, suspending it by passing it to another function or contract.\\n * @dev `target` The address to be called.\\n * @dev `value` Value to send in the call.\\n * @dev `payload` Encoded call with function selector and arguments.\\n */\\nstruct Command {\\n    address target;\\n    uint256 value;\\n    bytes payload;\\n}\\n\\nusing CommandLibrary for Command global;\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/IJitCompiler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IDecreasePositionEvaluator} from \\\"./adapters/IDecreasePositionEvaluator.sol\\\";\\nimport {IExchangeEvaluator} from \\\"./adapters/IExchangeEvaluator.sol\\\";\\nimport {IIncreasePositionEvaluator} from \\\"./adapters/IIncreasePositionEvaluator.sol\\\";\\nimport {Command} from \\\"./Command.sol\\\";\\nimport {Script} from \\\"./Script.sol\\\";\\n\\n/**\\n * @title IJitCompiler\\n * @notice Compiles a script or an instruction into an array of [Commands](/interfaces/accountAbstraction/interpreter/Command.sol/struct.Command.html) using protocol evaluator matching `protocol` field in the underlying instruction.\\n */\\ninterface IJitCompiler {\\n    /**\\n     * @notice Instruction designed to increase:\\n     *  1. Caller's magnitude of the position determined by the [PositionDescriptor](../adapters/PositionDescriptor.sol/struct.PositionDescriptor.html).\\n     *  2. Callee's balance of token(s).\\n     * @notice and decrease:\\n     *  1. Caller's balance of token(s).\\n     *  2. (*Optional*) callee's supply of the position determined by the [PositionDescriptor](../adapters/PositionDescriptor.sol/struct.PositionDescriptor.html).\\n     * @dev This instruction will be evaluated in [IncreasePositionEvaluator](../adapters/IIncreasePositionEvaluator.sol/interface.IIncreasePositionEvaluator.html).\\n     * @dev `protocol` The name of the underlying protocol where instruction should be evaluated. For example: `curvefi`, `oneinchv5`\\n     * @dev `request` The [`IncreasePositionRequest`](../adapters/IIncreasePositionEvaluator.sol/interface.IIncreasePositionEvaluator.html#increasepositionrequest) containing all information required for instruction evaluation.\\n     */\\n    struct IncreasePositionInstruction {\\n        string protocol;\\n        IIncreasePositionEvaluator.IncreasePositionRequest request;\\n    }\\n\\n    /**\\n     * @notice Instruction designed to increase:\\n     *  1. Caller's balance of token(s).\\n     *  2. (*Optional*) callee's supply of the position determined by the [PositionDescriptor](../adapters/PositionDescriptor.sol/struct.PositionDescriptor.html).\\n     * @notice and decrease:\\n     *  1. Caller's magnitude of the position determined by the [PositionDescriptor](../adapters/PositionDescriptor.sol/struct.PositionDescriptor.html).\\n     *  2. Callee's balance of token(s).\\n     * @dev This instruction will be evaluated in [DecreasePositionEvaluator](../adapters/IDecreasePositionEvaluator.sol/interface.IDecreasePositionEvaluator.html).\\n     * @dev `protocol` The name of the underlying protocol where instruction should be evaluated. For example: `curvefi`, `oneinchv5`\\n     * @dev `request` The [`DecreasePositionRequest`](../adapters/IDecreasePositionEvaluator.sol/interface.IDecreasePositionEvaluator.html#decreasepositionrequest) containing all information required for instruction evaluation.\\n     */\\n    struct DecreasePositionInstruction {\\n        string protocol;\\n        IDecreasePositionEvaluator.DecreasePositionRequest request;\\n    }\\n\\n    /**\\n     * @notice Instruction designed to increase:\\n     *  1. (*Optional*) caller's balance of output token.\\n     *  2. Callee's balance of input token.\\n     * @notice and decrease:\\n     *  1. Caller's balance of input token.\\n     *  2. (*Optional*) callee's balance of output token.\\n     * @dev This instruction will be evaluated in [ExchangeEvaluator](../adapters/IExchangeEvaluator.sol/interface.IExchangeEvaluator.html).\\n     * @dev `protocol` The name of the underlying protocol where instruction should be evaluated. For example: `curvefi`, `oneinchv5`\\n     * @dev `request` The [`ExchangeRequest`](../adapters/IExchangeEvaluator.sol/interface.IExchangeEvaluator.html#exchangerequest) containing all information required for instruction evaluation.\\n     */\\n    struct ExchangeInstruction {\\n        string protocol;\\n        IExchangeEvaluator.ExchangeRequest request;\\n    }\\n\\n    /**\\n     * @notice Instruction designed to increase:\\n     *  1. (*Optional*) caller's balance of output token.\\n     *  2. Callee's balance of input token.\\n     * @notice and decrease:\\n     *  1. Caller's balance of input token.\\n     *  2. (*Optional*) callee's balance of output token.\\n     * @dev This instruction will be evaluated in [ExchangeEvaluator](../adapters/IExchangeEvaluator.sol/interface.IExchangeEvaluator.html).\\n     * @dev **Important note:** this instruction has an identical structure to [ExchangeInstruction](#exchangeinstruction), but differs from it in that [ExchangeInstruction](#exchangeinstruction) is static and [ExchangeAllInstruction](#exchangeallinstruction) is dynamic. This means that the `amountIn` field will be set at runtime by the compiler to the caller's balance by the input token.\\n     * @dev `protocol` The name of the underlying protocol where instruction should be evaluated. For example: `curvefi`, `oneinchv5`\\n     * @dev `request` The [`ExchangeRequest`](../adapters/IExchangeEvaluator.sol/interface.IExchangeEvaluator.html#exchangerequest) containing all information required for instruction evaluation. The `amountIn` field will be set at runtime by the compiler to the caller's balance by the input token.\\n     */\\n    struct ExchangeAllInstruction {\\n        string protocol;\\n        IExchangeEvaluator.ExchangeRequest request;\\n    }\\n\\n    /**\\n     * @notice Compiles a [Script](../Script.sol/struct.Script.html).\\n     * @dev **Important note:** don't put two instructions to the same script if one depend on the other because content of the script will be compiled at once meaning that balance changes will be applied only after the compilation of the entire script. If you have two instructions and one depends on the other, put them into different scripts.\\n     * @param script Script to compile\\n     * @return An array of [`Commands`](../Command.sol/struct.Command.html) to execute the instruction.\\n     */\\n    function compile(Script calldata script) external returns (Command[] memory);\\n\\n    /**\\n     * @notice Compiles an increase position instruction.\\n     * @param instruction The [`IncreasePositionInstruction`](#increasepositioninstruction) struct.\\n     * @return An array of [`Commands`](../Command.sol/struct.Command.html) to execute the instruction.\\n     */\\n    function compileIncreasePositionInstruction(\\n        IncreasePositionInstruction calldata instruction\\n    ) external returns (Command[] memory);\\n\\n    /**\\n     * @notice Compiles a decrease position instruction.\\n     * @param instruction The [`DecreasePositionInstruction`](#decreasepositioninstruction) struct.\\n     * @return An array of [`Commands`](../Command.sol/struct.Command.html) to execute the instruction.\\n     */\\n    function compileDecreasePositionInstruction(\\n        DecreasePositionInstruction calldata instruction\\n    ) external returns (Command[] memory);\\n\\n    /**\\n     * @notice Compiles an exchange instruction.\\n     * @param instruction The [`ExchangeInstruction`](#exchangeinstruction) struct.\\n     * @return An array of [`Commands`](../Command.sol/struct.Command.html) to execute the instruction.\\n     */\\n    function compileExchangeInstruction(\\n        ExchangeInstruction calldata instruction\\n    ) external returns (Command[] memory);\\n\\n    /**\\n     * @notice Sets the `amountIn` field to the balance of the caller by the input token and compiles an underlying exchange instruction.\\n     * @dev `amountIn` will be overriden with the balance of the caller by the input token.\\n     * @param instruction The [`ExchangeAllInstruction`](#exchangeallinstruction) struct.\\n     * @return An array of [`Commands`](../Command.sol/struct.Command.html) to execute the instruction.\\n     */\\n    function compileExchangeAllInstruction(\\n        ExchangeAllInstruction calldata instruction\\n    ) external returns (Command[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/accountAbstraction/interpreter/Script.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IJitCompiler} from \\\"./IJitCompiler.sol\\\";\\n\\n/**\\n * @title Script\\n * @notice A structure defining a script with various instructions for a JIT compiler.\\n * @notice The [JIT compiler](../IJitCompiler.sol/interface.IJitCompiler.html) will compile it the following way:\\n * 1. Flatten content's instructions arrays into a single-dimensional array: `flattened = [...increasePositionInstructions, ...decreasePositionInstructions, ...exchangeInstructions, ...exchangeAllInstructions]`.\\n * 2. Execute `flattened[PC]` where `PC = sequence[i]` where `i` is the index of current loop iteration, starting from `i = 0`.\\n * 3. Increment current loop interation index: `i = i + 1`.\\n * 4. If `i < length(flattened)` go to step 2.\\n * @dev `sequence` Auto-incrementing read-only program counter. Determines the order of execution of the instruction within the script.\\n * @dev `increasePositionInstructions` An array of [`IncreasePositionInstructions`](../IJitCompiler.sol/interface.IJitCompiler.html#increasepositioninstruction).\\n * @dev `decreasePositionInstructions` An array of [`DecreasePositionInstructions`](../IJitCompiler.sol/interface.IJitCompiler.html#decreasepositioninstruction).\\n * @dev `exchangeInstructions` An array of [`ExchangeInstructions`](../IJitCompiler.sol/interface.IJitCompiler.html#exchangeinstruction).\\n * @dev `exchangeAllInstructions` An array of [`ExchangeAllInstructions`](../IJitCompiler.sol/interface.IJitCompiler.html#exchangeallinstruction).\\n */\\nstruct Script {\\n    uint256[] sequence;\\n    IJitCompiler.IncreasePositionInstruction[] increasePositionInstructions;\\n    IJitCompiler.DecreasePositionInstruction[] decreasePositionInstructions;\\n    IJitCompiler.ExchangeInstruction[] exchangeInstructions;\\n    IJitCompiler.ExchangeAllInstruction[] exchangeAllInstructions;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/base/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n/**\\n * @notice An error indicating that the amount for the specified token is zero.\\n * @param token The address of the token with a zero amount.\\n */\\nerror AmountMustNotBeZero(address token);\\n\\n/**\\n * @notice An error indicating that an address must not be zero.\\n */\\nerror AddressMustNotBeZero();\\n\\n/**\\n * @notice An error indicating that an array must not be empty.\\n */\\nerror ArrayMustNotBeEmpty();\\n\\n/**\\n * @notice An error indicating storage is already up to date and doesn't need further processing.\\n * @dev This error is thrown when attempting to update an entity(s) that is(are) already up to date.\\n */\\nerror AlreadyUpToDate();\\n\\n/**\\n * @notice An error indicating that an action is unauthorized for the specified account.\\n * @param account The address of the unauthorized account.\\n */\\nerror UnauthorizedAccount(address account);\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nlibrary Address {\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    function set(bytes32 _slot, address _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    function get(bytes32 _slot) internal view returns (address result_) {\\n        assembly {\\n            result_ := sload(_slot)\\n        }\\n    }\\n\\n    function isEth(address _token) internal pure returns (bool) {\\n        return _token == ETH || _token == address(0);\\n    }\\n\\n    function sort(address _a, address _b) internal pure returns (address, address) {\\n        return _a < _b ? (_a, _b) : (_b, _a);\\n    }\\n\\n    function sort(address[4] memory _array) internal pure returns (address[4] memory _sorted) {\\n        // Sorting network for the array of length 4\\n        (_sorted[0], _sorted[1]) = sort(_array[0], _array[1]);\\n        (_sorted[2], _sorted[3]) = sort(_array[2], _array[3]);\\n\\n        (_sorted[0], _sorted[2]) = sort(_sorted[0], _sorted[2]);\\n        (_sorted[1], _sorted[3]) = sort(_sorted[1], _sorted[3]);\\n        (_sorted[1], _sorted[2]) = sort(_sorted[1], _sorted[2]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AssetLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {SafeTransferLib} from \\\"solady/src/utils/SafeTransferLib.sol\\\";\\n\\nimport {Asset} from \\\"contracts/interfaces/accountAbstraction/compliance/Asset.sol\\\";\\nimport {AmountMustNotBeZero} from \\\"contracts/interfaces/base/CommonErrors.sol\\\";\\n\\nimport {Address} from \\\"./Address.sol\\\";\\n\\nlibrary AssetLibrary {\\n    using SafeTransferLib for address;\\n    using Address for address;\\n\\n    error NotEnoughReceived(address token, uint256 expected, uint256 received);\\n\\n    function forward(Asset calldata _self, address _to) internal {\\n        if (_self.amount == 0) revert AmountMustNotBeZero(_self.token);\\n\\n        if (_self.token.isEth()) _to.safeTransferETH(_self.amount);\\n        else _self.token.safeTransferFrom(msg.sender, _to, _self.amount);\\n    }\\n\\n    function enforceReceived(Asset calldata _self) internal view {\\n        if (_self.amount == 0) revert AmountMustNotBeZero(_self.token);\\n\\n        uint256 balance = _self.token.isEth()\\n            ? address(this).balance\\n            : _self.token.balanceOf(address(this));\\n\\n        if (balance < _self.amount) revert NotEnoughReceived(_self.token, _self.amount, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/CommandLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\nimport {SafeCall} from \\\"contracts/libraries/SafeCall.sol\\\";\\n\\n/**\\n * @notice Utility to convert often-used methods into a Command object\\n */\\nlibrary CommandPresets {\\n    function approve(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.approve, (_to, _amount));\\n    }\\n\\n    function transfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal pure returns (Command memory cmd_) {\\n        cmd_.target = _token;\\n        cmd_.payload = abi.encodeCall(IERC20.transfer, (_to, _amount));\\n    }\\n}\\n\\nlibrary CommandExecutor {\\n    using SafeCall for Command[];\\n\\n    function execute(Command[] calldata _cmds) external {\\n        _cmds.safeCallAll();\\n    }\\n}\\n\\nlibrary CommandLibrary {\\n    using CommandLibrary for Command[];\\n\\n    function last(Command[] memory _self) internal pure returns (Command memory) {\\n        return _self[_self.length - 1];\\n    }\\n\\n    function asArray(Command memory _self) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1);\\n        result_[0] = _self;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](2);\\n        result_[0] = _self;\\n        result_[1] = _cmd;\\n    }\\n\\n    function concat(\\n        Command memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + 1);\\n        result_[0] = _self;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _cmds[i - 1];\\n        }\\n    }\\n\\n    function append(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + _cmds.length);\\n        uint256 i;\\n        for (; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _cmds[i - _self.length];\\n        }\\n    }\\n\\n    function push(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_self.length + 1);\\n        for (uint256 i; i < _self.length; i++) {\\n            result_[i] = _self[i];\\n        }\\n        result_[_self.length] = _cmd;\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command memory _cmd\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](1 + _self.length);\\n        result_[0] = _cmd;\\n        for (uint256 i = 1; i < result_.length; i++) {\\n            result_[i] = _self[i - 1];\\n        }\\n    }\\n\\n    function unshift(\\n        Command[] memory _self,\\n        Command[] memory _cmds\\n    ) internal pure returns (Command[] memory result_) {\\n        result_ = new Command[](_cmds.length + _self.length);\\n        uint256 i;\\n        for (; i < _cmds.length; i++) {\\n            result_[i] = _cmds[i];\\n        }\\n        for (; i < result_.length; i++) {\\n            result_[i] = _self[i - _cmds.length];\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = CommandPresets.approve(_token, _self.target, _amount).concat(_self);\\n        } else {\\n            result_ = _self.asArray();\\n        }\\n    }\\n\\n    function populateWithRevokeAndApprove(\\n        Command memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        return\\n            CommandPresets.approve(_token, _self.target, 0).concat(\\n                _self.populateWithApprove(_token, _amount)\\n            );\\n    }\\n\\n    function populateWithApprove(\\n        Command[] memory _self,\\n        address _token,\\n        uint256 _amount\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amount != 0) {\\n            result_ = _self.unshift(\\n                CommandPresets.approve(_token, _self[_self.length - 1].target, _amount)\\n            );\\n        } else {\\n            result_ = _self;\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[2] memory _tokens,\\n        uint256[2] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] != 0) {\\n                result_ = populateWithApprove(_self, _tokens[0], _amounts[0]);\\n            } else {\\n                result_ = populateWithApprove(_self, _tokens[1], _amounts[1]);\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[3] memory _tokens,\\n        uint256[3] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2]],\\n                    [_amounts[1], _amounts[2]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2]],\\n                    [_amounts[0], _amounts[2]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1]],\\n                    [_amounts[0], _amounts[1]]\\n                );\\n            }\\n        }\\n    }\\n\\n    function populateWithApprove(\\n        Command memory _self,\\n        address[4] memory _tokens,\\n        uint256[4] memory _amounts\\n    ) internal pure returns (Command[] memory result_) {\\n        if (_amounts[0] != 0 && _amounts[1] != 0 && _amounts[2] != 0 && _amounts[3] != 0) {\\n            result_ = CommandPresets\\n                .approve(_tokens[0], _self.target, _amounts[0])\\n                .concat(CommandPresets.approve(_tokens[1], _self.target, _amounts[1]))\\n                .push(CommandPresets.approve(_tokens[2], _self.target, _amounts[2]))\\n                .push(CommandPresets.approve(_tokens[3], _self.target, _amounts[3]))\\n                .push(_self);\\n        } else {\\n            if (_amounts[0] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[1], _tokens[2], _tokens[3]],\\n                    [_amounts[1], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[1] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[2], _tokens[3]],\\n                    [_amounts[0], _amounts[2], _amounts[3]]\\n                );\\n            } else if (_amounts[2] == 0) {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[3]],\\n                    [_amounts[0], _amounts[1], _amounts[3]]\\n                );\\n            } else {\\n                result_ = populateWithApprove(\\n                    _self,\\n                    [_tokens[0], _tokens[1], _tokens[2]],\\n                    [_amounts[0], _amounts[1], _amounts[2]]\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Command} from \\\"contracts/interfaces/accountAbstraction/interpreter/Command.sol\\\";\\n\\n/**\\n * @notice Safe methods performing a low-level calls that revert\\n * if the call was not successful\\n */\\nlibrary SafeCall {\\n    using Address for address;\\n\\n    function safeCallAll(Command[] memory _cmds) internal {\\n        for (uint256 i; i < _cmds.length; i++) {\\n            safeCall(_cmds[i]);\\n        }\\n    }\\n\\n    function safeCall(Command memory _cmd) internal returns (bytes memory result_) {\\n        result_ = safeCall(_cmd.target, _cmd.value, _cmd.payload);\\n    }\\n\\n    function safeCall(address _target, bytes memory _data) internal returns (bytes memory result_) {\\n        result_ = safeCall(_target, 0, _data);\\n    }\\n\\n    function safeCall(\\n        address _target,\\n        uint256 _value,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionCallWithValue(_data, _value);\\n    }\\n\\n    function safeDelegateCall(\\n        address _target,\\n        bytes memory _data\\n    ) internal returns (bytes memory result_) {\\n        result_ = _target.functionDelegateCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"InvalidPathLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"InvalidSequenceAtIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"}],\"name\":\"ProtocolIsNotSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"}],\"name\":\"ProtocolIsSuspended\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"sequence\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionDescriptor\",\"name\":\"descriptor\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Asset[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidityOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IIncreasePositionEvaluator.IncreasePositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.IncreasePositionInstruction[]\",\"name\":\"increasePositionInstructions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionDescriptor\",\"name\":\"descriptor\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Asset[]\",\"name\":\"minOutput\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDecreasePositionEvaluator.DecreasePositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.DecreasePositionInstruction[]\",\"name\":\"decreasePositionInstructions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IExchangeEvaluator.ExchangeRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.ExchangeInstruction[]\",\"name\":\"exchangeInstructions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IExchangeEvaluator.ExchangeRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.ExchangeAllInstruction[]\",\"name\":\"exchangeAllInstructions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Script\",\"name\":\"script\",\"type\":\"tuple\"}],\"name\":\"compile\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionDescriptor\",\"name\":\"descriptor\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Asset[]\",\"name\":\"minOutput\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDecreasePositionEvaluator.DecreasePositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.DecreasePositionInstruction\",\"name\":\"_instruction\",\"type\":\"tuple\"}],\"name\":\"compileDecreasePositionInstruction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IExchangeEvaluator.ExchangeRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.ExchangeAllInstruction\",\"name\":\"_instruction\",\"type\":\"tuple\"}],\"name\":\"compileExchangeAllInstruction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IExchangeEvaluator.ExchangeRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.ExchangeInstruction\",\"name\":\"_instruction\",\"type\":\"tuple\"}],\"name\":\"compileExchangeInstruction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionDescriptor\",\"name\":\"descriptor\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Asset[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidityOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IIncreasePositionEvaluator.IncreasePositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct IJitCompiler.IncreasePositionInstruction\",\"name\":\"_instruction\",\"type\":\"tuple\"}],\"name\":\"compileIncreasePositionInstruction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct Command[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "JitCompiler", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}