// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.0 <0.8.0;
pragma abicoder v2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/cryptography/ECDSA.sol";
import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";
import "./Graphene.sol";
import "./PHRHolders.sol";

contract Airdrop is Ownable {
    using ECDSA for bytes32;
    using SafeMathUpgradeable for uint256;

    string private constant ARRAY_LEN_ERR = "Array length isn't equal";

    bytes32 private _merkleRoot;

    Graphene private _graphene;
    PHRHolders private _phrHolders;

    mapping (string => bool) private _spent;

    constructor(bytes32 merkleRoot_, address grapheneAddress_, address phrHolders_) {
        _merkleRoot = merkleRoot_;
        _graphene = Graphene(grapheneAddress_);
        _phrHolders = PHRHolders(phrHolders_);
    }

    function setRoot(bytes32 merkleRoot_) external onlyOwner {
        _merkleRoot = merkleRoot_;
    }

    function setGraphene(address graphene_) external onlyOwner {
        _graphene = Graphene(graphene_);
    }

    function setPhrHolders(address phrHolders_) external onlyOwner {
        _phrHolders = PHRHolders(phrHolders_);
    }

    function contractTokenBalance() external view returns(uint) {
        return _graphene.balanceOf(address(this));
    }

    function claimRestOfTokens() external onlyOwner returns(bool)  {
        require(_graphene.balanceOf(address(this)) > 0, "Contract HAS ZERO Graphene Tokens");
        require(_graphene.transfer(owner(), _graphene.balanceOf(address(this))));
        return true;
    }

    function checkProof(bytes32[] memory proof, bytes32 hash) view internal returns (bool) {
        bytes32 el;
        bytes32 h = hash;

        for (uint i = 0; i <= proof.length - 1; i += 1) {
            el = proof[i];

            if (h < el) {
                h = keccak256(abi.encodePacked(h, el));
            } else {
                h = keccak256(abi.encodePacked(el, h));
            }
        }

        return h == _merkleRoot;
    }

    function createMessageHash(string memory ownerAddress, uint256 amount) pure internal returns (bytes32) {
        return keccak256(abi.encodePacked(ownerAddress, amount));
    }

    /**
     * @dev Gives 'ethOwner' access to airdrop claim for 'phrAddress'.
     *
     * Requirements:
     *
     * - signature is valid and signed by white listed signer.
     *
     * @param ethOwner - Ethereum address which will be able to receive airdrop.
     * @param phrAddress - Phore address allowed receive airdrop.
     * @param signature - Signature of message generated by white listed signer.
     */
    function possessPhrAddress(address ethOwner, string memory phrAddress, bytes memory signature) public returns(bool){
        return _phrHolders.setPhoreOwner(ethOwner, phrAddress, signature);
    }

    /**
     * @dev Claims user airdrop based on parameters.
     *
     * Requirements:
     *
     * - tokens are not claimed yet for `phrAddr` address
     * - `amount` must be bigger than zero.
     * @param merkleProof - Publicly known proof that merkle tree contains user's message.
     * @param phrAddr - Phore address allowed receive airdrop.
     * @param amount - Number of graphene tokens to be claimed.
     */
    function claimGFN(address sender, bytes32[] memory merkleProof, string memory phrAddr, uint256 amount) public {
        require(!_spent[phrAddr], "Already spent!");
        require(amount > 0, "Amount CANNOT BE ZERO!");
        _spent[phrAddr] = true;

        bytes32 messageHash = createMessageHash(phrAddr, amount);
        require(checkProof(merkleProof, messageHash), "Merkle Proof is invalid!");
        require(_phrHolders.isPhoreOwner(sender, phrAddr), "Msg Sender is not an owner!");
        require(_graphene.transfer(sender, amount), "Transfer failed.");
    }

    /**
     * @dev Claims entire user airdrop in one transfer based on parameters.
     *
     * Requirements:
     *
     * - tokens are not claimed yet for `phrAddr` address
     * - `amount` must be bigger than zero.
     * @param merkleProofs - List of claim proofs for particular PHR addresses.
     * @param phrAddresses - List of Phore addresses able to receive airdrop.
     * @param amounts - List of GFN amounts for particular PHR addresses.
     */
    function claimAllGFN(address sender, bytes32[][] memory merkleProofs, string[] memory phrAddresses,
        uint256[] memory amounts, bytes[] memory signatures) public {
        require(merkleProofs.length == phrAddresses.length, ARRAY_LEN_ERR);
        require(merkleProofs.length == amounts.length, ARRAY_LEN_ERR);
        require(merkleProofs.length == signatures.length, ARRAY_LEN_ERR);

        uint amount = 0;
        uint256 phrAddressLen = phrAddresses.length;
        for (uint256 i = 0; i < phrAddressLen; i++) {
            if(_spent[phrAddresses[i]]) {
                continue;
            }

            bytes32 messageHash = createMessageHash(phrAddresses[i], amounts[i]);
            if (!checkProof(merkleProofs[i], messageHash)) {
                continue;
            }

            if (!_phrHolders.isPhoreOwner(sender, phrAddresses[i])) {
                if (!_phrHolders.setPhoreOwner(sender, phrAddresses[i], signatures[i])) {
                    continue;
                }
            }

            _spent[phrAddresses[i]] = true;
            amount = amount.add(amounts[i]);
        }

        require(amount > 0, "Amount CANNOT BE ZERO!");
        require(_graphene.transfer(sender, amount), "Transfer failed.");
    }


    /**
     * @dev Gives 'ethOwner' access to airdrop claim for 'phrAddress'.
     *
     * Requirements:
     *
     * - signature is valid and signed by white listed signer.
     *
     * @param phrAddress - Phore address able to receive airdrop.
     * @param signature - Signature of message generated by white listed signer.
     * @param amount - GFN amount for particular PHR address.
     * @param merkleProof - Claim proof for particular PHR address.
     */
    function possessPhrAddressAndClaimGFN(string memory phrAddress, bytes memory signature,
        uint256 amount, bytes32[] memory merkleProof) external {
        possessPhrAddress(_msgSender(), phrAddress, signature);
        claimGFN(_msgSender(), merkleProof, phrAddress, amount);
    }

    /**
     * @dev Gives 'ethOwner' access to airdrop claim for 'phrAddresses'.
     *
     * Requirements:
     *
     * - signatures are valid and signed by white listed signer.
     *
     * @param phrAddresses - List of Phore addresses able to receive airdrop.
     * @param signatures - List of signatures of messages generated by white listed signer.
     * @param amounts - List of GFN amounts for particular PHR addresses.
     * @param merkleProofs - List of claim proofs for particular PHR addresses.
     */
    function possessMultiplePhrAddressAndClaimGFN(string[] memory phrAddresses, bytes[] memory signatures,
        uint256[] memory amounts, bytes32[][] memory merkleProofs) external {
        require(phrAddresses.length == signatures.length, ARRAY_LEN_ERR);
        require(phrAddresses.length == amounts.length, ARRAY_LEN_ERR);
        require(phrAddresses.length == merkleProofs.length, ARRAY_LEN_ERR);

        claimAllGFN(_msgSender(), merkleProofs, phrAddresses, amounts, signatures);
    }
}