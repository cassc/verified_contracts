{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/ttg/src/DistributionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"../lib/common/src/interfaces/IERC20.sol\\\";\\n\\nimport { StatefulERC712 } from \\\"../lib/common/src/StatefulERC712.sol\\\";\\n\\nimport { ERC20Helper } from \\\"../lib/erc20-helper/src/ERC20Helper.sol\\\";\\n\\nimport { PureEpochs } from \\\"./libs/PureEpochs.sol\\\";\\n\\nimport { IERC6372 } from \\\"./abstract/interfaces/IERC6372.sol\\\";\\n\\nimport { IZeroToken } from \\\"./interfaces/IZeroToken.sol\\\";\\nimport { IDistributionVault } from \\\"./interfaces/IDistributionVault.sol\\\";\\n\\n/**\\n * @title  A contract enabling pro rata distribution of arbitrary tokens to holders of the Zero Token.\\n * @author M^0 Labs\\n */\\ncontract DistributionVault is IDistributionVault, StatefulERC712 {\\n    /* ============ Variables ============ */\\n\\n    /**\\n     * @dev The scale to apply when accumulating an account's claimable token, per epoch, before dividing.\\n     *      It is arbitrarily set to `1e9`. The smaller it is, the more dust will accumulate in the contract.\\n     *      Conversely, the larger it is, the more likely it is to overflow when accumulating.\\n     *      The more epochs that are claimed at once, the less dust will remain.\\n     */\\n    uint256 internal constant _GRANULARITY = 1e9;\\n\\n    // solhint-disable-next-line max-line-length\\n    // keccak256(\\\"Claim(address account,address token,uint256 startEpoch,uint256 endEpoch,address destination,uint256 nonce,uint256 deadline)\\\")\\n    /// @inheritdoc IDistributionVault\\n    bytes32 public constant CLAIM_TYPEHASH = 0x4b4633c3c305de33d5d9cf70f2712f26961648cd68d020c2556a9e43be58051d;\\n\\n    /// @inheritdoc IDistributionVault\\n    address public immutable zeroToken;\\n\\n    /// @dev The last recorded balance per token.\\n    mapping(address token => uint256 balance) internal _lastTokenBalances;\\n\\n    /// @inheritdoc IDistributionVault\\n    mapping(address token => mapping(uint256 epoch => uint256 amount)) public distributionOfAt;\\n\\n    /// @inheritdoc IDistributionVault\\n    mapping(address token => mapping(uint256 epoch => mapping(address account => bool claimed))) public hasClaimed;\\n\\n    /* ============ Constructor ============ */\\n\\n    /**\\n     * @notice Constructs a new DistributionVault contract.\\n     * @param  zeroToken_ The address of the Zero Token contract.\\n     */\\n    constructor(address zeroToken_) StatefulERC712(\\\"DistributionVault\\\") {\\n        if ((zeroToken = zeroToken_) == address(0)) revert InvalidZeroTokenAddress();\\n    }\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /// @inheritdoc IDistributionVault\\n    function claim(\\n        address token_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_,\\n        address destination_\\n    ) external returns (uint256) {\\n        return _claim(msg.sender, token_, startEpoch_, endEpoch_, destination_);\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function claimBySig(\\n        address account_,\\n        address token_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_,\\n        address destination_,\\n        uint256 deadline_,\\n        uint8 v_,\\n        bytes32 r_,\\n        bytes32 s_\\n    ) external returns (uint256) {\\n        unchecked {\\n            // NOTE: Need to cache to avoid stack too deep error.\\n            uint256 nonce_ = nonces[account_];\\n\\n            _revertIfInvalidSignature(\\n                account_,\\n                getClaimDigest(account_, token_, startEpoch_, endEpoch_, destination_, nonce_, deadline_),\\n                v_,\\n                r_,\\n                s_\\n            );\\n\\n            nonces[account_] = nonce_ + 1; // Nonce realistically cannot overflow.\\n        }\\n\\n        _revertIfExpired(deadline_);\\n\\n        return _claim(account_, token_, startEpoch_, endEpoch_, destination_);\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function claimBySig(\\n        address account_,\\n        address token_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_,\\n        address destination_,\\n        uint256 deadline_,\\n        bytes memory signature_\\n    ) external returns (uint256) {\\n        unchecked {\\n            // NOTE: Need to cache to avoid stack too deep error.\\n            uint256 nonce_ = nonces[account_];\\n\\n            _revertIfInvalidSignature(\\n                account_,\\n                getClaimDigest(account_, token_, startEpoch_, endEpoch_, destination_, nonce_, deadline_),\\n                signature_\\n            );\\n\\n            nonces[account_] = nonce_ + 1; // Nonce realistically cannot overflow.\\n        }\\n\\n        _revertIfExpired(deadline_);\\n\\n        return _claim(account_, token_, startEpoch_, endEpoch_, destination_);\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function distribute(address token_) external returns (uint256 amount_) {\\n        uint256 currentEpoch_ = clock();\\n        amount_ = getDistributable(token_);\\n\\n        emit Distribution(token_, currentEpoch_, amount_);\\n\\n        unchecked {\\n            // NOTE: Can be done unchecked because a token's total supply fits in a `uint256`.\\n            distributionOfAt[token_][currentEpoch_] += amount_; // Add to the distribution for the current epoch.\\n            _lastTokenBalances[token_] += amount_; // Track this contract's latest balance.\\n        }\\n    }\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @inheritdoc IDistributionVault\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external pure returns (string memory) {\\n        return PureEpochs.clockMode();\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function getClaimDigest(\\n        address account_,\\n        address token_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_,\\n        address destination_,\\n        uint256 nonce_,\\n        uint256 deadline_\\n    ) public view returns (bytes32) {\\n        return\\n            _getDigest(\\n                keccak256(\\n                    abi.encode(\\n                        CLAIM_TYPEHASH,\\n                        account_,\\n                        token_,\\n                        startEpoch_,\\n                        endEpoch_,\\n                        destination_,\\n                        nonce_,\\n                        deadline_\\n                    )\\n                )\\n            );\\n    }\\n\\n    /// @inheritdoc IERC6372\\n    function clock() public view returns (uint48) {\\n        return uint48(PureEpochs.currentEpoch());\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function getClaimable(\\n        address token_,\\n        address account_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_\\n    ) public view returns (uint256 claimable_) {\\n        uint256 currentEpoch_ = clock();\\n\\n        if (endEpoch_ >= currentEpoch_) revert NotPastTimepoint(endEpoch_, currentEpoch_); // Range must be past epochs.\\n\\n        // Starting must be before or same as end epoch.\\n        if (startEpoch_ > endEpoch_) revert StartEpochAfterEndEpoch(startEpoch_, endEpoch_);\\n\\n        uint256[] memory balances_ = IZeroToken(zeroToken).pastBalancesOf(account_, startEpoch_, endEpoch_);\\n        uint256[] memory totalSupplies_ = IZeroToken(zeroToken).pastTotalSupplies(startEpoch_, endEpoch_);\\n        uint256 epochCount_ = endEpoch_ - startEpoch_ + 1;\\n\\n        for (uint256 index_; index_ < epochCount_; ++index_) {\\n            uint256 balance_ = balances_[index_];\\n\\n            // Skip epochs with no Zero token balance (i.e. no distribution).\\n            if (balance_ == 0) continue;\\n\\n            unchecked {\\n                if (hasClaimed[token_][startEpoch_ + index_][account_]) continue;\\n            }\\n\\n            // Scale the amount by `_GRANULARITY` to avoid some amount of truncation while accumulating.\\n            claimable_ +=\\n                (distributionOfAt[token_][startEpoch_ + index_] * balance_ * _GRANULARITY) /\\n                totalSupplies_[index_];\\n        }\\n\\n        unchecked {\\n            // Divide the accumulated amount by `_GRANULARITY` to get the actual claimable amount.\\n            return claimable_ / _GRANULARITY;\\n        }\\n    }\\n\\n    /// @inheritdoc IDistributionVault\\n    function getDistributable(address token_) public view returns (uint256) {\\n        return IERC20(token_).balanceOf(address(this)) - _lastTokenBalances[token_];\\n    }\\n\\n    /* ============ Internal Interactive Functions ============ */\\n\\n    /**\\n     * @dev    Allows a caller to claim `token_` distribution between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  account_     The address of the account claiming the token.\\n     * @param  token_       The address of the token being claimed.\\n     * @param  startEpoch_  The starting epoch number as a clock value.\\n     * @param  endEpoch_    The ending epoch number as a clock value.\\n     * @param  destination_ The address the account where the claimed token will be sent.\\n     * @return claimed_     The total amount of token claimed by `account_`.\\n     */\\n    function _claim(\\n        address account_,\\n        address token_,\\n        uint256 startEpoch_,\\n        uint256 endEpoch_,\\n        address destination_\\n    ) internal returns (uint256 claimed_) {\\n        if (destination_ == address(0)) revert InvalidDestinationAddress();\\n\\n        claimed_ = getClaimable(token_, account_, startEpoch_, endEpoch_);\\n\\n        // NOTE: `getClaimable` skips epochs the account already claimed, so we can safely mark all epochs as claimed.\\n        // NOTE: This effectively iterates over the range again (is done in `getClaimable`), but the alternative is\\n        //       a lot of code duplication.\\n        for (uint256 epoch_ = startEpoch_; epoch_ < endEpoch_ + 1; ++epoch_) {\\n            hasClaimed[token_][epoch_][account_] = true;\\n        }\\n\\n        _lastTokenBalances[token_] -= claimed_; // Track this contract's latest balance of `token_`.\\n\\n        emit Claim(token_, account_, startEpoch_, endEpoch_, claimed_);\\n\\n        if (!ERC20Helper.transfer(token_, destination_, claimed_)) revert TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  ERC20 Token Standard.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-20: https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when `spender` has been approved for `amount` of the token balance of `account`.\\n     * @param  account The address of the account.\\n     * @param  spender The address of the spender being approved for the allowance.\\n     * @param  amount  The amount of the allowance being approved.\\n     */\\n    event Approval(address indexed account, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when `amount` tokens is transferred from `sender` to `recipient`.\\n     * @param  sender    The address of the sender who's token balance is decremented.\\n     * @param  recipient The address of the recipient who's token balance is incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     */\\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.\\n     * @dev    MUST emit an `Approval` event.\\n     * @param  spender The address of the account being allowed to spend up to the allowed amount.\\n     * @param  amount  The amount of the allowance being approved.\\n     * @return Whether or not the approval was successful.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice Allows a calling account to transfer `amount` tokens to `recipient`.\\n     * @param  recipient The address of the recipient who's token balance will be incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     * @return Whether or not the transfer was successful.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.\\n     * @param  sender    The address of the sender who's token balance will be decremented.\\n     * @param  recipient The address of the recipient who's token balance will be incremented.\\n     * @param  amount    The amount of tokens being transferred.\\n     * @return Whether or not the transfer was successful.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the allowance `spender` is allowed to spend on behalf of `account`.\\n     * @param  account The address of the account who's token balance `spender` is allowed to spend.\\n     * @param  spender The address of an account allowed to spend on behalf of `account`.\\n     * @return The amount `spender` can spend on behalf of `account`.\\n     */\\n    function allowance(address account, address spender) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the token balance of `account`.\\n     * @param  account The address of some account.\\n     * @return The token balance of `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals UIs should assume all amounts have.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the name of the contract/token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the current total supply of the token.\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/StatefulERC712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IStatefulERC712 } from \\\"./interfaces/IStatefulERC712.sol\\\";\\n\\nimport { ERC712Extended } from \\\"./ERC712Extended.sol\\\";\\n\\n/**\\n * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.\\n * @author M^0 Labs\\n * @dev    An abstract implementation to satisfy stateful EIP-712 with nonces.\\n */\\nabstract contract StatefulERC712 is IStatefulERC712, ERC712Extended {\\n    /// @inheritdoc IStatefulERC712\\n    mapping(address account => uint256 nonce) public nonces; // Nonces for all signatures.\\n\\n    /**\\n     * @notice Construct the StatefulERC712 contract.\\n     * @param  name_ The name of the contract.\\n     */\\n    constructor(string memory name_) ERC712Extended(name_) {}\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/erc20-helper/src/ERC20Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\nimport { IERC20Like } from \\\"./interfaces/IERC20Like.sol\\\";\\n\\n/**\\n * @title Small Library to standardize erc20 token interactions.\\n */\\nlibrary ERC20Helper {\\n\\n    /**************************************************************************************************************************************/\\n    /*** Internal Functions                                                                                                             ***/\\n    /**************************************************************************************************************************************/\\n\\n    function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\\n    }\\n\\n    function transferFrom(address token_, address from_, address to_, uint256 amount_) internal returns (bool success_) {\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\\n    }\\n\\n    function approve(address token_, address spender_, uint256 amount_) internal returns (bool success_) {\\n        // If setting approval to zero fails, return false.\\n        if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) return false;\\n\\n        // If `amount_` is zero, return true as the previous step already did this.\\n        if (amount_ == uint256(0)) return true;\\n\\n        // Return the result of setting the approval to `amount_`.\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\\n    }\\n\\n    function _call(address token_, bytes memory data_) private returns (bool success_) {\\n        if (token_.code.length == uint256(0)) return false;\\n\\n        bytes memory returnData;\\n        ( success_, returnData ) = token_.call(data_);\\n\\n        return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/libs/PureEpochs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @notice Defines epochs as periods away from STARTING_TIMESTAMP timestamp.\\n * @author M^0 Labs\\n * @dev    Provides a `uint16` epoch clock value.\\n */\\nlibrary PureEpochs {\\n    /* ============ Variables ============ */\\n\\n    /// @notice The timestamp of the start of Epoch 1.\\n    uint40 internal constant STARTING_TIMESTAMP = 1713099600;\\n\\n    /// @notice The approximate target of seconds an epoch should endure.\\n    uint40 internal constant EPOCH_PERIOD = 1296000;\\n\\n    /* ============ Internal View/Pure Functions ============ */\\n\\n    /// @dev Returns the current epoch number.\\n    function currentEpoch() internal view returns (uint16) {\\n        return uint16(((block.timestamp - STARTING_TIMESTAMP) / EPOCH_PERIOD) + 1);\\n    }\\n\\n    /// @dev Returns the remaining time in the current epoch.\\n    function timeRemainingInCurrentEpoch() internal view returns (uint40) {\\n        return STARTING_TIMESTAMP + (currentEpoch() * EPOCH_PERIOD) - uint40(block.timestamp);\\n    }\\n\\n    function clockMode() internal pure returns (string memory) {\\n        return \\\"mode=epoch&epochUnderlyingSource=blockTimestamp&epochStartingTimestamp=1713099600&epochPeriod=1296000\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/abstract/interfaces/IERC6372.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Contract clock properties.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-6372: https://eips.ethereum.org/EIPS/eip-6372\\n */\\ninterface IERC6372 {\\n    /// @notice Returns a machine-readable string description of the clock the contract is operating on.\\n    function CLOCK_MODE() external view returns (string memory);\\n\\n    /// @notice Returns the current timepoint according to the mode the contract is operating on.\\n    function clock() external view returns (uint48);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/interfaces/IZeroToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IEpochBasedVoteToken } from \\\"../abstract/interfaces/IEpochBasedVoteToken.sol\\\";\\n\\n/**\\n * @title  An instance of an EpochBasedVoteToken delegating minting control to a Standard Governor,\\n *         and enabling range queries for past balances, voting powers, delegations, and  total supplies.\\n * @author M^0 Labs\\n */\\ninterface IZeroToken is IEpochBasedVoteToken {\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when the length of some accounts array does not equal the length of some balances array.\\n     * @param  accountsLength The length of the accounts array.\\n     * @param  balancesLength The length of the balances array.\\n     */\\n    error ArrayLengthMismatch(uint256 accountsLength, uint256 balancesLength);\\n\\n    /// @notice Revert message when the Standard Governor Deployer specified in the constructor is address(0).\\n    error InvalidStandardGovernorDeployerAddress();\\n\\n    /// @notice Revert message when the caller is not the Standard Governor.\\n    error NotStandardGovernor();\\n\\n    /// @notice Revert message when the start of an inclusive range query is larger than the end.\\n    error StartEpochAfterEndEpoch();\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Mints `amount` token to `recipient`.\\n     * @param  recipient The address of the account receiving minted token.\\n     * @param  amount    The amount of token to mint.\\n     */\\n    function mint(address recipient, uint256 amount) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns an array of token balances of `account`\\n     *         between `startEpoch` and `endEpoch` past inclusive clocks.\\n     * @param  account    The address of some account.\\n     * @param  startEpoch The starting epoch number as a clock value.\\n     * @param  endEpoch   The ending epoch number as a clock value.\\n     * @return An array of token balances, each relating to an epoch in the inclusive range.\\n     */\\n    function pastBalancesOf(\\n        address account,\\n        uint256 startEpoch,\\n        uint256 endEpoch\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Returns an array of total token supplies between `startEpoch` and `endEpoch` clocks inclusively.\\n     * @param  startEpoch The starting epoch number as a clock value.\\n     * @param  endEpoch   The ending epoch number as a clock value.\\n     * @return An array of total supplies, each relating to an epoch in the inclusive range.\\n     */\\n    function pastTotalSupplies(uint256 startEpoch, uint256 endEpoch) external view returns (uint256[] memory);\\n\\n    /// @notice Returns the address of the Standard Governor.\\n    function standardGovernor() external view returns (address);\\n\\n    /// @notice Returns the address of the Standard Governor Deployer.\\n    function standardGovernorDeployer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/interfaces/IDistributionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IStatefulERC712 } from \\\"../../lib/common/src/interfaces/IStatefulERC712.sol\\\";\\nimport { IERC6372 } from \\\"../abstract/interfaces/IERC6372.sol\\\";\\n\\n/**\\n * @title  A contract enabling pro rata distribution of arbitrary tokens to holders of the Zero Token.\\n * @author M^0 Labs\\n */\\ninterface IDistributionVault is IERC6372, IStatefulERC712 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when `account` claims `token` distribution between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  token      The address of the token being claimed.\\n     * @param  account    The address of the account claiming the distribution.\\n     * @param  startEpoch The starting epoch number as a clock value.\\n     * @param  endEpoch   The ending epoch number as a clock value.\\n     * @param  amount     The total amount of token claimed by `account`.\\n     */\\n    event Claim(address indexed token, address indexed account, uint256 startEpoch, uint256 endEpoch, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when `token` is distributed pro rata to all holders at epoch `epoch`.\\n     * @param  token  The address of the token being distributed.\\n     * @param  epoch  The epoch number as a clock value.\\n     * @param  amount The total amount of token being distributed.\\n     */\\n    event Distribution(address indexed token, uint256 indexed epoch, uint256 amount);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Revert message when the destination address is address(0).\\n    error InvalidDestinationAddress();\\n\\n    /// @notice Revert message when the Zero Token address set at deployment is address(0).\\n    error InvalidZeroTokenAddress();\\n\\n    /**\\n     * @notice Revert message when a query for past values is for a timepoint greater or equal to the current clock.\\n     * @param  timepoint The timepoint being queried.\\n     * @param  clock     The current timepoint.\\n     */\\n    error NotPastTimepoint(uint256 timepoint, uint256 clock);\\n\\n    /// @notice Revert message when the start epoch is greater than the end epoch.\\n    error StartEpochAfterEndEpoch(uint256 startEpoch, uint256 endEpoch);\\n\\n    /// @notice Revert message when a token transfer, from this contract, fails.\\n    error TransferFailed();\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Allows a caller to claim `token` distribution between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  token       The address of the token being claimed.\\n     * @param  startEpoch  The starting epoch number as a clock value.\\n     * @param  endEpoch    The ending epoch number as a clock value.\\n     * @param  destination The address the account where the claimed token will be sent.\\n     * @return claimed     The total amount of token claimed by `account`.\\n     */\\n    function claim(\\n        address token,\\n        uint256 startEpoch,\\n        uint256 endEpoch,\\n        address destination\\n    ) external returns (uint256 claimed);\\n\\n    /**\\n     * @notice Allows a signer to claim `token` distribution between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  account     The purported address of the signing account.\\n     * @param  token       The address of the token being claimed.\\n     * @param  startEpoch  The starting epoch number as a clock value.\\n     * @param  endEpoch    The ending epoch number as a clock value.\\n     * @param  destination The address of the account where the claimed token will be sent.\\n     * @param  deadline    The last timestamp at which the signature is still valid.\\n     * @param  v           v of the signature.\\n     * @param  r           r of the signature.\\n     * @param  s           s of the signature.\\n     * @return claimed     The total amount of token claimed by `account`.\\n     */\\n    function claimBySig(\\n        address account,\\n        address token,\\n        uint256 startEpoch,\\n        uint256 endEpoch,\\n        address destination,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 claimed);\\n\\n    /**\\n     * @notice Allows a signer to claim `token` distribution between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  account     The purported address of the signing account.\\n     * @param  token       The address of the token being claimed.\\n     * @param  startEpoch  The starting epoch number as a clock value.\\n     * @param  endEpoch    The ending epoch number as a clock value.\\n     * @param  destination The address of the account where the claimed token will be sent.\\n     * @param  deadline    The last timestamp at which the signature is still valid.\\n     * @param  signature   A byte array signature.\\n     * @return claimed     The total amount of token claimed by `account`.\\n     */\\n    function claimBySig(\\n        address account,\\n        address token,\\n        uint256 startEpoch,\\n        uint256 endEpoch,\\n        address destination,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external returns (uint256 claimed);\\n\\n    /**\\n     * @notice Distributes the unaccounted balance of `token`.\\n     * @param  token The address of the token being distributed.\\n     * @return The total amount of additional tokens accounted in this distribution event.\\n     */\\n    function distribute(address token) external returns (uint256);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 typehash used in the encoding of the digest for the claimBySig function.\\n    function CLAIM_TYPEHASH() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the total amount of `token` eligible for distribution to holder at the end of epoch `epoch`.\\n     * @param  token The address of some token.\\n     * @param  epoch The epoch number as a clock value.\\n     * @return The total amount of token eligible for distribution to holder at the end of the epoch.\\n     */\\n    function distributionOfAt(address token, uint256 epoch) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of `token` `account` can claim between inclusive epochs `startEpoch` and `endEpoch`.\\n     * @param  token      The address of some token.\\n     * @param  account    The address of some account.\\n     * @param  startEpoch The starting epoch number as a clock value.\\n     * @param  endEpoch   The ending epoch number as a clock value.\\n     * @return The amount of token that `account` has yet to claim for these epochs, if any.\\n     */\\n    function getClaimable(\\n        address token,\\n        address account,\\n        uint256 startEpoch,\\n        uint256 endEpoch\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).\\n     * @param  account     The purported address of the signing account.\\n     * @param  token       The address of the token being claimed.\\n     * @param  startEpoch  The starting epoch number as a clock value.\\n     * @param  endEpoch    The ending epoch number as a clock value.\\n     * @param  destination The address the account where the claimed token will be sent.\\n     * @param  nonce       The nonce of the account claiming the token.\\n     * @param  deadline    The last timestamp at which the signature is still valid.\\n     * @return The digest to be signed.\\n     */\\n    function getClaimDigest(\\n        address account,\\n        address token,\\n        uint256 startEpoch,\\n        uint256 endEpoch,\\n        address destination,\\n        uint256 nonce,\\n        uint256 deadline\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the additional balance of `token_` that is not yet distributed.\\n     * @param  token The address of some token.\\n     * @return The total amount of token owned by the vault that is yet to be distributed.\\n     */\\n    function getDistributable(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns whether `account` has already claimed their `token` distribution for `epoch`.\\n     * @param  token   The address of some token.\\n     * @param  account The address of some account.\\n     * @param  epoch   The epoch number as a clock value.\\n     * @return Whether `account` has already claimed `token` rewards for `epoch`.\\n     */\\n    function hasClaimed(address token, uint256 epoch, address account) external view returns (bool);\\n\\n    /// @notice Returns the name of the contract.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the address of the Zero Token holders must have in order to be eligible for distributions.\\n    function zeroToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IStatefulERC712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712Extended } from \\\"./IERC712Extended.sol\\\";\\n\\n/**\\n * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.\\n * @author M^0 Labs\\n */\\ninterface IStatefulERC712 is IERC712Extended {\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when a signing account's nonce is not the expected current nonce.\\n     * @param  nonce         The nonce used in the signature.\\n     * @param  expectedNonce The expected nonce to be used in a signature by the signing account.\\n     */\\n    error InvalidAccountNonce(uint256 nonce, uint256 expectedNonce);\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the next nonce to be used in a signature by `account`.\\n     * @param  account The address of some account.\\n     * @return nonce   The next nonce to be used in a signature by `account`.\\n     */\\n    function nonces(address account) external view returns (uint256 nonce);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/ERC712Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712 } from \\\"./interfaces/IERC712.sol\\\";\\nimport { IERC712Extended } from \\\"./interfaces/IERC712Extended.sol\\\";\\n\\nimport { SignatureChecker } from \\\"./libs/SignatureChecker.sol\\\";\\n\\n/**\\n * @title  Typed structured data hashing and signing via EIP-712, extended by EIP-5267.\\n * @author M^0 Labs\\n * @dev    An abstract implementation to satisfy EIP-712: https://eips.ethereum.org/EIPS/eip-712\\n */\\nabstract contract ERC712Extended is IERC712Extended {\\n    /* ============ Variables ============ */\\n\\n    /// @dev keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 internal constant _EIP712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev keccak256(\\\"1\\\")\\n    bytes32 internal constant _EIP712_VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev Initial Chain ID set at deployment.\\n    uint256 internal immutable _INITIAL_CHAIN_ID;\\n\\n    /// @dev Initial EIP-712 domain separator set at deployment.\\n    bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;\\n\\n    /// @dev The name of the contract.\\n    string internal _name;\\n\\n    /* ============ Constructor ============ */\\n\\n    /**\\n     * @notice Constructs the EIP-712 domain separator.\\n     * @param  name_ The name of the contract.\\n     */\\n    constructor(string memory name_) {\\n        _name = name_;\\n\\n        _INITIAL_CHAIN_ID = block.chainid;\\n        _INITIAL_DOMAIN_SEPARATOR = _getDomainSeparator();\\n    }\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @inheritdoc IERC712Extended\\n    function eip712Domain()\\n        external\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields_,\\n            string memory name_,\\n            string memory version_,\\n            uint256 chainId_,\\n            address verifyingContract_,\\n            bytes32 salt_,\\n            uint256[] memory extensions_\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _name,\\n            \\\"1\\\",\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /// @inheritdoc IERC712\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == _INITIAL_CHAIN_ID ? _INITIAL_DOMAIN_SEPARATOR : _getDomainSeparator();\\n    }\\n\\n    /* ============ Internal View/Pure Functions ============ */\\n\\n    /**\\n     * @dev    Computes the EIP-712 domain separator.\\n     * @return The EIP-712 domain separator.\\n     */\\n    function _getDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _EIP712_DOMAIN_HASH,\\n                    keccak256(bytes(_name)),\\n                    _EIP712_VERSION_HASH,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev    Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).\\n     * @param  internalDigest_ The internal digest.\\n     * @return The digest to be signed.\\n     */\\n    function _getDigest(bytes32 internalDigest_) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), internalDigest_));\\n    }\\n\\n    /**\\n     * @dev   Revert if the signature is expired.\\n     * @param expiry_ Timestamp at which the signature expires or max uint256 for no expiry.\\n     */\\n    function _revertIfExpired(uint256 expiry_) internal view {\\n        if (block.timestamp > expiry_) revert SignatureExpired(expiry_, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev   Revert if the signature is invalid.\\n     * @dev   We first validate if the signature is a valid ECDSA signature and return early if it is the case.\\n     *        Then, we validate if it is a valid ERC-1271 signature, and return early if it is the case.\\n     *        If not, we revert with the error from the ECDSA signature validation.\\n     * @param signer_    The signer of the signature.\\n     * @param digest_    The digest that was signed.\\n     * @param signature_ The signature.\\n     */\\n    function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes memory signature_) internal view {\\n        SignatureChecker.Error error_ = SignatureChecker.validateECDSASignature(signer_, digest_, signature_);\\n\\n        if (error_ == SignatureChecker.Error.NoError) return;\\n\\n        if (SignatureChecker.isValidERC1271Signature(signer_, digest_, signature_)) return;\\n\\n        _revertIfError(error_);\\n    }\\n\\n    /**\\n     * @dev    Returns the signer of a signed digest, via EIP-712, and reverts if the signature is invalid.\\n     * @param  digest_ The digest that was signed.\\n     * @param  v_      v of the signature.\\n     * @param  r_      r of the signature.\\n     * @param  s_      s of the signature.\\n     * @return signer_ The signer of the digest.\\n     */\\n    function _getSignerAndRevertIfInvalidSignature(\\n        bytes32 digest_,\\n        uint8 v_,\\n        bytes32 r_,\\n        bytes32 s_\\n    ) internal pure returns (address signer_) {\\n        SignatureChecker.Error error_;\\n\\n        (error_, signer_) = SignatureChecker.recoverECDSASigner(digest_, v_, r_, s_);\\n\\n        _revertIfError(error_);\\n    }\\n\\n    /**\\n     * @dev   Revert if the signature is invalid.\\n     * @param signer_ The signer of the signature.\\n     * @param digest_ The digest that was signed.\\n     * @param r_      An ECDSA/secp256k1 signature parameter.\\n     * @param vs_     An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes32 r_, bytes32 vs_) internal pure {\\n        _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, r_, vs_));\\n    }\\n\\n    /**\\n     * @dev   Revert if the signature is invalid.\\n     * @param signer_ The signer of the signature.\\n     * @param digest_ The digest that was signed.\\n     * @param v_      v of the signature.\\n     * @param r_      r of the signature.\\n     * @param s_      s of the signature.\\n     */\\n    function _revertIfInvalidSignature(\\n        address signer_,\\n        bytes32 digest_,\\n        uint8 v_,\\n        bytes32 r_,\\n        bytes32 s_\\n    ) internal pure {\\n        _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, v_, r_, s_));\\n    }\\n\\n    /**\\n     * @dev   Revert if error.\\n     * @param error_ The SignatureChecker Error enum.\\n     */\\n    function _revertIfError(SignatureChecker.Error error_) private pure {\\n        if (error_ == SignatureChecker.Error.NoError) return;\\n        if (error_ == SignatureChecker.Error.InvalidSignature) revert InvalidSignature();\\n        if (error_ == SignatureChecker.Error.InvalidSignatureLength) revert InvalidSignatureLength();\\n        if (error_ == SignatureChecker.Error.InvalidSignatureS) revert InvalidSignatureS();\\n        if (error_ == SignatureChecker.Error.InvalidSignatureV) revert InvalidSignatureV();\\n        if (error_ == SignatureChecker.Error.SignerMismatch) revert SignerMismatch();\\n\\n        revert InvalidSignature();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/erc20-helper/src/interfaces/IERC20Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.7;\\n\\n/// @title Interface of the ERC20 standard as needed by ERC20Helper.\\ninterface IERC20Like {\\n\\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_);\\n\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/abstract/interfaces/IEpochBasedVoteToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20Extended } from \\\"../../../lib/common/src/interfaces/IERC20Extended.sol\\\";\\n\\nimport { IERC5805 } from \\\"./IERC5805.sol\\\";\\n\\n/**\\n * @title  Extension for an ERC5805 token that uses epochs as its clock mode and delegation via IERC1271.\\n * @author M^0 Labs\\n */\\ninterface IEpochBasedVoteToken is IERC5805, IERC20Extended {\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Revert message when the provided epoch is zero.\\n    error EpochZero();\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Changes the voting power delegation for `account` to `delegatee`.\\n     * @param  account   The purported address of the signing account.\\n     * @param  delegatee The address the voting power of `account` will be delegated to.\\n     * @param  nonce     The nonce used for the signature.\\n     * @param  expiry    The timestamp until which the signature is still valid.\\n     * @param  signature A byte array signature.\\n     */\\n    function delegateBySig(\\n        address account,\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bytes memory signature\\n    ) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).\\n     * @param  delegatee The address of the delegatee to delegate to.\\n     * @param  nonce     The nonce of the account delegating.\\n     * @param  expiry    The timestamp until which the signature is still valid.\\n     * @return The digest to be signed.\\n     */\\n    function getDelegationDigest(address delegatee, uint256 nonce, uint256 expiry) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the token balance of `account` at a past clock value `epoch`.\\n     * @param  account The address of some account.\\n     * @param  epoch   The epoch number as a clock value.\\n     * @return The token balance `account` at `epoch`.\\n     */\\n    function pastBalanceOf(address account, uint256 epoch) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the delegatee of `account` at a past clock value `epoch`.\\n     * @param  account The address of some account.\\n     * @param  epoch   The epoch number as a clock value.\\n     * @return The delegatee of the voting power of `account` at `epoch`.\\n     */\\n    function pastDelegates(address account, uint256 epoch) external view returns (address);\\n\\n    /**\\n     * @notice Returns the total token supply at a past clock value `epoch`.\\n     * @param  epoch The epoch number as a clock value.\\n     * @return The total token supply at `epoch`.\\n     */\\n    function pastTotalSupply(uint256 epoch) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC712Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC712 } from \\\"./IERC712.sol\\\";\\n\\n/**\\n * @title  EIP-712 extended by EIP-5267.\\n * @author M^0 Labs\\n * @dev    The additional interface as defined by EIP-5267: https://eips.ethereum.org/EIPS/eip-5267\\n */\\ninterface IERC712Extended is IERC712 {\\n    /* ============ Events ============ */\\n\\n    /// @notice MAY be emitted to signal that the domain could have changed.\\n    event EIP712DomainChanged();\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the fields and values that describe the domain separator used by this contract for EIP-712.\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Typed structured data hashing and signing via EIP-712.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-712: https://eips.ethereum.org/EIPS/eip-712\\n */\\ninterface IERC712 {\\n    /* ============ Custom Errors ============ */\\n\\n    /// @notice Revert message when an invalid signature is detected.\\n    error InvalidSignature();\\n\\n    /// @notice Revert message when a signature with invalid length is detected.\\n    error InvalidSignatureLength();\\n\\n    /// @notice Revert message when the S portion of a signature is invalid.\\n    error InvalidSignatureS();\\n\\n    /// @notice Revert message when the V portion of a signature is invalid.\\n    error InvalidSignatureV();\\n\\n    /**\\n     * @notice Revert message when a signature is being used beyond its deadline (i.e. expiry).\\n     * @param  deadline  The deadline of the signature.\\n     * @param  timestamp The current timestamp.\\n     */\\n    error SignatureExpired(uint256 deadline, uint256 timestamp);\\n\\n    /// @notice Revert message when a recovered signer does not match the account being purported to have signed.\\n    error SignerMismatch();\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/libs/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC1271 } from \\\"../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @title  A library to handle ECDSA/secp256k1 and ERC1271 signatures, individually or in arbitrarily in combination.\\n * @author M^0 Labs\\n */\\nlibrary SignatureChecker {\\n    /* ============ Enums ============ */\\n\\n    /**\\n     * @notice An enum representing the possible errors that can be emitted during signature validation.\\n     * @param  NoError                No error occurred during signature validation.\\n     * @param  InvalidSignature       The signature is invalid.\\n     * @param  InvalidSignatureLength The signature length is invalid.\\n     * @param  InvalidSignatureS      The signature parameter S is invalid.\\n     * @param  InvalidSignatureV      The signature parameter V is invalid.\\n     * @param  SignerMismatch         The signer does not match the recovered signer.\\n     */\\n    enum Error {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV,\\n        SignerMismatch\\n    }\\n\\n    /* ============ Internal View/Pure Functions ============ */\\n\\n    /**\\n     * @dev    Returns whether a signature is valid (ECDSA/secp256k1 or ERC1271) for a signer and digest.\\n     * @dev    Signatures must not be used as unique identifiers since the `ecrecover` EVM opcode\\n     *         allows for malleable (non-unique) signatures.\\n     *         See https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\\n     * @param  signer    The address of the account purported to have signed.\\n     * @param  digest    The hash of the data that was signed.\\n     * @param  signature A byte array signature.\\n     * @return           Whether the signature is valid or not.\\n     */\\n    function isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {\\n        return isValidECDSASignature(signer, digest, signature) || isValidERC1271Signature(signer, digest, signature);\\n    }\\n\\n    /**\\n     * @dev    Returns whether an ERC1271 signature is valid for a signer and digest.\\n     * @param  signer    The address of the account purported to have signed.\\n     * @param  digest    The hash of the data that was signed.\\n     * @param  signature A byte array ERC1271 signature.\\n     * @return           Whether the signature is valid or not.\\n     */\\n    function isValidERC1271Signature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeCall(IERC1271.isValidSignature, (digest, signature))\\n        );\\n\\n        return\\n            success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);\\n    }\\n\\n    /**\\n     * @dev    Decodes an ECDSA/secp256k1 signature from a byte array to standard v, r, and s parameters.\\n     * @param  signature A byte array ECDSA/secp256k1 signature.\\n     * @return v         An ECDSA/secp256k1 signature parameter.\\n     * @return r         An ECDSA/secp256k1 signature parameter.\\n     * @return s         An ECDSA/secp256k1 signature parameter.\\n     */\\n    function decodeECDSASignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        // ecrecover takes the signature parameters, and they can be decoded using assembly.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n    }\\n\\n    /**\\n     * @dev    Decodes an ECDSA/secp256k1 short signature as defined by EIP2098\\n     *         from a byte array to standard v, r, and s parameters.\\n     * @param  signature A byte array ECDSA/secp256k1 short signature.\\n     * @return r         An ECDSA/secp256k1 signature parameter.\\n     * @return vs        An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function decodeShortECDSASignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 vs) {\\n        // ecrecover takes the signature parameters, and they can be decoded using assembly.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            vs := mload(add(signature, 0x40))\\n        }\\n    }\\n\\n    /**\\n     * @dev    Returns whether an ECDSA/secp256k1 signature is valid for a signer and digest.\\n     * @param  signer    The address of the account purported to have signed.\\n     * @param  digest    The hash of the data that was signed.\\n     * @param  signature A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     * @return           Whether the signature is valid or not.\\n     */\\n    function isValidECDSASignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal pure returns (bool) {\\n        if (signature.length == 64) {\\n            (bytes32 r, bytes32 vs) = decodeShortECDSASignature(signature);\\n            return isValidECDSASignature(signer, digest, r, vs);\\n        }\\n\\n        return validateECDSASignature(signer, digest, signature) == Error.NoError;\\n    }\\n\\n    /**\\n     * @dev    Returns whether an ECDSA/secp256k1 short signature is valid for a signer and digest.\\n     * @param  signer  The address of the account purported to have signed.\\n     * @param  digest  The hash of the data that was signed.\\n     * @param  r       An ECDSA/secp256k1 signature parameter.\\n     * @param  vs      An ECDSA/secp256k1 short signature parameter.\\n     * @return         Whether the signature is valid or not.\\n     */\\n    function isValidECDSASignature(address signer, bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (bool) {\\n        return validateECDSASignature(signer, digest, r, vs) == Error.NoError;\\n    }\\n\\n    /**\\n     * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.\\n     * @param  digest    The hash of the data that was signed.\\n     * @param  signature A byte array ECDSA/secp256k1 signature.\\n     * @return           An error, if any, that occurred during the signer recovery.\\n     * @return           The address of the account recovered form the signature (0 if error).\\n     */\\n    function recoverECDSASigner(bytes32 digest, bytes memory signature) internal pure returns (Error, address) {\\n        if (signature.length != 65) return (Error.InvalidSignatureLength, address(0));\\n\\n        (uint8 v, bytes32 r, bytes32 s) = decodeECDSASignature(signature);\\n\\n        return recoverECDSASigner(digest, v, r, s);\\n    }\\n\\n    /**\\n     * @dev    Returns the signer of an ECDSA/secp256k1 short signature for some digest.\\n     * @dev    See https://eips.ethereum.org/EIPS/eip-2098\\n     * @param  digest The hash of the data that was signed.\\n     * @param  r      An ECDSA/secp256k1 signature parameter.\\n     * @param  vs     An ECDSA/secp256k1 short signature parameter.\\n     * @return        An error, if any, that occurred during the signer recovery.\\n     * @return        The address of the account recovered form the signature (0 if error).\\n     */\\n    function recoverECDSASigner(bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (Error, address) {\\n        unchecked {\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            return recoverECDSASigner(digest, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.\\n     * @param  digest The hash of the data that was signed.\\n     * @param  v      An ECDSA/secp256k1 signature parameter.\\n     * @param  r      An ECDSA/secp256k1 signature parameter.\\n     * @param  s      An ECDSA/secp256k1 signature parameter.\\n     * @return        An error, if any, that occurred during the signer recovery.\\n     * @return signer The address of the account recovered form the signature (0 if error).\\n     */\\n    function recoverECDSASigner(\\n        bytes32 digest,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (Error, address signer) {\\n        // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.\\n        if (uint256(s) > uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0))\\n            return (Error.InvalidSignatureS, address(0));\\n\\n        if (v != 27 && v != 28) return (Error.InvalidSignatureV, address(0));\\n\\n        signer = ecrecover(digest, v, r, s);\\n\\n        return (signer == address(0)) ? (Error.InvalidSignature, address(0)) : (Error.NoError, signer);\\n    }\\n\\n    /**\\n     * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.\\n     * @param  signer    The address of the account purported to have signed.\\n     * @param  digest    The hash of the data that was signed.\\n     * @param  signature A byte array ERC1271 signature.\\n     * @return           An error, if any, that occurred during the signer recovery.\\n     */\\n    function validateECDSASignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal pure returns (Error) {\\n        (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, signature);\\n\\n        return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;\\n    }\\n\\n    /**\\n     * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 short signature for a signer and digest.\\n     * @param  signer The address of the account purported to have signed.\\n     * @param  digest The hash of the data that was signed.\\n     * @param  r      An ECDSA/secp256k1 signature parameter.\\n     * @param  vs     An ECDSA/secp256k1 short signature parameter.\\n     * @return        An error, if any, that occurred during the signer recovery.\\n     */\\n    function validateECDSASignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (Error) {\\n        (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, r, vs);\\n\\n        return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;\\n    }\\n\\n    /**\\n     * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.\\n     * @param  signer The address of the account purported to have signed.\\n     * @param  digest The hash of the data that was signed.\\n     * @param  v      An ECDSA/secp256k1 signature parameter.\\n     * @param  r      An ECDSA/secp256k1 signature parameter.\\n     * @param  s      An ECDSA/secp256k1 signature parameter.\\n     * @return        An error, if any, that occurred during the signer recovery.\\n     */\\n    function validateECDSASignature(\\n        address signer,\\n        bytes32 digest,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (Error) {\\n        (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, v, r, s);\\n\\n        return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;\\n    }\\n\\n    /**\\n     * @dev    Returns an error if `signer` is not `recoveredSigner`.\\n     * @param  signer          The address of the some signer.\\n     * @param  recoveredSigner The address of the some recoveredSigner.\\n     * @return                 An error if `signer` is not `recoveredSigner`.\\n     */\\n    function validateRecoveredSigner(address signer, address recoveredSigner) internal pure returns (Error) {\\n        return (signer == recoveredSigner) ? Error.NoError : Error.SignerMismatch;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\nimport { IERC3009 } from \\\"./IERC3009.sol\\\";\\n\\n/**\\n * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712\\n *         and with EIP-1271 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).\\n * @author M^0 Labs\\n * @dev    The additional interface as defined by EIP-2612: https://eips.ethereum.org/EIPS/eip-2612\\n */\\ninterface IERC20Extended is IERC20, IERC3009 {\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when spender's allowance is not sufficient.\\n     * @param  spender    Address that may be allowed to operate on tokens without being their owner.\\n     * @param  allowance  Amount of tokens a `spender` is allowed to operate with.\\n     * @param  needed     Minimum amount required to perform a transfer.\\n     */\\n    error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @notice Revert message emitted when the transferred amount is insufficient.\\n     * @param  amount Amount transferred.\\n     */\\n    error InsufficientAmount(uint256 amount);\\n\\n    /**\\n     * @notice Revert message emitted when the recipient of a token is invalid.\\n     * @param  recipient Address of the invalid recipient.\\n     */\\n    error InvalidRecipient(address recipient);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.\\n     * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.\\n     * @param  spender  The address of an account allowed to spend on behalf of `owner`.\\n     * @param  value    The amount of the allowance being approved.\\n     * @param  deadline The last block number where the signature is still valid.\\n     * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.\\n     * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.\\n     * @param  spender   The address of an account allowed to spend on behalf of `owner`.\\n     * @param  value     The amount of the allowance being approved.\\n     * @param  deadline  The last block number where the signature is still valid.\\n     * @param  signature An arbitrary signature (EIP-712).\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/src/abstract/interfaces/IERC5805.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IStatefulERC712 } from \\\"../../../lib/common/src/interfaces/IStatefulERC712.sol\\\";\\n\\nimport { IERC6372 } from \\\"./IERC6372.sol\\\";\\n\\n/**\\n * @title  Voting with voting weight tracking and delegation support.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-5805: https://eips.ethereum.org/EIPS/eip-5805\\n */\\ninterface IERC5805 is IStatefulERC712, IERC6372 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when `delegator` changes its voting power delegation from `fromDelegatee` to `toDelegatee`.\\n     * @param  delegator     The address of the account changing its voting power delegation.\\n     * @param  fromDelegatee The previous account the voting power of `delegator` was delegated to.\\n     * @param  toDelegatee   The new account the voting power of `delegator` is delegated to.\\n     */\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegatee, address indexed toDelegatee);\\n\\n    /**\\n     * @notice Emitted when the available voting power of `delegatee` changes from `previousBalance` to `newBalance`.\\n     * @param  delegatee       The address of the account whose voting power is changed.\\n     * @param  previousBalance The previous voting power of `delegatee`.\\n     * @param  newBalance      The new voting power of `delegatee`.\\n     */\\n    event DelegateVotesChanged(address indexed delegatee, uint256 previousBalance, uint256 newBalance);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Revert message when a query for past values is for a timepoint greater or equal to the current clock.\\n     * @param  timepoint The timepoint being queried.\\n     * @param  clock     The current timepoint.\\n     */\\n    error NotPastTimepoint(uint48 timepoint, uint48 clock);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Allows a calling account to change its voting power delegation to `delegatee`.\\n     * @param  delegatee The address of the account the caller's voting power will be delegated to.\\n     */\\n    function delegate(address delegatee) external;\\n\\n    /**\\n     * @notice Changes the signing account's voting power delegation to `delegatee`.\\n     * @param  delegatee The address of the account the signing account's voting power will be delegated to.\\n     * @param  nonce     The nonce of the account delegating.\\n     * @param  expiry    The timestamp until which the signature is still valid.\\n     * @param  v         A signature parameter.\\n     * @param  r         A signature parameter.\\n     * @param  s         A signature parameter.\\n     */\\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /// @notice Returns the EIP712 typehash used in the encoding of the digest for the delegateBySig function.\\n    function DELEGATION_TYPEHASH() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the delegatee the voting power of `account` is delegated to.\\n     * @param  account The address of the account that can delegate its voting power.\\n     * @return The address of the account the voting power of `account` will be delegated to.\\n     */\\n    function delegates(address account) external view returns (address);\\n\\n    /**\\n     * @notice Returns the total voting power of `account` at a past clock value `timepoint`.\\n     * @param  account   The address of some account.\\n     * @param  timepoint The point in time, according to the clock mode the contract is operating on.\\n     * @return The total voting power of `account` at clock value `timepoint`.\\n     */\\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the total voting power of `account`.\\n     * @param  account The address of some account.\\n     * @return The total voting power of `account`.\\n     */\\n    function getVotes(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\n/**\\n * @title  Standard Signature Validation Method for Contracts via EIP-1271.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-1271: https://eips.ethereum.org/EIPS/eip-1271\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev    Returns a specific magic value if the provided signature is valid for the provided digest.\\n     * @param  digest     Hash of the data purported to have been signed.\\n     * @param  signature  Signature byte array associated with the digest.\\n     * @return magicValue Magic value 0x1626ba7e if the signature is valid.\\n     */\\n    function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/ttg/lib/common/src/interfaces/IERC3009.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.23;\\n\\nimport { IStatefulERC712 } from \\\"./IStatefulERC712.sol\\\";\\n\\n/**\\n * @title  Transfer via signed authorization following EIP-3009 standard.\\n * @author M^0 Labs\\n * @dev    The interface as defined by EIP-3009: https://eips.ethereum.org/EIPS/eip-3009\\n */\\ninterface IERC3009 is IStatefulERC712 {\\n    /* ============ Events ============ */\\n\\n    /**\\n     * @notice Emitted when an authorization has been canceled.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the canceled authorization.\\n     */\\n    event AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\n\\n    /**\\n     * @notice Emitted when an authorization has been used.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the used authorization.\\n     */\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n\\n    /* ============ Custom Errors ============ */\\n\\n    /**\\n     * @notice Emitted when an authorization has already been used.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the used authorization.\\n     */\\n    error AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);\\n\\n    /**\\n     * @notice Emitted when an authorization is expired.\\n     * @param  timestamp   Timestamp at which the transaction was submitted.\\n     * @param  validBefore Timestamp before which the authorization would have been valid.\\n     */\\n    error AuthorizationExpired(uint256 timestamp, uint256 validBefore);\\n\\n    /**\\n     * @notice Emitted when an authorization is not yet valid.\\n     * @param  timestamp  Timestamp at which the transaction was submitted.\\n     * @param  validAfter Timestamp after which the authorization will be valid.\\n     */\\n    error AuthorizationNotYetValid(uint256 timestamp, uint256 validAfter);\\n\\n    /**\\n     * @notice Emitted when the caller of `receiveWithAuthorization` is not the payee.\\n     * @param  caller Caller's address.\\n     * @param  payee  Payee's address.\\n     */\\n    error CallerMustBePayee(address caller, address payee);\\n\\n    /* ============ Interactive Functions ============ */\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes memory signature\\n    ) external;\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  r           An ECDSA/secp256k1 signature parameter.\\n     * @param  vs          An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external;\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization.\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  v           v of the signature.\\n     * @param  r           r of the signature.\\n     * @param  s           s of the signature.\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes memory signature\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  r           An ECDSA/secp256k1 signature parameter.\\n     * @param  vs          An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer.\\n     * @dev    This has an additional check to ensure that the payee's address matches\\n     *         the caller of this function to prevent front-running attacks.\\n     *         (See security considerations)\\n     * @param  from        Payer's address (Authorizer).\\n     * @param  to          Payee's address.\\n     * @param  value       Amount to be transferred.\\n     * @param  validAfter  The time after which this is valid (unix time).\\n     * @param  validBefore The time before which this is valid (unix time).\\n     * @param  nonce       Unique nonce.\\n     * @param  v           v of the signature.\\n     * @param  r           r of the signature.\\n     * @param  s           s of the signature.\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  signature  A byte array ECDSA/secp256k1 signature (encoded r, s, v).\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, bytes memory signature) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  r          An ECDSA/secp256k1 signature parameter.\\n     * @param  vs         An ECDSA/secp256k1 short signature parameter.\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, bytes32 r, bytes32 vs) external;\\n\\n    /**\\n     * @notice Attempt to cancel an authorization.\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @param  v          v of the signature.\\n     * @param  r          r of the signature.\\n     * @param  s          s of the signature.\\n     */\\n    function cancelAuthorization(address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /* ============ View/Pure Functions ============ */\\n\\n    /**\\n     * @notice Returns the state of an authorization.\\n     * @dev    Nonces are randomly generated 32-byte data unique to the authorizer's address\\n     * @param  authorizer Authorizer's address.\\n     * @param  nonce      Nonce of the authorization.\\n     * @return True if the nonce is used.\\n     */\\n    function authorizationState(address authorizer, bytes32 nonce) external view returns (bool);\\n\\n    /// @notice Returns `transferWithAuthorization` typehash.\\n    function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n\\n    /// @notice Returns `receiveWithAuthorization` typehash.\\n    function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n\\n    /// @notice Returns `cancelAuthorization` typehash.\\n    function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"common/=lib/protocol/lib/common/src/\",\r\n      \"contract-test-utils/=lib/ttg/lib/erc20-helper/lib/contract-test-utils/contracts/\",\r\n      \"ds-test/=lib/protocol/lib/solmate/lib/ds-test/src/\",\r\n      \"erc20-helper/=lib/ttg/lib/erc20-helper/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"protocol/=lib/protocol/\",\r\n      \"solmate/=lib/protocol/lib/solmate/src/\",\r\n      \"ttg/=lib/ttg/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zeroToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDestinationAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timepoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clock\",\"type\":\"uint256\"}],\"name\":\"NotPastTimepoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"}],\"name\":\"StartEpochAfterEndEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLAIM_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLOCK_MODE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v_\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s_\",\"type\":\"bytes32\"}],\"name\":\"claimBySig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"claimBySig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clock\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"distributionOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields_\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"}],\"name\":\"getClaimDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endEpoch_\",\"type\":\"uint256\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimable_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"getDistributable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DistributionVault", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000988567fe094570cce1ffda29d1f2d842b70492be", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}