{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title OwnableDeferral\\n * @author @NiftyMike | @NFTCulture\\n * @dev Implements checks for contract admin operations. Will be Backed by\\n * OZ Ownable.\\n *\\n * This contract is helpful when a contract tree gets complicated,\\n * and multiple contracts need to leverage Ownable.\\n *\\n * Sample Implementation:\\n *\\n * modifier isOwner() override(...) {\\n *     _isOwner();\\n *     _;\\n * }\\n *\\n * function _isOwner() internal view override(...) {\\n *     _checkOwner();\\n * }\\n */\\nabstract contract OwnableDeferral {\\n    modifier isOwner() virtual;\\n\\n    function _isOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/business/SafetyLatch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// Local References\\nimport '../access/v2/OwnableDeferral.sol';\\n\\n// Error Codes\\nerror DestructRevoked();\\nerror DestructExpired();\\n\\n/**\\n * @title SafetyLatch\\n * @author @NFTCulture\\n * @dev Utility class to fulfill \\\"killswitch\\\" requirements from business people.\\n * I named it \\\"SafetyLatch\\\" just be less negative. The intent of this class is to\\n * prevent screw-ups and not to be used nefariously.\\n *\\n * KillSwitch is set to expire on either of the following conditions:\\n *      1) A preconfigured block timestamp passes.\\n *      2) If it is voluntarily released by the owner.\\n *\\n * Call canDestruct() to see if the window has closed.\\n *\\n * Implementing contract must actually perform whatever logic needs to be done on destruct.\\n */\\nabstract contract SafetyLatch is OwnableDeferral {\\n    uint256 private immutable DESTRUCT_WINDOW_ENDS_AT;\\n    bool private REVOKE_DESTRUCT = false;\\n\\n    constructor(uint256 windowEndBlock) {\\n        DESTRUCT_WINDOW_ENDS_AT = windowEndBlock;\\n    }\\n\\n    function destructContract() external isOwner {\\n        if (REVOKE_DESTRUCT) revert DestructRevoked();\\n        if (block.number >= DESTRUCT_WINDOW_ENDS_AT) revert DestructExpired();\\n\\n        _executeOnDestruct();\\n    }\\n\\n    function revokeDestruct() external isOwner {\\n        REVOKE_DESTRUCT = true;\\n    }\\n\\n    function canDestruct() external view returns (bool) {\\n        if (REVOKE_DESTRUCT || block.number >= DESTRUCT_WINDOW_ENDS_AT) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function _executeOnDestruct() internal virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/ChainNativeMetadataConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// Local References\\nimport '../../access/v2/OwnableDeferral.sol';\\nimport './interfaces/IChainNativeMetadataProducer.sol';\\n\\n/**\\n * @title ChainNativeMetadataConsumer\\n * @author @NiftyMike | @NFTCulture\\n * @dev Basic implementation to manage connections to an external source for NFT metadata.\\n */\\nabstract contract ChainNativeMetadataConsumer is OwnableDeferral {\\n    // External contract that manages the collection's metadata in a chain-native way.\\n    IChainNativeMetadataProducer private _metadataProducer;\\n\\n    constructor(address __metadataProducer) {\\n        _setProducer(__metadataProducer);\\n    }\\n\\n    /**\\n     * @notice Set the on-chain metadata producer contract.\\n     * Can only be called if caller is owner.\\n     *\\n     * @param __metadataProducer address of the producer contract.\\n     */\\n    function setProducer(address __metadataProducer) external isOwner {\\n        _setProducer(__metadataProducer);\\n    }\\n\\n    function _setProducer(address __metadataProducer) internal {\\n        if (__metadataProducer != address(0)) {\\n            _metadataProducer = IChainNativeMetadataProducer(__metadataProducer);\\n        }\\n    }\\n\\n    function _getProducer() internal view virtual returns (IChainNativeMetadataProducer) {\\n        return _metadataProducer;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IChainNativeMetadataProducer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IChainNativeMetadataProducer\\n * @author @NiftyMike | @NFTCulture\\n * @dev Super thin interface definition for a contract that\\n * produces metadata in a chain native way.\\n */\\ninterface IChainNativeMetadataProducer {\\n    function getTokenTypeForToken(uint256 tokenId) external view returns (uint256);\\n\\n    function getJsonAsString(uint256 tokenId, uint256 tokenType) external view returns (string memory);\\n\\n    function getJsonAsEncodedString(uint256 tokenId, uint256 tokenType) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/token/v4/ERC721SolBase_NFTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// ERC721 from Sol-DAO/solbase, Packaged within NFTC Open Source Libraries.\\n// See: https://github.com/NFTCulture/nftc-contracts/blob/main/contracts/token/solbase/ERC721/ERC721.sol\\nimport '@nftculture/nftc-contracts/contracts/token/solbase/ERC721/extensions/ERC721SolBaseBurnable.sol';\\nimport '@nftculture/nftc-contracts/contracts/token/solbase/ERC721/extensions/ERC721SolBaseSupply.sol';\\n\\n// ClosedSea by Vectorized\\nimport 'closedsea/src/OperatorFilterer.sol';\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\n// NFTC Prerelease Contracts\\nimport '../../access/v2/OwnableDeferral.sol';\\nimport './interfaces/INFTCAdvanceMint.sol';\\n\\n/**\\n * @title  ERC721SolBase_NFTC\\n * @author @NFTCulture\\n * @dev SolBase/ERC721 plus NFTC-preferred extensions and add-ons.\\n *  - ERC721SolBaseBurnable\\n *  - Ownable\\n *  - OperatorFilterer\\n *  - INFTCAdvanceMint: The NFTC Advance Mint API, which includes Base URI Management\\n *    and Query Helpers\\n *\\n * Using implementation and approach created by Vectorized for OperatorFilterer.\\n * See: https://github.com/Vectorized/closedsea/blob/main/src/example/ExampleERC721A.sol\\n *\\n * @notice Be sure to add the following to your impl constructor:\\n * >>  _registerForOperatorFiltering();\\n * >>  operatorFilteringEnabled = true;\\n */\\nabstract contract ERC721SolBase_NFTC is ERC721SolBaseBurnable, OperatorFilterer, OwnableDeferral, INFTCAdvanceMint {\\n    using Strings for uint256;\\n\\n    uint64 public immutable MAX_SUPPLY;\\n\\n    string public baseURI;\\n\\n    bool public operatorFilteringEnabled;\\n\\n    constructor(uint64 __maxSupply, string memory __baseURI) {\\n        MAX_SUPPLY = __maxSupply;\\n        baseURI = __baseURI;\\n    }\\n\\n    function setContractURI(string memory __baseURI) external isOwner {\\n        baseURI = __baseURI;\\n    }\\n\\n    function getContractURI() external view override returns (string memory) {\\n        return _getContractURI();\\n    }\\n\\n    function _getContractURI() internal view returns (string memory) {\\n        return baseURI;\\n    }\\n\\n    function maxSupply() external view override returns (uint256) {\\n        return _maxSupply();\\n    }\\n\\n    function _maxSupply() internal view returns (uint256) {\\n        return MAX_SUPPLY;\\n    }\\n\\n    function balanceOwnedBy(address tokenOwner) external view override returns (uint256) {\\n        return super.balanceOf(tokenOwner);\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override(ERC721) onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(address operator, uint256 tokenId) public override(ERC721) onlyAllowedOperatorApproval(operator) {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        ERC721SolBaseSupply.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override(ERC721) onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) public override(ERC721) onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * Failsafe in case we need to turn operator filtering off.\\n     */\\n    function setOperatorFilteringEnabled(bool value) external isOwner {\\n        operatorFilteringEnabled = value;\\n    }\\n\\n    /**\\n     * Failsafe in case we need to change what subscription we are using, for whatever reason.\\n     */\\n    function registerForOperatorFiltering(address subscription, bool subscribe) external isOwner {\\n        _registerForOperatorFiltering(subscription, subscribe);\\n    }\\n\\n    function _operatorFilteringEnabled() internal view virtual override returns (bool) {\\n        return operatorFilteringEnabled;\\n    }\\n\\n    function _isPriorityOperator(address operator) internal pure override returns (bool) {\\n        // OpenSea Seaport Conduit:\\n        // https://etherscan.io/address/0x1E0049783F008A0085193E00003D00cd54003c71\\n        // https://goerli.etherscan.io/address/0x1E0049783F008A0085193E00003D00cd54003c71\\n        return operator == address(0x1E0049783F008A0085193E00003D00cd54003c71);\\n    }\\n\\n    function _tokenFilename(uint256 tokenId) internal pure virtual returns (string memory) {\\n        return tokenId.toString();\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/token/v4/interfaces/IBaseURIConfigurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IBaseURIConfigurable\\n * @author @NFTCulture\\n * @dev Interface to define Base URI configuration functions.\\n *\\n * Supported Contract Specs:\\n *  - ERC721A Static\\n *  - ERC721A Expandable\\n *  - ERC1155\\n */\\ninterface IBaseURIConfigurable {\\n    /*\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\\\\\\n    |                   API - General Functions                   |\\n    \\\\____________________________________________________________*/\\n\\n    // Set URI at the contract level. ERC721 - Base URI. ERC1155 - Uri.\\n    function setContractURI(string memory) external;\\n\\n    // Get URI configured at the contract level. ERC721 - Base URI. ERC1155 - Uri.\\n    function getContractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/token/v4/interfaces/INFTCAdvanceMint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Prerelease Contracts\\nimport './IBaseURIConfigurable.sol';\\nimport './INonFungibleTokenQueryable.sol';\\n\\n/**\\n * @title INFTCAdvanceMint\\n * @author @NFTCulture\\n * @dev Interface to define standardized functionality that should be exposed\\n * on NFTC Nifty contracts. This interface is tailored towards NFTs that are minted\\n * in advance and then delivered to recipients via some to-be-determined mechanism.\\n *\\n * Supported Contract Specs:\\n *  - ERC721SolBase\\n *  - ERC721A Static\\n *  - ERC721A Expandable\\n *  - ERC1155\\n */\\ninterface INFTCAdvanceMint is IBaseURIConfigurable, INonFungibleTokenQueryable {\\n    // Tag Interface\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/token/v4/interfaces/INonFungibleTokenQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title INonFungibleTokenQueryable\\n * @author @NFTCulture\\n * @dev Interface to define data-retrieval functions for a NonFungible Token contract.\\n */\\ninterface INonFungibleTokenQueryable {\\n    /*\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\u00b0\\\\\\n    |                   API - General Functions                   |\\n    \\\\____________________________________________________________*/\\n\\n    // Return the maximum possible number of tokens that can be minted by this contract.\\n    function maxSupply() external view returns (uint256);\\n\\n    // Return the current number of tokens that exist.\\n    function totalTokensExist() external view returns (uint256);\\n\\n    // Return the balance owned by an address.\\n    function balanceOwnedBy(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/financial/ERC2981_NFTCExtended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/common/ERC2981.sol';\\n\\n/**\\n * @title ERC2981_NFTCExtended\\n * @author @NiftyMike | @NFTCulture\\n * @dev A wrapper around ERC2981 which adds some common functionality.\\n */\\nabstract contract ERC2981_NFTCExtended is ERC2981 {\\n    function setDefaultRoyalty(address newReceiver, uint96 newRoyalty) external {\\n        _isOwner();\\n\\n        _setDefaultRoyalty(newReceiver, newRoyalty);\\n    }\\n\\n    function _isOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/financial/NFTCPaymentSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Open Source Contracts See: https://github.com/NFTCulture/nftc-contracts\\nimport './NFTCPaymentSplitterBase.sol';\\n\\n/**\\n * @title NFTCPaymentSplitter\\n * @author @NiftyMike | @NFTCulture\\n * @dev NFTC's Implementation of a Payment Splitter\\n *\\n * Underlying is based on OpenZeppelin Contracts v4.8.0 (finance/PaymentSplitter.sol)\\n */\\nabstract contract NFTCPaymentSplitter is NFTCPaymentSplitterBase {\\n    /**\\n     * @dev Overrides release() method, so that it can only be called by owner.\\n     * @notice Owner: Release funds to a specific address.\\n     *\\n     * @param account Payable address that will receive funds.\\n     */\\n    function release(address payable account) public override {\\n        _isOwner();\\n\\n        _release(account);\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to caller's address of the amount of Ether they are owed, according to their percentage of the\\n     * total shares and their previous withdrawals.\\n     * @notice Sender: request payment.\\n     */\\n    function releaseToSelf() public {\\n        _release(payable(_msgSender()));\\n    }\\n\\n    function _isOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/financial/NFTCPaymentSplitterBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\n/**\\n * @title NFTCPaymentSplitterBase\\n * @author @NiftyMike | @NFTCulture\\n * @dev An opinionated replacement of OZ's Payment Splitter.\\n *\\n * Notes:\\n *  - Based on OZ Contracts v4.8.0 (finance/PaymentSplitter.sol)\\n *  - ERC-20 token functionality removed to save gas.\\n *  - Transferability of Payees, but only by Payee\\n *  - Some require messages are shortened.\\n *  - contract changed to abstract and release() functionality moved to internal method.\\n *\\n * IMPORTANT: changes to release() require higher level classes to expose release() in order\\n * for funds to be withdrawn. This allows higher level classes to enforce better controls.\\n */\\nabstract contract NFTCPaymentSplitterBase is Context {\\n    event PayeeAdded(address account, uint256 shares);\\n    event PaymentReleased(address to, uint256 amount);\\n    event PaymentReceived(address from, uint256 amount);\\n    event PayeeTransferred(address oldOwner, address newOwner);\\n\\n    uint256 private _totalShares;\\n    uint256 private _totalReleased;\\n\\n    mapping(address => uint256) private _shares;\\n    mapping(address => uint256) private _released;\\n    address[] private _payees;\\n\\n    /**\\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\\n     * the matching position in the `shares` array.\\n     *\\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\\n     * duplicates in `payees`.\\n     */\\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\\n        require(payees.length == shares_.length, 'PaymentSplitter: length mismatch');\\n        require(payees.length > 0, 'PaymentSplitter: no payees');\\n\\n        for (uint256 i = 0; i < payees.length; i++) {\\n            _addPayee(payees[i], shares_[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\\n     * reliability of the events, and not the actual splitting of Ether.\\n     *\\n     * To learn more about this see the Solidity documentation for\\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\\n     * functions].\\n     */\\n    receive() external payable virtual {\\n        emit PaymentReceived(_msgSender(), msg.value);\\n    }\\n\\n    /**\\n     * @dev Getter for the total shares held by payees.\\n     */\\n    function totalShares() public view returns (uint256) {\\n        return _totalShares;\\n    }\\n\\n    /**\\n     * @dev Getter for the total amount of Ether already released.\\n     */\\n    function totalReleased() public view returns (uint256) {\\n        return _totalReleased;\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of shares held by an account.\\n     */\\n    function shares(address account) public view returns (uint256) {\\n        return _shares[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of Ether already released to a payee.\\n     */\\n    function released(address account) public view returns (uint256) {\\n        return _released[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the address of the payee number `index`.\\n     */\\n    function payee(uint256 index) public view returns (address) {\\n        return _payees[index];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of payee's releasable Ether.\\n     */\\n    function releasable(address account) public view returns (uint256) {\\n        return _releasable(account);\\n    }\\n\\n    function _releasable(address account) internal view returns (uint256) {\\n        uint256 totalReceived = address(this).balance + totalReleased();\\n        return _pendingPayment(account, totalReceived, released(account));\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\\n     * total shares and their previous withdrawals.\\n     */\\n    function _release(address payable account) internal {\\n        require(_shares[account] > 0, 'PaymentSplitter: no shares');\\n\\n        uint256 payment = _releasable(account);\\n\\n        require(payment != 0, 'PaymentSplitter: not due payment');\\n\\n        // _totalReleased is the sum of all values in _released.\\n        // If \\\"_totalReleased += payment\\\" does not overflow, then \\\"_released[account] += payment\\\" cannot overflow.\\n        _totalReleased += payment;\\n        unchecked {\\n            _released[account] += payment;\\n        }\\n\\n        Address.sendValue(account, payment);\\n        emit PaymentReleased(account, payment);\\n    }\\n\\n    /**\\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\\n     * already released amounts.\\n     */\\n    function _pendingPayment(\\n        address account,\\n        uint256 totalReceived,\\n        uint256 alreadyReleased\\n    ) private view returns (uint256) {\\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\\n    }\\n\\n    /**\\n     * @dev Add a new payee to the contract.\\n     * @param account The address of the payee to add.\\n     * @param shares_ The number of shares owned by the payee.\\n     */\\n    function _addPayee(address account, uint256 shares_) private {\\n        require(account != address(0), 'PaymentSplitter: zero address');\\n        require(shares_ > 0, 'PaymentSplitter: no shares');\\n        require(_shares[account] == 0, 'PaymentSplitter: payee has shares');\\n\\n        _payees.push(account);\\n        _shares[account] = shares_;\\n        _totalShares = _totalShares + shares_;\\n        emit PayeeAdded(account, shares_);\\n    }\\n\\n    /**\\n     * @dev Allows owner to transfer their shares to somebody else; it can only be called by of a share.\\n     * @notice Owner: Release funds to a specific address.\\n     *\\n     * @param newOwner Payable address which has no shares and will receive the shares of the current owner.\\n     */\\n    function transferPayee(address payable newOwner) public {\\n        require(newOwner != address(0), 'PaymentSplitter: zero address');\\n        require(_shares[_msgSender()] > 0, 'PaymentSplitter: no owned shares');\\n        require(_shares[newOwner] == 0, 'PaymentSplitter: payee has shares');\\n\\n        _transferPayee(newOwner);\\n        emit PayeeTransferred(_msgSender(), newOwner);\\n    }\\n\\n    function _transferPayee(address newOwner) private {\\n        if (_payees.length == 0) return;\\n\\n        for (uint i = 0; i < _payees.length - 1; i++) {\\n            if (_payees[i] == _msgSender()) {\\n                _payees[i] = newOwner;\\n                _shares[newOwner] = _shares[_msgSender()];\\n                _shares[_msgSender()] = 0;\\n            }\\n        }\\n    }\\n\\n    function release(address payable account) public virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/financial/NFTCSplitsAndRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Open Source Contracts See: https://github.com/NFTCulture/nftc-contracts\\nimport './ERC2981_NFTCExtended.sol';\\nimport './NFTCPaymentSplitter.sol';\\n\\n/**\\n * @title NFTCSplitsAndRoyalties\\n * @author @NiftyMike | @NFTCulture\\n * @dev One stop shop for Payment Splits and ERC2981 Royalty Definition.\\n */\\nabstract contract NFTCSplitsAndRoyalties is NFTCPaymentSplitter, ERC2981_NFTCExtended {\\n    constructor(\\n        address[] memory __addresses,\\n        uint256[] memory __splits,\\n        address defaultRoyaltyReceiver,\\n        uint96 defaultRoyaltyBasisPoints\\n    ) NFTCPaymentSplitterBase(__addresses, __splits) {\\n        // Default royalty information to be this contract, so that no potential\\n        // royalty payments are missed by marketplaces that support ERC2981.\\n        _setDefaultRoyalty(defaultRoyaltyReceiver, defaultRoyaltyBasisPoints);\\n    }\\n\\n    function _isOwner() internal view virtual override(NFTCPaymentSplitter, ERC2981_NFTCExtended);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/token/solbase/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Modern, minimalist, and gas-optimized ERC721 implementation.\\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error NotMinted();\\n\\n    error ZeroAddress();\\n\\n    error Unauthorized();\\n\\n    error WrongFrom();\\n\\n    error InvalidRecipient();\\n\\n    error UnsafeRecipient();\\n\\n    error AlreadyMinted();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Metadata Storage/Logic\\n    /// -----------------------------------------------------------------------\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Balance/Owner Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        if ((owner = _ownerOf[id]) == address(0)) revert NotMinted();\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) revert ZeroAddress();\\n        return _balanceOf[owner];\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Approval Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) revert Unauthorized();\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        if (from != _ownerOf[id]) revert WrongFrom();\\n\\n        if (to == address(0)) revert InvalidRecipient();\\n\\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[id])\\n            revert Unauthorized();\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, '') !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC165 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Mint/Burn Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        if (to == address(0)) revert InvalidRecipient();\\n\\n        if (_ownerOf[id] != address(0)) revert AlreadyMinted();\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (owner == address(0)) revert NotMinted();\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Safe Mint Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, '') !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/token/solbase/ERC721/extensions/ERC721SolBaseBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// NFTC Open Source Contracts (https://github.com/NFTCulture/nftc-contracts/tree/main)\\nimport './ERC721SolBaseSupply.sol';\\n\\n/**\\n * @title ERC721SolBaseBurnable\\n * @author @NiftyMike | @NFTCulture\\n *\\n * @dev ERC721 SolBase extension to enable tokens that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721SolBaseBurnable is ERC721SolBaseSupply {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId`.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        address owner = _ownerOf[tokenId];\\n\\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender] && msg.sender != getApproved[tokenId])\\n            revert Unauthorized();\\n\\n        _burn(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/token/solbase/ERC721/extensions/ERC721SolBaseSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\n// NFTC Open Source Contracts (https://github.com/NFTCulture/nftc-contracts/tree/main)\\nimport '../ERC721.sol';\\n\\n/**\\n * @title ERC721SolBaseSupply\\n * @author @NiftyMike | @NFTCulture\\n *\\n * @dev ERC721 SolBase extension to enable tracking of supply and number minted.\\n *\\n * NOTE: Not a full ERC721Enumerable implementation.\\n */\\nabstract contract ERC721SolBaseSupply is ERC721 {\\n    uint64 private mintedTokenCounter;\\n    uint64 private burnedTokenCounter;\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    function _totalSupply() internal view virtual returns (uint256) {\\n        return mintedTokenCounter - burnedTokenCounter;\\n    }\\n\\n    function totalMinted() public view virtual returns (uint256) {\\n        return _totalMinted();\\n    }\\n\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        return mintedTokenCounter;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        super.transferFrom(from, to, tokenId);\\n\\n        if (to == address(0)) {\\n            burnedTokenCounter++;\\n        }\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal override {\\n        super._mint(to, tokenId);\\n\\n        mintedTokenCounter++;\\n    }\\n\\n    function _burn(uint256 tokenId) internal override {\\n        super._burn(tokenId);\\n\\n        burnedTokenCounter++;\\n    }\\n\\n    function exists(uint256 tokenId) external view virtual returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf[tokenId] != address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"closedsea/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Optimized and flexible operator filterer to abide to OpenSea's\\n/// mandatory on-chain royalty enforcement in order for new collections to\\n/// receive royalties.\\n/// For more information, see:\\n/// See: https://github.com/ProjectOpenSea/operator-filter-registry\\nabstract contract OperatorFilterer {\\n    /// @dev The default OpenSea operator blocklist subscription.\\n    address internal constant _DEFAULT_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\\n    /// @dev The OpenSea operator filter registry.\\n    address internal constant _OPERATOR_FILTER_REGISTRY = 0x000000000000AAeB6D7670E522A718067333cd4E;\\n\\n    /// @dev Registers the current contract to OpenSea's operator filter,\\n    /// and subscribe to the default OpenSea operator blocklist.\\n    /// Note: Will not revert nor update existing settings for repeated registration.\\n    function _registerForOperatorFiltering() internal virtual {\\n        _registerForOperatorFiltering(_DEFAULT_SUBSCRIPTION, true);\\n    }\\n\\n    /// @dev Registers the current contract to OpenSea's operator filter.\\n    /// Note: Will not revert nor update existing settings for repeated registration.\\n    function _registerForOperatorFiltering(address subscriptionOrRegistrantToCopy, bool subscribe)\\n        internal\\n        virtual\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let functionSelector := 0x7d3e3dbe // `registerAndSubscribe(address,address)`.\\n\\n            // Clean the upper 96 bits of `subscriptionOrRegistrantToCopy` in case they are dirty.\\n            subscriptionOrRegistrantToCopy := shr(96, shl(96, subscriptionOrRegistrantToCopy))\\n\\n            for {} iszero(subscribe) {} {\\n                if iszero(subscriptionOrRegistrantToCopy) {\\n                    functionSelector := 0x4420e486 // `register(address)`.\\n                    break\\n                }\\n                functionSelector := 0xa0af2903 // `registerAndCopyEntries(address,address)`.\\n                break\\n            }\\n            // Store the function selector.\\n            mstore(0x00, shl(224, functionSelector))\\n            // Store the `address(this)`.\\n            mstore(0x04, address())\\n            // Store the `subscriptionOrRegistrantToCopy`.\\n            mstore(0x24, subscriptionOrRegistrantToCopy)\\n            // Register into the registry.\\n            if iszero(call(gas(), _OPERATOR_FILTER_REGISTRY, 0, 0x00, 0x44, 0x00, 0x04)) {\\n                // If the function selector has not been overwritten,\\n                // it is an out-of-gas error.\\n                if eq(shr(224, mload(0x00)), functionSelector) {\\n                    // To prevent gas under-estimation.\\n                    revert(0, 0)\\n                }\\n            }\\n            // Restore the part of the free memory pointer that was overwritten,\\n            // which is guaranteed to be zero, because of Solidity's memory size limits.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Modifier to guard a function and revert if the caller is a blocked operator.\\n    modifier onlyAllowedOperator(address from) virtual {\\n        if (from != msg.sender) {\\n            if (!_isPriorityOperator(msg.sender)) {\\n                if (_operatorFilteringEnabled()) _revertIfBlocked(msg.sender);\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier to guard a function from approving a blocked operator..\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        if (!_isPriorityOperator(operator)) {\\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Helper function that reverts if the `operator` is blocked by the registry.\\n    function _revertIfBlocked(address operator) private view {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Store the function selector of `isOperatorAllowed(address,address)`,\\n            // shifted left by 6 bytes, which is enough for 8tb of memory.\\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\\n            mstore(0x00, 0xc6171134001122334455)\\n            // Store the `address(this)`.\\n            mstore(0x1a, address())\\n            // Store the `operator`.\\n            mstore(0x3a, operator)\\n\\n            // `isOperatorAllowed` always returns true if it does not revert.\\n            if iszero(staticcall(gas(), _OPERATOR_FILTER_REGISTRY, 0x16, 0x44, 0x00, 0x00)) {\\n                // Bubble up the revert if the staticcall reverts.\\n                returndatacopy(0x00, 0x00, returndatasize())\\n                revert(0x00, returndatasize())\\n            }\\n\\n            // We'll skip checking if `from` is inside the blacklist.\\n            // Even though that can block transferring out of wrapper contracts,\\n            // we don't want tokens to be stuck.\\n\\n            // Restore the part of the free memory pointer that was overwritten,\\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /// @dev For deriving contracts to override, so that operator filtering\\n    /// can be turned on / off.\\n    /// Returns true by default.\\n    function _operatorFilteringEnabled() internal view virtual returns (bool) {\\n        return true;\\n    }\\n\\n    /// @dev For deriving contracts to override, so that preferred marketplaces can\\n    /// skip operator filtering, helping users save gas.\\n    /// Returns false for all inputs by default.\\n    function _isPriorityOperator(address) internal view virtual returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KH87/PixelPioneer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\n// Local References\\nimport './PixelPioneerBase.sol';\\nimport './PixelPioneerSplitsAndRoyalties.sol';\\n\\n// Error Codes\\nerror CallerIsNotOwner();\\n\\n/**\\n * @title PixelPioneer        .\\n *                            .+.\\n *             -:       .:    :+.\\n *    --      :=.       :+    -=                                         .     ..                     .:-:\\n *    .+.    --         :+    =-   .:.                                 :++-.  .++=: ..              :==:-++==:\\n *     =-  .=:          :=    +.  -=::.:.               -.        .==..+=-+=  =+:+-.=====:         -+:  =+:.-+.\\n *     =-:=-       :.   ==----+  :+   =+:.-+-   ..                 ++..++++:  =++=-+:   -+:      .++=--=++=-++.\\n *     -=--==-.    :.   +-::.=-  +- .=-+:=::+. -+=     .:-.        =+.  .+=   :+=.=+:   -+:       +=:::=+..-+:\\n *     --    .--       .+.  .+:  ==-=: -+:  ===:.======-::+-       =+.  :+:   =+:-+-   :+=       .+=  .+--+-.\\n *     .-              .+.  :+.   :.                      :+.      .-    .    .-=-.    =+.        :==-=+=:.\\n *                      +:  .+                            :-                           ..            ..\\n *\\n *                                                K. Haring 1987 \u2295\ufe00\\n *\\n *\\n * @dev                       Ascii art tribute to Keith Haring's distinctive signature\\n * @dev          Thanks to Herman Schechkin for https://github.com/hermanTenuki/ASCII-Generator.site\\n */\\ncontract PixelPioneer is PixelPioneerSplitsAndRoyalties, PixelPioneerBase, Ownable {\\n    // NFT License path subject to change, see getContractURI() for latest file.\\n    string private constant NFT_LICENSE_URL = 'https://www.haring.com/!/nft-ownership-license';\\n    address private constant METADATA_CONTRACT = 0xCD17e53ceA841FF9bE6cFc99d285DB754A6175F1; // PixelPioneerMetadata V1\\n\\n    constructor()\\n        ERC721('PixelPioneer', 'KH87')\\n        SafetyLatch(18253700) // Oct 1 2023\\n        PixelPioneerBase(NFT_LICENSE_URL)\\n        ChainNativeMetadataConsumer(METADATA_CONTRACT)\\n    {\\n        // Implementation version: v1.0.0\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {\\n        return ERC721.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * Fulfill isOwner() modifier implementation\\n     *\\n     * @dev see OwnableDeferred for more explanation on this.\\n     */\\n    modifier isOwner() override {\\n        _isOwner();\\n        _;\\n    }\\n\\n    /**\\n     * Fulfill _isOwner() implementation, backed by OZ Ownable.\\n     *\\n     * @dev see OwnableDeferred for more explanation on this.\\n     */\\n    function _isOwner() internal view override(NFTCSplitsAndRoyalties, OwnableDeferral) {\\n        // Same as _checkOwner() but using error code instead of a require statement.\\n        if (owner() != _msgSender()) revert CallerIsNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KH87/PixelPioneerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Prerelease Contracts\\nimport '@nftculture/nftc-contracts-private/contracts/business/SafetyLatch.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/metadata/v1/ChainNativeMetadataConsumer.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/token/v4/ERC721SolBase_NFTC.sol';\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\n// Error Codes\\nerror ExceedsBatchSize();\\nerror ExceedsPurchaseLimit();\\nerror ExceedsSupplyCap();\\nerror InvalidPayment();\\n\\n/**\\n * @title PixelPioneerBase\\n * @author @NiftyMike | @NFTCulture\\n * @dev ERC721 SolBase implementation with @NFTCulture standardized components.\\n *\\n * Tokens are minted in advance by the project team.\\n */\\nabstract contract PixelPioneerBase is ERC721SolBase_NFTC, ChainNativeMetadataConsumer, SafetyLatch {\\n    using Strings for uint256;\\n\\n    // Pixel Pioneer collection is limited to 5 tokens.\\n    uint16 private constant MAX_RESERVE_BATCH_SIZE = 5;\\n    uint16 private constant SUPPLY_CAP = 5;\\n\\n    constructor(string memory __baseURI) ERC721SolBase_NFTC(SUPPLY_CAP, __baseURI) {\\n        _registerForOperatorFiltering();\\n        operatorFilteringEnabled = true;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), 'No token');\\n\\n        uint256 tokenType = _getProducer().getTokenTypeForToken(tokenId);\\n        return _getProducer().getJsonAsEncodedString(tokenId, tokenType);\\n    }\\n\\n    /**\\n     * @notice Owner: advance mint tokens.\\n     *\\n     * @param destination address to send tokens to.\\n     * @param count the number of tokens to mint.\\n     */\\n    function advanceMintTokens(address destination, uint256 count) external isOwner {\\n        _advanceMintTokens(destination, count);\\n    }\\n\\n    function _advanceMintTokens(address destination, uint256 count) internal {\\n        if (0 >= count || count > MAX_RESERVE_BATCH_SIZE) revert ExceedsBatchSize();\\n\\n        uint256 currentTM = _totalMinted();\\n        if (currentTM + count > SUPPLY_CAP) revert ExceedsSupplyCap();\\n\\n        uint256 tokenId;\\n        for (tokenId = currentTM; tokenId < currentTM + count; tokenId++) {\\n            _internalMintTokens(destination, tokenId);\\n        }\\n    }\\n\\n    function _internalMintTokens(address minter, uint256 tokenId) internal {\\n        _safeMint(minter, tokenId);\\n    }\\n\\n    function _executeOnDestruct() internal override {\\n        uint256 idx;\\n\\n        for (idx; idx < _totalMinted(); idx++) {\\n            if (_exists(idx)) {\\n                _burn(idx);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Total number of tokens that currently exist.\\n     */\\n    function totalTokensExist() external view override returns (uint256) {\\n        return _totalSupply();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KH87/PixelPioneerSplitsAndRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Open Source Contracts See: https://github.com/NFTCulture/nftc-contracts\\nimport '@nftculture/nftc-contracts/contracts/financial/NFTCSplitsAndRoyalties.sol';\\n\\nabstract contract PixelPioneerSplitsAndRoyalties is NFTCSplitsAndRoyalties {\\n    address[] internal addresses = [0xB19C6659570b64DAd956b1A1b477764C9eF9546f];\\n\\n    uint256[] internal splits = [100];\\n\\n    uint96 private constant DEFAULT_ROYALTY_BASIS_POINTS = 1000;\\n\\n    constructor() NFTCSplitsAndRoyalties(addresses, splits, address(this), DEFAULT_ROYALTY_BASIS_POINTS) {\\n        // Nothing to do.\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestructExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestructRevoked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsBatchSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsSupplyCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongFrom\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"PayeeTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"advanceMintTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOwnedBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canDestruct\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destructContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFilteringEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"payee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subscription\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"subscribe\",\"type\":\"bool\"}],\"name\":\"registerForOperatorFiltering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseToSelf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"__baseURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"newRoyalty\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setOperatorFilteringEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__metadataProducer\",\"type\":\"address\"}],\"name\":\"setProducer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensExist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferPayee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PixelPioneer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}